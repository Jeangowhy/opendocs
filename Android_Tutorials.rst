#!/usr/bin/env bash

curl \
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-activities-intents?hl=zh-cn \
| sed -n '/devsite-page-title/,/Except as otherwise noted/p' \
| pandoc --column=90 -trst -rhtml >/dl/pl/out.rst ;

exit
| sed -n '/class="chapter"/,/feedback-container/p' \
| sed -n '/devsite-article/,/devsite-footer/p' \



ğŸŸ© Table of Contents
=====================


-  More Android

   -  `Android <https://www.android.com>`__
   -  `Android for Enterprise <https://www.android.com/enterprise/>`__
   -  `Security <https://www.android.com/security-center/>`__
   -  `Source <https://source.android.com>`__
   -  `News <https://developer.android.google.cn/news>`__
   -  `Blog <https://android-developers.googleblog.com/>`__
   -  `Podcasts <https://developer.android.google.cn/podcasts>`__

-  Discover

   -  `Gaming <https://developer.android.google.cn/games>`__
   -  `Machine Learning <https://developer.android.google.cn/ml>`__
   -  `Health & Fitness <https://developer.android.google.cn/health-and-fitness>`__
   -  `Camera & Media <https://developer.android.google.cn/media>`__
   -  `Privacy <https://developer.android.google.cn/privacy>`__
   -  `5G <https://developer.android.google.cn/training/connectivity/5g>`__

-  Android Devices

   -  `Large screens <https://developer.android.google.cn/large-screens>`__
   -  `Wear OS <https://developer.android.google.cn/wear>`__
   -  `ChromeOS devices <https://developer.android.google.cn/chrome-os>`__
   -  `Android for cars <https://developer.android.google.cn/cars>`__
   -  `Android TV <https://developer.android.google.cn/tv>`__

-  Releases

   -  `Android 14 <https://developer.android.google.cn/about/versions/14>`__
   -  `Android 13 <https://developer.android.google.cn/about/versions/13>`__
   -  `Android 12 <https://developer.android.google.cn/about/versions/12>`__
   -  `Android 11 <https://developer.android.google.cn/about/versions/11>`__
   -  `Android 10 <https://developer.android.google.cn/about/versions/10>`__
   -  `Pie <https://developer.android.google.cn/about/versions/pie>`__
   -  `Oreo <https://developer.android.google.cn/about/versions/oreo>`__
   -  `Nougat <https://developer.android.google.cn/about/versions/nougat>`__

-  Documentation and Downloads

   -  `Essentials <https://developer.android.google.cn/get-started>`__
   -  `Android Studio guide <https://developer.android.google.cn/studio/intro>`__
   -  `Developers guides <https://developer.android.google.cn/guide>`__
   -  `API reference <https://developer.android.google.cn/reference>`__
   -  `Download Studio <https://developer.android.google.cn/studio>`__
   -  `Android NDK <https://developer.android.google.cn/ndk>`__

-   Build AI experiences
-  `Get started <https://developer.android.google.cn/ai>`__
-   Get started
-  `Hello world <https://developer.android.google.cn/get-started/overview>`__
-  `Training courses <https://developer.android.google.cn/courses>`__
-  `Tutorials <https://developer.android.google.cn/get-started/codelabs>`__
-  `Kotlin for Android <https://developer.android.google.cn/kotlin>`__
-  `Monetization with Play â†—ï¸ <https://play.google.com/console/about/guides/monetize/>`__
-   Extend by device
-  `Large screens (e.g., tablets) <https://developer.android.google.cn/large-screens>`__
-  `Wear OS <https://developer.android.google.cn/wear>`__
-  `Android for Cars <https://developer.android.google.cn/cars>`__
-  `Android TV <https://developer.android.google.cn/tv>`__
-  `ChromeOS <https://developer.android.google.cn/chrome-os>`__
-  `Cross-device SDK <https://developer.android.google.cn/multi-device-development>`__
-   Build by category
-  `Generative AI <https://developer.android.google.cn/ai>`__
-  `Games <https://developer.android.google.cn/games>`__
-  `Camera & Media <https://developer.android.google.cn/media>`__
-  `Social & messaging <https://developer.android.google.cn/social-and-messaging>`__
-  `Health & Fitness <https://developer.android.google.cn/health-and-fitness>`__
-  `Enterprise apps <https://developer.android.google.cn/work/overview>`__
-   Get the latest
-  `Platform releases <https://developer.android.google.cn/about/versions>`__
-  `Android Studio preview <https://developer.android.google.cn/studio/preview>`__
-  `Jetpack & Compose libraries <https://developer.android.google.cn/jetpack/androidx/versions>`__
-  `Wear OS preview <https://developer.android.google.cn/training/wearables/versions/4>`__
-  `Privacy Sandbox <https://developer.android.google.cn/design-for-safety/privacy-sandbox>`__

-   Kits & more
-  `Go to Android & Material kits <https://developer.android.google.cn/design/ui/mobile#explore-our-kits>`__
-  `Go to Wear OS kits <https://developer.android.google.cn/design/ui/wear#explore-our-kits>`__
-   UI Design
-  `Design for Android <https://developer.android.google.cn/design/ui>`__
-  `Mobile <https://developer.android.google.cn/design/ui/mobile>`__
-  `Large screens (e.g., tablets) <https://developer.android.google.cn/design/ui/large-screens>`__
-  `Widgets <https://developer.android.google.cn/design/ui/widget>`__
-  `Wear OS <https://developer.android.google.cn/design/ui/wear>`__
-  `Android TV <https://developer.android.google.cn/design/ui/tv>`__
-   Architecture
-  `Introduction <https://developer.android.google.cn/topic/architecture/intro>`__
-  `Libraries <https://developer.android.google.cn/topic/libraries/view-binding>`__
-  `Navigation <https://developer.android.google.cn/guide/navigation/navigation-principles>`__
-  `Modularization <https://developer.android.google.cn/topic/modularization>`__
-  `Testing <https://developer.android.google.cn/training/testing/fundamentals>`__
-   Quality
-  `Overview <https://developer.android.google.cn/quality>`__
-  `Core value <https://developer.android.google.cn/quality/core-value>`__
-  `User experience <https://developer.android.google.cn/quality/user-experience>`__
-  `Technical quality <https://developer.android.google.cn/quality/technical>`__
-  `Privacy & security <https://developer.android.google.cn/quality/privacy-and-security>`__
-   Build for Billions
-  `Overview <https://developer.android.google.cn/build-for-billions>`__
-  `About new markets <https://developer.android.google.cn/docs/quality-guidelines/build-for-billions>`__
-  `Android (Go edition) <https://developer.android.google.cn/guide/topics/androidgo>`__

-   Gemini in Android Studio
-  `Learn more <https://developer.android.google.cn/gemini-in-android>`__
-  `Get Android Studio <https://developer.android.google.cn/studio>`__
-   Core areas
-  `Samples <https://developer.android.google.cn/samples>`__
-  `Try Quick Guidesáµ‡áµ‰áµ—áµƒ <https://developer.android.google.cn/quick-guides>`__
-  `User interfaces <https://developer.android.google.cn/develop/ui>`__
-  `Permissions <https://developer.android.google.cn/guide/topics/permissions/overview>`__
-  `Background work <https://developer.android.google.cn/develop/background-work>`__
-  `Data and files <https://developer.android.google.cn/guide/topics/data>`__
-  `Identity <https://developer.android.google.cn/identity>`__
-  `All core areas â¤µï¸ <https://developer.android.google.cn/develop#core-areas>`__
-   Tools and workflow
-  `Write and debug code <https://developer.android.google.cn/studio/write>`__
-  `Build projects <https://developer.android.google.cn/build>`__
-  `Test your app <https://developer.android.google.cn/training/testing>`__
-  `Performance <https://developer.android.google.cn/topic/performance/overview>`__
-  `Command-line tools <https://developer.android.google.cn/tools>`__
-  `Gradle plugin API <https://developer.android.google.cn/reference/tools/gradle-api>`__
-   Device tech
-  `Large screens (e.g., tablets) <https://developer.android.google.cn/guide/topics/large-screens/get-started-with-large-screens>`__
-  `Wear OS <https://developer.android.google.cn/training/wearables>`__
-  `Android Health <https://developer.android.google.cn/health-and-fitness/guides>`__
-  `Cross-device SDK <https://developer.android.google.cn/guide/topics/connectivity/cross-device-sdk/overview>`__
-  `Android for Cars <https://developer.android.google.cn/training/cars>`__
-  `Android TV <https://developer.android.google.cn/training/tv>`__
-  `ChromeOS <https://developer.android.google.cn/chrome-os/intro>`__
-   Libraries
-  `Android platform <https://developer.android.google.cn/reference/packages>`__
-  `Jetpack libraries <https://developer.android.google.cn/jetpack/androidx/explorer>`__
-  `Compose libraries <https://developer.android.google.cn/jetpack/androidx/releases/compose>`__
-  `Google Play services â†—ï¸ <https://developers.google.com/android/reference/packages>`__
-  `Google Play SDK index â†—ï¸ <https://play.google.com/sdks>`__


ğŸŸ© TOC - Training courses
==========================

   *  Training courses https://developer.android.google.cn/courses
   *  Google Developers Codelabs https://codelabs.developers.google.cn

For beginners
-------------------------------------------------------------------------------

   Start here for a high-level overview of how to build apps using the latest 
   Modern Android Development practices.

   Android Basics with Compose
   https://developer.android.google.cn/courses/android-basics-compose/course

   This is the recommended course to start learning Android! Build a series of 
   apps using Jetpack Compose, the modern toolkit for creating beautiful user 
   interfaces on Android. You will write these apps in the Kotlin programming 
   language and learn best practices in Material Design, app architecture, 
   data storage, fetching data from the network, testing, and more. 

   â­ No programming experience required.

   â­ Training level: Beginner


For experienced Android developers
-------------------------------------------------------------------------------

   Dive deeper into more advanced topics in Modern Android Development. 
   These resources assume that you have existing knowledge of how to build Android apps.

   *  Jetpack Compose for Android developers
      https://developer.android.google.cn/courses/jetpack-compose/course

      Get started with Jetpack Compose, a modern toolkit for building Android UI.

      â­ Training level: Intermediate

   *  Modern Android app architecture
      https://developer.android.google.cn/courses/pathways/android-architecture

      Learn about best practices and recommended architecture for building robust, production-quality apps.

      â­ Training level: Intermediate

   *  Accessibility
      https://developer.android.google.cn/courses/pathways/make-your-android-app-accessible

      Learn to make your Android apps usable by everyone, including people with accessibility needs.

      â­ Training level: Intermediate

   *  Kotlin coroutines
      https://developer.android.google.cn/courses/pathways/android-coroutines

      Use coroutines to simplify task management for commons use cases like making network calls and accessing local data.

      â­ Training level: Intermediate


Kotlin language training
-------------------------------------------------------------------------------

   For developers interested in learning Kotlin.

   *  Kotlin bootcamp for programmers
      https://developer.android.google.cn/courses/kotlin-bootcamp/overview

      In the Kotlin Bootcamp for Programmers course, youâ€™ll learn the basics of 
      Kotlin as you create programs in IntelliJ IDEA. This course is designed 
      for programmers who know an object-oriented language such as Java or C++.

      â­ Training level: Intermediate

   In the Kotlin Bootcamp for Programmers course, you learn the basics of Kotlin as you
   create various small programs in IntelliJ IDEA.

   The course materials include course codelabs with suggested homework assignments.

   You'll get the most value out of this course if you work through the lessons in
   sequence, but it's not a requirement. Depending on your knowledge, you may be able to
   skim some sections.

   Prerequisites


      This course is geared towards programmers who know an object-oriented language such as
      Java or C++. If you're familiar with C#, some of the features of Kotlin will be
      familiar.

   What does the course cover?


      *  Lesson 1: Get started


         In Lesson 1, you learn how to work with the Kotlin REPL (Read-Eval-Print Loop)
         interactive shell, and you practice using the basic syntax of Kotlin code.

         `Start Lesson 1 <https://codelabs.developers.google.com/codelabs/kotlin-bootcamp-introduction/#0>`__

      *  Lesson 2: Kotlin basics


         In Lesson 2, you learn how to use Kotlin data types, operators, and variables, and how
         to work with booleans and conditions. You explore the difference between nullable and
         non-nullable variables, and you practice using arrays, lists, and loops in Kotlin.

         `Start Lesson 2 <https://codelabs.developers.google.com/codelabs/kotlin-bootcamp-basics/#0>`__

      *  Lesson 3: Functions


         In Lesson 3, you learn how to create a program with a ``main()`` function and arguments
         in IntelliJ IDEA. You create small programs as you learn about default values, compact
         functions, list filters, basic lambdas, and higher-order functions.

         `Start Lesson 3 <https://codelabs.developers.google.com/codelabs/kotlin-bootcamp-functions/#0>`__

      *  Lesson 4: Classes and objects


         In Lesson 4, you learn about classes, objects, and inheritance in Kotlin. You create
         small programs as you learn about abstract classes, interfaces, and interface
         delegation.

         `Start Lesson 4 <https://codelabs.developers.google.com/codelabs/kotlin-bootcamp-classes/#0>`__

      *  Lesson 5.1: Extensions


         In Lesson 5.1, you learn about collections, constants, and extension functions in
         Kotlin. You create small programs as you learn about pairs, triples, lists, and hash
         maps for storing data, and implement extension functions to add functionality to
         existing classes.

         `Start Lesson 5.1 <https://codelabs.developers.google.com/codelabs/kotlin-bootcamp-extensions/#0>`__

      *  Lesson 5.2: Generics


         In Lesson 5.2, you learn about generic classes, methods, and functions in Kotlin. You
         create a type hierarchy, make classes more flexible by making them generic, and extend
         their functionality with generic methods and functions.

         `Start Lesson 5.2 <https://codelabs.developers.google.com/codelabs/kotlin-bootcamp-generics/#0>`__

      *  Lesson 6: Functional manipulation


         In Lesson 6, you learn about annotations, labeled breaks, and Single Abstract Methods
         (SAMs). You also review lambdas and higher-order functions. You then create and use
         lambdas and higher-order functions, and learn about higher-order functions in the
         Kotlin Standard Library.

         `Start Lesson 6 <https://codelabs.developers.google.com/codelabs/kotlin-bootcamp-sams/#0>`__


   *  Kotlin for Java developers
      https://developer.android.google.cn/courses/pathways/kotlin-for-java

      Incorporate and convert Java code into Kotlin using Android Studio, and learn 
      Kotlin language conventions along the way. Youâ€™ll also learn how to write Kotlin 
      code to make it callable from Java code.

      â­ Training level: Intermediate

      *  Converting to Kotlin
         `Take codelab <https://developer.android.google.cn/codelabs/java-to-kotlin>`__

         Learn Kotlin language conventions as you convert Java code to Kotlin

      *  Add Kotlin to an existing app
         `Read article <https://developer.android.google.cn/kotlin/add-kotlin>`__

         Add Kotlin files to your existing project and convert Java language code to Kotlin

      *  Java-friendly Kotlin
         `Take codelab <https://developer.android.google.cn/codelabs/java-friendly-kotlin>`__

         Write or adapt your Kotlin code to make it callable from Java code

      *  Kotlin-Java interop guide
         `Read article <https://developer.android.google.cn/kotlin/interop>`__

         A set of rules for authoring public APIs in Java and Kotlin



For Android Java developers
-------------------------------------------------------------------------------

   Refer here for Android training content for Java developers.

   *  Android Room with a View - Java
      https://developer.android.google.cn/codelabs/android-room-with-a-view

      Design and construct an app using Architecture Components, including ``Room``, 
      ``ViewModel``, and ``LiveData``.

      â­ Training level: Intermediate


   *  Background work with WorkManager - Java
      https://developer.android.google.cn/codelabs/android-workmanager-java

      Learn how to use WorkManager, a compatible, flexible and simple library for 
      deferrable background work in your app.

      â­ Training level: Intermediate


Certification and degree programs
-------------------------------------------------------------------------------

   Showcase your skills with a Google-certified credential.

   *  Associate Android Developer Certification
      https://developers.google.cn/certification/associate-android-developer

      This certification is being updated. New registrations for the exam are currently closed, 
      until the update is complete.

      â­ Training level: Intermediate


   *  Google Play Store Listing Certificate
      https://play.google.com/academy/certificate/

      The Google Play Store List Certificate proves foundational knowledge of 
      digital mobile marketing best practices for those building store listings in 
      Google Play Console.

      â­ Training level: Intermediate


   *  Android Kotlin Developer Nanodegree
      https://www.udacity.com/course/android-kotlin-developer-nanodegree--nd940

      Master Android development with Kotlin in this paid Udacity Nanodegree, 
      offering hands-on projects, mentor support, and career services.

      â­ Training level: Intermediate


ğŸŸ© TOC - Android codelabs
==========================

Codelabs provide a guided, tutorial, hands-on coding experience. Most codelabs 
will step you through the process of building a small application, or adding a 
new feature to an existing application.

Compose
-------

* [ğŸš€] Basic layouts in Compose
   https://developer.android.google.cn/codelabs/jetpack-compose-layouts?hl=en
   In this codelab, youâ€™ll learn how to implement real-world 
   designs with the composables and modifiers that Compose provides out 
   of the box.

* [ğŸš€] Add adaptive layouts to a view-based Android app with Compose
   https://developer.android.google.cn/codelabs/add-adaptive-layouts?hl=en
   Learn how to add adaptive layouts to a view-based Android app 
   with Jetpack Compose.

* [ğŸš€] Navigate between screens with Compose
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-navigation?hl=en
   Add the Navigation component to the Cupcake app to organize the 
   flow of the app, navigate and pass data between different 
   screens.

* [ğŸš€] Simple Animation with Jetpack Compose
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-woof-animation?hl=en
   Learn how to add a simple spring animation to your Compose app.

* [ğŸš€] Compose for Wear OS Codelab
   https://developer.android.google.cn/codelabs/compose-for-wear-os?hl=en
   In this codelab, youâ€™ll learn how to translate your Compose 
   knowledge to wearables with the new Compose for Wear OS. By the end, 
   youâ€™ll have created both simple and advanced composables in an 
   app for your wrist.

* [ğŸš€] Add Compose to a View-based app
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app?hl=en
   In this codelab, you learn how to migrate parts of a screen in 
   the View system to Jetpack Compose.

* [ğŸš€] Drag and Drop in Compose
   https://developer.android.google.cn/codelabs/codelab-dnd-compose?hl=en
   Learn to enable drag and drop in compose using modifiers.

* [ğŸš€] Intro to state in Compose
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-using-state?hl=en
   Learn about state, and how it can be used and manipulated by 
   Jetpack Compose.

* [ğŸš€] Material Theming with Jetpack Compose
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-material-theming?hl=en
   Learn how to add Material Theming to an app, including color, 
   shape, and typography.

* [ğŸš€] Migrating to Jetpack Compose
   https://developer.android.google.cn/codelabs/jetpack-compose-migration?hl=en
   In this codelab, youâ€™ll learn how to migrate parts of your appâ€™
   s screen in the View system to Jetpack Compose.

* [ğŸš€] Practice: Compose Basics
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-composables-practice-problems?hl=en
   Apply the concepts of basic UI composables to implement screens 
   for the given problems.

* [ğŸš€] Accessibility in Jetpack Compose
   https://developer.android.google.cn/codelabs/jetpack-compose-accessibility?hl=en
   In this codelab, youâ€™ll learn how to make your Compose app more 
   accessible. See how to increase touch targets, add content 
   descriptions, click labels, custom actions, and more.

* [ğŸš€] Jetpack Compose Navigation
   https://developer.android.google.cn/codelabs/jetpack-compose-navigation?hl=en
   In this codelab, youâ€™ll learn all about the basics of 
   Navigation in Compose.

* [ğŸš€] Jetpack Compose basics
   https://developer.android.google.cn/codelabs/jetpack-compose-basics?hl=en
   In this codelab, youâ€™ll learn the basics of Compose.

* [ğŸš€] State in Jetpack Compose
   https://developer.android.google.cn/codelabs/jetpack-compose-state?hl=en
   In this codelab youâ€™ll learn about how to build rich, 
   interactive, Compose applications by managing state.

* [ğŸš€] Animating elements in Jetpack Compose
   https://developer.android.google.cn/codelabs/jetpack-compose-animation?hl=en
   In this codelab, youâ€™ll learn how to use some Compose Animation APIs.

* [ğŸš€] Testing in Jetpack Compose
   https://developer.android.google.cn/codelabs/jetpack-compose-testing?hl=en
   In this codelab youâ€™ll learn about testing UIs created with 
   Jetpack Compose. You will write your first tests while learning 
   about testing in isolation, debugging tests, semantics trees and 
   synchronization.

* [ğŸš€] Jetpack Compose theming
   https://developer.android.google.cn/codelabs/jetpack-compose-theming-m2?hl=en
   In this codelab, youâ€™ll learn how to create a theme for your 
   app, style individual components and support light/dark themes.

* [ğŸš€] ViewModel and State in Compose
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-viewmodel-and-state?hl=en
   In this codelab, you learn how to use a ViewModel, one of the 
   architecture components. You will implement a ViewModel to retain 
   the app state during configuration changes.


Others
------

* [ğŸš€] Build a simple app with text composables
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-text-composables?hl=en
   Learn how to build a simple app with composable functions.

* [ğŸš€] Write unit tests for ViewModel
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-viewmodel?hl=en
   Learn how to test the ViewModel to verify the correctness, 
   functional behavior, and usability of your app.

* [ğŸš€] Add images to your Android app
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-images?hl=en
   Learn how to build a simple app with composable functions.

* [ğŸš€] Background Work with WorkManager
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-workmanager?hl=en
   The WorkManager API for Android makes working in the background 
   simple. WorkManager can create tasks that are queryable, 
   reusable, and chainable. WorkManager is the recommended task scheduler 
   on Android. This codelab will teach you the ins and outs of 
   WorkManager: everything from writing a simple job to more complex 
   chained jobs.

* [ğŸš€] Use SQL to read and write to a database
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-sql?hl=en
   Learn the core concepts of relational databases and learn to 
   read and manipulate a database using SQL.

* [ğŸš€] Your First Health Connect Integrated App
   https://developer.android.google.cn/codelabs/health-connect?hl=en
   In this Codelab, youâ€™ll build a health and fitness app that 
   supports reading and writing to Health Connect.

* [ğŸš€] Build an adaptive app with dynamic navigation
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens?hl=en
   Learn how to adapt your app for large screens with adaptive 
   navigation ui patterns.

* [ğŸš€] Add keyboard, mouse, trackpad, and stylus support with Jetpack Compose
   https://developer.android.google.cn/codelabs/large-screens/add-keyboard-and-mouse-support-with-compose?hl=en
   Learn how to develop your apps to support keyboard and pointing 
   devices, such as mouse and trackpad, with Compose.

* [ğŸš€] Build a list-detail layout with activity embedding and Material Design
   https://developer.android.google.cn/codelabs/large-screens/activity-embedding?hl=en
   Activity embedding enables activity-based apps to support two-
   pane layouts on large screens with no code refactoring. You add 
   some dependencies, create an XML configuration file, implement an 
   initializer, and make a few additions to the app manifest. Or, if 
   you prefer working in code, you can make a few Jetpack API calls 
   from the onCreate() method of the main activity. In this codelab, 
   you will use both the XML and API development approaches to 
   update an activity-based app to a list-detail, two-pane layout.

* [ğŸš€] Starting Android Accessibility
   https://developer.android.google.cn/codelabs/starting-android-accessibility?hl=en
   In this codelab, youâ€™ll learn the fundamentals of Android 
   Accessibility. Youâ€™ll work through exercises to learn how to use the 
   Android platform to build apps that can be used more easily by a 
   wider set of people with different accessibility needs.

* [ğŸš€] Add predictive back animations
   https://developer.android.google.cn/codelabs/predictive-back?hl=en
   In this codelab, you learn how to add predictive back 
   animations to the SociaLite app.

* [ğŸš€] Introduction to Coroutines in Android Studio
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-coroutines-android-studio?hl=en
   Learn to use Kotlin coroutines inside an Android app and how to 
   test coroutines.

* [ğŸš€] Persist data with Room
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-persisting-data-room?hl=en
   Learn how to use Room in your Android Kotlin apps. Room is a 
   persistence database library thatâ€™s part of Android Jetpack. Room 
   is an abstraction layer over SQLite. Room provides convenient APIs 
   to set up, configure, and query the database.

* [ğŸš€] Read and update data with Room
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-update-data-room?hl=en
   Learn how to use Room to read and update data in your Android 
   Kotlin apps. Room is a database library thatâ€™s part of Android 
   Jetpack. Room takes care of many of the chores of setting up and 
   configuring a database, and makes it possible for your app to 
   interact with the database using ordinary function calls.

* [ğŸš€] Create your first Tile in Wear OS
   https://developer.android.google.cn/codelabs/wear-tiles?hl=en
   In this codelab, youâ€™ll learn how to create your own Tile for 
   Wear OS. Youâ€™ll use Tiles Material Components, a library that 
   makes it easier to build UI that conforms to Material design 
   guidelines, and preview your tiles in Android Studio as you develop.

* [ğŸš€] Codelab for Drag and Drop
   https://developer.android.google.cn/codelabs/codelab-dnd-views?hl=en
   Learn to enable drag and drop for your views along with use of 
   DragHelper and DropHelper both within the app and across the app.

* [ğŸš€] Get data from the internet
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-getting-data-internet?hl=en
   Learn how to use community-developed libraries to connect to a 
   web service to retrieve and display data in your Android Kotlin 
   compose app. Also learn how to handle potential network errors.

* [ğŸš€] Add repository and Manual DI
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-repository?hl=en
   Learn how to further improve the architecture of the Mars 
   Photos app by separating the network calls into a repository.

* [ğŸš€] Test the Cupcake App
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-cupcake?hl=en
   Learn how to test the Navigation component and maximize the 
   amount of code that is tested.

* [ğŸš€] Testing for Accessibility
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-accessibility?hl=en
   Learn how to test an app for accessibility.

* [ğŸš€] Add a scrollable list
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-training-add-scrollable-list?hl=en
   Build an app that displays a scrollable list of affirmations 
   with text and images.

* [ğŸš€] Change the app icon
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-training-change-app-icon?hl=en
   Change the app icon for the Affirmations app.

* [ğŸš€] Create an Art Space app
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-art-space?hl=en
   Learn how to create an Android app that showcases your own art 
   space.

* [ğŸš€] Build an app with an adaptive layout
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens?hl=en
   Learn how to adapt your app for large screens by implementing 
   one of the canonical layout patterns.

* [ğŸš€] Create a widget with Glance
   https://developer.android.google.cn/codelabs/glance?hl=en
   In this codelab, you learn how to add Glance widgets to the 
   SociaLite app.

* [ğŸš€] Optimize your camera app on foldable devices with Jetpack WindowManager
   https://developer.android.google.cn/codelabs/android-camera-foldables?hl=en
   Over the years, Android devices have evolved to include a 
   variety of sizes, shapes, and displays, among other features. Since 
   the beginning, however, taking pictures with your phone has been 
   one of the most important use cases. Today, camera capabilities are 
   still one of the top reasons consumers purchase a phone.

* [ğŸš€] Stages of the Activity lifecycle
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-activity-lifecycle?hl=en
   In this codelab, you learn about the activity lifecycle and 
   logging.

* [ğŸš€] Run your first app on the Android Emulator
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-emulator?hl=en
   Learn how to run an app on the Android Emulator.

* [ğŸš€] Use the debugger in Android Studio
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-intro-debugger?hl=en
   Learn how to use the debugger in Android Studio to inspect and 
   debug the state of your app at runtime.

* [ğŸš€] Create an interactive Dice Roller app
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app?hl=en
   Learn how to build an interactive Dice Roller app that lets 
   users roll a dice and then shows them the result.

* [ğŸš€] Create an accessible and personalized theme and brand with Material Design 3
   https://developer.android.google.cn/codelabs/m3-design-theming?hl=en
   Learn how to create a theme and brand thatâ€™s accessible and 
   personalized with Material 3.

* [ğŸš€] Create your first Android app
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-first-app?hl=en
   Learn how to create your first Android app.

* [ğŸš€] Design an Adaptive Layout with Material Design
   https://developer.android.google.cn/codelabs/adaptive-material-guidance?hl=en
   Learn how to use adaptive design principles in Material Design 
   to achieve consistency across screen sizes. In this codelab, you 
   take a mobile design to tablet format, and learn about the 
   responsive grid, adaptive composition patterns, and the correct 
   components.

* [ğŸš€] Getting started with Vulkan on Android
   https://developer.android.google.cn/codelabs/beginning-vulkan-on-android?hl=en
   Vulkan is a high performance, modern graphic API. It provides 
   low level accessibility to the GPU and optimizes implementation in 
   various ways, but it is difficult to use. The alternative, 
   OpenGL ES, was simpler but has less features and performance as it is 
   based on legacy hardware architecture. OpenGL ES has been 
   deprecated on most other platforms and is no longer in active 
   development. On Android, we are planning to deprecate OpenGL ES and move to 
   Vulkan and need to prepare developers for the transition.

* [ğŸš€] Learn advanced coroutines with Kotlin Flow and LiveData
   https://developer.android.google.cn/codelabs/advanced-kotlin-coroutines?hl=en
   In this codelab, youâ€™ll build a coroutine-based Android app 
   that uses Architecture Components to fetch data from the network and 
   a Room database.

* [ğŸš€] Create and use variables in Kotlin
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-variables?hl=en
   Learn why variables are useful in programming, as well as how 
   to define and update variables in your Kotlin code.

* [ğŸš€] Use nullability in Kotlin
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-nullability?hl=en
   Learn how to use nullability in Kotlin.

* [ğŸš€] Create and use functions in Kotlin
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-functions?hl=en
   Learn about functions in Kotlin

* [ğŸš€] Integrating Adaptability features into your Native Game
   https://developer.android.google.cn/codelabs/adaptability-codelab?hl=en
   In this codelab, youâ€™ll start with a simple 3D physics 
   simulation game and integrate Adaptability features to it. You will 
   integrate:

* [ğŸš€] Load and display images from the internet
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-load-images?hl=en
   In this codelab, you use the Coil library to load and display 
   photos from the internet in your Android Compose app.

* [ğŸš€] Introduction to Coroutines in Kotlin Playground
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-coroutines-kotlin-playground?hl=en
   Within Kotlin Playground, learn to use Kotlin coroutines to 
   write asynchronous code.

* [ğŸš€] Download and install Android Studio
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-install-android-studio?hl=en
   Learn how to download and install Android Studio

* [ğŸš€] How to connect your Android device
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-connect-device?hl=en
   Learn how to connect your app

* [ğŸš€] Engage Wear OS users in new ways with the Ongoing Activity API
   https://developer.android.google.cn/codelabs/ongoing-activity?hl=en
   With the Ongoing Activity API in Wear, developers can engage 
   users from the watch face as well as the app launcher with minimal 
   amount of code and allow those users to jump back into the app 
   for important activities with a simple tap.

* [ğŸš€] Working with Preferences DataStore
   https://developer.android.google.cn/codelabs/android-preferences-datastore?hl=en
   In this codelab, youâ€™ll modify a sample app to incorporate 
   Jetpack Preferences DataStore, a new and improved data store solution 
   and replacement for SharedPreferences.

* [ğŸš€] Calculate a custom tip
   https://developer.android.google.cn/codelabs/basic-android-compose-calculate-tip?hl=en
   Learn how to add an action button, set up keyboard actions, and 
   use a Switch composable.

* [ğŸš€] Building a Data Layer
   https://developer.android.google.cn/codelabs/building-a-data-layer?hl=en
   In this codelab, you learn about the data layer in Android app 
   architecture. You build repositories, data models, and data 
   sources to read and write data to a local database and a network 
   service.

* [ğŸš€] Tweakr: Wizard of Oz Prototyping and Remote Control with Firebase + Android
   https://developer.android.google.cn/codelabs/tweakr-firebase?hl=en
   Calling all prototypers and motion designers! Are you sick of 
   tweaking one value in your animation and having to wait minutes to 
   compile and see your change? Ever want to hand someone a 
   prototype, and let them try it with various options you can adjust on 
   the fly? Do you get tingles when someone mentions â€œone-line solutionâ€?

* [ğŸš€] Getting Started with CameraX
   https://developer.android.google.cn/codelabs/camerax-getting-started?hl=en
   This codelab introduces how to create a camera app that uses 
   CameraX to show a viewfinder, take photos and analyze an image 
   stream from the camera.

* [ğŸš€] Android Paging Advanced codelab
   https://developer.android.google.cn/codelabs/android-paging?hl=en
   In this codelab, you modify a sample app to incorporate the 
   Paging Library, which reduces the appâ€™s memory footprint.

* [ğŸš€] Theming in Compose with Material 3
   https://developer.android.google.cn/codelabs/jetpack-compose-theming?hl=en
   The purpose of this codelab is to demonstrate theming in 
   Jetpack Compose with new Material Design 3 and Material You 
   implementation.

* [ğŸš€] Migrating your Dagger app to Hilt
   https://developer.android.google.cn/codelabs/android-dagger-to-hilt?hl=en
   In this codelab, youâ€™ll migrate an Android app that uses Dagger 
   as the Dependency Injection library to Hilt.

* [ğŸš€] Advanced State and Side Effects in Jetpack Compose
   https://developer.android.google.cn/codelabs/jetpack-compose-advanced-state-side-effects?hl=en
   In this codelab, youâ€™ll learn advanced concepts of state and 
   side effects in Jetpack Compose. See how to create a state holder 
   for complex stateful composables, how to create coroutines and 
   call suspend functions from Compose code, and how to trigger side 
   effects to accomplish different use cases.

* [ğŸš€] Use classes and objects in Kotlin
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-classes-and-objects?hl=en
   Learn how to use classes and objects in Kotlin.

* [ğŸš€] Using Play Asset Delivery in Unity games
   https://developer.android.google.cn/codelabs/unity-gamepad?hl=en
   In this codelab, modify a sample Unity project to take 
   advantage of Play Asset Delivery for on-demand asset downloading from 
   Google Play.

* [ğŸš€] Integrating Android Performance Tuner into your Unity game
   https://developer.android.google.cn/codelabs/android-performance-tuner-unity?hl=en
   In this codelab, youâ€™ll add Android Performance Tuner to a 
   Unity game, allowing you to get performance measures reported in the 
   Google Play Console when people play your game.

* [ğŸš€] Android Paging Basics
   https://developer.android.google.cn/codelabs/android-paging-basics?hl=en
   In this codelab, you integrate the Paging library into an app 
   that shows a list. The Paging library helps you load and display 
   pages of data from a larger dataset from local storage or over 
   network.

* [ğŸš€] Practice: Kotlin Fundamentals
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-kotlin-fundamentals-practice-problems?hl=en
   Apply the basic concepts of the Kotlin programming language to 
   solve the given problems.

* [ğŸš€] Support foldable and dual-screen devices with Jetpack WindowManager
   https://developer.android.google.cn/codelabs/android-window-manager-dual-screen-foldables?hl=en
   Learn to adapt your app to new form factors, like foldable and 
   dual-screen devices, with the Jetpack WindowManager library.

* [ğŸš€] Activity Recognition Transition API Codelab
   https://developer.android.google.cn/codelabs/activity-recognition-transition?hl=en
   Learn how to use Activity Recognition Transition Api to build 
   powerful contextual features in your app

* [ğŸš€] Calculate a custom tip
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-calculate-tip?hl=en
   Learn how to add an action button, set up keyboard actions, and 
   use a Switch composable.

* [ğŸš€] Your first program in Kotlin
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-first-program?hl=en
   Learn how to create and modify simple programs in Kotlin.

* [ğŸš€] Build an app that runs on a work profile
   https://developer.android.google.cn/codelabs/work-profile-apps?hl=en
   In this codelab, youâ€™ll be making changes to an app to provide 
   a better user experience when run on a managed device with a work 
   profile.

* [ğŸš€] Android Network Security Configuration Codelab
   https://developer.android.google.cn/codelabs/android-network-security-config?hl=en
   In this codelab, youâ€™ll explore the Network Security 
   Configuration on Android and encounter some common pitfalls around 
   establishing secure network communications.

* [ğŸš€] Media streaming with ExoPlayer
   https://developer.android.google.cn/codelabs/exoplayer-intro?hl=en
   In this codelab, you build a media player to render audio and 
   adaptive video streams with ExoPlayer, the open source media 
   player running in the Android YouTube app. The codelab uses and 
   customizes the UI components included with the library and demonstrates 
   how to instantiate, set up, reuse, and properly integrate an 
   ExoPlayer instance in the activity lifecycle.

* [ğŸš€] Using Dagger in your Android app - Kotlin
   https://developer.android.google.cn/codelabs/android-dagger?hl=en
   In this codelab, youâ€™ll build an Android app that uses Dagger 
   to do Dependency Injection.

* [ğŸš€] Direct Share to an Android app
   https://developer.android.google.cn/codelabs/android-direct-share?hl=en
   Direct Share makes sharing content quicker and easier. In this 
   codelab, youâ€™ll build an app that is able to display a list of 
   contacts in the system Intent chooser dialog so you can jump 
   directly into the app to make the sharing process seamless.

* [ğŸš€] Background Work with WorkManager - Java
   https://developer.android.google.cn/codelabs/android-workmanager-java?hl=en
   Android has many choices for guaranteed background work, which 
   have various pros and cons. The WorkManager library for Android 
   makes working in the background simple. WorkManager deals with 
   edge cases and compatibility issues. It also can create tasks that 
   are query-able, reusable and chain-able. WorkManager is the 
   recommended task scheduler on Android. This codelab will teach you the 
   ins-and-outs of WorkManager: everything from writing a simple job 
   to more complex chained jobs with constraints.

* [ğŸš€] Kotlin Bootcamp for programmers: Welcome to the course
   https://developer.android.google.cn/codelabs/kotlin-bootcamp-welcome?hl=en
   Welcome to the Kotlin bootcamp for programmers training course.

* [ğŸš€] Higher-order functions with collections
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-higher-order-functions?hl=en
   Learn how to use common higher-order functions with collections 
   in Kotlin

* [ğŸš€] Use Kotlin Coroutines in your Android App
   https://developer.android.google.cn/codelabs/kotlin-coroutines?hl=en
   In this codelab, youâ€™ll build a coroutine-based Android app 
   that uses Architecture Components to fetch data from the network and 
   a Room database.

* [ğŸš€] Support resizable surfaces in your camera app
   https://developer.android.google.cn/codelabs/android-camera2-preview?hl=en
   With the advent of Android 12L and the availability of new form 
   factors (such as foldable devices) and display modes such as 
   multi-window and multi-display, many assumptions regarding the 
   relationship between the camera output and the surface have been 
   challenged.

* [ğŸš€] Improve Engagement on Watch Next for Movie/TV Episodes on Android TV
   https://developer.android.google.cn/codelabs/watchnext-for-movie-tv-episodes?hl=en
   In this codelab, youâ€™ll learn best practices for building Watch 
   Next for TV movies/episodes.

* [ğŸš€] Android Privacy Codelab
   https://developer.android.google.cn/codelabs/android-privacy-codelab?hl=en
   Android has released many individual privacy features over the 
   past few releases, and we are excited for you to adopt them in 
   your apps! This codelab will seek to tie individual privacy 
   features together and show the developer how they can learn about their 
   appâ€™s access to private user data and adopt privacy best 
   practices in an existing, running app.

* [ğŸš€] Using Hilt in your Android app
   https://developer.android.google.cn/codelabs/android-hilt?hl=en
   In this codelab, youâ€™ll build an Android app that uses Hilt to 
   do Dependency Injection.

* [ğŸš€] Exposing data to watch face complications on Wear OS
   https://developer.android.google.cn/codelabs/data-sources?hl=en
   In this codelab, youâ€™ll learn how to expose your data to watch 
   face complications while keeping best practices for the platform 
   in mind.

* [ğŸš€] Create Hello-CMake with Android Studio
   https://developer.android.google.cn/codelabs/android-studio-cmake?hl=en
   In this codelab, youâ€™ll learn how to use Android Studio 4.0+ C
   ++ template

* [ğŸš€] Advanced WorkManager
   https://developer.android.google.cn/codelabs/android-adv-workmanager?hl=en
   Built on top of the â€œWorkManager Basicsâ€ codelab, this adds 
   support for the new Progress API introduced in WorkManager v2.3 and 
   shows how to customize WorkManager with a custom configuration. 
   This codelab will also cover how to test Workers.

* [ğŸš€] Add Rewarded Video Ads to your Android App
   https://developer.android.google.cn/codelabs/admob-rewarded-video-android?hl=en
   In this codelab, youâ€™ll integrate rewarded video ads into a 
   simple demo game.

* [ğŸš€] Converting to Kotlin
   https://developer.android.google.cn/codelabs/java-to-kotlin?hl=en
   In this codelab, youâ€™ll learn how to convert your Java code to 
   Kotlin

* [ğŸš€] Generics, objects, and extensions
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-generics?hl=en
   Gain a high-level introduction to more Kotlin concepts such as 
   generics, enum classes, data classes, objects, and scope 
   functions which youâ€™ll be using in your Compose code.

* [ğŸš€] Two-way communication without internet
   https://developer.android.google.cn/codelabs/nearby-connections?hl=en
   Learn how to connect your users with each other even when no 
   internet is available

* [ğŸš€] Build a musical game using Oboe
   https://developer.android.google.cn/codelabs/musicalgame-using-oboe?hl=en
   Learn how to build a musical game with the Oboe library.

* [ğŸš€] Kotlin Bootcamp for Programmers 1: Get started
   https://developer.android.google.cn/codelabs/kotlin-bootcamp-introduction?hl=en
   In this codelab, you learn some of the advantages of using 
   Kotlin, and you install the necessary tools (JDK+IDE).

* [ğŸš€] Android Room with a View - Kotlin
   https://developer.android.google.cn/codelabs/android-room-with-a-view-kotlin?hl=en
   In this codelab youâ€™ll build an Android app in Kotlin that uses 
   Android Architecture Components (RoomDatabase, Entity, DAO, 
   AndroidViewModel, LiveData) together with Kotlin coroutines. This 
   sample app stores a list of words in a Room database and displays it 
   in a RecyclerView. You will implement this app using the 
   recommended Android architecture using these components.

* [ğŸš€] Advanced Android in Kotlin 05.2: Introduction to Test Doubles and Dependency Injection
   https://developer.android.google.cn/codelabs/advanced-android-kotlin-training-testing-test-doubles?hl=en
   In this codelab youâ€™ll learn to set up manual dependency 
   injection, a service locator, and how to use fakes and mocks in your 
   Android Kotlin apps. In doing so, youâ€™ll learn how to test a 
   repository and write fragment integration tests.

* [ğŸš€] Add a scrollable list
   https://developer.android.google.cn/codelabs/basic-android-compose-training-add-scrollable-list?hl=en
   Add a scrollable list to the Affirmations app

* [ğŸš€] Using Play Asset Delivery in native games
   https://developer.android.google.cn/codelabs/native-gamepad?hl=en
   In this codelab, modify a C++ demo application to take 
   advantage of Play Asset Delivery for on-demand asset downloading from 
   Google Play.

* [ğŸš€] Building a Kotlin extensions library
   https://developer.android.google.cn/codelabs/building-kotlin-extensions-library?hl=en
   In this codelab, youâ€™ll build your own Kotin extensions library 
   for an API that was originally created in the Java programming 
   language. Youâ€™ll learn the basics of extension functions and 
   properties, as well as how to implement a coroutines and Flow version 
   of a traditional, callbacks based API.

* [ğŸš€] Android Sleep API Codelab
   https://developer.android.google.cn/codelabs/android-sleep-api?hl=en
   Learn how to register for the Android Sleep API to get the 
   SleepSegmentEvents and SleepClassifyEvents.

* [ğŸš€] Android fundamentals 02.2: Activity lifecycle and state
   https://developer.android.google.cn/codelabs/android-fundamentals-02-2-activity-lifecycle-and-state?hl=en
   In this codelab you add logging statements to the TwoActivities 
   app and observe activity lifecycle changes. You work with these 
   changes and explore how to handle user input under these 
   conditions.

* [ğŸš€] Optimizing your Android App for ChromeOS
   https://developer.android.google.cn/codelabs/optimized-for-chromeos?hl=en
   In this codelab, youâ€™ll build an Android app that contains many 
   of the optimizations needed for a good user experience on 
   ChromeOS.

* [ğŸš€] Add Nearby Messages to your app
   https://developer.android.google.cn/codelabs/android-nearby-messages?hl=en
   Learn how to send and discover messages with the Nearby 
   Messages API

* [ğŸš€] Working with Proto DataStore
   https://developer.android.google.cn/codelabs/android-proto-datastore?hl=en
   In this codelab, youâ€™ll modify a sample app to incorporate 
   Jetpack Proto DataStore, a new and improved data store solution and 
   replacement for SharedPreferences.

* [ğŸš€] People: Conversations and Bubbles
   https://developer.android.google.cn/codelabs/android-people?hl=en
   This codelab demonstrates how to show conversational 
   notifications as Bubbles on Android 11.

* [ğŸš€] Login with Biometrics on Android
   https://developer.android.google.cn/codelabs/biometric-login?hl=en
   In this codelab you will add biometric authentication to your 
   app as part of your login process. You will not replace your 
   current login process â€“ users can still log in with their account 
   password. Instead, you will augment your login process, giving users 
   the convenience to not have to remember their password every time 
   they open your app. The codelab shows how to ask users to opt-in 
   and then how to store the server generated user token behind 
   biometric authentication.

* [ğŸš€] Use collections in Kotlin
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-collections?hl=en
   Learn how to use arrays and collections, including lists, sets, 
   and maps.

* [ğŸš€] Use ConstraintLayout to design your Android views
   https://developer.android.google.cn/codelabs/constraint-layout?hl=en
   In this codelab, youâ€™ll learn how to use Android Studioâ€™s 
   Layout Editor to build your views using ConstraintLayout.

* [ğŸš€] Practice: Build Superheroes app
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-superheroes?hl=en
   Build upon the concepts of material design, building a list and 
   simple animations to build a list of super-heroes.

* [ğŸš€] Write conditionals in Kotlin
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-conditionals?hl=en
   Learn how to write conditionals in Kotlin.

* [ğŸš€] Data Binding in Android
   https://developer.android.google.cn/codelabs/android-databinding?hl=en
   In this codelab youâ€™ll learn how to use the Data Binding 
   library. The Data Binding Library allows you to bind UI components in 
   your layouts to data sources in your app using a declarative 
   format rather than programmatically. Youâ€™ll learn to set it all up, 
   use layout expressions, work with observable objects, and create 
   custom Binding Adapters to reduce boilerplate to a minimum.

* [ğŸš€] Build a handwritten digit classifier app with TensorFlow Lite
   https://developer.android.google.cn/codelabs/digit-classifier-tflite?hl=en
   In this codelab you will train a handwritten digit classifier 
   model using TensorFlow, then convert it to TensorFlow Lite format 
   and deploy it on an Android app.

* [ğŸš€] Approximate location
   https://developer.android.google.cn/codelabs/approximate-location?hl=en
   Request location permission in Android 1

* [ğŸš€] Integrating Android Performance Tuner into your native Android game
   https://developer.android.google.cn/codelabs/android-performance-tuner-native?hl=en
   In this codelab, youâ€™ll add Android Performance Tuner to a 
   native Android game, allowing you to get performance measures 
   reported in the Google Play Console when people play your game.

* [ğŸš€] On Demand Modules
   https://developer.android.google.cn/codelabs/on-demand-dynamic-delivery?hl=en
   With the Android App Bundle and Google Playâ€™s Dynamic Delivery, 
   your app can download dynamic feature modules on demand to 
   devices running Android 5.0 (API level 21) and higher. Your app simply 
   needs to call APIs in the Play Core Library to download and 
   install those modules as required, and the Google Play Store pushes 
   only the code and resources needed for that module to the device. 
   You can also use this API to download on demand modules for your 
   instant app.

* [ğŸš€] Project: Create a Business Card app
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-business-card?hl=en
   Learn how to create an Android app that showcases your business 
   card.

* [ğŸš€] Use collections in Kotlin
   https://developer.android.google.cn/codelabs/basic-android-kotlin-collections?hl=en
   Learn how to use arrays and collections, including lists, sets, 
   and maps.

* [ğŸš€] Scalable Implementation of Google Play Billing in Kotlin
   https://developer.android.google.cn/codelabs/play-billing-scalable-kotlin?hl=en
   This codelab shows how to add billing to an existing app. You 
   will learn how to use the Google Play Billing Library in your 
   project in a way that hides the nitty-gritty details from the rest of 
   your app and engineering team.

* [ğŸš€] Lesson 1.1 - Get started
   https://developer.android.google.cn/codelabs/android-development-kotlin-1.1?hl=en
   In this codelab, you learn some of the advantages of using 
   Kotlin, and you install the necessary tools (JDK+IDE).

* [ğŸš€] Automated Accessibility Testing using Espresso
   https://developer.android.google.cn/codelabs/a11y-testing-espresso?hl=en
   In this codelab, youâ€™ll learn the fundamentals of accessibility 
   testing using Espresso.

* [ğŸš€] Use function types and lambda expressions in Kotlin
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-function-types-and-lambda?hl=en
   Learn how to use lambda expressions and higher order functions 
   in Kotlin.

* [ğŸš€] Advanced Android in Kotlin 05.1: Testing Basics
   https://developer.android.google.cn/codelabs/advanced-android-kotlin-training-testing-basics?hl=en
   Learn the basics of testing your Android Kotlin apps. In this 
   codelab youâ€™ll learn to run tests, write basic tests, work with 
   AndroidX Test, as well as test ViewModel and LiveData.

* [ğŸš€] Build a Fast Checkout Experience on Android with Google Pay (Kotlin)
   https://developer.android.google.cn/codelabs/pay-android-checkout?hl=en
   In this codelab, youâ€™ll build a checkout screen in your Android 
   application, and equip it with Google Pay. This allows users in 
   your application to pay for items in a fast, convenient, and 
   secure way, with just the tap of a button.

* [ğŸš€] Android Testing Codelab
   https://developer.android.google.cn/codelabs/android-testing?hl=en
   In this codelab youâ€™ll learn how to write tests for a real 
   world Android application that uses modern architecture. It showcases 
   unit, integration and end-to-end tests using JUnit4, code 
   coverage tools, Robolectric and Espresso. Youâ€™ll also learn how to 
   create tests for an app that uses Kotlin coroutines and Architecture 
   Components like ViewModel, LiveData, Room, Navigation and Data 
   Binding.

* [ğŸš€] Practice: Build Sports app
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-sports-app?hl=en
   Build upon the concepts of material design by building a list 
   and simple animations to build a list of superheroes.

* [ğŸš€] Learn Jetpack Navigation
   https://developer.android.google.cn/codelabs/android-navigation?hl=en
   Learn how to implement common navigation requirements for 
   Android apps. Navigation Components handle fragment transactions, up/
   back stack, navigation UI patterns like navigation drawers, deep 
   links and more. Youâ€™ll also explore the type safe args plugin and 
   the Navigation Editor in Android Studio.

* [ğŸš€] Advanced Android in Kotlin 05.3: Testing Coroutines and Jetpack integrations
   https://developer.android.google.cn/codelabs/advanced-android-kotlin-training-testing-survey?hl=en
   In this codelab, you learn how to test coroutines, ViewModel 
   scoped coroutines, and Room, and implement end-to-end testing for 
   your Kotlin Android app.

* [ğŸš€] Android Room with a View - Java
   https://developer.android.google.cn/codelabs/android-room-with-a-view?hl=en
   In this codelab you build an app that uses Android Architecture 
   Components (RoomDatabase, Entity, DAO, AndroidViewModel, 
   LiveData) and implements the recommended architecture for these 
   components. The sample app stores a list of words in a Room database and 
   displays it in a RecyclerView.

* [ğŸš€] Managing Android Devices Without an App
   https://developer.android.google.cn/codelabs/android-management-api?hl=en
   Managing Android devices has never been easier. With the 
   Android Management API, you can build a policy and provision a device 
   in minutes. Our quickstart guide will give you everything you need 
   to get started, and will help you set up a device from scratch 
   in minutes.


Codelabs in Chinese
-------------------

* [ğŸš€] é¡¹ç›®ï¼šLunch Tray åº”ç”¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-project-lunch-tray?hl=zh_cn
   Android åŸºç¡€çŸ¥è¯†ç¬¬ 3 å•å…ƒé¡¹ç›®è¯´æ˜

* [ğŸš€] è®¡ç®—å°è´¹
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-tip-calculator?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†ä¸ºå°è´¹è®¡ç®—å™¨åº”ç”¨ç¼–å†™ä»£ç ã€‚

* [ğŸš€] æ›´æ”¹åº”ç”¨ä¸»é¢˜
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-change-app-theme?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†ä¸ºåº”ç”¨åˆ›å»ºè‰²å½©ä¸»é¢˜ã€‚

* [ğŸš€] Kotlin ä¸­çš„é›†åˆ
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-collections?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†è¯¦ç»†äº†è§£é›†åˆä»¥åŠ Kotlin ä¸­çš„ lambda å’Œé«˜é˜¶å‡½æ•°ã€‚

* [ğŸš€] è°ƒè¯•ç®€ä»‹
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-intro-debugging?hl=zh_cn
   å­¦ä¹ å¦‚ä½•è§£è¯»å †æ ˆè½¨è¿¹å¹¶ç†Ÿæ‚‰ Android Studio ä¸­çš„è°ƒè¯•å·¥å…·

* [ğŸš€] åœ¨ Kotlin ä¸­ä½¿ç”¨åˆ—è¡¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-lists?hl=zh_cn
   å­¦ä¹ å¦‚ä½•ä½¿ç”¨ä»¥ Kotlin ç¼–ç¨‹è¯­è¨€ç¼–å†™çš„åˆ—è¡¨ã€‚

* [ğŸš€] åœ¨ Kotlin ä¸­åˆ›å»ºç”Ÿæ—¥ç¥ç¦è¯­
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-kotlin-birthday-message?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†ä½¿ç”¨ Kotlin è¯­è¨€åˆ›å»ºç”Ÿæ—¥ç¥ç¦è¯­ç¨‹åºã€‚

* [ğŸš€] åˆ›å»º Birthday Card åº”ç”¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-birthday-card-app?hl=zh_cn
   åœ¨æœ¬ Codelab ä¸­ï¼Œæ‚¨å°†ä½¿ç”¨ Android Studio ä¸­çš„å¸ƒå±€ç¼–è¾‘å™¨åˆ›å»ºä¸€ä¸ªæ˜¾ç¤ºæ–‡æœ¬çš„ Android åº”ç”¨ã€‚

* [ğŸš€] ä¸‹è½½å¹¶å®‰è£… Android Studio
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-install-android-studio?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†ä¸‹è½½å¹¶å®‰è£… Android Studio å¼€å‘å·¥å…·ã€‚

* [ğŸš€] åˆ›å»ºäº¤äº’å¼ Dice Roller åº”ç”¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†æ„å»ºä¸€ä¸ªå¯æ·éª°å­å¹¶åœ¨å±å¹•ä¸Šæ˜¾ç¤ºç»“æœçš„ Android åº”ç”¨ã€‚

* [ğŸš€] å°† LiveData ä¸ ViewModel é…åˆä½¿ç”¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-livedata?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨ LiveDataï¼ˆæ¶æ„ç»„ä»¶ä¹‹ä¸€ï¼‰ï¼Œå¦‚ä½•å°† ViewModel ä¸­çš„åº”ç”¨æ•°æ®è½¬æ¢ä¸º 
   LiveDataï¼Œä»¥åŠå¦‚ä½•è§‚å¯Ÿ LiveData ä¸­çš„æ›´æ”¹å¹¶è‡ªåŠ¨æ›´æ–°ç•Œé¢ã€‚

* [ğŸš€] SQL åŸºç¡€çŸ¥è¯†
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-sql-basics?hl=zh_cn
   å­¦ä¹ å…³ç³»å‹æ•°æ®åº“çš„åŸºç¡€çŸ¥è¯†ï¼Œå¹¶ç»ƒä¹ åœ¨ Android Studio ä¸­ä½¿ç”¨ Database Inspector è¿è¡Œ SQL 
   æŸ¥è¯¢ã€‚

* [ğŸš€] åœ¨ Kotlin ä¸­æ·»åŠ æ¡ä»¶è¡Œä¸º
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-conditional-dice-roll-behavior?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†åˆ›å»ºä¸€ä¸ª Lucky Dice Roll Kotlin ç¨‹åºï¼Œ
   ç”¨äºæ£€æŸ¥æ‚¨æ·å‡ºçš„æ•°å­—æ˜¯å¦ç­‰äºç»™å®šçš„å¹¸è¿æ•°å­—ã€‚

* [ğŸš€] ä¸º Android åº”ç”¨åˆ›å»º XML å¸ƒå±€
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-xml-layouts?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨ XML è¯­è¨€ä¸º Android åº”ç”¨åˆ›å»ºå¸ƒå±€ã€‚

* [ğŸš€] å°†æ•°æ®å­˜å‚¨åœ¨ ViewModel ä¸­
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-viewmodel?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨ ViewModelï¼ˆæ¶æ„ç»„ä»¶ä¹‹ä¸€ï¼‰ï¼Œä»¥åŠå¦‚ä½•å®ç° ViewModel 
   ä»¥ä¾¿åœ¨é…ç½®æ›´æ”¹æœŸé—´ä¿ç•™åº”ç”¨æ•°æ®ã€‚

* [ğŸš€] å‘ Dice Roller åº”ç”¨æ·»åŠ å›¾ç‰‡
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-dice-roller-images?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å‘ Dice Roller åº”ç”¨æ·»åŠ å›¾ç‰‡ï¼Œä»è€Œæå‡ç”¨æˆ·ä½“éªŒã€‚

* [ğŸš€] é¡¹ç›®ï¼šDogglers åº”ç”¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-project-dogglers-app?hl=zh_cn
   Android åŸºç¡€çŸ¥è¯†ç¬¬ 2 å•å…ƒé¡¹ç›®è¯´æ˜

* [ğŸš€] ä½¿ç”¨æ–­ç‚¹è¿›è¡Œè°ƒè¯•
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-debugging-with-breakpoints?hl=zh_cn
   äº†è§£åœ¨è°ƒè¯•æ—¶å¦‚ä½•ä½¿ç”¨æ–­ç‚¹å¹¶è§‚å¯Ÿç‰¹å®šå˜é‡ã€‚

* [ğŸš€] å¯¼èˆªå’Œè¿”å›å †æ ˆ
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-navigation-backstack?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†äº†è§£è¿”å›å †æ ˆä»¥åŠå¦‚ä½•åœ¨æ‚¨çš„åº”ç”¨ä¸­è‡ªå®šä¹‰å¯¼èˆªè¡Œä¸ºã€‚

* [ğŸš€] Preferences DataStore
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-preferences-datastore?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨åä¸º Jetpack DataStore çš„æ•°æ®å­˜å‚¨è§£å†³æ–¹æ¡ˆåœ¨åº”ç”¨ä¸­å­˜å‚¨é”®å€¼å¯¹ã€‚

* [ğŸš€] å¯é€‰ï¼šåœ¨ç§»åŠ¨è®¾å¤‡ä¸Šè¿è¡Œæ‚¨çš„åº”ç”¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-run-on-mobile-device?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•è®¾ç½® Android è®¾å¤‡ï¼ˆå¦‚æ‰‹æœºæˆ–å¹³æ¿ç”µè„‘ï¼‰ä»¥åŠå¦‚ä½•åœ¨ Android è®¾å¤‡ä¸Šè¿è¡Œé€šè¿‡ 
   Android Studio å¼€å‘çš„åº”ç”¨ã€‚

* [ğŸš€] activity å’Œ intent
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-activities-intents?hl=zh_cn
   æ›´æ–°æœªå®Œæˆçš„åº”ç”¨ï¼Œä»¥ä¾¿åˆ©ç”¨éšå¼ intent å’Œæ˜¾å¼ intent å®ç°å¯¼èˆªã€‚

* [ğŸš€] åˆ›å»ºå¹¶è¿è¡Œæ‚¨çš„é¦–ä¸ª Android åº”ç”¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-first-template-project?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•é€šè¿‡ Android Studio ä½¿ç”¨ Kotlin æ„å»ºæ‚¨çš„é¦–ä¸ª Android 
   åº”ç”¨ã€‚æ‚¨å°†ä½¿ç”¨ Android Studio æ¨¡æ¿æ¥åˆ›å»ºæ‚¨çš„ç¬¬ä¸€ä¸ªé¡¹ç›®ã€‚

* [ğŸš€] é¡¹ç›®ï¼šLemonade åº”ç”¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-project-lemonade?hl=zh_cn
   Android åŸºç¡€çŸ¥è¯†ç¬¬ 1 å•å…ƒé¡¹ç›®è¯´æ˜

* [ğŸš€] ä½¿ç”¨å¡ç‰‡æ˜¾ç¤ºä¸€ç»„å›¾ç‰‡
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-display-list-cards?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†ç¾åŒ–åœ¨ä¸Šä¸€ä¸ª Codelab ä¸­åˆ›å»ºçš„ Affirmations åº”ç”¨çš„ç•Œé¢ã€‚

* [ğŸš€] Fragment ä¹‹é—´çš„å…±äº« ViewModel
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-shared-viewmodel?hl=zh_cn
   åœ¨æ›´é«˜çº§çš„åº”ç”¨ç¤ºä¾‹ä¸­ä½¿ç”¨ Jetpack Navigation ç»„ä»¶ï¼Œå¹¶äº†è§£åœ¨ activity çš„å¤šä¸ª fragment 
   ä¹‹é—´ä½¿ç”¨å…±äº« ViewModel çš„ä¼˜åŠ¿ã€‚

* [ğŸš€] è‡ªé€‚åº”å¸ƒå±€
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-adaptive-layouts?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•åˆ©ç”¨ SlidingPaneLayout ä½¿åº”ç”¨é€‚åº”ä¸åŒå±å¹•å°ºå¯¸

* [ğŸš€] ä½¿ç”¨ Kotlin ç¼–å†™æ‚¨çš„ç¬¬ä¸€ä¸ªç¨‹åº
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-first-kotlin-program?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†ä½¿ç”¨ Kotlin è¯­è¨€ç¼–å†™æ‚¨çš„ç¬¬ä¸€ä¸ªç¨‹åºã€‚

* [ğŸš€] å­˜å‚¨åº“æ¨¡å¼
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-repository-pattern?hl=zh_cn
   ä½¿ç”¨ä»“åº“æ¨¡å¼åœ¨ç°æœ‰åº”ç”¨ä¸­å®ç°ç¼“å­˜ã€‚

* [ğŸš€] ä½¿ç”¨ Room è¯»å–å’Œæ›´æ–°æ•°æ®
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-update-data-room?hl=zh_cn
   äº†è§£å¦‚ä½•åœ¨ Android Kotlin åº”ç”¨ä¸­ä½¿ç”¨ Room è¯»å–å’Œæ›´æ–°æ•°æ®ã€‚Room æ˜¯ä¸€ä¸ªæ•°æ®åº“åº“ï¼Œå±äº Android 
   Jetpack çš„ä¸€éƒ¨åˆ†ã€‚Room è´Ÿè´£å¤„ç†æ•°æ®åº“è®¾ç½®å’Œé…ç½®æ–¹é¢çš„è®¸å¤šç¹çå·¥ä½œï¼Œå¹¶è®©åº”ç”¨å¯ä»¥ä½¿ç”¨æ™®é€šçš„å‡½æ•°è°ƒç”¨ä¸æ•°æ®åº“è¿›è¡Œäº¤äº’ã€‚

* [ğŸš€] é¡¹ç›®ï¼šWater Me! åº”ç”¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-project-water-me?hl=zh_cn
   Android åŸºç¡€çŸ¥è¯†ç¬¬ 6 å•å…ƒé¡¹ç›®è¯´æ˜

* [ğŸš€] Kotlin ä¸­çš„ç±»å’Œå¯¹è±¡å®ä¾‹
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-create-dice-roller-in-kotlin?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†åˆ›å»ºä¸€ä¸ªå¯ä»¥æ·éª°å­çš„ Kotlin ç¨‹åºã€‚

* [ğŸš€] é¡¹ç›®ï¼šForage åº”ç”¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-project-forage?hl=zh_cn
   Android åŸºç¡€çŸ¥è¯†ç¬¬ 5 å•å…ƒé¡¹ç›®è¯´æ˜

* [ğŸš€] é¡¹ç›®ï¼šAmphibians åº”ç”¨
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-project-amphibians?hl=zh_cn
   Android åŸºç¡€çŸ¥è¯†ç¬¬ 4 å•å…ƒé¡¹ç›®è¯´æ˜

* [ğŸš€] ä½¿ç”¨ Kotlin å‘åº”ç”¨æ·»åŠ è¿è¡Œæ—¶æƒé™
   https://developer.android.google.cn/codelabs/android-app-permissions?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•å‘ Android åº”ç”¨æ·»åŠ æƒé™

* [ğŸš€] Kotlin ä¸­çš„ç±»å’Œç»§æ‰¿
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-classes-and-inheritance?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨ Kotlin ç¼–ç¨‹è¯­è¨€åˆ›å»ºå­ç±»ï¼Œä»¥åŠç»§æ‰¿çš„å·¥ä½œæ–¹å¼ã€‚

* [ğŸš€] Room å’Œ Flow ç®€ä»‹
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-intro-room-flow?hl=zh_cn
   å­¦ä¹ å…³ç³»å‹æ•°æ®åº“çš„åŸºç¡€çŸ¥è¯†ï¼Œå¹¶ç»ƒä¹ åœ¨ Android Studio ä¸­ä½¿ç”¨ Database Inspector è¿è¡Œ SQL 
   æŸ¥è¯¢ã€‚

* [ğŸš€] ä½¿ç”¨ Room æŒä¹…ä¿ç•™æ•°æ®
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-persisting-data-room?hl=zh_cn
   äº†è§£å¦‚ä½•åœ¨ Android Kotlin åº”ç”¨ä¸­ä½¿ç”¨ Roomã€‚Room æ˜¯ä¸€ä¸ªæŒä¹…æ€§æ•°æ®åº“ï¼Œå±äº Android 
   Jetpack çš„ä¸€éƒ¨åˆ†ã€‚Room æ˜¯ SQLite ä¹‹ä¸Šçš„ä¸€ä¸ªæŠ½è±¡å±‚ã€‚Room æä¾›æ–¹ä¾¿çš„ APIï¼Œ
   ç”¨äºè®¾ç½®å’Œé…ç½®æ•°æ®åº“ä»¥åŠä»æ•°æ®åº“æŸ¥è¯¢æ•°æ®ã€‚

* [ğŸš€] ä¸ºæ‚¨çš„ Android åº”ç”¨æ·»åŠ å›¾ç‰‡
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-birthday-card-app-image?hl=zh_cn
   åœ¨æœ¬ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨ ImageView å‘åº”ç”¨æ·»åŠ å›¾ç‰‡ã€‚

* [ğŸš€] è¿ç§»åˆ° Jetpack Compose
   https://developer.android.google.cn/codelabs/jetpack-compose-migration-io?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•å°† View ç³»ç»Ÿä¸­çš„éƒ¨åˆ†ç•Œé¢è¿ç§»åˆ° Jetpack Composeã€‚

* [ğŸš€] ä½¿ç”¨ WorkManager åœ¨åå°å¤„ç†å·¥ä½œ - Kotlin
   https://developer.android.google.cn/codelabs/android-workmanager?hl=zh_cn
   Android ä¸ºä¿è¯æ‰§è¡Œåå°å·¥ä½œæä¾›äº†è®¸å¤šé€‰æ‹©ï¼Œè¿™äº›é€‰æ‹©æ—¢æœ‰å¾ˆå¤šä¼˜ç‚¹ï¼Œä¹Ÿæœ‰å¾ˆå¤šç¼ºç‚¹ã€‚é¢å‘ Android çš„ 
   WorkManager API å¯ç®€åŒ–åå°å·¥ä½œã€‚WorkManager è§£å†³äº†æç«¯æƒ…å†µå’Œå…¼å®¹æ€§é—®é¢˜ã€‚å®ƒè¿˜å¯ä»¥åˆ›å»ºå¯æŸ¥è¯¢ã€å¯é‡ç”¨å’Œå¯é“¾æ¥çš„ä»»åŠ¡ã€‚
   WorkManager æ˜¯ Android å¹³å°ä¸Šæ¨èçš„ä»»åŠ¡è°ƒåº¦ç¨‹åºã€‚æœ¬ Codelab å°†å‘æ‚¨ä»‹ç» WorkManager 
   çš„è¯¦ç»†ä¿¡æ¯ï¼šä»ç¼–å†™ç®€å•çš„ä½œä¸šï¼Œåˆ°æ›´ä¸ºå¤æ‚çš„å…·æœ‰çº¦æŸæ¡ä»¶çš„é“¾å¼ä½œä¸šã€‚

* [ğŸš€] Refactoring to Kotlin (é‡æ„ä¸º Kotlin)
   https://developer.android.google.cn/codelabs/java-to-kotlin-zh?hl=en
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•å°† Java ä»£ç é‡æ„ä¸º Kotlin

* [ğŸš€] åˆ¶ä½œæ›´å¤šå£°æ³¢ - é‡‡æ ·å™¨
   https://developer.android.google.cn/codelabs/making-waves-2-sampler?hl=zh_cn
   æ„å»ºä½å»¶è¿Ÿæ•°å­—é‡‡æ ·å™¨

* [ğŸš€] ä» Java è°ƒç”¨ Kotlin ä»£ç 
   https://developer.android.google.cn/codelabs/java-friendly-kotlin?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ ç¼–å†™ä¸ Java å…·æœ‰æ— ç¼çš„äº’æ“ä½œæ€§çš„ Kotlin ä»£ç ã€‚

* [ğŸš€] æ‰‹åŠ¿å¯¼èˆªå’Œæ— è¾¹æ¡†ä½“éªŒ
   https://developer.android.google.cn/codelabs/gesture-navigation?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å¤„ç†ä¸€ä¸ªç°æœ‰åº”ç”¨ï¼Œä½¿å…¶åº”ç”¨æ§ä»¶å¯ä¸æ‰‹åŠ¿å¯¼èˆªé…åˆä½¿ç”¨ã€‚æ­¤å¤–ï¼Œæ‚¨è¿˜å°†æä¾›æ— è¾¹æ¡†å±å¹•ä½“éªŒã€‚

* [ğŸš€] ä½¿ç”¨ Kotlin 03.2 è¿›è¡Œé«˜çº§ Android å¼€å‘ï¼šä½¿ç”¨ MotionLayout çš„åŠ¨ç”»æ•ˆæœ
   https://developer.android.google.cn/codelabs/motion-layout?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†ä½¿ç”¨ MotionLayout æ„å»ºå…·æœ‰åŠ¨æ€åŠ¨ç”»æ•ˆæœçš„ Android Kotlin åº”ç”¨ã€‚

* [ğŸš€] ä½¿ç”¨ Kotlin è¿›è¡Œé«˜çº§ Android å¼€å‘ 04.1ï¼šAndroid Google åœ°å›¾
   https://developer.android.google.cn/codelabs/advanced-android-kotlin-training-maps?hl=zh_cn
   äº†è§£å¦‚ä½•å‘ Android Kotlin åº”ç”¨æ·»åŠ  Google åœ°å›¾ï¼Œå¹¶ä¸º Google åœ°å›¾è®¾ç½®æ ·å¼ã€‚

* [ğŸš€] åˆ¶ä½œå£°æ³¢ç¬¬ 1 éƒ¨åˆ† - æ„å»ºåˆæˆå™¨
   https://developer.android.google.cn/codelabs/making-waves-1-synth?hl=zh_cn
   ä½¿ç”¨ Android O ä¸­çš„ AAudio API æ„å»ºä½å»¶è¿Ÿçš„è§¦æ§åˆæˆå™¨åº”ç”¨ã€‚

* [ğŸš€] å†…å®¹ä¸ Android TV ä¸»å±å¹•é¢‘é“é›†æˆ (Kotlin)
   https://developer.android.google.cn/codelabs/tv-recommendations-kotlin?hl=zh_cn
   æ­¤ Codelab ä»‹ç» Android TV ä¸»å±å¹•åŠŸèƒ½ã€‚æ‚¨å°†å­¦ä¹ å¦‚ä½•åœ¨ Android TV ä¸»å±å¹•ä¸Šæ·»åŠ é¢‘é“å’ŒèŠ‚ç›®ï¼Œ
   å¹¶ä½¿å…¶å¯ä»¥è¢«ç”¨æˆ·å‘ç°ã€‚

* [ğŸš€] Android Kotlin åŸºç¡€çŸ¥è¯†ï¼šç”Ÿå‘½å‘¨æœŸå’Œæ—¥å¿—è®°å½•
   https://developer.android.google.cn/codelabs/kotlin-android-training-lifecycles-logging?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†äº†è§£ activity å’Œ fragment ç”Ÿå‘½å‘¨æœŸã€‚

* [ğŸš€] Android Kotlin åŸºç¡€çŸ¥è¯†ï¼š03.2 å®šä¹‰å¯¼èˆªè·¯å¾„
   https://developer.android.google.cn/codelabs/kotlin-android-training-add-navigation?hl=zh_cn
   å­¦ä¹ å¦‚ä½•ä½¿ç”¨ Android Studio çš„ Navigation Editor å®šä¹‰åº”ç”¨ä¸­çš„å¯¼èˆªæµï¼ˆå¯¼èˆªè·¯å¾„ï¼‰ã€‚
   æ‚¨å°†äº†è§£å¦‚ä½•å®ç°å‘ä¸ŠæŒ‰é’®ã€æ·»åŠ é€‰é¡¹èœå•ï¼Œä»¥åŠä¸ºåº”ç”¨åˆ›å»ºæŠ½å±‰å¼å¯¼èˆªæ ã€‚

* [ğŸš€] Android Kotlin åŸºç¡€çŸ¥è¯†ï¼šå¤æ‚çš„ç”Ÿå‘½å‘¨æœŸæƒ…å½¢
   https://developer.android.google.cn/codelabs/kotlin-android-training-complex-lifecycle?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•ç®¡ç†å¤æ‚çš„ç”Ÿå‘½å‘¨æœŸæƒ…å½¢ã€‚

* [ğŸš€] Android Kotlin åŸºç¡€çŸ¥è¯†ï¼š03.3 å¯åŠ¨å¤–éƒ¨ activity
   https://developer.android.google.cn/codelabs/kotlin-android-training-start-external-activity?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨ Safe Args æŠŠå‚æ•°ä¼ é€’åˆ° fragmentï¼Œä»¥ä¾¿æ›´è½»æ¾åœ°è°ƒè¯•åº”ç”¨ï¼›
   è¿˜ä¼šå­¦ä¹ å¦‚ä½•åœ¨åº”ç”¨ä¸­è°ƒç”¨å¤–éƒ¨ activityã€‚

* [ğŸš€] Android Kotlin åŸºç¡€çŸ¥è¯†ï¼šåˆ›å»º Room æ•°æ®åº“
   https://developer.android.google.cn/codelabs/kotlin-android-training-room-database?hl=zh_cn
   äº†è§£å¦‚ä½•åœ¨ Android Kotlin åº”ç”¨ä¸­ä½¿ç”¨ Roomã€‚Room æ˜¯ä¸€ä¸ªæ•°æ®åº“ï¼Œæ˜¯ Android Jetpack 
   çš„ä¸€éƒ¨åˆ†ã€‚Room è´Ÿè´£å¤„ç†æ•°æ®åº“è®¾ç½®å’Œé…ç½®æ–¹é¢çš„è®¸å¤šç¹çå·¥ä½œï¼Œå¹¶è®©åº”ç”¨å¯ä»¥ä½¿ç”¨æ™®é€šçš„å‡½æ•°è°ƒç”¨
   ä¸æ•°æ®åº“è¿›è¡Œäº¤äº’ã€‚

* [ğŸš€] Android Kotlin åŸºç¡€çŸ¥è¯†ï¼šåˆ›å»º fragment
   https://developer.android.google.cn/codelabs/kotlin-android-training-create-and-add-fragment?hl=zh_cn
   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•åˆ›å»º fragment å¹¶å°†å…¶æ·»åŠ åˆ°åº”ç”¨ä¸­ã€‚

* [ğŸš€] Android Kotlin åŸºç¡€çŸ¥è¯†ï¼š07.2 å°† DiffUtil å’Œæ•°æ®ç»‘å®šä¸ RecyclerView ç»“åˆä½¿ç”¨
   https://developer.android.google.cn/codelabs/kotlin-android-training-diffutil-databinding?hl=zh_cn
   å­¦ä¹ æé«˜ RecyclerView æ•ˆç‡çš„æŠ€å·§ï¼Œä»¥å¤„ç†å¤§å‹åˆ—è¡¨ã€‚æ­¤å¤–ï¼Œæ‚¨è¿˜èƒ½å­¦åˆ°ä¸€äº›å…¶ä»–æŠ€å·§ï¼Œä½¿æ‚¨çš„ä»£ç 
   æ›´æ˜“äºç»´æŠ¤å’Œæ‰©å±•ï¼Œä»¥åœ¨æ‚¨çš„ Android Kotlin åº”ç”¨ä¸­å¤„ç†å¤æ‚çš„åˆ—è¡¨å’Œç½‘æ ¼ã€‚

* [ğŸš€] åç¨‹ç®€ä»‹
   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-introduction-coroutines?hl=zh_cn


Android Developers
------------------

* [ğŸš€] Build and test a parked app for Android Automotive OS
   https://developer.android.google.cn/codelabs/build-a-parked-app?hl=en
   In this codelab, youâ€™ll learn how to build and test great 
   parked experiences for Android Automotive OS devices. You learn how to 
   make the most of the wide variety of screens found in cars and 
   how to let users control playback of content in various scenarios 
   unique to cars using standard Android mechanisms.

* [ğŸš€] Practical performance problem solving in Jetpack Compose
   https://developer.android.google.cn/codelabs/jetpack-compose-performance?hl=en
   Make your Compose app run fast by analyzing system traces and 
   fixing common lag causes.

* [ğŸš€] Practice: Click behavior
   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-button-click-practice-problem?hl=en
   Apply what you learned about button click behavior to build an app.

* [ğŸš€] Introduction to Compose for TV
   https://developer.android.google.cn/codelabs/compose-for-tv-introduction?hl=en
   Learn the basics of Compose for TV and create two screens that 
   are commonly available in TV apps.

* [ğŸš€] Handle edge-to-edge enforcements in Android 15
   https://developer.android.google.cn/codelabs/edge-to-edge?hl=en
   Learn how to handle edge-to-edge enforcements in Android 15.

* [ğŸš€] Learn Car App Library fundamentals
   https://developer.android.google.cn/codelabs/car-app-library-fundamentals?hl=en
   In this codelab, you learn the fundamentals of the Car App 
   Library. This library is used to build apps for Android Auto and 
   Android Automotive OS, which can be used both while parked and 
   driving. You learn how to reuse your implementation across both 
   platforms and have it handle the hard stuff, like different screen 
   configurations and input methods.

* [ğŸš€] Convertendo para Kotlin
   https://developer.android.google.cn/codelabs/java-to-kotlin-pt-br?hl=en
   Nesse codelab vocÃª aprenderÃ¡ como converter seu cÃ³digo Java para Kotlin.

* [ğŸš€] Receive location updates in Android 10 with Kotlin
   https://developer.android.google.cn/codelabs/while-in-use-location?hl=en
   In this codelab, you'll learn how to continue receiving location updates 
   for Android 10, keeping best practices for the platform in mind.

* [ğŸš€] Install Android 11 GSI for App Testing
   https://developer.android.google.cn/codelabs/using-android-q-gsi?hl=en
   In this codelab, you will install Android 11 Generic System 
   Image (GSI) to Android 9 (Pie) devices. After that, you can develop 
   and validate your application with the new OS!

* [ğŸš€] Configure, implement, and verify Android App Links
   https://developer.android.google.cn/codelabs/android-app-links-introduction?hl=en
   In this codelab, youâ€™ll build an Android App which lists a 
   series of restaurants. It aims to help design, configure, and verify 
   Android App Links.

* [ğŸš€] Improve app performance with Baseline Profiles
   https://developer.android.google.cn/codelabs/android-baseline-profiles-improve?hl=en
   This codelab shows how to improve app startup timing and frame 
   timing with Baseline Profiles.

* [ğŸš€] Add Play Integrity to your Android application
   https://developer.android.google.cn/codelabs/add-play-integrity?hl=en
   In this codelab, youâ€™ll add the Play Integrity API to a sample 
   application. Youâ€™ll use the Play Integrity API to request an 
   integrity verdict that helps you make determinations about the 
   license status and integrity of your app, and the integrity status of 
   the device it is running on.

* [ğŸš€] Inspect app performance with Macrobenchmark
   https://developer.android.google.cn/codelabs/android-macrobenchmark-inspect?hl=en
   In this codelab, youâ€™ll learn how to measure app startup timing 
   and frame timing with Jetpack Macrobenchmark.

* [ğŸš€] Enhance stylus support in an Android app
   https://developer.android.google.cn/codelabs/large-screens/advanced-stylus-support?hl=en
   Learn how to implement advanced techniques that enable a state-of-the-art 
   stylus experience in an Android app.

* [ğŸš€] Cronet Basics
   https://developer.android.google.cn/codelabs/cronet?hl=en
   Last Updated: 2022-05-06 Cronet is the Chromium network stack 
   made available to Android apps as a library. Cronet takes 
   advantage of multiple technologies that reduce the latency and increase 
   the throughput of the network requests that your app needs

* [ğŸš€] Create different versions of your app using build variants
   https://developer.android.google.cn/codelabs/build-variants?hl=en
   In this codelab, you build a default (â€œdemoâ€) and premium (â€œfull
   â€) version of the DiceRoller app using build variants.

* [ğŸš€] MDC-103 Android: Material Theming with Color, Elevation and Type (Kotlin)
   https://developer.android.google.cn/codelabs/mdc-103-kotlin?hl=en
   Discover how Material Components for Android make it easy to 
   differentiate your product and express your brand through design in 
   Kotlin.

* [ğŸš€] MDC-103 Android: Material theming with Color, Motion and Type (Java)
   https://developer.android.google.cn/codelabs/mdc-103-java?hl=en
   Discover how Material Components for Android make it easy to 
   differentiate your product and express your brand through design in 
   Java.

* [ğŸš€] MDC-102 Android: Material Structure and Layout (Java)
   https://developer.android.google.cn/codelabs/mdc-102-java?hl=en
   Learn how to use Material for structure and layout on Android 
   in Java.

* [ğŸš€] Building Beautiful Transitions with Material Motion for Android
   https://developer.android.google.cn/codelabs/material-motion-android?hl=en
   Build Material's motion system into the Reply app using 
   transitions from the Material Components for Android library, and Kotlin.

* [ğŸš€] Recognize Flowers with TensorFlow Lite on Android
   https://developer.android.google.cn/codelabs/recognize-flowers-with-tensorflow-on-android?hl=en
   In this codelab you will take an image classifier, and run it 
   on an Android phone using TensorFlow Lite.

* [ğŸš€] MDC-102 Android: Material Structure and Layout (Kotlin)
   https://developer.android.google.cn/codelabs/mdc-102-kotlin?hl=en
   Learn how to use Material for structure and layout on Android 
   in Kotlin.

* [ğŸš€] MDC-104 Android: Material Advanced Components (Kotlin)
   https://developer.android.google.cn/codelabs/mdc-104-kotlin?hl=en
   Improve your design and learn to use our advanced component 
   backdrop menu in Kotlin.

* [ğŸš€] MDC-104 Android: Material Advanced Components (Java)
   https://developer.android.google.cn/codelabs/mdc-104-java?hl=en
   Improve your design and learn to use our advanced component 
   backdrop menu in Java.

* [ğŸš€] Incorporate Lifecycle-Aware Components
   https://developer.android.google.cn/codelabs/android-lifecycles?hl=en
   In this codelab, you'll learn about lifecycle-aware architecture 
   components and how to incorporate LiveData and ViewModels into your app.

* [ğŸš€] MDC-101 Android: Material Components (MDC) Basics (Java)
   https://developer.android.google.cn/codelabs/mdc-101-java?hl=en
   Learn the basics of using Material Components for Android by 
   building a simple app with core components in Java.

* [ğŸš€] Deprecated: Deeper Content Integration with the New Android TV Home Screen
   https://developer.android.google.cn/codelabs/tv-channels-programs?hl=en
   This codelab introduces the new Android TV home screen. You'll 
   learn how to add channels and programs to the Android TV 
   launcher, and make them discoverable. Deprecated by jbax@

* [ğŸš€] Recognize Flowers with TensorFlow Lite on Android (beta)
   https://developer.android.google.cn/codelabs/recognize-flowers-with-tensorflow-on-android-beta?hl=en
   In this codelab you will take an image classifier, and run it 
   on an Android phone using TensorFlow Lite.

* [ğŸš€] Raise engagement on Android TV by integrating with the Play Next row
   https://developer.android.google.cn/codelabs/tv-watch-next?hl=en
   This codelab dives deeper into the new Android TV home screen. 
   You'll learn how to add programs to the Play Next row, the 
   different types of programs allowed, and best practices for your app to 
   integrate with the row.

* [ğŸš€] Recognize, Identify Language and Translate text with ML Kit and CameraX: Android
   https://developer.android.google.cn/codelabs/mlkit-android-translate?hl=en
   In this codelab, you'll build an Android app with ML Kit that 
   uses on-device Machine Learning to recognize, identify language 
   and translate text from between 59 languages. You'll also learn how 
   to integrate the CameraX library to accomplish these tasks from 
   a real-time camera feed.

* [ğŸš€] Controlling media through MediaSession
   https://developer.android.google.cn/codelabs/supporting-mediasession?hl=en
   In this codelab, you'll expand a video sample to add support 
   for MediaSession. This allows Android to control playback from 
   outside your app, for instance through the Google Assistant, remote 
   controls on TV, or on-screen controls on the lock screen and Wear OS.


ğŸš€ Incorporate Lifecycle-Aware Components
=========================================

   pandoc --column=100 -trst -rhtml https://developer.android.google.cn/codelabs/android-lifecycles

   *  Before you begin
   *  Step 1 - Setup Your Environment
   *  Step 2 - Add a ViewModel
   *  Step 3 - Wrap Data Using LiveData
   *  Step 4 - Subscribe to Lifecycle Events
   *  Step 5 - Share a ViewModel between Fragments
   *  Step 6 - Persist ViewModel state across process recreation (beta)
   *  Congratulations

Before you begin
----------------

   Architecture components are a set of Android libraries that help you structure your app
   in a way that is robust, testable, and maintainable.

   This codelab introduces you to the following lifecycle-aware architecture components for
   building Android apps:

   -  ``ViewModel`` - provides a way to create and retrieve objects that are bound to a
      specific lifecycle. A ViewModel_ 
      typically stores the state of a view's data and communicates with other components,
      such as data repositories or the domain layer which handles business logic.

   -  ``LifecycleOwner`` - LifecycleOwner_ is an interface implemented by the
      AppCompatActivity_ and Fragment_ classes. You can subscribe other components to 
      owner objects which implement this
      interface, to observe changes to the lifecycle of the owner.

   -  ``LiveData`` - allows you to observe changes to data across multiple components of
      your app without creating explicit, rigid dependency paths between them.
      LiveData_ respects the complex lifecycles of your app components, including activities,
      fragments, services, or any `LifecycleOwner`
      defined in your app.

      LiveData_ manages observer subscriptions by pausing subscriptions to stopped
      `LifecycleOwner` objects, and cancelling subscriptions to
      `LifecycleOwner` objects that are finished.

   To read an introductory guide:

   *  `Handling Lifecycles <https://developer.android.google.cn/topic/libraries/architecture/lifecycle.html>`__.
   *  `ViewModel <https://developer.android.google.cn/topic/libraries/architecture/viewmodel.html>`__.
   *  `LiveData <https://developer.android.google.cn/topic/libraries/architecture/livedata.html>`__.

.. _LifecycleOwner: https://developer.android.google.cn/reference/android/arch/lifecycle/LifecycleOwner.html
.. _ViewModel: https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html
.. _LiveData: https://developer.android.google.cn/reference/android/arch/lifecycle/LiveData.html
.. _AppCompatActivity: https://developer.android.google.cn/reference/androidx/appcompat/app/AppCompatActivity
.. _Fragment: https://developer.android.google.cn/reference/androidx/fragment/app/Fragment

Prerequisites

   This codelab has been designed for Android developers with some basic experience. To
   proceed, you must be familiar with the
   `Android activity lifecycle <https://developer.android.google.cn/guide/components/activities/activity-lifecycle.html>`__.

What you'll build

   In this codelab, you implement examples of each of the components described above. You
   begin with a sample app and add code through a series of steps, integrating the various
   architecture components as you progress.

What you'll need

   -  Android Studio 3.5 or greater.


Step 1 - Setup Your Environment
-------------------------------

   In this step, you download the code for the entire codelab and then run a simple example
   app.

   .. code:: bash

      $ git clone git@github.com:googlecodelabs/android-lifecycles.git

   Alternatively you can download the repository as a Zip file:

   `Download source code <https://github.com/googlecodelabs/android-lifecycles/archive/master.zip>`__

   Once you have the code:

   1. Open the project Android Studio version 2.5 or newer.
   2. Copy over the Android Studio run configurations that will be used in this codelab.

      Execute command from the code root directory:

      .. code:: bash

         # MacOS / Linux:
         mkdir -p .idea/runConfigurations
         cp runConfigurations/* .idea/runConfigurations/

         # Windows:
         MKDIR .idea\runConfigurations
         COPY runConfigurations\* .idea\runConfigurations\

      Once you have run the command, you should see run configurations for each step:

      .. figure:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/817549a52a3024b5.png

      Shows 11 configurations. App and then steps 1 to 6 with solutions for step 3, 4, 5 and 6.

   3. Run the **Step 1** run configuration on a device or emulator.

      The app runs and displays a screen similar to the following screenshot:

      .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/7f1d3f84a5405b9c.png

   3. Rotate the screen and notice that the timer resets!

      **Note**: If you're using an emulator or device running 
      `Android 8.0 or higher <https://developer.android.google.cn/about/versions/pie/android-9.0-changes-all#screen-rotation-changes>`__,
      you'll need to enable rotation in settings:

      .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/be422c095a5ed8d8.png

   You now need to update the app to persist state across screen rotations. You can use a
   ViewModel_
   because instances of this class survive configuration changes, such as screen rotation.

Step 2 - Add a ViewModel
------------------------

   In this step, you use a ViewModel_
   to persist state across screen rotations and address the behaviour you observed in the
   previous step. In the previous step, you ran an activity that displays a timer. This
   timer is reset when a configuration change, such as screen rotation, destroys an
   activity.

   You can use a ViewModel_
   to retain data across the entire lifecycle of an activity or a fragment. As the previous
   step demonstrates, an activity is a poor choice to manage app data. Activities and
   fragments are short-lived objects which are created and destroyed frequently as a user
   interacts with an app. A ViewModel_
   is also better suited to managing tasks related to network communication, as well as
   data manipulation and persistence.

Persisting the state of the Chronometer **using a ViewModel**

   Open ``ChronoActivity2`` and examine how the class retrieves and uses a ViewModel_:

   .. code:: kotlin

      ChronometerViewModel chronometerViewModel
                        = new ViewModelProvider(this).get(ChronometerViewModel.class);

   ``this`` refers to an instance of LifecycleOwner_.
   The framework keeps the ViewModel_ alive as long as the scope of the
   LifecycleOwner_ is alive. A ViewModel_
   is not destroyed if its owner is destroyed for a configuration change, such as screen
   rotation. The new instance of the owner re-connects to the existing ViewModel_,
   as illustrated by the following diagram:

   .. figure:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/1d42e8efcb42ff58.png

      The ViewModel survives an activity recreation and only the onCleared method 
      is called when the activity is finished.

   **Caution:** The scope of an activity or fragment goes from *created* to *finished* (or
   *terminated*), which you must not confuse with *destroyed*. Remember that when a device
   is rotated, the activity is destroyed but any instances of ``ViewModel`` associated with
   it are not.

Try it out

   Run the app (choose **Step 2** in the Run Configurations dropdown) and confirm the timer
   doesn't reset when you perform either of the following actions:

   1. Rotate the screen.
   2. Navigate to another app and then return.

   .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/5fb7f5e5a2a179d9.png

   However, if you or the system exit the app, then the timer resets.

   **Caution:** The system persists instances of ``ViewModel`` in memory throughout the
   life of a lifecycle owner, such as a fragment or activity. The system doesn't persist
   instances of ``ViewModel`` to long-term storage.


Step 3 - Wrap Data Using LiveData
---------------------------------

   In this step, you replace the chronometer used in previous steps with a custom one which
   uses a
   `Timer <https://developer.android.google.cn/reference/java/util/Timer.html>`__, and
   updates the UI every second. A
   `Timer <https://developer.android.google.cn/reference/java/util/Timer.html>`__ is a
   ``java.util`` class that you can use to schedule recurrent tasks. You add this logic to
   the ``LiveDataTimerViewModel`` class, and leave the activity to focus on managing the
   interaction between the user and the UI.

   The activity updates the UI when notified by the timer. To help avoid memory leaks, the
   ViewModel_ doesn't include references to the activity. For example, a configuration change, such as
   a screen rotation, might result in references in a
   ViewModel_ to an activity that should be garbage collected. The system retains instances of
   ViewModel_ until the corresponding activity or lifecycle owner no longer exists.

   **Caution:** Storing a reference to a
   `Context <https://developer.android.google.cn/reference/android/content/Context.html>`__
   or `View <https://developer.android.google.cn/reference/android/view/View.html>`__ in a
   ``ViewModel`` can result in memory leaks. Avoid fields that reference instances of the
   ``Context`` or ``View`` classes. The
   `onCleared() <https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html#onCleared()>`__
   method is useful to unsubscribe or clear references to other objects with a longer
   lifecycle, but not for clearing references to ``Context`` or ``View`` objects.

   Instead of modifying views directly from the
   ViewModel_,
   you configure an activity or fragment to *observe* a data source, receiving the data
   when it changes. This arrangement is called the observer pattern.

   **Note:** To expose data as an observable, wrap the type in a ``LiveData`` class.

   You may be familiar with the observer pattern if you've used the `Data Binding
   Library <https://developer.android.google.cn/topic/libraries/data-binding/index.html>`__,
   or other reactive libraries like ``RxJava``.
   LiveData_ is a special observable class which is lifecycle-aware, and only notifies active
   observers.

LifecycleOwner


   ``ChronoActivity3`` is an instance of AppCompatActivity_
   which is a subclass of
   `ComponentActivity <https://developer.android.google.cn/reference/androidx/activity/ComponentActivity.html>`__.
   Take a look at the reference documentation and notice that ``ComponentActivity`` implements
   LifecycleOwner_.
   LifecycleOwner_ is an interface that is used by any class that has an Android lifecycle. 
   Practically, it means that the class has a
   `Lifecycle <https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.html>`__
   object that represents its lifecycle.

   Both ViewModel_ and LiveData_ can bind to a ``Lifecycle``.

Update ChronoActivity

   1. Add the following code to the ``ChronoActivity3`` class, in the ``subscribe()``
      method, to create the subscription:

      .. code:: kotlin

         mLiveDataTimerViewModel.getElapsedTime().observe(this, elapsedTimeObserver);

   2. Next, set the new elapsed time value in the ``LiveDataTimerViewModel`` class. Find
      the following comment:

      .. code:: kotlin

         //TODO post the new value with LiveData.postValue()

   Replace the comment with the following statement:

      .. code:: kotlin

         mElapsedTime.postValue(newValue);

   3. Run the app and open **Logcat** in Android Studio. Notice that the log updates every
      second unless you navigate to another app. If your device supports multi-window mode,
      you may like to try using it. Rotating the screen does not affect how the app behaves.

   .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/fade3efb0f57f3bf.png

   **Note:** ``LiveData`` objects only send updates when the activity, or the
   ``LifecycleOwner`` is active. If you navigate to a different app, the log messages pause
   until you return. ``LiveData`` objects only consider subscriptions as active when their
   respective lifecycle owner is either
   `STARTED <https://developer.android.google.cn/reference/android/arch/lifecycle/Lifecycle.State.html#started>`__
   or
   `RESUMED <https://developer.android.google.cn/reference/android/arch/lifecycle/Lifecycle.State.html#resumed>`__.

Step 4 - Subscribe to Lifecycle Events
--------------------------------------

   Many Android components and libraries require you to:

   1. Subscribe, or initialize the component or library.
   2. Unsubscribe, or stop the component or library.

   Failing to complete the steps above can lead to memory leaks and subtle bugs.

   A lifecycle owner object can be passed to new instances of lifecycle-aware components,
   to ensure they're aware of the current state of a lifecycle.

   You can query the current state of a lifecycle using the following statement:

   .. code:: kotlin

      lifecycleOwner.getLifecycle().getCurrentState()

   The statement above returns a state, such as
   `Lifecycle.State.RESUMED <https://developer.android.google.cn/reference/android/arch/lifecycle/Lifecycle.State.html>`__,
   or
   `Lifecycle.State.DESTROYED <https://developer.android.google.cn/reference/android/arch/lifecycle/Lifecycle.State.html>`__.

   A lifecycle-aware object that implements
   `LifecycleObserver <https://developer.android.google.cn/reference/android/arch/lifecycle/LifecycleObserver.html>`__
   can also observe changes in the state of a lifecycle owner:

   .. code:: kotlin

      lifecycleOwner.getLifecycle().addObserver(this);

   You can annotate the object to instruct it to call the appropriate methods when
   required:

   .. code:: kotlin

      @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
      void addLocationListener() { ... }

Create a lifecycle-aware component

   In this step, you create a component that reacts to an activity lifecycle owner. Similar
   principles and steps apply when using a fragment as the lifecycle owner.

   You use the Android framework's
   `LocationManager <https://developer.android.google.cn/reference/android/location/LocationManager.html>`__
   to get the current latitude and longitude and display them to the user. This addition
   allows you to:

   -  Subscribe to changes and automatically update the UI using LiveData_.
   -  Create a wrapper of the
      `LocationManager <https://developer.android.google.cn/reference/android/location/LocationManager.html>`__
      that registers and unregisters, based on changes to the status of the activity.

   You would typically subscribe a
   `LocationManager <https://developer.android.google.cn/reference/android/location/LocationManager.html>`__
   to changes in either the ``onStart()`` or ``onResume()`` methods of an activity, and
   remove the listener in the ``onStop()`` or ``onPause()`` methods:

   .. code:: kotlin

      // Typical use, within an activity.

      @Override
      protected void onResume() {
            mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, mListener);
      }

      @Override
      protected void onPause() {
            mLocationManager.removeUpdates(mListener);
      }

   In this step, you'll update a class called ``BoundLocationManager`` to be
   lifecycle-aware: it will bind to, observe and react to changes in a ``LifecycleOwner``.

   For the class to observe the activity's lifecycle, you must add it as an observer. To
   accomplish this, instruct the ``BoundLocationManager`` object to observe the lifecycle
   by adding the following code to its constructor:

   .. code:: kotlin

      lifecycleOwner.getLifecycle().addObserver(this);

   To call a method when a lifecycle change occurs, you can use the ``@OnLifecycleEvent``
   annotation. Update the ``addLocationListener()`` and ``removeLocationListener()``
   methods with the following annotations in the ``BoundLocationListener`` class:

   .. code:: kotlin

      @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
      void addLocationListener() {
            ...
      }
      @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
      void removeLocationListener() {
            ...
      }

   **Note:** The observer is brought to the current state of the provider, so there's no
   need to call ``addLocationListener()`` from the constructor. It's called for you when
   the observer is added to the lifecycle owner.

   Run the app and verify that the **Log Monitor** displays the following actions, when you
   rotate the device:

   .. code:: bash

      D/BoundLocationMgr: Listener added
      D/BoundLocationMgr: Listener removed
      D/BoundLocationMgr: Listener added
      D/BoundLocationMgr: Listener removed

   Use the Android Emulator to simulate changing the location of the device (click the
   three dots to show the extended controls). The
   `TextView <https://developer.android.google.cn/reference/android/widget/TextView.html>`__
   is updated when it changes:

   .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/ad0d237382937d28.png

      Extended emulator controls showing where the device location can be changed (Location section)

Step 5 - Share a ViewModel between Fragments
--------------------------------------------

Share a ViewModel between fragment

   Complete the following additional steps using a ViewModel_
   to enable communication between fragments and the following:

   -  A single activity.
   -  Two instances of a fragment, each one with a
      `SeekBar <https://developer.android.google.cn/reference/android/widget/SeekBar.html>`__.
   -  A single ViewModel_ with a LiveData_ field.

   Run this step (Select run "Step 5" in run configurations) and notice two instances of
   `SeekBar <https://developer.android.google.cn/reference/android/widget/SeekBar.html>`__
   which are independent of each other:

   .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/218d038a7495f489.png

   Connect the fragments with a ViewModel_ so that when one
   `SeekBar <https://developer.android.google.cn/reference/android/widget/SeekBar.html>`__
   is changed, the other
   `SeekBar <https://developer.android.google.cn/reference/android/widget/SeekBar.html>`__
   is updated:

   .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/f7e7ff5af6cf9e8.png

   **Note:** You should use the activity as the lifecycle owner, as the lifecycle of each
   fragment is independent.

   There's no step-by-step manual for this exercise but you can find a solution in the
   ``step5_solution`` package.

Step 6 - Persist ViewModel state across process recreation (beta)
-----------------------------------------------------------------

   From `Overview of memory management <https://developer.android.google.cn/topic/performance/memory-overview>`__:

      When users switch between apps, Android keeps apps that are not foregroundâ€”that is, not
      visible to the user or running a foreground service like music playbackâ€” in a
      least-recently used (LRU) cache. For example, when a user first launches an app, a
      process is created for it; but when the user leaves the app, that process does not quit.
      The system keeps the process cached. If the user later returns to the app, the system
      reuses the process, thereby making the app switching faster.

   As the system runs low on memory, it kills processes in the cache beginning with the
   process least recently used. When the user navigates back to the app, the system will
   restart the app in a new process.

   Since this only happens if the user has not interacted with the app for a while, it
   *might* be permissible to have them return to the app and find it in the initial state.
   However, **there are cases where you might want to save the state of the app** or part
   of it, so that that information is not lost if the process happens to be killed.

   The ``lifecycle-viewmodel-savedstate`` module provides access to the saved state in
   ViewModels.

   The gradle dependency for this module is

   .. code:: kotlin

      "androidx.lifecycle:lifecycle-viewmodel-savedstate:$savedStateVersion"

   Once you have the dependency, as long as you are using a default Fragment or Activity,
   you'll have access to a SavedStateHandle in your ViewModel. A
   `SavedStateHandle <https://developer.android.google.cn/reference/androidx/lifecycle/SavedStateHandle>`__
   is a key-value mapping that survives process death.

   First, let's try out step 6 without these changes:

   1. Open run configuration "Step 6"

      .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/cd6bf4b161d90ffa.png

      You will see a simple form:

      .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/240a7519fbe7d6dc.png

         Name with value

   2. Change the name and click "SAVE". This will store it in a LiveData inside the ViewModel_.

      .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/2452cdc3297cbb1.png

         Name is now

   3. Simulate the system killing the process (requires emulator running P+). First make
      sure the process is running by typing:

      .. code:: bash

         $ adb shell ps -A |grep lifecycle

      This should output the running process with name
      ``com.example.android.codelabs.lifecycle``

      .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/b96f682cee729e29.png

         Result of the previous command shows a line with the running process.

      **Press Home** on your device or emulator and then run:

      .. code:: bash

         $ adb shell am kill com.example.android.codelabs.lifecycle

      If you then type again

      .. code:: bash

         $ adb shell ps -A |grep lifecycle

      You should get nothing, indicating that the process has been killed correctly.

   4. Open the app again (Look for *LC Step6* in your app launcher).

   .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/e351d21d8c6bd556.png

   The value in the ViewModel_ **was not persisted** however the ``EditText`` restored its
   state. How is this possible?

   .. Tip::

      Some UI elements, including ``EditText``, save their state using their own
      ``onSaveInstanceState`` implementation. This state is restored after a process is killed
      the same way it's restored after a configuration change. 
      
      Read `ViewModels: Persistence, onSaveInstanceState(), Restoring UI State and
      Loaders <https://medium.com/androiddevelopers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090>`__
      for more information.

      Actually, the ``lifecycle-viewmodel-savedstate`` module also uses
      ``onSaveInstanceState`` and ``onRestoreInstanceState`` to persist the ViewModel state
      but it makes these operations more convenient.

Implement a saved state for ViewModels

   In the ``SavedStateViewModel.java`` file you need to add a new constructor that takes a
   ``SavedStateHandle`` and store the state in a private field:

   .. code:: kotlin

      private SavedStateHandle mState;

      public SavedStateViewModel(SavedStateHandle savedStateHandle) {
         mState = savedStateHandle;
      }

   Now you'll use the module's LiveData support so you don't need to store and expose a
   LiveData in your ViewModel anymore. Replace the existing getter and ``saveNewName``
   with:

   .. code:: kotlin

      private static final String NAME_KEY = "name";

      // Expose an immutable LiveData
      LiveData<String> getName() {
            return mState.getLiveData(NAME_KEY);
      }

      void saveNewName(String newName) {
            mState.set(NAME_KEY, newName);
      }

   Now that you're using LiveData from ``mState``, the MutableLiveData name isn't used
   anymore and can be removed.

   Now you can try the same process again. Open the app, change the name and save it. Then,
   press Home and kill the process with:

   .. code:: bash

      $ adb shell am kill com.example.android.codelabs.lifecycle

   If you reopen the app, you'll see that the state in the ViewModel has been saved this
   time.

   .. image:: https://developer.android.google.cn/static/codelabs/android-lifecycles/img/e593195964f092c1.png

   With the `SavedStateHandler <https://developer.android.google.cn/reference/androidx/lifecycle/SavedStateHandle.html>`__
   you can save and restore primitives, Bundles, Parcelables, Serializables and other types
   of data. Check out the `Saved State module for ViewModel documentation <https://developers.android.com/topic/libraries/architecture/viewmodel-savedstate>`__
   for the acceptable classes and more details.

Congratulations
---------------

   You've learned how to introduce lifecycle-aware architecture components to your Android
   apps. `Continue to learn more about Android architecture components at developer.android.com. <https://developer.android.google.cn/topic/libraries/architecture/index.html>`__

   *All rights reserved. Java is a registered trademark of Oracle and/or its affiliates.*


ğŸš€ activity å’Œ intent
======================

https://developer.android.google.cn/codelabs/basic-android-kotlin-training-activities-intents?hl=zh-cn


1. ç®€ä»‹
-------


   **æ³¨æ„ï¼š** æœ¬ Codelab å·²è¿‡æ—¶ï¼Œæˆ‘ä»¬ä¸å†è¿›è¡Œç»´æŠ¤ã€‚å¦‚éœ€äº†è§£æœ€æ–°çš„æ¨èåšæ³•ï¼Œè¯·æ”¹ä¸ºå­¦ä¹ 
   `Android ä¹‹ Compose å¼€å‘åŸºç¡€è¯¾ç¨‹ã€‚ <https://developer.android.google.cn/courses/android-basics-compose/course?hl=zh-cn>`__

   åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ‚¨æ‰€å¤„ç†çš„åº”ç”¨åªæœ‰ä¸€ä¸ª activityã€‚å®é™…ä¸Šï¼Œè®¸å¤š Android åº”ç”¨éƒ½éœ€è¦å¤šä¸ª
   activityï¼Œå¹¶åœ¨å®ƒä»¬ä¹‹é—´è¿›è¡Œå¯¼èˆªã€‚

   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†æ„å»ºä¸€ä¸ªå­—å…¸åº”ç”¨ï¼Œä½¿å…¶ä½¿ç”¨å¤šä¸ª activityã€é€šè¿‡ intent åœ¨å„ activity
   ä¹‹é—´å¯¼èˆªï¼Œå¹¶å‘å…¶ä»–åº”ç”¨ä¼ é€’æ•°æ®ã€‚


å‰ææ¡ä»¶


   æ‚¨åº”è¯¥èƒ½å¤Ÿï¼š

   -  åœ¨ Android Studio ä¸­å¯¼èˆªåˆ°æŸä¸ªé¡¹ç›®ã€‚
   -  åœ¨ Android Studio ä¸­ä½¿ç”¨å’Œæ·»åŠ  XML èµ„æºã€‚
   -  æ›¿æ¢å’Œå®ç°ç°æœ‰ç±»ä¸­çš„æ–¹æ³•ã€‚
   -  åˆ›å»º Kotlin ç±»çš„å®ä¾‹ã€è®¿é—®ç±»å±æ€§ä»¥åŠè°ƒç”¨æ–¹æ³•ã€‚
   -  å¦‚éœ€è¯¦ç»†äº†è§£ç‰¹å®šç±»ï¼Œè¯·å‚é˜… `developer.android.com <https://developer.android.google.cn?hl=zh-cn>`__ã€‚


å­¦ä¹ å†…å®¹


   å¦‚ä½•æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

   -  ä½¿ç”¨æ˜¾å¼ intent å¯¼èˆªåˆ°ç‰¹å®š activityã€‚
   -  ä½¿ç”¨éšå¼ intent å¯¼èˆªåˆ°å…¶ä»–åº”ç”¨ä¸­çš„å†…å®¹ã€‚
   -  æ·»åŠ èœå•é€‰é¡¹ä»¥å‘åº”ç”¨æ ä¸­æ·»åŠ æŒ‰é’®ã€‚


æ„å»ºå†…å®¹


   -  ä¿®æ”¹å­—å…¸åº”ç”¨ï¼Œé€šè¿‡ä½¿ç”¨ intent å’Œæ·»åŠ é€‰é¡¹èœå•çš„æ–¹å¼å®ç°å±å¹•ä¹‹é—´çš„å¯¼èˆªã€‚


æ‰€éœ€æ¡ä»¶


   -  ä¸€å°å®‰è£…äº† Android Studio çš„è®¡ç®—æœºã€‚


2. èµ·å§‹ä»£ç 
-----------


   åœ¨æ¥ä¸‹æ¥çš„å‡ ä¸ªæ­¥éª¤ä¸­ï¼Œæ‚¨å°†é’ˆå¯¹ Words åº”ç”¨æ‰§è¡Œç›¸å…³æ“ä½œã€‚Words åº”ç”¨æ˜¯ä¸€ä¸ªç®€å•çš„å­—å…¸åº”ç”¨ï¼Œ
   å…¶ä¸­åŒ…å«å­—æ¯åˆ—è¡¨ã€æ¯ä¸ªå­—æ¯å¯¹åº”çš„å•è¯ï¼Œè¿˜èƒ½å¤Ÿåœ¨æµè§ˆå™¨ä¸­æŸ¥æ‰¾æ¯ä¸ªå•è¯çš„å«ä¹‰ã€‚

   ====================== ====================== ======================
   |7edb0777b033c159.png| |c465ef280fe3792a.png| |8ad271362c0a113b.png|
   ====================== ====================== ======================

   è¿™å…¶ä¸­æ¶‰åŠçš„å†…å®¹ç”šå¤šï¼Œä½†ä¸ç”¨æ‹…å¿ƒï¼Œæ‚¨ä¸å¿…æ„å»ºå®Œæ•´çš„åº”ç”¨ï¼Œåªéœ€è¦äº†è§£ intentã€‚
   ç›¸åï¼Œæˆ‘ä»¬ä¸ºæ‚¨æä¾›äº†é¡¹ç›®çš„ä¸å®Œæ•´ç‰ˆæœ¬ï¼Œä¹Ÿå«å…¥é—¨çº§é¡¹ç›®ã€‚

   å°½ç®¡æ‰€æœ‰å±å¹•å‡å·²å®ç°ï¼Œä½†æ‚¨ç›®å‰è¿˜ä¸èƒ½ä»ä¸€ä¸ªå±å¹•å¯¼èˆªåˆ°å¦ä¸€ä¸ªå±å¹•ã€‚æ‚¨çš„ä»»åŠ¡æ˜¯ä½¿ç”¨ intent
   è®©æ•´ä¸ªé¡¹ç›®èƒ½å¤Ÿæ­£å¸¸è¿è¡Œï¼Œä½†æ— éœ€ä»å¤´å¼€å§‹æ„å»ºæ‰€æœ‰å†…å®¹ã€‚


ä¸‹è½½æ­¤ Codelab çš„èµ·å§‹ä»£ç 


   æ­¤ Codelab æä¾›äº†èµ·å§‹ä»£ç ï¼Œä¾›æ‚¨ä½¿ç”¨æ­¤ Codelab
   ä¸­æ‰€æ•™çš„åŠŸèƒ½å¯¹å…¶è¿›è¡Œæ‰©å±•ã€‚èµ·å§‹ä»£ç å¯èƒ½åŒ…å«æ‚¨åœ¨ä¹‹å‰çš„ Codelab
   ä¸­å·²ç»ç†Ÿæ‚‰çš„ä»£ç ï¼Œä¹Ÿå¯èƒ½åŒ…å«æ‚¨ä¸ç†Ÿæ‚‰çš„ä»£ç ï¼Œæ‚¨å¯ä»¥åœ¨åç»­ Codelab ä¸­äº†è§£ç›¸å…³ä¿¡æ¯ã€‚

   å¦‚æœæ‚¨ä» GitHub ä¸‹è½½èµ·å§‹ä»£ç ï¼Œé‚£ä¹ˆè¯·æ³¨æ„ï¼Œæ–‡ä»¶å¤¹åç§°ä¸º ``android-basics-kotlin-words-app-starter``ã€‚
   åœ¨ Android Studio ä¸­æ‰“å¼€é¡¹ç›®æ—¶ï¼Œè¯·é€‰æ‹©æ­¤æ–‡ä»¶å¤¹ã€‚

   **èµ·å§‹ä»£ç ç½‘å€** ï¼š https://github.com/google-developer-training/android-basics-kotlin-words-app/tree/starter

   **åŒ…å«èµ·å§‹ä»£ç çš„åˆ†æ”¯åç§°** ï¼š ``starter``

   å¦‚æœæ‚¨ç†Ÿæ‚‰ Git å‘½ä»¤ï¼Œè¯·æ³¨æ„ï¼Œèµ·å§‹ä»£ç ä½äºåä¸ºâ€œstarterâ€çš„åˆ†æ”¯ä¸­ã€‚å…‹éš†ä»£ç åº“åï¼Œè¯·æŸ¥çœ‹
   ``origin/starter`` åˆ†æ”¯ä¸­çš„ä»£ç ã€‚å¦‚æœæ‚¨ä¹‹å‰ä»æœªä½¿ç”¨è¿‡ Git å‘½ä»¤ï¼Œè¯·æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤ä» GitHub
   ä¸‹è½½ä»£ç ã€‚

   1. è¿›å…¥ä¸ºæ­¤é¡¹ç›®æä¾›çš„ GitHub ä»£ç åº“é¡µé¢ã€‚
   2. éªŒè¯åˆ†æ”¯åç§°æ˜¯å¦ä¸æ­¤ Codelab
      ä¸­æŒ‡å®šçš„åˆ†æ”¯åç§°ä¸€è‡´ã€‚ä¾‹å¦‚ï¼Œåœ¨ä»¥ä¸‹å±å¹•æˆªå›¾ä¸­ï¼Œåˆ†æ”¯åç§°ä¸º **main** ã€‚

   |1e4c0d2c081a8fd2.png|

   3. åœ¨é¡¹ç›®çš„ GitHub é¡µé¢ä¸Šï¼Œç‚¹å‡» **Code** æŒ‰é’®ï¼Œä»¥æ‰“å¼€ä¸€ä¸ªå¼¹å‡ºå¼çª—å£ã€‚

   |1debcf330fd04c7b.png|

   4. åœ¨å¼¹å‡ºå¼çª—å£ä¸­ï¼Œç‚¹å‡» **Download ZIP** æŒ‰é’®ï¼Œå°†é¡¹ç›®ä¿å­˜åˆ°è®¡ç®—æœºä¸Šã€‚ç­‰å¾…ä¸‹è½½å®Œæˆã€‚
   5. åœ¨è®¡ç®—æœºä¸Šæ‰¾åˆ°è¯¥æ–‡ä»¶ï¼ˆå¾ˆå¯èƒ½åœ¨ **Downloads** æ–‡ä»¶å¤¹ä¸­ï¼‰ã€‚
   6. åŒå‡» ZIP æ–‡ä»¶è¿›è¡Œè§£å‹ç¼©ã€‚ç³»ç»Ÿå°†åˆ›å»ºä¸€ä¸ªåŒ…å«é¡¹ç›®æ–‡ä»¶çš„æ–°æ–‡ä»¶å¤¹ã€‚


åœ¨ Android Studio ä¸­æ‰“å¼€é¡¹ç›®


   1. å¯åŠ¨ Android Studioã€‚
   2. åœ¨ **Welcome to Android Studio** çª—å£ä¸­ï¼Œç‚¹å‡» **Open** ã€‚

   |d8e9dbdeafe9038a.png|

   æ³¨æ„ï¼šå¦‚æœ Android Studio å·²ç»æ‰“å¼€ï¼Œåˆ™æ”¹ä¸ºä¾æ¬¡é€‰æ‹© **File** > **Open** èœå•é€‰é¡¹ã€‚

   |8d1fda7396afe8e5.png|

   3. åœ¨æ–‡ä»¶æµè§ˆå™¨ä¸­ï¼Œå‰å¾€è§£å‹ç¼©çš„é¡¹ç›®æ–‡ä»¶å¤¹æ‰€åœ¨çš„ä½ç½®ï¼ˆå¾ˆå¯èƒ½åœ¨ **Downloads** æ–‡ä»¶å¤¹ä¸­ï¼‰ã€‚
   4. åŒå‡»è¯¥é¡¹ç›®æ–‡ä»¶å¤¹ã€‚
   5. ç­‰å¾… Android Studio æ‰“å¼€é¡¹ç›®ã€‚
   6. ç‚¹å‡» **Run** æŒ‰é’® |8de56cba7583251f.png| ä»¥æ„å»ºå¹¶è¿è¡Œåº”ç”¨ã€‚è¯·ç¡®ä¿è¯¥åº”ç”¨æŒ‰é¢„æœŸæ„å»ºã€‚


3. Words åº”ç”¨æ¦‚è§ˆ
-----------------


   åœ¨ç»§ç»­ä¹‹å‰ï¼Œè¯·èŠ±ç‚¹æ—¶é—´ç†Ÿæ‚‰ä¸€ä¸‹é¡¹ç›®ã€‚æ‚¨åº”è¯¥å·²ç»ç†Ÿæ‚‰äº†ä¸Šä¸€å•å…ƒä»‹ç»çš„æ‰€æœ‰æ¦‚å¿µã€‚ç›®å‰ï¼Œè¯¥åº”ç”¨ç”±ä¸¤ä¸ª
   activity ç»„æˆï¼Œæ¯ä¸ª activity å‡åŒ…å«ä¸€ä¸ª recycler è§†å›¾å’Œä¸€ä¸ªé€‚é…å™¨ã€‚

   |61af34429128695e.png|

   å…·ä½“è€Œè¨€ï¼Œæ‚¨å°†å¤„ç†ä»¥ä¸‹æ–‡ä»¶ï¼š

   1. ``LetterAdapter`` ç”± ``MainActivity`` ä¸­çš„ ``RecyclerView``
      ä½¿ç”¨ã€‚æ¯ä¸ªå­—æ¯éƒ½æ˜¯ä¸€ä¸ªå…·æœ‰ ``onClickListener``
      çš„æŒ‰é’®ï¼Œè¯¥ç›‘å¬å™¨ç›®å‰ä¸ºç©ºã€‚æ‚¨å°†åœ¨æ­¤ç›‘å¬å™¨ä¸­å¤„ç†æŒ‰ä¸‹æŒ‰é’®çš„æ“ä½œï¼Œä»¥å¯¼èˆªåˆ°
      ``DetailActivity`` ã€‚
   2. ``WordAdapter`` ç”± ``DetailActivity`` ä¸­çš„ ``RecyclerView``
      ä½¿ç”¨ï¼Œä»¥æ˜¾ç¤ºå•è¯åˆ—è¡¨ã€‚å°½ç®¡æ‚¨è¿˜æ— æ³•å¯¼èˆªåˆ°æ­¤å±å¹•ï¼Œä½†è¦çŸ¥é“ï¼Œæ¯ä¸ªå•è¯è¿˜æœ‰ä¸€ä¸ªç›¸åº”çš„å…·æœ‰
      ``onClickListener``
      çš„æŒ‰é’®ã€‚æ‚¨å°†åœ¨æ­¤ç›‘å¬å™¨ä¸­æ·»åŠ èƒ½å¤Ÿå¯¼èˆªåˆ°æµè§ˆå™¨çš„ä»£ç ï¼Œä»¥ä¾¿æ˜¾ç¤ºç›¸åº”å•è¯çš„å®šä¹‰ã€‚
   3. ``MainActivity``
      ä¹Ÿéœ€è¦è¿›è¡Œä¸€äº›æ›´æ”¹ã€‚åœ¨æ­¤ï¼Œæ‚¨å°†é€šè¿‡å®ç°é€‰é¡¹èœå•æ¥æ˜¾ç¤ºæŒ‰é’®ï¼Œä»è€Œä½¿ç”¨æˆ·èƒ½å¤Ÿåœ¨åˆ—è¡¨å’Œç½‘æ ¼å¸ƒå±€ä¹‹é—´è¿›è¡Œåˆ‡æ¢ã€‚

   |ce3474dba2a9c1c8.png|

   ç†Ÿæ‚‰åˆ°ç›®å‰ä¸ºæ­¢çš„é¡¹ç›®ä¹‹åï¼Œè¯·ç»§ç»­ä¸‹ä¸€éƒ¨åˆ†ï¼Œæ‚¨å°†äº†è§£ intentã€‚


4. intent ç®€ä»‹
--------------


   ç°åœ¨ï¼Œæ‚¨å·²è®¾ç½®å¥½åˆå§‹é¡¹ç›®ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬è®¨è®ºä¸€ä¸‹ intentï¼Œä»¥åŠå¦‚ä½•åœ¨åº”ç”¨ä¸­ä½¿ç”¨å®ƒä»¬ã€‚

   intent æ˜¯ç”¨äºè¡¨ç¤ºè¦æ‰§è¡Œçš„æŸäº›æ“ä½œçš„å¯¹è±¡ã€‚intent æœ€å¸¸è§ï¼ˆä½†è‚¯å®šä¸æ˜¯å”¯ä¸€ï¼‰çš„ç”¨é€”æ˜¯å¯åŠ¨
   activityã€‚intent åˆ†ä¸ºä¸¤ç§ç±»å‹ï¼š **éšå¼** å’Œ **æ˜¾å¼** ã€‚ **æ˜¾å¼ intent**
   éå¸¸å…·ä½“ï¼Œä½¿ç”¨è¿™ç±» intent æ—¶æ‚¨çŸ¥é“è¦å¯åŠ¨çš„å…·ä½“ activityï¼Œé€šå¸¸æ˜¯æ‚¨è‡ªå·±åº”ç”¨ä¸­çš„å±å¹•ã€‚

   **éšå¼ intent** æ›´æŠ½è±¡ä¸€äº›ï¼Œæ‚¨å¯ä»¥é€šè¿‡è¿™ç±» intent å‘ŠçŸ¥ç³»ç»Ÿè¦æ‰§è¡Œçš„æ“ä½œç±»å‹ ï¼ˆä¾‹å¦‚æ‰“å¼€é“¾æ¥ã€
   æ’°å†™ç”µå­é‚®ä»¶æˆ–æ‹¨æ‰“ç”µè¯ï¼‰ï¼Œç³»ç»Ÿåˆ™è´Ÿè´£ç¡®å®šå¦‚ä½•æ‰§è¡Œç›¸åº”è¯·æ±‚ã€‚åœ¨æ“ä½œè¿‡ç¨‹ä¸­ï¼Œæ‚¨å¯èƒ½å·²ç»è§è¿‡è¿™ä¸¤ç±»
   intentï¼Œä½†è‡ªå·±å¹¶ä¸çŸ¥é“ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œå¦‚æœè¦æ˜¾ç¤ºè‡ªå·±åº”ç”¨ä¸­çš„ activityï¼Œæ‚¨å¯ä»¥ä½¿ç”¨æ˜¾å¼ intentã€‚

   ====================== ======================
   |7edb0777b033c159.png| |c465ef280fe3792a.png|
   ====================== ======================

   ä½†æ˜¯ï¼Œå¯¹äºä¸ä¸€å®šæ¶‰åŠå½“å‰åº”ç”¨çš„æ“ä½œï¼ˆä¾‹å¦‚ï¼Œæ‚¨å‘ç°äº†ä¸€ä¸ªæœ‰è¶£çš„ Android æ–‡æ¡£é¡µé¢ï¼Œæƒ³ä¸å¥½å‹åˆ†äº«ï¼‰ï¼Œ
   åˆ™åº”ä½¿ç”¨ **éšå¼ intent** ã€‚æ‚¨å¯èƒ½ä¼šçœ‹åˆ°å¦‚ä¸‹æ‰€ç¤ºçš„èœå•ï¼Œè¯¢é—®ä½¿ç”¨å“ªä¸ªåº”ç”¨æ¥åˆ†äº«é¡µé¢ã€‚

   |e9c77033d9224170.png|

   æ‚¨å¯ä»¥ä½¿ç”¨æ˜¾å¼ intent æ¥æ‰§è¡Œæ“ä½œæˆ–æ˜¾ç¤ºè‡ªå·±åº”ç”¨ä¸­çš„å±å¹•ï¼Œå¹¶å¯¹æ•´ä¸ªæµç¨‹è´Ÿè´£ã€‚éšå¼ intent
   ä¸€èˆ¬ç”¨æ¥æ‰§è¡Œæ¶‰åŠå…¶ä»–åº”ç”¨çš„æ“ä½œï¼Œå¹¶ä¾èµ–ç³»ç»Ÿæ¥ç¡®å®šæœ€ç»ˆç»“æœã€‚æ‚¨å°†åœ¨ Words åº”ç”¨ä¸­ä½¿ç”¨è¿™ä¸¤ç±»
   intentã€‚

   |702236c6e2276f91.png|


5. è®¾ç½®æ˜¾å¼ intent
------------------


   ç°åœ¨ï¼Œæ‚¨å¯ä»¥å®ç°è‡ªå·±çš„é¦–ä¸ª intent
   äº†ã€‚åœ¨ç¬¬ä¸€ä¸ªå±å¹•ä¸Šï¼Œå½“ç”¨æˆ·ç‚¹æŒ‰æŸä¸ªå­—æ¯æ—¶ï¼Œç³»ç»Ÿåº”å°†ä»–ä»¬è½¬åˆ°åŒ…å«å•è¯åˆ—è¡¨çš„ç¬¬äºŒä¸ªå±å¹•ã€‚ ``DetailActivity``
   å·²ç»å®ç°ï¼Œå› æ­¤æ‚¨ç°åœ¨åªéœ€è¦ä½¿ç”¨ä¸€ä¸ª intent æ¥å¯åŠ¨å®ƒå³å¯ã€‚å› ä¸ºåº”ç”¨æ˜ç¡®çŸ¥é“åº”å¯åŠ¨å“ªä¸ª
   activityï¼Œæ‰€ä»¥åº”ä½¿ç”¨æ˜¾å¼ intentã€‚

   åªéœ€ç®€å•å‡ æ­¥ï¼Œå³å¯åˆ›å»ºå’Œä½¿ç”¨ intentï¼š

   1. æ‰“å¼€ ``LetterAdapter.kt`` å¹¶å‘ä¸‹æ»šåŠ¨åˆ°
      ``onBindViewHolder()`` ã€‚åœ¨ç”¨äºè®¾ç½®æŒ‰é’®æ–‡æœ¬çš„ä»£ç è¡Œä¸‹æ–¹ï¼Œä¸º ``holder.button`` è®¾ç½®
      ``onClickListener`` ã€‚

   .. code:: prettyprint

      holder.button.setOnClickListener {

      }

   2. ç„¶åï¼Œè·å–å¯¹ ``context`` çš„å¼•ç”¨ã€‚

   .. code:: prettyprint

      val context = holder.itemView.context

   3. åˆ›å»ºä¸€ä¸ª ``Intent`` ï¼Œå¹¶ä¼ å…¥ context ä»¥åŠç›®æ ‡ activity çš„ç±»åç§°ã€‚

   .. code:: prettyprint

      val intent = Intent(context, DetailActivity::class.java)

   æ‚¨æƒ³è¦æ˜¾ç¤ºçš„ activity çš„åç§°æ˜¯ä½¿ç”¨ ``DetailActivity::class.java`` æŒ‡å®šçš„ã€‚å®é™…çš„
   ``DetailActivity`` å¯¹è±¡ä¼šåœ¨åå°åˆ›å»ºã€‚

   4. è°ƒç”¨ ``putExtra`` æ–¹æ³•ï¼Œå¹¶ä¼ å…¥â€œletterâ€ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œä¼ å…¥æŒ‰é’®æ–‡æœ¬ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ã€‚

   .. code:: prettyprint

      intent.putExtra("letter", holder.button.text.toString())

   ä»€ä¹ˆæ˜¯ extraï¼Ÿè¯·è®°ä½ï¼Œintent åªæ˜¯ä¸€ç»„æŒ‡ä»¤ï¼Œç›®å‰è¿˜æ²¡æœ‰ç›®æ ‡ activity çš„å®ä¾‹ã€‚è€Œ extra
   æ˜¯ä¸€æ®µæ•°æ®ï¼ˆä¾‹å¦‚ä¸€ä¸ªæ•°å­—æˆ–ä¸€ä¸ªå­—ç¬¦ä¸²ï¼‰ï¼Œç³»ç»Ÿä¼šä¸ºå…¶æŒ‡å®šåç§°ï¼Œä»¥ä¾¿æ—¥åæ£€ç´¢ã€‚è¿™ç±»ä¼¼äºåœ¨è°ƒç”¨å‡½æ•°æ—¶
   ä¼ é€’å‚æ•°ã€‚ç”±äº ``DetailActivity`` å¯ä»¥é’ˆå¯¹ä»»ä½•å­—æ¯æ˜¾ç¤ºï¼Œæ‚¨éœ€è¦å‘ŠçŸ¥å®ƒæ˜¾ç¤ºå“ªä¸ªå­—æ¯ã€‚

   æ­¤å¤–ï¼Œæ‚¨è§‰å¾—ä¸ºä»€ä¹ˆéœ€è¦è°ƒç”¨ ``toString()`` ï¼ŸæŒ‰é’®æ–‡æœ¬å·²ç»æ˜¯å­—ç¬¦ä¸²äº†ï¼Œå¯¹å—ï¼Ÿ

   åœ¨æŸç§ç¨‹åº¦ä¸Šï¼Œæ˜¯çš„ã€‚å®ƒå®é™…ä¸Šæ˜¯ ``CharSequence`` ç±»å‹ï¼Œè¢«ç§°ä¸ºâ€œæ¥å£â€ã€‚ç›®å‰ï¼Œæ‚¨ä¸éœ€è¦äº†è§£æœ‰å…³ Kotlin
   æ¥å£çš„ä»»ä½•å†…å®¹ï¼Œåªè¦çŸ¥é“é€šè¿‡è¿™ç§æ–¹å¼å¯ä»¥ç¡®ä¿æŸç§ç±»å‹ï¼ˆä¾‹å¦‚å­—ç¬¦ä¸²ï¼‰ä¼šå®ç°ç‰¹å®šå‡½æ•°å’Œå±æ€§å°±è¡Œã€‚æ‚¨å¯ä»¥å°†
   ``CharSequence`` è§†ä¸ºä¸€ç§æ›´é€šç”¨çš„è¡¨ç¤ºæ–¹å¼ï¼Œä»£è¡¨ä¸€ç§ç±»ä¼¼äºå­—ç¬¦ä¸²çš„ç±»ã€‚æŒ‰é’®çš„ ``text``
   å±æ€§å¯ä»¥æ˜¯å­—ç¬¦ä¸²ï¼Œä¹Ÿå¯ä»¥æ˜¯åŒæ ·ä¸º ``CharSequence`` çš„ä»»ä½•å¯¹è±¡ã€‚ä¸è¿‡ï¼Œ ``putExtra()``
   æ–¹æ³•å¯ä»¥æ¥å— ``String`` ï¼Œè€Œä¸ä»…ä»…æ˜¯ä»»ä½• ``CharSequence`` ï¼Œå› æ­¤éœ€è¦è°ƒç”¨ ``toString()`` ã€‚

   5. å¯¹ context å¯¹è±¡è°ƒç”¨ ``startActivity()`` æ–¹æ³•ï¼Œå¹¶ä¼ å…¥ ``intent`` ã€‚

   .. code:: prettyprint

      context.startActivity(intent)

   ç°åœ¨ï¼Œè¿è¡Œåº”ç”¨å¹¶å°è¯•ç‚¹æŒ‰æŸä¸ªå­—æ¯ã€‚ç³»ç»Ÿä¼šæ˜¾ç¤ºè¯¦æƒ…å±å¹•ï¼ä½†æ˜¯ï¼Œæ— è®ºç”¨æˆ·ç‚¹æŒ‰å“ªä¸ªå­—æ¯ï¼Œè¯¦æƒ…å±å¹•
   å§‹ç»ˆä¼šæ˜¾ç¤ºå­—æ¯ A å¯¹åº”çš„å•è¯ã€‚æ‚¨ä»éœ€è¦åœ¨è¯¦æƒ… activity ä¸­æ‰§è¡Œä¸€äº›æ“ä½œï¼Œä»¥ä¾¿å®ƒé’ˆå¯¹ä½œä¸º 
   ``intent`` extra ä¼ é€’çš„ä»»æ„å­—æ¯æ˜¾ç¤ºç›¸åº”å•è¯ã€‚


6. è®¾ç½® DetailActivity
----------------------


   æ‚¨åˆšåˆšåˆ›å»ºäº†æ‚¨çš„é¦–ä¸ªæ˜¾å¼ intentï¼ç°åœ¨ï¼Œæ¥å¤„ç†è¯¦æƒ…å±å¹•ã€‚

   åœ¨ ``DetailActivity`` çš„ ``onCreate`` æ–¹æ³•ä¸­ï¼Œåœ¨å¯¹ ``setContentView``
   çš„è°ƒç”¨ä¹‹åï¼Œå°†ç¡¬ç¼–ç çš„å­—æ¯æ›¿æ¢ä¸ºç”¨äºè·å–ä» ``intent`` ä¼ å…¥çš„ ``letterId`` çš„ä»£ç ã€‚

   .. code:: prettyprint

      val letterId = intent?.extras?.getString("letter").toString()

   æ­¤å¤„æ¶‰åŠçš„å†…å®¹è¾ƒå¤šï¼Œå› æ­¤æˆ‘ä»¬é€ä¸€äº†è§£å„ä¸ªéƒ¨åˆ†ï¼š

   é¦–å…ˆï¼Œ ``intent`` å±æ€§æ¥è‡ªå“ªé‡Œï¼Ÿå®ƒä¸æ˜¯ ``DetailActivity`` çš„å±æ€§ï¼Œç›¸åï¼Œå®ƒå¯ä»¥æ˜¯ä»»æ„
   activity çš„å±æ€§ã€‚å®ƒä¼šä¿ç•™å¯¹ç”¨äºå¯åŠ¨ç›¸åº” activity çš„ intent çš„å¼•ç”¨ã€‚

   extra å±æ€§ä¸º ``Bundle`` ç±»å‹ï¼Œæ‚¨å¯èƒ½å·²ç»çŒœåˆ°ï¼Œå®ƒæä¾›äº†ä¸€ç§è®¿é—®ä¼ å…¥ç›¸åº” intent çš„æ‰€æœ‰
   extra çš„æ–¹å¼ã€‚

   è¿™ä¸¤ç§å±æ€§éƒ½ä½¿ç”¨é—®å·è¿›è¡Œäº†æ ‡è®°ã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆï¼ŸåŸå› åœ¨äºï¼Œ ``intent`` å’Œ ``extras``
   å±æ€§å¯ä¸º nullï¼Œè¿™æ„å‘³ç€å®ƒä»¬å¯èƒ½æœ‰å€¼ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰å€¼ã€‚æœ‰æ—¶ï¼Œæ‚¨å¯èƒ½å¸Œæœ›æŸä¸ªå˜é‡ä¸º
   ``null`` ã€‚å®é™…ä¸Šï¼Œ ``intent`` å±æ€§å¯èƒ½å¹¶ä¸æ˜¯ ``Intent`` ï¼ˆå¦‚æœ activity ä¸æ˜¯é€šè¿‡
   intent å¯åŠ¨ï¼‰ï¼Œextra å±æ€§ä¹Ÿå¯èƒ½å¹¶ä¸æ˜¯ ``Bundle`` ï¼Œè€Œæ˜¯ä¸€ä¸ªåä¸º ``null`` çš„å€¼ã€‚åœ¨
   Kotlin ä¸­ï¼Œ ``null`` è¡¨ç¤ºæ²¡æœ‰å€¼ã€‚ç›¸åº”å¯¹è±¡å¯èƒ½å·²å­˜åœ¨ï¼Œä¹Ÿå¯èƒ½ä¸º ``null`` ã€‚å¦‚æœæ‚¨çš„åº”ç”¨
   å°è¯•åœ¨ ``null`` å¯¹è±¡ä¸Šè®¿é—®å±æ€§æˆ–è°ƒç”¨å‡½æ•°ï¼Œåº”ç”¨å°†ä¼šå´©æºƒã€‚ä¸ºäº†å®‰å…¨åœ°è®¿é—®æ­¤å€¼ï¼Œå¯ä»¥åœ¨åç§°å
   æ·»åŠ â€œ ``?`` â€ã€‚å¦‚æœ ``intent`` ä¸º ``null`` ï¼Œæ‚¨çš„åº”ç”¨ç”šè‡³ä¸ä¼šå°è¯•è®¿é—® extra å±æ€§ï¼›
   å¦‚æœ ``extras`` ä¸º nullï¼Œæ‚¨çš„ä»£ç ç”šè‡³ä¸ä¼šå°è¯•è°ƒç”¨ ``getString()`` ã€‚

   å¦‚ä½•çŸ¥é“å“ªäº›å±æ€§éœ€è¦æ·»åŠ é—®å·ä»¥ç¡®ä¿å…¶ä¸º null
   æ—¶çš„å®‰å…¨æ€§ï¼Ÿæ‚¨å¯ä»¥æ ¹æ®ç±»å‹åç§°åè·Ÿçš„æ˜¯é—®å·è¿˜æ˜¯æ„Ÿå¹å·æ¥åˆ¤æ–­ã€‚

   |b43155b06a5556e.png|

   æœ€åè¦æ³¨æ„çš„æ˜¯ï¼Œå®é™…çš„å­—æ¯æ˜¯ä½¿ç”¨ ``getString`` æ£€ç´¢çš„ï¼Œå®ƒä¼šè¿”å›
   ``String?`` ï¼Œå› æ­¤ç³»ç»Ÿä¼šè°ƒç”¨ ``toString()`` ä»¥ç¡®ä¿ç»“æœæ˜¯ä¸€ä¸ª ``String`` ï¼Œè€Œä¸æ˜¯
   ``null`` ã€‚

   ç°åœ¨ï¼Œå½“æ‚¨è¿è¡Œåº”ç”¨å¹¶è½¬åˆ°è¯¦æƒ…å±å¹•æ—¶ï¼Œåº”è¯¥ä¼šçœ‹åˆ°æ¯ä¸ªå­—æ¯å¯¹åº”çš„å•è¯åˆ—è¡¨ã€‚

   |c465ef280fe3792a.png|


æ¸…ç†


   æ‰§è¡Œ intent çš„ä»£ç å’Œæ£€ç´¢æ‰€é€‰å­—æ¯çš„ä»£ç éƒ½å°† ``extra``
   çš„åç§°ç¡¬ç¼–ç æˆäº†â€œletterâ€ã€‚å°½ç®¡æ­¤æ–¹æ³•é€‚ç”¨äºæ­¤ç±»å°å‹ç¤ºä¾‹ï¼Œä½†å¯¹äºéœ€è¦è·Ÿè¸ªæ›´å¤š intent extra
   çš„å¤§å‹åº”ç”¨æ¥è¯´ï¼Œè¿™å¹¶éæœ€ä½³æ–¹æ³•ã€‚

   è™½ç„¶æ‚¨å¯ä»¥åªåˆ›å»ºä¸€ä¸ªåä¸ºâ€œletterâ€çš„å¸¸é‡ï¼Œä½†å½“æ‚¨å‘åº”ç”¨æ·»åŠ æ›´å¤š intent extra
   æ—¶ï¼Œä»£ç å¯èƒ½ä¼šå˜å¾—æ¯”è¾ƒåºæ‚ã€‚å¦å¤–ï¼Œæ‚¨åº”è¯¥å°†æ­¤å¸¸é‡æ”¾å…¥å“ªä¸ªç±»å‘¢ï¼Ÿè¯·è®°ä½ï¼Œè¯¥å­—ç¬¦ä¸²ä¼šåŒæ—¶ç”¨äº
   ``DetailActivity`` å’Œ
   ``MainActivity`` ã€‚æ‚¨éœ€è¦ä¸€ç§æ–¹æ³•æ¥å®šä¹‰å¸¸é‡ï¼Œä½¿å…¶èƒ½åœ¨å¤šä¸ªç±»ä¸­ä½¿ç”¨ï¼ŒåŒæ—¶ä¿æŒä»£ç çš„æ¡ç†æ€§ã€‚

   å¹¸è¿çš„æ˜¯ï¼ŒKotlin ä¸­æœ‰ä¸€ç§ä¾¿æ·çš„åŠŸèƒ½å« `ä¼´ç”Ÿå¯¹è±¡ <https://kotlinlang.org/docs/reference/object-declarations.html>`__ ï¼Œ
   å¯ç”¨æ¥åˆ†ç¦»å¸¸é‡ï¼Œä½¿å®ƒä»¬æ— éœ€ç‰¹å®šç±»å®ä¾‹å³å¯ä½¿ç”¨ã€‚ä¼´ç”Ÿå¯¹è±¡ä¸å…¶ä»–å¯¹è±¡ç±»ä¼¼ï¼Œä¾‹å¦‚æŸä¸ªç±»çš„å®ä¾‹ã€‚
   ä½†æ˜¯ï¼Œåœ¨ç¨‹åºä½¿ç”¨æœŸé—´ï¼Œåªä¼šæœ‰ä¸€ä¸ªä¼´ç”Ÿå¯¹è±¡å®ä¾‹å­˜åœ¨ï¼Œæ­£å› ä¸ºå¦‚æ­¤ï¼Œè¿™æœ‰æ—¶è¢«ç§°ä¸º `å•ä¾‹æ¨¡å¼ <https://en.wikipedia.org/wiki/Singleton_pattern>`__ ã€‚
   è™½ç„¶åœ¨æ­¤ Codelab ä¹‹å¤–æœ‰å¤§é‡å…³äºå•ä¾‹æ¨¡å¼çš„ç”¨ä¾‹ï¼Œä½†ç°åœ¨ï¼Œæ‚¨éœ€è¦ä½¿ç”¨ä¼´ç”Ÿå¯¹è±¡è¿™ç§æ–¹æ³•æ¥æ•´ç†å¸¸é‡ï¼Œ
   ä½¿å®ƒä»¬å¯ä» ``DetailActivity`` å¤–éƒ¨è®¿é—®ã€‚é¦–å…ˆï¼Œæ‚¨å°†ä½¿ç”¨ä¼´ç”Ÿå¯¹è±¡æ¥é‡æ„â€œletterâ€extra çš„ä»£ç ã€‚

   1. åœ¨ ``DetailActivity`` ä¸­ ``onCreate`` çš„ä¸Šæ–¹ï¼Œæ·»åŠ ä»¥ä¸‹ä»£ç ï¼š

   .. code:: prettyprint

      companion object {

      }

   è¯·æ³¨æ„ï¼Œè¿™ç±»ä¼¼äºå®šä¹‰ç±»ï¼Œåªä¸è¿‡æ‚¨ä½¿ç”¨çš„æ˜¯ ``object`` å…³é”®å­—ã€‚æ­¤å¤–è¿˜æœ‰å…³é”®å­—
   ``companion`` ï¼Œè¿™æ„å‘³ç€å®ƒä¸ ``DetailActivity``
   ç±»ç›¸å…³è”ï¼Œæˆ‘ä»¬æ— éœ€ä¸ºå…¶æä¾›å•ç‹¬çš„ç±»å‹åç§°ã€‚

   2. åœ¨å¤§æ‹¬å·å†…ï¼Œé’ˆå¯¹ letter å¸¸é‡æ·»åŠ ä¸€ä¸ªå±æ€§ã€‚

   .. code:: prettyprint

      const val LETTER = "letter"

   3. å¦‚éœ€ä½¿ç”¨æ–°çš„å¸¸é‡ï¼Œè¯·æ›´æ–° ``onCreate()`` ä¸­çš„ç¡¬ç¼–ç å­—æ¯è°ƒç”¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

   .. code:: prettyprint

      val letterId = intent?.extras?.getString(LETTER).toString()

   å†æ¬¡æé†’ï¼Œè¯·æ³¨æ„ï¼Œæ‚¨å¯ä»¥ç…§å¸¸ä½¿ç”¨ç‚¹è¡¨ç¤ºæ³•å¼•ç”¨è¯¥å¸¸é‡ï¼Œä½†å®ƒå±äº ``DetailActivity`` ã€‚

   4. åˆ‡æ¢åˆ° ``LetterAdapter`` ï¼Œç„¶åä¿®æ”¹å¯¹ ``putExtra`` çš„è°ƒç”¨ï¼Œä»¥ä½¿ç”¨æ–°å¸¸é‡ã€‚

   .. code:: prettyprint

      intent.putExtra(DetailActivity.LETTER, holder.button.text.toString())

   è®¾ç½®å®Œæ¯•ï¼é€šè¿‡é‡æ„ï¼Œæ‚¨è®©è‡ªå·±çš„ä»£ç æ›´æ˜“äºé˜…è¯»ï¼Œä¸”æ›´æ˜“äºç»´æŠ¤ã€‚å¦‚æœæ­¤å¸¸é‡æˆ–è€…æ‚¨æ·»åŠ çš„ä»»ä½•å…¶ä»–
   å¸¸é‡éœ€è¦æ›´æ”¹ï¼Œæ‚¨åªéœ€åœ¨ä¸€ä¸ªä½ç½®è¿›è¡Œæ›´æ”¹å³å¯ã€‚

   å¦‚éœ€è¯¦ç»†äº†è§£ä¼´ç”Ÿå¯¹è±¡ï¼Œè¯·å‚é˜…æœ‰å…³ `å¯¹è±¡è¡¨è¾¾å¼å’Œå£°æ˜ <https://kotlinlang.org/docs/reference/object-declarations.html>`__ 
   çš„ Kotlin æ–‡æ¡£ã€‚


7. è®¾ç½®éšå¼ intent
------------------


   åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæ‚¨æ˜¾ç¤ºçš„éƒ½æ˜¯è‡ªå·±åº”ç”¨ä¸­çš„ç‰¹å®š activityã€‚ä¸è¿‡ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ‚¨å¯èƒ½å¹¶ä¸çŸ¥é“
   éœ€è¦å¯åŠ¨å“ªä¸ª activity æˆ–å“ªä¸ªåº”ç”¨ã€‚åœ¨æˆ‘ä»¬çš„è¯¦æƒ…å±å¹•ä¸Šï¼Œæ¯ä¸ªå•è¯éƒ½æ˜¯ä¸€ä¸ªæŒ‰é’®ï¼Œç‚¹å‡»åéƒ½å°†æ˜¾ç¤º
   è¯¥å•è¯çš„ç”¨æˆ·å®šä¹‰ã€‚

   åœ¨æˆ‘ä»¬çš„ç¤ºä¾‹ä¸­ï¼Œæ‚¨å°†ä½¿ç”¨ Google æœç´¢æä¾›çš„å­—å…¸åŠŸèƒ½ã€‚ä¸è¿‡ï¼Œæ‚¨éœ€è¦å¯åŠ¨è®¾å¤‡çš„æµè§ˆå™¨æ¥æ˜¾ç¤º
   æœç´¢é¡µé¢ï¼Œè€Œä¸æ˜¯å‘åº”ç”¨æ·»åŠ æ–°çš„ activityã€‚

   å› æ­¤ï¼Œæ‚¨å¯èƒ½éœ€è¦ä¸€ä¸ª intentï¼Œç”¨æ¥åœ¨ Chromeï¼ˆAndroid ä¸Šçš„é»˜è®¤æµè§ˆå™¨ï¼‰ä¸­åŠ è½½ç›¸åº”é¡µé¢ï¼Œå¯¹å—ï¼Ÿ

   ä¸ä¸€å®šã€‚

   æœ‰äº›ç”¨æˆ·å¯èƒ½æ›´å–œæ¬¢ç¬¬ä¸‰æ–¹æµè§ˆå™¨ã€‚æˆ–è€…ï¼Œç”¨æˆ·çš„æ‰‹æœºä¸Šé™„å¸¦åˆ¶é€ å•†é¢„å®‰è£…çš„æµè§ˆå™¨ã€‚ä¹Ÿå¯èƒ½ä»–ä»¬å®‰è£…äº†
   Google æœç´¢åº”ç”¨ï¼Œç”šè‡³æ˜¯ç¬¬ä¸‰æ–¹å­—å…¸åº”ç”¨ã€‚

   æ‚¨æ— æ³•ç¡®å®šç”¨æˆ·å®‰è£…äº†å“ªäº›åº”ç”¨ï¼Œä¹Ÿæ— æ³•å‡è®¾ä»–ä»¬å¯èƒ½å¸Œæœ›ä»¥å“ªç§æ–¹å¼æŸ¥å•è¯ã€‚è¿™æ˜¯ä¸€ä¸ªå®Œç¾ç¤ºä¾‹ï¼Œè¯´æ˜äº†
   ä½•æ—¶åº”ä½¿ç”¨éšå¼ intentã€‚æ‚¨çš„åº”ç”¨å‘ç³»ç»Ÿæä¾›ç›¸å…³ä¿¡æ¯ï¼Œè¯´æ˜åº”æ‰§è¡Œä½•ç§æ“ä½œï¼Œç„¶åç”±ç³»ç»Ÿç¡®å®šå¦‚ä½•
   æ‰§è¡Œè¯¥æ“ä½œï¼Œå¹¶æ ¹æ®éœ€è¦æç¤ºç”¨æˆ·æä¾›ä»»ä½•å…¶ä»–ä¿¡æ¯ã€‚

   æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼Œåˆ›å»ºéšå¼ intentï¼š

   1. å¯¹äºæ­¤åº”ç”¨ï¼Œæ‚¨å°†åœ¨ Google æœç´¢ä¸­æœç´¢ç›¸åº”å•è¯ã€‚ç¬¬ä¸€ä¸ªæœç´¢ç»“æœå°†æ˜¯è¯¥å•è¯çš„å­—å…¸å®šä¹‰ã€‚
      ç”±äºæ¯æ¬¡æœç´¢éƒ½ä¼šä½¿ç”¨ç›¸åŒçš„åŸºå‡†ç½‘å€ï¼Œæœ€å¥½å°†å…¶å®šä¹‰ä¸ºè‡ªå·±çš„å¸¸é‡ã€‚åœ¨ ``DetailActivity`` ä¸­ï¼Œ
      ä¿®æ”¹ä¼´ç”Ÿå¯¹è±¡ä»¥æ·»åŠ æ–°çš„å¸¸é‡ ``SEARCH_PREFIX`` ã€‚è¿™ä¾¿æ˜¯ Google æœç´¢çš„åŸºå‡†ç½‘å€ã€‚

   .. code:: prettyprint

      companion object {
         const val LETTER = "letter"
         const val SEARCH_PREFIX = "https://www.google.com/search?q="
      }

   2. ç„¶åï¼Œæ‰“å¼€ ``WordAdapter`` ï¼Œå¹¶åœ¨ ``onBindViewHolder()`` æ–¹æ³•ä¸­å¯¹æŒ‰é’®è°ƒç”¨
      ``setOnClickListener()`` ã€‚é¦–å…ˆï¼Œä¸ºæœç´¢æŸ¥è¯¢åˆ›å»ºä¸€ä¸ª ``Uri`` ã€‚å½“è°ƒç”¨ ``parse()``
      ä»¥ä»æŸä¸ª ``String`` åˆ›å»º ``Uri`` æ—¶ï¼Œæ‚¨éœ€è¦ä½¿ç”¨å­—ç¬¦ä¸²æ ¼å¼ï¼Œä»¥ä¾¿å°†å•è¯é™„åŠ åˆ°
      ``SEARCH_PREFIX`` ã€‚

   .. code:: prettyprint

      holder.button.setOnClickListener {
          val queryUrl: Uri = Uri.parse("${DetailActivity.SEARCH_PREFIX}${item}")
      }

   URIï¼Œ Uniform Resource Identifierï¼Œè¡¨ç¤ºç»Ÿä¸€èµ„æºæ ‡è¯†ç¬¦ã€‚æ‚¨å¯èƒ½å·²ç»çŸ¥é“ï¼ŒURL
   ï¼ˆUniform Resource Locatorï¼Œè¡¨ç¤ºç»Ÿä¸€èµ„æºå®šä½ç¬¦ï¼‰æ˜¯æŒ‡å‘æŸä¸ªç½‘é¡µçš„å­—ç¬¦ä¸²ã€‚URI æ˜¯ä¸€ä¸ª
   æ›´ä¸ºå®½æ³›çš„æ ¼å¼æœ¯è¯­ã€‚æ‰€æœ‰ URL éƒ½æ˜¯ URIï¼Œä½†å¹¶éæ‰€æœ‰ URI éƒ½æ˜¯ URLã€‚å…¶ä»– URI
   ï¼ˆä¾‹å¦‚ï¼Œç”µè¯å·ç å¯¹åº”çš„åœ°å€ï¼‰å¯èƒ½ä¼šä»¥ ``tel:`` å¼€å¤´ï¼Œä½†ä¼šè¢«è§†ä¸º URN
   ï¼ˆUniform Resource Nameï¼Œè¡¨ç¤ºç»Ÿä¸€èµ„æºåç§°ï¼‰ã€‚ç”¨äºè¡¨ç¤ºè¿™ä¸¤ç§æ•°æ®çš„æ•°æ®ç±»å‹è¢«ç§°ä¸º ``URI`` ã€‚

   |828cef3fdcfdaed.png|

   è¯·æ³¨æ„ï¼Œæ­¤å¤„æ²¡æœ‰å¼•ç”¨æ‚¨è‡ªå·±åº”ç”¨ä¸­çš„ä»»ä½• activityã€‚æ‚¨åªæ˜¯æä¾›ä¸€ä¸ª
   ``URI`` ï¼Œå¹¶æœªæŒ‡æ˜å…¶æœ€ç»ˆçš„ä½¿ç”¨æ–¹å¼ã€‚

   2. å®šä¹‰ ``queryUrl`` åï¼Œåˆå§‹åŒ–æ–°çš„ ``intent`` å¯¹è±¡ï¼š

   .. code:: prettyprint

      val intent = Intent(Intent.ACTION_VIEW, queryUrl)

   æ‚¨å°† ``Intent.ACTION_VIEW`` ä¸ ``URI`` ä¸€åŒä¼ å…¥ï¼Œè€Œä¸æ˜¯ä¼ å…¥ context å’Œ activityã€‚

   ``ACTION_VIEW`` æ˜¯ä¸€ä¸ªé€šç”¨ intentï¼Œå¯ä»¥æ¥å—
   URIï¼ˆåœ¨æœ¬ä¾‹ä¸­ä¸ºç½‘å€ï¼‰ã€‚ç„¶åï¼Œç³»ç»Ÿå°±ä¼šçŸ¥é“åº”é€šè¿‡åœ¨ç”¨æˆ·çš„ç½‘ç»œæµè§ˆå™¨ä¸­æ‰“å¼€è¯¥ URI æ¥å¤„ç†æ­¤
   intentã€‚ä¸€äº›å…¶ä»– intent ç±»å‹åŒ…æ‹¬ï¼š

   -  ``CATEGORY_APP_MAPS`` - å¯åŠ¨åœ°å›¾åº”ç”¨
   -  ``CATEGORY_APP_EMAIL`` - å¯åŠ¨ç”µå­é‚®ä»¶åº”ç”¨
   -  ``CATEGORY_APP_GALLERY`` - å¯åŠ¨å›¾åº“ï¼ˆç›¸å†Œï¼‰åº”ç”¨
   -  ``ACTION_SET_ALARM`` - åœ¨åå°è®¾ç½®é—¹é’Ÿ
   -  ``ACTION_DIAL`` - æ‹¨æ‰“ç”µè¯

   å¦‚éœ€äº†è§£è¯¦æƒ…ï¼Œè¯·è®¿é—®æœ‰å…³ä¸€äº› `å¸¸ç”¨ intent çš„æ–‡æ¡£ã€‚ <https://developer.android.google.cn/guide/components/intents-common?hl=zh-cn>`__

   3. æœ€åï¼Œå³ä½¿æ‚¨ä¸å¯åŠ¨åº”ç”¨ä¸­çš„ä»»ä½•ç‰¹å®š activityï¼Œæ‚¨ä¹Ÿéœ€è¦é€šè¿‡è°ƒç”¨ ``startActivity()``
      å¹¶ä¼ å…¥ ``intent`` æ¥å‘ŠçŸ¥ç³»ç»Ÿå¯åŠ¨å…¶ä»–åº”ç”¨ã€‚

   .. code:: prettyprint

      context.startActivity(intent)

   ç°åœ¨ï¼Œå½“æ‚¨å¯åŠ¨åº”ç”¨ã€å‰å¾€å•è¯åˆ—è¡¨å¹¶ç‚¹æŒ‰å…¶ä¸­æŸä¸ªå•è¯æ—¶ï¼Œæ‚¨çš„è®¾å¤‡åº”å¯¼èˆªåˆ°ç›¸åº”ç½‘å€
   ï¼ˆæˆ–è€…æ ¹æ®æ‚¨å®‰è£…çš„åº”ç”¨æ˜¾ç¤ºé€‰é¡¹åˆ—è¡¨ï¼‰ã€‚

   å…·ä½“è¡Œä¸ºä¼šå› ç”¨æˆ·è€Œå¼‚ï¼Œæœ€ç»ˆéƒ½èƒ½ä¸ºæ‰€æœ‰ç”¨æˆ·æä¾›æ— ç¼çš„ä½“éªŒï¼Œè€Œä¸ä¼šä½¿ä»£ç å˜å¾—å¤æ‚ã€‚


8. è®¾ç½®èœå•å’Œå›¾æ ‡
-----------------


   ç°åœ¨ï¼Œæ‚¨å·²ç»é€šè¿‡æ·»åŠ æ˜¾å¼ intent å’Œéšå¼ intent ä½¿æ‚¨çš„åº”ç”¨å®ç°äº†å…¨é¢å¯å¯¼èˆªï¼Œæ¥ä¸‹æ¥è¯¥æ·»åŠ 
   èœå•é€‰é¡¹äº†ï¼Œä»¥ä¾¿ç”¨æˆ·èƒ½å¤Ÿåœ¨åˆ—è¡¨å’Œç½‘æ ¼å¸ƒå±€ä¹‹é—´åˆ‡æ¢å­—æ¯æ˜¾ç¤ºæ–¹å¼ã€‚

   ====================== ======================
   |7edb0777b033c159.png| |ce3474dba2a9c1c8.png|
   ====================== ======================

   åˆ°ç°åœ¨ï¼Œæ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼Œè®¸å¤šåº”ç”¨çš„å±å¹•é¡¶éƒ¨éƒ½æœ‰æ­¤æ ã€‚è¿™è¢«ç§°ä¸ºåº”ç”¨æ ï¼Œé™¤äº†èƒ½å¤Ÿæ˜¾ç¤ºåº”ç”¨åç§°å¤–ï¼Œ
   å®ƒè¿˜å¯ä»¥è¿›è¡Œè‡ªå®šä¹‰ï¼Œå¹¶æ‰˜ç®¡å¤§é‡å®ç”¨åŠŸèƒ½ï¼ˆä¾‹å¦‚ï¼Œå®ç”¨æ“ä½œçš„å¿«æ·æ–¹å¼æˆ–æº¢å‡ºèœå•ï¼‰ã€‚

   |dfc4095251c1466e.png|

   é’ˆå¯¹æ­¤åº”ç”¨ï¼Œå°½ç®¡æˆ‘ä»¬ä¸ä¼šæ·»åŠ åŠŸèƒ½é½å…¨çš„èœå•ï¼Œä½†æ‚¨å°†å­¦ä¹ å¦‚ä½•å‘åº”ç”¨æ æ·»åŠ è‡ªå®šä¹‰æŒ‰é’®ï¼Œä»¥ä¾¿ç”¨æˆ·èƒ½å¤Ÿæ›´æ”¹å¸ƒå±€ã€‚

   1. é¦–å…ˆï¼Œæ‚¨éœ€è¦å¯¼å…¥ä¸¤ä¸ªè¡¨ç¤ºç½‘æ ¼è§†å›¾å’Œåˆ—è¡¨è§†å›¾çš„å›¾æ ‡ã€‚æ·»åŠ è¢«ç§°ä¸ºâ€œæ¨¡å—è§†å›¾â€ï¼ˆå°†å…¶å‘½åä¸º
      **ic_grid_layout** ï¼‰å’Œâ€œåˆ—è¡¨è§†å›¾â€ï¼ˆå°†å…¶å‘½åä¸º **ic_linear_layout** ï¼‰çš„å‰ªè´´ç”»
      çŸ¢é‡èµ„æºã€‚å¦‚æœæ‚¨éœ€è¦å›é¡¾å¦‚ä½•æ·»åŠ  Material å›¾æ ‡ï¼Œè¯·æŸ¥çœ‹ `æ­¤é¡µé¢è¯´æ˜ã€‚ <https://developer.android.google.cn/codelabs/basic-android-kotlin-training-polished-user-experience?continue=https%3A%2F%2Fdeveloper.android.com%2Fcourses%2Fpathways%2Fandroid-basics-kotlin-unit-2-pathway-1%23codelab-https%3A%2F%2Fdeveloper.android.com%2Fcodelabs%2Fbasic-android-kotlin-training-polished-user-experience&hl=zh-cn#3>`__ 

   |5a01fc03113ac399.png|

   2. æ‚¨è¿˜éœ€è¦é€šè¿‡æŸç§æ–¹å¼æ¥å‘ŠçŸ¥ç³»ç»Ÿï¼Œåº”ç”¨æ ä¸­åº”æ˜¾ç¤ºå“ªäº›é€‰é¡¹ä»¥åŠåº”ä½¿ç”¨å“ªäº›å›¾æ ‡ã€‚ä¸ºæ­¤ï¼Œè¯·å³é”®ç‚¹å‡»
      **res** æ–‡ä»¶å¤¹ï¼Œç„¶åä¾æ¬¡é€‰æ‹© **New > Android Resource
      File** ï¼Œä»¥æ·»åŠ æ–°çš„èµ„æºæ–‡ä»¶ã€‚å°† **Resource Type** è®¾ç½®ä¸º ``Menu`` ï¼Œå°† **File
      Name** è®¾ç½®ä¸º ``layout_menu`` ã€‚

   |c4f83806a1aa121b.png|

   3. ç‚¹å‡» **OK** ã€‚
   4. æ‰“å¼€ **res/Menu/layout_menu** ã€‚å°† ``layout_menu.xml`` çš„å†…å®¹æ›¿æ¢ä¸ºä»¥ä¸‹ä»£ç ï¼š

   .. code:: prettyprint

      <menu xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:app="http://schemas.android.com/apk/res-auto">
         <item android:id="@+id/action_switch_layout"
             android:title="@string/action_switch_layout"
             android:icon="@drawable/ic_linear_layout"
             app:showAsAction="always" />
      </menu>

   èœå•æ–‡ä»¶çš„ç»“æ„éå¸¸ç®€å•ã€‚å°±åƒå¸ƒå±€ä»¥ç”¨äºå­˜å‚¨å„ä¸ªè§†å›¾çš„å¸ƒå±€ç®¡ç†å™¨å¼€å¤´ä¸€æ ·ï¼Œèœå• XML
   æ–‡ä»¶ä¹Ÿä»¥åŒ…å«å„ä¸ªé€‰é¡¹çš„èœå•æ ‡è®°å¼€å¤´ã€‚

   æ‚¨çš„èœå•åªæœ‰ä¸€ä¸ªæŒ‰é’®ï¼Œè¯¥æŒ‰é’®å…·æœ‰ä»¥ä¸‹å‡ ä¸ªå±æ€§ï¼š

   -  ``id`` ï¼šä¸è§†å›¾ä¸€æ ·ï¼Œèœå•é€‰é¡¹ä¹Ÿæœ‰ä¸€ä¸ª IDï¼Œä»¥ä¾¿åœ¨ä»£ç ä¸­åŠ ä»¥å¼•ç”¨ã€‚
   -  ``title`` ï¼šåœ¨æœ¬ä¾‹ä¸­ï¼Œæ­¤æ–‡æœ¬å®é™…ä¸Šå¹¶ä¸å¯è§ï¼Œä½†å®ƒå¯èƒ½æœ‰åŠ©äºå±å¹•é˜…è¯»å™¨è¯†åˆ«èœå•ã€‚
   -  ``icon`` ï¼šé»˜è®¤å€¼ä¸º
      ``ic_linear_layout`` ã€‚ä½†æ˜¯ï¼Œå½“ç”¨æˆ·é€‰æ‹©æŒ‰é’®åï¼Œç³»ç»Ÿä¾¿ä¼šåˆ‡æ¢æ˜¾ç¤ºåˆ—è¡¨å’Œç½‘æ ¼å›¾æ ‡ã€‚
   -  ``showAsAction`` ï¼šæ­¤å±æ€§å¯å‘ŠçŸ¥ç³»ç»Ÿå¦‚ä½•æ˜¾ç¤ºè¯¥æŒ‰é’®ã€‚ç”±äºè¯¥å±æ€§è¢«è®¾ç½®ä¸ºâ€œalwaysâ€ï¼Œå¯¹åº”æŒ‰é’®å°†å§‹ç»ˆæ˜¾ç¤ºåœ¨åº”ç”¨æ ä¸­ï¼Œä¸ä¼šæˆä¸ºæº¢å‡ºèœå•çš„ä¸€éƒ¨åˆ†ã€‚

   å½“ç„¶ï¼Œä»…è®¾ç½®å±æ€§å¹¶ä¸æ„å‘³ç€èœå•ä¼šæ‰§è¡Œä»»ä½•å®é™…çš„æ“ä½œã€‚

   æ‚¨ä»ç„¶éœ€è¦åœ¨ ``MainActivity.kt`` ä¸­æ·»åŠ ä¸€äº›ä»£ç ï¼Œæ‰èƒ½ä½¿èœå•æ­£å¸¸è¿è¡Œã€‚


9. å®ç°èœå•æŒ‰é’®
---------------


   è‹¥æƒ³çœ‹åˆ°èœå•æŒ‰é’®çš„å®é™…åº”ç”¨ï¼Œéœ€è¦åœ¨ ``MainActivity.kt`` ä¸­æ‰§è¡Œä¸€äº›æ“ä½œã€‚

   1. é¦–å…ˆï¼Œæœ€å¥½åˆ›å»ºä¸€ä¸ªå±æ€§æ¥è·Ÿè¸ªåº”ç”¨æ‰€å¤„çš„å¸ƒå±€çŠ¶æ€ã€‚è¿™æ ·å¯ä»¥ç®€åŒ–åˆ‡æ¢å¸ƒå±€æŒ‰é’®çš„æ“ä½œã€‚å°†é»˜è®¤å€¼è®¾ç½®ä¸º
      ``true`` ï¼Œå› ä¸ºç³»ç»Ÿå°†é»˜è®¤ä½¿ç”¨çº¿æ€§å¸ƒå±€ç®¡ç†å™¨ã€‚

   .. code:: prettyprint

      private var isLinearLayoutManager = true

   2. å½“ç”¨æˆ·åˆ‡æ¢æŒ‰é’®æ—¶ï¼Œæ‚¨éœ€è¦å°†é¡¹åˆ—è¡¨è½¬æ¢ä¸ºé¡¹ç½‘æ ¼ã€‚å¦‚æœæ‚¨å›æƒ³ä¸€ä¸‹å­¦åˆ°çš„ recycler
      è§†å›¾ç›¸å…³çŸ¥è¯†ï¼Œä¼šå‘ç°æœ‰è®¸å¤šä¸åŒçš„å¸ƒå±€ç®¡ç†å™¨ï¼Œå…¶ä¸­ ``GridLayoutManager``
      å…è®¸åœ¨å•è¡Œä¸­æ˜¾ç¤ºå¤šä¸ªé¡¹ã€‚

   .. code:: prettyprint

      private fun chooseLayout() {
          if (isLinearLayoutManager) {
              recyclerView.layoutManager = LinearLayoutManager(this)
          } else {
              recyclerView.layoutManager = GridLayoutManager(this, 4)
          }
          recyclerView.adapter = LetterAdapter()
      }

   æ­¤å¤„ä½¿ç”¨äº† ``if`` è¯­å¥æ¥åˆ†é…å¸ƒå±€ç®¡ç†å™¨ã€‚é™¤äº†è®¾ç½® ``layoutManager``
   ä¹‹å¤–ï¼Œæ­¤ä»£ç è¿˜ä¼šåˆ†é…é€‚é…å™¨ã€‚ ``LetterAdapter`` æ—¢ç”¨äºåˆ—è¡¨å¸ƒå±€ï¼Œä¹Ÿç”¨äºç½‘æ ¼å¸ƒå±€ã€‚

   3. æ‚¨æœ€åˆä½¿ç”¨ XML
      è®¾ç½®èœå•æ—¶ï¼Œæ‚¨ä¸ºå…¶æä¾›çš„æ˜¯é™æ€å›¾æ ‡ã€‚ä½†æ˜¯ï¼Œåˆ‡æ¢å¸ƒå±€åï¼Œæ‚¨åº”æ›´æ–°å›¾æ ‡ä»¥åæ˜ æ–°çš„åŠŸèƒ½ï¼Œå³å¯åˆ‡æ¢å›åˆ—è¡¨å¸ƒå±€ã€‚åœ¨æ­¤ï¼Œæ‚¨åªéœ€æ ¹æ®ä¸‹æ¬¡ç‚¹æŒ‰æŒ‰é’®æ—¶å°†åˆ‡æ¢å›çš„å¸ƒå±€ï¼Œè®¾ç½®çº¿æ€§å’Œç½‘æ ¼å¸ƒå±€å›¾æ ‡ã€‚

   .. code:: prettyprint

      private fun setIcon(menuItem: MenuItem?) {
         if (menuItem == null)
             return

         // Set the drawable for the menu icon based on which LayoutManager is currently in use

         // An if-clause can be used on the right side of an assignment if all paths return a value.
         // The following code is equivalent to
         // if (isLinearLayoutManager)
         //     menu.icon = ContextCompat.getDrawable(this, R.drawable.ic_grid_layout)
         // else menu.icon = ContextCompat.getDrawable(this, R.drawable.ic_linear_layout)
         menuItem.icon =
             if (isLinearLayoutManager)
                 ContextCompat.getDrawable(this, R.drawable.ic_grid_layout)
             else ContextCompat.getDrawable(this, R.drawable.ic_linear_layout)
      }

   å›¾æ ‡æ˜¯æ ¹æ® ``isLinearLayoutManager`` å±æ€§æœ‰æ¡ä»¶åœ°è®¾ç½®çš„ã€‚

   ä¸ºäº†ä½¿æ‚¨çš„åº”ç”¨çœŸæ­£ä½¿ç”¨èœå•ï¼Œæ‚¨éœ€è¦æ›¿æ¢å¦å¤–ä¸¤ä¸ªæ–¹æ³•ã€‚

   -  ``onCreateOptionsMenu`` ï¼šç”¨äºè†¨èƒ€é€‰é¡¹èœå•å¹¶æ‰§è¡Œä»»ä½•å…¶ä»–è®¾ç½®ã€‚
   -  ``onOptionsItemSelected`` ï¼šç”¨äºåœ¨é€‰ä¸­æŒ‰é’®åå®é™…è°ƒç”¨ ``chooseLayout()`` ã€‚

   1. æŒ‰ä»¥ä¸‹æ–¹å¼æ›¿æ¢ ``onCreateOptionsMenu`` ï¼š

   .. code:: prettyprint

      override fun onCreateOptionsMenu(menu: Menu?): Boolean {
         menuInflater.inflate(R.menu.layout_menu, menu)

         val layoutButton = menu?.findItem(R.id.action_switch_layout)
         // Calls code to set the icon based on the LinearLayoutManager of the RecyclerView
         setIcon(layoutButton)

         return true
      }

   è¿™é‡Œæ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«çš„ã€‚è†¨èƒ€è¿‡å¸ƒå±€ä¹‹åï¼Œæ‚¨éœ€è¦è°ƒç”¨ ``setIcon()``
   ä»¥ç¡®ä¿ç³»ç»Ÿæ ¹æ®å¸ƒå±€å‡†ç¡®æ˜¾ç¤ºå›¾æ ‡ã€‚æ­¤æ–¹æ³•ä¼šè¿”å›ä¸€ä¸ª ``Boolean`` ï¼ˆæ­¤å¤„è¿”å›çš„æ˜¯
   ``true`` ï¼‰ï¼Œå› ä¸ºæ‚¨æƒ³è¦åˆ›å»ºé€‰é¡¹èœå•ã€‚

   2. åªéœ€å†æ·»åŠ å¦å¤–å‡ è¡Œä»£ç ï¼Œå³å¯å®ç° ``onOptionsItemSelected`` ï¼Œå¦‚ä¸‹æ‰€ç¤ºã€‚

   .. code:: prettyprint

      override fun onOptionsItemSelected(item: MenuItem): Boolean {
         return when (item.itemId) {
             R.id.action_switch_layout -> {
                 // Sets isLinearLayoutManager (a Boolean) to the opposite value
                 isLinearLayoutManager = !isLinearLayoutManager
                 // Sets layout and icon
                 chooseLayout()
                 setIcon(item)

                 return true
             }
             //  Otherwise, do nothing and use the core event handling

             // when clauses require that all possible paths be accounted for explicitly,
             //  for instance both the true and false cases if the value is a Boolean,
             //  or an else to catch all unhandled cases.
             else -> super.onOptionsItemSelected(item)
         }
      }

   æ¯æ¬¡ç‚¹æŒ‰èœå•é¡¹æ—¶ï¼Œç³»ç»Ÿéƒ½ä¼šè°ƒç”¨æ­¤æ–¹æ³•ï¼Œå› æ­¤åŠ¡å¿…è¦æ£€æŸ¥ç‚¹æŒ‰çš„æ˜¯å“ªä¸ªèœå•é¡¹ã€‚æ‚¨åœ¨ä¸Šé¢ä½¿ç”¨äº†
   ``when`` è¯­å¥ã€‚å¦‚æœ ``id`` ä¸ ``action_switch_layout`` èœå•é¡¹åŒ¹é…ï¼Œæ‚¨å°±ä¼šå¦å®š
   ``isLinearLayoutManager`` çš„å€¼ã€‚ç„¶åï¼Œè°ƒç”¨ ``chooseLayout()`` å’Œ
   ``setIcon()`` ï¼Œä»¥ä¾¿ç›¸åº”åœ°æ›´æ–°ç•Œé¢ã€‚

   åœ¨è¿è¡Œåº”ç”¨ä¹‹å‰ï¼Œè¿˜éœ€è¦å®Œæˆä¸€é¡¹æ“ä½œã€‚ç”±äºå¸ƒå±€ç®¡ç†å™¨å’Œé€‚é…å™¨ç°åœ¨æ˜¯åœ¨ ``chooseLayout()``
   ä¸­è®¾ç½®çš„ï¼Œæ‚¨åº”æ›¿æ¢ ``onCreate()``
   ä¸­çš„ç›¸åº”ä»£ç ä»¥è°ƒç”¨æ–°çš„æ–¹æ³•ã€‚å®Œæˆæ›´æ”¹åï¼Œ ``onCreate()`` åº”å¦‚ä¸‹æ‰€ç¤ºã€‚

   .. code:: prettyprint

      override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)

         val binding = ActivityMainBinding.inflate(layoutInflater)
         setContentView(binding.root)

         recyclerView = binding.recyclerView
         // Sets the LinearLayoutManager of the recyclerview
         chooseLayout()
      }

   ç°åœ¨ï¼Œè¿è¡Œæ‚¨çš„åº”ç”¨ï¼Œæ‚¨åº”è¯¥èƒ½å¤Ÿä½¿ç”¨èœå•æŒ‰é’®åœ¨åˆ—è¡¨è§†å›¾å’Œç½‘æ ¼è§†å›¾ä¹‹é—´è¿›è¡Œåˆ‡æ¢ã€‚


10. è§£å†³æ–¹æ¡ˆä»£ç 
----------------


   æ­¤ Codelab çš„è§£å†³æ–¹æ¡ˆä»£ç å¯åœ¨ä¸‹é¢çš„é¡¹ç›®ä¸­æ‰¾åˆ°ï¼š

   **è§£å†³æ–¹æ¡ˆä»£ç ç½‘å€** ï¼š `https://github.com/google-developer-training/android-basics-kotlin-words-app <https://github.com/google-developer-training/android-basics-kotlin-words-app/tree/activities>`__

   **åŒ…å«è§£å†³æ–¹æ¡ˆä»£ç çš„åˆ†æ”¯åç§°** ï¼š ``activities``

   1. è¿›å…¥ä¸ºæ­¤é¡¹ç›®æä¾›çš„ GitHub ä»£ç åº“é¡µé¢ã€‚
   2. éªŒè¯åˆ†æ”¯åç§°æ˜¯å¦ä¸æ­¤ Codelab
      ä¸­æŒ‡å®šçš„åˆ†æ”¯åç§°ä¸€è‡´ã€‚ä¾‹å¦‚ï¼Œåœ¨ä»¥ä¸‹å±å¹•æˆªå›¾ä¸­ï¼Œåˆ†æ”¯åç§°ä¸º **main** ã€‚

   |1e4c0d2c081a8fd2.png|

   3. åœ¨é¡¹ç›®çš„ GitHub é¡µé¢ä¸Šï¼Œç‚¹å‡» **Code** æŒ‰é’®ï¼Œä»¥æ‰“å¼€ä¸€ä¸ªå¼¹å‡ºå¼çª—å£ã€‚

   |1debcf330fd04c7b.png|

   4. åœ¨å¼¹å‡ºå¼çª—å£ä¸­ï¼Œç‚¹å‡» **Download ZIP** æŒ‰é’®ï¼Œå°†é¡¹ç›®ä¿å­˜åˆ°è®¡ç®—æœºä¸Šã€‚ç­‰å¾…ä¸‹è½½å®Œæˆã€‚
   5. åœ¨è®¡ç®—æœºä¸Šæ‰¾åˆ°è¯¥æ–‡ä»¶ï¼ˆå¾ˆå¯èƒ½åœ¨ **Downloads** æ–‡ä»¶å¤¹ä¸­ï¼‰ã€‚
   6. åŒå‡» ZIP æ–‡ä»¶è¿›è¡Œè§£å‹ç¼©ã€‚ç³»ç»Ÿå°†åˆ›å»ºä¸€ä¸ªåŒ…å«é¡¹ç›®æ–‡ä»¶çš„æ–°æ–‡ä»¶å¤¹ã€‚


åœ¨ Android Studio ä¸­æ‰“å¼€é¡¹ç›®


   1. å¯åŠ¨ Android Studioã€‚
   2. åœ¨ **Welcome to Android Studio** çª—å£ä¸­ï¼Œç‚¹å‡» **Open** ã€‚

   |d8e9dbdeafe9038a.png|

   æ³¨æ„ï¼šå¦‚æœ Android Studio å·²ç»æ‰“å¼€ï¼Œåˆ™æ”¹ä¸ºä¾æ¬¡é€‰æ‹© **File** > **Open** èœå•é€‰é¡¹ã€‚

   |8d1fda7396afe8e5.png|

   3. åœ¨æ–‡ä»¶æµè§ˆå™¨ä¸­ï¼Œå‰å¾€è§£å‹ç¼©çš„é¡¹ç›®æ–‡ä»¶å¤¹æ‰€åœ¨çš„ä½ç½®ï¼ˆå¾ˆå¯èƒ½åœ¨ **Downloads**
      æ–‡ä»¶å¤¹ä¸­ï¼‰ã€‚
   4. åŒå‡»è¯¥é¡¹ç›®æ–‡ä»¶å¤¹ã€‚
   5. ç­‰å¾… Android Studio æ‰“å¼€é¡¹ç›®ã€‚
   6. ç‚¹å‡» **Run** æŒ‰é’® |8de56cba7583251f.png| ä»¥æ„å»ºå¹¶è¿è¡Œåº”ç”¨ã€‚è¯·ç¡®ä¿è¯¥åº”ç”¨æŒ‰é¢„æœŸæ„å»ºã€‚


11. æ€»ç»“
--------


   -  æ˜¾å¼ intent ç”¨äºå¯¼èˆªåˆ°åº”ç”¨ä¸­çš„ç‰¹å®š activityã€‚
   -  éšå¼ intent å¯¹åº”äºç‰¹å®šçš„æ“ä½œï¼ˆä¾‹å¦‚æ‰“å¼€é“¾æ¥æˆ–å…±äº«å›¾ç‰‡ï¼‰ï¼Œå¹¶è®©ç³»ç»Ÿæ¥ç¡®å®šæ‰§è¡Œç›¸åº”
      intent çš„æ–¹å¼ã€‚
   -  å€ŸåŠ©èœå•é€‰é¡¹ï¼Œæ‚¨å¯ä»¥å‘åº”ç”¨æ æ·»åŠ æŒ‰é’®å’Œèœå•ã€‚
   -  ä¼´ç”Ÿå¯¹è±¡æä¾›äº†ä¸€ç§å°†å¯é‡å¤ä½¿ç”¨çš„å¸¸é‡ä¸æŸç§ç±»å‹ï¼ˆè€Œä¸æ˜¯è¯¥ç±»å‹çš„å®ä¾‹ï¼‰ç›¸å…³è”çš„æ–¹å¼ã€‚

   æ‰§è¡Œ intent çš„æ–¹æ³•å¦‚ä¸‹ï¼š

   -  è·å–å¯¹ context çš„å¼•ç”¨ã€‚
   -  åˆ›å»ºä¸€ä¸ª ``Intent`` å¯¹è±¡ï¼Œå¹¶æä¾› activity æˆ– intent
      ç±»å‹ï¼ˆå…·ä½“å–å†³äºæ˜¯æ˜¾å¼è¿˜æ˜¯éšå¼ï¼‰ã€‚
   -  é€šè¿‡è°ƒç”¨ ``putExtra()`` ä¼ é€’ä»»ä½•éœ€è¦çš„æ•°æ®ã€‚
   -  è°ƒç”¨ ``startActivity()`` ï¼ŒåŒæ—¶ä¼ å…¥ ``intent`` å¯¹è±¡ã€‚


12. äº†è§£æ›´å¤šå†…å®¹
----------------


   -  `intent å’Œ intent è¿‡æ»¤å™¨ <https://developer.android.google.cn/guide/components/intents-filters?hl=zh-cn>`__
   -  `å¸¸ç”¨ intent <https://www.google.com/search?client=safari&rls=en&q=common+intents+android&ie=UTF-8&oe=UTF-8&hl=zh-cn>`__
   -  `ä½¿ç”¨ XML åˆ›å»ºé€‰é¡¹èœå• <https://developer.android.google.cn/guide/topics/ui/menus?hl=zh-cn>`__
   -  `Kotlin ä¸­çš„æ¥å£ <https://kotlinlang.org/docs/reference/interfaces.html>`__
   -  `CharSequence æ¥å£ <https://developer.android.google.cn/reference/java/lang/CharSequence?hl=zh-cn>`__
   -  `Kotlin ä¸­çš„ null å®‰å…¨æ€§ <https://kotlinlang.org/docs/reference/null-safety.html>`__
   -  `Kotlin ä¸­çš„å¯¹è±¡è¡¨è¾¾å¼å’Œå£°æ˜ <https://kotlinlang.org/docs/reference/object-declarations.html>`__
   -  `å•ä¾‹æ¨¡å¼ <https://en.wikipedia.org/wiki/Singleton_pattern>`__
   -  `Kotlin ä¸­çš„æ§åˆ¶æµ <https://kotlinlang.org/docs/reference/control-flow.html>`__

.. |7edb0777b033c159.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/7edb0777b033c159_1920.png
.. |c465ef280fe3792a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/c465ef280fe3792a_1920.png
.. |8ad271362c0a113b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/8ad271362c0a113b_1920.png
.. |1e4c0d2c081a8fd2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/1e4c0d2c081a8fd2_1920.png
.. |1debcf330fd04c7b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/1debcf330fd04c7b_1920.png
.. |d8e9dbdeafe9038a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/d8e9dbdeafe9038a_1920.png
.. |8d1fda7396afe8e5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/8d1fda7396afe8e5_1920.png
.. |8de56cba7583251f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/8de56cba7583251f_1920.png
.. |61af34429128695e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/61af34429128695e_1920.png
.. |ce3474dba2a9c1c8.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/ce3474dba2a9c1c8_1920.png
.. |7edb0777b033c159.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/7edb0777b033c159_1920.png
.. |c465ef280fe3792a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/c465ef280fe3792a_1920.png
.. |e9c77033d9224170.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/e9c77033d9224170_1920.png
.. |702236c6e2276f91.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/702236c6e2276f91_1920.png
.. |b43155b06a5556e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/b43155b06a5556e_1920.png
.. |c465ef280fe3792a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/c465ef280fe3792a_1920.png
.. |828cef3fdcfdaed.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/828cef3fdcfdaed_1920.png
.. |7edb0777b033c159.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/7edb0777b033c159_1920.png
.. |ce3474dba2a9c1c8.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/ce3474dba2a9c1c8_1920.png
.. |dfc4095251c1466e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/dfc4095251c1466e_1920.png
.. |5a01fc03113ac399.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/5a01fc03113ac399_1920.png
.. |c4f83806a1aa121b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-activities-intents/img/c4f83806a1aa121b_1920.png


ğŸŸ© TOC - Quick Guides
=====================

https://developer.android.google.cn/quick-guides

Quick Guides :sup:`beta`

   Quick guides are a new type of documentation for Android
   developers, designed to help you meet your goals in a fast and
   focused way.

   Contents include Collections, Individual guides, Video HowTo.


Have questions or feedback

   Go to our frequently asked questions page and learn about
   quick guides or reach out and let us know your thoughts.

   `Go to FAQ <https://developer.android.google.cn/quick-guides/faq>`__
   `Leave feedback <https://issuetracker.google.com/issues/new?component=1573691&template=1993320>`__


Collections
-----------

   *  Display text

      https://developer.android.google.cn/quick-guides/collections/display-text
      Enhance your app's usability and aesthetic appeal by customizing the 
      way it displays text

   *  Display images

      https://developer.android.google.cn/quick-guides/collections/display-images
      Work with images onscreen using a vector, bitmap, or directly drawing 
      with a canvas on screen

   *  Display a list or grid

      https://developer.android.google.cn/quick-guides/collections/display-a-list-or-grid
      Display and arrange collections of items efficiently with lists and grids

   *  Display interactive components

      https://developer.android.google.cn/quick-guides/collections/display-interactive-components
      Use composable functions to implement Material Design components.

   *  Create a home screen scaffold

      https://developer.android.google.cn/quick-guides/collections/create-a-home-screen-scaffold
      Conveniently add standard UI elements and follow Material Design guidelines

   *  Compose Basics

      https://developer.android.google.cn/quick-guides/collections/compose-basics
      This series of videos introduces various Compose APIs, quickly showing 
      you what's available and how to use them.

   *  Request user input

      https://developer.android.google.cn/quick-guides/collections/request-user-input
      Make your app interactive by enabling users to enter text and other inputs


Individual Guides
-----------------

   *  Create a scaffold component to hold the UI together

      https://developer.android.google.cn/quick-guides/content/create-scaffold
      A scaffold provides holds together different parts of the UI, such as 
      app bars and floating action buttons, giving apps a coherent look and feel.

   *  Create a slide-in menu with the navigation drawer component

      https://developer.android.google.cn/quick-guides/content/create-navigation-drawer
      A navigation drawer is a slide-in navigation menu.

   *  Create a button

      https://developer.android.google.cn/quick-guides/content/create-button
      A button triggers a specific action.

   *  Add a switch that users can toggle

      https://developer.android.google.cn/quick-guides/content/add-toggle-switch
      You can use a toggle switch to let users choose one of two states.

   *  Create a chip to represent complex entities

      https://developer.android.google.cn/quick-guides/content/create-chip
      A chip component visually represents complex entities, often with an 
      icon and a label.

   *  Create a notification with a snackbar

      https://developer.android.google.cn/quick-guides/content/create-snackbar-notification
      A snackbar shows a brief notification at the bottom of the screen.

   *  Create a card as a container

      https://developer.android.google.cn/quick-guides/content/create-card-as-container
      A card provides a Material Design container for your UI.

   *  Display an app bar

      https://developer.android.google.cn/quick-guides/content/display-app-bar
      An app bar is a container at the top or bottom of the screen that 
      contains key features and navigation items.

   *  Create a progress indicator

      https://developer.android.google.cn/quick-guides/content/create-progress-indicator
      A progress indicator shows the status of an operation.

   *  Create a floating action button (FAB)

      https://developer.android.google.cn/quick-guides/content/create-floating-action-button
      A floating action button lets the user perform a primary action in the app.

   *  Display pop-up messages or requests for user input

      https://developer.android.google.cn/quick-guides/content/display-user-input
      Dialogs display pop-up messages or request user input on a layer above 
      the main app content.

   *  Create a bottom sheet

      https://developer.android.google.cn/quick-guides/content/create-bottom-sheet
      A bottom sheet shows secondary content at the bottom of the screen.

   *  Create a slider for a range of values

      https://developer.android.google.cn/quick-guides/content/create-range-slider
      A range slider lets users make selections from a range of values.

   *  Display an animated image

      https://developer.android.google.cn/quick-guides/content/display-animated-image
      You can create a more interactive and engaging user experience in your 
      app by loading a drawable file to display animated images. Animated images
      are useful for creating loading indicators, success or error indicators,
      facilitating game development, and various other UI functions.

   *  Create a scrollable grid

      https://developer.android.google.cn/quick-guides/content/create-scrollable-grid
      You can manage large datasets and dynamic content with lazy 
      grids, improving app performance. With lazy grid composables, you can
      display items in a scrollable container, spanned across multiple columns
      or rows.

   *  Display a bottom app bar

      https://developer.android.google.cn/quick-guides/content/display-bottom-app-bar
      Create a bottom app bar to help users navigate and access functions 
      in your app.

   *  Style parts of text

      https://developer.android.google.cn/quick-guides/content/style-parts-text
      You can style parts of text to improve readability, increase positive 
      user experience, and encourage greater creativity through use of colors
      and fonts.

   *  Display a paging list

      https://developer.android.google.cn/quick-guides/content/display-paging-list
      Create a paging list so that users can scroll to access content too 
      large to fit on a single screen. Horizontal paging lists can help users
      navigate through content such as images, slideshows, or product carousels.
      Vertical paging lists are useful for content-heavy apps where users may 
      need to scroll through a large number of items, such as articles.

   *  Create a button to enable snap scrolling

      https://developer.android.google.cn/quick-guides/content/enable-snap-scrolling
      You can display a button to let a user snap scroll to a specific point 
      in a list, saving time and increasing user engagement.

   *  Animate character-by-character the appearance of text

      https://developer.android.google.cn/quick-guides/content/animate-text
      You can animate, character-by-character, the appearance of text, so 
      it looks like a streaming typing effect.

   *  Show or hide password based on a user toggle

      https://developer.android.google.cn/quick-guides/content/show-hide-password
      You can create an icon to hide or show a password based on a user 
      toggle to improve security and enhance the user experience.

   *  Display a top app bar

      https://developer.android.google.cn/quick-guides/content/display-top-app-bar
      Create a top app bar to help users navigate and access functions in 
      your app, using the TopAppBar composable.

   *  Support multiple links in a single string of text

      https://developer.android.google.cn/quick-guides/content/support-multiple-links
      You can support multiple links in a single string of text to give 
      users options where to go and increase engagement.

   *  Create a finite scrollable list

      https://developer.android.google.cn/quick-guides/content/finite-scrolling-list
      Scrollable lists can help manage datasets, create responsive designs, 
      and facilitate navigation. To display a finite collection of items in your
      app, you can create a scrollable list using the `verticalScroll` or 
      horizontalScroll` modifiers.

   *  Build a list using multiple item types

      https://developer.android.google.cn/quick-guides/content/build-list-multiple-item-types
      You can use a list with multiple item types to display mixed content 
      types such as text, images, and interactive elements.

   *  Create a parallax scrolling effect

      https://developer.android.google.cn/quick-guides/content/parallax-scrolling
      Parallax scrolling is a technique in which the background content 
      and foreground content scroll at different speeds. You can implement this
      technique to enhance your app's UI, creating a more dynamic experience as
      your users scroll.

   *  Display an image clipped to a shape

      https://developer.android.google.cn/quick-guides/content/clipped-image
      You can draw shadows around the clipped area of the image so that you 
      can display an image in the shape of a clip.

   *  Validate input as the user types

      https://developer.android.google.cn/quick-guides/content/validate-input
      You can validate input as the user types in a text field, such as 
      entering a name, email, address, or other contact information. This
      validation reduces errors and saves your users time.

   *  Auto-format a phone number in a text field

      https://developer.android.google.cn/quick-guides/content/auto-format-phone-number
      You can auto format a phone number in a text field to save time 
      and increase user engagement, productivity, and efficiency.

   *  Load and display images

      https://developer.android.google.cn/quick-guides/content/load-images
      To display images in your app for content and for responses to 
      user actions, load the images from the disk or from an external source on
      the internet.

   *  Display layered images on a canvas

      https://developer.android.google.cn/quick-guides/content/display-layered-image
      You can blend or overlay source images to display layered images on 
      a canvas. For example, you can replicate how the Android Framework
      generates app icons by combining separate background and foreground
      drawables.

   *  Lazily load data with lists and Paging

      https://developer.android.google.cn/quick-guides/content/lazily-load-list
      Use the Paging library to support large lists of itemsâ€”including 
      an infinite listâ€”in your app by loading and displaying data incrementally.
      With lazy loading, you can reduce initial load times and optimize memory
      usage, enhancing performance.

   *  Display nested scrolling items in a list

      https://developer.android.google.cn/quick-guides/content/display-nested-list
      You can display nested scrolling items within a list to present 
      complex layouts, such as product catalogs, media galleries, news feeds,
      and more. Presenting content in this way can enhance the usability of your
      app, making it easier for users to navigate.

   *  Add a custom page indicator

      https://developer.android.google.cn/quick-guides/content/custom-page-indicator
      Using page indicators, you can help your users understand their 
      current position within your app's content, providing a visual indication
      of progress.

Videos
------

   *  Accessibility in Compose

      https://developer.android.google.cn/quick-guides/content/video/accessibility-in-compose
      Add accessibility features to your app. See how to increase your app'
      s reach and versatility with a small amount of work.

   *  Lazy lists in Compose

      https://developer.android.google.cn/quick-guides/content/video/lazy-lists-compose
      Compose gives you a simpler and more-performant way of creating 
      scrolling lists, using fewer lines of code than RecyclerView. Learn how to
      use lazy layouts to create lists that let add content to lists, on demand.

   *  Testing in Compose

      https://developer.android.google.cn/quick-guides/content/video/testing-in-compose
      Build your first Jetpack Compose tests. Learn how to use Compose's 
      testing artifacts to write UI tests, use test rules, finders, and
      assertions.

   *  Advanced layouts in Compose

      https://developer.android.google.cn/quick-guides/content/video/advanced-layouts-compose
      See how to build complex designs for your Compose layouts, focusing 
      on layout phase and constraints, subcompose layouts, and intrinsic
      measurements.

   *  Five quick animations in Compose

      https://developer.android.google.cn/quick-guides/content/video/five-animations-compose
      These 5 quick and easy animations can help make your app come to life 
      in just a few minutes. Make your Compose app stand out even if you don't
      have the time to learn everything there is to know about animations.

   *  Intro to drawing in Compose

      https://developer.android.google.cn/quick-guides/content/video/drawing-in-compose
      After you're comfortable working in Compose, you might want to 
      start drawing your own custom components. This video covers how to get
      started with custom drawing.

   *  Insets in Compose

      https://developer.android.google.cn/quick-guides/content/video/insets-in-compose
      Learn how insets communicate to your app where system decorations 
      are placed, and how Compose APIs help your content automatically move with
      the system bars, software keyboard, and the taskbar. Don't be afraid to go
      edge-to-edge!

   *  Draw text in Compose

      https://developer.android.google.cn/quick-guides/content/video/draw-text-compose
      See how to use Compose APIs specifically designed to draw text on 
      a canvas. This segment shows the code to draw an emoji font in a rounded
      rectangle.

   *  Lists in Compose

      https://developer.android.google.cn/quick-guides/content/video/lists-in-compose
      Explore Compose's Lazy components that make it easy to display lists 
      of items. Learn how to show different item types and even how to implement
      sticky headers. See how to programmatically control or react to the scroll
      position changes.

   *  Animation in Compose

      https://developer.android.google.cn/quick-guides/content/video/animation-in-compose
      See how to animate state values, using transitions, animating 
      visibility or size changes and crossfades by using the Compose animation
      APIs.

   *  State in Compose

      https://developer.android.google.cn/quick-guides/content/video/state-in-compose
      Learn how state flows through your Compose-based app and how the 
      framework can automatically update UI to display new values. See how to
      create observable states, how to retain state across recompositions or
      configuration changes, and how to structure your composables for optimal 
      data flow.

   *  Debugging recomposition in Compose

      https://developer.android.google.cn/quick-guides/content/video/debugging-recomposition
      A look into debugging a performance issue in Jetsnack and how to fix it 
      in Jetpack Compose. Learn why deferring state reads by using a lambda
      means composition can be skipped.


â­ Create a scaffold component to hold the UI together
======================================================

https://developer.android.google.cn/quick-guides/content/create-scaffold?hl=en

   In Material Design, a scaffold is a fundamental structure that provides a
   standardized platform for complex user interfaces. It holds together
   different parts of the UI, such as app bars and floating action buttons,
   giving apps a coherent look and feel.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Create a scaffold
-----------------

   The following example provides a full example of how you might implement
   `Scaffold </reference/kotlin/androidx/compose/material/package-summary#Scaffold(androidx.compose.foundation.layout.WindowInsets,androidx.compose.ui.Modifier,androidx.compose.material.ScaffoldState,kotlin.Function0,kotlin.Function0,kotlin.Function1,kotlin.Function0,androidx.compose.material.FabPosition,kotlin.Boolean,kotlin.Function1,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.ui.unit.Dp,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function1)>`__.
   It contains a top app bar, bottom app bar, and a floating action button that
   interacts with ``Scaffold``'s internal state.


      .. code:: prettyprint

         @Composable
         fun ScaffoldExample() {
             var presses by remember { mutableIntStateOf(0) }

             Scaffold(
                 topBar = {
                     TopAppBar(
                         colors = topAppBarColors(
                             containerColor = MaterialTheme.colorScheme.primaryContainer,
                             titleContentColor = MaterialTheme.colorScheme.primary,
                         ),
                         title = {
                             Text("Top app bar")
                         }
                     )
                 },
                 bottomBar = {
                     BottomAppBar(
                         containerColor = MaterialTheme.colorScheme.primaryContainer,
                         contentColor = MaterialTheme.colorScheme.primary,
                     ) {
                         Text(
                             modifier = Modifier
                                 .fillMaxWidth(),
                             textAlign = TextAlign.Center,
                             text = "Bottom app bar",
                         )
                     }
                 },
                 floatingActionButton = {
                     FloatingActionButton(onClick = { presses++ }) {
                         Icon(Icons.Default.Add, contentDescription = "Add")
                     }
                 }
             ) { innerPadding ->
                 Column(
                     modifier = Modifier
                         .padding(innerPadding),
                     verticalArrangement = Arrangement.spacedBy(16.dp),
                 ) {
                     Text(
                         modifier = Modifier.padding(8.dp),
                         text =
                         """
                             This is an example of a scaffold. It uses the Scaffold composable's parameters to create a screen with a simple top app bar, bottom app bar, and floating action button.

                             It also contains some basic inner content, such as this text.

                             You have pressed the floating action button $presses times.
                         """.trimIndent(),
                     )
                 }
             }
         } // Scaffold.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/scaffold.png
      :alt: An implementation of scaffold that contains simple top and bottom
      app bars, as well as a floating action button that iterates a counter. The
      inner content of the scaffold is simple text that explains the component.
      :width: 100.0%

      **Figure 1.** An implementation of scaffold.


Key points
----------

   The `Scaffold </reference/kotlin/androidx/compose/material/ScaffoldState>`__
   composable provides a straightforward API you can use to quickly assemble
   your app's structure according to Material Design guidelines. ``Scaffold``
   accepts several composables as parameters. Among these are the following:

   -  ``topBar``: The app bar across the top of the screen.
   -  ``bottomBar``: The app bar across the bottom of the screen.
   -  ``floatingActionButton``: A button that hovers over the bottom-right
      corner of the screen that you can use to expose key actions.

   For more detailed examples on how you can implement both top and bottom app
   bars, see the app bars page.

   You can also pass ``Scaffold`` content as you would to other containers. It
   passes an ``innerPadding`` value to the ``content`` lambda that you can then
   use in child composables.


â­ Create a slide-in menu with the navigation drawer component
==============================================================

https://developer.android.google.cn/quick-guides/content/create-navigation-drawer?hl=en

   The `navigation drawer <https://material.io/components/navigation-drawer>`__
   component is a slide-in menu that lets users navigate to various sections of
   your app. Users can activate it by swiping from the side or tapping a menu
   icon.

   Consider these three use cases for implementing a navigation drawer:

   -  **Content organization:** Enable users to switch between different
      categories, such as in news or blogging apps.
   -  **Account management:** Provide quick links to account settings and
      profile sections in apps with user accounts.
   -  **Feature discovery:** Organize multiple features and settings in a single
      menu to facilitate user discovery and access in complex apps.

   In Material Design, there are two types of navigation drawers:

   -  **Standard:** Share space within a screen with other content.
   -  **Modal:** Appears over the top of other content within a screen.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Implement a navigation drawer
-----------------------------

   You can use the `ModalNavigationDrawer </reference/kotlin/androidx/compose/material3/package-summary#ModalNavigationDrawer(kotlin.Function0,androidx.compose.ui.Modifier,androidx.compose.material3.DrawerState,kotlin.Boolean,androidx.compose.ui.graphics.Color,kotlin.Function0)>`__
   composable to implement a navigation drawer:


      .. code:: prettyprint

         ModalNavigationDrawer(
             drawerContent = {
                 ModalDrawerSheet {
                     Text("Drawer title", modifier = Modifier.padding(16.dp))
                     Divider()
                     NavigationDrawerItem(
                         label = { Text(text = "Drawer Item") },
                         selected = false,
                         onClick = { /*TODO*/ }
                     )
                     // ...other drawer items
                 }
             }
         ) {
             // Screen content
         } // MaterialLayoutSnippets.kt


Key points
----------

   -  Use the ``drawerContent`` slot to provide a `ModalDrawerSheet </reference/kotlin/androidx/compose/material3/package-summary#ModalDrawerSheet(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.WindowInsets,kotlin.Function1)>`__
      and provide the drawer's contents.

   -  ``ModalNavigationDrawer`` accepts a number of additional drawer
      parameters. For example, you can toggle whether or not the drawer responds
      to drags with the ``gesturesEnabled`` parameter as in the following
      example:

      .. container:: iframe

         .. code:: prettyprint

            ModalNavigationDrawer(
                drawerContent = {
                    ModalDrawerSheet {
                        // Drawer contents
                    }
                },
                gesturesEnabled = false
            ) {
                // Screen content
            }MaterialLayoutSnippets.kt


Control navigation drawer behavior
----------------------------------

   To control how the drawer opens and closes, use `DrawerState </reference/kotlin/androidx/compose/material3/DrawerState>`__:


      .. code:: prettyprint

         val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
         val scope = rememberCoroutineScope()
         ModalNavigationDrawer(
             drawerState = drawerState,
             drawerContent = {
                 ModalDrawerSheet { /* Drawer content */ }
             },
         ) {
             Scaffold(
                 floatingActionButton = {
                     ExtendedFloatingActionButton(
                         text = { Text("Show drawer") },
                         icon = { Icon(Icons.Filled.Add, contentDescription = "") },
                         onClick = {
                             scope.launch {
                                 drawerState.apply {
                                     if (isClosed) open() else close()
                                 }
                             }
                         }
                     )
                 }
             ) { contentPadding ->
                 // Screen content
             }
         } // MaterialLayoutSnippets.kt


Key points
----------

   -  Pass a ``DrawerState`` to ``ModalNavigationDrawer`` using the
      ``drawerState`` parameter.
   -  ``DrawerState`` provides access to the `open </reference/kotlin/androidx/compose/material3/DrawerState#open>`__
      and `close </reference/kotlin/androidx/compose/material3/DrawerState#close>`__
      functions, as well as properties related to the current drawer state.
      These suspending functions require a ``CoroutineScope``, which you can
      instantiate using `rememberCoroutineScope </reference/kotlin/androidx/compose/runtime/package-summary#remembercoroutinescope>`__.
      You can also call the suspending functions in response to UI events.


Results

   .. image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/material/m3-navigation-drawer.png
   
      **Figure 1.** A standard navigation drawer (left) and a modal navigation
      drawer (right).


â­ Create a button
==================

https://developer.android.google.cn/quick-guides/content/create-button?hl=en

   Buttons let the user trigger a defined action. There are five types of
   button:

   ========== ==================================================================
   Type        Appearance                                     - Purpose
   ========== ==================================================================
   `Filled`    Solid background with contrasting text.
               - For primary actions, such as "Submit" and "Save." The shadow effect
                 emphasizes the button's importance.

   `Tonal`     Background color varies to match the sur face
               - For primary or significant actions. Filled buttons provide visual
                 weight and are appropriate for actions like "Add to cart" and "Sign in."

   `Elevated`  Shadow makes it stand out.
               - For primary or significant actions. Increase elevation to make the
                 button more prominent.

   `Outlined`  Features a border with no fill.
               - For actions that are important but not primary. Outlined buttons pair
                 well with other buttons to indicate alternative, secondary actions
                 like "Cancel" or "Back."

   `Text`      Text with no background or border.
               - For less critical actions such as navigational links, or secondary
                 actions like "Learn more" or "View details."
   ========== ==================================================================

Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Create a filled button
----------------------

   The filled button component uses the basic `Button </reference/kotlin/androidx/compose/material3/package-summary?#Button(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.material3.ButtonColors,androidx.compose.material3.ButtonElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.layout.PaddingValues,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function1)>`__
   composable. It is filled with a solid color by default.


      .. code:: prettyprint

         @Composable
         fun FilledButtonExample(onClick: () -> Unit) {
             Button(onClick = { onClick() }) {
                 Text("Filled")
             }
         } // Button.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/button-filled.png
      :alt: A filled button with a purple background that reads, 'filled'.
      :width: 200px

      **Figure 1.** A filled button.


Create a filled tonal button
----------------------------

   The filled tonal button component uses the `FilledTonalButton </reference/kotlin/androidx/compose/material3/package-summary#FilledTonalButton(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.material3.ButtonColors,androidx.compose.material3.ButtonElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.layout.PaddingValues,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function1)>`__
   composable. It is filled with a tonal color by default.


      .. code:: prettyprint

         @Composable
         fun FilledTonalButtonExample(onClick: () -> Unit) {
             FilledTonalButton(onClick = { onClick() }) {
                 Text("Tonal")
             }
         } // Button.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/button-tonal.png
      :alt: A tonal button with a light purple background that reads, 'filled'.
      :width: 200px

      **Figure 2.** A tonal button.


Create an outlined button
-------------------------

   The outlined button component uses the `OutlinedButton </reference/kotlin/androidx/compose/material3/package-summary#OutlinedButton(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.material3.ButtonColors,androidx.compose.material3.ButtonElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.layout.PaddingValues,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function1)>`__
   composable. It appears with an outline by default.


      .. code:: prettyprint

         @Composable
         fun OutlinedButtonExample(onClick: () -> Unit) {
             OutlinedButton(onClick = { onClick() }) {
                 Text("Outlined")
             }
         } // Button.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/button-outlined.png
      :alt: A transparent outlined button with a dark border that reads,
      'Outlined'.
      :width: 200px

      **Figure 3.** An outlined button.


Create an elevated button
-------------------------

   The elevated button component uses the `ElevatedButton </reference/kotlin/androidx/compose/material3/package-summary#ElevatedButton(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.material3.ButtonColors,androidx.compose.material3.ButtonElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.layout.PaddingValues,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function1)>`__
   composable. It has a shadow that represents the elevation effect by default
   and appears as an outlined button with a shadow.


      .. code:: prettyprint

         @Composable
         fun ElevatedButtonExample(onClick: () -> Unit) {
             ElevatedButton(onClick = { onClick() }) {
                 Text("Elevated")
             }
         } // Button.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/button-elevated.png
      :alt: An elevated button with a gray background that reads, 'Elevated'.
      :width: 200px

      **Figure 4.** An elevated button.


Create a text button
--------------------

   The text button component uses the `TextButton </reference/kotlin/androidx/compose/material3/package-summary#TextButton(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.material3.ButtonColors,androidx.compose.material3.ButtonElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.layout.PaddingValues,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function1)>`__
   composable. Until clicked, it appears only as text. It does not have a solid
   fill or outline by default.


      .. code:: prettyprint

         @Composable
         fun TextButtonExample(onClick: () -> Unit) {
             TextButton(
                 onClick = { onClick() }
             ) {
                 Text("Text Button")
             }
         } // Button.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/button-text.png
      :alt: A text button that reads 'Text Button'
      :width: 200px

      **Figure 5.** A text button.


Key points
----------

   -  ``onClick``: The function called when the user presses the button.
   -  ``enabled``: When false, this parameter causes the button to appear unavailable and inactive.
   -  ``colors``: An instance of ``ButtonColors`` that determines the colors used in the button.
   -  ``contentPadding``: The padding within the button.


â­ Add a switch that users can toggle
=====================================

https://developer.android.google.cn/quick-guides/content/add-toggle-switch?hl=en

   The `Switch </reference/kotlin/androidx/compose/material3/package-summary#Switch(kotlin.Boolean,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Boolean,androidx.compose.material3.SwitchColors,androidx.compose.foundation.interaction.MutableInteractionSource)>`__
   component lets users toggle between two states: checked and unchecked. Use a
   switch to let the user to do one of the following:

   -  Toggle a setting on or off.
   -  Enable or disable a feature.
   -  Select an option.

   The component has two parts: the thumb and the track. The thumb is the
   draggable part of the switch, and the track is the background. The user can
   drag the thumb to the left or right to change the state of the switch. They
   can also tap the switch to check and clear it.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Implement a switch
------------------

   The following example is a minimal implementation of the ``Switch``
   composable:


      .. code:: prettyprint

         @Composable
         fun SwitchMinimalExample() {
             var checked by remember { mutableStateOf(true) }

             Switch(
                 checked = checked,
                 onCheckedChange = {
                     checked = it
                 }
             )
         } // Switch.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/switch-deactivated.png
      :alt: A basic switch that is unchecked.

      **Figure 1.** An unchecked switch.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/switch.png
      :alt: A basic Switch that is checked.

      **Figure 2.** A checked switch.


Create a custom thumb
---------------------

   You can pass any composable for the ``thumbContent`` parameter to create a
   custom thumb. The following is an example of a switch that uses a custom icon
   for its thumb:


      .. code:: prettyprint

         @Composable
         fun SwitchWithIconExample() {
             var checked by remember { mutableStateOf(true) }

             Switch(
                 checked = checked,
                 onCheckedChange = {
                     checked = it
                 },
                 thumbContent = if (checked) {
                     {
                         Icon(
                             imageVector = Icons.Filled.Check,
                             contentDescription = null,
                             modifier = Modifier.size(SwitchDefaults.IconSize),
                         )
                     }
                 } else {
                     null
                 }
             )
         } // Switch.kt


Results

   The unchecked appearance is the same as the example in the preceding section.
   However, when checked, this implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/switch-icon.png
      :alt: A switch that uses the thumbContent parameter to display a custom
      icon when checked.

      **Figure 3.** A switch with a custom checked icon.


Use custom colors
-----------------

   Use the ``colors`` parameter to change the color of a switch's thumb and
   track, taking into account whether the switch is checked.


      .. code:: prettyprint

         @Composable
         fun SwitchWithCustomColors() {
             var checked by remember { mutableStateOf(true) }

             Switch(
                 checked = checked,
                 onCheckedChange = {
                     checked = it
                 },
                 colors = SwitchDefaults.colors(
                     checkedThumbColor = MaterialTheme.colorScheme.primary,
                     checkedTrackColor = MaterialTheme.colorScheme.primaryContainer,
                     uncheckedThumbColor = MaterialTheme.colorScheme.secondary,
                     uncheckedTrackColor = MaterialTheme.colorScheme.secondaryContainer,
                 )
             )
         } // Switch.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/switch-colors.png
      :alt: A switch that uses the colors parameter to display a switch with
      custom colors for both the thumb and tack.

      **Figure 4.** A switch with custom colors.


Key points
----------

   -  Basic parameters:

      -  **``checked``**: The initial state of the switch.
      -  **``onCheckedChange``**: A callback that is called when the state of
         the switch changes.
      -  **``enabled``**: Whether the switch is enabled or disabled.
      -  **``colors``**: The colors used for the switch.

   -  Advanced parameters

      -  **``thumbContent``**: Use this to customize the appearance of the thumb
         when it is checked.
      -  **``colors``**: Use this to customize the color of the track and thumb.


â­ Create a chip to represent complex entities
==============================================

https://developer.android.google.cn/quick-guides/content/create-chip?hl=en

   The ``Chip`` component is a compact, interactive UI element. It represents
   complex entities like a contact or tag, often with an icon and label. It can
   be checkable, dismissible, or clickable.

   The five types of chips and where you might use them are as follows:

   -  `Assist`: Guides the user during a task. Often appears as a
      temporary UI element in response to user input.
   -  `Filter`: Lets users refine content from a set of options.
      They can be selected or deselected, and may include a checkmark icon when
      selected.
   -  `Input`: Represents user-provided information, such as
      selections in a menu. They can contain an icon and text, and provide an
      'X' for removal.
   -  `Suggestion`: Provides recommendations to the user based
      on their recent activity or input. Typically appear beneath an input field
      to prompt user actions.
   -  `Elevated`: Has an elevated appearance instead of looking
      flat.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Create an assist chip
---------------------

   The `AssistChip </reference/kotlin/androidx/compose/material3/package-summary#AssistChip(kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Function0,kotlin.Function0,androidx.compose.ui.graphics.Shape,androidx.compose.material3.ChipColors,androidx.compose.material3.ChipElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.interaction.MutableInteractionSource)>`__
   composable provides a straightforward way to create an assist chip that
   nudges the user in a particular direction. One distinguishing feature is its
   ``leadingIcon`` parameter that lets you display an icon on the left side of
   the chip, as shown in figure 1. The following example demonstrates how you
   can implement it:


      .. code:: prettyprint

         @Composable
         fun AssistChipExample() {
             AssistChip(
                 onClick = { Log.d("Assist chip", "hello world") },
                 label = { Text("Assist chip") },
                 leadingIcon = {
                     Icon(
                         Icons.Filled.Settings,
                         contentDescription = "Localized description",
                         Modifier.size(AssistChipDefaults.IconSize)
                     )
                 }
             )
         } // Chip.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/chip-assist.png
      :alt: A simple assist chip.
      :width: 100.0%

      **Figure 1.** Assist chip.


Create a filter chip
--------------------

   The `FilterChip </reference/kotlin/androidx/compose/material3/package-summary#FilterChip(kotlin.Boolean,kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Function0,kotlin.Function0,androidx.compose.ui.graphics.Shape,androidx.compose.material3.SelectableChipColors,androidx.compose.material3.SelectableChipElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.interaction.MutableInteractionSource)>`__
   composable requires you to track whether or not the chip is selected. The
   following example demonstrates how you can show a leading checked icon only
   when the user has selected the chip:


      .. code:: prettyprint

         @Composable
         fun FilterChipExample() {
             var selected by remember { mutableStateOf(false) }

             FilterChip(
                 onClick = { selected = !selected },
                 label = {
                     Text("Filter chip")
                 },
                 selected = selected,
                 leadingIcon = if (selected) {
                     {
                         Icon(
                             imageVector = Icons.Filled.Done,
                             contentDescription = "Done icon",
                             modifier = Modifier.size(FilterChipDefaults.IconSize)
                         )
                     }
                 } else {
                     null
                 },
             )
         } // Chip.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/chip-filter.png
      :alt: An unselected filter chip, with no check and a plan background.
      :width: 100.0%

      **Figure 2.** Unselected filter chip.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/components/chip-filter-active.png
      :alt: Selected filter chip, with a check and a coloured background.
      :width: 100.0%

      **Figure 3.** Selected filter chip.


Create an input chip
--------------------

   You can use the `InputChip </reference/kotlin/androidx/compose/material3/package-summary#InputChip(kotlin.Boolean,kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Function0,kotlin.Function0,kotlin.Function0,androidx.compose.ui.graphics.Shape,androidx.compose.material3.SelectableChipColors,androidx.compose.material3.SelectableChipElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.interaction.MutableInteractionSource)>`__
   composable to create chips that result from user interaction. For example, in
   an email client, when the user is writing an email, an input chip might
   represent a person whose address the user has entered into the "to:" field.

   The following implementation demonstrates an input chip that is in a selected
   state. The user dismisses the chip when they press it.

   **Note:**  Consider how you might use a chip like this in the preceding
   email use case, with a name passed in for the ``text`` parameter, and a
   function that performs the necessary network calls for ``onDismiss``.


      .. code:: prettyprint

         @Composable
         fun InputChipExample(
             text: String,
             onDismiss: () -> Unit,
         ) {
             var enabled by remember { mutableStateOf(true) }
             if (!enabled) return

             InputChip(
                 onClick = {
                     onDismiss()
                     enabled = !enabled
                 },
                 label = { Text(text) },
                 selected = enabled,
                 avatar = {
                     Icon(
                         Icons.Filled.Person,
                         contentDescription = "Localized description",
                         Modifier.size(InputChipDefaults.AvatarSize)
                     )
                 },
                 trailingIcon = {
                     Icon(
                         Icons.Default.Close,
                         contentDescription = "Localized description",
                         Modifier.size(InputChipDefaults.AvatarSize)
                     )
                 },
             )
         } // Chip.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/chip-input.png
      :alt: An input chip with an avatar and a trailing icon.
      :width: 100.0%

      **Figure 4.** Input chip.


Create a suggestion chip
------------------------

   The `SuggestionChip </reference/kotlin/androidx/compose/material3/package-summary#SuggestionChip(kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Function0,androidx.compose.ui.graphics.Shape,androidx.compose.material3.ChipColors,androidx.compose.material3.ChipElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.interaction.MutableInteractionSource)>`__
   composable is the most basic of the composables listed on this page, both in
   its API definition and its common use cases. Suggestion chips present
   dynamically generated hints. For example, in an AI chat app, you might use
   suggestion chips to present possible responses to the most recent message.

   Consider this implementation of ``SuggestionChip``:


      .. code:: prettyprint

         @Composable
         fun SuggestionChipExample() {
             SuggestionChip(
                 onClick = { Log.d("Suggestion chip", "hello world") },
                 label = { Text("Suggestion chip") }
             )
         } // Chip.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/chip-suggestion.png
      :alt: A simple assist chip.
      :width: 100.0%

      **Figure 5.** Assist chip.

   **Note:**  Although the suggestion chip component is intended for
   informational purposes, it does still take an ``onClick`` lambda that you can
   use to create interactivity.


Create an elevated chip
-----------------------

   All the examples in this document use the base composables that take a flat
   appearance. If you want a chip that has an elevated appearance, use one of
   the three following composables:

   -  `ElevatedAssistChip </reference/kotlin/androidx/compose/material3/package-summary#ElevatedAssistChip(kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Function0,kotlin.Function0,androidx.compose.ui.graphics.Shape,androidx.compose.material3.ChipColors,androidx.compose.material3.ChipElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.interaction.MutableInteractionSource)>`__
   -  `ElevatedFilterChip </reference/kotlin/androidx/compose/material3/package-summary#ElevatedFilterChip(kotlin.Boolean,kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Function0,kotlin.Function0,androidx.compose.ui.graphics.Shape,androidx.compose.material3.SelectableChipColors,androidx.compose.material3.SelectableChipElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.interaction.MutableInteractionSource)>`__
   -  `ElevatedSuggestionChip </reference/kotlin/androidx/compose/material3/package-summary#ElevatedSuggestionChip(kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Function0,androidx.compose.ui.graphics.Shape,androidx.compose.material3.ChipColors,androidx.compose.material3.ChipElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.interaction.MutableInteractionSource)>`__


Key points
----------

   Four composables correspond to the four types of chips, and they share the
   following parameters:

   -  **``label``**: The string that appears on the chip.
   -  **``icon``**: The icon displayed at the start of the chip. Some
      composables have a separate ``leadingIcon`` and ``trailingIcon``
      parameter.
   -  **``onClick``**: The lambda that the chip calls when the user clicks it.


â­ Create a notification with a snackbar
========================================

https://developer.android.google.cn/quick-guides/content/create-snackbar-notification?hl=en

   The `snackbar component <https://material.io/components/snackbars>`__ serves
   as a brief notification that appears at the bottom of the screen. It provides
   feedback about an operation or action without interrupting the user
   experience. Snackbars disappear after a few seconds. The user can also
   dismiss them with an action, such as tapping a button.

   Consider these three use cases where you might use a snackbar:

   -  **Action confirmation:** After a user deletes an email or message, a
      snackbar appears to confirm the action and offer an "Undo" option.
   -  **Network status:** When the app loses its internet connection, a snackbar
      pops up to note that it is now offline.
   -  **Data submission:** Upon successfully submitting a form or updating
      settings, a snackbar notes that the change has saved successfully.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Create a basic snackbar
-----------------------

   To implement a snackbar, you first create `SnackbarHost </reference/kotlin/androidx/compose/material3/package-summary#SnackbarHost(androidx.compose.material3.SnackbarHostState,androidx.compose.ui.Modifier,kotlin.Function1)>`__,
   which includes a `SnackbarHostState </reference/kotlin/androidx/compose/material3/SnackbarHostState>`__
   property. ``SnackbarHostState`` provides access to the `showSnackbar() </reference/kotlin/androidx/compose/material3/SnackbarHostState#showsnackbar>`__
   function which you can use to display your snackbar.

   This suspending function requires a ``CoroutineScope`` such as with using
   `rememberCoroutineScope </reference/kotlin/androidx/compose/runtime/package-summary#remembercoroutinescope>`__
   â€” and can be called in response to UI events to show a `Snackbar </reference/kotlin/androidx/compose/material3/package-summary#snackbar>`__
   within ``Scaffold``.


      .. code:: prettyprint

         val scope = rememberCoroutineScope()
         val snackbarHostState = remember { SnackbarHostState() }
         Scaffold(
             snackbarHost = {
                 SnackbarHost(hostState = snackbarHostState)
             },
             floatingActionButton = {
                 ExtendedFloatingActionButton(
                     text = { Text("Show snackbar") },
                     icon = { Icon(Icons.Filled.Image, contentDescription = "") },
                     onClick = {
                         scope.launch {
                             snackbarHostState.showSnackbar("Snackbar")
                         }
                     }
                 )
             }
         ) { contentPadding ->
             // Screen content
         } // MaterialLayoutSnippets.kt


Create a snackbar with action
-----------------------------

   You can provide an optional action and adjust the duration of the
   ``Snackbar``. The ``snackbarHostState.showSnackbar()`` function accepts
   additional ``actionLabel`` and ``duration`` parameters, and returns a
   `SnackbarResult </reference/kotlin/androidx/compose/material3/SnackbarResult>`__.


      .. code:: prettyprint

         val scope = rememberCoroutineScope()
         val snackbarHostState = remember { SnackbarHostState() }
         Scaffold(
             snackbarHost = {
                 SnackbarHost(hostState = snackbarHostState)
             },
             floatingActionButton = {
                 ExtendedFloatingActionButton(
                     text = { Text("Show snackbar") },
                     icon = { Icon(Icons.Filled.Image, contentDescription = "") },
                     onClick = {
                         scope.launch {
                             val result = snackbarHostState
                                 .showSnackbar(
                                     message = "Snackbar",
                                     actionLabel = "Action",
                                     // Defaults to SnackbarDuration.Short
                                     duration = SnackbarDuration.Indefinite
                                 )
                             when (result) {
                                 SnackbarResult.ActionPerformed -> {
                                     /* Handle snackbar action performed */
                                 }
                                 SnackbarResult.Dismissed -> {
                                     /* Handle snackbar dismissed */
                                 }
                             }
                         }
                     }
                 )
             }
         ) { contentPadding ->
             // Screen content
         } // MaterialLayoutSnippets.kt

   You can provide a custom ``Snackbar`` with the ``snackbarHost`` parameter.
   See the `SnackbarHost API reference docs </reference/kotlin/androidx/compose/material/package-summary#snackbarhost>`__
   for more information.


Results

   .. image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/material/m3-snackbar.png

      **Figure 1.** Snackbar notifications with action.


â­ Create a card as a container
===============================

https://developer.android.google.cn/quick-guides/content/create-card-as-container?hl=en

   The `Card </reference/kotlin/androidx/compose/material3/package-summary#Card(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.material3.CardColors,androidx.compose.material3.CardElevation,androidx.compose.foundation.BorderStroke,kotlin.Function1)>`__
   composable acts as a Material Design container for your UI. Cards present a
   single coherent piece of content, such as:

   -  A product in a shopping app.
   -  A news story in a news app.
   -  A message in a communications app.

   The focus on portraying a single piece of content distinguishes ``Card`` from
   other containers. For example, ``Scaffold`` provides general structure to a
   whole screen. Card is a smaller UI element inside a larger layout, whereas a
   layout component such as ``Column`` or ``Row`` provides a simpler and more
   generic API.

   This topic shows you how to implement four types of cards:

   -  `Basic`
   -  `Filled`
   -  `Elevated`
   -  `Outlined`


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Create a basic card
-------------------

   ``Card`` behaves much like other containers in Compose. You declare its
   content by calling other composables within it. For example, consider how
   ``Card`` contains a call to ``Text`` in the following minimal example:


      .. code:: prettyprint

         @Composable
         fun CardMinimalExample() {
             Card() {
                 Text(text = "Hello, world!")
             }
         }

   **Note:**  By default, a ``Card`` wraps its content in a ``Column``
   composable, placing each item inside the card beneath one another.


Create a filled card
--------------------

   The key here is the use of the ``colors`` property to change the filled
   color:


      .. code:: prettyprint

         @Composable
         fun FilledCardExample() {
             Card(
                 colors = CardDefaults.cardColors(
                     containerColor = MaterialTheme.colorScheme.surfaceVariant,
                 ),
                 modifier = Modifier
                     .size(width = 240.dp, height = 100.dp)
             ) {
                 Text(
                     text = "Filled",
                     modifier = Modifier
                         .padding(16.dp),
                     textAlign = TextAlign.Center,
                 )
             }
         } // Card.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/card-filled.png
      :alt: A card is filled with the surface variant color from the material
      theme.

      **Figure 1.** Example of a filled card.


Create an elevated card
-----------------------

   The following snippet demonstrates how to implement an elevated card. Use the
   dedicated `ElevatedCard </reference/kotlin/androidx/compose/material3/package-summary#ElevatedCard(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.material3.CardColors,androidx.compose.material3.CardElevation,kotlin.Function1)>`__
   composable.

   You can use the ``elevation`` property to control the appearance of elevation
   and the resulting shadow.


      .. code:: prettyprint

         @Composable
         fun ElevatedCardExample() {
             ElevatedCard(
                 elevation = CardDefaults.cardElevation(
                     defaultElevation = 6.dp
                 ),
                 modifier = Modifier
                     .size(width = 240.dp, height = 100.dp)
             ) {
                 Text(
                     text = "Elevated",
                     modifier = Modifier
                         .padding(16.dp),
                     textAlign = TextAlign.Center,
                 )
             }
         } // Card.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/card-elevated.png
      :alt: A card is elevated above the background of the app, with a shadow.

      **Figure 2.** Example of an elevated card.


Create an outlined card
-----------------------

   The following is an example of an outlined card. Use the dedicated
   `OutlinedCard </reference/kotlin/androidx/compose/material3/package-summary#OutlinedCard(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.material3.CardColors,androidx.compose.material3.CardElevation,androidx.compose.foundation.BorderStroke,kotlin.Function1)>`__
   composable.


      .. code:: prettyprint

         @Composable
         fun OutlinedCardExample() {
             OutlinedCard(
                 colors = CardDefaults.cardColors(
                     containerColor = MaterialTheme.colorScheme.surface,
                 ),
                 border = BorderStroke(1.dp, Color.Black),
                 modifier = Modifier
                     .size(width = 240.dp, height = 100.dp)
             ) {
                 Text(
                     text = "Outlined",
                     modifier = Modifier
                         .padding(16.dp),
                     textAlign = TextAlign.Center,
                 )
             }
         } // Card.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/card-outlined.png
      :alt: A card is outlined with a thin black border.

      **Figure 3.** Example of an outlined card.


Key points
----------

   See the
   `reference </reference/kotlin/androidx/compose/material3/package-summary#Card(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.material3.CardColors,androidx.compose.material3.CardElevation,androidx.compose.foundation.BorderStroke,kotlin.Function1)>`__
   for the API definition of ``Card``. It defines several parameters that you
   can use to customize the appearance and behavior of the component.

   Some key parameters include:

   -  **``elevation``**: Adds a shadow to the component that makes it look
      elevated above the background.
   -  **``colors``**: Uses the ``CardColors`` type to set the default color of
      both the container and any children.
   -  **``enabled``**: If you pass ``false`` for this parameter, the card
      appears as disabled and does not respond to user input.
   -  **``onClick``**: Ordinarily, a ``Card`` does not accept click events. As
      such, the primary overload you would like to note is that which defines an
      ``onClick`` parameter. Use this overload when you want your implementation
      of ``Card`` to respond to clicks from the user.

   **Beta:**  The ``Card`` overload that defines the ``onClick`` parameter is
   experimental.
   Cards don't come with inherent scroll or dismiss actions, but can integrate
   into composables offering these features. For example, to implement swipe to
   dismiss on a card, integrate it with the `SwipeToDismiss </reference/kotlin/androidx/compose/material3/package-summary#SwipeToDismiss(androidx.compose.material3.DismissState,kotlin.Function1,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.collections.Set)>`__
   composable. To integrate with scroll, use scroll modifiers such as `verticalScroll </reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier).verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)>`__.
   See the `Scroll documentation </develop/ui/compose/touch-input/pointer-input/scroll>`__ 
   for more information.


â­ Display an app bar
=====================

https://developer.android.google.cn/quick-guides/content/display-app-bar?hl=en

   App bars are containers at the top or the bottom of the screen that give your
   users access to key features and navigation items:

   ================ ==========================================================
   Type             - Appearance         - Purpose
   ================ ==========================================================
   `Top app bar`    - Across the top of the screen.
                    - Provides access to key tasks and information. Typically hosts a
                    title, core action items, and certain navigation items.

   `Bottom app bar` - Across the bottom of the screen.
                    - Typically includes core navigation items. Might give access to other
                    actions, for example, by using a floating action button.
   ================ ==========================================================

Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Implement a top app bar

   The following code shows implementations for the four types of top app bars,
   including varying examples of how you can control scroll behavior.

   -  `Small top app bar`
   -  `Center-aligned top app bar`
   -  `Medium top app bar`
   -  `Large top app bar`


Small top app bar
-----------------

   To create a small top app bar, use the `TopAppBar </reference/kotlin/androidx/compose/material3/package-summary#TopAppBar(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function1,androidx.compose.foundation.layout.WindowInsets,androidx.compose.material3.TopAppBarColors,androidx.compose.material3.TopAppBarScrollBehavior)>`__
   composable. This is the simplest possible top app bar and in this example
   just contains a title.

   The following example does not pass ``TopAppBar`` a value for
   ``scrollBehavior``, so the top app bar does not react to scrolling of the
   inner content.


      .. code:: prettyprint

         @Composable
         fun SmallTopAppBarExample() {
             Scaffold(
                 topBar = {
                     TopAppBar(
                         colors = TopAppBarDefaults.topAppBarColors(
                             containerColor = MaterialTheme.colorScheme.primaryContainer,
                             titleContentColor = MaterialTheme.colorScheme.primary,
                         ),
                         title = {
                             Text("Small Top App Bar")
                         }
                     )
                 },
             ) { innerPadding ->
                 ScrollContent(innerPadding)
             }
         } // AppBar.kt


Result

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-small.png
      :alt: An example of a small top app bar.
      :width: 100.0%

      **Figure 1.** A small top app bar.


Center-aligned top app bar
--------------------------

   The center-aligned top app bar is the same as the small app bar, except the
   title is centered within the component. To implement it, use the dedicated
   `CenterAlignedTopAppBar </reference/kotlin/androidx/compose/material/package-summary#Scaffold(androidx.compose.foundation.layout.WindowInsets,androidx.compose.ui.Modifier,androidx.compose.material.ScaffoldState,kotlin.Function0,kotlin.Function0,kotlin.Function1,kotlin.Function0,androidx.compose.material.FabPosition,kotlin.Boolean,kotlin.Function1,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.ui.unit.Dp,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function1)>`__
   composable.

   This example uses ``enterAlwaysScrollBehavior()`` to get the value that it
   passes for ``scrollBehavior``. The bar collapses when the user scrolls the
   scaffold's inner content.


      .. code:: prettyprint

         @Composable
         fun CenterAlignedTopAppBarExample() {
             val scrollBehavior = TopAppBarDefaults.pinnedScrollBehavior(rememberTopAppBarState())

             Scaffold(
                 modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),

                 topBar = {
                     CenterAlignedTopAppBar(
                         colors = TopAppBarDefaults.topAppBarColors(
                             containerColor = MaterialTheme.colorScheme.primaryContainer,
                             titleContentColor = MaterialTheme.colorScheme.primary,
                         ),
                         title = {
                             Text(
                                 "Centered Top App Bar",
                                 maxLines = 1,
                                 overflow = TextOverflow.Ellipsis
                             )
                         },
                         navigationIcon = {
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                                     contentDescription = "Localized description"
                                 )
                             }
                         },
                         actions = {
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     imageVector = Icons.Filled.Menu,
                                     contentDescription = "Localized description"
                                 )
                             }
                         },
                         scrollBehavior = scrollBehavior,
                     )
                 },
             ) { innerPadding ->
                 ScrollContent(innerPadding)
             }
         } // AppBar.kt


Result

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-centered.png
      :alt: Write your alt text here
      :width: 100.0%

      **Figure 2.** A center-aligned top app bar.


Medium top app bar
------------------

   The medium top app bar places the title beneath any additional icons. To
   create one, use the `MediumTopAppBar </reference/kotlin/androidx/compose/material3/package-summary#MediumTopAppBar(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function1,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.WindowInsets,androidx.compose.material3.TopAppBarColors,androidx.compose.material3.TopAppBarScrollBehavior)>`__
   composable.

   Like the previous code, this example uses ``enterAlwaysScrollBehavior()`` to
   get the value that it passes for ``scrollBehavior``.


      .. code:: prettyprint

         @Composable
         fun MediumTopAppBarExample() {
             val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior(rememberTopAppBarState())

             Scaffold(
                 modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),
                 topBar = {
                     MediumTopAppBar(
                         colors = TopAppBarDefaults.topAppBarColors(
                             containerColor = MaterialTheme.colorScheme.primaryContainer,
                             titleContentColor = MaterialTheme.colorScheme.primary,
                         ),
                         title = {
                             Text(
                                 "Medium Top App Bar",
                                 maxLines = 1,
                                 overflow = TextOverflow.Ellipsis
                             )
                         },
                         navigationIcon = {
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                                     contentDescription = "Localized description"
                                 )
                             }
                         },
                         actions = {
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     imageVector = Icons.Filled.Menu,
                                     contentDescription = "Localized description"
                                 )
                             }
                         },
                         scrollBehavior = scrollBehavior
                     )
                 },
             ) { innerPadding ->
                 ScrollContent(innerPadding)
             }
         } // AppBar.kt


Result

   **Figure 3.** A medium top app bar demonstrating the scroll behavior from
   ``enterAlwaysScrollBehavior``.


Large top app bar
-----------------

   A large top app bar is similar to the medium, though the padding between the
   title and the icons is greater and it occupies more space on screen overall.
   To create one, use the `LargeTopAppBar </reference/kotlin/androidx/compose/material3/package-summary#LargeTopAppBar(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function1,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.WindowInsets,androidx.compose.material3.TopAppBarColors,androidx.compose.material3.TopAppBarScrollBehavior>`__
   ) composable.

   This example uses ``exitUntilCollapsedScrollBehavior()`` to get the value
   that it passes for ``scrollBehavior``. The bar collapses when the user
   scrolls the scaffold's inner content, but then expands when the user scrolls
   to the end of the inner content.


      .. code:: prettyprint

         @Composable
         fun LargeTopAppBarExample() {
             val scrollBehavior = TopAppBarDefaults.exitUntilCollapsedScrollBehavior(rememberTopAppBarState())

             Scaffold(
                 modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),
                 topBar = {
                     LargeTopAppBar(
                         colors = TopAppBarDefaults.topAppBarColors(
                             containerColor = MaterialTheme.colorScheme.primaryContainer,
                             titleContentColor = MaterialTheme.colorScheme.primary,
                         ),
                         title = {
                             Text(
                                 "Large Top App Bar",
                                 maxLines = 1,
                                 overflow = TextOverflow.Ellipsis
                             )
                         },
                         navigationIcon = {
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                                     contentDescription = "Localized description"
                                 )
                             }
                         },
                         actions = {
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     imageVector = Icons.Filled.Menu,
                                     contentDescription = "Localized description"
                                 )
                             }
                         },
                         scrollBehavior = scrollBehavior
                     )
                 },
             ) { innerPadding ->
                 ScrollContent(innerPadding)
             }
         } // AppBar.kt


Result

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-large.png
      :alt: A screen in an app with a bottom app bar that holds for action icons
      on the left side, and a floating action button on the right.
      :width: 100.0%

      **Figure 4.** An example implementation of a large top app bar.


Implement a bottom app bar
--------------------------

   To create a bottom app bar, use the `BottomAppBar </reference/kotlin/androidx/compose/material3/package-summary#BottomAppBar(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.PaddingValues,androidx.compose.foundation.layout.WindowInsets,kotlin.Function1)>`__
   composable, which is similar to the top app bar composable.

   You pass composables for the following key parameters:

   -  ``actions``: A series of icons that appear on the left side of the bar.
      These are commonly either key actions for the given screen, or navigation
      items.
   -  ``floatingActionButton``: The floating action button that appears on the
      right side of the bar.

   **Note:**  You can also use ``BottomAppBar`` without passing a value for
   ``actions`` and ``floatingActionButton``. You create a custom bottom app bar
   by filling ``BottomAppBar`` with content as you would other containers.


      .. code:: prettyprint

         @Composable
         fun BottomAppBarExample() {
             Scaffold(
                 bottomBar = {
                     BottomAppBar(
                         actions = {
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(Icons.Filled.Check, contentDescription = "Localized description")
                             }
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     Icons.Filled.Edit,
                                     contentDescription = "Localized description",
                                 )
                             }
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     Icons.Filled.Mic,
                                     contentDescription = "Localized description",
                                 )
                             }
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     Icons.Filled.Image,
                                     contentDescription = "Localized description",
                                 )
                             }
                         },
                         floatingActionButton = {
                             FloatingActionButton(
                                 onClick = { /* do something */ },
                                 containerColor = BottomAppBarDefaults.bottomAppBarFabColor,
                                 elevation = FloatingActionButtonDefaults.bottomAppBarFabElevation()
                             ) {
                                 Icon(Icons.Filled.Add, "Localized description")
                             }
                         }
                     )
                 },
             ) { innerPadding ->
                 Text(
                     modifier = Modifier.padding(innerPadding),
                     text = "Example of a scaffold with a bottom app bar."
                 )
             }
         } // AppBar.kt


Result

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-bottom.png
      :alt: A screen in an app with a bottom app bar that holds for action icons
      on the left side, and a floating action button on the right.
      :width: 100.0%

      **Figure 5.** An example implementation of a bottom app bar.


Key points
----------

   -  You generally pass app bars to the ``Scaffold`` composable, which has
      specific parameters to receive them.

   -  The composables that you use to implement top app bars share key
      parameters:

      -  ``title``: The text that appears across the app bar.
      -  ``navigationIcon``: The primary icon for navigation, which appears on
         the left of the app bar.
      -  ``actions``: Icons that provide the user access to key actions, which
         appear on the right of the app bar.
      -  ``scrollBehavior``: Determines how the top app bar responds to
         scrolling of the scaffold's inner content.
      -  ``colors``: Determines how the app bar appears.

   -  You can control how the app bar responds when the user scrolls the
      scaffold's inner content. To do so, create an instance of
      `TopAppBarScrollBehavior </reference/kotlin/androidx/compose/material3/TopAppBarScrollBehavior>`__
      and pass it to your top app bar for the ``scrollBehavior`` parameter.
      There are three types of ``TopAppBarScrollBehavior``:

      -  ``enterAlwaysScrollBehavior``: When the user pulls up the scaffold's
         inner content, the top app bar collapses. The app bar expands when the
         user pulls down the inner content.
      -  ``exitUntilCollapsedScrollBehavior``: Similar to
         ``enterAlwaysScrollBehavior``, though the app bar also expands when the
         user reaches the end of the scaffold's inner content.
      -  ``pinnedScrollBehavior``: The app bar remains in place and does not
         react to scrolling.


â­ Create a progress indicator
==============================

https://developer.android.google.cn/quick-guides/content/create-progress-indicator?hl=en

   Progress indicators visually surface the status of an operation. They use
   motion to bring to the user's attention how near completion the process is,
   such as loading or processing data. They can also signify that processing is
   taking place, without reference to how close to completion it might be.

   Consider these three use cases where you might use a progress indicator:

   -  **Loading content**: While fetching content from a network, such as
      loading an image or data for a user profile.
   -  **File upload**: Give the user feedback on how long the upload might take.
   -  **Long processing**: While an app is processing a large amount of data,
      convey to the user how much of the total is complete.

   In Material Design, there are two types of progress indicator:

   -  `Determinate`: Displays exactly how much progress has
      been made.
   -  `Indeterminate`: Animates continually without regard to
      progress.

   Likewise, a progress indicator can take one of the two following forms:

   -  **Linear**: A horizontal bar that fills from left to right.
   -  **Circular**: A circle whose stroke grows in length until it encompasses
      the full circumference of the circle.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


            .. code:: kotlin

                 implementation(platform("androidx.compose:compose-bom:2024.06.00"))


            .. code:: groovy

                 implementation platform('androidx.compose:compose-bom:2024.06.00')


Create determinate indicators
-----------------------------

   A determinate indicator reflects exactly how complete an action is. Use
   either the `LinearProgressIndicator </reference/com/google/android/material/progressindicator/LinearProgressIndicator>`__
   or `CircularProgressIndicator </reference/com/google/android/material/progressindicator/CircularProgressIndicator>`__
   composables and pass a value for the ``progress`` parameter.

   The following snippet provides a relatively detailed example. When the user
   presses the button, the app both displays the progress indicator, and
   launches a coroutine that gradually increases the value of ``progress``. This
   causes the progress indicator to iterate up in turn.

   **Note:**  The following example uses a coroutine to do the work of
   iterating the ``progress`` value because it would otherwise block the UI
   thread.


      .. code:: prettyprint

         @Composable
         fun LinearDeterminateIndicator() {
             var currentProgress by remember { mutableStateOf(0f) }
             var loading by remember { mutableStateOf(false) }
             val scope = rememberCoroutineScope() // Create a coroutine scope

             Column(
                 verticalArrangement = Arrangement.spacedBy(12.dp),
                 horizontalAlignment = Alignment.CenterHorizontally,
                 modifier = Modifier.fillMaxWidth()
             ) {
                 Button(onClick = {
                     loading = true
                     scope.launch {
                         loadProgress { progress ->
                             currentProgress = progress
                         }
                         loading = false // Reset loading when the coroutine finishes
                     }
                 }, enabled = !loading) {
                     Text("Start loading")
                 }

                 if (loading) {
                     LinearProgressIndicator(
                         progress = { currentProgress },
                         modifier = Modifier.fillMaxWidth(),
                     )
                 }
             }
         }

         /** Iterate the progress value */
         suspend fun loadProgress(updateProgress: (Float) -> Unit) {
             for (i in 1..100) {
                 updateProgress(i.toFloat() / 100)
                 delay(100)
             }
         } // ProgressIndicator.kt


Results

   When loading is partially complete, the linear indicator in the preceding
   example appears as follows:

   Likewise, the circular indicator appears as follows:


Create indeterminate indicators
-------------------------------

   An indeterminate indicator does not reflect how close to completion an
   operation is. Rather, it uses motion to indicate to the user that processing
   is ongoing, though without specifying any degree of completion.

   To create an indeterminate progress indicator, use the
   ``LinearProgressIndicator`` or ``CircularProgressIndicator`` composable, but
   don't pass in a value for ``progress``. The following example demonstrates
   how you can toggle an indeterminate indicator with a button press.

   **Note:**  This example also demonstrates how you can pass values for the
   ``color`` and ``trackColor`` parameters to customize the appearance of the
   indicator.


      .. code:: prettyprint

         @Composable
         fun IndeterminateCircularIndicator() {
             var loading by remember { mutableStateOf(false) }

             Button(onClick = { loading = true }, enabled = !loading) {
                 Text("Start loading")
             }

             if (!loading) return

             CircularProgressIndicator(
                 modifier = Modifier.width(64.dp),
                 color = MaterialTheme.colorScheme.secondary,
                 trackColor = MaterialTheme.colorScheme.surfaceVariant,
             )
         } // ProgressIndicator.kt


Results

   The following is an example of this implementation when the indicator is
   active:

   The following is an example of the same implementation but with
   ``LinearProgressIndicator`` instead of ``CircularProgressIndicator``.


Key points
----------

   Although there are several composables you can use to create progress
   indicators consistent with Material Design, their parameters don't differ
   greatly. Among the key parameters you should keep in mind are the following:

   -  ``progress``: The current progress that the indicator displays. Pass a
      ``Float`` between ``0.0`` and ``1.0``.
   -  ``color``: The color of the indicator, that is, the part of the component
      that reflects progress and which fully encompasses the component when
      progress is complete.
   -  ``trackColor``: The color of the track over which the indicator is drawn.

   **Note:**  The APIs for ``LinearProgressIndicator`` and
   ``CircularProgressIndicator`` are essentially the same and the way you use
   either one is identical.


â­ Create a floating action button (FAB)
========================================

https://developer.android.google.cn/quick-guides/content/create-floating-action-button?hl=en

   A floating action button (FAB) is a high-emphasis button that lets the user
   perform a primary action in an application. It promotes a single, focused
   action that is the most common pathway a user might take and is typically
   found anchored to the bottom right of the screen.

   Consider these three use cases where you might use a FAB:

   -  **Create new item**: In a note-taking app, a FAB might be used to quickly
      create a new note.
   -  **Add new contact**: In a chat app, a FAB could open an interface that
      lets the user add someone to a conversation.
   -  **Center location**: In a map interface, a FAB could center the map on the
      user's current location.

   In Material Design, there are four types of FAB:

   -  `FAB`: A floating action button of ordinary size.
   -  `Small FAB`: A smaller floating action button.
   -  `Large FAB`: A larger floating action button.
   -  `Extended FAB`: A floating action button that contains more
      than just an icon.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Create a basic floating action button
-------------------------------------

   To create a general floating action button, use the basic `FloatingActionButton </reference/kotlin/androidx/compose/material3/package-summary#FloatingActionButton(kotlin.Function0,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.material3.FloatingActionButtonElevation,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function0)>`__
   composable:


      .. code:: prettyprint

         @Composable
         fun Example(onClick: () -> Unit) {
             FloatingActionButton(
                 onClick = { onClick() },
             ) {
                 Icon(Icons.Filled.Add, "Floating action button.")
             }
         } // FloatingActionButton.kt


Result

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/fab.png
      :alt: A standard floating action button with rounded corner, a shadow, and
      an 'add' icon.

      **Figure 1.** A floating action button.


Create a small floating action button
-------------------------------------

   To create a small floating action button, use the `SmallFloatingActionButton </reference/kotlin/androidx/compose/material3/package-summary#SmallFloatingActionButton(kotlin.Function0,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.material3.FloatingActionButtonElevation,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function0)>`__
   composable. The following example demonstrates how to do so, with the
   addition of custom colors.


      .. code:: prettyprint

         @Composable
         fun SmallExample(onClick: () -> Unit) {
             SmallFloatingActionButton(
                 onClick = { onClick() },
                 containerColor = MaterialTheme.colorScheme.secondaryContainer,
                 contentColor = MaterialTheme.colorScheme.secondary
             ) {
                 Icon(Icons.Filled.Add, "Small floating action button.")
             }
         } // FloatingActionButton.kt

   **Note:**  Because the various FAB composables share many parameters, you
   can use the approach in this example to customize colors with other
   composables.

Result

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/fab-small.png
      :alt: An implementation of SmallFloatingActionButton that contains an
      'add' icon.

      **Figure 2.** A small floating action button.


Create a large floating action button
-------------------------------------

   To create a large floating action button, use the
   `LargeFloatingActionButton </reference/kotlin/androidx/compose/material3/package-summary#LargeFloatingActionButton(kotlin.Function0,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.material3.FloatingActionButtonElevation,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function0)>`__
   composable. This composable is not significantly different from the other
   examples aside from the fact that it results in a bigger button.

   The following is a straightforward implementation of a large FAB.

   **Note:**  This example passes ``CircleShape`` as the value for the
   ``shape`` parameter, resulting in a round button, rather than a square with
   rounded borders. You can pass any instance of ``Shape``, or set the value of
   ``MaterialTheme.shape.large`` to adjust it across your app.


      .. code:: prettyprint

         @Composable
         fun LargeExample(onClick: () -> Unit) {
             LargeFloatingActionButton(
                 onClick = { onClick() },
                 shape = CircleShape,
             ) {
                 Icon(Icons.Filled.Add, "Large floating action button")
             }
         } // FloatingActionButton.kt


Result

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/fab-large.png
      :alt: An implementation of LargeFloatingActionButton that contains an
      'add' icon.

      **Figure 3.** A large floating action button.


Create an extended floating action button
-----------------------------------------

   You can create more complex floating action buttons with the
   `ExtendedFloatingActionButton </reference/kotlin/androidx/compose/material3/package-summary#ExtendedFloatingActionButton(kotlin.Function0,kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.material3.FloatingActionButtonElevation,androidx.compose.foundation.interaction.MutableInteractionSource)>`__
   composable. The key difference between it and
   `FloatingActionButton </reference/kotlin/androidx/compose/material3/package-summary#FloatingActionButton(kotlin.Function0,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.material3.FloatingActionButtonElevation,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function0)>`__
   is that it has dedicated ``icon`` and ``text`` parameters. They let you
   create a button with more complex content that scales to fit its content
   appropriately.

   The following snippet demonstrates how to implement
   ``ExtendedFloatingActionButton``, with example values passed for ``icon`` and
   ``text``.


      .. code:: prettyprint

         @Composable
         fun ExtendedExample(onClick: () -> Unit) {
             ExtendedFloatingActionButton(
                 onClick = { onClick() },
                 icon = { Icon(Icons.Filled.Edit, "Extended floating action button.") },
                 text = { Text(text = "Extended FAB") },
             )
         } // FloatingActionButton.kt


Result

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/fab-extended.png
      :alt: An implementation of ExtendedFloatingActionButton that displays text
      that says 'extended button' and an edit icon.

      **Figure 4.** A floating action button with both text and an icon.


Key points
----------

   Although there are several composables you can use to create floating action
   buttons consistent with Material Design, their parameters don't differ
   greatly. Among the key parameters you should keep in mind are the following:

   -  ``onClick``: The function called when the user presses the button.
   -  ``containerColor``: The color of the button.
   -  ``contentColor``: The color of the icon.


â­ Display pop-up messages or requests for user input
=====================================================

https://developer.android.google.cn/quick-guides/content/display-user-input?hl=en

   The `Dialog </reference/kotlin/androidx/compose/ui/window/package-summary#Dialog(kotlin.Function0,androidx.compose.ui.window.DialogProperties,kotlin.Function0)>`__
   component displays pop-up messages or requests user input on a layer above
   the main app content. It creates an interruptive UI experience to capture
   user attention.

   Among the use cases for a dialog are the following:

   -  Confirming user action, such as when deleting a file.
   -  Requesting user input, such as in a to-do list app.
   -  Presenting a list of options for user selection, like choosing a country
      in a profile setup.

   This topic provides the following implementations:

   -  `Alert`
   -  `Basic dialog`
   -  `Advanced dialog`


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


         .. code:: kotlin

               implementation(platform("androidx.compose:compose-bom:2024.06.00"))


         .. code:: groovy

               implementation platform('androidx.compose:compose-bom:2024.06.00')


Create an Alert dialog
----------------------

   The `AlertDialog </reference/kotlin/androidx/compose/material3/package-summary#AlertDialog(kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,androidx.compose.ui.window.DialogProperties)>`__
   composable provides a convenient API for creating a Material Design themed
   dialog. The following example implements two buttons in an alert dialog, one
   that dismisses the dialog, and another that confirms its request:


      .. code:: prettyprint

         @OptIn(ExperimentalMaterial3Api::class)
         @Composable
         fun AlertDialogExample(
             onDismissRequest: () -> Unit,
             onConfirmation: () -> Unit,
             dialogTitle: String,
             dialogText: String,
             icon: ImageVector,
         ) {
             AlertDialog(
                 icon = {
                     Icon(icon, contentDescription = "Example Icon")
                 },
                 title = {
                     Text(text = dialogTitle)
                 },
                 text = {
                     Text(text = dialogText)
                 },
                 onDismissRequest = {
                     onDismissRequest()
                 },
                 confirmButton = {
                     TextButton(
                         onClick = {
                             onConfirmation()
                         }
                     ) {
                         Text("Confirm")
                     }
                 },
                 dismissButton = {
                     TextButton(
                         onClick = {
                             onDismissRequest()
                         }
                     ) {
                         Text("Dismiss")
                     }
                 }
             )
         } // Dialog.kt

   This implementation implies a parent composable that passes arguments to the
   child composable in this way:


      .. code:: prettyprint

         @Composable
         fun DialogExamples() {
             // ...
             val openAlertDialog = remember { mutableStateOf(false) }

             // ...
                 when {
                     // ...
                     openAlertDialog.value -> {
                         AlertDialogExample(
                             onDismissRequest = { openAlertDialog.value = false },
                             onConfirmation = {
                                 openAlertDialog.value = false
                                 println("Confirmation registered") // Add logic here to handle confirmation.
                             },
                             dialogTitle = "Alert dialog example",
                             dialogText = "This is an example of an alert dialog with buttons.",
                             icon = Icons.Default.Info
                         )
                     }
                 }
             }
         } // Dialog.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/dialog-alert.png
      :alt: An open alert dialog that has both a dismiss and confirm button.

      **Figure 1.** An alert dialog with buttons.


Key points
----------

   ``AlertDialog`` has specific parameters for handling particular elements of
   the dialog. Among them are the following:

   -  ``title``: The text that appears along the top of the dialog.

   -  ``text``: The text that appears centered within the dialog.

   -  ``icon``: The graphic that appears at the top of the dialog.

   -  ``onDismissRequest``: The function called when the user dismisses the
      dialog, such as by tapping outside of it.

   -  ``dismissButton``: A composable that serves as the dismiss button.

   -  ``confirmButton``: A composable that serves as the confirm button.

   -  When the user clicks either of the buttons, the dialog closes. When the
      user clicks confirm, it calls a function that also handles the
      confirmation. In this example, those functions are ``onDismissRequest()``
      and ``onConfirmRequest()``.

      In cases where your dialog requires a more complex set of buttons, you may
      benefit from using the ``Dialog`` composable and populating it in a more
      freeform manner.


Create a dialog
---------------

   `Dialog </reference/kotlin/androidx/compose/ui/window/package-summary#Dialog(kotlin.Function0,androidx.compose.ui.window.DialogProperties,kotlin.Function0)>`__
   is a basic composable that doesn't provide any styling or predefined slots
   for content. It is a straightforward container that you should populate with
   a container such as ``Card``. The following are some of the key parameters of
   a dialog:

   -  **``onDismissRequest``**: The lambda called when the user closes the
      dialog.
   -  **``properties``**: An instance of `DialogProperties </reference/kotlin/androidx/compose/ui/window/DialogProperties>`__
      that provides some additional scope for customization.

   **Caution:**  You must manually specify the size and shape of ``Dialog``.
   You also must provide an inner container.

Create a basic dialog
---------------------

   The following example is a basic implementation of the ``Dialog`` composable.
   Note that it uses a ``Card`` as the secondary container. Without the
   ``Card``, the ``Text`` component would appear alone above the main app
   content.


      .. code:: prettyprint

         @Composable
         fun MinimalDialog(onDismissRequest: () -> Unit) {
             Dialog(onDismissRequest = { onDismissRequest() }) {
                 Card(
                     modifier = Modifier
                         .fillMaxWidth()
                         .height(200.dp)
                         .padding(16.dp),
                     shape = RoundedCornerShape(16.dp),
                 ) {
                     Text(
                         text = "This is a minimal dialog",
                         modifier = Modifier
                             .fillMaxSize()
                             .wrapContentSize(Alignment.Center),
                         textAlign = TextAlign.Center,
                     )
                 }
             }
         } // Dialog.kt


Result

   Note that when the dialog is open, the main app content beneath it appears
   darkened and grayed out:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/dialog-minimal.png
      :alt: A dialog that contains nothing other than a label.

      **Figure 2.** Minimal dialog.


Create an advanced dialog
-------------------------

   The following is a more advanced implemented of the ``Dialog`` composable. In
   this case, the component manually implements a similar interface to the
   preceding ``AlertDialog`` example.

   **Caution:**  If you only need to display a two-button dialog as in this
   example, you should use ``AlertDialog`` and its more convenient API. However,
   if you want to create a more complex dialog, perhaps with forms and multiple
   buttons, you should use ``Dialog`` with custom content, as in the following
   example.


      .. code:: prettyprint

         @Composable
         fun DialogWithImage(
             onDismissRequest: () -> Unit,
             onConfirmation: () -> Unit,
             painter: Painter,
             imageDescription: String,
         ) {
             Dialog(onDismissRequest = { onDismissRequest() }) {
                 // Draw a rectangle shape with rounded corners inside the dialog
                 Card(
                     modifier = Modifier
                         .fillMaxWidth()
                         .height(375.dp)
                         .padding(16.dp),
                     shape = RoundedCornerShape(16.dp),
                 ) {
                     Column(
                         modifier = Modifier
                             .fillMaxSize(),
                         verticalArrangement = Arrangement.Center,
                         horizontalAlignment = Alignment.CenterHorizontally,
                     ) {
                         Image(
                             painter = painter,
                             contentDescription = imageDescription,
                             contentScale = ContentScale.Fit,
                             modifier = Modifier
                                 .height(160.dp)
                         )
                         Text(
                             text = "This is a dialog with buttons and an image.",
                             modifier = Modifier.padding(16.dp),
                         )
                         Row(
                             modifier = Modifier
                                 .fillMaxWidth(),
                             horizontalArrangement = Arrangement.Center,
                         ) {
                             TextButton(
                                 onClick = { onDismissRequest() },
                                 modifier = Modifier.padding(8.dp),
                             ) {
                                 Text("Dismiss")
                             }
                             TextButton(
                                 onClick = { onConfirmation() },
                                 modifier = Modifier.padding(8.dp),
                             ) {
                                 Text("Confirm")
                             }
                         }
                     }
                 }
             }
         } // Dialog.kt


Result

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/dialog-image.png
      :alt: A dialog with a photo of Mount Feathertop, Victoria. Below the image
      are a dismiss button and a confirm button.

      **Figure 3.** A dialog that includes an image.


â­ Create a bottom sheet
========================

https://developer.android.google.cn/quick-guides/content/create-bottom-sheet?hl=en

   A bottom sheet shows secondary content, anchored to the bottom of the screen.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Implement a bottom sheet
------------------------

   To implement a `bottom sheet <https://m3.material.io/components/bottom-sheets/overview>`__,
   use the `ModalBottomSheet </reference/kotlin/androidx/compose/material3/package-summary#ModalBottomSheet(kotlin.Function0,androidx.compose.ui.Modifier,androidx.compose.material3.SheetState,androidx.compose.ui.unit.Dp,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,androidx.compose.ui.graphics.Color,kotlin.Function0,kotlin.Function0,androidx.compose.material3.ModalBottomSheetProperties,kotlin.Function1)>`__
   composable:


      .. code:: prettyprint

         ModalBottomSheet(onDismissRequest = { /* Executed when the sheet is dismissed */ }) {
             // Sheet content
         } // MaterialLayoutSnippets.kt


Expand and collapse the sheet
-----------------------------

   To expand and collapse the sheet, use
   `SheetState </reference/kotlin/androidx/compose/material3/SheetState>`__:


      .. code:: prettyprint

         val sheetState = rememberModalBottomSheetState()
         val scope = rememberCoroutineScope()
         var showBottomSheet by remember { mutableStateOf(false) }
         Scaffold(
             floatingActionButton = {
                 ExtendedFloatingActionButton(
                     text = { Text("Show bottom sheet") },
                     icon = { Icon(Icons.Filled.Add, contentDescription = "") },
                     onClick = {
                         showBottomSheet = true
                     }
                 )
             }
         ) { contentPadding ->
             // Screen content

             if (showBottomSheet) {
                 ModalBottomSheet(
                     onDismissRequest = {
                         showBottomSheet = false
                     },
                     sheetState = sheetState
                 ) {
                     // Sheet content
                     Button(onClick = {
                         scope.launch { sheetState.hide() }.invokeOnCompletion {
                             if (!sheetState.isVisible) {
                                 showBottomSheet = false
                             }
                         }
                     }) {
                         Text("Hide bottom sheet")
                     }
                 }
             }
         } // MaterialLayoutSnippets.kt


Key points
----------

   -  Use the ``content`` slot, which uses a
      `ColumnScope </reference/kotlin/androidx/compose/foundation/layout/ColumnScope>`__
      to lay out sheet content composables in a column.

   -  Use `rememberSheetState </reference/kotlin/androidx/compose/material3/package-summary#rememberSheetState(kotlin.Boolean,kotlin.Function1)>`__
      to create an instance of ``SheetState`` that you pass to
      ``ModalBottomSheet`` with the ``sheetState`` parameter.

   -  ``SheetState`` provides access to the `show </reference/kotlin/androidx/compose/material3/SheetState#show()>`__
      and `hide </reference/kotlin/androidx/compose/material3/SheetState#hide()>`__
      functions and to properties related to the current sheet state. These
      functions require a ``CoroutineScope`` â€” for example, `rememberCoroutineScope </reference/kotlin/androidx/compose/runtime/package-summary#remembercoroutinescope>`__
      â€” and can be called in response to UI events.

   -  Make sure to remove the ``ModalBottomSheet`` from composition when you
      hide the bottom sheet.


Results

   .. image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/material/m3-bottom-sheet.png

      **Figure 1.** A standard bottom sheet (left) and a modal bottom sheet (right).


â­ Create a slider for a range of values
========================================

https://developer.android.google.cn/quick-guides/content/create-range-slider?hl=en

   The `Slider </reference/kotlin/androidx/compose/material3/package-summary#Slider(androidx.compose.material3.SliderState,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.material3.SliderColors,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function1,kotlin.Function1)>`__
   composable lets users make selections from a range of values. You might use a
   slider to let the user do the following:

   -  Adjust settings that use a range of values, such as volume, and
      brightness.
   -  Filter data in a graph, as when setting a price range.
   -  User input, like setting a rating in a review.

   The slider contains a track, thumb, value label, and tick marks:

   -  **Track**: The track is the horizontal bar that represents the range of
      values the slider can take.
   -  **Thumb**: The thumb is a draggable control element on the slider that
      allows the user to select a specific value within the range defined by the
      track.
   -  **Tick marks**: Tick marks are optional visual markers or indicators that
      appear along the track of the slider.

   This topic shows the following slider implementations:

   -  `Basic`
   -  `Advanced`
   -  `Range`


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Create a basic slider
---------------------

   The following example is a straightforward slider. That allows the user to
   select a value from ``0.0`` to ``1.0``. Because the user can select any value
   in that range, the slider is *continuous*.


      .. code:: prettyprint

         @Preview
         @Composable
         fun SliderMinimalExample() {
             var sliderPosition by remember { mutableFloatStateOf(0f) }
             Column {
                 Slider(
                     value = sliderPosition,
                     onValueChange = { sliderPosition = it }
                 )
                 Text(text = sliderPosition.toString())
             }
         } // Slider.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/slider-basic.png
      :alt: A slider component with a value selected roughly three quarters
      along the track.
      :width: 75.0%

      **Figure 1.** A basic implementation of a slider.


Create an advanced slider
-------------------------

   The following snippet implements a slider that has three steps, with a range
   from ``0.0`` to ``50.0``. Because the thumb snaps to each step, this slider
   is *discrete*.


      .. code:: prettyprint

         @Preview
         @Composable
         fun SliderAdvancedExample() {
             var sliderPosition by remember { mutableFloatStateOf(0f) }
             Column {
                 Slider(
                     value = sliderPosition,
                     onValueChange = { sliderPosition = it },
                     colors = SliderDefaults.colors(
                         thumbColor = MaterialTheme.colorScheme.secondary,
                         activeTrackColor = MaterialTheme.colorScheme.secondary,
                         inactiveTrackColor = MaterialTheme.colorScheme.secondaryContainer,
                     ),
                     steps = 3,
                     valueRange = 0f..50f
                 )
                 Text(text = sliderPosition.toString())
             }
         } // Slider.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/slider-advanced.png
      :alt: Write your alt text here
      :width: 75.0%

      **Figure 2.** A slider with steps and a set value range.

   **Note:**  The very beginning and end of a slider count as "steps". In the
   preceding example where the range is ``0f..50f`` and the number of ``steps``
   is ``3``, each interval along the range is ``12.5`` because the beginning and
   end of the slider are also intervals the user can select.

Range slider
------------

   You can also use the dedicated `RangeSlider </reference/kotlin/androidx/compose/material3/package-summary#RangeSlider(kotlin.ranges.ClosedFloatingPointRange,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.ranges.ClosedFloatingPointRange,kotlin.Int,kotlin.Function0,androidx.compose.material3.SliderColors)>`__
   composable. This allows the user to select two values. This can be useful in
   cases such as when the user wishes to select a minimum and maximum price.

   The following example is a relatively straightforward example of a continuous
   range slider:


      .. code:: prettyprint

         @Preview
         @Composable
         fun RangeSliderExample() {
             var sliderPosition by remember { mutableStateOf(0f..100f) }
             Column {
                 RangeSlider(
                     value = sliderPosition,
                     steps = 5,
                     onValueChange = { range -> sliderPosition = range },
                     valueRange = 0f..100f,
                     onValueChangeFinished = {
                         // launch some business logic update with the state you hold
                         // viewModel.updateSelectedSliderValue(sliderPosition)
                     },
                 )
                 Text(text = sliderPosition.toString())
             }
         } // Slider.kt


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/slider-range.png
      :alt: A range slider component with two values selected. A label displays
      the upper and lower bounds of the selection.
      :width: 75.0%

      **Figure 3.** An implementation of a range slider.


Key points
----------

   See the `Slider </reference/kotlin/androidx/compose/material3/package-summary#Slider(androidx.compose.material3.SliderState,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.material3.SliderColors,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function1,kotlin.Function1)>`__
   reference for a full API definition. Some of the key parameters for the
   ``Slider`` composable are the following:

   -  **``value``**: The current value of the slider.
   -  **``onValueChange``**: A lambda that gets called every time the value is
      changed.
   -  **``enabled``**: A boolean value that indicates if the user can interact
      with the slider.

   When implementing a more complex slider, you can additionally make use of the
   following parameters.

   -  **``colors``**: An instance of ``SliderColors`` that lets you control the
      colors of the slider.
   -  **``valueRange``**: The range of values that the slider can take.
   -  **``steps``**: The number of notches on the slider to which the thumb
      snaps.

   You can also pass ``Slider`` a ``thumb`` and ``track`` composable to more
   thoroughly customize the appearance of the component.


â­ Display an animated image
============================

https://developer.android.google.cn/quick-guides/content/display-animated-image?hl=en

   You can create a more interactive and engaging user experience in your app by
   loading a drawable file to display animated images. Animated images are
   useful for creating loading indicators, success or error indicators,
   facilitating game development, and various other UI functions.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation("androidx.compose.animation:animation.graphics.android:1.6.3")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation 'androidx.compose.animation:animation.graphics.android:1.6.3'


Display an animated image
-------------------------

   The following code displays an animated vector that automatically toggles
   between two states:


      .. code:: prettyprint

         @Composable
         fun AnimatedVectorDrawable() {
             val image = AnimatedImageVector.animatedVectorResource(R.drawable.ic_hourglass_animated)
             var atEnd by remember { mutableStateOf(false) }
             Image(
                 painter = rememberAnimatedVectorPainter(image, atEnd),
                 contentDescription = "Timer",
                 modifier = Modifier.clickable {
                     atEnd = !atEnd
                 },
                 contentScale = ContentScale.Crop
             )
         }


Key points about the code
-------------------------

   -  Loads a vector resource, animating the drawing attributes over time.
   -  An ``Image`` instance that uses a `Painter </reference/kotlin/androidx/compose/ui/graphics/painter/Painter>`__
      instance to perform the animation, created from the
      ``AnimatedImageVector`` and ``boolean`` state by the
      ``rememberAnimatedVectorPainter()`` function.
   -  When ``atEnd`` is ``true``, the ``Painter`` instance stops animating.


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/avd_example_compose.gif
      :alt: Hourglass animating its contents and rotating
      :width: 75.0%

      **Figure 1.** Animated vector drawable in Compose.


â­ Create a scrollable grid
===========================

https://developer.android.google.cn/quick-guides/content/create-scrollable-grid?hl=en

   You can manage large datasets and dynamic content with lazy grids, improving
   app performance. With lazy grid composables, you can display items in a
   scrollable container, spanned across multiple columns or rows.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Decide grid orientation

   The `LazyHorizontalGrid </reference/kotlin/androidx/compose/foundation/lazy/grid/package-summary#LazyHorizontalGrid(androidx.compose.foundation.lazy.grid.GridCells,androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.grid.LazyGridState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__
   and `LazyVerticalGrid </reference/kotlin/androidx/compose/foundation/lazy/grid/package-summary#LazyVerticalGrid(androidx.compose.foundation.lazy.grid.GridCells,androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.grid.LazyGridState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__
   composables provide support for displaying items in a grid. A lazy vertical
   grid displays its items in a vertically scrollable container, spanned across
   multiple columns, while lazy horizontal grids have the same behavior on the
   horizontal axis.


Create a scrollable grid

   The following code creates a horizontal scrolling grid with three columns:


      .. code:: prettyprint

         val itemsList = (0..15).toList()

         val itemModifier = Modifier.border(1.dp, Color.Blue).width(80.dp).wrapContentSize()

         LazyHorizontalGrid(
             rows = GridCells.Fixed(3),
             horizontalArrangement = Arrangement.spacedBy(16.dp),
             verticalArrangement = Arrangement.spacedBy(16.dp)
         ) {
             items(itemsList) {
                 Text("Item is $it", itemModifier)
             }

             item {
                 Text("Single item", itemModifier)
             }

         }


Key points about the code

   -  The ``LazyHorizontalGrid`` composable determines the horizontal
      orientation of the grid.

      -  To create a vertical grid, use the ``LazyVerticalGrid`` instead.

   -  The ``rows`` property specifies how to arrange the grid content.

      -  For a vertical grid, use the ``columns`` property to specify the
         arrangement.

   -  `items(itemsList) </reference/kotlin/androidx/compose/foundation/lazy/LazyListScope#items(kotlin.Int,kotlin.Function1,kotlin.Function1,kotlin.Function2)>`__
      adds ``itemsList`` to ``LazyHorizontalGrid``. The lambda renders a
      `Text </reference/kotlin/androidx/compose/material/package-summary#Text(androidx.compose.ui.text.AnnotatedString,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.font.FontStyle,androidx.compose.ui.text.font.FontWeight,androidx.compose.ui.text.font.FontFamily,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextDecoration,androidx.compose.ui.text.style.TextAlign,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextOverflow,kotlin.Boolean,kotlin.Int,kotlin.Int,kotlin.collections.Map,kotlin.Function1,androidx.compose.ui.text.TextStyle)>`__
      composable for each item and set the text to the item description.

   -  `item() </reference/kotlin/androidx/compose/foundation/lazy/LazyListScope#item(kotlin.Any,kotlin.Any,kotlin.Function1)>`__
      adds a single item to ``LazyHorizontalGrid`` while the lambda renders a
      single ``Text`` composable in a similar manner to ``items()``.

   -  `GridCells.Fixed </reference/kotlin/androidx/compose/foundation/lazy/grid/GridCells.Fixed>`__
      defines the number of rows or columns.

   -  To create a grid with as many rows as possible, set the number of rows
      using `GridCells.Adaptive </reference/kotlin/androidx/compose/foundation/lazy/grid/GridCells.Adaptive>`__.

      In the following code, the ``20.dp`` value specifies that every column is
      at least 20.dp, and all columns have equal widths. If the screen is 88.dp
      wide, there are 4 columns at 22.dp each.

      .. container:: iframe

         .. code:: prettyprint

            LazyVerticalGrid(
                columns = GridCells.Adaptive(minSize = 20.dp)
            )


Results

   **Figure 1.** A horizontal scrollable grid using ``LazyHorizontalGrid``.


â­ Display a bottom app bar
===========================

https://developer.android.google.cn/quick-guides/content/display-bottom-app-bar?hl=en

   Create a bottom app bar to help users navigate and access functions in your
   app. Follow this guidance to add a bottom app bar to your app by using the
   `BottomAppBar </reference/com/google/android/material/bottomappbar/BottomAppBar>`__
   composable.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation ("androidx.compose.material:compose-material-icons-extended-android")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation 'androidx.compose.material:compose-material-icons-extended-android'


Create a bottom app bar
-----------------------

   Use the following code to create a bottom app bar containing four icon
   buttons, and a floating action button:


      .. code:: prettyprint

         @Composable
         fun BottomAppBarExample() {
             Scaffold(
                 bottomBar = {
                     BottomAppBar(
                         actions = {
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(Icons.Filled.Check, contentDescription = "Localized description")
                             }
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     Icons.Filled.Edit,
                                     contentDescription = "Localized description",
                                 )
                             }
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     Icons.Filled.Mic,
                                     contentDescription = "Localized description",
                                 )
                             }
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     Icons.Filled.Image,
                                     contentDescription = "Localized description",
                                 )
                             }
                         },
                         floatingActionButton = {
                             FloatingActionButton(
                                 onClick = { /* do something */ },
                                 containerColor = BottomAppBarDefaults.bottomAppBarFabColor,
                                 elevation = FloatingActionButtonDefaults.bottomAppBarFabElevation()
                             ) {
                                 Icon(Icons.Filled.Add, "Localized description")
                             }
                         }
                     )
                 },
             ) { innerPadding ->
                 Text(
                     modifier = Modifier.padding(innerPadding),
                     text = "Example of a scaffold with a bottom app bar."
                 )
             }
         }


Key points about the code
-------------------------

   -  An outer `Scaffold </reference/kotlin/androidx/compose/material/package-summary#Scaffold(androidx.compose.foundation.layout.WindowInsets,androidx.compose.ui.Modifier,androidx.compose.material.ScaffoldState,kotlin.Function0,kotlin.Function0,kotlin.Function1,kotlin.Function0,androidx.compose.material.FabPosition,kotlin.Boolean,kotlin.Function1,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.ui.unit.Dp,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function1)>`__
      that has a ``bottomBar`` set.

   -  A ``bottomBar`` implementation that contains a list of actions.

   -  Actions that are implementations of
      `IconButton </reference/kotlin/androidx/compose/material/package-summary#IconButton(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function0)>`__
      that contain `Icon </reference/kotlin/androidx/compose/material3/package-summary#Icon(androidx.compose.ui.graphics.ImageBitmap,kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color)>`__
      for image and content description text, each with an ``onClick`` lambda to
      perform these actions.

   You can pass composables for the following key parameters:

   -  ``actions``: a series of icons that appear on the left side of the bar.
      These are commonly either key actions for the given screen, or navigation
      items.

   -  `floatingActionButton </reference/com/google/android/material/floatingactionbutton/FloatingActionButton>`__:
      the floating action button that appears on the right side of the bar.

   **Note:**  After you add the bottom app bar, you can customize it with
   content as you do with other containers by filling the ``BottomAppBar``
   composable with other content. You can also use ``BottomAppBar`` without
   passing a value for ``actions`` or ``floatingActionButton``.

Results

   .. figure:: https://developer.android.google.cn/static/quick-guides/content/bottom-app-bar.png
      :alt: An example of a bottom app bar
      :width: 250px

      **Figure 1.** An example of a bottom app bar.


â­ Style parts of text
======================

https://developer.android.google.cn/quick-guides/content/style-parts-text?hl=en

   You can style parts of text to improve readability, increase positive user
   experience, and encourage greater creativity through use of colors and fonts.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Style parts of text
-------------------

   The following code displays the string "Hello World" using blue for the "H",
   red for the "W", and black for the rest of the text. To set different styles
   within a single `Text </reference/kotlin/androidx/compose/material/package-summary#Text(androidx.compose.ui.text.AnnotatedString,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.font.FontStyle,androidx.compose.ui.text.font.FontWeight,androidx.compose.ui.text.font.FontFamily,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextDecoration,androidx.compose.ui.text.style.TextAlign,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextOverflow,kotlin.Boolean,kotlin.Int,kotlin.Int,kotlin.collections.Map,kotlin.Function1,androidx.compose.ui.text.TextStyle)>`__
   composable, use the following code:


      .. code:: prettyprint

          @Composable
             fun MultipleStylesInText() {
                 Text(
                     buildAnnotatedString {
                         withStyle(style = SpanStyle(color = Color.Blue)) {
                             append("H")
                         }
                         append("ello ")

                         withStyle(style = SpanStyle(fontWeight = FontWeight.Bold, color = Color.Red)) {
                             append("W")
                         }
                         append("orld")
                     }
                 )
             }


Key points about the code

   -  Uses `buildAnnotatedString </reference/kotlin/androidx/compose/ui/text/package-summary#buildAnnotatedString(kotlin.Function1)>`__
      that returns an `AnnotatedString </reference/kotlin/androidx/compose/ui/text/AnnotatedString>`__
      string to set different styles within text.

   -  Styles part of text with `SpanStyle </reference/kotlin/androidx/compose/ui/text/SpanStyle>`__,
      a configuration that allows character-level styling.


Results

   .. figure::
      https://developer.android.google.cn/static/quick-guides/content/style%20parts%20of%20a%20text%20display.png
      :alt: Hello World text with multiple styles
      :width: 250px

      **Figure 1.** A line of text with multiple styles.


â­ Display a paging list
========================

https://developer.android.google.cn/quick-guides/content/display-paging-list?hl=en

   Create a paging list so that users can scroll to access content too large to
   fit on a single screen. Horizontal paging lists can help users navigate
   through content such as images, slideshows, or product carousels. Vertical
   paging lists are useful for content-heavy apps where users may need to scroll
   through a large number of items, such as articles.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Create a paging list
--------------------

   You can configure a horizontal or vertical paging list, depending on the
   orientation required for your app. The following code creates a horizontal
   paging list displaying 10 items:


      .. code:: prettyprint

         val pagerState = rememberPagerState(pageCount = {
             10
         })
         HorizontalPager(state = pagerState) { page ->
             Text(
                 text = "Page: $page",
                 modifier = Modifier.fillMaxWidth()
             )
         }


Key points about the code
-------------------------

   -  The `HorizontalPager </reference/kotlin/androidx/compose/foundation/pager/package-summary#HorizontalPager(androidx.compose.foundation.pager.PagerState,androidx.compose.ui.Modifier,androidx.compose.foundation.layout.PaddingValues,androidx.compose.foundation.pager.PageSize,kotlin.Int,androidx.compose.ui.unit.Dp,androidx.compose.ui.Alignment.Vertical,androidx.compose.foundation.gestures.TargetedFlingBehavior,kotlin.Boolean,kotlin.Boolean,kotlin.Function1,androidx.compose.ui.input.nestedscroll.NestedScrollConnection,androidx.compose.foundation.gestures.snapping.SnapPosition,kotlin.Function2)>`__
      composable provides a horizontally scrollable list of items.

      -  To create a vertical paging list, use the `VerticalPager </reference/kotlin/androidx/compose/foundation/pager/package-summary#VerticalPager(androidx.compose.foundation.pager.PagerState,androidx.compose.ui.Modifier,androidx.compose.foundation.layout.PaddingValues,androidx.compose.foundation.pager.PageSize,kotlin.Int,androidx.compose.ui.unit.Dp,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.TargetedFlingBehavior,kotlin.Boolean,kotlin.Boolean,kotlin.Function1,androidx.compose.ui.input.nestedscroll.NestedScrollConnection,androidx.compose.foundation.gestures.snapping.SnapPosition,kotlin.Function2)>`__
         composable instead.

   -  Each page in the list contains a `Text </reference/kotlin/androidx/compose/material/package-summary#Text(androidx.compose.ui.text.AnnotatedString,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.font.FontStyle,androidx.compose.ui.text.font.FontWeight,androidx.compose.ui.text.font.FontFamily,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextDecoration,androidx.compose.ui.text.style.TextAlign,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextOverflow,kotlin.Boolean,kotlin.Int,kotlin.Int,kotlin.collections.Map,kotlin.Function1,androidx.compose.ui.text.TextStyle)>`__
      object that displays the string "Page" and the page index number.

   -  An instance of `rememberPagerState() </reference/kotlin/androidx/compose/foundation/pager/package-summary#rememberPagerState(kotlin.Int,kotlin.Float)>`__
      persists a page's state when the user navigates away, and displays the
      same page when the user returns to it.


Results


   .. image:: https://developer.android.google.cn/static/quick-guides/content/horizintal_pager_compose.mp4

      Figure 1. Demo of HorizontalPager.



â­ Create a button to enable snap scrolling
===========================================

https://developer.android.google.cn/quick-guides/content/enable-snap-scrolling?hl=en

   You can display a button to let a user snap scroll to a specific point in a
   list, saving time and increasing user engagement.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation("androidx.compose.material3:material3")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation 'androidx.compose.material3:material3'


Create a button to enable snap scrolling
----------------------------------------

   Use the following code to create a button for smooth snap scrolling in a
   vertical lazy list with 10 items:


      .. code:: prettyprint

         @Composable
         fun MessageList(modifier: Modifier = Modifier) {
             val listState = rememberLazyListState()
             val coroutineScope = rememberCoroutineScope()

             LazyColumn(state = listState, modifier = Modifier.height(120.dp)) {
                 items(10) { index ->
                     Text(
                         modifier = Modifier.height(40.dp),
                         text = "Item $index"
                     )
                 }
             }

             Button(onClick = {
                 coroutineScope.launch {
                     listState.animateScrollToItem(index = 0)
                 }
             }) {
                 Text(text = "Go top")
             }
         }


Key points about the code
-------------------------

   -  Uses the `listState </reference/kotlin/androidx/compose/foundation/lazy/LazyListState>`__
      object to remember the scroll state of `LazyColumn </reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyColumn(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__
      to the selected position.

   -  Launches a coroutine to call `listState.animateScrollToItem </reference/kotlin/androidx/compose/foundation/lazy/LazyListState#animateScrollToItem(kotlin.Int,kotlin.Int)>`__,
      which scrolls to the indexed item while animating the scrolling action.


Results

   .. figure:: https://developer.android.google.cn/static/quick-guides/content/snap-scroll.gif
      :alt: A vertically scrolling list with an active button
      :width: 250px

      **Figure 1.** A vertical scrolling list with a snap scroll button.


â­ Animate character-by-character the appearance of text
========================================================

https://developer.android.google.cn/quick-guides/content/animate-text?hl=en

   You can animate, character-by-character, the appearance of text, so it looks
   like a streaming typing effect, similar to what a typewriter would produce.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation("androidx.compose.material3:material3")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation 'androidx.compose.material3:material3'


Animate text character-by-character
-----------------------------------

   This code animates text character-by-character. It tracks an index to control
   how much of the text is revealed. The displayed text updates dynamically to
   show only the characters up to the current index. Finally, the variable runs
   the animation when it changes.


      .. code:: prettyprint

         @Composable
         fun LetterByLetterAnimatedText() {
             val text = "This text animates as though it is being typed \uD83E\uDDDE\u200Dâ™€\uFE0F \uD83D\uDD10  \uD83D\uDC69\u200Dâ¤\uFE0F\u200D\uD83D\uDC68 \uD83D\uDC74\uD83C\uDFFD"

             // Iterate over the characters.
             val breakIterator = remember(text) { BreakIterator.getCharacterInstance() }

             // Define the duration (milliseconds) of the pause before each successive
             // character is displayed. These pauses between characters create the
             // illusion of an animation.
             val typingDelayInMs = 50L

             var substringText by remember {
                 mutableStateOf("")
             }
             LaunchedEffect(text) {
                 // Initial start delay of the typing animation
                 delay(1000)
                 breakIterator.text = StringCharacterIterator(text)

                 var nextIndex = breakIterator.next()
                 // Iterate over the string, by index boundary
                 while (nextIndex != BreakIterator.DONE) {
                     substringText = text.subSequence(0, nextIndex).toString()
                     // Go to the next logical character boundary
                     nextIndex = breakIterator.next()
                     delay(typingDelayInMs)
                 }
             }
             Text(substringText)
         }


Key points about the code

   -  `BreakIterator </reference/android/icu/text/BreakIterator>`__
      correctly iterates over characters regardless of how they are stored. For
      example, animated emojis are made up of multiple characters;
      ``BreakIterator`` ensures that they're handled as a single character, so
      that the animation isn't broken.

   -  `LaunchedEffect </reference/kotlin/androidx/compose/runtime/package-summary#LaunchedEffect(kotlin.Any,kotlin.coroutines.SuspendFunction1)>`__
      starts a coroutine to introduce the delay between the characters. You can
      replace the code block with a click listenerâ€“or any other eventâ€“to trigger
      animation.

   -  The `Text </reference/kotlin/androidx/compose/material/package-summary#Text(kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.font.FontStyle,androidx.compose.ui.text.font.FontWeight,androidx.compose.ui.text.font.FontFamily,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextDecoration,androidx.compose.ui.text.style.TextAlign,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextOverflow,kotlin.Boolean,kotlin.Int,kotlin.Int,kotlin.Function1,androidx.compose.ui.text.TextStyle)>`__
      composable re-renders every time the value of ``substringText`` is
      updated.


Results

   .. image:: https://developer.android.google.cn/static/quick-guides/content/animate_char_by_char_example.mp4

      **Figure 1.** Text and emoji animated character-by-character.


â­ Show or hide password based on a user toggle
===============================================

https://developer.android.google.cn/quick-guides/content/show-hide-password?hl=en

   You can create an icon to hide or show a password based on a user toggle to
   improve security and enhance the user experience.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation("androidx.compose.material3:material3")
            implementation ("androidx.compose.material:material-icons-extended")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation 'androidx.compose.material3:material3'
            implementation 'androidx.compose.material:material-icons-extended'


Show or hide a password based on user toggle
--------------------------------------------

   To show or hide a password based on a user toggle, create an input field for
   entering information and use a clickable icon for the toggle:


      .. code:: prettyprint

         @Composable
         fun PasswordTextField() {
            var password by rememberSaveable { mutableStateOf("") }
            var showPassword by remember { mutableStateOf(false) }
            val passwordVisualTransformation = remember { PasswordVisualTransformation() }

            TextField(
                value = password,
                onValueChange = { password = it },
                label = { Text("Enter password") },
                visualTransformation = if (showPassword) {
                    VisualTransformation.None
                } else {
                    passwordVisualTransformation
                },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
                modifier = Modifier.fillMaxWidth(),
                trailingIcon = {
                    Icon(
                        if (showPassword) {
                             Icons.Filled.Visibility
                         } else {
                             Icons.Filled.VisibilityOff
                         },
                        contentDescription = "Toggle password visibility",
                        modifier = Modifier.clickable { showPassword = !showPassword })
                }
            )
         }


Key points about the code
-------------------------

   -  Maintains the password visibility state in ``showPassword``.

   -  Uses a `TextField </reference/kotlin/androidx/compose/material/package-summary#TextField(androidx.compose.ui.text.input.TextFieldValue,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors)>`__
      composable for password entry.

   -  Has a clickable trailing icon, which toggles the value of
      ``showPassword``.

   -  Defines the `visualTransformation </reference/kotlin/androidx/compose/ui/text/input/VisualTransformation>`__
      attribute and the ``painter`` of the trailing icon by the state of
      ``showPassword``.

   -  Dictates the ``visualTransformation`` attribute to display or hide the
      password.


Results

   .. figure:: https://developer.android.google.cn/static/quick-guides/content/password_visibility_toggle.gif
      :alt: Toggling the show and hide password icon
      :width: 250px

      **Figure 1.** Toggling the show and hide password icon.


â­ Display a top app bar
========================

https://developer.android.google.cn/quick-guides/content/display-top-app-bar?hl=en

   Create a top app bar to help users navigate and access functions in your app,
   using the `TopAppBar </reference/kotlin/androidx/compose/material3/package-summary#TopAppBar(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function1,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.WindowInsets,androidx.compose.material3.TopAppBarColors,androidx.compose.material3.TopAppBarScrollBehavior)>`__
   composable.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Create a composable for top app bar
-----------------------------------

   Create a top app bar using the `MediumTopAppBar </reference/kotlin/androidx/compose/material3/package-summary#MediumTopAppBar(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function1,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.WindowInsets,androidx.compose.material3.TopAppBarColors,androidx.compose.material3.TopAppBarScrollBehavior)>`__
   composable that collapses when the user scrolls down the content area, and
   expands when the user scrolls back to the top of the content:


      .. code:: prettyprint

         @Composable
         fun MediumTopAppBarExample() {
             val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior(rememberTopAppBarState())

             Scaffold(
                 modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),
                 topBar = {
                     MediumTopAppBar(
                         colors = TopAppBarDefaults.topAppBarColors(
                             containerColor = MaterialTheme.colorScheme.primaryContainer,
                             titleContentColor = MaterialTheme.colorScheme.primary,
                         ),
                         title = {
                             Text(
                                 "Medium Top App Bar",
                                 maxLines = 1,
                                 overflow = TextOverflow.Ellipsis
                             )
                         },
                         navigationIcon = {
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     imageVector = Icons.Filled.ArrowBack,
                                     contentDescription = "Localized description"
                                 )
                             }
                         },
                         actions = {
                             IconButton(onClick = { /* do something */ }) {
                                 Icon(
                                     imageVector = Icons.Filled.Menu,
                                     contentDescription = "Localized description"
                                 )
                             }
                         },
                         scrollBehavior = scrollBehavior
                     )
                 },
             ) { innerPadding ->
                 ScrollContent(innerPadding)
             }
         }


Key points about the code
-------------------------

   -  An outer `Scaffold </reference/kotlin/androidx/compose/material/package-summary#Scaffold(androidx.compose.foundation.layout.WindowInsets,androidx.compose.ui.Modifier,androidx.compose.material.ScaffoldState,kotlin.Function0,kotlin.Function0,kotlin.Function1,kotlin.Function0,androidx.compose.material.FabPosition,kotlin.Boolean,kotlin.Function1,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.ui.unit.Dp,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function1)>`__
      with a ``TopBar`` set.

   -  A title consisting of a single ``Text`` element.

   -  A top bar with a single action defined.

   -  An `IconButton </reference/kotlin/androidx/compose/material/package-summary#IconButton(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function0)>`__
      action with an ``onClick`` lambda to perform the action.

   -  An ``IconButton`` containing an `Icon </reference/kotlin/androidx/compose/material3/package-summary#Icon(androidx.compose.ui.graphics.ImageBitmap,kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color)>`__
      that has an icon image and a content description text.

   -  The scroll behavior for the Scaffold's inner content is defined as
      ``enterAlwaysScrollBehavior()``. This collapses the app bar when the user
      pulls up the inner content, and expands the app bar when the user pulls
      down the inner content.

   -  In addition to ``MediumTopBar``, which contains the title, you can also
      use:

      -  ``TopAppBar``: use for screens that don't require a lot of navigation
         or actions.

      -  `CenterAlignedTopAppBar </reference/kotlin/androidx/compose/material3/package-summary#CenterAlignedTopAppBar(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function1,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.WindowInsets,androidx.compose.material3.TopAppBarColors,androidx.compose.material3.TopAppBarScrollBehavior)>`__:
         use for screens that have a single primary action.Title is centered
         within the component.

      -  ``MediumTopAppBar``: use for screens that require a moderate amount of
         navigation and actions.

      -  `LargeTopAppBar </reference/kotlin/androidx/compose/material3/package-summary#LargeTopAppBar(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function1,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.WindowInsets,androidx.compose.material3.TopAppBarColors,androidx.compose.material3.TopAppBarScrollBehavior)>`__:
         use for screens that require a lot of navigation and actions. Uses more
         padding than ``MediumTopAppBar`` and places the title beneath any
         additional icons.


Results

   .. image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-scroll.mp4

      **Figure 1.** A medium top app bar.


â­ Support multiple links in a single string of text
====================================================

https://developer.android.google.cn/quick-guides/content/support-multiple-links?hl=en

   You can support multiple links in a single string of text to perform
   different actions when clicking a subsection of text.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation("androidx.compose.material3:material3")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation 'androidx.compose.material3:material3'


Display multiple links in a single string
-----------------------------------------

   This snippet embeds multiple clickable links into a single string of text:


      .. code:: prettyprint

         @Composable
         fun AnnotatedClickableText() {
             val annotatedText = buildAnnotatedString {
                 append("Go to ")

                 // We attach this *URL* annotation to the following content until `pop()` is called.
                 pushStringAnnotation(
                     tag = "URL", annotation = "https://developer.android.com"
                 )
                 withStyle(
                     style = SpanStyle(
                         color = Color.Green, fontWeight = FontWeight.Bold
                     )
                 ) {
                     append("Android Developers")
                 }
                 pop()

                 append(" and check the ")

                 pushStringAnnotation(
                     tag = "URL", annotation = "https://developer.android.com/jetpack/compose"
                 )
                 withStyle(
                     style = SpanStyle(
                         color = Color.Blue, fontWeight = FontWeight.Bold
                     )
                 ) {
                     append("Compose guidelines.")
                 }
                 pop()
             }

             ClickableText(text = annotatedText, onClick = { offset ->
                 annotatedText.getStringAnnotations(
                     tag = "URL", start = offset, end = offset
                 ).firstOrNull()?.let { annotation ->
                     // If yes, we log its value.
                     Log.d("Clicked URL", annotation.item)
                 }
             })
         }


Key points about the code
-------------------------

   -  Uses the `buildAnnotatedString </reference/kotlin/androidx/compose/ui/text/package-summary#buildAnnotatedString(kotlin.Function1)>`__
      function to create an annotated string of text.

   -  Uses the `pushStringAnnotation() </reference/kotlin/androidx/compose/ui/text/AnnotatedString.Builder#pushStringAnnotation(kotlin.String,kotlin.String)>`__
      method to begin annotating the upcoming text with any necessary
      information, such as a URL string.

   -  Adds text using `append() </reference/kotlin/androidx/compose/ui/text/AnnotatedString.Builder#append(kotlin.CharSequence,kotlin.Int,kotlin.Int)>`__,
      and then uses the `pop() </reference/kotlin/androidx/compose/ui/text/AnnotatedString.Builder#pop()>`__
      method to halt the text annotation.

   -  To add more links, repeat the previous two steps by surrounding each link
      with the ``pushStringAnnotation()`` and ``pop()`` methods. This annotates
      the text handled by the ``onClick`` event.

   -  Creates a `ClickableText </reference/kotlin/androidx/compose/foundation/text/package-summary#ClickableText(androidx.compose.ui.text.AnnotatedString,androidx.compose.ui.Modifier,androidx.compose.ui.text.TextStyle,kotlin.Boolean,androidx.compose.ui.text.style.TextOverflow,kotlin.Int,kotlin.Function1,kotlin.Function1)>`__
      component and uses the ``onClick`` parameter to manage user taps. Verify
      if there is a URL annotation linked to the text where you clicked. Then
      you can perform the click actions.


Results

   .. figure:: https://developer.android.google.cn/static/quick-guides/content/multiple-links.png
      :alt: One text string containing two different links
      :width: 100.0%

      **Figure 1.** A screenshot of one text string containing two different
      links.


â­ Create a finite scrollable list
==================================

https://developer.android.google.cn/quick-guides/content/finite-scrolling-list?hl=en

   Scrollable lists can help manage datasets, create responsive designs, and
   facilitate navigation. You can display smaller collections of items in your
   app by using a finite scrolling list. To avoid performance issues with larger
   datasets or a list of unknown length, see `Lazily load data with lists and Paging </quick-guides/content/lazily-load-list>`__.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Create a vertical scrolling list

   Use the following code to create a vertical scrolling list:


      .. code:: prettyprint

         @Composable
         private fun ScrollBoxes(modifier: Modifier = Modifier) {
             Column(
                 modifier = Modifier.thenOtherModifiers
                     .background(Color.LightGray)
                     .size(100.dp)
                     .verticalScroll(rememberScrollState())
             ) {
                 repeat(10) {
                     Text("Item $it", modifier = Modifier.padding(2.dp))
                 }
             }
         }


Key points about the code
-------------------------

   -  Sets the `Column </reference/kotlin/androidx/compose/foundation/layout/package-summary#Column(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,kotlin.Function1)>`__
      scrolling behavior with the `verticalScroll </reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier).verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)>`__
      modifier and the `rememberScrollState </reference/kotlin/androidx/compose/foundation/package-summary#rememberScrollState(kotlin.Int)>`__
      function.

   -  To create a horizontal scrolling list, create a `Row </reference/kotlin/androidx/compose/foundation/layout/package-summary#Row(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,kotlin.Function1)>`__
      with a `horizontalScroll </reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier).horizontalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)>`__
      modifier.


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/gestures-simplescroll.gif

      A vertical list responding to scroll gestures

      **Figure 1.** A vertical scrolling list.


â­ Build a list using multiple item types
=========================================

https://developer.android.google.cn/quick-guides/content/build-list-multiple-item-types?hl=en

   You can use a list with multiple item types to display mixed content types
   such as text, images, and interactive elements.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Add multiple item types

   You can specify the content type for each item of the layout when you compose
   a list or a grid with multiple types of items:


      .. code:: prettyprint

              LazyColumn {
                     items(
                           messages,
                           contentType = { it.type }
                     ) {
                           when (message.type) {
               // Content Types and Composables are defined elsewhere.
                              is Audio -> AudioMessage(message)
                              is Text -> TextMessage(message)
              }
         }


Key points about the code
-------------------------

   -  Specifies the content type for each item by setting `contentType </reference/kotlin/androidx/compose/foundation/lazy/package-summary#extension-functions-summary>`__
      in `items() </reference/kotlin/androidx/compose/foundation/lazy/LazyListScope#items(kotlin.Int,kotlin.Function1,kotlin.Function1,kotlin.Function2)>`__.

   -  Maps each content type to a corresponding composable. For example,
      ``Audio`` is a ``contentType`` that is defined elsewhere and is mapped to
      an ``AudioMessage`` composable.

   -  Compose reuses the rendered composables for each item of a given content
      type.


Results

   .. figure:: https://developer.android.google.cn/static/quick-guides/content/multiple-item-types.png
      :alt: Code output showing audio and text messages
      :width: 250px

      **Figure 1.** Code output showing audio and text messages.


â­ Create a parallax scrolling effect
=====================================

https://developer.android.google.cn/quick-guides/content/parallax-scrolling?hl=en

   Parallax scrolling is a technique in which the background content and
   foreground content scroll at different speeds. You can implement this
   technique to enhance your app's UI, creating a more dynamic experience as
   your users scroll.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


            .. code:: kotlin

                 implementation(platform("androidx.compose:compose-bom:2024.06.00"))


            .. code:: groovy

                 implementation platform('androidx.compose:compose-bom:2024.06.00')


Create a parallax effect
------------------------

   To achieve the parallax effect, you apply a fraction of the scrolling value
   from the scrolling composable to the composable that needs the parallax
   effect. The following snippet takes two nested visual elementsâ€”an image and a
   block of textâ€”and scrolls them in the same direction at different speeds:


      .. code:: prettyprint

         fun Modifier.parallaxLayoutModifier(scrollState: ScrollState, rate: Int) =
                 layout { measurable, constraints ->
                     val placeable = measurable.measure(constraints)
                     val height = if (rate > 0) scrollState.value / rate else scrollState.value
                     layout(placeable.width, placeable.height) {
                         placeable.place(0, height)
                     }
                 }

           val scrollState = rememberScrollState()
                             Column(
                                 modifier = Modifier
                                     .fillMaxWidth()
                                     .verticalScroll(scrollState),
                             ) {

                                     Image(
                                         painterResource(id = R.drawable.cupcakes),
                                         contentDescription = "Android logo",
                                         contentScale = ContentScale.Fit,
                                  // Reduce scrolling rate by half.
                                         modifier = parallaxLayoutModifier(scrollState, 2)
                                     )

                                 Text(
                                     text = stringResource(R.string.detail_placeholder),
                                     modifier = Modifier
                                         .background(Color.White)
                                         .padding(horizontal = 8.dp),

                                 )
                             }


Key points about the code
-------------------------

   -  Creates a custom ``layout`` modifier to adjust the rate by which the
      composable scrolls.

   -  The ``Image`` scrolls at a slower rate than the ``Text``, producing a
      parallax effect as the two composables translate vertically at different
      rates.


Results

   .. image:: https://developer.android.google.cn/static/quick-guides/content/parallax_video.mp4

      **Figure 1.** A scrolling list with a parallax effect.


â­ Display an image clipped to a shape
======================================

https://developer.android.google.cn/quick-guides/content/clipped-image?hl=en

   You can draw shadows around the clipped area of the image so that you can
   display an image in the shape of a clip. With this technique you can
   customize your app, creating designs such as avatars and product thumbnails,
   or displaying logos with custom shapes. To clip and display an image, you
   must do the following:

   -  Create a custom shape.
   -  Clip the image to a shape.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation("androidx.graphics:graphics-shapes:1.0.0-alpha05")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation 'androidx.graphics:graphics-shapes:1.0.0-alpha05'


Create a custom shape
---------------------

   The following code creates a custom shape that can dynamically draw and
   render a rounded polygon:


      .. code:: prettyprint

         fun RoundedPolygon.getBounds() = calculateBounds().let { Rect(it[0], it[1], it[2], it[3]) }
         class RoundedPolygonShape(
             private val polygon: RoundedPolygon,
             private var matrix: Matrix = Matrix()
         ) : Shape {
             private var path = Path()
             override fun createOutline(
                 size: Size,
                 layoutDirection: LayoutDirection,
                 density: Density
             ): Outline {
                 path.rewind()
                 path = polygon.toPath().asComposePath()
                 matrix.reset()
                 val bounds = polygon.getBounds()
                 val maxDimension = max(bounds.width, bounds.height)
                 matrix.scale(size.width / maxDimension, size.height / maxDimension)
                 matrix.translate(-bounds.left, -bounds.top)

                 path.transform(matrix)
                 return Outline.Generic(path)
             }
         }


Key points about the code
-------------------------

   -  ``RoundedPolygon.getBounds()`` defines an extension function on the
      `RoundedPolygon </reference/kotlin/androidx/graphics/shapes/RoundedPolygon>`__
      class to calculate its bounds.

   -  The ``RoundedPolygonShape`` class implements the `Shape </reference/kotlin/androidx/compose/ui/graphics/Shape>`__
      interface, allowing you to define a custom shape (a rounded polygon) in
      Jetpack Compose.

   -  The shape uses a `Matrix </reference/kotlin/androidx/compose/ui/graphics/Matrix>`__ to
      manage scaling and translation operations for flexible rendering.

   -  The ``createOutline()`` function takes a ``RoundedPolygon`` object, scales
      and translates it to fit within a given size, and returns an `Outline </reference/kotlin/androidx/compose/ui/graphics/Outline>`__
      object that describes the final shape to be drawn.


Clip the image to a shape
-------------------------

   The following code crops the image to the hexagon shape, and adds a subtle
   drop shadow to provide a sense of depth:


      .. code:: prettyprint

         val hexagon = remember {
             RoundedPolygon(
                 6,
                 rounding = CornerRounding(0.2f)
             )
         }
         val clip = remember(hexagon) {
             RoundedPolygonShape(polygon = hexagon)
         }
         Box(
             modifier = Modifier.fillMaxSize(),
             contentAlignment = Alignment.Center
         ) {
             Image(
                 painter = painterResource(id = R.drawable.dog),
                 contentDescription = "Dog",
                 contentScale = ContentScale.Crop,
                 modifier = Modifier
                     .graphicsLayer {
                         this.shadowElevation = 6.dp.toPx()
                         this.shape = clip
                         this.clip = true
                         this.ambientShadowColor = Color.Black
                         this.spotShadowColor = Color.Black
                     }
                     .size(200.dp)

             )
         }


Key points about the code
-------------------------

   -  The ``RoundedPolygon`` and ``RoundedPolygonShape`` objects are used to
      define and apply a hexagonal shape to the image.

   -  The code uses `graphicsLayer </reference/kotlin/androidx/compose/ui/graphics/package-summary#(androidx.compose.ui.Modifier).graphicsLayer(kotlin.Function1)>`__
      to add an elevation-based shadow to the image. This creates a sense of
      depth and visual separation from the background.

   -  The use of `remember </reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0)>`__
      blocks optimizes performance by ensuring that the shape and clipping
      definitions are calculated only once and remembered for later
      recompositions of the UI.


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/clip_with_shadow.png
      :alt: Dog in hexagon with shadow applied around the edges
      :width: 300px

      **Figure 1.** Custom shape applied as clip.


â­ Validate input as the user types
===================================

https://developer.android.google.cn/quick-guides/content/validate-input?hl=en

   You can validate input as the user types in a text field, such as entering a
   name, email, address, or other contact information. This validation reduces
   errors and saves your users time.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Validate input as the user types
--------------------------------

   Use the following code to display the field input and validate the text while
   the user types. If the information is not validated, an error message helps
   the user correct the input.


      .. code:: prettyprint

         class EmailViewModel : ViewModel() {
             var email by mutableStateOf("")
                 private set

             val emailHasErrors by derivedStateOf {
                 if (email.isNotEmpty()) {
                     // Email is considered erroneous until it completely matches EMAIL_ADDRESS.
                     !android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()
                 } else {
                     false
                 }
             }

             fun updateEmail(input: String) {
                 email = input
             }
         }

         @Composable
         fun ValidatingInputTextField(
             email: String,
             updateState: (String) -> Unit,
             validatorHasErrors: Boolean
         ) {
             OutlinedTextField(
                 modifier = Modifier
                     .fillMaxWidth()
                     .padding(10.dp),
                 value = email,
                 onValueChange = updateState,
                 label = { Text("Email") },
                 isError = validatorHasErrors,
                 supportingText = {
                     if (validatorHasErrors) {
                         Text("Incorrect email format.")
                     }
                 }
             )
         }

         ValidatingInputTextField(
                         email = viewModel.email,
                         updateState = { input -> viewModel.updateEmail(input) },
                         validatorHasErrors = viewModel.emailHasErrors
                     )


Key points about the code
-------------------------

   -  Defines a composable that reuses the `OutlinedTextField </reference/kotlin/androidx/compose/material/package-summary#TextField(kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors)>`__
      component, adding the required parameters to display validator error
      messages as user types.

   -  ``EmailViewModel`` is used to maintain state and provide the email
      validation logic.

   -  if ``isError`` is true, the UI provides a visual indicator of a validation
      error state.

   -  The component will display "Incorrect email format." until a complete,
      correct email is input.


Results

   .. figure:: https://developer.android.google.cn/static/quick-guides/content/email_validation.png
      :alt: A valid text input
      :width: 500px

      **Figure 1.** A text input field with email validators displaying no error
      messages for a valid email address.

   .. figure:: https://developer.android.google.cn/static/quick-guides/content/invalid_email_format_example.png
      :alt: An invalid text input with errors
      :width: 500px

      **Figure 2.** A text input field displaying an error message when an
      invalid email address is entered.


â­ Auto-format a phone number in a text field
=============================================

https://developer.android.google.cn/quick-guides/content/auto-format-phone-number?hl=en

   You can auto format a phone number in a text field in your app, saving users
   time by formatting the phone number as they input digits. Follow this
   guidance to auto format a phone number:

   -  Create the text field.
   -  Auto-format a number in the text field.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation("androidx.compose.material3:material3")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation 'androidx.compose.material3:material3'


Create the text field
---------------------

   First, configure the `TextField </reference/kotlin/androidx/compose/material/package-summary#TextField(androidx.compose.ui.text.input.TextFieldValue,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors)>`__.
   This example shows a phone number formatted per the North American Numbering
   Plan (NANP). ``NanpVisualTransformation`` formats a raw string of numbers to
   NANP, eg. 1234567890 to (123) 456-7890.


      .. code:: prettyprint

         @Composable
         fun PhoneNumber() {
             var phoneNumber by rememberSaveable { mutableStateOf("") }
             val numericRegex = Regex("[^0-9]")
             TextField(
                 value = phoneNumber,
                 onValueChange = {
                     // Remove non-numeric characters.
                     val stripped = numericRegex.replace(it, "")
                     phoneNumber = if (stripped.length >= 10) {
                         stripped.substring(0..9)
                     } else {
                         stripped
                     }
                 },
                 label = { Text("Enter Phone Number") },
                 visualTransformation = NanpVisualTransformation(),
                 keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
             )
         }


Key points about the code
-------------------------

   -  A ``TextField`` composable where the ``onValueChange`` uses a regular
      expression to remove all non-numeric characters and limits the length to a
      maximum of 10 characters before updating the ``phoneNumber`` state.

   -  The ``TextField`` has a custom `VisualTransformation </reference/kotlin/androidx/compose/ui/text/input/VisualTransformation>`__
      instance set on the ``visualTransformation`` attribute.
      ``NanpVisualTransformation``, the custom class instantiated here, is
      defined in the following section.


Auto-format a number in the text field
--------------------------------------

   To format a raw string of numbers, use the implementation of the custom
   ``NanpVisualTransformation`` class:


      .. code:: prettyprint

         class NanpVisualTransformation() : VisualTransformation {

            override fun filter(text: AnnotatedString): TransformedText {
                val trimmed = if (text.text.length >= 10) text.text.substring(0..9) else text.text

                var out = if (trimmed.isNotEmpty()) "(" else ""

                for (i in trimmed.indices) {
                    if (i == 3) out += ") "
                    if (i == 6) out += "-"
                    out += trimmed[i]
                }
                return TransformedText(AnnotatedString(out), phoneNumberOffsetTranslator)
            }

            private val phoneNumberOffsetTranslator = object : OffsetMapping {

                override fun originalToTransformed(offset: Int): Int =
                    when (offset) {
                        0  -> offset
                    // Add 1 for opening parenthesis.
                        in 1..3 -> offset + 1
                    // Add 3 for both parentheses and a space.
                        in 4..6 -> offset + 3
                    // Add 4 for both parentheses, space, and hyphen.
                        else -> offset + 4
                    }

                override fun transformedToOriginal(offset: Int): Int =
                    when (offset) {
                        0 -> offset
                    // Subtract 1 for opening parenthesis.
                        in 1..5 -> offset - 1
                    // Subtract 3 for both parentheses and a space.
                        in 6..10 -> offset - 3
                    // Subtract 4 for both parentheses, space, and hyphen.
                        else -> offset - 4
                    }

            }
         }


Key points about the code
-------------------------

   -  The ``filter()`` function inserts the non-numeric formatting characters at
      the appropriate places.

   -  The ``phoneNumberOffsetTranslator`` object contains two methods. One maps
      the offsets between the original string and the formatted one, and the
      other does the reverse mapping. These mappings enable the skipping of the
      formatting characters when the user changes the cursor location in the
      text field.

   -  The formatted string and ``phoneNumberOffsetTranslator`` are used as
      arguments for a ``TransformedText`` instance that is returned and used by
      the ``TextField`` to perform the formatting.


Results

   .. figure:: https://developer.android.google.cn/static/quick-guides/content/nanp_formatter.gif
      :alt: An auto-formatted phone number in the text field
      :width: 250px

      **Figure 1.** An auto-formatted phone number in the text field.


â­ Load and display images
==========================

https://developer.android.google.cn/quick-guides/content/load-images?hl=en

   To display images in your app for content and for responses to user actions,
   load the images from the disk or from an external source on the internet. You
   can load images the following ways:

   -  From the disk
   -  From a network using Coil
   -  From a network using Glide


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Load an image from the disk

   You can load locally stored images from the disk to display them in your app
   for content and to respond to user actions.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Load the image
--------------

   Use the following code to load a locally stored image from the disk to
   display in your app:


      .. code:: prettyprint

         Image(
             painter = painterResource(id = R.drawable.dog),
             contentDescription = stringResource(id = R.string.dog_content_description)
         )


Key points about the code
-------------------------

   -  A defined Compose `Image </reference/kotlin/androidx/compose/foundation/package-summary#Image>`__
      object with a ``painter`` attribute set to a `painterResource() </reference/kotlin/androidx/compose/ui/res/package-summary#painterresource>`__
      that loads an image from app resources.

   -  A ``contentDescription`` that ``TalkBack`` can read to make your app more
      accessible.

   -  A ``stringResource()`` to load translated content description from the
      ``strings.xml`` file.


Load an image over the network
------------------------------

   You can load images stored externally on the internet using either ``Coil`` or
   ``Glide``. To choose which library to use for your project, consider factors such
   as project requirements and performance constraints.


Load an image using Coil

   You can load images from the internet using `Coil <https://coil-kt.github.io/coil/>`__, 
   a third-party library. Coil is backed by Kotlin coroutines, and takes responsibility 
   for loading the image away from the Main thread, and displays it once loaded. 
   Follow this guidance to load images from the internet using Coil.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation("io.coil-kt:coil-compose:2.6.0")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation 'io.coil-kt:coil-compose:2.6.0'


Load the image

   Use the following code to load images using Coil:


      .. code:: prettyprint

         // AsyncImage is provided by Coil.
         AsyncImage(
             model = "https://example.com/image.jpg",
             contentDescription = "Translated description of what the image contains"
         )


Load an image using Glide

   You can load images stored externally on the internet using `Glide <https://github.com/bumptech/glide>`__ 
   to display them in your app's feed. Glide is a fast and efficient image loading 
   library for Android focused on smooth scrolling, and takes responsibility for 
   loading the image away from the Main thread, and displays it once loaded.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation("com.github.bumptech.glide:compose:1.0.0-beta01")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation 'com.github.bumptech.glide:compose:1.0.0-beta01'


Load the image

   Use the following code to load images using Glide:


      .. code:: prettyprint

         GlideImage(
             model = "https://example.com/image.jpg",
             contentDescription = "Translated description of what the image contains"
         )


Results

   .. figure:: https://developer.android.google.cn/static/quick-guides/content/dog.png
      :alt: An image of a dog
      :width: 250px

      **Figure 1.** An image loaded and displayed.


â­ Display layered images on a canvas
=====================================

https://developer.android.google.cn/quick-guides/content/display-layered-image?hl=en

   You can blend or overlay source images to display layered images on a canvas.
   For example, you can replicate how the Android Framework generates app icons
   by combining separate background and foreground drawables. To display layered
   images, you must do the following:

   -  Layer images on a canvas.
   -  Overlay the source.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Layer images on a canvas
------------------------

   The following code layers two source images on top of each other, rendering a
   blended image on the canvas:


      .. code:: prettyprint

         class OverlayImagePainter constructor(
             private val image: ImageBitmap,
             private val imageOverlay: ImageBitmap,
             private val srcOffset: IntOffset = IntOffset.Zero,
             private val srcSize: IntSize = IntSize(image.width, image.height),
             private val overlaySize: IntSize = IntSize(imageOverlay.width, imageOverlay.height)
         ) : Painter() {

             private val size: IntSize = validateSize(srcOffset, srcSize)
             override fun DrawScope.onDraw() {
                 // Draw the first image without any blend mode.
                 drawImage(
                     image,
                     srcOffset,
                     srcSize,
                     dstSize = IntSize(
                         this@onDraw.size.width.roundToInt(),
                         this@onDraw.size.height.roundToInt()
                     )
                 )
                 // Draw the second image with an Overlay blend mode to blend the two together.
                 drawImage(
                     imageOverlay,
                     srcOffset,
                     overlaySize,
                     dstSize = IntSize(
                         this@onDraw.size.width.roundToInt(),
                         this@onDraw.size.height.roundToInt()
                     ),
                     blendMode = BlendMode.Overlay
                 )
             }

             // Return the dimension of the underlying ImageBitmap as its intrinsic width and height.
             override val intrinsicSize: Size get() = size.toSize()

             private fun validateSize(srcOffset: IntOffset, srcSize: IntSize): IntSize {
                 require(
                     srcOffset.x >= 0 &&
                         srcOffset.y >= 0 &&
                         srcSize.width >= 0 &&
                         srcSize.height >= 0 &&
                         srcSize.width <= image.width &&
                         srcSize.height <= image.height
                 )
                 return srcSize
             }
         }


Key points about the code
-------------------------

   -  Uses ``OverlayImagePainter``, which is a custom `Painter </reference/kotlin/androidx/compose/ui/graphics/painter/Painter>`__
      implementation that you can use to overlay images over the source image.
      The blend mode controls how the images are combined. The first image is
      not overwriting anything else, so no blend mode is needed. The ``Overlay``
      blend mode of the second image overwrites the areas of the first image
      that are covered by the second image.

   -  ``DrawScope.onDraw()`` is overridden and the two images are overlaid in
      this function.

   -  ``intrinsicSize`` is overridden to correctly report the intrinsic size of
      the combined image.


Overlay source image
--------------------

   With this custom painter ``Painter``, you can overlay an image on top of the
   source image as follows:


      .. code:: prettyprint

         val rainbowImage = ImageBitmap.imageResource(id = R.drawable.rainbow)
         val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)
         val customPainter = remember {
             OverlayImagePainter(dogImage, rainbowImage)
         }
         Image(
             painter = customPainter,
             contentDescription = stringResource(id = R.string.dog_content_description),
             contentScale = ContentScale.Crop,
             modifier = Modifier.wrapContentSize()
         )


Key points about the code
-------------------------

   -  The images to be combined are each loaded as `ImageBitmap </reference/kotlin/androidx/compose/ui/graphics/ImageBitmap>`__
      instances before being combined using ``OverlayImagePainter``.

   -  The combined images are rendered by an `Image </reference/kotlin/androidx/compose/foundation/package-summary#Image(androidx.compose.ui.graphics.ImageBitmap,kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,androidx.compose.ui.layout.ContentScale,kotlin.Float,androidx.compose.ui.graphics.ColorFilter,androidx.compose.ui.graphics.FilterQuality)>`__
      composable that uses the custom painter to combine the source images when
      rendering.


Results

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-rainbowoverlay.jpg
      :alt: Custom Painter that overlays two images on top of each other
      :figclass: screenshot
      :width: 25.0%

      **Figure 1**: An ``Image`` that uses a custom ``Painter`` to overlay a
      semi-transparent rainbow image over the image of a dog.


â­ Lazily load data with lists and Paging
=========================================

https://developer.android.google.cn/quick-guides/content/lazily-load-list?hl=en

   With lazy loading and Paging, you can support large lists of itemsâ€”including
   an infinite listâ€”in your app by loading and displaying data incrementally.
   This technique enables you to reduce initial load times and optimize memory
   usage, enhancing performance.

   **Note:**  For optimized performance, use the Paging Library with a lazy
   list for an infinite list of data.

Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation("androidx.paging:paging-compose:3.3.0-alpha05")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation "androidx.paging:paging-compose:3.3.0-alpha05"


Display paged content
---------------------

   With the Paging library, you can load and display pages of data from a larger
   dataset acquired from local storage or over a network. Use the following code
   to display a paginated list that shows a progress bar to indicate to the user
   that more data is being fetched:


      .. code:: prettyprint

           // Collect the flow of data from a Pager object, and transform
           // it into a LazyPagingItems object.
           val lazyPagingItems = pager.flow.collectAsLazyPagingItems()

             LazyColumn {
                 // Dynamically fetch the total item count from lazyPagingItems
                 // and ensure the uniqueness of each item using their id.
                 items(
                     lazyPagingItems.itemCount,
                     key = lazyPagingItems.itemKey { it.id }
                     //Fetch the message at the specific index from lazyPagingItems.
                 ) { index ->
                     val message = lazyPagingItems[index]
                     // Display the message or a placeholder.
                     if (message != null) {
                        MessageRow(message)
                     } else {
                         MessagePlaceholder()
                     }
                 }
             }

             @Composable
             fun MessagePlaceholder() {
                 Box(Modifier.fillMaxWidth().height(48.dp)) {
                     CircularProgressIndicator()
                 }
             }

             @Composable
             fun MessageRow(message: Text) {
                 Card(modifier = Modifier.padding(8.dp)) {
                     Column(
                         modifier = Modifier.padding(8.dp),
                         verticalArrangement = Arrangement.Center
                     ) {
                         Text(message.sender)
                         Text(message.text)
                     }
                 }
             }


Key points about the code
-------------------------

   -  `LazyColumn </reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyColumn(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__:
      This composable is used to display a large list of items (messages)
      efficiently. It only renders the items that are visible on the screen,
      thus saving resources and memory.

   -  The `lazyPagingItems </reference/kotlin/androidx/paging/compose/LazyPagingItems>`__
      object efficiently manages the loading and presentation of paged data
      within the ``LazyColumn``. It passes ``LazyPagingItems`` to `items </reference/kotlin/androidx/compose/foundation/lazy/LazyListScope#items(kotlin.Int,kotlin.Function1,kotlin.Function1,kotlin.Function2)>`__
      in the ``LazyColumn`` composable.

   -  ``MessageRow(message: Text)`` is responsible for rendering individual
      message items, likely displaying the sender and text of the message within
      a Card.

   -  ``MessagePlaceholder()`` provides a visual placeholder (a loading spinner)
      while the actual message data is being fetched, enhancing the user
      experience.


Results

   .. figure:: https://developer.android.google.cn/static/quick-guides/content/lazy-loading.gif
      :alt: A large list fetching data as the user scrolls
      :width: 250px

      **Figure 1.** A large list using the Paging library to fetch data as the
      user scrolls.


â­ Display nested scrolling items in a list
===========================================

https://developer.android.google.cn/quick-guides/content/display-nested-list?hl=en

   You can display nested scrolling items within a list to present complex
   layouts, such as product catalogs, media galleries, news feeds, and more.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))
            implementation("libs.androidx.material3")
            implementation("io.coil-kt:coil-compose:2.6.0")


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')
            implementation "libs.androidx.material3"
            implementation "io.coil-kt:coil-compose:2.6.0"


Implement nested horizontal scrolling in vertical list
------------------------------------------------------

   The following code produces a list that scrolls two ways. The rows of the
   list scroll horizontally; the list as a wholeâ€”a single columnâ€”scrolls
   vertically.


      .. code:: prettyprint

         @Composable
         fun NestedScrollingRowsList(urls: List<String>) {
             LazyColumn {
                 items(10) {
                     LazyRow {
                         item { Text("Row: $it") }
                         items(urls.size) { index ->
                             // AsyncImage provided by Coil.
                             AsyncImage(
                                 model = urls[index],
                                 modifier = Modifier.size(150.dp),
                                 contentDescription = null
                             )
                         }
                     }
                 }
             }
         }


Results

   .. figure:: https://developer.android.google.cn/static/quick-guides/content/nested_list%20(1).gif
      :alt: Nested horizontal lists within a vertical scrolling list
      :width: 250px

      **Figure 1.** Nested horizontal lists within a vertical scrolling list.


â­ Add a custom page indicator
==============================

https://developer.android.google.cn/quick-guides/content/custom-page-indicator?hl=en

   Using page indicators, you can help your users understand their current
   position within your app's content, providing a visual indication of
   progress. These navigational cues are useful when you present content
   sequentially, such as carousel implementations, image galleries and
   slideshows, or pagination in lists.


Version compatibility

   This implementation requires that your project minSDK be set to API level 21
   or higher.


Dependencies


      .. code:: kotlin

            implementation(platform("androidx.compose:compose-bom:2024.06.00"))


      .. code:: groovy

            implementation platform('androidx.compose:compose-bom:2024.06.00')


Create a horizontal pager with a custom page indicator
------------------------------------------------------

   The following code creates a horizontal pager that has a page indicator,
   giving the user visual cues for how many pages there are and which page is
   visible:


      .. code:: prettyprint

         Box(modifier = Modifier.fillMaxSize()) {
             val pagerState = rememberPagerState(pageCount = {
                 4
             })
             HorizontalPager(
                 state = pagerState,
                 modifier = Modifier.fillMaxSize()
             ) { page ->
                 Text(
                     text = "Page: $page",
                 )
             }
             Row(
                 Modifier
                     .wrapContentHeight()
                     .fillMaxWidth()
                     .align(Alignment.BottomCenter)
                     .padding(bottom = 8.dp),
                 horizontalArrangement = Arrangement.Center
             ) {
                 repeat(pagerState.pageCount) { iteration ->
                     val color = if (pagerState.currentPage == iteration) Color.DarkGray else Color.LightGray
                     Box(
                         modifier = Modifier
                             .padding(2.dp)
                             .clip(CircleShape)
                             .background(color)
                             .size(16.dp)
                     )
                 }
             }
         }


Key points about the code
-------------------------

   -  The code implements a `HorizontalPager </reference/kotlin/androidx/compose/foundation/pager/package-summary#HorizontalPager(androidx.compose.foundation.pager.PagerState,androidx.compose.ui.Modifier,androidx.compose.foundation.layout.PaddingValues,androidx.compose.foundation.pager.PageSize,kotlin.Int,androidx.compose.ui.unit.Dp,androidx.compose.ui.Alignment.Vertical,androidx.compose.foundation.gestures.TargetedFlingBehavior,kotlin.Boolean,kotlin.Boolean,kotlin.Function1,androidx.compose.ui.input.nestedscroll.NestedScrollConnection,androidx.compose.foundation.gestures.snapping.SnapPosition,kotlin.Function2)>`__,
      which lets you swipe horizontally between different pages of content. In
      this case, each page displays the page number.

   -  The ``rememberPagerState()`` function initializes the pager and sets the
      number of pages to 4. This function creates a state object that tracks the
      current page, and lets you control the pager.

   -  The `pagerState.currentPage </reference/kotlin/androidx/compose/foundation/pager/PagerState#currentPage()>`__
      property is used to determine which page indicator should be highlighted.

   -  The page indictator appears in a pager overlaid by a `Row </reference/kotlin/androidx/compose/foundation/layout/package-summary#Row(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,kotlin.Function1)>`__
      implementation.

   -  A 16 dp circle is drawn for each page in the pager. The indicator for the
      current page is displayed as ``DarkGray``, while the rest of the indicator
      circles are ``LightGray``.

   -  The `Text </reference/kotlin/androidx/compose/material/package-summary#Text(androidx.compose.ui.text.AnnotatedString,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.font.FontStyle,androidx.compose.ui.text.font.FontWeight,androidx.compose.ui.text.font.FontFamily,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextDecoration,androidx.compose.ui.text.style.TextAlign,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextOverflow,kotlin.Boolean,kotlin.Int,kotlin.Int,kotlin.collections.Map,kotlin.Function1,androidx.compose.ui.text.TextStyle)>`__
      composable within the ``HorizontalPager`` displays the text "Page: [page
      number]" on each page.


Results

   .. image:: https://developer.android.google.cn/static/quick-guides/content/page_indicator.mp4

      Figure 1. Pager showing a circle indicator under the content.


ğŸŸ© TOC - Android Basics with Compose
=====================================

   pandoc --column=100 -trst -rhtml https://developer.android.google.cn/courses/android-basics-compose/course  | subl -

   This is the recommended course to start learning Android! Build a series of 
   apps using Jetpack Compose, the modern toolkit for creating beautiful user 
   interfaces on Android. You will write these apps in the Kotlin programming 
   language and learn best practices in Material Design, app architecture, 
   data storage, fetching data from the network, testing, and more. 

   â­ No programming experience required.

   â­ Training level: Beginner

   Android Basics with Compose is a self-paced, online course on how to build 
   Android apps using the latest best practices. It covers the basics of building 
   apps with Jetpack Compose, the recommended toolkit for building user interfaces on Android.


   Course goals

   -  Understand the fundamentals of Kotlin and Jetpack Compose
   -  Build a series of basic Android apps
   -  Use Android app architecture, Jetpack libraries and work with data
      according to Modern Android Development practices

   Prerequisites

   -  Basic computer skills
   -  Basic math skills
   -  A computer that can run Android Studio (see `system requirements <https://developer.android.google.cn/studio>`__)
   -  (Optional) Android device


Unit 1: Your first Android app
------------------------------

   `Unit 1: Your first Android app <https://developer.android.google.cn/courses/android-basics-compose/unit-1>`__

   Learn programming basics and create your first Android app.

   -  Write simple Kotlin programs that display text output.
   -  Download and install Android Studio.
   -  Build an Android app with a simple user interface that displays text and images.
   -  Run the app on a device or emulator.

   `Introduction to Kotlin <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-1-pathway-1>`__

      Pathway 1 | Duration: 3 hours

      Learn introductory programming concepts in Kotlin.

      *  [ğŸš€] Before you begin https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-before-you-begin
      *  [ğŸ§­] Welcome to Android Basics with Compose 
      *  [ğŸš€] Your first program in Kotlin https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-first-program
      *  [ğŸš€] Create and use variables in Kotlin https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-variables
      *  [ğŸš€] Create and use functions in Kotlin https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-functions
      *  [ğŸš€] Practice: Kotlin Basics https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-intro-kotlin-practice-problems
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 

   `Setup Android Studio <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-1-pathway-2>`__

      Pathway 2 | Duration: 4 hours

      Install and set up Android Studio, create your first project, and run it on
      a device or emulator.

      *  [ğŸ§­] Introduction to Android Studio 
      *  [ğŸš€] Download and install Android Studio https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-install-android-studio
      *  [ğŸš€] Create your first Android app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-first-app
      *  [ğŸš€] Run your first app on the Android Emulator https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-emulator
      *  [ğŸš€] How to connect your Android device https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-connect-device
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 

   `Build a basic layout <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-1-pathway-3>`__

      Pathway 3 | Duration: 3 hours

      Build an Android app with a simple user interface that displays text and
      images.

      *  [ğŸ§­] Intro to Jetpack Compose 
      *  [ğŸ§­] Design a birthday card app 
      *  [ğŸš€] Build a simple app with text composables https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-text-composables
      *  [ğŸš€] Add images to your Android app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-images
      *  [ğŸš€] Practice: Compose Basics https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-composables-practice-problems
      *  [ğŸš€] Project: Create a business card app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-business-card
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 


Unit 2: Building app UI
-----------------------

   `Unit 2: Building app UI <https://developer.android.google.cn/courses/android-basics-compose/unit-2>`__

   3 pathways | Duration: 21 hours

   Continue learning the fundamentals of Kotlin, and start building more
   interactive apps.

   -  Use conditionals, function types, classes, and lambda expressions in Kotlin.
   -  Understand how composition and recomposition works.
   -  Add a button to an app UI and respond to user taps.
   -  Create an app that works with data entered by the user.
   -  Learn how to use state to display data and reflect the changes
      automatically when the data gets updated.
   -  Write unit tests to test isolated functions.

   `Kotlin fundamentals <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-2-pathway-1>`__

      Pathway 1 | Duration: 8 hours

      Learn more fundamentals of Kotlin, object-oriented programming, and lambdas.

      *  [ğŸ§­] Kotlin Fundamentals 
      *  [ğŸš€] Write conditionals in Kotlin https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-conditionals
      *  [ğŸš€] Use nullability in Kotlin https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-nullability
      *  [ğŸš€] Use classes and objects in Kotlin https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-classes-and-objects
      *  [ğŸš€] Use function types and lambda expressions in Kotlin https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-function-types-and-lambda
      *  [ğŸš€] Practice: Kotlin Fundamentals https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-kotlin-fundamentals-practice-problems
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 

   `Add a button to an app <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-2-pathway-2>`__

      Pathway 2 | Duration: 6 hours

      Learn how to respond to a button click in an Android app.

      *  [ğŸ§­] Intro to Dice Roller app 
      *  [ğŸš€] Create an interactive Dice Roller app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app
      *  [ğŸš€] Use the debugger in Android Studio https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-intro-debugger
      *  [ğŸš€] Practice: Click behavior https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-button-click-practice-problem
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 

   `Interacting with UI and state <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-2-pathway-3>`__

      Pathway 3 | Duration: 7 hours

      Create a tip calculator app that calculates the tip from user input.

      *  [ğŸ§­] Understanding state in Compose 
      *  [ğŸ§­] Intro to tip calculator 
      *  [ğŸš€] Intro to state in Compose https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-using-state
      *  [ğŸš€] Calculate a custom tip https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-calculate-tip
      *  [ğŸš€] Write automated tests https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-write-automated-tests
      *  [ğŸš€] Project: Create an Art Space app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-art-space
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 


Unit 3: Display lists and use Material Design
---------------------------------------------

   `Unit 3: Display lists and use Material Design <https://developer.android.google.cn/courses/android-basics-compose/unit-3>`__

   3 Pathways | Duration: 15 hours

   Build apps that display a list of data and learn how to make your apps more
   beautiful with Material Design.

   -  Use data classes, functions, and collections in Kotlin.
   -  Create a scrollable list in an app that displays both text and images.
   -  Add click listeners to interact with list items.
   -  Add an app bar to the app and modify the app theme.
   -  Use Material Design to build modern and intuitive user interfaces, using
      colors, shapes and typography.

   `More Kotlin fundamentals <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-3-pathway-1>`__

      Pathway 1 | Duration: 8 hours

      Learn additional Kotlin programming concepts that will enable you to build
      more interesting and fun Android apps.

      *  [ğŸ§­] More Kotlin fundamentals 
      *  [ğŸš€] Generics, objects, and extensions https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-generics
      *  [ğŸš€] Use collections in Kotlin https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-collections
      *  [ğŸš€] Higher-order functions with collections https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-higher-order-functions
      *  [ğŸš€] Practice: Classes and Collections https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-classes-and-collections
      *  [ğŸ›¤] Quiz 

   `Build a scrollable list <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-3-pathway-2>`__

      Pathway 2 | Duration: 4 hours

      Create an app that displays a scrollable list of text and images using
      Compose.

      *  [ğŸ§­] Intro to Affirmations app 
      *  [ğŸš€] Add a scrollable list https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-training-add-scrollable-list
      *  [ğŸš€] Change the app icon https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-training-change-app-icon
      *  [ğŸš€] Practice: Build a grid https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-grid
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 

   `Build beautiful apps <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-3-pathway-3>`__

      Pathway 3 | Duration: 3 hours

      Make your apps more beautiful and intuitive to use with Material Design,
      animations, and accessibility best practices.

      *  [ğŸ§­] Intro to Material Design with Compose 
      *  [ğŸš€] Material Theming with Jetpack Compose https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-material-theming
      *  [ğŸš€] Simple animation with Jetpack Compose https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-woof-animation
      *  [ğŸš€] Testing for Accessibility https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-accessibility
      *  [ğŸš€] Practice: Build Superheroes app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-superheroes
      *  [ğŸš€] Project: Create a 30 Days App https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-30-days
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 


Unit 4: Navigation and app architecture
---------------------------------------

   `Unit 4: Navigation and app architecture <https://developer.android.google.cn/courses/android-basics-compose/unit-4>`__

   3 pathways | Duration: 27 hours

   Learn the best practices of app architecture to build more complex apps.
   Enhance your users' ability to navigate across, into and back out from the
   various screens within your app for a consistent and predictable user
   experience.

   -  Explain activities and their lifecycles.
   -  Understand Modern Android architecture.
   -  Use StateFlow and UDF pattern to work with state and events.
   -  Add a ViewModel to save data and state.
   -  Set up and use the Navigation component with Compose.
   -  Understand what responsive UI is.
   -  Use window class sizes to build for different screen sizes.
   -  Add a navigation drawer to an app.

   `Architecture Components <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-4-pathway-1>`__

      Pathway 1 | Duration: 9 hours

      Learn about app architecture and how to use ViewModels, UI State, and
      StateFlow to build more complex apps.

      *  [ğŸ§­] Welcome to Unit 4 
      *  [ğŸš€] Stages of the Activity lifecycle https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-activity-lifecycle
      *  [ğŸ§­] Intro to App architecture 
      *  [ğŸ§­] Architecture: The UI Layer 
      *  [ğŸš€] ViewModel and State in Compose https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-viewmodel-and-state
      *  [ğŸš€] Write unit tests for ViewModel https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-viewmodel
      *  [ğŸš€] Practice: Add a ViewModel to Dessert Clicker https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-viewmodel
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 

   `Navigation in Jetpack Compose <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-4-pathway-2>`__

      Pathway 2 | Duration: 6 hours

      Learn how to use the Navigation component to build more complex apps with
      more screens and how to navigate and pass data between different
      composables.

      *  [ğŸ§­] Introduction to Navigation and Cupcake App 
      *  [ğŸš€] Navigate between screens with Compose https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-navigation
      *  [ğŸš€] Test the Cupcake app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-cupcake
      *  [ğŸš€] Practice: Add navigation https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-navigation
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 

   `Adapt for different screen sizes <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-4-pathway-3>`__

      Pathway 3 | Duration: 13 hours

      In this pathway, you'll learn how to adapt your app to different screen
      sizes and provide a better user experience, as well as how to test your
      adaptive UI.

      *  [ğŸ§­] Adaptive layouts 
      *  [ğŸ§­] Intro to Reply app 
      *  [ğŸš€] Build an adaptive app with dynamic navigation https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens 
      *  [ğŸš€] Build an app with an adaptive layout https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens 
      *  [ğŸš€] Practice: Build Sports app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-sports-app 
      *  [ğŸš€] Project: Create a My City app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-my-city 
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 


Unit 5: Connect to the internet
-------------------------------

   `Unit 5: Connect to the internet <https://developer.android.google.cn/courses/android-basics-compose/unit-5>`__

   2 Pathways | Duration: 14 hours

   Use Kotlin coroutines to perform multiple tasks at once, and learn about
   HTTP and REST to get data from the internet using Retrofit. Then use the
   Coil library to display images in your app.

   -  Describe the basics of concurrency and how to use coroutines in an   Android app.
   -  Define and understand the data layer in Modern Android app architecture.
   -  Implement a repository to centralize data access.
   -  Use Retrofit to retrieve data from a remote server.
   -  Load and display images using the Coil library.
   -  Implement dependency injection to decouple the classes, making it easier
      to test, maintain, and scale the app.

   `Get data from the internet <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-5-pathway-1>`__

      Pathway 1 | Duration: 6 hours

      Implement coroutines to perform tasks concurrently without blocking the app,
      and learn about HTTP and REST to get data from the internet.

      *  [ğŸ§­] Connect to the internet 
      *  [ğŸš€] Introduction to Coroutines in Kotlin Playground https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-coroutines-kotlin-playground
      *  [ğŸš€] Introduction to Coroutines in Android Studio https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-coroutines-android-studio
      *  [ğŸ§­] Introduction to HTTP/REST 
      *  [ğŸš€] Get data from the internet https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-getting-data-internet
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 

   `Load and display images from the internet <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-5-pathway-2>`__

      Pathway 2 | Duration: 3 hours

      Apply architecture best practices to the app and use Coil to download and
      display images.

      *  [ğŸ§­] Architecture: The Data Layer 
      *  [ğŸš€] Add repository and Manual Dependency Injection https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-repository
      *  [ğŸš€] Load and display images from the internet https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-load-images
      *  [ğŸš€] Practice: Build amphibians app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-amphibians-app
      *  [ğŸš€] Project: Create a Bookshelf app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-bookshelf
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 


Unit 6: Data persistence
------------------------

   `Unit 6: Data persistence <https://developer.android.google.cn/courses/android-basics-compose/unit-6>`__

   3 Pathways | Duration: 10 hours

   Learn how to store data locally on the device and keep your apps working
   through any network disruptions for a smooth and consistent user experience.

   -  Learn the basics of SQL to insert, update, and delete data from a SQLite    database.
   -  Use the Room library to add a database to an Android app.
   -  Use Database Inspector to test and debug database issues.
   -  Use Preference DataStore to store user preferences.

   `Introduction to SQL <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-6-pathway-1>`__

      Pathway 1 | Duration: 2 hours

      Learn how to use SQL to read and manipulate data in a relational database.

      *  [ğŸ§­] Introduction to Databases and SQL 
      *  [ğŸš€] Use SQL to read and write to a database https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-sql
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 

   `Use Room for data persistence <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-6-pathway-2>`__

      Pathway 2 | Duration: 6 hours

      Use the Room library to easily create and use relational databases in an
      Android app.

      *  [ğŸ§­] Kotlin Flows in Practice 
      *  [ğŸ› ] Testing Flows https://developer.android.google.cn/kotlin/flow/test
      *  [ğŸ§­] Using Room Kotlin APIs 
      *  [ğŸš€] Persist Data with Room https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-persisting-data-room 
      *  [ğŸš€] Read and update data with Room https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-update-data-room 
      *  [ğŸš€] Practice: Build Bus Schedule app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-bus-schedule-app 
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 

   `Store and access data using keys with DataStore <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-6-pathway-3>`__

      Pathway 3 | Duration: 2 hours

      Learn how to store simple, key-value pair data with Preferences DataStore in
      an Android app

      *  [ğŸ§­] Introduction to Datastore 
      *  [ğŸ§­] Preferences Datastore 
      *  [ğŸš€] Save preferences locally with DataStore https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-datastore 
      *  [ğŸš€] Project: Create a flight search app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-flight-search 
      *  [ğŸ§­] What's next? 
      *  [ğŸ›¤] Quiz 


Unit 7: WorkManager
-------------------

   `Unit 7: WorkManager <https://developer.android.google.cn/courses/android-basics-compose/unit-7>`__

   1 Pathway | Duration: 6 hours

   Use Android Jetpack's WorkManager API to schedule necessary background work,
   such as data backups or fresh content downloads, that keeps running even if
   the app exits or the device restarts.

   -  Define long running tasks that need to run in background work.
   -  Add WorkManager to an Android app.
   -  Create a Worker object and enqueue work.
   -  Create constraints on WorkRequests.
   -  Use the Background Task Inspector to inspect and debug WorkManager.

   `Schedule tasks with WorkManager <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-7-pathway-1>`__

      Pathway 1 | Duration: 3 hours

      Learn when and how to use WorkManager, an API that handles background work
      that needs to run regardless of whether the application process is still
      running.

      *  [ğŸ§­] Introduction to WorkManager 
      *  [ğŸ§­] Implementing WorkManager 
      *  [ğŸš€] Background work with WorkManager https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-workmanager
      *  [ğŸš€] Advanced WorkManager and Testing https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-verify-background-work
      *  [ğŸš€] Practice: Build Water Me app https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-water-me-app
      *  [ğŸ›¤] Quiz 


Unit 8: Views and Compose
-------------------------

   `Unit 8: Views and Compose <https://developer.android.google.cn/courses/android-basics-compose/unit-8>`__

   2 Pathways | Duration: 4 hours

   Learn how to use Compose and the older UI toolkit based on Views
   side-by-side in the same app. In this unit, you will learn interoperability
   APIs and best practices to add a new feature to an existing app in Views,
   use an existing library that uses Views, or use a UI component that is not
   yet available in Compose.

   -  Understand the View-based UI toolkit and build app UI using XML.
   -  Add a composable in an app built with Views.
   -  Add Navigation component to the app and use it to navigate between fragments.
   -  Use AndroidView to display views.
   -  Add existing View-based UI components in a Compose app.

   `Android Views and Compose in Views <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-8-pathway-1>`__

      Pathway 1 | Duration: 3 hours

      Learn the basics of building apps with Android Views and how to add a
      composable in an app built with Views.

      *  [ğŸ§­] Android View System 
      *  [ğŸš€] Build an Android app with Views https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-app-with-views
      *  [ğŸ§­] Compose in Views 
      *  [ğŸš€] Add Compose to a legacy app https://developer.android.google.cn/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app
      *  [ğŸ›¤] Quiz 

   `Views in Compose <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-8-pathway-2>`__

      Pathway 2 | Duration: 1 hours

      Learn how to add and use existing Views inside an app built with Jetpack
      Compose.

      *  [ğŸ§­] Views in Compose 
      *  [ğŸš€] View Interoperability in Compose https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-view-interop
      *  [ğŸ›¤] Quiz 


ğŸš€ Before you begin
====================


1. Before you begin
-------------------

   Welcome to Android Basics with Compose!

   This course is for people who want to learn how to build Android apps in the Kotlin programming
   language using the latest best practices recommended by Google. You will build a series of apps
   using Jetpack Compose, which is the modern way to create beautiful user interfaces (UIs) in your
   Android apps.

   You'll work through codelabs, which are step-by-step coding instructions for how to build an app
   or a feature for an app. If you're more of a visual learner who wants to watch how it's done
   first, some of these codelabs are accompanied by code-along videos. There are also practice
   problems to reinforce what you learned, and projects that provide you with the opportunity to
   experiment and learn more on your own.

   Learning is a personal experience that's different for everyone. Depending on your background and
   experience, there are several options for how you can navigate this course most effectively.


**For people who are new to programming**

   If you're new to programming, start at the beginning of the course and work your way through each
   learning pathway in order. The programming and Android concepts build on each other, which is why
   it's important to go through the content sequentially. You're also encouraged to work through the
   practice problems and projects as additional ways to build your confidence as a new developer.


**For existing developers**

   If you already have programming experience, you can skip some of the material to move through the
   course at a quicker pace. The beginning of each unit contains codelabs for any necessary Kotlin
   programming concepts you need to build the apps in that unit. If you feel confident in those
   topics about the Kotlin language, you can skip those sections and move into the content on
   building apps.

   If you're already an Android developer, you may be more interested in the Compose topics
   presented in this course. `Compose <https://developer.android.google.cn/jetpack/compose>`__ is
   Android's modern toolkit for building native UI, which simplifies and accelerates UI development.
   It requires less code to implement a UI compared to the Android View system, which makes your app
   easier to maintain. If you want to learn more about Compose, the first half of this course is the
   most relevant because it covers UIs, Material Design, and navigation. Alternatively, you can work
   through the `Jetpack Compose for Android Developers course <https://developer.android.google.cn/courses/pathways/compose>`__ 
   with articles, videos, and codelabs on important topics for developers switching to Compose.

   Regardless of which route you take to learn Android, we hope these resources help you bring your
   app ideas to life!

   Have fun learning,

   Your instructors from the Android Team at Google

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-before-you-begin/img/3e52bdd2663adeac.png

      Image showing course authors, Murat Yener, Meghan Mehta, Dan Galpin, Kat Kuan, Sagar Begale,
      Angie Sasmita, Raka Chowdhury, and Anuj Garg


ğŸš€ Download and install Android Studio
=======================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-install-android-studio


1. Before you begin
-------------------

   In this codelab, you will install Android Studio.

   Android Studio is the official integrated development environment (IDE) for Android app
   development, built and distributed by Google. An IDE contains tools that enable software
   developers to design, build, run, and test software, in this case, apps for the Android platform.
   Android Studio uses IntelliJ IDEA as its foundation and includes the Android plugin pre-installed
   along with some modifications specifically for the Android platform.


Prerequisites

   -  Intermediate computer skills, familiarity with files and folders, and using apps, such as a
      spreadsheet, word processor, or photo editor.
   -  Ability to download, install, and update software.


What you'll learn

   -  How to check that your computer configuration meets the minimum requirements for running
      Android Studio.
   -  How to download and install the Android Studio.


What you'll need

   -  A computer running a 64-bit version of Windows (8, 10, or 11), Linux, macOS (10.14 Mojave or
      later), or ChromeOS.
   -  Internet access for your computer.



2. Windows: Verify system requirements
--------------------------------------


Android Studio system requirements

   The following are the system requirements for Android Studio on Windows.

   -  64-bit MicrosoftÂ® WindowsÂ® 8/10/11
   -  x86_64 CPU architecture; 2nd generation Intel Core or newer, or AMD CPU with support for a
      `Windows Hypervisor <https://developer.android.google.cn/studio/run/emulator-acceleration#vm-windows>`__
   -  8 GB RAM or more
   -  8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)
   -  1280 x 800 minimum screen resolution


Check system requirements (Windows 10)

   On a Windows computer, you can find all the information that you need to verify the system
   requirements in the Settings app.

   1. Open **Settings**.

   **Tip:** You can use the search tool next to the Start button at the bottom of your screen to
   locate it.

   2. Click **System**.
   3. At the bottom of the left-hand navigation pane, click **About**.
   4. Make sure that the **Windows specifications** meet or exceed the requirements.
      |e37a2f51fc945235.png|
   5. Select **Device specifications**. Make sure that the Installed RAM is at least as much as is
      required and that the system type is the 64-bit version of the operating system.

   |d57ac05cc5c74047.png|

   6. In the navigation pane, click **Display**. Make sure that the **Resolution** is the same or
      better than what's required.

   |45f3ba97421c68e0.png|


Verify storage

   1. Open the file explorer.
   2. In the left-hand navigation pane, click **This PC**.
   3. Ensure that the local storage has enough free space to install Android Studio.

   |4748e8a455b8cdba.png|


Check system requirements (Windows 8.1)

   If you're using Windows 8.1, the steps to find device specifications are as follows:

   1. Open the Settings App.
   2. In the navigation pane, click **PC and devices**.
   3. In the navigation pane, click **PC info**. Check that your CPU and RAM meet the minimum
      requirements, and ensure you're using a 64-bit operating system.

   |71f9a2e30fb16593.png|

   4. In the navigation pane, click **Display**. Check that your display meets the requirements.
      |97c48dd5bda38ee7.png|
   5. Open the file explorer, click **This PC**, and check that you have enough disk space.
      |19ab36acd1dbffea.png|



3. Windows: Download and install Android Studio
-----------------------------------------------


Download Android Studio

   1. Open any web browser and navigate to the `Android Studio download page <https://developer.android.google.cn/studio#get-android-studio>`__.

   This is the Android Developers website, where you can download Android Studio. This page
   automatically detects your operating system.

   2. Click **Download Android Studio**. The **Terms and Conditions** page with the Android Studio
      **License Agreement** opens.
   3. Read the **License Agreement**.
   4. At the bottom of the page, if you agree with the terms and conditions, select the **I have
      read and agree with the above terms and conditions** checkbox.
   5. Click **Download Android Studio** to start the download.
   6. When prompted, save the file to a location where you can easily locate it, such as the
      ``Downloads`` folder.
   7. Wait for the download to complete. This may take a while and may be a good moment to enjoy
      some tea!


Install Android Studio on Windows

   1. Open the folder where you downloaded and saved the Android Studio installation file.
   2. Double-click the downloaded file.
   3. If you see a **User Account Control** dialog about allowing the installation to make changes
      to your computer, click **Yes** to confirm the installation.

   |d01a8cfe00b9b80b.png|

   The **Welcome to Android Studio Setup** dialog displays.

   |82d03b4157cdc3ad.png|

   4. Click **Next** to start the installation.
   5. Accept the default installation settings for all steps.
   6. Click **Finish** when the installation is done to launch Android Studio.

   |6a7eba659ca0d6f1.png|

   7. Choose your preference of light or dark theme when Android Studio first launches. Screenshots
      in this course use the light theme, but choose whichever one you prefer.

   |e91289b2f9f25157.png|

   8. During the installation, the setup wizard downloads and installs additional components and
      tools needed for Android app development. This may take some time depending on your internet
      speed. During this time, you may see a **User Account Control** dialog for **Windows Command
      Processor**. Click **Yes** to accept the dialog.

   |22f23c1915646d8f.png|

   9. You may also receive a **Windows Security Alert** about adb.exe. Click **Allow Access,** if
      needed, to continue the installation.

   |785f9241b5a8f766.png|

   10. When the download and installation completes, click **Finish**.

   The **Welcome to Android Studio** window displays and you're ready to start creating apps!

   |e32573db6eb94acb.png|



4. macOS: Verify system requirements
------------------------------------


Android Studio system requirements (macOS)

   The following are the system requirements for Android Studio on macOS.

   -  MacOSÂ® 10.14 (Mojave) or higher
   -  ARM-based chips, or 2nd generation Intel Core or newer with support for 
      `Hypervisor Framework <https://developer.android.google.cn/studio/run/emulator-acceleration#vm-mac>`__
   -  8 GB RAM or more
   -  8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)
   -  1280 x 800 minimum screen resolution


Check system requirements

   1. Select |9a4d269f5ee241c3.png| **> About This Mac**.
   2. In the dialog, under the **Overview** tab, look for the OS version number and ensure that it's
      within the required range.
   3. In the **Memory** tab, check that the listed total memory meets or exceeds the required
      minimum.

   For example, in the screenshot below, the OS version is 12.2.1 and memory is 16 GB.

   |b8eef3db98e80c31.png|

   4. In the same dialog, click the **Displays** tab.
   5. In the description of the display, ensure that your computer's screen resolution meets or
      exceeds the recommended resolution.

   |3a78f1bd1d8755ff.png|

   6. Click the **Storage** tab.
   7. Check the available disk space and ensure that it meets or exceeds the required disk space for
      installing and running Android Studio.

   |81d58d93c4999d0c.png|



5. macOS: Download and install Android Studio
---------------------------------------------


Download Android Studio

   1. Open any web browser and navigate to the `Android Studio download page <https://developer.android.google.cn/studio/?gclid=Cj0KCQiAjJOQBhCkARIsAEKMtO3zEhdK4_I0CEZic3UH4dl-9gVXuHFR9dCl3TOHKjmv3xWLU3UxfhYaApfAEALw_wcB&gclsrc=aw.ds>`__.
      This is the Android Developers website, where you can download Android Studio. This page
      automatically detects your operating system.
   2. Click **Download Android Studio**. The **Terms and Conditions** page with the Android Studio
      **License Agreement** opens.
   3. Read the **License Agreement**.
   4. At the bottom of the page, if you agree with the terms and conditions, select the **I have
      read and agree with the above terms and conditions** checkbox.
   5. Click **Mac with Intel chip** or **Mac with Apple chip** to start the download.
   6. When prompted, save the file to a location where you can easily locate it, such as the
      ``Downloads`` folder.
   7. Wait for the download to complete. This may take a while and may be a good moment to enjoy
      some tea!

   **Note:** If you need more help or want to customize your installation, refer to the instructions
   to `install Android Studio <https://developer.android.google.cn/studio/install.html>`__, which
   includes screencasts.


Install Android Studio on macOS

   1. Open the folder where you downloaded and saved the Android Studio installation file.
   2. Double-click the downloaded file. The following dialog displays:

   |48e880ca6b15ce12.png|

   3. Drag the **Android Studio** icon to the ``Applications`` folder.
   4. In the ``Applications`` folder, double-click the **Android Studio** icon to launch the
      **Android Studio Setup Wizard**.
   5. If you see a warning about installing or running a file downloaded from the Internet, accept
      the installation.

   |26d72a52b817756e.png|

   6. Follow the **Android Studio Setup Wizard** and accept the default settings for all steps.
      During the installation, the setup wizard downloads and installs additional components and
      tools needed for Android app development. This may take some time, depending on your internet
      speed. So, you could go refill your tea cup!
   7. When the installation completes, Android Studio starts automatically.

   The **Welcome to Android Studio** window opens and you're ready to start creating apps!

   |46481d6fa7a5b2d5.png|



6. Linux: Verify system requirements
------------------------------------


Android Studio system requirements

   The following are the Android Studio system requirements for Linux.

   -  Any 64-bit Linux distribution that supports Gnome, KDE, or Unity DE; GNU C Library (glibc)
      2.31 or later.
   -  x86_64 CPU architecture; 2nd generation Intel Core or newer, or AMD processor with support for
      AMD Virtualization (AMD-V) and SSSE3
   -  8 GB RAM or more
   -  8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)
   -  1280 x 800 minimum screen resolution


Check system requirements

   Use the terminal commands to check if your computer meets the hardware requirements before
   installing.

   **Tip:** You can quickly open a Terminal window using the keyboard shortcut Ctrl+Alt+T.

   1. Use ``lscpu`` to check your processor specifications.

   .. code:: prettyprint

      lscpu

   |1b21e5a271358b4d.png|

   2. Use the ``free`` command to check total system memory.

   The output is in megabytes, so the system below has 32 GB of total memory.

   .. code:: prettyprint

      free -m

   |7f27191ef2dcab70.png|

   3. Use the ``df`` command to check available disk space.

   .. code:: prettyprint

      df -h

   |bbc93fd8434457e5.png|

   4. Use ``xrandr`` to check the screen resolution.

   .. code:: prettyprint

      xrandr | grep '*'

   |cb59ad579a5d500b.png|



7. Linux: Download and install Android Studio
---------------------------------------------


Download Android Studio

   1. Open any web browser and navigate to the `Android Studio download page <https://developer.android.google.cn/studio/?gclid=Cj0KCQiAjJOQBhCkARIsAEKMtO3zEhdK4_I0CEZic3UH4dl-9gVXuHFR9dCl3TOHKjmv3xWLU3UxfhYaApfAEALw_wcB&gclsrc=aw.ds>`__.
   2. This is the Android Developers website, where you can download Android Studio. This page
      automatically detects your operating system. Click **Download Android Studio**. The **Terms
      and Conditions** page with the **Android Studio License Agreement** opens.
   3. Read the **License Agreement**.
   4. At the bottom of the page, if you agree with the terms and conditions, select the **I have
      read and agree with the above terms and conditions** checkbox.
   5. Click **Download Android Studio** to start the download.
   6. When prompted, save the file to a location where you can easily locate it, such as the
      ``Downloads`` folder.
   7. Wait for the download to complete. This may take a while and may be a good moment to enjoy
      some tea!


Install Android Studio on Linux

   |b4227dc325a0d88e.png|

   Open the ``Downloads`` folder in the terminal.

   1. Extract the archive with the ``tar`` command.

   .. code:: prettyprint

      tar -xzvf android-studio-2022.2.1.20-linux.tar.gz

   2. Navigate to the ``android-studio/bin`` directory.

   .. code:: prettyprint

      cd android-studio/bin

   3. Run ``studio.sh``

   .. code:: prettyprint

      ./studio.sh

   4. Keep **Do not import settings** selected and click **OK** on the prompt.

   |da78acc3fe00d3d1.png|

   5. Choose whether or not to share usage data with Google.

   |452dfd9799b9445.png|

   6. Keep **Standard** as the selected install type. Click **Next** to continue.

   |f066c9371aff4900.png|

   7. Choose your preference of light or dark theme. Screenshots in this course use the light theme,
      but choose whichever one you prefer. You can always change this later.

   |94c5ef155301e63f.png|

   8. Accept all the default settings and click **Next**.

   |6b0a242ab7ac238b.png|

   9. Read and agree to the **License Agreement** for the Android SDK and Android NDK, and click
      **Next**.

   |25cc1be6f2679d09.png|

   10. You may also see some additional information about hardware acceleration and the Android
       emulator. Click **Finish**.

   |687d2bf45a4756e.png|

   11. During the installation, the setup wizard downloads and installs additional components and
       tools needed for Android app development.

   |38f6d6410fd543f3.png|

   When the installation is complete, click **Finish**.

   |8ecdc0b3483ab8cd.png|

   12. The **Welcome to Android Studio** dialog displays and you're ready to start creating apps!

   |ce74de482bc8844a.png|


8. Conclusion
-------------

   Congratulations! You've successfully installed Android Studio. Now you're ready for the next
   step!

   If you ran into any technical difficulties with the installation steps, refer to the
   `troubleshooting guide <https://developer.android.google.cn/studio/troubleshoot>`__.


Summary

   -  An Integrated Development Environment, or IDE, is a collection of tools for developing
      software.
   -  Android Studio is the IDE based on IntelliJ IDEA used for Android development.


Learn more

   -  `Download Android Studio <https://developer.android.google.cn/studio/>`__
   -  `Install Android Studio <https://developer.android.google.cn/studio/install>`__
   -  `Meet Android Studio <https://developer.android.google.cn/studio/intro>`__


.. |e37a2f51fc945235.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/e37a2f51fc945235.png
.. |d57ac05cc5c74047.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/d57ac05cc5c74047.png
.. |45f3ba97421c68e0.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/45f3ba97421c68e0.png
.. |4748e8a455b8cdba.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/4a8ab6bb6c487787.png
.. |71f9a2e30fb16593.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/71f9a2e30fb16593.png
.. |97c48dd5bda38ee7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/97c48dd5bda38ee7.png
.. |19ab36acd1dbffea.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/19ab36acd1dbffea.png
.. |d01a8cfe00b9b80b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/d01a8cfe00b9b80b.png
.. |82d03b4157cdc3ad.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/82d03b4157cdc3ad.png
.. |6a7eba659ca0d6f1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/6a7eba659ca0d6f1.png
.. |e91289b2f9f25157.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/e91289b2f9f25157.png
.. |22f23c1915646d8f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/22f23c1915646d8f.png
.. |785f9241b5a8f766.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/785f9241b5a8f766.png
.. |e32573db6eb94acb.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/e32573db6eb94acb.png
.. |9a4d269f5ee241c3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/9a4d269f5ee241c3.png
.. |b8eef3db98e80c31.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/b8eef3db98e80c31.png
.. |3a78f1bd1d8755ff.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/3a78f1bd1d8755ff.png
.. |81d58d93c4999d0c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/81d58d93c4999d0c.png
.. |48e880ca6b15ce12.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/48e880ca6b15ce12.png
.. |26d72a52b817756e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/26d72a52b817756e.png
.. |46481d6fa7a5b2d5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/46481d6fa7a5b2d5.png
.. |1b21e5a271358b4d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/1b21e5a271358b4d.png
.. |7f27191ef2dcab70.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/7f27191ef2dcab70.png
.. |bbc93fd8434457e5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/bbc93fd8434457e5.png
.. |cb59ad579a5d500b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/cb59ad579a5d500b.png
.. |b4227dc325a0d88e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/b4227dc325a0d88e.png
.. |da78acc3fe00d3d1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/da78acc3fe00d3d1.png
.. |452dfd9799b9445.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/452dfd9799b9445.png
.. |f066c9371aff4900.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/f066c9371aff4900.png
.. |94c5ef155301e63f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/94c5ef155301e63f.png
.. |6b0a242ab7ac238b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/6b0a242ab7ac238b.png
.. |25cc1be6f2679d09.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/25cc1be6f2679d09.png
.. |687d2bf45a4756e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/687d2bf45a4756e.png
.. |38f6d6410fd543f3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/38f6d6410fd543f3.png
.. |8ecdc0b3483ab8cd.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/8ecdc0b3483ab8cd.png
.. |ce74de482bc8844a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-install-android-studio/img/ce74de482bc8844a.png


ğŸš€ Create your first Android app
=================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-first-app


1. Before you begin
-------------------

   Install `Android Studio <https://developer.android.google.cn/studio>`__ on your computer if you
   haven't done so already. Check that your computer meets the system requirements required for
   running Android Studio (located at the bottom of the download page). If you need more detailed
   instructions on the setup process, refer to the `Download and install Android Studio <https://developer.android.google.cn/codelabs/basic-android-kotlin-training-install-android-studio>`__
   codelab.

   In this codelab, you create your first Android app with a project template provided by Android
   Studio. You use Kotlin and Jetpack Compose to customize your app. Note that Android Studio gets
   updated and sometimes the UI changes so it is okay if your Android Studio looks a little
   different than the screenshots in this codelab.


Prerequisites

   -  Basic Kotlin knowledge


What you'll need

   -  The latest version of Android Studio


What you'll learn

   -  How to create an Android App with Android Studio
   -  How to run apps with the Preview tool in Android Studio
   -  How to update text with Kotlin
   -  How to update a User Interface (UI) with Jetpack Compose
   -  How to see a preview of your app with Preview in Jetpack Compose


What you'll build

   -  An app that lets you customize your introduction!

   Here's what the app looks like when you complete this codelab (except it will be customized with
   your name!):

   |13957184d295b16f.png|


What you'll need

   -  A computer with `Android Studio <https://developer.android.google.cn/studio>`__ installed.


2. Create a project using the template
--------------------------------------

   In this codelab, you create an Android app with the **Empty Activity** project template provided
   by Android Studio.

   To create a project in Android Studio:

   1. Double click the Android Studio icon to launch Android Studio.

   |4853d32c0c91ae24.png|

   2. In the **Welcome to Android Studio** dialog, click **New Project**.

   |3ae9fa94ff44605d.png|

   The **New Project** window opens with a list of templates provided by Android Studio.

   |e8d10ef688c296.png|

   In Android Studio, a project template is an Android project that provides the blueprint for a
   certain type of app. Templates create the structure of the project and the files needed for
   Android Studio to build your project. The template that you choose provides starter code to get
   you going faster.

   3. Make sure the **Phone and Tablet** tab is selected.
   4. Click the **Empty Activity** template to select it as the template for your project. The
      **Empty Activity** template is the template to create a simple project that you can use to
      build a Compose app. It has a single screen and displays the text ``"Hello`` ``Android!"``.
   5. Click **Next**. The **New Project** dialog opens. This has some fields to configure your
      project.
   6. Configure your project as follows:

   The **Name** field is used to enter the name of your project, for this codelab type "Greeting
   Card".

   Leave the **Package name** field as is. This is how your files will be organized in the file
   structure. In this case, the package name will be ``com.example.greetingcard``.

   Leave the **Save location** field as is. It contains the location where all the files related to
   your project are saved. Take a note of where that is on your computer so that you can find your
   files.

   Select **API 24: Android 7.0 (Nougat)** from the menu in the **Minimum SDK** field. `Minimum SDK <https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element>`__ 
   indicates the minimum version of Android that your app can run on.

   |7a0f8e0cb77e120c.png|

   7. Click **Finish**. This may take a while - this is a great time to get a cup of tea! While
      Android Studio is setting up, a progress bar and message indicates whether Android Studio is
      still setting up your project. It may look like this:

   |This image shows a progress bar spinning and the text reads,|

   A message that looks similar to this informs you when the project set up is created.

   |This image shows a Gradle sync message that reads,|

   8. You may see a **What's New** pane which contains updates on new features in Android Studio.
      Close it for now.

   |c4b2b7748563ebb7.png|

   9. Click **Split** on the top right of Android Studio, this allows you to view both code and
      design. You can also click **Code** to view code only or click **Design** to view design only.

   |b17a701425679ff1.png|

   After pressing **Split** you should see three areas:

   |d90019bf5a60c11b.png|

   -  The **Project** view (1) shows the files and folders of your project
   -  The **Code** view (2) is where you edit code
   -  The **Design** view (3) is where you preview what your app looks like

   In the **Design** view, you may see a blank pane with this text:

   |The text on this reads|

   10. Click **Build & Refresh**. It may take a while to build but when it is done the preview shows
       a text box that says "**Hello Android!**". Empty Compose activity contains all the code
       necessary to create this app.

   |a86077be9d06a909.png|


3. Find project files
---------------------

   In this section you will continue to explore Android Studio by becoming familiar with the file
   structure.

   1. In Android Studio, take a look at the **Project** tab. The **Project** tab shows the files and
      folders of your project. When you were setting up your project the package name was
      **com.example.greetingcard**. You can see that package right here in the **Project** tab. A
      package is basically a folder where code is located. Android Studio organizes the project in a
      directory structure made up of a set of packages.
   2. If necessary, select **Android** from the drop-down menu in the **Project** tab.

   |52051aa2a3038b89.png|

   This is the standard view and organization of files that you use. It's useful when you write code
   for your project because you can easily access the files you will be working on in your app.
   However, if you look at the files in a file browser, such as Finder or Windows Explorer, the file
   hierarchy is organized very differently.

   3. Select **Project Source Files** from the drop-down menu. You can now browse the files in the
      same way as in any file browser.

   |84dc993206449d28.png|

   4. Select **Android** again to switch back to the previous view. You use the **Android** view for
      this course. If your file structure ever looks strange, check to make sure you're still in
      **Android** view.


4. Update the text
------------------

   Now that you have gotten to know Android Studio, it's time to start making your greeting card!

   Look at the **Code** view of the ``MainActivity.kt`` file. Notice there are some automatically
   generated functions in this code, specifically the ``onCreate()`` and the ``setContent()``
   functions.

   **Note:** Remember that a function is a segment of a program that performs a specific task.

   .. code:: prettyprint

      class MainActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContent {
                  GreetingCardTheme {
                      // A surface container using the 'background' color from the theme
                      Surface(
                          modifier = Modifier.fillMaxSize(),
                          color = MaterialTheme.colorScheme.background
                      ) {
                          Greeting("Android")
                      }
                  }
              }
          }
      }

   The ``onCreate()`` function is the entry point to this Android app and calls other functions to
   build the user interface. In Kotlin programs, the ``main()`` function is the entry point/starting
   point of execution. In Android apps, the ``onCreate()`` function fills that role.

   The `setContent() <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/platform/ComposeView#setContent(kotlin.Function0)>`__
   function within the ``onCreate()`` function is used to define your layout through composable
   functions. All functions marked with the ``@Composable`` annotation can be called from the
   ``setContent()`` function or from other Composable functions. The annotation tells the Kotlin
   compiler that this function is used by Jetpack Compose to generate the UI.

   **Note:** The compiler takes the Kotlin code you wrote, looks at it line by line, and translates
   it into something that the computer can understand. This process is called compiling your code.

   Next, look at the ``Greeting()`` function. The ``Greeting()`` function is a Composable function,
   notice the ``@Composable`` annotation above it. This Composable function takes some input and
   generates what's shown on the screen.

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Text(
              text = "Hello $name!",
              modifier = modifier
          )
      }

   You've learned about functions before (if you need a refresher, visit the
   `Create and use functions in Kotlin <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-functions>`__
   codelab), but there are a few differences with composable functions.



   ::

      @Composable <â”€â”€â”€ 1.
           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€ 2.                       3. â”€â”€â”€â”€â”€â”€â”€â”€â•®
      fun  â”‚  Greeting  â”‚ (name: String, modififer: Modifier = Modifier) {
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
           â”‚ function body          â”‚
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   1. You add the ``@Composable`` annotation before the function.
   2. ``@Composable`` function names are capitalized.
   3. ``@Composable`` functions can't return anything.

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Text(
              text = "Hello $name!",
              modifier = modifier
          )
      }

   Right now the ``Greeting()`` function takes in a name and displays ``Hello`` to that person.

   1. Update the ``Greeting()`` function to introduce yourself instead of saying "Hello":

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Text(
              text = "Hi, my name is $name!",
              modifier = modifier
          )
      }

   2. Android should automatically update the preview.

   |34c74a1b980c177.png|

   Great! You changed the text, but it introduces you as Android, which is probably not your name.
   Next, you will personalize it to introduce you with your name!

   The ``GreetingPreview()`` function is a cool feature that lets you see what your composable looks
   like without having to build your entire app. To enable a preview of a composable, annotate with
   ``@Composable`` and ``@Preview``. The ``@Preview`` annotation tells Android Studio that this
   composable should be shown in the design view of this file.

   As you can see, the ``@Preview`` annotation takes in a parameter called ``showBackground``. If
   ``showBackground`` is set to **true**, it will add a background to your composable preview.

   Since Android Studio by default uses a light theme for the editor, it can be hard to see the
   difference between ``showBackground`` ``=`` ``true`` and ``showBackground`` ``=`` ``false``.
   However, this is an example of what the difference looks like. Notice the white background on the
   image set to ``true``.

   +------------------------------------------------+
   | |239d7fabe065588.png|   showBackground = true  |
   +------------------------------------------------+
   | |3ce153efce1dadd3.png|  showBackground = false |
   +------------------------------------------------+

   3. Update the ``GreetingPreview()`` function with your name. Then rebuild and check out your
      personalized greeting card!

   .. code:: prettyprint

      @Preview(showBackground = true)
      @Composable
      fun GreetingPreview() {
          GreetingCardTheme {
              Greeting("Meghan")
          }
      }

   |9703ef244f8ee16c.png|


5. Change the background color
------------------------------

   Now you have the introduction text, but it's a little boring! In this section, you learn to
   change the background color.

   To set a different background color for your introduction, you'll need to surround your text with
   a `Surface <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/package-summary#Surface(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.foundation.BorderStroke,androidx.compose.ui.unit.Dp,kotlin.Function0)>`__.
   A ``Surface`` is a container that represents a section of UI where you can alter the appearance,
   such as the background color or border.

   1. To surround the text with a ``Surface``, highlight the line of text, press (``Alt+Enter`` for
      Windows or ``Option+Enter`` on Mac), and then select **Surround with widget**.

   |220f9c42667a9595.png|

   2. Choose **Surround with Container**.

   |f5258fe61ffc94fb.png|

   The default container it will give you is ``Box``, but you can change this to another container
   type. You will learn about ``Box`` layout later in the course.

   |85e695291c03dcfc.png|

   3. Delete ``Box`` and type ``Surface()`` instead.

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Surface() {
              Text(
                  text = "Hi, my name is $name!",
                  modifier = modifier
              )
          }
      }

   4. To the ``Surface`` container add a ``color`` parameter, set it to ``Color``.

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Surface(color = Color) {
              Text(
                  text = "Hi, my name is $name!",
                  modifier = modifier
              )
          }
      }

   5. When you type ``Color`` you may notice that it is red, which means Android Studio is not able
      to resolve this. To solve this scroll to the top of the file where it says import and press
      the three buttons.

   |80b6219d24f04365.png|

   6. Add this statement to the bottom of the list of imports.

   .. code:: prettyprint

      import androidx.compose.ui.graphics.Color

   The full list of imports will look similar to this.

   .. code:: prettyprint

      import android.os.Bundle
      import androidx.activity.ComponentActivity
      import androidx.activity.compose.setContent
      import androidx.compose.foundation.layout.Box
      import androidx.compose.foundation.layout.fillMaxSize
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Surface
      import androidx.compose.material3.Text
      import androidx.compose.runtime.Composable
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.tooling.preview.Preview
      import com.example.greetingcard.ui.theme.GreetingCardTheme
      import androidx.compose.ui.graphics.Color

   7. In your code, the best practice is to keep your imports listed alphabetically and remove
      unused imports. To do this press **Help** on the top toolbar, type in **optimize imports**,
      and click on **Optimize Imports**.

   |92241239038c774a.png|

   You could open the **Optimize Imports** directly from the menu: **Code** > **Optimize Imports.**
   Using Help's search option will help you locate a menu item if you don't remember where it is.

   The full list of imports will now look like this:

   .. code:: prettyprint

      import android.os.Bundle
      import androidx.activity.ComponentActivity
      import androidx.activity.compose.setContent
      import androidx.compose.foundation.layout.fillMaxSize
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Surface
      import androidx.compose.material3.Text
      import androidx.compose.runtime.Composable
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.graphics.Color
      import androidx.compose.ui.tooling.preview.Preview
      import com.example.greetingcard.ui.theme.GreetingCardTheme

   8. Notice that the Color that you typed in the Surface parentheses has switched from being red to
      being underlined in red. To fix that, add a period after it. You will see a pop-up showing
      different color options.

   This is one of the cool features in Android Studio, it is intelligent and will help you out when
   it can. In this case it knows you are wanting to specify a color so it will suggest different
   colors.

   |3a709cb72da0f83d.png|

   9. Choose a color for your surface. This codelab uses **Cyan**, but you can choose your favorite!

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
         Surface(color = Color.Cyan) {
             Text(
                 text = "Hi, my name is $name!",
                 modifier = modifier
             )
         }
      }

   10. Notice the updated preview.

   |217a09ca55b503f8.png|


6. Add padding
--------------

   Now your text has a background color, next you will add some space (padding) around the text.

   A `Modifier <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier>`__
   is used to augment or decorate a composable. One modifier you can use is the ``padding``
   modifier, which adds space around the element (in this case, adding space around the text). This
   is accomplished by using the `Modifier.padding() <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).padding(androidx.compose.ui.unit.Dp)>`__
   function.

   Every composable should have an optional parameter of the type ``Modifier``. This should be the
   first optional parameter.

   1. Add a padding to the ``modifier`` with a size of ``24.dp``.

   **Note:** You learn more about density-independent pixels (``dp``) in the next pathway, but refer
   to `Layout â€“ Material Design 3 <https://m3.material.io/foundations/layout/understanding-layout/spacing#abccd6ce-1092-4ad0-9351-de75aeae0edf>`__
   article if you want to read more now.

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Surface(color = Color.Cyan) {
              Text(
                  text = "Hi, my name is $name!",
                  modifier = modifier.padding(24.dp)
              )
          }
      }

   2. Add these imports to the import statement section.

   Make sure to use **Optimize Imports** to alphabetize the new imports.

   .. code:: prettyprint

      import androidx.compose.ui.unit.dp
      import androidx.compose.foundation.layout.padding

   |2c09be85535277e9.png|

   Well congratulations - you built your first Android app in Compose! This is a pretty huge
   accomplishment. Take some time to play around with different colors and text, make it your own!


7. Review the solution code
---------------------------


Code snippet for review

   .. code:: prettyprint

      package com.example.greetingcard

      import android.os.Bundle
      import androidx.activity.ComponentActivity
      import androidx.activity.compose.setContent
      import androidx.compose.foundation.layout.fillMaxSize
      import androidx.compose.foundation.layout.padding
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Surface
      import androidx.compose.material3.Text
      import androidx.compose.runtime.Composable
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.graphics.Color
      import androidx.compose.ui.tooling.preview.Preview
      import androidx.compose.ui.unit.dp
      import com.example.greetingcard.ui.theme.GreetingCardTheme

      class MainActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContent {
                  GreetingCardTheme {
                      // A surface container using the 'background' color from the theme
                      Surface(
                          modifier = Modifier.fillMaxSize(),
                          color = MaterialTheme.colorScheme.background
                      ) {
                          Greeting("Android")
                      }
                  }
              }
          }
      }

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Surface(color = Color.Cyan) {
              Text(
                  text = "Hi, my name is $name!",
                  modifier = modifier.padding(24.dp)
              )
          }
      }

      @Preview(showBackground = true)
      @Composable
      fun GreetingPreview() {
          GreetingCardTheme {
              Greeting("Meghan")
          }
      }


8. Conclusion
-------------

   You learned about Android Studio and built your first Android app with Compose, great job!

   This codelab is part of the `Android Basics with Compose course <https://developer.android.google.cn/courses/android-basics-compose/course>`__. 
   To learn how to run your app on the emulator or a physical device, check out the next codelabs in 
   `this pathway <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-1-pathway-2>`__.


Summary

   -  To create a new project: open Android Studio, click **New Project > Empty Activity > Next**,
      enter a name for your project and then configure its settings.
   -  To see how your app looks, use the **Preview** pane.
   -  Composable functions are like regular functions with a few differences: functions names are
      capitalized, you add the ``@Composable`` annotation before the function, ``@Composable``
      functions can't return anything.
   -  A `Modifier <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier>`__
      is used to augment or decorate your composable.


Learn more

   -  `Meet Android Studio <https://developer.android.google.cn/studio/intro>`__
   -  `Projects overview <https://developer.android.google.cn/studio/projects>`__
   -  `Create a project <https://developer.android.google.cn/studio/projects/create-project>`__
   -  `Add code from a template <https://developer.android.google.cn/studio/projects/templates>`__
   -  `Jetpack Compose <https://developer.android.google.cn/jetpack/compose>`__
   -  `Padding â€“ Material Design 3 <https://m3.material.io/foundations/layout/understanding-layout/spacing#64eb2223-f5e8-4d2a-9edc-9e3a7002220a>`__


.. |13957184d295b16f.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/13957184d295b16f.png
.. |4853d32c0c91ae24.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/4853d32c0c91ae24.png
.. |3ae9fa94ff44605d.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/3ae9fa94ff44605d.png
.. |e8d10ef688c296.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/e8d10ef688c296.png
.. |7a0f8e0cb77e120c.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/7a0f8e0cb77e120c.png
.. |This image shows a progress bar spinning and the text reads,| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/68405342ab13c821.png
.. |This image shows a Gradle sync message that reads,| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/3558f61a535db5d1.png
.. |c4b2b7748563ebb7.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/c4b2b7748563ebb7.png
.. |b17a701425679ff1.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/b17a701425679ff1.png
.. |d90019bf5a60c11b.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/d90019bf5a60c11b.png
.. |The text on this reads| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/38c4a624cae42640.png
.. |a86077be9d06a909.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/a86077be9d06a909.png
.. |52051aa2a3038b89.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/52051aa2a3038b89.png
.. |84dc993206449d28.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/84dc993206449d28.png
.. |34c74a1b980c177.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/34c74a1b980c177.png
.. |239d7fabe065588.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/239d7fabe065588.png
.. |3ce153efce1dadd3.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/3ce153efce1dadd3.png
.. |9703ef244f8ee16c.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/9703ef244f8ee16c.png
.. |220f9c42667a9595.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/220f9c42667a9595.png
.. |f5258fe61ffc94fb.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/f5258fe61ffc94fb.png
.. |85e695291c03dcfc.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/85e695291c03dcfc.png
.. |80b6219d24f04365.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/80b6219d24f04365.png
.. |92241239038c774a.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/92241239038c774a.png
.. |3a709cb72da0f83d.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/3a709cb72da0f83d.png
.. |217a09ca55b503f8.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/217a09ca55b503f8.png
.. |2c09be85535277e9.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-first-app/img/2c09be85535277e9.png


ğŸš€ Run your first app on the Android Emulator
==============================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-emulator



1. Before you begin
-------------------

   In this codelab, you'll take the Greeting Card app you built in the 
   `Create your first Android app codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-first-app>`__ , 
   set up an Android Virtual Device (AVD), and see your code in action on an Android Emulator.


Prerequisites

   -  Knowledge of how to set up, configure, and use apps, such as a word processor or a
      spreadsheet.


What you'll learn

   -  How to create an AVD and run an app on the Android Emulator


What you'll build

   -  A basic Android app from a template


What you'll need

   -  A computer with Android Studio installed


2. Watch the code-along video (Optional)
----------------------------------------

   If you'd like to watch one of the course instructors complete the codelab, play the below video.

   It's recommended to expand the video to full screen. In the video player, click the **Full
   screen** icon |This symbol shows 4 corners on a square highlighted, to indicate full screen
   mode.| so you can see Android Studio and the code more clearly.

   This step is optional. You can also skip the video and start the codelab instructions right away.

   .. image:: https://googledownloads.cn/cn-devsite/HyOejjpVFtQ.mp4


3. Run your app on the Android Emulator
---------------------------------------

   In this task, you'll use the `Device Manager <http://developer.android.google.cn/tools/devices/managing-avds.html>`__ to create an
   Android Virtual Device (AVD). An AVD is a software version, also called an emulator, of a mobile
   device that runs on your computer and mimics the configuration of a particular type of Android
   device. This could be any phone, tablet, TV, watch, or Android Auto device. You'll use an AVD to
   run the Greeting Card app.

   **Note:** The Android Emulator is an independent app used to set up a virtual device and it has
   its own system requirements. Virtual devices can use a lot of disk space. If you run into any
   issues, see `Run apps on the Android Emulator <https://developer.android.google.cn/studio/run/emulator.html#Requirements>`__.


Create an AVD

   To run an Android app in an emulator on your computer, you first create a virtual device.

   1. In Android Studio, select **Tools > Device Manager**.

   |cf2abfbf15ceaa38.png|

   The **Device Manager** dialog opens. If you created a virtual device previously, it's listed in
   this dialog.

   |75adb8b6801b6f7f.png|

   2. Click + (**Create Virtual Device)**.

   The **Virtual Device Configuration** dialog appears.

   |41d28c72ce93fd7.png|

   The dialog shows a list of pre-configured devices, organized by category, from which you can
   choose. For each device, the table provides a column for its display size (in inches), screen
   resolution (in pixels), and pixel density (number of pixels per inch).

   3. Select **Phone** as the category.
   4. Select a phone, such as the **Pixel 6**, and then click **Next**.

   This step opens another screen where you can choose the version of Android to run on your virtual
   device. This lets you test your app on different versions of Android.

   |4413763938ade209.png|

   5. If there's a download link next to **UpsideDownCake**, click **Download > Accept > Next >
      Finish**. The presence of the download link indicates that the image isn't installed on your
      computer, in which case you must install the image before you can configure the virtual
      device. Expect the download to take some time to complete.

   |dca196de91530326.png|

   |30286f0543d58317.png|

   6. In the **Recommended** tab, choose **UpsideDownCake** as the version of Android to run on the
      virtual device, and then click **Next**.

   Android 14 UpsideDownCake is the latest version of Android at the time of writing, but you can
   choose any later stable version. For a list of stable versions, see 
   `Platform codenames, versions, API levels, and NDK releases <https://source.android.google.cn/setup/start/build-numbers#platform-code-names-versions-api-levels-and-ndk-releases>`__.

   **Important:** These Android system images use a lot of disk space, so only a few are part of
   your original installation. Many more versions of the Android system are available than are shown
   in the **Recommended** tab. To see them, look under the **x86 Images** and **Other Images** tabs
   in the **Virtual Device Configuration** dialog.

   |4a06ff8ced8c3009.png|

   This action opens another screen, where you can choose additional configuration details for your
   device.

   |d0c8eaebaafe26a3.png|

   **Note:** If you see the red warning about using an image with Google APIs like in the screenshot
   above, you can disregard it for now.

   7. In the **AVD Name** field, enter a name for your AVD or use the default. Leave the rest of the
      fields unchanged.

   8. Click **Finish**.

   This action returns to the **Device Manager** pane.

   |448300499c4c136e.png|

   9. Close the **Device Manager** dialog.


Run your app on the Android Emulator

   1. Select the virtual device that you created from the dropdown menu at the top of the Android
      Studio window.

   |f74add101e42afde.png|

   2. Click |a9b51361ad5fb49f.png|.

   The virtual device starts just like a physical device. Expect this to take a whileâ€”potentially
   several minutesâ€”for the emulator to start for the first time. The virtual device should open
   beside the code editor.

   |1d09cfc43d012bd.png|

   When your app is ready, it opens on the virtual device.

   |e5f5b9afeb297948.png|

   Great job! Your virtual device is now up and running. The app launches, and you can see the
   background color and greeting text on the screen.


4. Conclusion
-------------

   Congratulations! You ran your app on the Android Emulator!


Summary

   -  To create an AVD, open your project, click **Tools > Device Manager**, and use the 
      `Device Manager <http://developer.android.google.cn/tools/devices/managing-avds.html>`__ 
      to select a hardware device and system image.
   -  To run your app on a virtual device, ensure that you created a device, select the device from
      the toolbar menu, and click |a9b51361ad5fb49f.png|.


Learn more

   -  `Meet Android Studio <https://developer.android.google.cn/studio/intro>`__
   -  `Projects overview <https://developer.android.google.cn/studio/projects>`__
   -  `Create a project <https://developer.android.google.cn/studio/projects/create-project>`__
   -  `Add code from a template <https://developer.android.google.cn/studio/projects/templates>`__
   -  `Build and run your app <https://developer.android.google.cn/studio/run>`__
   -  `Run apps on the Android Emulator <https://developer.android.google.cn/studio/run/emulator>`__

.. |This symbol shows 4 corners on a square highlighted, to indicate full screen mode.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/adba01179d2b6579.png
.. |cf2abfbf15ceaa38.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/cf2abfbf15ceaa38.png
.. |75adb8b6801b6f7f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/75adb8b6801b6f7f.png
.. |41d28c72ce93fd7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/41d28c72ce93fd7.png
.. |4413763938ade209.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/4413763938ade209.png
.. |dca196de91530326.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/dca196de91530326.png
.. |30286f0543d58317.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/30286f0543d58317.png
.. |4a06ff8ced8c3009.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/4a06ff8ced8c3009.png
.. |d0c8eaebaafe26a3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/d0c8eaebaafe26a3.png
.. |448300499c4c136e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/448300499c4c136e.png
.. |f74add101e42afde.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/f74add101e42afde.png
.. |a9b51361ad5fb49f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/a9b51361ad5fb49f.png
.. |1d09cfc43d012bd.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/1d09cfc43d012bd.png
.. |e5f5b9afeb297948.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-emulator/img/e5f5b9afeb297948.png



ğŸš€ How to connect your Android device
=======================================

   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-connect-device


1. Before you begin
--------------------------------------------------------------------------------

   In this codelab, you learn how to connect your app in Android Studio to your physical
   Android device. You can either connect your device with a cable or with Wi-Fi. This
   codelab will cover both cases. Note that Android Studio gets updated and sometimes the
   UI changes so it is okay if your Android Studio looks a little different than what is
   shown on the screen.


Prerequisites

   -  Basic knowledge of how to use Android Studio.
   -  Ability to open and adjust settings on your Android device.


What you'll learn

   -  How to enable your Android device to run apps from Android Studio.
   -  How to connect and run an app in Android Studio on a physical Android device.


What you'll need

   -  `Android Studio <https://developer.android.google.cn/studio>`__ downloaded and
      installed on your computer.
   -  An app project set up in Android Studio.
   -  An Android device, such as a phone or tablet running Lollipop or later.
   -  (Optional) A USB cable to connect your Android device to your computer through their
      USB ports.

   **Note:** If you need help to determine which kind of USB ports your computer and
   Android device have, and the corresponding cable that you need, see
   `USB <https://en.wikipedia.org/wiki/USB>`__.


2. Watch the code-along video (Optional)
--------------------------------------------------------------------------------

   If you'd like to watch one of the course instructors complete the codelab, play the
   below video.

   It's recommended to expand the video to full screen (with this icon |This symbol shows 4
   corners on a square highlighted, to indicate full screen mode.| in the lower right
   corner of the video) so you can see Android Studio and the code more clearly.

   This step is optional. You can also skip the video and start the codelab instructions
   right away.


3. Enable USB debugging
--------------------------------------------------------------------------------

   To let Android Studio communicate with your Android device, you must enable USB
   debugging in the Developer options settings of the device.

   To show developer options and enable USB debugging:

   1. On your Android device, tap **Settings** > **About phone**.
   2. Tap **Build number** seven times.
   3. If prompted, enter your device password or pin. You know you succeeded when you see a
      **You are now a developer!** message.

   |fc5ee039dab58109.png|

   4. Return to **Settings** and then tap **System** > **Developer options**.
   5. If you don't see **Developer options**, tap **Advanced options**.

   ======================================================================== ========
   |This image shows the System page with Developer options boxed in red.|  |47c878fe8ba38d47.png|
   ======================================================================== ========

   6. Tap **Developer options** and then tap the **USB debugging** toggle to turn it on.

   |This image shows the Options page with USB debugging toggled on and boxed in red.|


`Install the Google USB Driver (Windows only) <https://developer.android.google.cn/codelabs/basic-android-kotlin-training-run-on-mobile-device>`__

   If you installed Android Studio on Windows, you must install a USB device driver before
   you can run your app on a physical device.

   **Note:** For Ubuntu Linux, follow the instructions in 
   `Run Apps on a Hardware Device <http://developer.android.google.cn/tools/device.html>`__.

   1. In Android Studio, click **Tools > SDK Manager**. The **Preferences > Appearance &
      Behavior > System Settings > Android SDK** dialog opens.
   2. Click the **SDK Tools** tab.
   3. Select **Google USB Driver** and then click **OK**.

   |3a5910f5cf07382f.png|

   When done, the driver files are downloaded into the
   ``android_sdk\extras\google\usb_driver`` directory. Now you can connect and run your app
   from Android Studio.


4. Run your app on the Android device with a cable
--------------------------------------------------------------------------------

   There are two ways to connect your device to Android Studio, through a cable or through
   Wi-Fi. You can choose whichever you like more.

   To run your app from Android Studio on your Android device:

   1. Connect your Android device to your computer with a USB cable. A dialog should appear
      on your device, which asks you to allow USB debugging.

   |ade9c70a580ffbee.png|

   2. Select the **Always allow from this computer** checkbox and then tap **OK**.
   3. In Android Studio on your computer, make sure your device is selected in the
      dropdown. Click |This is the Android Studio Run icon|.

   |d180c23e4e73e5d2.png|

   4. Select your device and then click **OK**. Android Studio installs the app on your
      device and runs it.

   **Note:** For Android Studio 3.6 and higher, the physical device is automatically
   selected when the device is connected with debugging turned on.

   5. If your device runs an Android platform that isn't installed in Android Studio and
      you see a message that asks whether you want to install the needed platform, click
      **Install > Continue > Finish**. Android Studio installs the app on your device and
      runs it.


5. Run your app on the Android device with Wi-Fi
--------------------------------------------------------------------------------

   If you don't have a cable, you can also connect and run your app on your device with
   Wi-Fi.


Get started

   1. Ensure that your computer and device are connected to the same wireless network.
   2. Ensure that your device runs Android 11 or higher. For more information, see 
      `Check & update your Android version <https://support.google.com/android/answer/7680439>`__.
   3. Ensure that your computer has the latest version of Android Studio. To download it,
      see `Android Studio <https://developer.android.google.cn/studio>`__.
   4. Ensure that your computer has the latest version of the 
      `SDK Platform Tools <https://developer.android.google.cn/studio/releases/platform-tools>`__.


Pair your device

   1. In Android Studio, select **Pair Devices Using Wi-Fi** from the run configurations
      drop-down menu.

   |This image shows a drop-down menu with Pair Devices Using Wi-Fi selected.|

   The **Pair devices over Wi-Fi** dialog opens.

   |4715f95a3d2be595.png|

   2. Go to **Developer options**, scroll down to the **Debugging** section and turn on
      **Wireless debugging**.

   |1a7a69258cf2a132.png|

   3. On the **Allow wireless debugging on this network?** popup, select **Allow**.

   |5da578d4c08b3c3b.png|

   4. If you want to pair your device with a QR code, select **Pair device with QR code**
      and then scan the QR code on your computer. Alternatively, if you want to pair your
      device with a pairing code, select **Pair device with pairing code** and then enter
      the 6-digit code.
   5. Click run and you can deploy your app to your device.

   **Note:** If you want to pair a different device or forget this device on your computer,
   navigate to **Wireless debugging** on your device, tap on your workstation name under
   **Paired devices**, and select **Forget**.


6. Troubleshooting
--------------------------------------------------------------------------------

   -  If your computer runs Linux or Windows, and you can't run your app on a physical
      Android device, see `Run apps on a hardware device <http://developer.android.google.cn/tools/device.html>`__ 
      for additional steps.

   -  If your computer runs Windows and the emulator installation doesn't work, see
      `Install OEM USB Drivers <http://developer.android.google.cn/tools/extras/oem-usb.html>`__ for the
      appropriate USB driver for your device.

   -  If Android Studio doesn't recognize your device: try unplugging the USB cable and
      plug it back in or restarting Android Studio.

   -  If your computer still doesn't find the device or declares it unauthorized:
      disconnect the USB cable. On the device, tap **Settings > Developer options > Revoke
      USB debugging authorizations**. Reconnect the device to your computer. When prompted,
      grant authorizations.


7. Conclusion
--------------------------------------------------------------------------------

   You learned how to run an app in Android Studio on your physical Android device!


Summary

   -  You can run Android apps on your physical device through a cord or through Wi-Fi.
   -  Windows users need to install a USB debugging driver to run apps on their physical
      device.
   -  If you are running your app through Wi-Fi, you can pair using a QR code or a 6 digit
      code.


Learn more

   -  `Run apps on a hardware device <https://developer.android.google.cn/studio/run/device>`__
   -  `Install OEM USB drivers <https://developer.android.google.cn/studio/run/oem-usb#Drivers>`__
   -  `Get the Google USB Driver <https://developer.android.google.cn/studio/run/win-usb>`__

   Except as otherwise noted, the content of this page is licensed under the 
   `Creative Commons Attribution 4.0 License <https://creativecommons.org/licenses/by/4.0/>`__, and code samples
   are licensed under the `Apache 2.0 License <https://www.apache.org/licenses/LICENSE-2.0>`__. 
   For details, see the `Google Developers Site Policies <https://developers.google.cn/site-policies>`__. Java is a
   registered trademark of Oracle and/or its affiliates.


.. |This symbol shows 4 corners on a square highlighted, to indicate full screen mode.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/adba01179d2b6579.png
.. |fc5ee039dab58109.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/fc5ee039dab58109.png
.. |This image shows the System page with Developer options boxed in red.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/c4b7a41bbf7800c3.png
.. |47c878fe8ba38d47.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/47c878fe8ba38d47.png
.. |This image shows the Options page with USB debugging toggled on and boxed in red.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/cfc535f28f645d95.png
.. |3a5910f5cf07382f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/3a5910f5cf07382f.png
.. |ade9c70a580ffbee.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/ade9c70a580ffbee.png
.. |This is the Android Studio Run icon| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/948df8a56a7923c8.png
.. |d180c23e4e73e5d2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/d180c23e4e73e5d2.png
.. |This image shows a drop-down menu with Pair Devices Using Wi-Fi selected.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/eaab2f4e864cb67a.png
.. |4715f95a3d2be595.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/4715f95a3d2be595.png
.. |1a7a69258cf2a132.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/1a7a69258cf2a132.png
.. |5da578d4c08b3c3b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-connect-device/img/5da578d4c08b3c3b.png


ğŸš€ Build a simple app with text composables
===========================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-text-composables



1. Before you begin
-------------------

   In this codelab, you use Jetpack Compose to build a simple Android app that displays a birthday
   message on the screen.


Prerequisites

   -  How to create an app in Android Studio.
   -  How to run an app on an emulator or your Android device.


What you'll learn

   -  How to write composable functions, such as ``Text``, ``Column`` and ``Row`` composable
      functions.
   -  How to display text in your app in a layout.
   -  How to format the text, such as changing text size.


What you'll build

   -  An Android app that displays a birthday greeting in text format, which looks like this
      screenshot when done:

   |2ff181d48325023c.png|


What you'll need

   -  A computer with Android Studio installed
   - https://github.dev/google-developer-training/basic-android-kotlin-compose-birthday-card-app


2. Set up a Happy Birthday app
------------------------------

   In this task, you set up a project in Android Studio with the Empty Activity template and change
   the text message to a personalized birthday greeting.


Create an Empty Activity project

   1. In the **Welcome to Android Studio** dialog, select **New Project**.
   2. In the **New Project** dialog, select **Empty Activity** and then click **Next**.
   3. In the **Name** field enter ``Happy Birthday`` and then select a minimum API level of 24
      (Nougat) in the **Minimum SDK** field and click **Finish**.

   |b17b607847b0d0ab.png|

   4. Wait for Android Studio to create the project files and build the project.
   5. Click |fd26b2e3c2870c3.png| **Run â€˜app'**.

   The app should look like this screenshot:

   |d8299bfc1a82cd57.png|

   When you created this Happy Birthday app with the Empty Activity template, Android Studio set up
   resources for a basic Android app, including a **Hello Android!** message on the screen. In this
   codelab, you learn how that message gets there, how to change its text to a birthday greeting,
   and how to add and format additional messages.


What is a user interface (UI)?

   The user interface (UI) of an app is what you see on the screen: text, images, buttons, and many
   other types of elements, and how it's laid out on the screen. It's how the app shows things to
   the user and how the user interacts with the app.

   This image contains a clickable button, text message, and text-input field where users can enter
   data.

   |9a2df39af4122803.png|

   *Clickable button*

   |50a9b402fd9037c0.png|

   *Text message inside a Card*

   |17794ea52cfb5473.png|

   *Text-input field*

   Each of these elements is called a UI component. Almost everything you see on the screen of your
   app is a UI element (also known as a UI component). They can be interactive, like a clickable
   button or an editable input field, or they can be decorative images.

   In the following apps, try to find as many UI components as you can.

   =========================== =====================
   |showing recommended apps|  |f3835a9ffa17a7c.png|
   =========================== =====================

   In this codelab, you work with a UI element that displays text called a ``Text`` element.


3. What is Jetpack Compose?
---------------------------

   Jetpack Compose is a modern toolkit for building Android UIs. Compose simplifies and accelerates
   UI development on Android with less code, powerful tools, and intuitive Kotlin capabilities. With
   Compose, you can build your UI by defining a set of functions, called composable functions, that
   take in data and describe UI elements.


Composable functions

   Composable functions are the basic building block of a UI in Compose. A composable function:

   -  Describes some part of your UI.
   -  Doesn't return anything.
   -  Takes some input and generates what's shown on the screen.


Annotations

   Annotations are means of attaching extra information to code. This information helps tools like
   the Jetpack Compose compiler, and other developers understand the app's code.

   An annotation is applied by prefixing its name (the annotation) with the ``@`` character at the
   beginning of the declaration you are annotating. Different code elements, including properties,
   functions, and classes, can be annotated. Later on in the course, you'll learn about classes.

   The following diagram is an example of annotated function:

   ::

      Annotation, Prefix character: @
           â”‚
      â•­â”€â”€â”€â”€â”´â”€â”€â”€â”€â•®
      @Composable
      fun Greeting (name: String, modifier: Modifier) { }
      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                               â”‚
                     Function declaration

   The following code snippet has examples of annotated properties. You will be using these in the
   coming codelabs.

   .. code:: prettyprint

      // Example code, do not copy it over

      @Json
      val imgSrcUrl: String

      @Volatile
      private var INSTANCE: AppDatabase? = null


Annotations with parameters

   Annotations can take parameters. Parameters provide extra information to the tools processing
   them. The following are some examples of the ``@Preview`` annotation with and without parameters.

   .. code:: kotlin

      @Preview
      @Composable
      fun GreetingPreview() {
         HappyBirthdayTheme {
            Greeting (name: "Android")
         }
      }

   |Android studio screenshot showing code and preview|

   *Annotation without parameters*

   .. code:: kotlin

      @Preview(showBackground = true)
      @Composable
      fun GreetingPreview() {
         HappyBirthdayTheme {
            Greeting (name: "Android")
         }
      }

   |e3845e0f058aede9.png|


   *Annotation previewing background*

   .. code:: kotlin

      @Preview(name = "My Preview")
      @Composable
      fun GreetingPreview() {
         HappyBirthdayTheme {
            Greeting (name: "Android")
         }
      }

   |28a8df85bf4e80e6.png|

   *Annotation with a preview title*

   You can pass multiple arguments to the annotation, as shown here.

   |895f8d3a229c287a.png|

   Android studio screenshot showing code and preview

   *Annotation with a preview title and the system UI (the phone screen)*

   Jetpack Compose includes a wide range of built-in annotations, you have already seen
   ``@Composable`` and ``@Preview`` annotations so far in the course. You will learn more
   annotations and their usages in the latter part of the course.


Example of a composable function

   The Composable function is annotated with the `@Composable <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/Composable>`__
   annotation. All composable functions must have this annotation. This annotation informs the
   Compose compiler that this function is intended to convert data into UI. As a reminder, a
   compiler is a special program that takes the code you wrote, looks at it line by line, and
   translates it into something the computer can understand (machine language).

   This code snippet is an example of a simple composable function that is passed data (the ``name``
   function parameter) and uses it to render a text element on the screen.

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String) {
          Text(text = "Hello $name!")
      }

   A few notes about the composable function:

   -  Jetpack Compose is built around composable functions. These functions let you define your
      app's UI programmatically by describing how it should look, rather than focusing on the
      process of the UI's construction. To create a composable function, just add the
      ``@Composable`` annotation to the function name.

   -  Composable functions can accept arguments, which let the app logic describe or modify the UI.
      In this case, your UI element accepts a ``String`` so that it can greet the user by name.


Notice the composable functions in code

   1. In Android Studio, open the ``MainActivity.kt`` file.

   2. Scroll to the ``GreetingPreview()`` function. This composable function helps preview the
      ``Greeting()`` function. As a good practice, functions should always be named or renamed to
      describe their functionality. Change the name of this function to ``BirthdayCardPreview()``.

   .. code:: prettyprint

      @Preview(showBackground = true)
      @Composable
      fun BirthdayCardPreview() {
          HappyBirthdayTheme {
              Greeting("Android")
          }
      }

   Composable functions can call other composable functions. In this code snippet, the preview
   function is calling the ``Greeting()`` composable function.

   Notice the previous function also has another annotation, a ``@Preview`` annotation, with a
   parameter before the ``@Composable`` annotation. You learn more about the arguments passed to the
   ``@Preview`` annotation later in the course.


Composable function names

   The compose function that returns nothing and bears the ``@Composable`` annotation MUST be named
   using Pascal case. Pascal case refers to a naming convention in which the first letter of each
   word in a compound word is capitalized. The difference between Pascal case and camel case is that
   all words in Pascal case are capitalized. In camel case, the first word can be in either case.

   The Compose function:

   -  *MUST* be a noun: ``DoneButton()``
   -  *NOT* a verb or verb phrase: ``DrawTextField()``
   -  *NOT* a nouned preposition: ``TextFieldWithLink()``
   -  *NOT* an adjective: ``Bright()``
   -  *NOT* an adverb: ``Outside()``
   -  Nouns *MAY* be prefixed by descriptive adjectives: ``RoundIcon()``

   To learn more see `Naming Composable functions <https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md#naming-unit-composable-functions-as-entities>`__.

   **Example code. Do not copy over**

   .. code:: prettyprint

      // Do: This function is a descriptive PascalCased noun as a visual UI element
      @Composable
      fun FancyButton(text: String) {}


      // Do: This function is a descriptive PascalCased noun as a non-visual element
      // with presence in the composition
      @Composable
      fun BackButtonHandler() {}


      // Don't: This function is a noun but is not PascalCased!
      @Composable
      fun fancyButton(text: String) {}


      // Don't: This function is PascalCased but is not a noun!
      @Composable
      fun RenderFancyButton(text: String) {}


      // Don't: This function is neither PascalCased nor a noun!
      @Composable
      fun drawProfileImage(image: ImageAsset) {}


4. Design pane in Android Studio
--------------------------------

   `Android Studio <https://developer.android.google.cn/studio>`__ lets you preview your composable
   functions within the IDE, instead of installing the app to an Android device or emulator. As you
   learned in the previous pathway, you can preview what your app looks like in the **Design** pane
   in Android Studio.

   |2bb27291fa8c8ecc.png|

   The composable function must provide default values for any parameters to preview it. For this
   reason, it is recommended not to preview the ``Greeting()`` function directly. Instead, you need
   to add another function, the ``BirthdayCardPreview()`` function in this case, that calls the
   ``Greeting()`` function with an appropriate parameter.

   .. code:: prettyprint

      @Preview(showBackground = true)
      @Composable
      fun BirthdayCardPreview() {
          HappyBirthdayTheme {
              Greeting("Android")
          }
      }

   **Tip**: Click **Split** icon to view both your code and design preview.

   |86a1dd28a40dea11.png|

   To view your preview:

   1. In the ``BirthdayCardPreview()`` function, change the ``"Android"`` argument in the
      *``Greeting()``* function to your name.

   .. code:: prettyprint

      @Preview(showBackground = true)
      @Composable
      fun BirthdayCardPreview() {
          HappyBirthdayTheme {
              Greeting("James")
          }
      }

   2. The preview should automatically update.

   You should see the updated preview.

   |907e7542c84daf9f.png|

   **Important**: The code you added to the ``BirthdayCardPreview()`` function with the ``@Preview``
   annotation is only for previewing in the **Design** pane in Android Studio. These changes aren't
   reflected in the app. You learn how to make changes to the app later in this codelab.


5. Add a new text element
-------------------------

   In this task, you remove the ``Hello $name!`` greeting and add a birthday greeting.


Add a new composable function

   1. In the ``MainActivity.kt`` file, delete the ``Greeting()`` function definition. You will add
      your own function to display the greeting in the codelab later.

   **Remove the following code**

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Text(
              text = "Hello $name!",
              modifier = modifier
          )
      }

   2. Inside the ``onCreate()`` function, notice that the ``Greeting()`` function call is now
      colored red. This red coloring indicates an error. Hover over the cursor over this function
      call and Android Studio will display information regarding the error.

   |9634619e59248532.png|

   3. Delete the ``Greeting()`` function call along with its arguments from the ``onCreate()`` and
      ``BirthdayCardPreview()`` functions. Your ``MainActivity.kt`` file will look similar to this:

   .. code:: prettyprint

      class MainActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContent {
                  HappyBirthdayTheme {
                      // A surface container using the 'background' color from the theme
                      Surface(
                          modifier = Modifier.fillMaxSize(),
                          color = MaterialTheme.colorScheme.background
                      ) {
                      }
                  }
              }
          }
      }

      @Preview(showBackground = true)
      @Composable
      fun BirthdayCardPreview() {
          HappyBirthdayTheme {
          }
      }

   4. Before the ``BirthdayCardPreview()`` function, add a new function called ``GreetingText()``.
      Don't forget to add the ``@Composable`` annotation before the function because this will be a
      compose function describing a ``Text`` composable.

   .. code:: prettyprint

      @Composable
      fun GreetingText() {
      }

   5. It's a best practice to have your Composable accept a ``Modifier`` parameter, and pass that
      ``modifier`` to its first child. You will learn more about ``Modifier`` and child elements in
      the subsequent tasks and codelabs. For now, add a ``Modifier`` parameter to the
      ``GreetingText()`` function.

   .. code:: prettyprint

      @Composable
      fun GreetingText(modifier: Modifier = Modifier) {
      }

   6. Add a ``message`` parameter of type ``String`` to the ``GreetingText()`` composable function.

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, modifier: Modifier = Modifier) {
      }

   7. In the ``GreetingText()`` function, add a `Text <https://developer.android.google.cn/jetpack/compose/text>`__ 
      composable passing in the text message as a named argument.

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, modifier: Modifier = Modifier) {
          Text(
              text = message
          )
      }

   This ``GreetingText()`` function displays text in the UI. It does so by calling the ``Text()``
   composable function.


Preview the function

   In this task you will preview the ``GreetingText()`` function in the **Design** pane.

   1. Call the ``GreetingText()`` function inside the ``BirthdayCardPreview()`` function.
   2. Pass a ``String`` argument to the ``GreetingText()`` function, a birthday greeting to your
      friend. You can customize it with their name if you like, such as ``"Happy Birthday Sam!"``.

   .. code:: prettyprint

      @Preview(showBackground = true)
      @Composable
      fun BirthdayCardPreview() {
          HappyBirthdayTheme {
              GreetingText(message = "Happy Birthday Sam!")
          }
      }

   3. In the **Design** pane updated automatically. Preview your changes.

   |334688e2e89fb19e.png|


6. Change font size
-------------------

   You added text to your user interface, but it doesn't look like the final app yet. In this task,
   you learn how to change the size, text color, and other attributes that affect the appearance of
   the text element. You can also experiment with different font sizes and colors.


Scalable pixels

   The `scalable pixels (SP) <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/unit/package-summary#(kotlin.Float).sp()>`__
   is a unit of measure for the font size. UI elements in Android apps use two different units of
   measurement: `density-independent pixels (DP) <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/unit/package-summary#(kotlin.Int).dp()>`__,
   which you use later for the layout, and scalable pixels (SP). By default, the SP unit is the same
   size as the DP unit, but it resizes based on the user's preferred text size under phone settings.

   1. In the ``MainActivity.kt`` file, scroll to the ``Text()`` composable in the ``GreetingText()``
      function.
   2. Pass the ``Text()`` function a ``fontSize`` argument as a second named argument and set it to
      a value of ``100.sp``.

   .. code:: prettyprint

      Text(
          text = message,
          fontSize = 100.sp
      )

   Android Studio highlights the ``.sp`` code because you need to import some classes or properties
   to compile your app.

   |ba6c753d4eefd1d5.png|

   3. Click **``.sp``**, which is highlighted by Android Studio.
   4. Click **Import** in the popup to import the **``androidx.compose.ui.unit.sp``** to use the
      ``.sp`` extension property.

   **Note:** The AndroidX (Android Extension) library contains a set of libraries and classes that
   help accelerate your app development, by providing you the core functionality. You can access the
   classes, properties, and other artifacts using the ``androidx`` package.

   5. Scroll to the top of the file and notice the ``import`` statements, where you should see an
      ``import androidx.compose.ui.unit.sp`` statement, which means that Android Studio adds the
      package to your file.

   |e073e9d3465e080c.png|

   **Note:** If you encounter any problems with importing using Android Studio, you can manually add
   the imports at the top of the file.

   6. Notice the updated preview of the font size. The reason for overlapping message is you need to
      specify the line height.

   |3bf48548c10f4ea.png|

   **Note:** The ``sp`` is an `extension property <https://kotlinlang.org/docs/extensions.html#extension-properties>`__ 
   for ``Int``, which creates an ``sp`` unit. Similarly, you can use the ``.sp`` 
   extension property in other data types, like ``Float`` and ``Double``.

   7. Update the ``Text`` composable to include the line height.

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, modifier: Modifier = Modifier) {
          Text(
              text = message,
              fontSize = 100.sp,
              lineHeight = 116.sp,
          )
      }

   |ef457e9b19d4d495.png|

   Now you can experiment with different font sizes.


7. Add another text element
---------------------------

   In your previous tasks, you added a birthday-greeting message to your friend. In this task, you
   sign your card with your name.

   1. In the ``MainActivity.kt`` file, scroll to the ``GreetingText()`` function.
   2. Pass the function a ``from`` parameter of type ``String`` for your signature.

   .. code:: prettyprint

      fun GreetingText(message: String, from: String, modifier: Modifier = Modifier)

   **Note**: The order of the function parameters doesn't matter if you use the named arguments in
   the function call.

   3. After the birthday message ``Text`` composable, add another ``Text`` composable that accepts a
      ``text`` argument set to the ``from`` value.

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, from: String, modifier: Modifier = Modifier) {
          Text(
              // ...
          )
          Text(
              text = from
          )
      }

   4. Add a ``fontSize`` named argument set to a value of ``36.sp``.

   .. code:: prettyprint

      Text(
          text = from,
          fontSize = 36.sp
      )

   5. Scroll to the ``BirthdayCardPreview()`` function.
   6. Add another ``String`` argument to sign your card, such as ``"From Emma"``.

   .. code:: prettyprint

      GreetingText(message = "Happy Birthday Sam!", from = "From Emma")

   7. Notice the preview.

   |8d148222c669dcad.png|

   A composable function might describe several UI elements. However, if you don't provide guidance
   on how to arrange them, Compose might arrange the elements in a way that you don't like. For
   example, the previous code generates two text elements that overlap each other because there's no
   guidance on how to arrange the two composables.

   In your next task, you will learn how to arrange the composables in a row and in a column.


8. Arrange the text elements in a row and column
------------------------------------------------


UI Hierarchy

   The UI hierarchy is based on containment, meaning one component can contain one or more
   components, and the terms parent and child are sometimes used. The context here is that the
   parent UI elements contain children UI elements, which in turn can contain children UI elements.
   In this section, you will learn about ``Column``, ``Row``, and ``Box`` composables, which can act
   as parent UI elements.

   ::

      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      â”‚ Parent            â”‚
      â”‚                   â”‚
      â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
      â”‚ â”‚               â”‚ â”‚
      â”‚ â”‚     Child     â”‚ â”‚
      â”‚ â”‚               â”‚ â”‚
      â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   The three basic, standard layout elements in Compose are
   `Column <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Column(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,kotlin.Function1)>`__,
   `Row <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Row(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,kotlin.Function1)>`__,
   and `Box <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1)>`__
   composables. You learn more about the ``Box`` composable in the next codelab.

   ::

      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      â”‚                   â”‚
      â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
      â”‚ â”‚               â”‚ â”‚
      â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚    â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®  â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®  â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®  â”‚
      â”‚ â”‚               â”‚ â”‚    â”‚  â”‚        â”‚  â”‚        â”‚  â”‚        â”‚  â”‚
      â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚    â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯  â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯  â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯  â”‚
      â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      â”‚ â”‚               â”‚ â”‚
      â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
      â”‚                   â”‚
      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
            Column                             Row

   ``Column``, ``Row``, and ``Box`` are composable functions that take composable content as
   arguments, so you can place items inside these layout elements. For example, each child element
   inside a ``Row`` composable is placed horizontally next to each other in a row.

   .. code:: prettyprint

      // Don't copy.
      Row {
          Text("First Column")
          Text("Second Column")
      }

   These text elements display next to each other on the screen as seen in this image.

   The blue borders are only for demonstration purposes and don't display.

   |7117f9998760a828.png|


Trailing lambda syntax

   Notice in the previous code snippet that curly braces are used instead of parentheses in the
   ``Row`` composable function. This is called *Trailing Lambda Syntax*. You learn about *lambdas*
   and trailing lambda syntax in detail later in the course. For now, get familiar with this
   commonly used Compose syntax.

   Kotlin offers a special syntax for passing functions as parameters to functions, when the last
   parameter is a function.


   ::

           â•­â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      fun  â”‚ name â”‚ ( â”‚ parameter1 â”‚, â”‚ parameter2 â”‚, ... â”‚  function  â”‚ ) {
           â•°â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
           â”‚ function body          â”‚
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   When you pass a function as that parameter, you can use trailing lambda syntax. Instead of
   putting the function inside the parentheses, you can place it outside the parentheses in curly
   braces. This is a recommended and common practice in Compose, so you need to be familiar with how
   the code looks.

   For example, the last parameter in the ``Row()`` composable function is the ``content``
   parameter, a function that describes the child UI elements. Suppose you wanted to create a row
   that contains three text elements. This code would work, but it's very cumbersome to use named
   parameter for the trailing lambda:

   .. code:: prettyprint

      Row(
          content = {
              Text("Some text")
              Text("Some more text")
              Text("Last text")
          }
      )

   Because the ``content`` parameter is the last one in the function signature and you pass its
   value as a lambda expression (for now, it's okay if you don't know what a lambda is, just
   familiarize yourself with the syntax), you can remove the ``content`` parameter and the
   parentheses as follows:

   .. code:: prettyprint

      Row {
          Text("Some text")
          Text("Some more text")
          Text("Last text")
      }


Arrange the text elements in a row

   In this task, you arrange the text elements in your app in a row to avoid overlap.

   1. In the ``MainActivity.kt`` file, scroll to the ``GreetingText()`` function.
   2. Add the ``Row`` composable around the text elements so that it shows a row with two text
      elements. Select the two ``Text`` composables, click on the light bulb. Select **Surround with
      widget** > **Surround with Row**.

   |7ca98d82742d60b9.png|

   |94f248eb6f802b93.png|

   Now the function should look like this code snippet:

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, from: String, modifier: Modifier = Modifier) {
          Row {
              Text(
                  text = message,
                  fontSize = 100.sp,
                  lineHeight = 116.sp,
              )
              Text(
                  text = from,
                  fontSize = 36.sp
              )
          }
      }

   3. Android Studio auto imports ``Row`` function for you. Scroll to the top and notice the import
      section. The ``import androidx.compose.foundation.layout.Row`` should have been added.
   4. Observe the updated preview in the **Design** pane. Temporarily change the font size for the
      birthday message to `30.sp <http://30.sp>`__.

   |Birthday greeting and signature are displayed next to each other in a row.|

   The preview looks much better now that there's no overlap. However, this isn't what you want
   because there's not enough room for your signature. In your next task, you arrange the text
   elements in a column to resolve this issue.


Arrange the text elements in a column

   In this task, it is your turn to change the ``GreetingText()`` function to arrange the text
   elements in a column. The preview should look like this screenshot:

   |d80295e73578e75d.png|

   Now that you've tried doing this on your own, feel free to check your code against the solution
   code in this snippet:

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, from: String, modifier: Modifier = Modifier) {
          Column {
              Text(
                  text = message,
                  fontSize = 100.sp,
                  lineHeight = 116.sp,
              )
              Text(
                  text = from,
                  fontSize = 36.sp
              )
          }
      }

   Notice the auto imported package by Android Studio:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Column

   Recollect that you need to pass the modifier parameter to the child element in the composables.
   That means you need to pass the modifier parameter to the ``Column`` composable.

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, from: String, modifier: Modifier = Modifier) {
          Column(modifier = modifier) {
              Text(
                  text = message,
                  fontSize = 100.sp,
                  lineHeight = 116.sp,
              )
              Text(
                  text = from,
                  fontSize = 36.sp
              )
          }
      }


9. Add greeting to the app
--------------------------

   Once you're happy with the preview, it's time to add the composable to your app on your device or
   emulator.

   1. In the ``MainActivity.kt`` file, scroll to the ``onCreate()`` function.
   2. Call the ``GreetingText()`` function from the ``Surface`` block.
   3. Pass the ``GreetingText()`` function, your birthday greeting and signature.

   The completed ``onCreate()`` function should look like this code snippet:

   .. code:: prettyprint

      class MainActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContent {
                  HappyBirthdayTheme {
                      // A surface container using the 'background' color from the theme
                      Surface(
                          modifier = Modifier.fillMaxSize(),
                          color = MaterialTheme.colorScheme.background
                      ) {
                          GreetingText(message = "Happy Birthday Sam!", from = "From Emma")
                      }
                  }
              }
          }
      }

   4. Build and run your app on the emulator.

   |59e9c0c6e19748ff.png|


Align greeting to the center

   1. To align the greeting in the center of the screen add a parameter called
      ``verticalArrangement`` set it to ``Arrangement.Center``. You will learn more on the
      ``verticalArrangement`` in a later codelab.

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, from: String, modifier: Modifier = Modifier) {
          Column(
              verticalArrangement = Arrangement.Center,
              modifier = modifier
          ) {
              // ...
          }
      }

   2. Add ``8.dp`` padding around the column. It is a good practice to use padding values in
      increments of ``4.dp``.

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, from: String, modifier: Modifier = Modifier) {
          Column(
              verticalArrangement = Arrangement.Center,
              modifier = modifier.padding(8.dp)
          ) {
              // ...
          }
      }

   3. To further beautify your app, align the greeting text to the center using ``textAlign``.

   .. code:: prettyprint

      Text(
          text = message,
          fontSize = 100.sp,
          lineHeight = 116.sp,
          textAlign = TextAlign.Center
      )

   |28c8e62f86323ba4.png|

   In the above screenshot, only the greeting is center aligned because of the ``textAlign``
   parameter. The signature, **From Emma** has the default alignment which is left.

   4. Add padding to the signature and align it to the right.

   .. code:: prettyprint

      Text(
          text = from,
          fontSize = 36.sp,
          modifier = Modifier
              .padding(16.dp)
              .align(alignment = Alignment.End)
      )

   |82b858f2f79ca9c4.png|


Adopt good practice

   It is a good practice to pass the modifier attribute(s) along with the modifier from the parent
   composable. Update the modifier parameter in the ``GreetingText()`` as follows:

   **onCreate()**

   .. code:: prettyprint

      Surface(
          //...
      ) {
          GreetingText(
              message = "Happy Birthday Sam!",
              from = "From Emma",
              modifier = Modifier.padding(8.dp)
          )
      }

   **GreetingText()**

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, from: String, modifier: Modifier = Modifier) {
          Column(
              verticalArrangement = Arrangement.Center,
              modifier = modifier
          ) {
              // ...
          }
      }

   Build and run your app on the emulator to see the final result.

   |2ff181d48325023c.png|


10. Get the solution code
-------------------------

   The completed ``MainActivity.kt``:

   .. code:: prettyprint

      package com.example.happybirthday

      import android.os.Bundle
      import androidx.activity.ComponentActivity
      import androidx.activity.compose.setContent
      import androidx.compose.foundation.layout.Arrangement
      import androidx.compose.foundation.layout.Column
      import androidx.compose.foundation.layout.fillMaxSize
      import androidx.compose.foundation.layout.padding
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Surface
      import androidx.compose.material3.Text
      import androidx.compose.runtime.Composable
      import androidx.compose.ui.Alignment
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.text.style.TextAlign
      import androidx.compose.ui.tooling.preview.Preview
      import androidx.compose.ui.unit.dp
      import androidx.compose.ui.unit.sp
      import com.example.happybirthday.ui.theme.HappyBirthdayTheme

      class MainActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContent {
                  HappyBirthdayTheme {
                      // A surface container using the 'background' color from the theme
                      Surface(
                          modifier = Modifier.fillMaxSize(),
                          color = MaterialTheme.colorScheme.background
                      ) {
                          GreetingText(
                              message = "Happy Birthday Sam!",
                              from = "From Emma",
                              modifier = Modifier.padding(8.dp)
                          )
                      }
                  }
              }
          }
      }

      @Composable
      fun GreetingText(message: String, from: String, modifier: Modifier = Modifier) {
          Column(
              verticalArrangement = Arrangement.Center,
              modifier = modifier
          ) {
              Text(
                  text = message,
                  fontSize = 100.sp,
                  lineHeight = 116.sp,
                  textAlign = TextAlign.Center
              )
              Text(
                  text = from,
                  fontSize = 36.sp,
                  modifier = Modifier
                      .padding(16.dp)
                      .align(alignment = Alignment.End)
              )
          }
      }

      @Preview(showBackground = true)
      @Composable
      fun BirthdayCardPreview() {
          HappyBirthdayTheme {
              GreetingText(message = "Happy Birthday Sam!", from = "From Emma")
          }
      }


   The completed ``Theme.kt``:

   .. code:: kotlin

      package com.example.happybirthday.ui.theme

      import android.app.Activity
      import android.os.Build
      import androidx.compose.foundation.isSystemInDarkTheme
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.darkColorScheme
      import androidx.compose.material3.dynamicDarkColorScheme
      import androidx.compose.material3.dynamicLightColorScheme
      import androidx.compose.material3.lightColorScheme
      import androidx.compose.runtime.Composable
      import androidx.compose.runtime.SideEffect
      import androidx.compose.ui.graphics.toArgb
      import androidx.compose.ui.platform.LocalContext
      import androidx.compose.ui.platform.LocalView
      import androidx.core.view.WindowCompat

      private val DarkColorScheme = darkColorScheme(
         primary = dark_primary,
         secondary = dark_secondary,
         tertiary = dark_tertiary
      )

      private val LightColorScheme = lightColorScheme(
         primary = light_primary,
         secondary = light_secondary,
         tertiary = light_tertiary
      )

      @Composable
      fun HappyBirthdayTheme(
         darkTheme: Boolean = isSystemInDarkTheme(),
         // Dynamic color is available on Android 12+
         dynamicColor: Boolean = true,
         content: @Composable () -> Unit
      ) {
         val colorScheme = when {
            dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
                  val context = LocalContext.current
                  if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
            }

            darkTheme -> DarkColorScheme
            else -> LightColorScheme
         }
         val view = LocalView.current
         if (!view.isInEditMode) {
            SideEffect {
                  val window = (view.context as Activity).window
                  window.statusBarColor = colorScheme.primary.toArgb()
                  WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = darkTheme
            }
         }

         MaterialTheme(
            colorScheme = colorScheme,
            typography = Typography,
            content = content
         )
      }


   The completed ``Type.kt``:

   .. code:: kotlin

      package com.example.happybirthday.ui.theme

      import androidx.compose.material3.Typography
      import androidx.compose.ui.text.TextStyle
      import androidx.compose.ui.text.font.FontFamily
      import androidx.compose.ui.text.font.FontWeight
      import androidx.compose.ui.unit.sp

      // Set of Material typography styles to start with
      val Typography = Typography(
         bodyLarge = TextStyle(
            fontFamily = FontFamily.Default,
            fontWeight = FontWeight.Normal,
            fontSize = 16.sp,
            lineHeight = 24.sp,
            letterSpacing = 0.5.sp
         )
      )


   The completed ``Color.kt``:

   .. code:: kotlin

      package com.example.happybirthday.ui.theme

      import androidx.compose.ui.graphics.Color

      val light_primary = Color(0xFFD0BCFF)
      val light_secondary = Color(0xFFCCC2DC)
      val light_tertiary = Color(0xFFEFB8C8)

      val dark_primary = Color(0xFF6650a4)
      val dark_secondary = Color(0xFF625b71)
      val dark_tertiary = Color(0xFF7D5260)


11. Conclusion
--------------

   You created your Happy Birthday app.

   In the next codelab, you add a picture to your app, and change the alignment of the text elements
   to beautify it.


Summary

   -  Jetpack Compose is a modern toolkit for building Android UI. Jetpack Compose simplifies and
      accelerates UI development on Android with less code, powerful tools, and intuitive Kotlin
      APIs.
   -  The user interface (UI) of an app is what you see on the screen: text, images, buttons, and
      many other types of elements.
   -  Composable functions are the basic building block of Compose. A composable function is a
      function that describes some part of your UI.
   -  The Composable function is annotated with the ``@Composable`` annotation; this annotation
      informs the Compose compiler that this function is intended to convert data into UI.
   -  The three basic standard layout elements in Compose are ``Column``, ``Row,`` and ``Box``. They
      are Composable functions that take Composable content, so you can place items inside. For
      example, each child within a ``Row`` will be placed horizontally next to each other.


Learn more

   -  `Composable <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/Composable>`__
   -  `Compose layout basics <https://developer.android.google.cn/jetpack/compose/layouts/basics>`__
   -  `Pixel density <https://m3.material.io/foundations/layout/understanding-layout/spacing#28f7a086-b6f7-4120-b18f-02a5fa5adbb5>`__
   -  `Text in Compose <https://developer.android.google.cn/jetpack/compose/text>`__
   -  `Kotlin for Jetpack Compose <https://developer.android.google.cn/jetpack/compose/kotlin>`__


.. |2ff181d48325023c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/2ff181d48325023c.png
.. |b17b607847b0d0ab.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/b17b607847b0d0ab.png
.. |fd26b2e3c2870c3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/fd26b2e3c2870c3.png
.. |d8299bfc1a82cd57.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/d8299bfc1a82cd57.png
.. |9a2df39af4122803.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/9a2df39af4122803.png
.. |50a9b402fd9037c0.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/50a9b402fd9037c0.png
.. |17794ea52cfb5473.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/17794ea52cfb5473.png
.. |showing recommended apps| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/dcb5e11ef39aa76d.png
.. |f3835a9ffa17a7c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/f3835a9ffa17a7c.png
.. |Android studio screenshot showing code and preview| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/c7165115f8a9e40b.png
.. |e3845e0f058aede9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/e3845e0f058aede9.png
.. |28a8df85bf4e80e6.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/28a8df85bf4e80e6.png
.. |895f8d3a229c287a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/895f8d3a229c287a.png
.. |2bb27291fa8c8ecc.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/2bb27291fa8c8ecc.png
.. |86a1dd28a40dea11.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/86a1dd28a40dea11.png
.. |907e7542c84daf9f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/907e7542c84daf9f.png
.. |9634619e59248532.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/9634619e59248532.png
.. |334688e2e89fb19e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/334688e2e89fb19e.png
.. |ba6c753d4eefd1d5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/ba6c753d4eefd1d5.png
.. |e073e9d3465e080c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/e073e9d3465e080c.png
.. |3bf48548c10f4ea.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/3bf48548c10f4ea.png
.. |ef457e9b19d4d495.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/ef457e9b19d4d495.png
.. |8d148222c669dcad.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/8d148222c669dcad.png
.. |7117f9998760a828.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/7117f9998760a828.png
.. |function parameter is the last parameter| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/6373d65802273065.png
.. |7ca98d82742d60b9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/7ca98d82742d60b9.png
.. |94f248eb6f802b93.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/94f248eb6f802b93.png
.. |Birthday greeting and signature are displayed next to each other in a row.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/665aa2f1cc85c29.png
.. |d80295e73578e75d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/d80295e73578e75d.png
.. |59e9c0c6e19748ff.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/59e9c0c6e19748ff.png
.. |28c8e62f86323ba4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/28c8e62f86323ba4.png
.. |82b858f2f79ca9c4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-text-composables/img/82b858f2f79ca9c4.png


ğŸš€ Add images to your Android app
==================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-images



1. Before you begin
-------------------


   In this codelab, you learn how to add images to your app using an ``Image`` composable.


Prerequisites

   -  Basic knowledge of how to create and run an app in Android Studio.
   -  Basic knowledge of how to add UI elements, such as text composables.


What you'll learn

   -  How to add an image or photo to your Android app.
   -  How to display an image in your app with an ``Image`` composable.
   -  Best practices using ``String`` resources.


What you'll build

   -  Enhance the **Happy Birthday** app to include an image.


What you'll need

   -  A computer with Android Studio installed.
   -  The app from the `Build a simple app with text composables <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-text-composables>`__
      codelab.


2. Set up your app
------------------


   Open your Happy Birthday project from the previous codelab in Android Studio.

   When you run the app, it should look like this screenshot.

   |2ff181d48325023c.png|


Add an image to your project

   In this task, you'll download an image from the internet and add it to your **Happy Birthday**
   app.

   1. Open the image for your birthday card app from this `link <https://github.com/google-developer-training/basic-android-kotlin-compose-birthday-card-app/blob/main/app/src/main/res/drawable-nodpi/androidparty.png>`__.
   2. Click **Download**.

   |1d731e32164fca8a.png|

   3. Right-click the image and then save the file to your computer as ``androidparty.png``.
   4. Make note of where you saved the image.

   For example, you may have saved it in your **Downloads** folder.

   5. In Android Studio, click **View > Tool Windows > Resource Manager** or click the **Resource
      Manager** tab next to the **Project** window.

   |318ae32952de3b49.png|

   |2703cd334049774f.png|

   **Note**: Resource Manager is a tool window that lets you import, create, manage, and use
   resources in your app.

   6. Click **+ (Add resources to the module) > Import Drawables**.

   |41054199d5299d08.png|

   7. In the file browser, select the image file that you downloaded and then click **Open**.

   This action opens the **Import drawables** dialog.

   |727d06e96adc8b19.png|

   8. Android Studio shows you a preview of the image. Select **Density** from the **QUALIFIER
      TYPE** drop-down list. You'll learn why you're doing this, in a later section.

   |c8e37d10f3afb21d.png|

   9. Select **No Density** from the **VALUE** list.

   |a8d0554a56c5a6e7.png|

   Android devices come in different screen sizes (phones, tablets, and TVs to name a few), and
   their screens also have different pixel sizes. That is, while one device has 160 pixels per
   square inch, another device fits 480 pixels in the same space. If you don't consider these
   variations in pixel density, the system might scale your images, which could result in blurry
   images, or large images that consume too much memory, or images that are sized improperly.

   When you resize images that are larger than the Android system can handle, an out-of-memory error
   is thrown. For photographs and background images, such as the current image, the
   ``androidparty.png``, you should place them in the ``drawable-nodpi`` folder, which stops the
   resizing behavior.

   For more information about pixel densities, see `Support different pixel densities <https://developer.android.google.cn/training/multiscreen/screendensities>`__.

   10. Click **Next**.
   11. Android Studio shows you the folder structure in which your image will be placed. Notice the
       ``drawable-nodpi`` folder.
   12. Click **Import(C)**.

   |6fbeec4f4d4fa984.png|

   Android Studio creates a ``drawable-nodpi`` folder and places your image in it. In the Android
   Studio project view, the resource name is displayed as ``androidparty.png (nodpi)``. In the
   computer file system, Android Studio would have created a folder called ``drawable-nodpi``.

   |It is placed under the folder drawable no dpi|

   If the image is imported successfully, Android Studio adds the image to the list under the
   **Drawable** tab. This list includes all your images and icons for the app. You can now use this
   image in your app.

   |305e34085badab89.png|

   13. Switch back to the project view, click **View > Tool Windows > Project** or click the
       **Project** tab on the far left.
   14. Click **app > res > drawable** to confirm that the image is in the ``drawable`` folder.

   |9ace033108aa748a.png|


3. Add an Image composable
--------------------------


   To display an image in your app, it needs a place to be displayed. Just like you use a ``Text``
   composable to display text, you can use an ``Image`` composable to display an image.

   In this task, you add an ``Image`` composable to your app, set its image to the image that you
   downloaded, position it and adjust its size so that it fills the screen.


Add a composable function to add an image

   1. In the ``MainActivity.kt`` file, add a ``GreetingImage()`` composable function after the
      ``GreetingText()`` function.
   2. Pass the ``GreetingImage()`` function two ``String`` parameters: one called ``message`` for
      the birthday greeting and the other called ``from`` for your signature.

   .. code:: prettyprint

      @Composable
      fun GreetingImage(message: String, from: String) {
      }

   3. Every composable function should accept an optional ``Modifier`` parameter. Modifiers tell a
      UI element how to lay out, display, or behave within its parent layout. Add another parameter
      at the ``GreetingImage()`` composable.

   .. code:: prettyprint

      @Composable
      fun GreetingImage(message: String, from: String, modifier: Modifier = Modifier) {
      }


Resources in Jetpack Compose

   Resources are the additional files and static content that your code uses, such as bitmaps,
   user-interface strings, animation instructions, and more. For more information about resources in
   Android, see `App resources overview <https://developer.android.google.cn/guide/topics/resources/providing-resources>`__.

   You should always separate app resources, such as images and strings, from your code so that you
   can maintain them independently. At runtime, Android uses the appropriate resource based on the
   current configuration. For example, you might want to provide a different UI layout based on the
   screen size or different strings based on the language setting.


Grouping resources

   You should always place each type of resource in a specific subdirectory of your project's
   ``res/`` directory. For example, here's the file hierarchy for a simple project:

   .. code:: prettyprint

      MyProject/
          src/
              MyActivity.kt
          res/
              drawable/
                  graphic.png
              mipmap/
                  icon.png
              values/
                  strings.xml

   As you can see in this example, the ``res/`` directory contains all the resources in
   subdirectories, which includes a ``drawable/`` directory for an image resource, a ``mipmap/``
   directory for launcher icons, and a ``values/`` directory for string resources. To learn more
   about the usage, format, and syntax for app resources, see `Resource types overview <https://developer.android.google.cn/guide/topics/resources/available-resources>`__.


Accessing resources

   Jetpack Compose can access the resources defined in your Android project. Resources can be
   accessed with resource IDs that are generated in your project's ``R`` class.

   An ``R`` class is an automatically generated class by Android that contains the IDs of all
   resources in the project. In most cases, the resource ID is the same as the filename. For
   example, the image in the previous file hierarchy can be accessed with this code:

   .. code:: prettyprint

         â•­â”€â”€ Auto generated R class
         â”‚    â•­â”€â”€ subfolder in res folder
         â”‚    â”‚       â•­â”€â”€ Resource ID (mostly same as filename)
         R.drawable.graphic

   R is a autogenerated class, drawable is a sub directory in res folder, graphic is resource ID.

   In the next task, you use the image, **``androidparty.png``** file, which you added in the
   previous task.

   1. In the ``GreetingImage()`` function, declare a ``val`` property and name it ``image``.
   2. Make a call to `painterResource() <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/res/package-summary#painterResource(kotlin.Int)>`__
      function by passing in the ``androidparty`` resource. Assign the returned value to the
      ``image`` variable.

   .. code:: prettyprint

      val image = painterResource(R.drawable.androidparty)

   Android Studio highlights the ``painterResource`` code because you need to import the function
   to compile your app.

   |c00b0257f932d39e.png|

   3. Click ``.painterResource`` which is highlighted by Android Studio.
   4. Click **Import** in the popup to add the import for
      ``androidx.compose.ui.res.painterResource``.

   The `painterResource() <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/res/package-summary#painterResource(kotlin.Int)>`__
   function loads a drawable image resource and takes resource ID (``R.drawable.androidparty`` in
   this case) as an argument.

   3. After the call to the `painterResource() <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/res/package-summary#painterResource(kotlin.Int)>`__
      function, add an ``Image`` composable and then pass in the ``image`` as a named argument for
      the ``painter``.

   .. code:: prettyprint

      Image(
          painter = image
      )

   Android Studio highlights the ``Image`` code because you need to import the function to compile
   your app.

   |2922caef87be79f.png|

   To fix this warning, add the following import at the top of your ``MainActivity.kt`` file:

   .. code:: prettyprint

      import androidx.compose.foundation.Image

   The initial warning is now resolved but if you hover over the word ``Image``, Android Studio
   displays a new warning that states, "None of the following functions can be called with the
   arguments supplied." This is because the provided argument does not match any of the ``Image``
   function signatures.

   |8b7c2d29c614414f.png|

   This warning will be fixed in the next section.


Check your app for accessibility

   When you follow coding practices for accessibility, you let all of your users, including those
   with `disabilities <https://developer.android.google.cn/guide/topics/ui/accessibility>`__, 
   more easily navigate, and interact with, your app.

   **Note:** Android provides many tools for users. For example,
   `TalkBack <https://support.google.com/accessibility/android/answer/6283677>`__ is the Google
   screen reader included on Android devices. TalkBack gives users spoken feedback so that users can
   use their device without looking at the screen. To learn more about accessibility, 
   see `Build accessible apps <https://developer.android.google.cn/guide/topics/ui/accessibility/>`__.

   Android Studio provides hints and warnings to help you make your app more accessible. A content
   description defines the purpose of a UI element, which makes your app more usable with TalkBack.

   However, the image in this app is only included for decorative purposes. The addition of a
   content description for the image would make it harder to use with TalkBack in this particular
   case. Instead of setting the content description that's announced to the user, you can set the
   image's ``contentDescription`` argument to ``null`` so that TalkBack skips the ``Image``
   composable.

   -  In the ``Image`` composable, add another named argument called ``contentDescription`` and set
      its value to ``null``.

   .. code:: prettyprint

      Image(
          painter = image,
          contentDescription = null
      )


Preview the ``Image`` composable

   In this task, you preview the image composable and run the app on an emulator or device.

   1. In the ``BirthdayCardPreview()`` function, replace the ``GreetingText()`` function call with a
      ``GreetingImage()`` function call.

   Your function should look like this code snippet:

   .. code:: prettyprint

      @Preview(showBackground = true)
      @Composable
      fun BirthdayCardPreview() {
          HappyBirthdayTheme {
              GreetingImage(
                  message = "Happy Birthday Sam!",
                  from = "From Emma"
              )
          }
      }

   2. The **Design** pane should auto update, if it doesn't, click |609ccb451d05cf6b.png| to build.

   Notice that you can't see the text anymore because the new function only has an ``Image``
   composable, but not a ``Text`` composable.

   |acd47e25eb2a8d55.png|


4. Add Box layout
-----------------


   The three basic, standard layout elements in Compose are
   `Column <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Column(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,kotlin.Function1)>`__,
   `Row <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Row(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,kotlin.Function1)>`__,
   and `Box <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1)>`__
   composables. You learned about `Column <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Column(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,kotlin.Function1)>`__
   and `Row <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Row(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,kotlin.Function1)>`__
   composables in the previous codelabs, now you will explore more about the ``Box`` composable.

   `Box <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Box(androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Boolean,kotlin.Function1)>`__
   layout is one of the standard layout elements in Compose. Use ``Box`` layout to stack elements on
   top of one another. ``Box`` layout also lets you configure the specific alignment of the elements
   that it contains.

   |4d191637aaecf374.png|

   1. In the ``GreetingImage()`` function, add a ``Box`` composable around the ``Image`` composable
      as shown:

   .. code:: prettyprint

      @Composable
      fun GreetingImage(message: String, from: String, modifier: Modifier = Modifier) {
          val image = painterResource(R.drawable.androidparty)
          Box {
              Image(
                  painter = image,
                  contentDescription = null
              )
          }
      }

   2. Import the ``androidx.compose.foundation.layout.Box`` function when prompted by Android
      Studio.
   3. Add code to pass the ``modifier`` parameter to the ``Box`` composable.

   .. code:: prettyprint

      @Composable
      fun GreetingImage(message: String, from: String, modifier: Modifier = Modifier) {
          val image = painterResource(R.drawable.androidparty)
          Box(modifier) {
              Image(
                  painter = image,
                  contentDescription = null
              )
          }
      }

   4. At the end of the ``Box`` composable, call the ``GreetingText()`` function, and pass it the
      birthday message, signature, and the modifier as shown:

   .. code:: prettyprint

      @Composable
      fun GreetingImage(message: String, from: String, modifier: Modifier = Modifier) {
          val image = painterResource(R.drawable.androidparty)
          Box(modifier) {
              Image(
                  painter = image,
                  contentDescription = null
              )
              GreetingText(
                  message = message,
                  from = from,
                  modifier = Modifier
                      .fillMaxSize()
                      .padding(8.dp)
              )
          }
      }

   5. Notice the updated preview in the **Design** pane.

   You should see the text and image.

   |The background image is anchored to the top|

   6. To make the above changes reflect in the emulator or a device, in the ``onCreate()`` function,
      replace the ``GreetingText()`` function call with a ``GreetingImage()`` function call.

   Your ``setContent`` block should look like this code snippet:

   .. code:: prettyprint

      setContent {
          HappyBirthdayTheme {
              // A surface container using the 'background' color from the theme
              Surface(
                  modifier = Modifier.fillMaxSize(),
                  color = MaterialTheme.colorScheme.background
              ) {
                  GreetingImage(
                      message = "Happy Birthday Sam!",
                      from = "From Emma"
                  )
              }
          }
      }

   Notice that the image is as wide as the screen, but the image is anchored to the top of the
   screen. There's whitespace at the bottom of the screen that doesn't look very attractive. In your
   next task, you will fill the width and height of the screen, and scale the image to fill the
   entire screen.


5. Change opacity and scale the image
-------------------------------------


   In this task, you make the image full screen to beautify your app. To achieve this you use the
   ``ContentScale`` parameters.


Scale content

   You have added the image to your app and positioned the image. Now, you need to adjust the scale
   type of the image, which says how to size the image, to make it fullscreen.

   There are quite a few `ContentScale <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/layout/ContentScale>`__
   `types <https://developer.android.google.cn/jetpack/compose/graphics/images/customize#content-scale>`__
   available. You use the ``ContentScale.Crop`` parameter scaling, which scales the image uniformly
   to maintain the aspect ratio so that the width and height of the image are equal to, or larger
   than, the corresponding dimension of the screen.

   1. Add a ``ContentScale`` named argument to the image.

   .. code:: prettyprint

      Image(
          painter = image,
          contentDescription = null,
          contentScale = ContentScale.Crop
      )

   2. Import the ``androidx.compose.ui.layout.ContentScale`` interface when prompted by Android
      Studio.
   3. Check out the **Design** pane.

   The image should now fill the entire preview screen as you can see in this screenshot:

   |ae1a5ec6b294f466.png|


Change opacity

   To improve the app's contrast, change the opacity of the background image.

   Add ``alpha`` parameter to the ``Image`` composable and set it to ``0.5F``.

   .. code:: prettyprint

      Image(
          painter = image,
          contentDescription = null,
          contentScale = ContentScale.Crop,
          alpha = 0.5F
      )

   Notice the change in image opacity.

   ====================== ======================
   |951cdc313bfd120d.png| |9aa0a40888ce93ff.png|
   ====================== ======================

   That's a lot of code! It's time to preview all your hard work.


Run the app

   Run the app on a device or emulator.

   |9d1416521733e8c.png|

   Good job with the full-screen image and text message. You have also changed the opacity of the
   image.


Layout Modifiers

   Modifiers are used to decorate or add behavior to Jetpack Compose UI elements. For example, you
   can add backgrounds, padding or behavior to rows, text, or buttons. To set them, a composable or
   a layout needs to accept a modifier as a parameter.

   In a previous codelab, you learned about modifiers and used the padding modifier
   (``Modifier.padding``) to add space around ``Text`` composable. Modifiers can do a lot and you
   will see that in this and upcoming pathways.

   For example, this ``Text`` composable has a ``Modifier`` argument that changes the background
   color to green.

   .. code:: prettyprint

      // Example
      Text(
          text = "Hello, World!",
          // Solid element background color
          modifier = Modifier.background(color = Color.Green)
      )

   Similar to the above example, you can add Modifiers to layouts to position the child elements
   using arrangement and alignment properties.

   To set children's position within a `Row <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Row(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,kotlin.Function1)>`__,
   set the ``horizontalArrangement`` and ``verticalAlignment`` arguments. For a `Column <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Column(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,kotlin.Function1)>`__,
   set the ``verticalArrangement`` and ``horizontalAlignment`` arguments.

   The arrangement property is used to arrange the child elements when the size of the layout is
   larger than the sum of its children.

   For example: when the size of the `Column <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Column(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,kotlin.Function1)>`__
   is larger than the sum of its children sizes, a `verticalArrangement <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Column(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,kotlin.Function1)>`__
   can be specified to define the positioning of the children inside the ``Column``. Below is an
   illustration of different vertical arrangements:
   
   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/df69881d07b064d0.gif
   
      equal height, space between, space around, space evenly, top, center and bottom


   Similarly, when the size of the `Row <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Row(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,kotlin.Function1)>`__
   is larger than the sum of its children sizes, a ``horizontalArrangement`` can be specified to
   define the positioning of the children inside the ``Row``. Below is an illustration of different
   horizontal arrangements:
   
   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/c1e6c40e30136af2.gif
   
      equal weight, space between, space around, space evenly, end, center and start


   The alignment property is used to align the child elements at the start, center, or end of
   layout.


6. Align and arrange the text
-----------------------------


   In this task, you will observe the code that you have added in the previous codelab to arrange
   the text in the app.

   1. In the ``MainActivity.kt`` file, scroll to the ``GreetingText()`` function. The
      ``verticalArrangement`` property in the column is set to ``Arrangement.Center``. The text
      content will be centered on the screen thus.

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, from: String, modifier: Modifier = Modifier) {
          Column(
              verticalArrangement = Arrangement.Center,
              modifier = modifier
          ) {
              Text(
                  text = message,
                  fontSize = 100.sp,
                  lineHeight = 116.sp,
                  textAlign = TextAlign.Center
              )
              Text(
                  text = from,
                  fontSize = 36.sp,
                  modifier = Modifier
                      .padding(16.dp)
                      .align(alignment = Alignment.End)
              )
          }
      }


Padding

   A UI element wraps itself around its content. To prevent it from wrapping too tightly, you can
   specify the amount of *padding* on each side.

   ::

                                           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                  â”‚                     â”‚ 
         â”‚ Hello World! â”‚                  â”‚     Hello World!    â”‚ 
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                  â”‚                     â”‚ 
                                           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 

      ================================= ==============================
      |Text composable without padding| |Text composable with padding|
      ================================= ==============================

   Padding is used as a modifier, which means that you can apply it to any composable. For each side
   of the composable, the ``padding`` modifier takes an optional argument that defines the amount of
   padding.

   ::

                                  top
               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
               â”‚                   â”‚                    â”‚ 
               â”‚                   â”‚                    â”‚ 
               â”‚                   â”‚                    â”‚ 
               â”‚                   â”‚                    â”‚ 
      start    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Hello World! â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ end
               â”‚                   â”‚                    â”‚ 
               â”‚                   â”‚                    â”‚ 
               â”‚                   â”‚                    â”‚ 
               â”‚                   â”‚                    â”‚ 
               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 
                                 bottom

            |Diagram shows top start bottom and end padding|

   .. code:: prettyprint

      // This is an example.
      Modifier.padding(
          start = 16.dp,
          top = 16.dp,
          end = 16.dp,
          bottom = 16.dp
      )

   1. Your turn! In the ``MainActivity.kt`` file, scroll to where the ``GreetingText()`` function is
      called and notice the padding attribute.

   .. code:: prettyprint

      modifier = Modifier
          .fillMaxSize()
          .padding(8.dp)

   2. Similarly notice inside the ``GreetingText()`` function, the padding for the signature
      ``Text`` composable.

   .. code:: prettyprint

      modifier = Modifier
          .padding(16.dp)
          .align(alignment = Alignment.End)


7. Adopt good code practices
----------------------------


Translation

   When you write apps, it's important to remember that they may be translated into another language
   at some point. As you learned in an earlier codelab, a ``String`` data type is a sequence of
   characters, such as ``"Happy Birthday Sam!"``.

   A *hardcoded* string is one that's written directly in the code of your app. Hardcoded strings
   make it more difficult to translate your app into other languages and harder to reuse strings in
   different places in your app. You can extract strings into a resource file to resolve these
   issues. Instead of hardcoding strings in your code, you put the strings into a file, name the
   string resources, and use the names whenever you want to use the strings. The name stays the
   same, even if you change the string or translate it to a different language.

   1. In the ``MainActivity.kt`` file, scroll to the ``onCreate()`` function. Select the birthday
      greeting, ``Happy Birthday Sam!`` string without quotes.
   2. Click the bulb on the left side of the screen.
   3. Select **Extract string resource**.

   |bd8451ea9a2aee25.png|

   Android Studio opens the **Extract Resource** dialog. In this dialog, you can customize what your
   string resource is called and some details on how to store it. The **Resource name** field is
   where you enter what the string is going to be called. The **Resource value** field is where you
   enter the actual string itself.

   4. In the **Extract Resource** dialog, change the **Resource name** to ``happy_birthday_text``.

   String resources should have lowercase names and multiple words should be separated with an
   underscore. Leave the other settings with the defaults.

   |c110d39102e88e4.png|

   5. Click **OK**.
   6. Notice the changes in code.

   The hardcoded string is now replaced with a call to the ``getString()`` function.

   .. code:: prettyprint

      GreetingImage(
          message = getString(R.string.happy_birthday_text),
          from = "From Emma",
          modifier = Modifier.padding(8.dp)
      )

   **Note:** Some Android Studio versions replace the hardcoded string with the ``getString()``
   function. Please manually change the function to ``stringResource()`` in such cases.

   If needed, add ``import androidx.compose.ui.res.stringResource`` to the imports section.

   7. In the **Project** pane, open the **strings.xml** file from the path
      **``app > res > values > strings.xml``** and notice that Android Studio created a string
      resource called ``happy_birthday_text``.

   .. code:: prettyprint

      <resources>
          <string name="app_name">Happy Birthday</string>
          <string name="happy_birthday_text">Happy Birthday Sam!</string>
      </resources>

   The ``strings.xml`` file has a list of strings that the user sees in your app. Note that the name
   of your app is also a string resource. By putting the strings all in one place, you can more
   easily translate all the text in your app and more easily reuse a string in different parts of
   your app.

   8. Follow the same steps to extract the text for the signature ``Text`` composable, but this time
      enter ``signature_text`` in the **Resource name** field.

   Your finished file should look like this code snippet:

   .. code:: prettyprint

      <resources>
          <string name="app_name">Happy Birthday</string>
          <string name="happy_birthday_text">Happy Birthday Sam!</string>
          <string name="signature_text">From Emma</string>
      </resources>

   9. Update the ``BirthdayCardPreview()`` to use ``stringResource()`` and the extracted strings.

   .. code:: prettyprint

      @Preview(showBackground = true)
      @Composable
      fun BirthdayCardPreview() {
          HappyBirthdayTheme {
              GreetingImage(
                  message = stringResource(R.string.happy_birthday_text),
                  from = stringResource(R.string.signature_text)
              )
          }
      }

   **Note:** If Android Studio displays an "Unresolved reference: stringResource" warning message
   when hovering over ``stringResource``, you will need to add an import statement for
   ``androidx.compose.ui.res.stringResource`` in order to use the ``stringResource()`` function.

   10. Run your app again to make sure that it still works.


8. Try this challenge
---------------------


   Good job on adding the image to your app. Here's a challenge for you:

   1. Arrange or align the signature text composable so that it is aligned to the center of the
      screen.

   Here's a hint: Compose offers the ``align`` modifier to position a child composable individually,
   defying the alignment layout rules enforced by the parent layout. Chain the
   ``.align(alignment = Alignment.CenterHorizontally)`` argument with the text composable
   ``Modifier``.

   Your app should look something like this:

   |b681900fe13e5598.png|

   Here's the solution code for the ``GreetingText()`` function for your reference:

   .. code:: prettyprint

      @Composable
      fun GreetingText(message: String, from: String, modifier: Modifier = Modifier) {
          Column(
              verticalArrangement = Arrangement.Center,
              modifier = modifier
          ) {
              Text(
                  text = message,
                  fontSize = 100.sp,
                  lineHeight = 116.sp,
                  textAlign = TextAlign.Center
              )
              Text(
                  text = from,
                  fontSize = 36.sp,
                  modifier = Modifier
                      .padding(16.dp)
                      .align(alignment = Alignment.CenterHorizontally)
              )
          }
      }


9. Get the solution code
------------------------


   The solution code for the **Happy Birthday** app is on GitHub.

   GitHub is a service that lets developers manage code for their software projects. It uses Git, a
   version-control system that tracks changes made for each version of the code. If you've ever seen
   the version history of a document in `Google Docs <https://www.google.com/docs/about/>`__, you
   can see what edits were made and when they were made. Similarly, you can track the version
   history of the code in a project. This is helpful when you work on a project as an individual or
   with a team.

   GitHub also has a website that lets you view and manage your project. This GitHub link lets you
   browse the Happy Birthday project files online or download them on your computer.

   To download the code for the finished codelab, you can use this git command:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-birthday-card-app.git

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-birthday-card-app/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the downloaded repository.

   If you want to see the solution code, `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-birthday-card-app>`__.


Branches in GitHub

   Before you understand what a branch is, understand what a *repository* or repo is. A repository
   is your whole project (directories and files) that you clone (copy) on your computer. A branch is
   a version of your repository, or in other words, an independent line of development. As an
   example, in this course, the *starter* branch could be a version of your project that you used to
   build up on during codelab. The *main* or *solution* branch is the version of your project at the
   end of your codelab, containing the complete solution code.

   A repository can contain multiple branches, which means there are multiple versions of the code
   in the repository.


10. Conclusion
--------------


   You added an image to your **Happy Birthday** app, aligned the text with modifiers, followed the
   accessibility guidelines, and made it easier to translate to other languages! More importantly,
   you finished creating your own **Happy Birthday** app! Share your work on social media, and use
   the hashtag **#AndroidBasics** so we can see it!


Summary

   -  The **Resource Manager** tab in Android Studio helps you add and organize your images and
      other resources.
   -  An ``Image`` composable is a UI element that displays images in your app.
   -  An ``Image`` composable should have a content description to make your app more accessible.
   -  Text that's shown to the user, such as the birthday greeting, should be extracted into a
      string resource to make it easier to translate your app into other languages.


Learn more

   -  `Manage your app's UI resources with Resource Manager <https://developer.android.google.cn/studio/write/resource-manager>`__
   -  `Build more accessible apps <https://developer.android.google.cn/guide/topics/ui/accessibility>`__
   -  `Support different languages and cultures <https://developer.android.google.cn/training/basics/supporting-devices/languages>`__
   -  `Getting started with GitHub <https://help.github.com/en/github/getting-started-with-github>`__

.. |2ff181d48325023c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/2ff181d48325023c.png
.. |1d731e32164fca8a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/1d731e32164fca8a.png
.. |318ae32952de3b49.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/318ae32952de3b49.png
.. |2703cd334049774f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/2703cd334049774f.png
.. |41054199d5299d08.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/41054199d5299d08.png
.. |727d06e96adc8b19.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/727d06e96adc8b19.png
.. |c8e37d10f3afb21d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/c8e37d10f3afb21d.png
.. |a8d0554a56c5a6e7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/a8d0554a56c5a6e7.png
.. |6fbeec4f4d4fa984.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/6fbeec4f4d4fa984.png
.. |It is placed under the folder drawable no dpi| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/5d5eac7fd129c558.png
.. |305e34085badab89.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/305e34085badab89.png
.. |9ace033108aa748a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/9ace033108aa748a.png
.. |c00b0257f932d39e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/c00b0257f932d39e.png
.. |2922caef87be79f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/2922caef87be79f.png
.. |8b7c2d29c614414f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/8b7c2d29c614414f.png
.. |609ccb451d05cf6b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/609ccb451d05cf6b.png
.. |acd47e25eb2a8d55.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/acd47e25eb2a8d55.png
.. |4d191637aaecf374.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/4d191637aaecf374.png
.. |The background image is anchored to the top| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/fa25ed7a4b6eb4d6.png
.. |ae1a5ec6b294f466.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/ae1a5ec6b294f466.png
.. |951cdc313bfd120d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/951cdc313bfd120d.png
.. |9aa0a40888ce93ff.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/9aa0a40888ce93ff.png
.. |9d1416521733e8c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/9d1416521733e8c.png
.. |bd8451ea9a2aee25.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/bd8451ea9a2aee25.png
.. |c110d39102e88e4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/c110d39102e88e4.png
.. |b681900fe13e5598.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-images/img/b681900fe13e5598.png


ğŸš€ Practice: Compose Basics
============================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-composables-practice-problems


1. Before you begin
-------------------

   Congratulations! You built your first app and acquired knowledge of the basics of Jetpack
   Compose. Now you're ready to put what you learned into practice.

   These exercises focus on how to build apps with the UI composables that you learned. The
   exercises are inspired by real-world use cases, some of which you probably encountered before.

   These exercises provide you with resources that you need for implementation, such as images and
   strings. The string resources contain the text that's displayed in the UI. You add these strings
   to the ``strings.xml`` file and use them in your code.

   Additionally, the exercises provide you with a set of specifications, such as font size, to use
   for the text content or padding around the UI components. These specifications help you build
   consistent UIs and often guide developers to visualize and build the screens. You might encounter
   similar specifications when you work with a team for an organization.

   Some exercises might require you to use a ``Modifier``. In such cases, see the **References**
   section available for each problem, where you can find links to documentation related to the
   modifiers or properties. You can read the documentation and determine how to incorporate the
   concepts in the app. The ability to comprehend documentation is one of the important skills that
   you should develop to grow your knowledge.

   The solution code is available at the end, but try to solve the exercises before you check the
   answers. Consider the solutions as one way to implement the app. The solution code uses the basic
   composables and concepts that you learned so far. There's a lot of room for improvement, so feel
   free to experiment and try different things.

   Work through the problems at a pace that's comfortable to you. You're encouraged to take as much
   time as you need to solve each problem thoughtfully.

   Lastly, you should use Android Studio to create separate projects for these exercises.


Prerequisites

   -  Complete `Build a simple app with text composables codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-text-composables#0>`__.
   -  Complete `Add images to your Android app codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-images#0>`__.
   -  The latest version of Android Studio
   -  Basic knowledge of the Kotlin programming language
   -  Ability to create Android projects with default templates in Android Studio.
   -  Knowledge of different ``Composable`` functions, such as the ``Text``, ``Image``, ``Box``,
      ``Column``, and ``Row`` functions
   -  Knowledge of ``Modifier`` classes for UI decoration


What you'll need

   -  A computer with internet access and Android Studio installed.


2. Compose article
------------------

   The Learn Together app displays a list of articles about several Jetpack libraries. Users can
   choose the topic of their choice and learn about its latest developments.

   In this exercise, you build a screen for the app, which displays a tutorial for Jetpack Compose.
   You use the image and string resources provided in the **Resources** section for this problem.


Final screenshot

   After you finish the implementation, your design should match this screenshot:

   |c8c16974d0aef074.png|


UI specifications

   Follow this UI specification:

   |UI specification for building the Compose article screen.|

   1. Set the image to fill the entire screen's width.
   2. Set the first ``Text`` composable to a ``24sp`` font size and ``16dp`` padding (start, end,
      bottom, and top).
   3. Set the second ``Text`` composable to a default font size, ``16dp`` padding(start and end),
      and ``Justify`` text align.
   4. Set the third ``Text`` composable to a default font size, ``16dp`` padding (start, end,
      bottom, and top), and ``Justify`` text align.


Resources

   You need `this image <https://github.com/google-developer-training/basic-android-kotlin-compose-training-practice-problems/blob/main/Unit%201/Pathway%203/ComposeArticle/app/src/main/res/drawable-nodpi/bg_compose_background.png>`__
   to `import into your project <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-images#0>`__
   and these strings:

   -  ``Jetpack Compose tutorial``
   -  ``Jetpack Compose is a modern toolkit for building native Android UI. Compose simplifies and accelerates UI development on Android with less code, powerful tools, and intuitive Kotlin APIs.``
   -  ``In this tutorial, you build a simple UI component with declarative functions. You call Compose functions to say what elements you want and the Compose compiler does the rest. Compose is built around Composable functions. These functions let you define your app\'s UI programmatically because they let you describe how it should look and provide data dependencies, rather than focus on the process of the UI\'s construction, such as initializing an element and then attaching it to a parent. To create a Composable function, you add the @Composable annotation to the function name.``

   **Hint:** Which composable aligns its children vertically?


References

   -  `TextAlign.Justify property <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/text/style/TextAlign#Justify()>`__


3. Task manager
---------------

   The Task Manager app lets users manage their day-to-day tasks and check the tasks that they need
   to complete.

   In this exercise, you build a screen that users see when they complete all the tasks for a given
   day.


Final screenshot

   After you finish the implementation, your design should match this screenshot:

   |b5a2de2b0064e729.png|


UI specification

   Follow these UI specifications:

   |UI specification for task completed screen.|

   1. Center align all of the content vertically and horizontally on the screen.
   2. Set the first ``Text`` composable to a ``Bold`` font weight, ``24dp`` padding top, and ``8dp``
      padding bottom.
   3. Set the second ``Text`` composable to a ``16sp`` font size.


Resources

   `This image <https://github.com/google-developer-training/basic-android-kotlin-compose-training-practice-problems/blob/main/Unit%201/Pathway%203/TaskCompleted/app/src/main/res/drawable/ic_task_completed.png>`__,
   which you need to download and then import into your project, and these strings:

   -  ``All tasks completed``
   -  ``Nice work!``


4. Compose quadrant
-------------------

   In this exercise, you need to apply most of the concepts that you learned so far and then go a
   step further to explore a new ``Modifier`` and properties. This might look like an extra
   challenge, but don't worry! You can check the **References** section for this problem, where you
   can find the links to these ``Modifier`` classes and properties, and use them for implementation.

   You need to build an app that displays the information about the ``Composable`` functions that
   you learned.

   The screen is divided into four quadrants. Each quadrant provides the name of a ``Composable``
   function and describes it in one sentence.


Final screenshot

   After you finish the implementation, your design should match this screenshot:

   |c0c70117bbd3b5b5.png|


UI specifications

   Follow these UI specifications for the entire screen:

   -  Divide the entire screen into four equal parts, each of which contains a Compose card and
      displays information about a ``Composable`` function.

   |5b11c91ad6a356eb.png|

   Follow these specifications for each quadrant:

   |e6befaa575985819.png|

   1. Set the entire quadrant (start, end, top, and bottom) to a ``16dp`` padding.
   2. Center align all of the content vertically and horizontally in each quadrant.
   3. Format the first ``Text`` composable in bold and set it to a ``16dp`` padding bottom.
   4. Set the second ``Text`` composable to a ``Default`` font size.


Resources

   These colors:

   -  ``Color(0xFFEADDFF)``
   -  ``Color(0xFFD0BCFF)``
   -  ``Color(0xFFB69DF8)``
   -  ``Color(0xFFF6EDFF)``

   These strings:

   -  ``Text composable``
   -  ``Displays text and follows the recommended Material Design guidelines.``
   -  ``Image composable``
   -  ``Creates a composable that lays out and draws a given Painter class object.``
   -  ``Row composable``
   -  ``A layout composable that places its children in a horizontal sequence.``
   -  ``Column composable``
   -  ``A layout composable that places its children in a vertical sequence.``


References

   -  `Weight modifier function <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/RowScope#(androidx.compose.ui.Modifier).weight(kotlin.Float,kotlin.Boolean)>`__
   -  `FontWeight.Bold property <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/text/font/FontWeight#Bold()>`__
   -  `TextAlign.Justify property <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/text/style/TextAlign#Justify()>`__


5. Solution code
----------------

   -  `Compose article <https://github.com/google-developer-training/basic-android-kotlin-compose-training-practice-problems/tree/main/Unit%201/Pathway%203/ComposeArticle>`__
   -  `Task manager <https://github.com/google-developer-training/basic-android-kotlin-compose-training-practice-problems/tree/main/Unit%201/Pathway%203/TaskCompleted>`__
   -  `Compose quadrant <https://github.com/google-developer-training/basic-android-kotlin-compose-training-practice-problems/tree/main/Unit%201/Pathway%203/ComposeQuadrant>`__


.. |c8c16974d0aef074.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-composables-practice-problems/img/c8c16974d0aef074.png
.. |UI specification for building the Compose article screen.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-composables-practice-problems/img/905139e48ed11bee.png
.. |b5a2de2b0064e729.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-composables-practice-problems/img/b5a2de2b0064e729.png
.. |UI specification for task completed screen.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-composables-practice-problems/img/7c2bfe139b3ffaa9.png
.. |c0c70117bbd3b5b5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-composables-practice-problems/img/c0c70117bbd3b5b5.png
.. |5b11c91ad6a356eb.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-composables-practice-problems/img/5b11c91ad6a356eb.png
.. |e6befaa575985819.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-composables-practice-problems/img/e6befaa575985819.png


ğŸš€ Project: Create a Business Card app
=======================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-business-card


1. Before you begin
-------------------

   You apply what you learned in this unit to create your own business card app. Unlike previous
   codelabs in which you were given step-by-step instructions to follow, here you're only provided
   with guidelines and suggestions about what you can build with the concepts that you learned so
   far. You're encouraged to use your creativity to build the app independently with limited
   guidance.

   It's a challenge to build an app on your own, but don't worry because you've had enough practice!
   You can use the same skills that you learned in this new context. You can always refer to
   previous codelabs if you're unsure of how to implement certain parts of the app.

   When you build this app on your own and solve the problems that you face along the way, you learn
   faster and retain the concepts longer. As a side benefit, the app is completely customized, so
   you can personalize and showcase it to your friends and family!


Prerequisites

   -  Ability to create and run a project in Android Studio.
   -  Experience with composable functions, which includes ``Text`` and ``Image`` composables.


What you'll learn

   -  How to build simple layouts with ``Row`` and ``Column`` composables, and arrange them with
      ``horizontalAlignment`` and ``verticalArrangement`` parameters.
   -  How to customize Compose elements with a ``Modifier`` object.


What you'll build

   -  An Android app that displays a business card.


What you'll need

   -  A computer with Android Studio installed.
   -  The Android logo to display in the app, which is provided for your use in this
      `repo <https://github.com/google-developer-training/basic-android-compose-training-assets/tree/main/Unit%201/Pathway%203/Project:%20business%20card%20app>`__.

   Here's a sample of how your app might look at the end of this project:

   |c941a07bca72427f.png|


2. Build UI with composables
----------------------------


Create a low-fidelity prototype

   When you begin a project, it's useful to visualize how UI elements need to fit together on the
   screen. In professional-development work, oftentimes there are designers or design teams that
   provide developers with UI mockups, or designs, that contain exact specifications. However, if
   you don't work with a designer, you can create a low-fidelity, or low-fi, prototype on your own.
   Low-fi prototype refers to a simple model, or drawing, that provides a basic idea of what the app
   looks like.

   Surprisingly, it's common to work without a designer, which makes the ability to sketch simple UI
   mockups a handy skill for a developer. Don't worry, you don't need to be a professional designer
   or even know how to use design tools. You can simply use a pen and paper,
   `Slides <http://slides.google.com>`__, or `Drawings <https://docs.google.com/drawings/>`__ to
   help you build it.

   To create a low-fidelity prototype:

   1. On your preferred medium, add elements that make up your app. Some elements to consider
      include the Android logo, your name, title, and contact information, icons that indicate
      contact information. For example, a telephone icon indicates a phone number.
   2. Add these elements in different positions and then evaluate them visually. Don't worry about
      getting it perfect the first time. You can always settle on one design now and iteratively
      improve it later.

   **Note**: There are principles that help make design better for users, which is outside the scope
   of this project. To learn more, see `Understanding layout <https://m3.material.io/foundations/layout/understanding-layout/overview>`__.

   You may come up with a low-fi design that looks like this image:

   |33433fd75a21776.png|


Convert design into code

   To use your prototype to help translate your design into code:

   1. Identify different logical sections of the apps and draw boundaries around them. This step
      helps you divide your screen into small composables and think about the hierarchy of the
      composables.

   In this example, you can divide the screen into two sections:

   -  Logo, name, and title
   -  Contact information

   Each section can be converted into one composable. This way you are able to build your UI with
   small composable building blocks. You can arrange each of these sections with layout composables,
   such as a ``Row`` or ``Column`` composable.

   |86ba449b7f9a5866.png|

   2. For each section of the app that contains multiple UI elements, draw boundaries around them.
      These boundaries help you see how one element relates to another in the section.

   |699b66506190e912.png|

   Now it's easier to see how you can arrange ``Text``, ``Image``, ``Icon``, and other composables
   with layout composables.

   Some notes on various composables that you may use:

   ``Row`` or ``Column`` composables

   -  Experiment with various ``horizontalArrangement`` and ``verticalAlignment`` parameters in
      ``Row`` and ``Column`` composables to match the design that you have.

   ``Image`` composables

   -  Don't forget to fill in the ``contentDescription`` parameter. As mentioned in the previous
      codelab, TalkBack uses the ``contentDescription`` parameter to help with the accessibility of
      the app. If the ``Image`` composable is only used for decorative purposes or there's a
      ``Text`` element that describes the ``Image`` composable, you can set the
      ``contentDescription`` parameter to ``null``. You can also customize the size of the image by
      specifying the ``height`` and ``width`` modifiers in the ``modifier`` parameter.

   ``Icon`` composables

   -  You can use the `Icon composable <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/icons/Icons>`__
      to add `icons from Material Design <https://fonts.google.com/icons?selected=Material+Icons>`__.
      You can change the `Tint parameter <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/package-summary#Icon(androidx.compose.ui.graphics.vector.ImageVector,kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color)>`__
      to adjust the icon color to fit the style of your business card. Similar to the ``Image``
      composable, don't forget to fill in the ``contentDescription`` parameter.

   ``Text`` composables

   -  You can experiment with various values of ``fontSize``, ``textAlign``, ``color``, and
      ``fontWeight`` parameters to style your text.

   Spacing and alignment

   -  You can use ``Modifier`` arguments, such as ``padding`` and ``weight`` modifiers, to help with
      the arrangement of composables.
   -  You can also use `Spacer composable <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Spacer(androidx.compose.ui.Modifier)>`__
      to make spacing more explicit.

   Color customization

   -  You can use custom color with the ``Color`` class and the color `hex code <https://www.w3schools.com/colors/colors_hexadecimal.asp>`__ 
      (a hexadecimal way to represent a color in RGB format). For example, the green 
      color of Android has a hex code of #3DDC84. You can make your text the same 
      green color with this code:

   .. code:: prettyprint

      Text("Example", color = Color(0xFF3ddc84))

   3. Run the app in an emulator or on your Android device to ensure that it compiles.


3. Good luck!
-------------

   Hopefully, this guide inspires you to create your own business card with Compose! You can further
   customize your app with your own logo or even your own photo! After you're done, showcase your
   work with your friends and family. If you'd like to share your work on social media, use the
   hashtag #AndroidBasics.

.. |c941a07bca72427f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-business-card/img/c941a07bca72427f.png
.. |33433fd75a21776.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-business-card/img/33433fd75a21776.png
.. |86ba449b7f9a5866.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-business-card/img/86ba449b7f9a5866.png
.. |699b66506190e912.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-business-card/img/699b66506190e912.png


ğŸš€ Create an interactive Dice Roller app
=========================================



1. Before you begin
-------------------

   In this codelab, you create an interactive **Dice Roller** app that lets users tap a ``Button``
   composable to roll a dice. The outcome of the roll is shown with an ``Image`` composable on the
   screen.

   You use Jetpack Compose with Kotlin to build your app layout and then write business logic to
   handle what happens when the ``Button`` composable is tapped.


Prerequisites

   -  Ability to create and run a basic Compose app in Android Studio.
   -  Familiarity with how to use the ``Text`` composable in an app.
   -  Knowledge of how to extract text into a string resource to make it easier to translate your
      app and reuse strings.
   -  Knowledge of Kotlin programming basics.


What you'll learn

   -  How to add a ``Button`` composable to an Android app with Compose.
   -  How to add behavior to a ``Button`` composable in an Android app with Compose.
   -  How to open and modify the ``Activity`` code of an Android app.


What you'll build

   -  An interactive Android app called Dice Roller that lets users roll a dice and shows them the
      result of the roll.


What you'll need

   -  A computer with Android Studio installed.

   Here's what the app look likes when you complete this codelab:

   |3e9a9f44c6c84634.png|


2. Establish a baseline
-----------------------


Create a project

   1. In Android Studio, click **File > New > New Project**.
   2. In the **New Project** dialog, select **Empty Activity** and then click **Next**.

   |39373040e14f9c59.png|

   3. In the **Name** field, enter ``Dice Roller``.
   4. In the **Minimum SDK** field, select a minimum API level of 24 (Nougat) from the menu and then
      click **Finish**.

   |8fd6db761068ca04.png|


3. Create the layout infrastructure
-----------------------------------


Preview the project

   To preview the project:

   -  Click **Build & Refresh** in the **Split** or **Design** pane.

   |9f1e18365da2f79c.png|

   Now you should see a preview in the **Design** pane. If it looks small, don't worry because it
   changes when you modify the layout.

   |b5c9dece74200185.png|


Restructure the sample code

   You need to change some of the generated code to more closely resemble the theme of a dice roller
   app.

   As you saw in the screenshot of the final app, there's an image of a dice and a button to roll
   it. You will structure the composable functions to reflect this architecture.

   To restructure the sample code:

   1. Remove the ``GreetingPreview()`` function.
   2. Create a ``DiceWithButtonAndImage()`` function with the ``@Composable`` annotation.

   This composable function represents the UI components of the layout and also holds the
   button-click and image-display logic.

   3. Remove the ``Greeting(name: String, modifier: Modifier = Modifier)`` function.
   4. Create a ``DiceRollerApp()`` function with the ``@Preview`` and ``@Composable`` annotations.

   Because this app only consists of a button and an image, think of this composable function as the
   app itself. That's why it's called the ``DiceRollerApp()`` function.

   **``MainActivity.kt``**

   .. code:: prettyprint

      @Preview
      @Composable
      fun DiceRollerApp() {

      }

      @Composable
      fun DiceWithButtonAndImage() {

      }

   Because you removed the ``Greeting()`` function, the call to ``Greeting("Android")`` in the
   ``DiceRollerTheme()`` lambda body is highlighted red. That's because the compiler can't find a
   reference to that function anymore.

   5. Delete all of the code inside the ``setContent{}`` lambda found in the ``onCreate()`` method.
   6. In the ``setContent{}`` lambda body, call the ``DiceRollerTheme{}`` lambda and then inside the
      ``DiceRollerTheme{}`` lambda, call the ``DiceRollerApp()`` function.

   **``MainActivity.kt``**

   .. code:: prettyprint

      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          setContent {
              DiceRollerTheme {
                  DiceRollerApp()
              }
          }
      }

   7. In the ``DiceRollerApp()`` function, call the ``DiceWithButtonAndImage()`` function.

   **``MainActivity.kt``**

   .. code:: prettyprint

      @Preview
      @Composable
      fun DiceRollerApp() {
          DiceWithButtonAndImage()
      }


Add a modifier

   Compose uses a `Modifier <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier>`__
   object, which is a collection of elements that decorate or modify the behavior of Compose UI
   elements. You use this to style the UI components of the **Dice Roller** app's components.

   To add a modifier:

   1. Modify the ``DiceWithButtonAndImage()`` function to accept a ``modifier`` argument of type
      ``Modifier`` and assign it a default value of ``Modifier``.

   **``MainActivity.kt``**

   .. code:: prettyprint

      @Composable 
      fun DiceWithButtonAndImage(modifier: Modifier = Modifier) {
      }

   The previous code snippet may confuse you, so let's break it down. The function allows a
   ``modifier`` parameter to be passed in. The default value of the ``modifier`` parameter is a
   ``Modifier`` object, hence the ``= Modifier`` piece of the method signature. The default value of
   a parameter lets anyone who calls this method in the future decide whether to pass a value for
   the parameter. If they pass their own ``Modifier`` object, they can customize the behavior and
   decoration of the UI. If they choose not to pass a ``Modifier`` object, it assumes the value of
   the default, which is the plain ``Modifier`` object. You can apply this practice to any
   parameter. For more information about default arguments, see `Default arguments <https://kotlinlang.org/docs/functions.html#default-arguments>`__.

   **Note**: The ``import androidx.compose.ui.Modifier`` statement imports the
   ``androidx.compose.ui.Modifier`` package, which lets you reference the ``Modifier`` object.

   2. Now that the ``DiceWithButtonAndImage()`` composable has a modifier parameter, pass a modifier
      when the composable is called. Because the method signature for the
      ``DiceWithButtonAndImage()`` function changed, a ``Modifier`` object with the desired
      decorations should be passed in when it's called. The ``Modifier`` class is responsible for
      the decoration of, or the addition of behavior to, a composable in the ``DiceRollerApp()``
      function. In this case, there are some important decorations to add to the ``Modifier`` object
      that's passed to the ``DiceWithButtonAndImage()`` function.

   You might wonder why you should bother to pass a ``Modifier`` argument at all when there's a
   default. The reason is because composables can undergo *recomposition*, which essentially means
   that the block of code in the ``@Composable`` method executes again. If a ``Modifier`` object is
   created in a block of code, it could potentially be recreated and that isn't efficient.
   Recomposition is covered later in this codelab.

   **``MainActivity.kt``**

   .. code:: prettyprint

      DiceWithButtonAndImage(modifier = Modifier)

   3. Chain a `fillMaxSize() <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).fillMaxSize(kotlin.Float)>`__
      method onto the ``Modifier`` object so that the layout fills the entire screen.

   This method specifies that the components should fill the space available. Earlier in this
   codelab, you saw a screenshot of the final UI of the Dice Roller app. A notable feature is that
   the dice and button are centered on the screen. The `wrapContentSize() <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).wrapContentSize(androidx.compose.ui.Alignment,kotlin.Boolean)>`__
   method specifies that the available space should at least be as large as the components inside of
   it. However, because the ``fillMaxSize()`` method is used, if the components inside of the layout
   are smaller than the available space, an `Alignment <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Alignment>`__
   object can be passed to ``wrapContentSize()`` method that specifies how the components should
   align within the available space.

   **``MainActivity.kt``**

   .. code:: prettyprint

      DiceWithButtonAndImage(modifier = Modifier
          .fillMaxSize()
      )

   **Note**: The import statements for ``fillMaxSize()`` and ``wrapContentSize()`` are
   ``import androidx.compose.foundation.layout.fillMaxSize`` and
   ``import androidx.compose.foundation.layout.wrapContentSize``, respectively.

   4. Chain the ``wrapContentSize()`` method onto the ``Modifier`` object and then pass
      ``Alignment.Center`` as an argument to center the components. ``Alignment.Center`` specifies
      that a component centers both vertically and horizontally.

   **``MainActivity.kt``**

   .. code:: prettyprint

      DiceWithButtonAndImage(modifier = Modifier
          .fillMaxSize()
          .wrapContentSize(Alignment.Center)
      )

   **Note**: The import statement for the ``Alignment`` object is
   ``import androidx.compose.ui.Alignment``.


4. Create a vertical layout
---------------------------

   In Compose, vertical layouts are created with the ``Column()`` function.

   The `Column() <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Column(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,kotlin.Function1)>`__
   function is a composable layout that places its children in a vertical sequence. In the expected
   app design, you can see that the dice image displays vertically above the roll button:

   |7d70bb14948e3cc1.png|

   To create a vertical layout:

   1. In the ``DiceWithButtonAndImage()`` function, add a ``Column()`` function.

   **Note:** The import statement for the ``Column`` composable is
   ``import androidx.compose.foundation.layout.Column``.

   2. Pass the ``modifier`` argument from the ``DiceWithButtonAndImage()`` method signature to the
      ``Column()``'s modifier argument.

   The ``modifier`` argument ensures that the composables in the ``Column()`` function adhere to the
   constraints called on the ``modifier`` instance.

   3. Pass a ``horizontalAlignment`` argument to the ``Column()`` function and then set it to a
      value of ``Alignment.CenterHorizontally``.

   This ensures that the children within the column are centered on the device screen with respect
   to the width.

   **``MainActivity.kt``**

   .. code:: prettyprint

      fun DiceWithButtonAndImage(modifier: Modifier = Modifier) {
          Column (
              modifier = modifier,
              horizontalAlignment = Alignment.CenterHorizontally
          ) {}
      }


5. Add a button
---------------

   1. In the ``strings.xml`` file, add a string and set it to a ``Roll`` value.

   **``res/values/strings.xml``**

   .. code:: prettyprint

      <string name="roll">Roll</string>

   2. In the ``Column()``'s lambda body, add a ``Button()`` function.

   **Note:** The import statement for the ``Button`` composable is
   ``import androidx.compose.material3.Button``.

   3. In the ``MainActivity.kt`` file, add a ``Text()`` function to the ``Button()`` in the lambda
      body of the function.

   4. Pass the string resource ID of the ``roll`` string to the ``stringResource()`` function and
      pass the result to the ``Text`` composable.

   **``MainActivity.kt``**

   .. code:: prettyprint

      Column(
          modifier = modifier,
          horizontalAlignment = Alignment.CenterHorizontally
      ) {
          Button(onClick = { /*TODO*/ }) {
              Text(stringResource(R.string.roll))
          }
      }

   **Note**: If you autocomplete the ``Button()`` function, the ``onClick = { /*TODO*/ }`` argument
   appears. If you don't autocomplete it or Android Studio doesn't let you do so, you can implement
   this argument on your own as a placeholder.

   **Note:** The import statement for the ``stringResource`` function is
   ``import androidx.compose.ui.res.stringResource``.


6. Add an image
---------------

   Another essential component of the app is the dice image, which displays the result when the user
   taps the **Roll** button. You add the image with an ``Image`` composable, but it requires an
   image resource, so first you need to download some images provided for this app.


Download the dice images

   1. Open `this URL <https://github.com/google-developer-training/basic-android-kotlin-compose-training-dice-roller/raw/main/dice_images.zip>`__
      to download a zip file of dice images to your computer and then wait for the download to
      complete.

   Locate the file on your computer. It's likely in your **Downloads** folder.

   2. Unpack the zip file to create a new ``dice_images`` folder that contains six dice image files
      with dice values from 1 to 6.


Add the dice images to your app

   1. In Android Studio, click **View > Tool Windows > Resource Manager**.
   2. Click **+ > Import Drawables** to open a file browser.

   |12f17d0b37dd97d2.png|

   3. Find and select the six dice image folder and proceed to upload them.

   The uploaded images will appear as follows.

   |4f66c8187a2c58e2.png|

   4. Click **Next**.

   |688772df9c792264.png|

   The **Import Drawables** dialog appears and shows where the resource files go in the file
   structure.

   5. Click **Import** to confirm that you want to import the six images.

   The images should appear in the **Resource Manager** pane.

   |c2f08e5311f9a111.png|

   **Important!** You can refer to these images in your Kotlin code with their resource IDs:

   -  ``R.drawable.dice_1``
   -  ``R.drawable.dice_2``
   -  ``R.drawable.dice_3``
   -  ``R.drawable.dice_4``
   -  ``R.drawable.dice_5``
   -  ``R.drawable.dice_6``

   Nice work! In the next task, you use these images in your app.


Add an ``Image`` composable

   The dice image should appear above the **Roll** button. Compose inherently places UI components
   sequentially. In other words, whichever composable is declared first displays first. This could
   mean that the first declaration displays above, or before, the composable declared after it.
   Composables inside of a ``Column`` composable will appear above / below each other on the device.
   In this app, you use a ``Column`` to stack Composables vertically, therefore, whichever
   Composable is declared first inside the ``Column()`` function displays before the composable
   declared after it in the same ``Column()`` function.

   To add an ``Image`` composable:

   1. In the ``Column()`` function body, create an ``Image()`` function before the ``Button()``
      function.

   **``MainActivity.kt``**

   .. code:: prettyprint

      Column(
          modifier = modifier,
          horizontalAlignment = Alignment.CenterHorizontally
      ) {
          Image()
          Button(onClick = { /*TODO*/ }) {
            Text(stringResource(R.string.roll))
          }
      }

   **Note:** The import statement for the ``Image`` composable is
   ``import androidx.compose.foundation.Image``.

   2. Pass the ``Image()`` function a ``painter`` argument, and then assign it a ``painterResource``
      value that accepts a drawable resource id argument. For now, pass the following resource id:
      ``R.drawable.dice_1`` argument.

   **``MainActivity.kt``**

   .. code:: prettyprint

      Image(
          painter = painterResource(R.drawable.dice_1)
      )

   **Note:** The import statement for the ``painterResource`` function is
   ``import androidx.compose.ui.res.painterResource``.

   **Note**: Later on, you will change the value passed for the resource id. For now, it should be
   passed a default so that the code will compile for preview purposes.

   3. Any time you create an Image in your app, you should provide what is called a "content
      description." Content descriptions are an important part of Android development. They attach
      descriptions to their respective UI components to increase accessibility. For more information
      about content descriptions, see `Describe each UI element <https://developer.android.google.cn/guide/topics/ui/accessibility/apps#describe-ui-element>`__.
      You can pass a content description to the image as a parameter.

   **``MainActivity.kt``**

   .. code:: prettyprint

      Image(
          painter = painterResource(R.drawable.dice_1),
          contentDescription = "1"
      )

   **Note:** The above content description is a placeholder for the time being. This will be updated
   in a later section of this codelab.

   Now all the necessary UI components are present. But the ``Button`` and the ``Image`` are
   crowding each other a bit.

   |54b27140071ac2fa.png|

   1. To fix that, add a `Spacer <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Spacer(androidx.compose.ui.Modifier)>`__
      composable between the ``Image`` and the ``Button`` composables. A ``Spacer`` takes a
      ``Modifier`` as a parameter. In this case, the ``Image`` is above the ``Button``, so there
      needs to be a vertical space between them. Therefore, the ``Modifier``'s height can be set to
      apply to the ``Spacer``. Try setting the height to ``16.dp``. Typically, dp dimensions are
      changed in increments of ``4.dp``.

   **``MainActivity.kt``**

   .. code:: prettyprint

      Spacer(modifier = Modifier.height(16.dp))

   **Note:** The imports for the ``Spacer`` composable, modifier ``height``, and ``dp`` are:

   ``import androidx.compose.foundation.layout.height``

   ``import androidx.compose.foundation.layout.Spacer``

   ``import androidx.compose.ui.unit.dp``

   2. In the **Preview** pane, click **Build & Refresh**.

   You should see something similar to this image:

   |73eea4c166f7e9d2.png|


7. Build the dice-roll logic
----------------------------

   Now that all the necessary composables are present, you modify the app so that a tap of the
   button rolls the dice.


Make the button interactive

   1. In the ``DiceWithButtonAndImage()`` function before the ``Column()`` function, create a
      ``result`` variable and set it equal to a ``1`` value.
   2. Take a look at the ``Button`` composable. You will notice that it is being passed an
      ``onClick`` parameter which is set to a pair of curly braces with the comment ``/*TODO*/``
      inside the braces. The braces, in this case, represent what is known as a lambda, the area
      inside of the braces being the lambda body. When a function is passed as an argument, it can
      also be referred to as a "`callback <https://en.wikipedia.org/wiki/Callback_(computer_programming)>`__".

   **``MainActivity.kt``**

   .. code:: prettyprint

      Button(onClick = { /*TODO*/ })

   A lambda is a function literal, which is a function like any other, but instead of being declared
   separately with the ``fun`` keyword, it is written inline and passed as an expression. The
   ``Button`` composable is expecting a function to be passed as the ``onClick`` parameter. This is
   the perfect place to use a lambda, and you will be writing the lambda body in this section.

   3. In the ``Button()`` function, remove the ``/*TODO*/`` comment from the value of the lambda
      body of the ``onClick`` parameter.
   4. A dice roll is random. To reflect that in code, you need to use the correct syntax to generate
      a random number. In Kotlin, you can use the ``random()`` method on a number range. In the
      ``onClick`` lambda body, set the ``result`` variable to a range between 1 to 6 and then call
      the ``random()`` method on that range. Remember that, in Kotlin, ranges are designated by two
      periods between the first number in the range and the last number in the range.

   **``MainActivity.kt``**

   .. code:: prettyprint

      fun DiceWithButtonAndImage(modifier: Modifier = Modifier) {
          var result = 1
          Column(
              modifier = modifier,
              horizontalAlignment = Alignment.CenterHorizontally
          ) {
              Image(
                  painter = painterResource(R.drawable.dice_1),
                  contentDescription = "1"
              )
              Spacer(modifier = Modifier.height(16.dp))
              Button(onClick = { result = (1..6).random() }) {
                  Text(stringResource(R.string.roll))
              }
          }
      }

   Now the button is tappable, but a tap of the button won't cause any visual change yet because you
   still need to build that functionality.


Add a conditional to the dice roller app

   In the previous section, you created a ``result`` variable and hard-coded it to a ``1`` value.
   Ultimately, the value of the ``result`` variable is reset when the **Roll** button is tapped and
   it should determine which image is shown.

   Composables are stateless by default, which means that they don't hold a value and can be
   recomposed any time by the system, which results in the value being reset. However, Compose
   provides a convenient way to avoid this. Composable functions can store an object in memory using
   the ``remember`` composable.

   1. Make the ``result`` variable a ``remember`` composable.

   The ``remember`` composable requires a function to be passed.

   2. In the ``remember`` composable body, pass in a ``mutableStateOf()`` function and then pass the
      function a ``1`` argument.

   The ``mutableStateOf()`` function returns an observable. You learn more about observables later,
   but for now this basically means that when the value of the ``result`` variable changes, a
   recomposition is triggered, the value of the result is reflected, and the UI refreshes.

   **``MainActivity.kt``**

   .. code:: prettyprint

      var result by remember { mutableStateOf(1) }

   **Note**: The ``import androidx.compose.runtime.mutableStateOf`` and
   ``import androidx.compose.runtime.remember`` statements import the packages needed for the
   ``mutableStateOf()`` function and the ``remember`` composable.

   The following import statements are also needed to import necessary extension functions of State:

   ``import androidx.compose.runtime.getValue``

   ``import androidx.compose.runtime.setValue``

   Now, when the button is tapped, the ``result`` variable is updated with a random number value.

   The ``result`` variable can now be used to determine which image to show.

   3. Underneath the instantiation of the ``result`` variable, create an immutable ``imageResource``
      variable set to a ``when`` expression that accepts a ``result`` variable and then set each
      possible result to its drawable.

   **``MainActivity.kt``**

   .. code:: prettyprint

      val imageResource = when (result) {
          1 -> R.drawable.dice_1
          2 -> R.drawable.dice_2
          3 -> R.drawable.dice_3
          4 -> R.drawable.dice_4
          5 -> R.drawable.dice_5
          else -> R.drawable.dice_6
      }

   4. Change the ID passed to the ``painterResource`` parameter of the ``Image`` composable from the
      ``R.drawable.dice_1`` drawable to the ``imageResource`` variable.
   5. Change the ``contentDescription`` parameter of the ``Image`` composable to reflect the value
      of ``result`` variable by converting the ``result`` variable to a string with ``toString()``
      and passing it as the ``contentDescription``.

   **``MainActivity.kt``**

   .. code:: prettyprint

      Image(
         painter = painterResource(imageResource),
         contentDescription = result.toString()
      )

   6. Run your app.

   Your **Dice Roller** app should fully work now!

   |3e9a9f44c6c84634.png|


8. Get the solution code
------------------------

   To download the code for the finished codelab, you can use this git command:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-dice-roller.git

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-dice-roller/archive/refs/heads/main.zip>`__

   If you want to see the solution code, `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-dice-roller>`__.

   1. Navigate to the provided GitHub repository page for the project.
   2. Verify that the branch name matches the branch name specified in the codelab. For example, in
      the following screenshot the branch name is **main**.

   |1e4c0d2c081a8fd2.png|

   3. On the GitHub page for the project, click the **Code** button, which brings up a popup.

   |1debcf330fd04c7b.png|

   4. In the popup, click the **Download ZIP** button to save the project to your computer. Wait for
      the download to complete.
   5. Locate the file on your computer (likely in the **Downloads** folder).
   6. Double-click the ZIP file to unpack it. This creates a new folder that contains the project
      files.


Open the project in Android Studio

   1. Start Android Studio.
   2. In the **Welcome to Android Studio** window, click **Open**.

   |d8e9dbdeafe9038a.png|

   Note: If Android Studio is already open, instead, select the **File** > **Open** menu option.

   |8d1fda7396afe8e5.png|

   3. In the file browser, navigate to where the unzipped project folder is located (likely in your
      **Downloads** folder).
   4. Double-click on that project folder.
   5. Wait for Android Studio to open the project.
   6. Click the **Run** button |8de56cba7583251f.png| to build and run the app. Make sure it builds
      as expected.


9. Conclusion
-------------

   You created an interactive **Dice Roller** app for Android with Compose!


Summary

   -  Define composable functions.
   -  Create layouts with Compositions.
   -  Create a button with the ``Button`` composable.
   -  Import ``drawable`` resources.
   -  Display an image with the ``Image`` composable.
   -  Make an interactive UI with composables.
   -  Use the ``remember`` composable to store objects in a Composition to memory.
   -  Refresh the UI with the ``mutableStateOf()``\ function to make an observable.


Learn more

   -  `Jetpack Compose Tutorial <https://developer.android.google.cn/jetpack/compose/tutorial>`__
   -  `Add Jetpack Compose toolkit dependencies <https://developer.android.google.cn/jetpack/compose/setup#compose-compiler>`__
   -  `Get started with Jetpack Compose <https://developer.android.google.cn/jetpack/compose/documentation>`__
   -  `Basics of Composable functions <https://developer.android.google.cn/jetpack/compose/layouts/basics#composable-functions>`__
   -  `Button composable <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Button(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.material3.ButtonColors,androidx.compose.material3.ButtonElevation,androidx.compose.foundation.BorderStroke,androidx.compose.foundation.layout.PaddingValues,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function1)>`__
   -  `Image composable <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/package-summary#Image(androidx.compose.ui.graphics.ImageBitmap,kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,androidx.compose.ui.layout.ContentScale,kotlin.Float,androidx.compose.ui.graphics.ColorFilter,androidx.compose.ui.graphics.FilterQuality)>`__
   -  `State and Jetpack Compose <https://developer.android.google.cn/jetpack/compose/state>`__

.. |3e9a9f44c6c84634.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/3e9a9f44c6c84634.png
.. |39373040e14f9c59.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/39373040e14f9c59.png
.. |8fd6db761068ca04.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/8fd6db761068ca04.png
.. |9f1e18365da2f79c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/9f1e18365da2f79c.png
.. |b5c9dece74200185.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/b5c9dece74200185.png
.. |7d70bb14948e3cc1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/7d70bb14948e3cc1.png
.. |12f17d0b37dd97d2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/12f17d0b37dd97d2.png
.. |4f66c8187a2c58e2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/4f66c8187a2c58e2.png
.. |688772df9c792264.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/688772df9c792264.png
.. |c2f08e5311f9a111.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/c2f08e5311f9a111.png
.. |54b27140071ac2fa.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/54b27140071ac2fa.png
.. |73eea4c166f7e9d2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/73eea4c166f7e9d2.png
.. |1e4c0d2c081a8fd2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/1e4c0d2c081a8fd2.png
.. |1debcf330fd04c7b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/1debcf330fd04c7b.png
.. |d8e9dbdeafe9038a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/d8e9dbdeafe9038a.png
.. |8d1fda7396afe8e5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/8d1fda7396afe8e5.png
.. |8de56cba7583251f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app/img/8de56cba7583251f.png


ğŸš€ Use the debugger in Android Studio
======================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-intro-debugger


1. Before you begin
-------------------

   This codelab teaches you how to use the debugger in Android Studio to inspect what happens in the
   Dice Roller app at runtime.

   The debugger is an essential tool that lets you inspect the execution of the code that powers
   your Android app so that you can fix any bugs in it. It lets you specify points at which to
   suspend the execution of the code and manually interact with variables, methods, and other
   aspects of the code.


Prerequisites

   -  Basic familiarity with Android Studio
   -  Ability to create and run a basic Jetpack Compose app in Android Studio
   -  Completion of the `Create an interactive Dice Roller App codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app>`__


What you'll learn

   -  How to attach the debugger to an Android app.
   -  How to launch an app with the debugger attached.
   -  How to use some fundamental features of the debugger.
   -  What the debugger is typically used for.


What you'll need

   -  A computer with Android Studio installed
   -  The solution code for the Dice Roller app in Compose


2. Watch the code-along video (Optional)
----------------------------------------

   If you'd like to watch one of the course instructors complete the codelab, play the below video.

   It's recommended to expand the video to full screen (with this icon |This symbol shows 4 corners
   on a square highlighted, to indicate full screen mode.| in the lower right corner of the video)
   so you can see Android Studio and the code more clearly.

   This step is optional. You can also skip the video and start the codelab instructions right away.


3. Get the starter code
-----------------------

   To get started, download the code:

   `Download Zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-dice-roller/archive/refs/heads/main.zip>`__

   Alternatively, you can clone the Github repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-dice-roller.git
      $ cd basic-android-kotlin-compose-training-dice-roller

   **Note:** The starter code is on the ``main`` branch of the downloaded repository.

   You can browse the code in the `GitHub repository <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-dice-roller>`__.


4. Run the debugger
-------------------

   There are two ways to run the debugger alongside your app:

   -  Attach the debugger to an existing app process that runs on a device or emulator.
   -  Run the app with the debugger.

   Both ways accomplish the same thing to a certain extent. Once you're familiar with both ways, you
   can pick the one that you prefer or whichever one is required.


Attach the debugger to an app process

   If your app is already running, you can attach the debugger to it.

   To attach the debugger to an app process, follow these steps:

   1. Click |608818eddd06d35d.png| **Attach Debugger to Android Process**.

   |9bd4c917bad56baa.png|

   A **Choose Process** dialog opens in which you can choose the process to which you want to attach
   the debugger.

   2. Select **``com.example.diceroller``** and then click **OK**.

   |a4c65b5bc972bd46.png|

   A **Debug** pane appears at the bottom of Android Studio with a message that indicates that the
   debugger is attached to the target device or emulator.

   |adad34e172cbc49a.png|

   You attached the debugger to your app! Don't worry about what this means or what you can do with
   the debugger because that's covered later in this codelab. Next, you learn how to launch an app
   with the debugger already attached.


Run the app **with the debugger**

   If you know that you want to use the debugger from the start, you can save time when you run the
   app with the debugger. Furthermore, if you want to debug code that only runs when the app
   launches, you need to launch the app with the debugger already attached.

   To run the app with the debugger, follow these steps:

   1. In the **Debug** pane, click |ca283f38f21b0cb7.png| **Stop**, and then close the app on the
      device or emulator.

   |3c82e7f80c6c174d.png|

   2. Click |67f9548b52d797b7.png| **Debug â€˜app'**.

   |cbf915fde4e6b443.png|

   The same **Debug** pane appears at the bottom of Android Studio with some console output.

   |f69e0370c2b5ad0e.png|

   Now you know how to launch the debugger! Next, you learn how to use it.


5. Use the debugger
-------------------


The **Debug** **pane**

   You likely noticed that there are quite a few buttons across the top of the **Debug** pane, but
   these buttons don't mean much right now, and most are grayed out and unclickable. This section
   covers the more-commonly used features found in the debugger. This codelab explains the other
   buttons as they become relevant.

   When you first launch the debugger, you see a number of buttons in the **Debug** pane. At the top
   of the **Debug** pane, you see the **Debugger** and **Console** buttons.

   |5f35f4c555240598.png|

   The **Console** button displays the logcat output of the app. If you have any log statements in
   your code, the output displays as that piece of code executes.

   The **Debugger** button displays three separate panes, which are empty right now because you
   aren't using the debugger:

   1. Frames display
   2. Evaluation and watch expression entry
   3. Variables pane

   |3752c14cdd27b8c4.png|


Use common debugger features

Set a breakpoint

   One of the main features of the debugger is that it lets you stop execution on a specific line of
   code with a breakpoint.

   To set a breakpoint in Android Studio, you need to navigate to a specific line of code and then
   click in the gutter next to the line number. To unset a breakpoint, you need to click an existing
   breakpoint in the gutter to make it disappear.

   -  To try it yourself, set a breakpoint where the ``imageResource`` variable is set.

   |Add and remove a breakpoint|


Use the Resume Program **button**

   In the last section, you set a breakpoint where the ``imageResource`` variable is set. This
   breakpoint causes the execution to suspend upon this instruction. When code execution is
   suspended with the debugger, you likely need to continue execution to continue running the app.
   The most direct way to do this is to use the **Resume Program** button.

   To resume the program, follow these steps:

   1. Click |67f9548b52d797b7.png| **Debug â€˜app'**. You should see something like this image after
      the app launches:

   |c8a1660c4209458c.png|

   Before you resume the program, it's important to explain some of what you see on the screen when
   the debugger suspends execution:

   -  Many of the buttons in the **Debug** pane are now clickable.
   -  The **Frames** pane displays a lot of information, which includes a highlighted reference to
      the line where the breakpoint was set.
   -  The **Variables** pane displays a number of items, but this app doesn't have many variables so
      there isn't a lot of information that is relevant in the scope of this codelab at the moment.
      However, the ability to inspect variables is an essential feature of the debugger because it
      yields insight into what happens in the code at runtime. This codelab goes into more detail
      about how to inspect variables later.

   If you look at the app on your device or emulator, you notice that the screen is blank because
   the app is suspended on a line of code. More specifically, execution stopped at the breakpoint
   and the UI hasn't yet rendered.

   Bear in mind that the app won't always stop immediately only because a breakpoint was set. It
   depends on where you place a breakpoint in the code. In this case, you placed it on a line that
   executes when the app starts.

   The key thing to remember is that the app only suspends at a breakpoint when an attempt to
   execute the line at which the breakpoint was set occurs. There are multiple ways to move the
   debugger forward, but for now you use the **Resume Program** button.

   2. Click |937f070d95764107.png| **Resume Program**.

   |7d664cd5dd8a2d9b.png|

   You should now see something that looks like this image:

   |388c58b0f31f797e.png|

   The majority of the information disappears and the buttons are once again unclickable. The app
   also appears as normal on your device or emulator. The reason for this is that the code is no
   longer suspended at the breakpoint and the app is in a normal running state. The debugger is
   attached, but it doesn't do much until there's an attempt to execute a line of code that has a
   breakpoint set. Leave this breakpoint in place because it's useful in the following examples.


Use the Step Into **button**

   The **Step Into** button of the debugger is a handy way to drill deeper into the code at runtime.
   If an instruction makes a call to a method or another piece of code, the **Step Into** button
   lets you enter the code without the need to navigate there manually before you launch the
   debugger to set a breakpoint.

   To use the **Step Into** button, follow these steps:

   1. Create a breakpoint in the ``setContent`` lambda body in the ``onCreate()`` function of the
      ``MainActivity`` class where the ``DiceRollerApp()``\ function is called.

   |aa4337eabccc85d.png|

   2. Click |67f9548b52d797b7.png| **Debug â€˜app'** to rerun the app with the debugger. The execution
      suspends at the line where the ``DiceRollerApp()`` function is called.
   3. Click |1e7236e85d113e8f.png| **Step Into**.

   |73a80d2b10caea5f.png|

   Now line 40 is highlighted and the **Frames** pane in the **Debug** pane indicates that the code
   is suspended on line 40.

   |ece32a03703a0531.png|

   If you expand the **Frames** pane, you can see that the line after the highlighted line starts
   with ``invoke:`` followed by a line number, which is 32 in the previous image. This is what is
   referred to as the *call stack*. Essentially, it shows the chain of calls that lead the code
   execution to the current line. In this case, line 32 holds an instruction that calls the
   ``DiceRollerApp()`` function.

   When you clicked the **Step Into** button when the debugger stopped at the breakpoint set on that
   function call, the debugger *stepped into* that function, which leads the execution to line 40
   where the function is declared. The highlighted line indicates where the execution is suspended.
   If the lines after the highlighted line have line numbers associated with them, it's an
   indication of the path of execution. In this particular case, the debugger indicates that an
   instruction on line 32 brought you to line 40.

   4. Click |937f070d95764107.png| **Resume Program**.

   This should lead you to the original breakpoint that you set. You might understand a bit more
   about what you saw when you stopped execution in the first example. This is the same picture from
   the sixth step of the **Resume program** section:

   |76a1bef8e6cdf656.png|

   In the call stack, you can see that the ``DiceWithButtonAndImage()`` function suspended on line
   50 and the function was called from line 41 in the ``DiceRollerApp()`` function, which was called
   on line 32. The call-stack feature can help you understand the path of execution. This is very
   helpful when a function is called from many different places in the app.

   The **Step Into** button provides a way to enter a function and suspend the execution without
   setting a breakpoint in the function itself. In this case, you set a breakpoint on the call to
   the ``DiceRollerApp()`` function. When you click the **Step Into** button, the execution suspends
   in the ``DiceRollerApp()`` function.

   Dice Roller is a fairly small app because there aren't many files, classes, or functions. When
   you work with bigger apps, the **Step Into** feature of the debugger becomes more useful because
   it gives you the option to drill down into the code without the need to navigate the code on your
   own.


Use the Step Over **button**

   The **Step Over** button provides another means by which you can step through your app code at
   runtime. It moves the execution to the next line of code and advances the debugger.

   To use the **Step Over** button, follow these steps:

   -  Click |21e306488908a0f3.png| **Step Over**.

   |25b1ea30948cfc31.png|

   You now see that the debugger suspended the code on the next line of execution, which is line 51.
   You can proceed to step through each line, consecutively.

   |17e5998c76809c62.png|


Use the Step Out **button**

   The **Step Out** button does the opposite of the **Step Into** button. Rather than drill down
   into the call stack, the **Step Out** button navigates up the call stack.

   To use the **Step Out** button, follow these steps:

   1. Click |fbe8baec2ab73e94.png| **Step Out**.

   Can you guess what line the program suspends on?

   |9e7ce3969c28f091.png|

   2. Notice that the debugger stepped out of the ``DiceRollerApp()`` function and back to the line
      that called it.

   |fd19d30216463877.png|

   The **Step Out** button is a useful tool when you find yourself too deep in a method call stack.
   It lets you work your way up the call stack without the need to step through all the code for
   each method that you stepped into.


**Inspect variables**

   Earlier in the codelab, there was a brief description of the **Variables** pane, which provides a
   more in-depth explanation of how to inspect the variables shown in the pane to help you debug
   issues in your app.

   To inspect the variables, follow these steps:

   1. Click the breakpoint to remove it from where the ``DiceRollerApp()`` function is called, but
      leave the breakpoint where the ``imageResource`` variable is set.
   2. Click |67f9548b52d797b7.png| **Debug â€˜app'**. You should see that the ``result$delegate``
      variable is a ``MutableState`` with a value of 1. That is because when the variable is
      defined, it is instantiated with a ``mutableStateOf`` 1. ``MutableState`` means that the
      result variable holds a state that can be changed.

   **Note:** The ``result$delegate`` variable in the **Variables** pane refers to the ``result``
   variable in the code. The ``$delegate`` notation is there because the ``result`` variable is a
   ``remember`` delegate.

   |ac37c7436b5235c0.png|

   3. Click |937f070d95764107.png| **Resume Program**.
   4. In the app, click **Roll**. Your code suspends at the breakpoint again and you may see a
      different value for the ``result$delegate`` variable.

   In this image, the mutable state of the ``result$delegate`` variable holds a value of 2, This
   demonstrates how you can inspect variables at runtime with the debugger. In a more full-featured
   app, the value of a variable could potentially cause a crash. When you use the debugger to
   inspect variables, you can gain more insight into the details of the crash so that you can fix
   the bug.

   |a869ec4ba3b66fbf.png|


6. Conclusion
-------------

   Congratulations! You used the debugger in Android Studio.


Summary

   -  Attach the debugger to an app.
   -  Launch an app with the debugger already attached.
   -  Gain familiarity with the debugger pane.
   -  Set a breakpoint.
   -  Resume the program from the debugger.
   -  Use the **Step Into** button.
   -  Use the **Step Over** button.
   -  Use the **Step Out** button.
   -  Inspect variables with the debugger.


.. |This symbol shows 4 corners on a square highlighted, to indicate full screen mode.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/adba01179d2b6579.png
.. |608818eddd06d35d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/608818eddd06d35d.png
.. |9bd4c917bad56baa.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/9bd4c917bad56baa.png
.. |a4c65b5bc972bd46.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/a4c65b5bc972bd46.png
.. |adad34e172cbc49a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/adad34e172cbc49a.png
.. |ca283f38f21b0cb7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/ca283f38f21b0cb7.png
.. |3c82e7f80c6c174d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/3c82e7f80c6c174d.png
.. |67f9548b52d797b7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/67f9548b52d797b7.png
.. |cbf915fde4e6b443.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/cbf915fde4e6b443.png
.. |f69e0370c2b5ad0e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/f69e0370c2b5ad0e.png
.. |5f35f4c555240598.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/5f35f4c555240598.png
.. |3752c14cdd27b8c4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/3752c14cdd27b8c4.png
.. |Add and remove a breakpoint| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/4e2a6dba91f67ab1.gif
.. |c8a1660c4209458c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/c8a1660c4209458c.png
.. |937f070d95764107.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/937f070d95764107.png
.. |7d664cd5dd8a2d9b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/7d664cd5dd8a2d9b.png
.. |388c58b0f31f797e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/388c58b0f31f797e.png
.. |aa4337eabccc85d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/aa4337eabccc85d.png
.. |1e7236e85d113e8f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/1e7236e85d113e8f.png
.. |73a80d2b10caea5f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/73a80d2b10caea5f.png
.. |ece32a03703a0531.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/ece32a03703a0531.png
.. |76a1bef8e6cdf656.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/76a1bef8e6cdf656.png
.. |21e306488908a0f3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/21e306488908a0f3.png
.. |25b1ea30948cfc31.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/25b1ea30948cfc31.png
.. |17e5998c76809c62.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/17e5998c76809c62.png
.. |fbe8baec2ab73e94.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/fbe8baec2ab73e94.png
.. |9e7ce3969c28f091.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/9e7ce3969c28f091.png
.. |fd19d30216463877.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/fd19d30216463877.png
.. |ac37c7436b5235c0.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/ac37c7436b5235c0.png
.. |a869ec4ba3b66fbf.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-intro-debugger/img/a869ec4ba3b66fbf.png


ğŸš€ Practice: Click behavior
============================

   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-button-click-practice-problem


1. Before you begin
--------------------------------------------------------------------------------

   In this pathway, you learned how to add a button to an app and how to modify the app to
   respond to a button click. Now, it's time to practice what you learned by building an
   app.

   You will create an app called the Lemonade app. First, read the requirements of the
   Lemonade app to understand how the app should look and behave. If you want to challenge
   yourself, you can build the app on your own from there. If you get stuck, you can read
   subsequent sections to receive more hints and guidance about how to break down the
   problem and approach it step by step.

   Work through this practice problem at a pace that's comfortable for you. Take as much
   time as you need to build each part of the app's functionality. The solution code for
   the Lemonade app is available at the end, but it's recommended that you try to build the
   app yourself before you check the solution. Remember that the provided solution is not
   the only way to build the Lemonade app, so it's completely valid to build it a different
   way as long as the app requirements are met.


**Prerequisites**

   -  Able to create a simple UI layout in Compose with text and image composables
   -  Able to build an interactive app that responds to a button click
   -  Basic understanding of composition and recomposition
   -  Familiarity with the basics of the Kotlin programming language, including functions,
      variables, conditionals, and lambdas


**What you'll need**

   -  A computer with internet access and Android Studio installed.


2. App overview
--------------------------------------------------------------------------------

   You're going to help us bring our vision of making digital lemonade to life! The goal is
   to create a simple, interactive app that lets you juice lemons when you tap the image on
   screen until you have a glass of lemonade. Consider it a metaphor or maybe just a fun
   way to pass the time!

   |dfcc3bc3eb43e4dd.png|

   Here's how the app works:

   1. When the user first launches the app, they see a lemon tree. There's a label that
      prompts them to tap the lemon tree image to "select" a lemon from the tree.
   2. After they tap the lemon tree, the user sees a lemon. They are prompted to tap the
      lemon to "squeeze" it to make lemonade. They need to tap the lemon several times to
      squeeze it. The number of taps required to squeeze the lemon is different each time
      and is a randomly generated number between 2 to 4 (inclusive).
   3. After they've tapped the lemon the required number of times, they see a refreshing
      glass of lemonade! They are asked to tap the glass to "drink" the lemonade.
   4. After they tap the lemonade glass, they see an empty glass. They are asked to tap the
      empty glass to start again.
   5. After they tap the empty glass, they see the lemon tree and can begin the process
      again. More lemonade please!

   Here are larger screenshots of how the app looks:

   ====================== ====================== ====================== ======================
   |5384eedd313cb5a9.png| |89cec3022a462039.png| |513e4b0ee349a4d2.png| |9dbd92f4413c186e.png|
   ====================== ====================== ====================== ======================

   For each step of making lemonade, there's a different image and text label on the
   screen, and different behavior for how the app responds to a click. For example, when
   the user taps the lemon tree, the app shows a lemon.

   Your job is to build the app's UI layout and implement the logic for the user to move
   through all the steps to make lemonade.


3. Get started
--------------------------------------------------------------------------------


**Create a project**

   In Android Studio, create a new project with the **Empty Activity** template with the
   following details:

   -  Name: Lemonade
   -  Package name: com.example.lemonade
   -  Minimum SDK: 24

   When the app has been successfully created and the project builds, then proceed with the
   next section.


**Add images**

   You're provided with four vector drawable files that you use in the Lemonade app.

   Get the files:

   1. Download a `zip file of the images <https://github.com/google-developer-training/basic-android-kotlin-compose-training-lemonade/raw/main/lemonade_images.zip>`__
      for the app.
   2. Double click the zip file. This step unzips the images into a folder.
   3. Add the images into the ``drawable`` folder of your app. If you don't remember how to
      do this, see the `Create an interactive Dice Roller app codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app>`__.

   Your project folder should look like the following screenshot in which the
   ``lemon_drink.xml``, ``lemon_restart.xml``, ``lemon_squeeze.xml``, and
   ``lemon_tree.xml`` assets now appear under the **res > drawable** directory:

   |ccc5a4aa8a7e9fbd.png|

   4. Double click a vector drawable file to see the image preview.
   5. Select the **Design** pane (not the **Code** or **Split** views) to see a full-width
      view of the image.

   |3f3a1763ac414ec0.png|

   After the image files are included in your app, you can refer to them in your code. For
   example, if the vector drawable file is called ``lemon_tree.xml``, then in your Kotlin
   code, you can refer to the drawable using its resource ID in the format of
   ``R.drawable.lemon_tree``.


**Add string resources**

   Add the following strings to your project in the **res > values > strings.xml** file:

   -  ``Tap the lemon tree to select a lemon``
   -  ``Keep tapping the lemon to squeeze it``
   -  ``Tap the lemonade to drink it``
   -  ``Tap the empty glass to start again``

   The following strings are also needed in your project. They're not displayed on the
   screen in the user interface, but these are used for the content description of the
   images in your app to describe what the images are. Add these additional strings in your
   app's ``strings.xml`` file:

   -  ``Lemon tree``
   -  ``Lemon``
   -  ``Glass of lemonade``
   -  ``Empty glass``

   If you don't remember how to declare string resources in your app, see the 
   `Create an interactive Dice Roller app codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app>`__
   or refer to
   `String <https://developer.android.google.cn/guide/topics/resources/string-resource#String>`__.
   Give each string resource an appropriate identifier name that describes the value it
   contains. For example, for the string ``"Lemon"``, you can declare it in the
   ``strings.xml`` file with the identifier name ``lemon_content_description``, and then
   refer to it in your code using the resource ID: ``R.string.lemon_content_description``.


**Steps of making lemonade**

   Now you have the string resources and image assets that are needed to implement the app.
   Here's a summary of each step of the app and what is shown on the screen:

   Step 1:

   -  Text: ``Tap the lemon tree to select a lemon``
   -  Image: Lemon tree (``lemon_tree.xml``)

   |b2b0ae4400c0d06d.png|

   Step 2:

   -  Text: ``Keep tapping the lemon to squeeze it``
   -  Image: Lemon (``lemon_squeeze.xml``)

   |7c6281156d027a8.png|

   Step 3:

   -  Text: ``Tap the lemonade to drink it``
   -  Image: Full glass of lemonade (``lemon_drink.xml``)

   |38340dfe3df0f721.png|

   Step 4:

   -  Text: ``Tap the empty glass to start again``
   -  Image: Empty glass (``lemon_restart.xml``)

   |e9442e201777352b.png|


**Add visual polish**

   To make your version of the app look like these final screenshots, there are a couple
   more visual adjustments to make in the app:

   -  Increase the font size of the text so that it's larger than the default font size
      (such as ``18sp``).
   -  Add additional space in between the text label and the image below it, so they're not
      too close to each other (such as ``16dp``).
   -  Give the button an accent color and slightly rounded corners to let the users know
      that they can tap the image.

   If you want to challenge yourself, build the rest of the app based on the description of
   how it should work. If you want more guidance, proceed to the next section.

   **Warning:** Do not proceed with reading the rest of the instructions unless you want
   hints revealed. It's recommended for you to try the problem yourself and only consult
   the rest of the instructions if you get stuck.


4. Plan out how to build the app
--------------------------------------------------------------------------------

   When building an app, it's a good idea to get a minimal working version of the app done
   first. Then gradually add more functionality until you complete all desired
   functionality. Identify a small piece of end-to-end functionality that you can build
   first.

   In the Lemonade app, notice that the key part of the app is transitioning from one step
   to another with a different image and text label shown each time. Initially, you can
   ignore the special behavior of the squeeze state because you can add this functionality
   later after you build the foundation of the app.

   Below is a proposal of the high-level overview of the steps that you can take to build
   the app:

   1. Build the UI layout for the first step of making lemonade, which prompts the user to
      select a lemon from the tree. You can skip the border around the image for now
      because that's a visual detail that you can add later.

   |b2b0ae4400c0d06d.png|

   2. Implement the behavior in the app so that when the user taps the lemon tree, the app
      shows a lemon image and its corresponding text label. This covers the first two steps
      of making lemonade.

   |adbf0d217e1ac77d.png|

   3. Add code so that the app displays the rest of the steps to make lemonade, when the
      image is tapped each time. At this point, a single tap on the lemon can transition to
      displaying the glass of lemonade.

   |There are 4 boxes in a horizontal row, each with a green border. Each box contains a
   number from 1 to 4. There is an arrow from box 1 to box 2, from box 2 to box 3, from box
   3 to box 4, and from box 4 to box 1. Under box 1, there is a text label that says; Tap
   the lemon tree to select a lemon; and a lemon tree image. Under box 2, there is a text
   label that says; Keep tapping the lemon to squeeze it; and a lemon image. Under box 3,
   there is a text label that says;Tap the lemonade to drink it; and the image of a glass
   of lemonade. Under box 4, there is a text label that says;Tap the empty glass to start
   again; and the image of an empty glass.|

   4. Add custom behavior for the lemon squeeze step, so that the user needs to "squeeze",
      or tap, the lemon a specific number of times that's randomly generated from 2 to 4.

   |There are 4 boxes in a horizontal row, each with a green border. Each box contains a
   number from 1 to 4. There is an arrow from box 1 to box 2, from box 2 to box 3, from box
   3 to box 4, and from box 4 to box 1. There is an additional arrow from box 2 back to
   itself with a label that says; Random number of times. Under box 1 is the image of the
   lemon tree and the corresponding text label. Under box 2 is the image of the lemon and
   the corresponding text label. Under box 3 is the image of the glass of lemonade and the
   corresponding text label. Under box 4 is the image of the empty glass and the
   corresponding text label.|

   5. Finalize the app with any other necessary visual polish details. For example, change
      the font size and add a border around the image to make the app look more polished.
      Verify that the app follows good coding practices, such as adhering to the 
      `Kotlin coding style guidelines <https://developer.android.google.cn/kotlin/style-guide>`__
      and adding comments to your code.

   If you can use these high-level steps to guide you in the implementation of the Lemonade
   app, go ahead and build the app on your own. If you find that you need additional
   guidance on each of these five steps, proceed to the next section.


5. Implement the app
--------------------------------------------------------------------------------


**Build the UI layout**

   First modify the app so that it displays the image of the lemon tree and its
   corresponding text label, which says ``Tap the lemon tree to select a lemon``, in the
   center of the screen. There should also be ``16dp`` of space in between the text and the
   image below it.

   |b2b0ae4400c0d06d.png|

   If it helps, you can use the following starter code in the ``MainActivity.kt`` file:

   .. code:: prettyprint

      package com.example.lemonade

      import android.os.Bundle
      import androidx.activity.ComponentActivity
      import androidx.activity.compose.setContent
      import androidx.compose.foundation.layout.fillMaxSize
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Surface
      import androidx.compose.material3.Text
      import androidx.compose.runtime.Composable
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.tooling.preview.Preview
      import com.example.lemonade.ui.theme.LemonadeTheme

      class MainActivity : ComponentActivity() {
         override fun onCreate(savedInstanceState: Bundle?) {
             super.onCreate(savedInstanceState)
             setContent {
                 LemonadeTheme {
                     LemonApp()
                 }
             }
         }
      }

      @Composable
      fun LemonApp() {
         // A surface container using the 'background' color from the theme
         Surface(
             modifier = Modifier.fillMaxSize(),
             color = MaterialTheme.colorScheme.background
         ) {
             Text(text = "Hello there!")
         }
      }

      @Preview(showBackground = true)
      @Composable
      fun DefaultPreview() {
         LemonadeTheme {
             LemonApp()
         }
      }

   This code is similar to the code that's autogenerated by Android Studio. However,
   instead of a ``Greeting()`` composable, there's a ``LemonApp()`` composable defined and
   it doesn't expect a parameter. The ``DefaultPreview()`` composable is also updated to
   use the ``LemonApp()`` composable so you can preview your code easily.

   After you enter this code in Android Studio, modify the ``LemonApp()`` composable, which
   should contain the contents of the app. Here are some questions to guide your thought
   process:

   -  What composables will you use?
   -  Is there a standard `Compose layout component <https://developer.android.google.cn/jetpack/compose/layouts/basics#standard-layouts>`__
      that can help you arrange the composables into the desired positions?

   **Important:** To make your app accessible for more users, remember to set 
   `content descriptions on the images <https://developer.android.google.cn/jetpack/compose/accessibility#describe-visual>`__
   to describe what the image contains.

   Go and implement this step so that you have the lemon tree and text label displayed in
   your app, when your app launches.
   `Preview <https://developer.android.google.cn/jetpack/compose/tooling#preview>`__ your
   composable in Android Studio to see how the UI looks as you modify your code. Run the
   app to ensure that it looks like the screenshot that you saw earlier in this section.

   Return to these instructions when you're done, if you want more guidance on how to add
   behavior when the image is tapped on.


**Add click behavior**

   Next you will add code so that when the user taps the image of the lemon tree, the image
   of the lemon appears along with the text label ``Keep tapping the lemon to squeeze it``.
   In other words, when you tap the lemon tree, it causes the text and image to change.

   |adbf0d217e1ac77d.png|

   Earlier in this pathway, you learned how to make a button clickable. In the case of the
   Lemonade app, there's no ``Button`` composable. However, you can make any composable,
   not just buttons, clickable when you specify the ``clickable`` modifier on it. For an
   example, see the
   `clickable <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier).clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0)>`__
   documentation page.

   What should happen when the image is clicked? The code to implement this behavior is
   non-trivial, so take a step back to revisit a familiar app.


Look at the Dice Roller app

   Revisit the code from the Dice Roller app to observe how the app displays different dice
   images based on the value of the dice roll:

   **MainActivity.kt in Dice Roller app**

   .. code:: prettyprint

      ...

      @Composable
      fun DiceWithButtonAndImage(modifier: Modifier = Modifier) {
         var result by remember { mutableStateOf(1) }
         val imageResource = when(result) {
             1 -> R.drawable.dice_1
             2 -> R.drawable.dice_2
             3 -> R.drawable.dice_3
             4 -> R.drawable.dice_4
             5 -> R.drawable.dice_5
             else -> R.drawable.dice_6
         }
         Column(modifier = modifier, horizontalAlignment = Alignment.CenterHorizontally) {
             Image(painter = painterResource(id = imageResource), contentDescription = result.toString())
             Button(onClick = { result = (1..6).random() }) {
                Text(stringResource(id = R.string.roll))
             }
         }
      }

      ...

   Answer these questions about the Dice Roller app code:

   -  Which variable's value determines the appropriate dice image to display?
   -  What action from the user triggers that variable to change?

   The ``DiceWithButtonAndImage()`` composable function stores the most recent dice roll,
   in the ``result`` variable, which was defined with the ``remember`` composable and
   ``mutableStateOf()`` function in this line of code:

   .. code:: prettyprint

      var result by remember { mutableStateOf(1) }

   When the ``result`` variable gets updated to a new value, Compose triggers recomposition
   of the ``DiceWithButtonAndImage()`` composable, which means that the composable will
   execute again. The ``result`` value is remembered across recompositions, so when the
   ``DiceWithButtonAndImage()`` composable runs again, the most recent ``result`` value is
   used. Using a ``when`` statement on the value of the ``result`` variable, the composable
   determines the new drawable resource ID to show and the ``Image`` composable displays
   it.


Apply what you learned to the Lemonade app

   Now answer similar questions about the Lemonade app:

   -  Is there a variable that you can use to determine what text and image should be shown
      on the screen? Define that variable in your code.
   -  Can you use conditionals in Kotlin to have the app perform different behavior based
      on the value of that variable? If so, write that conditional statement in your code.
   -  What action from the user triggers that variable to change? Find the appropriate
      place in your code where that happens. Add code there to update the variable.

   **Note:** You may want to represent each step of making lemonade with a number. For
   example, step 1 of the app has the image of the lemon tree and clicking the image goes
   to step 2 of the app. This can help you organize which text string goes with which
   image.

   |There is a box with a green border that contains the number 1. An arrow points from
   this box to another box with a green border that contains the number 2. Under the first
   box is a text label that says;Tap the lemon tree to select a lemon; and an image of a
   lemon tree. Under the second box is a text label that says; Keep tapping the lemon to
   squeeze it; and an image of a lemon.|

   This section can be quite challenging to implement and requires changes in multiple
   places of your code to work correctly. Don't be discouraged if the app doesn't work as
   you expect right away. Remember that there are multiple correct ways to implement this
   behavior.

   When you're done, run the app and verify that it works. When you launch the app, it
   should show the image of the lemon tree and its corresponding text label. A single tap
   of the image of the lemon tree should update the text label and show the image of the
   lemon. A tap on the lemon image shouldn't do anything for now.


**Add remaining steps**

   Now your app can display two of the steps to make lemonade! At this point, your
   ``LemonApp()`` composable may look something like the following code snippet. It's okay
   if your code looks slightly different as long as the behavior in the app is the same.

   **MainActivity.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun LemonApp() {
         // Current step the app is displaying (remember allows the state to be retained
         // across recompositions).
         var currentStep by remember { mutableStateOf(1) }

         // A surface container using the 'background' color from the theme
         Surface(
             modifier = Modifier.fillMaxSize(),
             color = MaterialTheme.colorScheme.background
         ) {
             when (currentStep) {
                 1 -> {
                     Column (
                         horizontalAlignment = Alignment.CenterHorizontally,
                         verticalArrangement = Arrangement.Center,
                         modifier = Modifier.fillMaxSize()
                     ){
                         Text(text = stringResource(R.string.lemon_select))
                         Spacer(modifier = Modifier.height(32.dp))
                         Image(
                             painter = painterResource(R.drawable.lemon_tree),
                             contentDescription = stringResource(R.string.lemon_tree_content_description),
                             modifier = Modifier
                                 .wrapContentSize()
                                 .clickable {
                                     currentStep = 2
                                 }
                         )
                     }
                 }
                 2 -> {
                     Column (
                         horizontalAlignment = Alignment.CenterHorizontally,
                         verticalArrangement = Arrangement.Center,
                         modifier = Modifier.fillMaxSize()
                     ){
                         Text(text = stringResource(R.string.lemon_squeeze))
                         Spacer(modifier = Modifier.height(32
                             .dp))
                         Image(
                             painter = painterResource(R.drawable.lemon_squeeze),
                             contentDescription = stringResource(R.string.lemon_content_description),
                             modifier = Modifier.wrapContentSize()
                         )
                     }
                 }
             }
         }
      }
      ...

   Next you'll add the rest of the steps to make lemonade. A single tap of the image should
   move the user to the next step of making lemonade, where the text and image both update.
   You will need to change your code to make it more flexible to handle all steps of the
   app, not just the first two steps.

   |There are 4 boxes in a horizontal row, each with a green border. Each box contains a
   number from 1 to 4. There is an arrow from box 1 to box 2, from box 2 to box 3, from box
   3 to box 4, and from box 4 to box 1. Under box 1, there is a text label that says; Tap
   the lemon tree to select a lemon; and the image of a lemon tree . Under box 2, there is
   a text label that says; Keep tapping the lemon to squeeze it; and the image of a lemon.
   Under box 3, there is a text label that says; Tap the lemonade to drink it; and the
   image of a glass of lemonade. Under box 4, there is a text label that says; Tap the
   empty glass to start again; and the image of an empty glass.|

   To have different behavior each time that the image is clicked, you need to customize
   the clickable behavior. More specifically, the lambda that's executed when the image is
   clicked needs to know which step we're moving to.

   You may start to notice that there's repeated code in your app for each step of making
   lemonade. For the ``when`` statement in the previous code snippet, the code for case
   ``1`` is very similar to case ``2`` with small differences. If it's helpful, create a
   new composable function, called ``LemonTextAndImage()`` for example, that displays text
   above an image in the UI. By creating a new composable function that takes some input
   parameters, you have a reusable function that's useful in multiple scenarios as long as
   you change the inputs that you pass in. It's your job to figure out what the input
   parameters should be. After you create this composable function, update your existing
   code to call this new function in relevant places.

   Another advantage to having a separate composable like ``LemonTextAndImage()`` is that
   your code becomes more organized and robust. When you call ``LemonTextAndImage()``, you
   can be sure that both the text and image will get updated to the new values. Otherwise,
   it's easy to accidentally miss one case where an updated text label is displayed with
   the wrong image.

   Here's one additional hint: You can even pass in a lambda function to a composable. Be
   sure to use function type notation to specify what type of function should be passed in.
   In the following example, a ``WelcomeScreen()`` composable is defined and accepts two
   input parameters: a ``name`` string and an ``onStartClicked()`` function of type
   ``() -> Unit``. That means that the function takes no inputs (the empty parentheses
   before the arrow) and has no return value ( the ``Unit`` following the arrow). Any
   function that matches that function type ``() -> Unit`` can be used to set the
   ``onClick`` handler of this ``Button``. When the button is clicked, the
   ``onStartClicked()`` function is called.

   .. code:: prettyprint

      @Composable
      fun WelcomeScreen(name: String, onStartClicked: () -> Unit) {
          Column {
              Text(text = "Welcome $name!")
              Button(
                  onClick = onStartClicked
              ) {
                  Text("Start")
              }
          }
      }

   Passing in a lambda to a composable is a useful pattern because then the
   ``WelcomeScreen()`` composable can be reused in different scenarios. The user's name and
   the button's ``onClick`` behavior can be different each time because they're passed in
   as arguments.

   With this additional knowledge, go back to your code to add the remaining steps of
   making lemonade to your app.

   Return to these instructions if you want additional guidance on how to add the custom
   logic around squeezing the lemon a random number of times.


**Add squeeze logic**

   Great job! Now you have the basis of the app. Tapping the image should move you from one
   step to the next. It's time to add the behavior of needing to squeeze the lemon multiple
   times to make lemonade. The number of times that the user needs to squeeze, or tap, the
   lemon should be a random number between 2 to 4 (inclusive). This random number is
   different each time that the user picks a new lemon from the tree.

   |There are 4 boxes in a horizontal row, each with a green border. Each box contains a
   number from 1 to 4. There is an arrow from box 1 to box 2, from box 2 to box 3, from box
   3 to box 4, and from box 4 to box 1. There is an additional arrow from box 2 back to
   itself with a label that says; Random number of times; Under box 1 is an image of a
   lemon tree and the corresponding text label. Under box 2 is the image of the lemon and
   the corresponding text label. Under box 3 is the image of the glass of lemonade and the
   corresponding text label. Under box 4 is the image of the empty glass and the
   corresponding text label.|

   Here are some questions to guide your thought process:

   -  How do you generate random numbers in Kotlin?
   -  At what point in your code should you generate the random number?
   -  How do you ensure that the user tapped the lemon the required number of times before
      moving to the next step?
   -  Do you need any variables stored with the ``remember`` composable so that the data
      doesn't get reset every time the screen is redrawn?

   When you're done implementing this change, run the app. Verify that it takes multiple
   taps of the image of the lemon to move to the next step, and that the number of taps
   required each time is a random number between 2 and 4. If a single tap of the lemon
   image displays the lemonade glass, go back to your code to figure out what's missing and
   try again.

   Return to these instructions if you want additional guidance on how to finalize the app.


**Finalize the app**

   You're almost done! Add some last details to polish up the app.

   As a reminder, here are the final screenshots of how the app looks:

   ====================== ======================
   |b2b0ae4400c0d06d.png| |7c6281156d027a8.png|
   |38340dfe3df0f721.png| |e9442e201777352b.png|
   ====================== ======================

   -  Vertically and horizontally center the text and images within the screen.
   -  Set the font size of the text to ``18sp``.
   -  Add ``16dp`` of space between the text and image.
   -  Add a thin border of ``2dp`` around the images with slightly rounded corners of
      ``4dp``. The border has an `RGB <https://en.wikipedia.org/wiki/RGB_color_model>`__
      color value of ``105`` for red, ``205`` for green, and ``216`` for blue. For examples
      of how to add a border, you can Google search it. Or you can refer to the
      documentation on
      `Border <https://developer.android.google.cn/jetpack/compose/modifiers-list#Border>`__.

   When you've completed these changes, run your app and then compare it with the final
   screenshots to ensure that they match.

   As part of good coding practices, go back and add comments to your code, so that anyone
   who reads your code can understand your thought process more easily. Remove any import
   statements at the top of your file that aren't used in your code. Ensure that your code
   follows the `Kotlin style guide <https://developer.android.google.cn/kotlin/style-guide>`__. All these efforts
   will help make your code more readable by other people and easier to maintain!

   Well done! You did an amazing job implementing the Lemonade app! That was a challenging
   app with many parts to figure out. Now treat yourself to a refreshing glass of lemonade.
   Cheers!


6. Get the solution code
--------------------------------------------------------------------------------

   Download the solution code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-lemonade/archive/refs/heads/main.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-lemonade.git

   Remember that your code doesn't need to precisely match the solution code because there
   are multiple ways to implement the app.

   You can also browse the code in the 
   `Lemonade app GitHub repository <https://github.com/google-developer-training/basic-android-kotlin-compose-training-lemonade>`__.

   Content and code samples on this page are subject to the licenses described in the 
   `Content License <https://developer.android.google.cn/license>`__. Java and OpenJDK are trademarks or registered trademarks of Oracle
   and/or its affiliates.


.. |dfcc3bc3eb43e4dd.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/dfcc3bc3eb43e4dd.png
.. |5384eedd313cb5a9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/5384eedd313cb5a9.png
.. |89cec3022a462039.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/89cec3022a462039.png
.. |513e4b0ee349a4d2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/513e4b0ee349a4d2.png
.. |9dbd92f4413c186e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/9dbd92f4413c186e.png
.. |ccc5a4aa8a7e9fbd.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/ccc5a4aa8a7e9fbd.png
.. |3f3a1763ac414ec0.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/3f3a1763ac414ec0.png
.. |b2b0ae4400c0d06d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/b2b0ae4400c0d06d.png
.. |7c6281156d027a8.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/7c6281156d027a8.png
.. |38340dfe3df0f721.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/38340dfe3df0f721.png
.. |e9442e201777352b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/e9442e201777352b.png
.. |adbf0d217e1ac77d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/adbf0d217e1ac77d.png
.. |There are 4 boxes in a horizontal row, each with a green border. Each box contains a number from 1 to 4. There is an arrow from box 1 to box 2, from box 2 to box 3, from box 3 to box 4, and from box 4 to box 1. Under box 1, there is a text label that says; Tap the lemon tree to select a lemon; and a lemon tree image. Under box 2, there is a text label that says; Keep tapping the lemon to squeeze it; and a lemon image. Under box 3, there is a text label that says;Tap the lemonade to drink it; and the image of a glass of lemonade. Under box 4, there is a text label that says;Tap the empty glass to start again; and the image of an empty glass.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/33a36bcbe200af53.png
.. |There are 4 boxes in a horizontal row, each with a green border. Each box contains a number from 1 to 4. There is an arrow from box 1 to box 2, from box 2 to box 3, from box 3 to box 4, and from box 4 to box 1. There is an additional arrow from box 2 back to itself with a label that says; Random number of times. Under box 1 is the image of the lemon tree and the corresponding text label. Under box 2 is the image of the lemon and the corresponding text label. Under box 3 is the image of the glass of lemonade and the corresponding text label. Under box 4 is the image of the empty glass and the corresponding text label.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/a23102cb6c068174.png
.. |There is a box with a green border that contains the number 1. An arrow points from this box to another box with a green border that contains the number 2. Under the first box is a text label that says;Tap the lemon tree to select a lemon; and an image of a lemon tree. Under the second box is a text label that says; Keep tapping the lemon to squeeze it; and an image of a lemon.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/270ecd406fc30120.png
.. |There are 4 boxes in a horizontal row, each with a green border. Each box contains a number from 1 to 4. There is an arrow from box 1 to box 2, from box 2 to box 3, from box 3 to box 4, and from box 4 to box 1. Under box 1, there is a text label that says; Tap the lemon tree to select a lemon; and the image of a lemon tree . Under box 2, there is a text label that says; Keep tapping the lemon to squeeze it; and the image of a lemon. Under box 3, there is a text label that says; Tap the lemonade to drink it; and the image of a glass of lemonade. Under box 4, there is a text label that says; Tap the empty glass to start again; and the image of an empty glass.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/2c0f70529e0cf69d.png
.. |There are 4 boxes in a horizontal row, each with a green border. Each box contains a number from 1 to 4. There is an arrow from box 1 to box 2, from box 2 to box 3, from box 3 to box 4, and from box 4 to box 1. There is an additional arrow from box 2 back to itself with a label that says; Random number of times; Under box 1 is an image of a lemon tree and the corresponding text label. Under box 2 is the image of the lemon and the corresponding text label. Under box 3 is the image of the glass of lemonade and the corresponding text label. Under box 4 is the image of the empty glass and the corresponding text label.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-button-click-practice-problem/img/52b9b7321e689600.png


ğŸš€ Intro to state in Compose
============================

pandoc --column=100 -trst -rhtml https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-using-state | subl -


1. Before you begin
--------------------------------------------------------------------------------

   This codelab teaches you about state, and how it can be used and manipulated by Jetpack
   Compose.

   At its core, state in an app is any value that can change over time. This definition is
   very broad and includes everything from a database to a variable in your app. You learn
   more about databases in a later unit, but for now all you need to know is that a
   database is an organized collection of structured information, such as the files on your
   computer.

   All Android apps display state to the user. A few examples of state in Android apps
   include:

   -  A message that shows when a network connection can't be established.
   -  Forms, such as registration forms. The state can be filled and submitted.
   -  Tappable controls, such as buttons. The state could be *not tapped*, *being tapped*
      (display animation), or *tapped* (an ``onClick`` action).

   In this codelab, you explore how to use and think about state when you use Compose. To
   do this, you build a tip calculator app called Tip Time with these built-in Compose UI
   elements:

   -  A ``TextField`` composable to enter and edit text.
   -  A ``Text`` composable to display text.
   -  A ``Spacer`` composable to display empty space between UI elements.

   At the end of this codelab, you'll have built an interactive tip calculator that
   automatically calculates the tip amount when you enter the service amount. This image
   shows what the final app looks like:

   |e82cbb534872abcf.png|


Prerequisites

   -  Basic understanding of Compose, such as the ``@Composable`` annotation.
   -  Basic familiarity with Compose layouts, such as the ``Row`` and ``Column`` layout
      composables.
   -  Basic familiarity with modifiers, such as the ``Modifier.padding()`` function.
   -  Familiarity with the ``Text`` composable.


What you'll learn

   -  How to think about state in a UI.
   -  How Compose uses state to display data.
   -  How to add a text box to your app.
   -  How to hoist a state.


**What you'll build**

   -  A tip-calculator app called Tip Time that calculates a tip amount based on the
      service amount.


**What you'll need**

   -  A computer with internet access and a web browser
   -  Knowledge of Kotlin
   -  The latest version of `Android Studio <https://developer.android.google.cn/studio>`__


2. Get started
--------------------------------------------------------------------------------

   1. Check `Google's online tip calculator <https://www.google.com/search?q=tip+calculator>`__. 
      Please note that this
      is just an example and this is not the Android app you will be creating in this
      course.

   |46bf4366edc1055f.png| |18da3c120daa0759.png|

   2. Enter different values in the **Bill** and **Tip %** boxes. The tip and total values
      change.

   |c0980ba3e9ebba02.png|

   Notice that the moment you enter the values, the **Tip** and the **Total** update. By
   the end of the following codelab you will be developing a similar tip calculator app in
   Android.

   In this pathway, you'll build a simple tip calculator Android app.

   Developers will often work in this wayâ€”get a simple version of the app ready and working
   (even if it doesn't look very good), and then add more features and make it more
   visually appealing later.

   By the end of this codelab, your tip calculator app will look like these screenshots.
   When the user enters a **bill amount**, your app will display a suggested tip amount.
   The tip percentage is hardcoded to **15%** for now. In the next codelab, you will
   continue to work on your app and add more features like setting a custom tip percentage.

   ====================== =====================
   |9819649900a3a6f5.png| |e82cbb534872abcf.png|
   ====================== =====================


3. Get Starter Code
--------------------------------------------------------------------------------

   Starter code is a pre-written code that can be used as a starting point for a new
   project. It can also help you to focus on new concepts taught in this codelab.

   Get started with the starter code by downloading it here:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator/archive/refs/heads/starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator.git
      $ cd basic-android-kotlin-compose-training-tip-calculator
      $ git checkout starter

   **Note:** The starter code is in the ``starter`` branch of the downloaded repository.

   You can browse the starter code in the
   `TipTime <https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator/tree/starter>`__
   GitHub repository.


**Starter app overview**

   To familiarize yourself with the starter code, complete the following steps:

   1. Open the project with starter code in Android Studio.
   2. Run the app on an Android device or emulator.
   3. You will notice two text components; one is for a label and the other is for
      displaying tip amount.

   |e85b767a43c69a97.png|


Starter code walk through

   The starter code has the text composables. In this pathway, you will add a text field to
   take users input. Here is a brief walkthrough of some files to get you started.

   **res > values > strings.xml**

   .. code:: prettyprint

      <resources>
         <string name="app_name">Tip Time</string>
         <string name="calculate_tip">Calculate Tip</string>
         <string name="bill_amount">Bill Amount</string>
         <string name="tip_amount">Tip Amount: %s</string>
      </resources>

   This is the ``string.xml`` file in the resources with all the strings you will be using
   in this app.

   **MainActivity**

   This file contains mostly template generated code and following functions.

   -  The ``TipTimeLayout()`` function contains a ``Column`` element with two text
      composables that you see in the screenshots. This also has ``spacer`` composable to
      add space for aesthetic reasons.
   -  The ``calculateTip()`` function that accepts the bill amount and calculates a 15% tip
      amount. The ``tipPercent`` parameter is set to a ``15.0`` default argument value.
      This sets the default tip value to 15% for now. In the next codelab, you get the tip
      amount from the user.

   .. code:: prettyprint

      @Composable
      fun TipTimeLayout() {
          Column(
              modifier = Modifier
                  .statusBarsPadding()
                  .padding(horizontal = 40.dp)
                  .verticalScroll(rememberScrollState())
                  .safeDrawingPadding(),
              horizontalAlignment = Alignment.CenterHorizontally,
              verticalArrangement = Arrangement.Center
          ) {
              Text(
                  text = stringResource(R.string.calculate_tip),
                  modifier = Modifier
                      .padding(bottom = 16.dp, top = 40.dp)
                      .align(alignment = Alignment.Start)
              )
              Text(
                  text = stringResource(R.string.tip_amount, "$0.00"),
                  style = MaterialTheme.typography.displaySmall
              )
              Spacer(modifier = Modifier.height(150.dp))
          }
      }

   .. code:: prettyprint

      private fun calculateTip(amount: Double, tipPercent: Double = 15.0): String {
         val tip = tipPercent / 100 * amount
         return NumberFormat.getCurrencyInstance().format(tip)
      }

   In the ``onCreate()`` function's ``Surface()`` block, the ``TipTimeLayout()`` function
   is being called. This displays the app's layout in the device or the emulator.

   .. code:: prettyprint

      override fun onCreate(savedInstanceState: Bundle?) {
         //...
         setContent {
             TipTimeTheme {
                 Surface(
                 //...
                 ) {
                     TipTimeLayout()
                 }
             }
         }
      }

   The ``TipTimeLayoutPreview()`` function's ``TipTimeTheme`` block, the
   ``TipTimeLayout()`` function is being called. This displays the app's layout in the
   **Design** and in the **Split** pane.

   .. code:: prettyprint

      @Preview(showBackground = true)
      @Composable
      fun TipTimeLayoutPreview() {
         TipTimeTheme {
             TipTimeLayout()
         }
      }

   |ae11354e61d2a2b9.png|


**Take input from the user**

   In this section, you add the UI element that lets the user enter the bill amount in the
   app. You can see what it looks like in this image:

   |58671affa01fb9e1.png|

   Your app uses a custom style and theme.

   Styles and themes are a collection of attributes that specifies the appearance for a
   single UI element. A style can specify attributes such as font color, font size,
   background color, and much more which can be applied for the entire app. Later codelabs
   will cover how to implement these in your app. For now, this has already been done for
   you to make your app more beautiful.

   To get a better understanding, here is a side-by-side comparison of the solution version
   of the app with and without a custom theme.

   =============================================== ==============================
   |9819649900a3a6f5.png|\ Without a custom theme. |678d911263888d8f.png|\ With a custom theme.
   =============================================== ==============================

   **Note:** When you add a text field composable in your app, it will have a color scheme
   as part of the custom theme something like this:

   |f658ec4a43ef365b.png|

   The ``TextField`` composable function lets the user enter text in an app. For example,
   notice the text box on the login screen of the Gmail app in this image:

   |Phone screen with gmail app with a text field for email|

   Add the ``TextField`` composable to the app:

   1. In the ``MainActivity.kt`` file, add an ``EditNumberField()`` composable function,
      that takes a ``Modifier`` parameter.

   2. In the body of the ``EditNumberField()`` function below ``TipTimeLayout()``, add a
      ``TextField`` that accepts a ``value`` named parameter set to an empty string and an
      ``onValueChange`` named parameter set to an empty lambda expression:

   .. code:: prettyprint

      @Composable
      fun EditNumberField(modifier: Modifier = Modifier) {
         TextField(
            value = "",
            onValueChange = {},
            modifier = modifier
         )
      }

   3. Notice the parameters that you passed:

   -  The ``value`` parameter is a text box that displays the string value you pass here.
   -  The ``onValueChange`` parameter is the lambda callback that's triggered when the user
      enters text in the text box.

   4. Import this function:

   .. code:: prettyprint

      import androidx.compose.material3.TextField

   5. In the ``TipTimeLayout()`` composable, on the line after the first text composable
      function, call the ``EditNumberField()`` function, passing the following modifier.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.fillMaxWidth

      @Composable
      fun TipTimeLayout() {
         Column(
              modifier = Modifier
                  .statusBarsPadding()
                  .padding(horizontal = 40.dp)
                  .verticalScroll(rememberScrollState())
                  .safeDrawingPadding(),
              horizontalAlignment = Alignment.CenterHorizontally,
              verticalArrangement = Arrangement.Center
         ) {
             Text(
                 ...
             )
             EditNumberField(modifier = Modifier.padding(bottom = 32.dp).fillMaxWidth())
             Text(
                 ...
             )
             ...
         }
      }

   This displays the text box on the screen.

   6. In the **Design** pane, you should see the ``Calculate Tip`` text, an empty text box
      and the ``Tip Amount`` text composable.

   |2c208378cd4b8d41.png|


4. Use state in Compose
--------------------------------------------------------------------------------

   State in an app is any value that can change over time. In this app, the state is the
   bill amount.

   Add a variable to store state:

   1. At the beginning of the ``EditNumberField()`` function, use the ``val`` keyword to
      add an ``amountInput`` variable set it to ``"0"`` value:

   .. code:: prettyprint

      val amountInput = "0"

   This is the state of the app for the bill amount.

   2. Set the ``value`` named parameter to an ``amountInput`` value:

   .. code:: prettyprint

      TextField(
         value = amountInput,
         onValueChange = {},
      )

   3. Check the preview. The text box displays the value set to the state variable as you
      can see in this image:

   |e8e24821adfd9d8c.png|

   4. Run the app in the emulator, try to enter a different value. The hardcoded state
      remains unchanged because the ``TextField`` composable doesn't update itself. It
      updates when its ``value`` parameter changes, which is set to the ``amountInput``
      property.

   The ``amountInput`` variable represents the state of the text box. Having a hardcoded
   state isn't useful because it can't be modified and it doesn't reflect user input. You
   need to update the state of the app when the user updates the bill amount.


5. The Composition
--------------------------------------------------------------------------------

   The composables in your app describe a UI that shows a column with some text, a spacer,
   and a text box. The text shows a ``Calculate Tip`` text, and the text box shows a ``0``
   value or whatever the default value is.

   Compose is a declarative UI framework, meaning that you *declare* how the UI should look
   in your code. If you wanted your text box to show a ``100`` value initially, you'd set
   the initial value in the code for the composables to a ``100`` value.

   What happens if you want your UI to change while the app is running or as the user
   interacts with the app? For example, what if you wanted to update the ``amountInput``
   variable with the value entered by the user and display it in the text box? That's when
   you rely on a process called recomposition to update the Composition of the app.

   The *Composition* is a description of the UI built by Compose when it executes
   composables. Compose apps call composable functions to transform data into UI. If a
   state change happens, Compose re-executes the affected composable functions with the new
   state, which creates an updated UIâ€”this is called *recomposition*. Compose schedules a
   *recomposition* for you.

   When Compose runs your composables for the first time during *initial composition*, it
   keeps track of the composables that you call to describe your UI in a Composition.
   *Recomposition* is when Compose re-executes the composables that may have changed in
   response to data changes and then updates the Composition to reflect any changes.

   The Composition can only be produced by an *initial composition* and updated by
   *recomposition*. The only way to modify the Composition is through *recomposition*. To
   do this, *Compose needs to know what state to track* so that it can schedule the
   recomposition when it receives an update. In your case, it's the ``amountInput``
   variable, so whenever its value changes, Compose schedules a recomposition.

   You use the
   `State <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/State>`__
   and
   `MutableState <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/MutableState>`__
   types in Compose to make state in your app observable, or tracked, by Compose. The
   State type is immutable, so you can only read the value in it, while the
   `MutableState <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/MutableState>`__
   type is mutable. You can use the
   `mutableStateOf() <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#mutableStateOf(kotlin.Any,androidx.compose.runtime.SnapshotMutationPolicy)>`__
   function to create an observable ``MutableState``. It receives an initial value as a
   parameter that is wrapped in a ``State`` object, which then makes its ``value``
   observable.

   The value returned by the ``mutableStateOf()`` function:

   -  Holds state, which is the bill amount.
   -  Is mutable, so the value can be changed.
   -  Is observable, so Compose observes any changes to the value and triggers a
      recomposition to update the UI.

   Add a cost-of-service state:

   1. In the ``EditNumberField()`` function, change the ``val`` keyword before the
      ``amountInput`` state variable to the ``var`` keyword:

   .. code:: prettyprint

      var amountInput = "0"

   This makes ``amountInput`` mutable.

   2. Use the ``MutableState<String>`` type instead of the hardcoded ``String`` variable so
      that Compose knows to track the ``amountInput`` state and then pass in a ``"0"``
      string, which is the initial default value for the ``amountInput`` state variable:

   .. code:: prettyprint

      import androidx.compose.runtime.MutableState
      import androidx.compose.runtime.mutableStateOf

      var amountInput: MutableState<String> = mutableStateOf("0")

   The ``amountInput`` initialization can also be written like this with type inference:

   .. code:: prettyprint

      var amountInput = mutableStateOf("0")

   The ``mutableStateOf()`` function receives an initial ``"0"`` value as an argument,
   which then makes ``amountInput`` observable. This results in this compilation warning in
   Android Studio, but you fix it soon:

   ::

      Creating a state object during composition without using remember.

   3. In the ``TextField`` composable function, use the ``amountInput.value`` property:

   .. code:: prettyprint

      TextField(
         value = amountInput.value,
         onValueChange = {},
         modifier = modifier
      )

   Compose keeps track of each composable that reads state ``value`` properties and
   triggers a recomposition when its ``value`` changes.

   The ``onValueChange`` callback is triggered when the text box's input changes. In the
   lambda expression, the ``it`` variable contains the new value.

   4. In the ``onValueChange`` named parameter's lambda expression, set the
      ``amountInput.value`` property to the ``it`` variable:

   .. code:: prettyprint

      @Composable
      fun EditNumberField(modifier: Modifier = Modifier) {
         var amountInput = mutableStateOf("0")
         TextField(
             value = amountInput.value,
             onValueChange = { amountInput.value = it },
             modifier = modifier
         )
      }

   You are updating the state of the ``TextField`` (that is the ``amountInput`` variable),
   when the ``TextField`` notifies you that there is a change in the text through
   ``onValueChange`` callback function.

   5. Run the app and enter text in the text box. The text box still shows a ``0`` value as
      you can see in this image:

   |3a2c62f8ec55e339.gif|

   When the user enters text in the text box, the ``onValueChange`` callback is called and
   the ``amountInput`` variable is updated with the new value. The ``amountInput`` state is
   tracked by Compose, so the moment that its value changes, recomposition is scheduled and
   the ``EditNumberField()`` composable function is executed again. In that composable
   function, the ``amountInput`` variable is reset to its initial ``0`` value. Thus, the
   text box shows a ``0`` value.

   With the code you added, state changes cause recompositions to be scheduled.

   However, you need a way to preserve the value of the ``amountInput`` variable across
   recompositions so that it's not reset to a ``0`` value each time that the
   ``EditNumberField()`` function recomposes. You resolve this issue in the next section.


6. Use remember function to save state
--------------------------------------------------------------------------------

   Composable methods can be called many times because of recomposition. The composable
   resets its state during recomposition if it's not saved.

   Composable functions can store an object across recompositions with the
   `remember <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0)>`__.
   A value computed by the ``remember`` function is stored in the Composition during
   initial composition and the stored value is returned during recomposition. Usually
   ``remember`` and ``mutableStateOf`` functions are used together in composable functions
   to have the state and its updates be reflected properly in the UI.

   Use the ``remember`` function in ``EditNumberField()`` function:

   1. In the ``EditNumberField()`` function, initialize the ``amountInput`` variable with
      the ``by`` ``remember`` Kotlin property delegate, by surrounding the call to
      `mutableStateOf <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#mutableStateOf(kotlin.Any,androidx.compose.runtime.SnapshotMutationPolicy)>`__\ ``()``
      function with ``remember``.

   2. In the
      `mutableStateOf <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#mutableStateOf(kotlin.Any,androidx.compose.runtime.SnapshotMutationPolicy)>`__\ ``()``
      function, pass in an empty string instead of a static ``"0"`` string:

   .. code:: prettyprint

      var amountInput by remember { mutableStateOf("") }

   Now the empty string is the initial default value for the ``amountInput`` variable.
   ``by`` is a `Kotlin property delegation <https://kotlinlang.org/docs/delegated-properties.html>`__. 
   The default getter and setter functions for the ``amountInput`` property are delegated to the
   ``remember`` class's getter and setter functions, respectively.

   3. Import these functions:

   .. code:: prettyprint

      import androidx.compose.runtime.remember
      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.setValue

   **Warning:** This code may throw the error that you see in this image regarding the
   ``getValue()`` extension function:

   |b651ccb43a6fd25.png|

   If so, manually add the ``getValue`` and ``setValue`` imports into the import block at
   the beginning of the file as you can see in this image:

   |bad619de4ecfefc.png|

   Adding the delegate's getter and setter imports lets you read and set ``amountInput``
   without referring to the ``MutableState``'s ``value`` property.

   Updated ``EditNumberField()`` function should look like this:

   .. code:: prettyprint

      @Composable
      fun EditNumberField(modifier: Modifier = Modifier) {
         var amountInput by remember { mutableStateOf("") }
         TextField(
             value = amountInput,
             onValueChange = { amountInput = it },
             modifier = modifier
         )
      }

   **Note:** During initial composition, ``value`` in the ``TextField`` is set to the
   initial value, which is an empty string.

   When the user enters text into the text field, the ``onValueChange`` lambda callback is
   called, the lambda executes, and the ``amountInput.value`` is set to the updated value
   entered in the text field.

   The ``amountInput`` is the mutable state being tracked by the Compose, recomposition is
   scheduled. The ``EditNumberField()`` composable function is recomposed. Since you are
   using ``remember`` ``{ },`` the change survives the recomposition and that is why the
   state is not re-initialized to ``""``.

   The ``value`` of the text field is set to the remembered value of ``amountInput``. The
   text field recomposes (redrawn on the screen with new value).

   4. Run the app and enter some text in the text box. You should see the text you typed
      now.

   |59ac301a208b47c4.png|


7. State and recomposition in action
--------------------------------------------------------------------------------

   In this section, you set a breakpoint and debug the ``EditNumberField()`` composable
   function to see how initial composition and recomposition work.

   **Note**: A breakpoint is a place in your code where you want to pause the normal
   execution of your app to perform other actions, such as examine variables, evaluate
   expressions, or execute your code line by line. You can set a breakpoint on any
   executable line of code.

   Set a breakpoint and debug the app on an emulator or a device:

   1. In the ``EditNumberField()`` function next to the ``onValueChange`` named parameter,
      set a line breakpoint.
   2. In the navigation menu, click **Debug â€˜app'**. The app launches on the emulator or
      device. Your app's execution pauses for the first time when the ``TextField`` element
      is created.

   |154e060231439307.png|

   3. In the **Debug** pane, click |2a29a3bad712bec.png| **Resume Program**. The text box
      is created.
   4. On the emulator or device, enter a letter in the text box. Your app's execution
      pauses again when it reaches the breakpoint that you set.

   When you enter the text, the ``onValueChange`` callback is called. Inside the lambda
   ``it`` has the new value you typed in the keypad.

   Once the value of "it" is assigned to ``amountInput`` then Compose triggers the
   recomposition with the new data as the observable value has changed.

   |1d5e08d32052d02e.png|

   5. In the **Debug** pane, click |2a29a3bad712bec.png| **Resume Program**. The text
      entered in the emulator or on the device displays next to the line with the
      breakpoint as seen in this image:

   |1f5db6ab5ca5b477.png|

   This is the state of the text field.

   6. Click |2a29a3bad712bec.png| **Resume Program**. The value entered is displayed on the
      emulator or device.


8. Modify the appearance
--------------------------------------------------------------------------------

   In the previous section, you got the text field to work. In this section, you enhance
   the UI.


**Add a label to the text box**

   Every text box should have a label that lets users know what information they can enter.
   In the first part of the following example image, the label text is in the middle of a
   text field and aligned with the input line. In the second part of the following example
   image, the label is moved higher in the text box when the user clicks in the text box to
   enter text. To learn more about text-field anatomy, see
   `Anatomy <https://material.io/components/text-fields#anatomy>`__.

   |a2afd6c7fc547b06.png|

   Modify the ``EditNumberField()`` function to add a label to the text field:

   1. In the ``EditNumberField()`` function's ``TextField()`` composable function , add a
      ``label`` named parameter set to an empty lambda expression:

   .. code:: prettyprint

      TextField(
      //...
         label = { }
      )

   2. In the lambda expression, call the ``Text()`` function that accepts a
      *``stringResource``*\ ``(R.string.``\ *``bill_amount``*\ ``)``:

   .. code:: prettyprint

      label = { Text(stringResource(R.string.bill_amount)) },

   3. In the ``TextField()`` composable function, add ``singleLine`` named parameter set to
      a ``true`` value:

   .. code:: prettyprint

      TextField(
        // ...
         singleLine = true,
      )

   This condenses the text box to a single, horizontally scrollable line from multiple
   lines.

   4. Add the ``keyboardOptions`` parameter set to a ``KeyboardOptions()``:

   .. code:: prettyprint

      import androidx.compose.foundation.text.KeyboardOptions

      TextField(
        // ...
         keyboardOptions = KeyboardOptions(),
      )

   Android provides an option to configure the keyboard displayed on the screen to enter
   digits, email addresses, URLs, and passwords, to name a few. To learn more about other
   keyboard types, see
   `KeyboardType <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/text/input/KeyboardType>`__.

   5. Set the keyboard type to number keyboard to input digits. Pass the
      ``KeyboardOptions`` function a ``keyboardType`` named parameter set to a
      ``KeyboardType.Number``:

   .. code:: prettyprint

      import androidx.compose.ui.text.input.KeyboardType

      TextField(
        // ...
         keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
      )

   The completed ``EditNumberField()`` function should look like this code snippet:

   .. code:: prettyprint

      @Composable
      fun EditNumberField(modifier: Modifier = Modifier) {
          var amountInput by remember { mutableStateOf("") }
          TextField(
              value = amountInput,
              onValueChange = { amountInput = it },
              singleLine = true,
              label = { Text(stringResource(R.string.bill_amount)) },
              keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
              modifier = modifier
          )
      }

   6. Run the app.

   You can see the changes to the keypad in this screenshot:

   |55936268bf007ee9.png|


9. Display the tip amount
--------------------------------------------------------------------------------

   In this section, you implement the main functionality of the app, which is the ability
   to calculate and display the tip amount.

   In the ``MainActivity.kt`` file, a ``private`` ``calculateTip()`` function is given to
   you as part of the starter code. You will use this function to calculate the tip amount:

   .. code:: prettyprint

      private fun calculateTip(amount: Double, tipPercent: Double = 15.0): String {
          val tip = tipPercent / 100 * amount
          return NumberFormat.getCurrencyInstance().format(tip)
      }

   In the above method you are using
   `NumberFormat <https://developer.android.google.cn/reference/java/text/NumberFormat>`__
   to display the format of the tip as currency.

   Now your app can calculate the tip, but you still need to format and display it with the
   class.


Use the ``calculateTip()`` function

   The text entered by the user in the text field composable is returned to the
   ``onValueChange`` callback function as a ``String`` even though the user entered a
   number. To fix this, you need to convert the ``amountInput`` value, which contains the
   amount entered by the user.

   1. In ``EditNumberField()`` composable function, create a new variable called ``amount``
      after the ``amountInput`` definition. Call the
      `toDoubleOrNull <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-double-or-null.html>`__
      function on the ``amountInput`` variable, to convert the ``String`` to a ``Double``:

   .. code:: prettyprint

      val amount = amountInput.toDoubleOrNull()

   The ``toDoubleOrNull()`` function is a predefined Kotlin function that parses a string
   as a ``Double`` number and returns the result or ``null`` if the string isn't a valid
   representation of a number.

   2. At the end of the statement, add an ``?:`` Elvis operator that returns a ``0.0``
      value when ``amountInput`` is null:

   .. code:: prettyprint

      val amount = amountInput.toDoubleOrNull() ?: 0.0

   **Note**: The ``?:`` Elvis operator returns the expression that precedes it if the value
   isn't ``null`` and the expression that proceeds it when the value is ``null``. It lets
   you write this code more idiomatically. For more information, see `Elvis
   operator <https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator>`__.

   3. After the ``amount`` variable, create another ``val`` variable called ``tip``.
      Initialize it with the ``calculateTip()``, passing the ``amount`` parameter.

   .. code:: prettyprint

      val tip = calculateTip(amount)

   The ``EditNumberField()`` function should look like this code snippet:

   .. code:: prettyprint

      @Composable
      fun EditNumberField(modifier: Modifier = Modifier) {
         var amountInput by remember { mutableStateOf("") }

         val amount = amountInput.toDoubleOrNull() ?: 0.0
         val tip = calculateTip(amount)

         TextField(
             value = amountInput,
             onValueChange = { amountInput = it },
             label = { Text(stringResource(R.string.bill_amount)) },
             modifier = Modifier.fillMaxWidth(),
             singleLine = true,
             keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
         )
      }


Show the calculated tip amount

   You have written the function to calculate the tip amount, the next step is to display
   the calculated tip amount:

   1. In the ``TipTimeLayout()`` function at the end of the ``Column()`` block, notice the
      text composable that displays ``$0.00``. You will update this value to the calculated
      tip amount.

   .. code:: prettyprint

      @Composable
      fun TipTimeLayout() {
          Column(
              modifier = Modifier
                  .statusBarsPadding()
                  .padding(horizontal = 40.dp)
                  .verticalScroll(rememberScrollState())
                  .safeDrawingPadding(),
              horizontalAlignment = Alignment.CenterHorizontally,
              verticalArrangement = Arrangement.Center
          ) {
              // ...
              Text(
                  text = stringResource(R.string.tip_amount, "$0.00"),
                  style = MaterialTheme.typography.displaySmall
              )
              // ...
          }
      }

   You need to access the ``amountInput`` variable in the ``TipTimeLayout()`` function to
   calculate and display the tip amount, but the ``amountInput`` variable is the state of
   the text field defined in the ``EditNumberField()`` composable function, so you can't
   call it from the ``TipTimeLayout()`` function yet. This image illustrates the structure
   of the code:

   |50bf0b9d18ede6be.png|

   This structure won't let you display the tip amount in the new ``Text`` composable
   because the ``Text`` composable needs to access the ``amount`` variable calculated from
   the ``amountInput`` variable. You need to expose the ``amount`` variable to the
   ``TipTimeLayout()`` function. This image illustrates the desired code structure, which
   makes the ``EditNumberField()`` composable stateless:

   |ab4ec72388149f7c.png|

   This pattern is called *state hoisting*. In the next section, you *hoist*, or lift, the
   state from a composable to make it stateless.

   **Note:** A stateless composable is a composable â€‹â€‹that doesn't store its own state. It
   displays whatever state it's given as input arguments.


10. State hoisting
--------------------------------------------------------------------------------

   In this section, you learn how to decide where to define your state in a way that you
   can reuse and share your composables.

   In a composable function, you can define variables that hold state to display in the UI.
   For example, you defined the ``amountInput`` variable as state in the
   ``EditNumberField()`` composable.

   When your app becomes more complex and other composables need access to the state within
   the ``EditNumberField()`` composable, you need to consider hoisting, or extracting, the
   state out of the ``EditNumberField()`` composable function.


Understand stateful versus stateless **composables**

   You should hoist the state when you need to:

   -  Share the state with multiple composable functions.
   -  Create a stateless composable that can be reused in your app.

   When you extract state from a composable function, the resulting composable function is
   called stateless. That is, composable functions can be made stateless by extracting
   state from them.

   A *stateless* composable is a composable that doesn't have a state, meaning it doesn't
   hold, define, or modify a new state. On the other hand, a *stateful* composable is a
   composable that owns a piece of state that can change over time.

   **Note:** In real apps, having a 100% stateless composable can be difficult to achieve
   depending on the composable's responsibilities. You should design your composables in a
   way that they will own as little state as possible and allow the state to be hoisted
   when it makes sense, by exposing it in the composable's API.

   State hoisting is a pattern of moving state to its caller to make a component stateless.

   When applied to composables, this often means introducing two parameters to the
   composable:

   -  A ``value: T`` parameter, which is the current value to display.
   -  An ``onValueChange: (T) -> Unit`` â€“ callback lambda, which is triggered when the
      value changes so that the state can be updated elsewhere, such as when a user enters
      some text in the text box.

   Hoist the state in ``EditNumberField()`` function:

   1. Update the ``EditNumberField()`` function definition, to hoist the state by adding
      the ``value`` and ``onValueChange`` parameters:

   .. code:: prettyprint

      @Composable
      fun EditNumberField(
         value: String,
         onValueChange: (String) -> Unit,
         modifier: Modifier = Modifier
      ) {
      //...

   The ``value`` parameter is of ``String`` type, and the ``onValueChange`` parameter is of
   ``(String) -> Unit`` type, so it's a function that takes a ``String`` value as input and
   has no return value. The ``onValueChange`` parameter is used as the ``onValueChange``
   callback passed into the ``TextField`` composable.

   **Note:** The best practice is to provide a default
   `Modifier <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier>`__
   parameter to all composable functions, which increases reusability. You should add it as
   the first optional parameter after all required parameters.

   2. In the ``EditNumberField()`` function, update the ``TextField()`` composable function
      to use the passed in parameters:

   .. code:: prettyprint

      TextField(
         value = value,
         onValueChange = onValueChange,
         // Rest of the code
      )

   3. Hoist the state, move the remembered state from the ``EditNumberField()``\ function
      to the ``TipTimeLayout()`` function:

   .. code:: prettyprint

      @Composable
      fun TipTimeLayout() {
         var amountInput by remember { mutableStateOf("") }

         val amount = amountInput.toDoubleOrNull() ?: 0.0
         val tip = calculateTip(amount)
        
         Column(
             //...
         ) {
             //...
         }
      }

   4. You hoisted the state to ``TipTimeLayout()``, now pass it to ``EditNumberField()``.
      In the ``TipTimeLayout()`` function, update the *``EditNumberField``*\ ``()``
      function call to use the hoisted state:

   .. code:: prettyprint

      EditNumberField(
         value = amountInput,
         onValueChange = { amountInput = it },
         modifier = Modifier
             .padding(bottom = 32.dp)
             .fillMaxWidth()
      )

   This makes *``EditNumberField``* stateless. You hoisted the UI state to its ancestor,
   ``TipTimeLayout()``. The ``TipTimeLayout()`` is the state(``amountInput``) owner now.


**Positional formatting**

   Positional formatting is used to display dynamic content in strings. For example,
   imagine that you want the **Tip amount** text box to display an ``xx.xx`` value that
   could be any amount calculated and formatted in your function. To accomplish this in the
   ``strings.xml`` file, you need to define the string resource with a placeholder
   argument, like this code snippet:

   .. code:: prettyprint

      // No need to copy.

      // In the res/values/strings.xml file
      <string name="tip_amount">Tip Amount: %s</string>

   In the compose code, you can have multiple, and any type of, placeholder arguments. A
   ``string`` placeholder is ``%s``.

   Notice the text composable in ``TipTimeLayout()``, you pass in the formatted tip as an
   argument to the ``stringResource()`` function.

   .. code:: prettyprint

      // No need to copy
      Text(
         text = stringResource(R.string.tip_amount, "$0.00"),
         style = MaterialTheme.typography.displaySmall
      )

   1. In the function, ``TipTimeLayout()``, use the ``tip`` property to display the tip
      amount. Update the ``Text`` composable's ``text`` parameter to use the ``tip``
      variable as a parameter.

   .. code:: prettyprint

      Text(
           text = stringResource(R.string.tip_amount, tip),
           // ...

   The completed ``TipTimeLayout()`` and ``EditNumberField()`` functions should look like
   this code snippet:

   .. code:: prettyprint

      @Composable
      fun TipTimeLayout() {
         var amountInput by remember { mutableStateOf("") }
         val amount = amountInput.toDoubleOrNull() ?: 0.0
         val tip = calculateTip(amount)

         Column(
             modifier = Modifier
                  .statusBarsPadding()
                  .padding(horizontal = 40.dp)
                  .verticalScroll(rememberScrollState())
                  .safeDrawingPadding(),
             horizontalAlignment = Alignment.CenterHorizontally,
             verticalArrangement = Arrangement.Center
         ) {
             Text(
                 text = stringResource(R.string.calculate_tip),
                 modifier = Modifier
                     .padding(bottom = 16.dp, top = 40.dp)
                     .align(alignment = Alignment.Start)
             )
             EditNumberField(
                 value = amountInput,
                 onValueChange = { amountInput = it },
                 modifier = Modifier
                     .padding(bottom = 32.dp)
                     .fillMaxWidth()
             )
             Text(
                 text = stringResource(R.string.tip_amount, tip),
                 style = MaterialTheme.typography.displaySmall
             )
             Spacer(modifier = Modifier.height(150.dp))
         }
      }

      @Composable
      fun EditNumberField(
         value: String,
         onValueChange: (String) -> Unit,
         modifier: Modifier = Modifier
      ) {
         TextField(
             value = value,
             onValueChange = onValueChange,
             singleLine = true,
             label = { Text(stringResource(R.string.bill_amount)) },
             keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
             modifier = modifier
         )
      }

   To summarize, you hoisted the ``amountInput`` state from the ``EditNumberField()`` into
   the ``TipTimeLayout()`` composable. For the text box to work as before, you have to pass
   in two arguments to the ``EditNumberField()`` composable function: the ``amountInput``
   value and the lambda callback that updates the ``amountInput`` value from the user's
   input. These changes let you calculate the tip from the ``amountInput`` property in the
   ``TipTimeLayout()`` to display it to the user.

   2. Run the app on the emulator or device and then enter a value in the **bill amount**
      text box. The tip amount of 15 percent of the bill amount is displayed as you can see
      in this image:

   |de593783dc813e24.png|


11. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator.git
      $ cd basic-android-kotlin-compose-training-tip-calculator
      $ git checkout state

   Alternatively you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `file_downloadDownload zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator/archive/refs/heads/state.zip>`__

   **Note:** The solution code is in the ``state`` branch of the downloaded repository.

   If you want to see the solution code, `view it on GitHub <https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator/tree/state>`__.


12. Conclusion
--------------------------------------------------------------------------------

   Congratulations! You completed this codelab and learned how to use state in a Compose
   app!


Summary

   -  State in an app is any value that can change over time.
   -  The *Composition* is a description of the UI built by Compose when it executes
      composables. Compose apps call composable functions to transform data into UI.
   -  Initial composition is a creation of the UI by Compose when it executes composable
      functions the first time.
   -  Recomposition is the process of running the same composables again to update the tree
      when their data changes.
   -  State hoisting is a pattern of moving state to its caller to make a component
      stateless.


**Learn more**

   -  `State and Jetpack Compose <https://developer.android.google.cn/jetpack/compose/state>`__
   -  `State in Jetpack Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-state>`__
   -  `Thinking in Compose <https://developer.android.google.cn/jetpack/compose/mental-model>`__
   -  `Jetpack Compose: State <https://youtu.be/mymWGMy9pYI>`__
   -  `A Compose state of mind: Using Compose's automatic state observation <https://www.youtube.com/watch?v=rmv2ug-wW4U>`__
   -  `Where to hoist state \| Compose \| Android Developers <https://developer.android.google.cn/jetpack/compose/state-hoisting>`__

.. |e82cbb534872abcf.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/e82cbb534872abcf.png
.. |46bf4366edc1055f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/46bf4366edc1055f.png
.. |18da3c120daa0759.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/18da3c120daa0759.png
.. |c0980ba3e9ebba02.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/c0980ba3e9ebba02.png
.. |9819649900a3a6f5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/9819649900a3a6f5.png
.. |e85b767a43c69a97.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/e85b767a43c69a97.png
.. |ae11354e61d2a2b9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/ae11354e61d2a2b9.png
.. |58671affa01fb9e1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/58671affa01fb9e1.png
.. |9819649900a3a6f5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/678d911263888d8f.png
.. |678d911263888d8f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/ee8d440a5ed6bc6d.png
.. |f658ec4a43ef365b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/f658ec4a43ef365b.png
.. |Phone screen with gmail app with a text field for email| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/2847d588a84cec09.png
.. |2c208378cd4b8d41.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/2c208378cd4b8d41.png
.. |e8e24821adfd9d8c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/e8e24821adfd9d8c.png
.. |3a2c62f8ec55e339.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/3a2c62f8ec55e339.gif
.. |b651ccb43a6fd25.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/b651ccb43a6fd25.png
.. |bad619de4ecfefc.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/bad619de4ecfefc.png
.. |59ac301a208b47c4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/59ac301a208b47c4.png
.. |154e060231439307.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/154e060231439307.png
.. |2a29a3bad712bec.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/2a29a3bad712bec.png
.. |1d5e08d32052d02e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/1d5e08d32052d02e.png
.. |1f5db6ab5ca5b477.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/1f5db6ab5ca5b477.png
.. |a2afd6c7fc547b06.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/a2afd6c7fc547b06.png
.. |55936268bf007ee9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/55936268bf007ee9.png
.. |50bf0b9d18ede6be.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/50bf0b9d18ede6be.png
.. |ab4ec72388149f7c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/ab4ec72388149f7c.png
.. |de593783dc813e24.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-using-state/img/de593783dc813e24.png


ğŸš€ Calculate a custom tip
==========================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-calculate-tip


1. Before you begin

   In this codelab, you use the solution code from the `Intro to state in Compose <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-using-state#0>`__
   codelab to build an interactive tip calculator that can automatically calculate and round a tip
   amount when you enter the bill amount and tip percentage. You can see the final app in this
   image:

   |d8e768525099378a.png|


Prerequisites

   -  The `Intro to state in Compose codelab. <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-using-state#0>`__
   -  Ability to add ``Text`` and ``TextField`` composables to an app.
   -  Knowledge of the ``remember()`` function, state, state hoisting, and the difference between
      stateful and stateless composable functions.


What you'll learn

   -  How to add an action button to a virtual keyboard.
   -  What a ``Switch`` composable is and how to use it.
   -  Add leading icons to the text fields.


**What you'll build**

   -  A Tip Time app that calculates tip amounts based on the user's inputted bill amount and tip
      percentage.


**What you'll need**

   -  The latest version of `Android Studio <https://developer.android.google.cn/studio>`__
   -  The solution code from the `Intro to state in Compose codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-using-state#12>`__


2. Get the starter code

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator/archive/refs/heads/state.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator.git
      $ cd basic-android-kotlin-compose-training-tip-calculator
      $ git checkout state

   **Note:** The starter code is in the ``state`` branch of the downloaded repository.

   You can browse the code in the `Tip Time GitHub repository. <https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator/tree/state>`__


3. Starter app overview

   This codelab begins with the Tip Time app from the previous codelab 
   `Intro to state in Compose <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-using-state>`__,
   which provides the user interface needed to calculate a tip with a fixed tip percentage. The
   **Bill amount** text box lets the user enter the cost of the service. The app calculates and
   displays the tip amount in a ``Text`` composable.


**Run the Tip Time App**

   1. Open the Tip Time project in Android Studio and run the app on an emulator or a device.
   2. Enter a bill amount. The app automatically calculates and displays the tip amount.

   |b6bd5374911410ac.png|

   In the current implementation, the percentage of the tip is hardcoded to 15%. In this codelab,
   you extend this feature with a text field that lets the app calculate a custom tip percentage and
   round the tip amount.


Add necessary string resources

   1. In the **Project** tab, click **res > values > strings.xml**.
   2. In between the ``strings.xml`` file's ``<resources>`` tags, add these string resources:

   .. code:: prettyprint

      <string name="how_was_the_service">Tip Percentage</string>
      <string name="round_up_tip">Round up tip?</string>

   The ``strings.xml`` file should look like this code snippet, which includes the strings from the
   previous codelab:

   **``strings.xml``**

   .. code:: prettyprint

      <resources>
          <string name="app_name">Tip Time</string>
          <string name="calculate_tip">Calculate Tip</string>
          <string name="bill_amount">Bill Amount</string>
          <string name="how_was_the_service">Tip Percentage</string>
          <string name="round_up_tip">Round up tip?</string>
          <string name="tip_amount">Tip Amount: %s</string>
      </resources>


4. Add a tip-percentage text field

   A customer may want to tip more or less based on the quality of the service provided and various
   other reasons. To accommodate this, the app should let the user calculate a custom tip. In this
   section, you add a text field for the user to enter a custom tip percentage as you can see in
   this image:

   |391b4b1a090687ef.png|

   You already have a **Bill Amount** text field composable in your app, which is the stateless
   ``EditNumberField()`` composable function. In the previous codelab, you hoisted the
   ``amountInput`` state from the ``EditNumberField()`` composable to the ``TipTimeLayout()``
   composable, which made the ``EditNumberField()`` composable stateless.

   To add a text field, you can reuse the same ``EditNumberField()`` composable, but with a
   different label. To make this change, you need to pass in the label as a parameter, rather than
   hard coded it inside the ``EditNumberField()`` composable function.

   Make the ``EditNumberField()`` composable function reusable:

   1. In the ``MainActivity.kt`` file in the ``EditNumberField()`` composable function's parameters,
      add a ``label`` string resource of ``Int`` type:

   .. code:: prettyprint

      @Composable
      fun EditNumberField(
          label: Int,
          value: String,
          onValueChanged: (String) -> Unit,
          modifier: Modifier = Modifier
      )

   **Note:** The best practice is to provide a default `Modifier <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier>`__
   parameter to all composable functions, which increases reusability. You should add it as the
   first optional parameter after all required parameters.

   2. In the function body, replace the hardcoded string resource ID with the ``label`` parameter:

   .. code:: prettyprint

      @Composable
      fun EditNumberField(
          //...
      ) {
           TextField(
               //...
               label = { Text(stringResource(label)) },
               //...
           )
      }

   3. To denote that the ``label`` parameter is expected to be a string resource reference, annotate
      the function parameter with the ``@StringRes`` annotation:

   .. code:: prettyprint

      @Composable
      fun EditNumberField(
          @StringRes label: Int,
          value: String,
          onValueChanged: (String) -> Unit,
          modifier: Modifier = Modifier
      ) 

   **Note:** An example of a string resource reference is the ``R.string.bill_amount``.

   4. Import the following:

   .. code:: prettyprint

      import androidx.annotation.StringRes

   **Note:** The ``@StringRes`` annotation is a type-safe way to use string resources. It indicates
   that the integer to be passed is a string resource from the ``values/strings.xml`` file. These
   annotations are useful to developers who work on your code and for code-inspection tools like `lint <https://developer.android.google.cn/studio/write/lint>`__
   in Android Studio. You learn more about lint in a future codelab.

   5. In the ``TipTimeLayout()`` composable function's ``EditNumberField()`` function call, set the
      ``label`` parameter to the ``R.string.bill_amount`` string resource:

   .. code:: prettyprint

      EditNumberField(
          label = R.string.bill_amount,
          value = amountInput,
          onValueChanged = { amountInput = it },
          modifier = Modifier.padding(bottom = 32.dp).fillMaxWidth()
      )

   6. In the **Preview** pane there should not be any visual changes.

   |b223d5ba4a54f792.png|

   7. In the ``TipTimeLayout()`` composable function after the ``EditNumberField()`` function call,
      add another text field for the custom tip percentage. Make a call to the ``EditNumberField()``
      composable function with these parameters:

   .. code:: prettyprint

      EditNumberField(
          label = R.string.how_was_the_service,
          value = "",
          onValueChanged = { },
          modifier = Modifier.padding(bottom = 32.dp).fillMaxWidth()
      )

   This adds another text box for the custom tip percentage.

   8. The app preview now shows a **Tip Percentage** text field as you can see in this image:

   |a5f5ef5e456e185e.png|

   9. At the top of the ``TipTimeLayout()`` composable function, add a ``var`` property called
      ``tipInput`` for the added text field's state variable. Use ``mutableStateOf("")`` to
      initialize the variable and surround the call with ``remember`` function:

   .. code:: prettyprint

      var tipInput by remember { mutableStateOf("") }

   10. In the new ``EditNumberField()`` function call, set the ``value`` named parameter to
       the ``tipInput`` variable and then update the ``tipInput`` variable in the ``onValueChanged``
       lambda expression:

   .. code:: prettyprint

      EditNumberField(
          label = R.string.how_was_the_service,
          value = tipInput,
          onValueChanged = { tipInput = it },
          modifier = Modifier.padding(bottom = 32.dp).fillMaxWidth()
      )

   11. In the ``TipTimeLayout()`` function after the ``tipInput`` variable's definition. Define a
       ``val`` named ``tipPercent`` that converts the ``tipInput`` variable to a ``Double`` type.
       Use an Elvis operator and return ``0``, if the value is ``null``. This value could be
       ``null`` if the text field is empty.

   .. code:: prettyprint

      val tipPercent = tipInput.toDoubleOrNull() ?: 0.0

   12. In the ``TipTimeLayout()`` function, update the ``calculateTip()`` function call, pass in the
       ``tipPercent`` variable as the second parameter:

   .. code:: prettyprint

      val tip = calculateTip(amount, tipPercent)

   The code for the ``TipTimeLayout()`` function should look like this code snippet now:

   .. code:: prettyprint

      @Composable
      fun TipTimeLayout() {
          var amountInput by remember { mutableStateOf("") }
          var tipInput by remember { mutableStateOf("") }
          val amount = amountInput.toDoubleOrNull() ?: 0.0
          val tipPercent = tipInput.toDoubleOrNull() ?: 0.0

          val tip = calculateTip(amount, tipPercent)
          Column(
              modifier = Modifier.padding(40.dp),
              horizontalAlignment = Alignment.CenterHorizontally,
              verticalArrangement = Arrangement.Center
          ) {
              Text(
                  text = stringResource(R.string.calculate_tip),
                  modifier = Modifier
                      .padding(bottom = 16.dp)
                      .align(alignment = Alignment.Start)
              )
              EditNumberField(
                  label = R.string.bill_amount,
                  value = amountInput,
                  onValueChanged = { amountInput = it },
                  modifier = Modifier
                      .padding(bottom = 32.dp)
                      .fillMaxWidth()
              )
              EditNumberField(
                  label = R.string.how_was_the_service,
                  value = tipInput,
                  onValueChanged = { tipInput = it },
                  modifier = Modifier
                      .padding(bottom = 32.dp)
                      .fillMaxWidth()
              )
              Text(
                  text = stringResource(R.string.tip_amount, tip),
                  style = MaterialTheme.typography.displaySmall
              )
              Spacer(modifier = Modifier.height(150.dp))
          }
      }

   13. Run the app on an emulator or a device, and then enter a bill amount and the tip percentage.
       Does the app calculate tip amount correctly?

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/23fc1e924d9963bc.png

      screen shot with bill amount as 100 tip percentage as 20 and the tip amount is shown as 20 dollars


5. Set an action button

   In the previous codelab, you explored how to use the ``KeyboardOptions`` class to set the type of
   the keyboard. In this section, you explore how to set the keyboard action button with the same
   ``KeyboardOptions``. A keyboard action button is a button at the end of the keyboard. You can see
   some examples in this table:

   +-------------------------------------------------+-------------------------------------------------+
   | **Property**                                    | **Action button on the keyboard**               |
   +-------------------------------------------------+-------------------------------------------------+
   | `ImeAction.Search`_                             | The image represents the Search icon to         |
   | Used when the user wants to execute a search.   | execute a search.                               |
   |                                                 | |67fd7f2efed7e677.png|                          |
   +-------------------------------------------------+-------------------------------------------------+
   | `ImeAction.Send`_                               | The image represents the Send icon to send the  |
   | Used when the user wants to send the text in    | text in the input field.                        |
   | the input field.                                | |b19be317a5574818.png|                          |
   +-------------------------------------------------+-------------------------------------------------+
   | `ImeAction.Go`_                                 | The image represents the Go icon to navigate    |
   | Used when the user wants to navigate to the     | to the target of the text in the input.         |
   | target of the text in the input.                | |ac61541c3a56b2bb.png|                          |
   +-------------------------------------------------+-------------------------------------------------+

.. |67fd7f2efed7e677.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/67fd7f2efed7e677.png
.. |b19be317a5574818.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/b19be317a5574818.png
.. |ac61541c3a56b2bb.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/ac61541c3a56b2bb.png

.. _ImeAction.Go: https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Go()
.. _ImeAction.Send: https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Send()
.. _ImeAction.Search: https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Search()

   In this task, you set two different action buttons for the text boxes:

   -  A **Next** action button for the **Bill Amount** text box, which indicates that the user is
      done with the current input and wants to move to the next text box.
   -  A **Done** action button for the **Tip Percentage** text box, which indicates that the user
      finished providing input.

   You can see examples of keyboards with these action buttons in these images:

   ====================== ======================
   |46559a252132af44.png| |b8972b81b513b0a.png|
   ====================== ======================

   Add keyboard options:

   1. In the ``EditNumberField()`` function's ``TextField()`` function call, pass the
      ``KeyboardOptions`` constructor an ``imeAction`` named argument set to an ``ImeAction.Next``
      value. Use the
      ```KeyboardOptions.Default.copy()`` <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/text/KeyboardOptions#copy(androidx.compose.ui.text.input.KeyboardCapitalization,kotlin.Boolean,androidx.compose.ui.text.input.KeyboardType,androidx.compose.ui.text.input.ImeAction)>`__
      function to make sure you use the other default options.

   .. code:: prettyprint

      import androidx.compose.ui.text.input.ImeAction


      @Composable
      fun EditNumberField(
          //...
      ) {
          TextField(
              //...
              keyboardOptions = KeyboardOptions.Default.copy(
                  keyboardType = KeyboardType.Number,
                  imeAction = ImeAction.Next
              )
          )
      }

   2. Run the app on an emulator or a device. The keyboard now displays the **Next** action button
      as you can see in this image:

   |82574a95b658f052.png|

   Notice the keyboard displays the same **Next** action button when the **Tip Percentage** text
   field is selected. However, you want two different action buttons for the text fields. You fix
   this problem shortly.

   3. Examine the ``EditNumberField()`` function. The ``keyboardOptions`` parameter in the
      ``TextField()`` function is hardcoded. To create different action buttons for the text fields,
      you need to pass in the ``KeyboardOptions`` object as an argument, which you will do in the
      next step.

   .. code:: prettyprint

      // No need to copy, just examine the code.
      fun EditNumberField(
          @StringRes label: Int,
          value: String,
          onValueChanged: (String) -> Unit,
          modifier: Modifier = Modifier
      ) {
          TextField(
              //...
              keyboardOptions = KeyboardOptions.Default.copy(
                 keyboardType = KeyboardType.Number,
                 imeAction = ImeAction.Next
              )
          )
      }

   4. In the ``EditNumberField()`` function definition, add a ``keyboardOptions`` parameter of type
      ``KeyboardOptions`` type. In the function body, assign it to the ``TextField()`` function's
      ``keyboardOptions`` named parameter:

   .. code:: prettyprint

      @Composable
      fun EditNumberField(
          @StringRes label: Int,
          keyboardOptions: KeyboardOptions,
          // ...
      ){
          TextField(
              //...
              keyboardOptions = keyboardOptions
          )
      }

   5. In the ``TipTimeLayout()`` function, update the first ``EditNumberField()`` function call,
      pass in the ``keyboardOptions`` named parameter for the **Bill Amount** text field:

   .. code:: prettyprint

      EditNumberField(
          label = R.string.bill_amount,
          keyboardOptions = KeyboardOptions.Default.copy(
              keyboardType = KeyboardType.Number,
              imeAction = ImeAction.Next
          ),
          // ...
      )

   6. In the second ``EditNumberField()`` function call, change the **Tip Percentage** text field's
      ``imeAction`` to ``ImeAction.Done``. Your function should look like this code snippet:

   .. code:: prettyprint

      EditNumberField(
          label = R.string.how_was_the_service,
          keyboardOptions = KeyboardOptions.Default.copy(
              keyboardType = KeyboardType.Number,
              imeAction = ImeAction.Done
          ),
          // ...
      )

   7. Run the app. It displays the **Next** and **Done** action buttons as you can see in these
      images:

   ====================== ======================
   |82574a95b658f052.png| |a87ef38535796bb1.png|
   ====================== ======================

   8. Enter any bill amount and click the **Next** action button, and then enter any tip percentage
      and click the **Done** action button. That closes the keypad.

   |a9e3fbddfff829c8.gif|


6. Add a switch

   A switch toggles the state of a single item on or off.

   |6923dfb1101602c7.png|

   There are two-states in a toggle that let the user select between two options. A toggle consists
   of a track, thumb and an optional icon as you can see in these images:

   |b4f7f68b848bcc2b.png|

   Switch is a selection control that can be used to enter decisions or declare preferences, such as
   settings as you can see in this image:

   |5cd8acb912ab38eb.png|

   The user may drag the *thumb* back and forth to choose the selected option, or simply tap the
   switch to toggle. You can see another example of a toggle in this GIF in which the Visual options
   setting is toggled to **Dark mode**:

   |eabf96ad496fd226.gif|

   To learn more about switches, see the
   `Switches <https://m3.material.io/components/switch/overview>`__ documentation.

   You use the ``Switch`` composable so that the user can choose whether to round up the tip to the
   nearest whole number as you can see in this image:

   |b42af9f2d3861e4.png|

   Add a row for the ``Text`` and ``Switch`` composables:

   1. After the ``EditNumberField()`` function, add a ``RoundTheTipRow()`` composable function and
      then pass in a default ``Modifier``, as arguments similar to the ``EditNumberField()``
      function:

   .. code:: prettyprint

      @Composable
      fun RoundTheTipRow(modifier: Modifier = Modifier) {
      }

   2. Implement the ``RoundTheTipRow()`` function, add a ``Row`` layout composable with the
      following ``modifier`` to set the child elements' width to the maximum on the screen, center
      the alignment, and ensure a ``48dp`` size:

   .. code:: prettyprint

      Row(
         modifier = modifier
             .fillMaxWidth()
             .size(48.dp),
         verticalAlignment = Alignment.CenterVertically
      ) {
      }

   3. Import the following:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Row
      import androidx.compose.foundation.layout.size

   4. In the ``Row`` layout composable's lambda block, add a ``Text`` composable that uses the
      ``R.string.round_up_tip`` string resource to display a ``Round up tip?`` string:

   .. code:: prettyprint

      Text(text = stringResource(R.string.round_up_tip))

   5. After the ``Text`` composable, add a ``Switch`` composable, and pass a ``checked`` named
      parameter set it to ``roundUp`` and an ``onCheckedChange`` named parameter set it to
      ``onRoundUpChanged``.

   .. code:: prettyprint

      Switch(
          checked = roundUp,
          onCheckedChange = onRoundUpChanged,
      )

   This table contains information about these parameters, which are the same parameters that you
   defined for the ``RoundTheTipRow()`` function:

   =================== ==============================================================================
   **Parameter**       **Description**
   ``checked``         Whether the switch is checked. This is the state of the ``Switch`` composable.
   ``onCheckedChange`` The callback to be called when the switch is clicked.
   =================== ==============================================================================

   6. Import the following:

   .. code:: prettyprint

      import androidx.compose.material3.Switch

   7. In the ``RoundTheTipRow()`` function, add a ``roundUp`` parameter of ``Boolean`` type and an
      ``onRoundUpChanged`` lambda function that takes a ``Boolean`` and returns nothing:

   .. code:: prettyprint

      @Composable
      fun RoundTheTipRow(
          roundUp: Boolean,
          onRoundUpChanged: (Boolean) -> Unit,
          modifier: Modifier = Modifier
      )

   This hoists the switch's state.

   8. In the ``Switch`` composable, add this ``modifier`` to align the ``Switch`` composable to the
      end of the screen:

   .. code:: prettyprint

             Switch(
                 modifier = modifier
                     .fillMaxWidth()
                     .wrapContentWidth(Alignment.End),
                 //...
             )

   9. Import the following:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.wrapContentWidth

   10. In the ``TipTimeLayout()`` function, add a var variable for the ``Switch`` composable's
       state. Create a ``var`` variable named ``roundUp`` set it to ``mutableStateOf()``, with
       ``false`` as the initial value. Surround the call with ``remember { }``.

   .. code:: prettyprint

      fun TipTimeLayout() {
          //...
          var roundUp by remember { mutableStateOf(false) }

          //...
          Column(
              ...
          ) {
            //...
         }
      }

   This is the variable for the ``Switch`` composable state, and false will be the default state.

   11. In the ``TipTimeLayout()`` function's ``Column`` block after the **Tip Percentage** text
       field. Call the ``RoundTheTipRow()`` function with the following arguments: ``roundUp`` named
       parameter set to a ``roundUp`` and an ``onRoundUpChanged`` named parameter set to a lambda
       callback that updates the ``roundUp`` value:

   .. code:: prettyprint

      @Composable
      fun TipTimeLayout() {
          //...

          Column(
              ...
          ) {
              Text(
                  ...
              )
              Spacer(...)
              EditNumberField(
                  ...
              )
              EditNumberField(
                  ...
              )
              RoundTheTipRow(
                   roundUp = roundUp,
                   onRoundUpChanged = { roundUp = it },
                   modifier = Modifier.padding(bottom = 32.dp)
               )
              Text(
                  ...
              )
          }
      }

   This displays the **Round up tip?** row.

   12. Run the app. The app displays the **Round up tip?** toggle.

   |5225395a29022a5e.png|

   13. Enter a bill amount and tip percentage, and then select the **Round up tip?** toggle. The tip
       amount isn't rounded because you still need to update the ``calculateTip()`` function, which
       you do in the next section.


Update the ``calculateTip()`` function to round the tip

   Modify the ``calculateTip()`` function to accept a ``Boolean`` variable to 
   `round up <https://www.collinsdictionary.com/us/dictionary/english/round-up#:~:text=If%20you%20round%20an%20amount,or%20tip%20up%20to%2010%25.>`__
   the tip to the nearest integer:

   1. To round up the tip, the ``calculateTip()`` function should know the state of the switch,
      which is a ``Boolean``. In the ``calculateTip()`` function, add a ``roundUp`` parameter of
      ``Boolean`` type:

   .. code:: prettyprint

      private fun calculateTip(
          amount: Double,
          tipPercent: Double = 15.0,
          roundUp: Boolean
      ): String { 
          //...
      }

   2. In the ``calculateTip()`` function before the ``return`` statement, add an ``if()`` condition
      that checks the ``roundUp`` value. If the ``roundUp`` is ``true``, define a ``tip`` variable
      and set to ``kotlin.math.``\ *``ceil``*\ ``()`` function and then pass the function ``tip`` as
      argument:

   .. code:: prettyprint

      if (roundUp) {
          tip = kotlin.math.ceil(tip)
      }

   Android Studio shows you an error - ``val cannot be reassigned`` error, you need to change the
   ``tip`` variable to a ``var`` variable:

   ``var tip = tipPercent / 100 * amount``

   **Note:** The `kotlin.math.ceil(x) <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.math/ceil.html>`__
   function rounds the given value of an integer up. For example, it rounds 10.65 to 11.00. This
   function can take a ``Double`` or a ``Float`` number.

   The completed ``calculateTip()`` function should look like this code snippet:

   .. code:: prettyprint

      private fun calculateTip(amount: Double, tipPercent: Double = 15.0, roundUp: Boolean): String {
          var tip = tipPercent / 100 * amount
          if (roundUp) {
              tip = kotlin.math.ceil(tip)
          }
          return NumberFormat.getCurrencyInstance().format(tip)
      }

   3. In the ``TipTimeLayout()`` function, update the ``calculateTip()`` function call and then pass
      in a ``roundUp`` parameter:

   .. code:: prettyprint

      val tip = calculateTip(amount, tipPercent, roundUp)

   4. Run the app. Now it rounds up the tip amount as you can see in these images:

   ====================== ======================
   |caff187fc2c8c46.png|  |fe592cd5eea3a7b.png|
   ====================== ======================


7. Add support for landscape orientation

   Android devices come in a variety of form factorsâ€”phones, tablets, foldables, and ChromeOS
   devicesâ€”which have a wide range of screen sizes. Your app should support both orientations
   portrait and landscape.

   1. Test your app in landscape mode, turn on the Auto-rotate.

   |8566fc367d5a5b2f.png|

   2. Rotate your emulator or device left, notice you are not able to see the tip amount. To resolve
      this you will need a vertical scrollbar, that helps you scroll your app screen.

   |28d23a73c2a5ea24.png|

   3. Add ``.verticalScroll(rememberScrollState())`` to the modifier to enable the column to scroll
      vertically. The ``rememberScrollState()`` creates and automatically remembers the scroll
      state.

   .. code:: prettyprint

      @Composable
      fun TipTimeLayout() {
          // ...
          Column(
              modifier = Modifier
                  .padding(40.dp)
                  .verticalScroll(rememberScrollState()),
              horizontalAlignment = Alignment.CenterHorizontally,
              verticalArrangement = Arrangement.Center
          ) {
              //...
          }
      }

   4. Import the following:

   .. code:: prettyprint

      import androidx.compose.foundation.rememberScrollState
      import androidx.compose.foundation.verticalScroll

   5. Run the app again. Try scrolling in landscape mode!

   |179866a0fae00401.gif|


8. Add leading icon to text fields (optional)

   Icons can make the text field more visually appealing and provide additional information about
   the text field. Icons can be used to convey information about the purpose of the text field, such
   as what type of data is expected or what kind of input is required. For example, an icon of a
   phone next to a text field might indicate that the user is expected to enter a phone number.

   Icons can be used to guide the user's input by providing visual cues about what is expected. For
   example, an icon of a calendar next to a text field might indicate that the user is expected to
   enter a date.

   Following is an example of a text field with a search icon, indicating to enter the search term.

   |9318c9a2414c4add.png|

   Add another parameter to the ``EditNumberField()`` composable called ``leadingIcon`` of the type
   ``Int``. Annotate it with ``@DrawableRes``.

   .. code:: prettyprint

      @Composable
      fun EditNumberField(
          @StringRes label: Int,
          @DrawableRes leadingIcon: Int,
          keyboardOptions: KeyboardOptions,
          value: String,
          onValueChanged: (String) -> Unit,
          modifier: Modifier = Modifier
      ) 

   1. Import the following:

   .. code:: prettyprint

      import androidx.annotation.DrawableRes
      import androidx.compose.material3.Icon

   2. Add the leading icon to the text field. The ``leadingIcon`` takes a composable, you will pass
      in the following ``Icon`` composable.

   .. code:: prettyprint

      TextField(
          value = value,
          leadingIcon = { Icon(painter = painterResource(id = leadingIcon), null) },
          //...
      )

   3. Pass in the leading icon to the text fields. Icons are already present in the starter code for
      your convenience.

   .. code:: prettyprint

      EditNumberField(
          label = R.string.bill_amount,
          leadingIcon = R.drawable.money,
          // Other arguments
      )
      EditNumberField(
          label = R.string.how_was_the_service,
          leadingIcon = R.drawable.percent,
          // Other arguments
      )

   4. Run the app.

   |bff007b9d67ede83.png|

   Congratulations! Your app now has the capability to calculate custom tips.


9. Get the solution code

   To download the code for the finished codelab, you can use this git command:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator.git

   Alternatively you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the downloaded repository.

   If you want to see the solution code, `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-tip-calculator/tree/main>`__.


10. Conclusion

   Congratulations! You added custom tip functionality to your Tip Time app. Now your app lets users
   input a custom tip percentage and round up the tip amount. Share your work on social media with
   #AndroidBasics!


**Learn more**

   -  `Text fields â€“ Material Design 3 <https://m3.material.io/components/text-fields/guidelines#5c8a5f07-b1a5-455f-bf76-7ff0d724f6b0>`__
   -  `Switch â€“ Material Design 3 <https://m3.material.io/components/switch/overview>`__

.. |d8e768525099378a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/d8e768525099378a.png
.. |b6bd5374911410ac.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/b6bd5374911410ac.png
.. |391b4b1a090687ef.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/391b4b1a090687ef.png
.. |b223d5ba4a54f792.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/b223d5ba4a54f792.png
.. |a5f5ef5e456e185e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/a5f5ef5e456e185e.png
.. |46559a252132af44.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/46559a252132af44.png
.. |b8972b81b513b0a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/b8972b81b513b0a.png
.. |82574a95b658f052.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/82574a95b658f052.png
.. |a87ef38535796bb1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/a87ef38535796bb1.png
.. |a9e3fbddfff829c8.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/a9e3fbddfff829c8.gif
.. |6923dfb1101602c7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/6923dfb1101602c7.png
.. |b4f7f68b848bcc2b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/b4f7f68b848bcc2b.png
.. |5cd8acb912ab38eb.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/5cd8acb912ab38eb.png
.. |eabf96ad496fd226.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/eabf96ad496fd226.gif
.. |b42af9f2d3861e4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/b42af9f2d3861e4.png
.. |5225395a29022a5e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/5225395a29022a5e.png
.. |caff187fc2c8c46.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/caff187fc2c8c46.png
.. |fe592cd5eea3a7b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/fe592cd5eea3a7b.png
.. |8566fc367d5a5b2f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/8566fc367d5a5b2f.png
.. |28d23a73c2a5ea24.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/28d23a73c2a5ea24.png
.. |179866a0fae00401.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/179866a0fae00401.gif
.. |9318c9a2414c4add.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/9318c9a2414c4add.png
.. |bff007b9d67ede83.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-calculate-tip/img/bff007b9d67ede83.png


ğŸš€ Write automated tests
=========================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-write-automated-tests


1. Before you begin
--------------------------------------------------------------------------------

   This codelab teaches you about automated tests in Android, and how they let you write
   scalable and robust apps. You also become more familiar with the difference between 
   ``UI logic`` and ``business logic``, and how to test both. Finally, you learn how to write and run
   automated tests in Android Studio.


Prerequisites

   -  Ability to write an Android app with functions and composables.


**What you'll learn**

   -  What automated tests in Android do.
   -  Why automated tests are important.
   -  What a local test is and what it's used for.
   -  What an instrumentation test is and what it's used for.
   -  How to write local tests for Android code.
   -  How to write instrumentation tests for Android apps.
   -  How to run automated tests.


**What you'll build**

   -  A local test
   -  An instrumentation test


**What you'll need**

   -  The latest version of `Android Studio <https://developer.android.google.cn/studio>`__
   -  The solution code for the Tip Time app

2. Get the starter code
--------------------------------------------------------------------------------

   Download the code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator/archive/refs/heads/main.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator.git
      $ cd basic-android-kotlin-compose-training-tip-calculator
      $ git checkout main

   **Note:** The starter code is in the ``main`` branch of the downloaded repository.

3. Automated tests
--------------------------------------------------------------------------------

   Testing, for software, is a structured method of checking your software to make sure that
   it works as expected. Automated testing is code that checks to ensure that another piece of
   code that you wrote works correctly.

   Testing is an important part of the app development process. By running tests against your
   app consistently, you can verify your app's correctness, functional behavior, and usability
   before you release it publicly.

   Testing also provides a way to continuously check the existing code as changes are
   introduced.

   While manual testing almost always has a place, testing in Android can often be automated.
   Throughout the remaining course, you focus on automated tests to test the app code and the
   functional requirements of the app itself. In this codelab, you learn the very basics of
   testing in Android. In later codelabs, you learn more advanced practices of testing Android
   apps.

   As you become familiar with Android development and testing Android apps, you should make
   it a regular practice to write tests alongside your app code. Creating a test every time
   you create a new feature in your app reduces your workload later as your app grows. It also
   provides a convenient way for you to make sure your app works properly without spending too
   much time manually testing your app.

   Automated testing is an essential part of all software development and Android development
   is no exception. As such, there's no better time to introduce it than right now!


**Why automated tests are important**

   At first, it might seem like you don't really need tests in your app, but testing is needed
   in apps of all sizes and complexities.

   To grow your codebase, you need to test existing functionality as you add new pieces, which
   is only possible if you have existing tests. As your app grows, manual testing takes much
   more effort than automated testing. Furthermore, once you start working on apps in
   production, testing becomes critical when you have a large user base. For example, you must
   account for many different types of devices running many different versions of Android.

   Eventually, you reach a point where automated tests can account for the majority of usage
   scenarios significantly faster than manual tests. When you run tests before you release new
   code, you can make changes to the existing code so that you avoid the release of an app
   with unexpected behaviors.

   Remember that automated tests are tests executed through software, as opposed to manual
   tests, which are carried out by a person who directly interacts with a device. Automated
   testing and manual testing play a critical role in ensuring that users of your product have
   a pleasant experience. However, automated tests can be more precise and they optimize your
   team's productivity because a person isn't required to run them and they can be executed
   much faster than a manual test.


**Type of automated tests**

Local tests

   Local tests are a type of automated test that directly test a small piece of code to ensure
   that it functions properly. With local tests, you can test functions, classes, and
   properties. Local tests are executed on your workstation, which means they run in a
   development environment without the need for a device or emulator. This is a fancy way to
   say that local tests run on your computer. They also have very low overhead for computer
   resources, so they can run fast even with limited resources. Android Studio comes ready to
   run local tests automatically.


**Instrumentation tests**

   For Android development, an instrumentation test is a UI test. Instrumentation tests let
   you test parts of an app that depend on the Android API, and its platform APIs and
   services.

   Unlike local tests, UI tests launch an app or part of an app, simulate user interactions,
   and check whether the app reacted appropriately. Throughout this course, UI tests are run
   on a physical device or emulator.

   When you run an instrumentation test on Android, the test code is actually built into its
   own Android Application Package (APK) like a regular Android app. An APK is a compressed
   file that contains all the code and necessary files to run the app on a device or emulator.
   The test APK is installed on the device or emulator along with the regular app APK. The
   test APK then runs its tests against the app APK.

4. Write a local test
--------------------------------------------------------------------------------


**Prepare the app code**

   Local tests directly test methods from the app code, so the methods to be tested must be
   available to the testing classes and methods. The local test in the following code snippet
   ensures that the ``calculateTip()`` method works correctly, but the ``calculateTip()``
   method is currently ``private`` and thus not accessible from the test. Remove the
   ``private`` designation and make it ``internal``:

   **``MainActivity.kt``**

   .. code:: prettyprint

      internal fun calculateTip(amount: Double, tipPercent: Double = 15.0, roundUp: Boolean): String {
          var tip = tipPercent / 100 * amount
          if (roundUp) {
              tip = kotlin.math.ceil(tip)
          }
          return NumberFormat.getCurrencyInstance().format(tip)
      }

   -  In the ``MainActivity.kt`` file on the line before the ``calculateTip()`` method, add
      the ``@VisibleForTesting`` annotation:

   .. code:: prettyprint

      @VisibleForTesting
      internal fun calculateTip(amount: Double, tipPercent: Double = 15.0, roundUp: Boolean): String {
          var tip = tipPercent / 100 * amount
          if (roundUp) {
              tip = kotlin.math.ceil(tip)
          }
          return NumberFormat.getCurrencyInstance().format(tip)
      }

   This makes the method public, but indicates to others that it's only public for testing
   purposes.


Create the test directory

   In Android projects, the ``test`` directory is where local tests are written.

   Create the **test** directory:

   1. In the **Project** tab, change the view to Project.

   |a6b5eade0103eca9.png|

   2. Right click on the **src** directory.

   |d6bfede787910341.png|

   3. Select **New** > **Directory**

   |a457c469e7058234.png|

   4. In the **New Directory** window, select ****.

   |bd2c2ef635f0a392.png|

   5. Type the **return** or **enter** key on your keyboard. The **test** directory can now be
      seen in the **Project** tab.

   |d07872d354d8aa92.png|

   The **test** directory requires a package structure identical to that of the ``main``
   directory where your app code lives. In other words, just as your app code is written in
   the **main > java > com > example > tiptime** package, your local tests will be written in
   **test > java > com > example > tiptime**.

   Create this package structure in the **test** directory:

   1. Right click on the **test/java** directory and select **New > Package**.

   |99fcf5ff6cda7b57.png|

   2. In the **New Package** window, type ``com.example.tiptime``.

   |6223d2f5664ca35f.png|


**Create the test class**

   Now that the **test** package is ready, it's time to write some tests! Start by creating
   the test class.

   1. In the **Project** tab, click **app > src > test** and then click the
      |d4706c21930a1ef3.png| expander arrow next to the ``test`` directory.
   2. Right click the **``com.example.tiptime``** directory and then select **New > Kotlin
      Class/File**.

   |5e9d46922b587fdc.png|

   3. Enter ``TipCalculatorTests`` as the class name.

   |9260eb95d7aa6095.png|


**Write the test**

   As previously mentioned, local tests are used to test small pieces of code in the app. The
   main function of the Tip Time App calculates tips, so there should be a local test that
   ensures that the tip calculation logic works correctly.

   To achieve this, you need to directly call the ``calculateTip()`` function like you did in
   the app code. Then you ensure that the value returned by the function matches an expected
   value based on the values that you passed to the function.

   There are a few things that you should know about writing automated tests. The following
   list of concepts apply to local and instrumentation tests. They might seem abstract at
   first, but you become more familiar with them by the end of this codelab.

   -  Write automated tests in the form of methods.
   -  Annotate the method with the ``@Test`` annotation. This lets the compiler know that the
      method is a test method and runs the method accordingly.

   **Note**: The ``@Test`` annotation is imported from the ``org.junit.Test`` package with the
   ``import org.junit.Test`` import statement.

   -  Ensure that the name clearly describes what the test tests for and what the expected
      result is.

   -  Test methods don't use logic like regular app methods. They aren't concerned with how
      something is implemented. They strictly check an expected output for a given input. That
      is to say, test methods only execute a set of instructions to assert that an app's UI or
      logic functions correctly. You don't need to understand what this means yet because you
      see what this looks like later, but remember that test code may look quite different
      from the app code that you're used to.

   -  Tests typically end with an *assertion*, which is used to ensure that a given condition
      is met. Assertions come in the form of a method call that has *assert* in its name. For
      example: the ``assertTrue()`` assertion is commonly used in Android testing. Assertion
      statements are used in most tests, but they're rarely used in actual app code.

   Write the test:

   1. Create a method to test the calculation of a 20% tip for a $10 bill amount. The expected
      result of that calculation is $2.

   .. code:: prettyprint

      import org.junit.Test

      class TipCalculatorTests {

         @Test
         fun calculateTip_20PercentNoRoundup() {
             
         }
      }

   You may remember that the ``calculateTip()`` method from the ``MainActivity.kt`` file in
   the app code requires three parameters. The bill amount, the tip percent, and a flag to
   round the result or not.

   .. code:: prettyprint

      fun calculateTip(amount: Double, tipPercent: Double, roundUp: Boolean)

   When it comes time to call this method from the test, these parameters need to be passed
   like they were when the method was called in the app code.

   2. In the ``calculateTip_20PercentNoRoundup()`` method, create two constant variables: an
      ``amount`` variable set to a ``10.00`` value and a ``tipPercent`` variable set to a
      ``20.00`` value.

   .. code:: prettyprint

      val amount = 10.00
      val tipPercent = 20.00

   3. In the app code, in the ``MainActivity.kt`` file, observe the following code, the tip
      amount is formatted based on the locale of the device.

   **``MainActivity.kt``**

   .. code:: prettyprint

      ...
      NumberFormat.getCurrencyInstance().format(tip)
      ...

   The same formatting must be used when verifying the expected tip amount in the test.

   4. Create an ``expectedTip`` variable set to
      ``NumberFormat.getCurrencyInstance().format(2)``.

   The ``expectedTip`` variable is compared to the result of the ``calculateTip()`` method
   later. This is how the test ensures that the method works correctly. In the last step, you
   set the ``amount`` variable to a ``10.00`` value and the ``tipPercent`` variable to a
   ``20.00`` value. Twenty percent of 10 is 2, hence the ``expectedTip`` variable being set to
   a formatted currency with a value of ``2``. Remember, the ``calculateTip()`` method returns
   a formatted ``String`` value.

   5. Call the ``calculateTip()`` method with the ``amount`` and ``tipPercent`` variables, and
      pass a ``false`` argument for the roundup.

   You don't need to account for rounding up in this case because the expected result doesn't
   factor in rounding up.

   6. Store the result of the method call in a constant ``actualTip`` variable.

   Up to this point, writing this test hasn't been much different from writing a regular
   method in the app code. However, now that you have the returned value from the method that
   you want to test, you must determine whether that value is the correct value with an
   assertion.

   Making an assertion is typically the end goal of an automated test and it's not something
   commonly used in app code. In this case, you want to ensure that the ``actualTip`` variable
   is equal to the ``expectedTip`` variable. The ``assertEquals()`` method from the ``JUnit``
   library can be used for this.

   The ``assertEquals()`` method takes two parametersâ€”an expected value and an actual value.
   If those values are equal, the assertion and the test pass. If they're not equal, the
   assertion and the test fail.

   7. Call this ``assertEquals()`` method, and then pass in the ``expectedTip`` and
      ``actualTip`` variables as parameters:

   .. code:: prettyprint

      import org.junit.Assert.assertEquals
      import org.junit.Test
      import java.text.NumberFormat

      class TipCalculatorTests {

          @Test
          fun calculateTip_20PercentNoRoundup() {
              val amount = 10.00
              val tipPercent = 20.00
              val expectedTip = NumberFormat.getCurrencyInstance().format(2)
              val actualTip = calculateTip(amount = amount, tipPercent = tipPercent, false)
              assertEquals(expectedTip, actualTip)
          }
      }

   **Note**: There are many assertions in the ``JUnit`` library. Some common assertions that
   you might encounter are:

   -  ``assertEquals()``
   -  ``assertNotEquals()``
   -  ``assertTrue()``
   -  ``assertFalse()``
   -  ``assertNull()``
   -  ``assertNotNull()``
   -  ``assertThat()``

   For more information, see `Assert <https://developer.android.google.cn/reference/junit/framework/Assert>`__.


**Run the test**

   Now it's time to run your test!

   You may have noticed that arrows appear in the gutter alongside the line number of your
   class name and test function. You can click these arrows to run the test. When you click
   the arrow next to a method, you only run that test method. If you have multiple test
   methods in a class, you can click the arrow next to the class to run all the test methods
   in that class.

   |722bf5c7600bc004.png|

   Run the test:

   -  Click the arrows next to the class declaration and then click **Run
      â€˜TipCalculatorTests'**.

   |a294e77a57b0bb0a.png|

   You should see the following:

   -  At the bottom of the **Run** pane, you see some output.

   |c97b205fef4da587.png|

5. Write an instrumentation test
--------------------------------------------------------------------------------


Create the instrumentation directory

   The instrumentation directory is created in a similar manner to that of the local test
   directory.

   1. Right click on the **src** directory and select **New > Directory.**

   |309ea2bf7ad664e2.png|

   2. In the **New Directory** window select **androidTest/java**.

   |7ad7d6bba44effcc.png|

   3. Type the **return** or **enter** key on your keyboard. The **androidTest** directory can
      now be seen in the **Project** tab.

   |bd0a1ed4d803e426.png|

   Just like the ``main`` and ``test`` directories have the same package structure, the
   ``androidTest`` directory must contain that same package structure.

   1. Right click on the **androidTest/java** folder and select **New > Package.**
   2. In the **New Package** window, type ``com.example.tiptime``.
   3. Type the **return** or **enter** key on your keyboard. The complete package structure
      for the ``androidTest`` directory can now be seen in the **Project** tab.


**Create the test class**

   In Android projects, the instrumentation test directory is designated as the
   ``androidTest`` directory.

   To create an instrumentation test, you need to repeat the same process that you used to
   create a local test, but this time create it inside the ``androidTest`` directory.

   Create the test class:

   1. Navigate to the ``androidTest`` directory in the project pane.
   2. Click the |cf54f6c094aa8fa3.png| expand arrows next to each directory until you see the
      ``tiptime`` directory.

   |14674cbab3cba3e2.png|

   3. Right-click the ``tiptime`` directory and then select **New > Kotlin Class/File**.
   4. Enter ``TipUITests`` as the class name.

   |acd0c385ae834a16.png|


Write the test

   Instrumentation test code is quite different from local test code.

   Instrumentation tests test an actual instance of the app and its UI, so the UI content must
   be set, similar to how the content is set in the ``onCreate()`` method of the
   ``MainActivity.kt`` file when you wrote the code for the Tip Time app. You need to do this
   before you write all instrumentation tests for apps built with Compose.

   In the case of the Tip Time app tests, you proceed to write instructions to interact with
   the UI components so that the tip calculating process is tested through the UI. The concept
   of an instrumentation test can seem abstract at first, but don't worry! The process is
   covered in the following steps.

   Write the test:

   1. Create a ``composeTestRule`` variable set to the result of the ``createComposeRule()``
      method and annotate it with the ``Rule`` annotation:

   .. code:: prettyprint

      import androidx.compose.ui.test.junit4.createComposeRule
      import org.junit.Rule

      class TipUITests {

         @get:Rule
         val composeTestRule = createComposeRule()
      }

   2. Create a ``calculate_20_percent_tip()`` method and annotate it with the ``@Test``
      annotation:

   .. code:: prettyprint

      import org.junit.Test

      @Test
      fun calculate_20_percent_tip() {
      }

   The compiler knows that methods annotated with ``@Test`` annotation in the ``androidTest``
   directory refer to instrumentation tests and methods annotated with ``@Test`` annotation in
   the ``test`` directory refer to local tests.

   3. In the function body, call the ``composeTestRule.setContent()`` function. This sets the
      UI content of the ``composeTestRule``.
   4. In the function's lambda body, call the ``TipTimeTheme()`` function with a lambda body
      that calls the ``TipTimeLayout()`` function.

   .. code:: prettyprint

      import com.example.tiptime.ui.theme.TipTimeTheme

      @Test
      fun calculate_20_percent_tip() {
          composeTestRule.setContent {
              TipTimeTheme {
                 TipTimeLayout()
              }
          }
      }

   When you're done, the code should look similar to the code written to set the content in
   the ``onCreate()`` method in the ``MainActivity.kt`` file. Now that the UI content is set
   up, you can write instructions to interact with the app's UI components. In this app, you
   need to test that the app displays the correct tip value based on the bill amount and tip
   percentage inputs.

   5. UI components can be accessed as *nodes* through the ``composeTestRule``. A common way
      to do this is to access a node that contains a particular text with the
      ``onNodeWithText()`` method. Use the ``onNodeWithText()`` method to access the
      ``TextField`` composable for the bill amount:

   .. code:: prettyprint

      import androidx.compose.ui.test.onNodeWithText

      @Test
      fun calculate_20_percent_tip() {
          composeTestRule.setContent {
              TipTimeTheme {
                  TipTimeLayout()
              }
          }
          composeTestRule.onNodeWithText("Bill Amount")
      }

   Next you can call the ``performTextInput()`` method and pass in the text that you want
   entered to fill the ``TextField`` composable.

   6. Populate the ``TextField`` for the bill amount with a ``10`` value:

   .. code:: prettyprint

      import androidx.compose.ui.test.performTextInput

      @Test
      fun calculate_20_percent_tip() {
          composeTestRule.setContent {
              TipTimeTheme {
                  TipTimeLayout()
              }
          }
          composeTestRule.onNodeWithText("Bill Amount")
      .performTextInput("10")
      }

   7. Use the same approach to populate the ``OutlinedTextField`` for the tip percentage with
      a ``20`` value:

   .. code:: prettyprint

      @Test
      fun calculate_20_percent_tip() {
          composeTestRule.setContent {
              TipTimeTheme {
                  TipTimeLayout()
              }
          }
         composeTestRule.onNodeWithText("Bill Amount")
      .performTextInput("10")
         composeTestRule.onNodeWithText("Tip Percentage").performTextInput("20")
      }

   After all the ``TextField`` composables are populated, the tip displays in a ``Text``
   composable at the bottom of the screen in the app.

   Now that you instructed the test to populate these ``TextField`` composables, you have to
   make sure that the ``Text`` composable displays the correct tip with an assertion.

   In instrumentation tests with Compose, assertions can be called directly on UI components.
   There are a number of assertions available, but in this case you want to use the
   ``assertExists()`` method. The ``Text`` composable that displays the tip amount is expected
   to display: ``Tip Amount: $2.00``.

   **Note**: The currency symbol may change depending on device locale. The usage of â€˜``$``'
   is just an example. The currency must be formatted based on locale.

   8. Make an assertion that a node with that text exists:

   .. code:: prettyprint

      import java.text.NumberFormat

      @Test
      fun calculate_20_percent_tip() {
          composeTestRule.setContent {
              TipTimeTheme {
                  Surface (modifier = Modifier.fillMaxSize()){
                      TipTimeLayout()
                  }
              }
          }
         composeTestRule.onNodeWithText("Bill Amount")
            .performTextInput("10")
         composeTestRule.onNodeWithText("Tip Percentage").performTextInput("20")
         val expectedTip = NumberFormat.getCurrencyInstance().format(2)
         composeTestRule.onNodeWithText("Tip Amount: $expectedTip").assertExists(
            "No node with this text was found."
         )
      }


**Run the test**

   The process of running an instrumentation test is the same as that for a local test. You
   click the arrows in the gutter next to each declaration to run an individual test or the
   entire test class.

   |ad45b3e8730f9bf2.png|

   -  Click the arrows next to the class declaration. You can see the tests run on your device
      or emulator. When the test is finished, you should see the output that you see in this
      image:

   |bfd75ec0a8a98999.png|

6. Get the solution code
--------------------------------------------------------------------------------

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator/archive/refs/heads/test_solution.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator.git
      $ cd basic-android-kotlin-compose-training-tip-calculator
      $ git checkout test_solution

   **Note:** The solution code is in the `test_solution <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-tip-calculator/tree/test_solution>`__
   branch of the downloaded repository.

7. Conclusion
--------------------------------------------------------------------------------

   Congratulations! You wrote your first automated tests in Android. Tests are a critical
   component of software quality control. As you continue to build Android apps, ensure that
   you write tests alongside your app features to ensure that your apps work properly
   throughout the development process.


**Summary**

   -  What automated tests are.
   -  Why automated tests are important.
   -  The difference between local tests and instrumentation tests
   -  Fundamental best practices for writing automated tests.
   -  Where to find and place local and instrumentation test classes in an Android project.
   -  How to create a test method.
   -  How to create local and instrumentation test classes.
   -  How to make assertions in local and instrumentation tests.
   -  How to use test rules.
   -  How to use ``ComposeTestRule`` to launch the app with a test.
   -  How to interact with composables in an instrumentation test.
   -  How to run tests.

.. |a6b5eade0103eca9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/a6b5eade0103eca9.png
.. |d6bfede787910341.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/d6bfede787910341.png
.. |a457c469e7058234.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/a457c469e7058234.png
.. |bd2c2ef635f0a392.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/bd2c2ef635f0a392.png
.. |d07872d354d8aa92.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/d07872d354d8aa92.png
.. |99fcf5ff6cda7b57.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/99fcf5ff6cda7b57.png
.. |6223d2f5664ca35f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/6223d2f5664ca35f.png
.. |d4706c21930a1ef3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/d4706c21930a1ef3.png
.. |5e9d46922b587fdc.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/5e9d46922b587fdc.png
.. |9260eb95d7aa6095.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/9260eb95d7aa6095.png
.. |722bf5c7600bc004.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/722bf5c7600bc004.png
.. |a294e77a57b0bb0a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/a294e77a57b0bb0a.png
.. |c97b205fef4da587.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/c97b205fef4da587.png
.. |309ea2bf7ad664e2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/309ea2bf7ad664e2.png
.. |7ad7d6bba44effcc.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/7ad7d6bba44effcc.png
.. |bd0a1ed4d803e426.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/bd0a1ed4d803e426.png
.. |cf54f6c094aa8fa3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/cf54f6c094aa8fa3.png
.. |14674cbab3cba3e2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/14674cbab3cba3e2.png
.. |acd0c385ae834a16.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/acd0c385ae834a16.png
.. |ad45b3e8730f9bf2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-write-automated-tests/img/ad45b3e8730f9bf2.png


ğŸš€ Create an Art Space app
===========================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-art-space


1. Before you begin
--------------------------------------------------------------------------------

   You apply what you learned in this unit to create your own digital art space â€” an app that
   displays an array of artwork that you can showcase. Unlike previous codelabs in which you were
   given step-by-step instructions to follow, here you're only provided with guidelines and
   suggestions about what you can build with the concepts that you learned so far. You're encouraged
   to use your creativity to build the app independently with limited guidance.

   It's a challenge to build an app on your own, but don't worry because you have had enough
   practice! You can use the same skills that you've learned in this new context. You can always
   refer to previous codelabs if you're unsure how to implement certain parts of the app.

   When you build this app on your own and solve the problems that you face along the way, you learn
   faster and retain the concepts longer. As a side benefit, the app is completely customized, so
   you can use it to showcase your creation as part of your developer portfolio!

   **Warning:** Don't use assets that you don't own or have appropriate rights to use for your app.


Prerequisites

   -  Ability to create and run a project in Android Studio.
   -  Experience with Kotlin syntax, which includes ``Boolean`` and ``when`` expressions.
   -  Ability to apply basic Jetpack Compose concepts, such as the use of state with
      ``MutableState`` object.
   -  Experience with composable functions, which includes ``Text``, ``Image``, and ``Button``
      composables.


What you'll learn

   -  How to build low-fidelity prototypes and translate them to code.
   -  How to build simple layouts with ``Row`` and ``Column`` composables, and arrange them with
      ``horizontalAlignment`` and ``verticalArrangement`` parameters.
   -  How to customize Compose elements with a ``Modifier`` object.
   -  How to identify states and modify them upon triggers, such as button taps.


What you'll build

   -  An Android app that can display artwork or family photos


What you'll need

   -  A computer with Android Studio installed.
   -  Photos or digital art to display in the app.

   Here is a sample of how your app might look at the end of this project:

   |fd250028b87ec08f.png|

   *A sample of an Art Space app that displays a curated collection of framed artwork by the Android
   Basics Training team.*


2. Build static UI with composables
--------------------------------------------------------------------------------


Create a low-fidelity prototype

   Low-fidelity (low-fi) prototype refers to a simple model, or drawing, that provides a basic idea
   of what the app looks like.

   Create a low-fi prototype:

   1. Think about what you want to display in your Art Space app and who the target audience is.
   2. On your preferred medium, add elements that make up your app. Some elements to consider
      include:

   -  Artwork image
   -  Information about the artwork, such as its title, artist, and year of publication
   -  Any other elements, such as buttons that make the app interactive and dynamic.

   3. Put these elements in different positions and then evaluate them visually. Don't worry about
      getting it perfect the first time. You can always settle on one design now and iteratively
      improve later.

   **Note**: There are principles that help make design better for users, which is outside the scope
   of this project. To learn more, see `Understanding layout <https://m3.material.io/foundations/layout/understanding-layout/overview>`__.

   4. You may come up with a low-fi design that looks like this image:

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-art-space/img/51dc55a841c367d0.png

      A low-fidelity prototype that displays placeholders for the image, text, and buttons.

   Figure 1. Placeholder elements in UI mockups help to visualize the end product.


Convert design into code

   Use your prototype to help translate your design into code:

   1. Identify UI elements needed to build your app.

   For example, from the design example that you made, you need to have one ``Image`` composable,
   two ``Text`` composables, and two ``Button`` composables in your code.

   2. Identify different logical sections of the apps and draw boundaries around them.

   This step helps you divide your screen into small composables and think about the hierarchy of
   the composables.

   In this example, you can divide the screen into three sections:

   -  Artwork wall
   -  Artwork descriptor
   -  Display controller

   You can arrange each of these sections with layout composables, such as a ``Row`` or ``Column``
   composable.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-art-space/img/ab430785fcded354.png

      The boundaries drawn on a low-fi prototype, which outline three distinct sections.

   Figure 2. Boundaries around sections help developers conceptualize composables.

   3. For each section of the app that contains multiple UI elements, draw boundaries around them.

   These boundaries help you see how one element relates to another in the section.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-art-space/img/1a298cf143592ba9.png

      Smaller boundaries drawn in each section of the low-fi prototype to separate the text and
      buttons.

   Figure 3. More boundaries around the text and buttons help developers arrange composables.

   Now it's easier to see how you can arrange composables, such as ``Text`` and ``Button``
   composables, with layout composables.

   Some notes on various composables that you may use:

   -  ``Row`` **or** ``Column`` **composables**. Experiment with various ``horizontalArrangement``
      and ``verticalAlignment`` parameters in ``Row`` and ``Column`` composables to match the design
      that you have.

   -  ``Image`` **composables**. Don't forget to fill in the ``contentDescription`` parameter. As
      mentioned in the previous codelab, **TalkBack** uses the ``contentDescription`` parameter to
      help with the accessibility of the app. If the ``Image`` composable is only used for
      decorative purposes or there's a ``Text`` element that describes the ``Image`` composable, you
      can set the ``contentDescription`` parameter to ``null``.

   -  ``Text`` **composables**. You can experiment with various values of ``fontSize``,
      ``textAlign``, and ``fontWeight`` to style your text. You may also use a
      `buildAnnotatedString <https://developer.android.google.cn/jetpack/compose/text#multiple-styles>`__
      function to apply multiple styles for a single ``Text`` composable.

   -  ``Surface`` **composables**. You can experiment with various values of ``Elevation``,
      ``Color``, and ``BorderStroke`` for ``Modifier.border`` to create different UIs within
      ``Surface`` composables.

   -  **Spacing and alignment**. You can use ``Modifier`` arguments, such as ``padding`` and
      ``weight``, to help with the composables arrangement.

   **Note**: For a simple app, you can style each UI element on its own. However, this approach
   creates overhead as you add more screens. Compose helps maintain design consistency through its
   implementation of Material Design. You learn more about Material Design and Material Theming in
   future units. To learn more, see `Material Theming in Compose <https://developer.android.google.cn/jetpack/compose/designsystems/material3>`__.

   4. Run the app in an emulator or your Android device.

   |888a90e67f8e2cc2.png|

   Figure 4. This app shows static content, but users can't interact with it yet.


3. Make the app interactive
--------------------------------------------------------------------------------


Determine user interaction

   The advantage of building an art space digitally is that you can make it interactive and dynamic
   for your users. In the initial design, you built two buttons for the users to interact with.
   However, it's your own art space! You can change the design and how your users can interact with
   the app as you want. Now take a minute to think about how you want your users to interact with
   the app and how the app should respond based on such interactions. Some possible interactions you
   can add to your app include:

   -  Show next or previous artwork upon button tap.
   -  Fast forward artwork displayed to the next album upon swipe.
   -  Show a tooltip for additional information upon a long button tap.

   **Note**: There are many gestures and animations supported by Compose to make your app
   interactive. You learn more about animation in future units. For more information about advanced
   topics, see `Gestures <https://developer.android.google.cn/jetpack/compose/gestures>`__.


Create states for dynamic elements

   Work on the part of the UI that shows the next or previous artwork upon a button tap:

   1. First, identify the UI elements that need to change upon user interaction.

   In this case, the UI elements are the artwork image, artwork title, artist and year.

   2. If necessary, create a state for each of the dynamic UI elements with the ``MutableState``
      object.
   3. Remember to replace hardcoded values with ``states`` defined.

   **Note**: While you currently use one state for each dynamic UI element, this approach may not be
   the most efficient for code readability and performance of the app. You can potentially group
   related elements together as one entity and declare it as a single state, which you learn how to
   do with the ``Collection`` and ``Data`` classes in future units. After you complete those
   concepts, you can return to this project and refactor your code with the concepts that you
   learned.


Write conditional logic for interaction

   1. Think about the behavior you need when a user taps the buttons, beginning with the **Next**
      button.

   When users tap the **Next** button, they should expect to see the next artwork in the sequence.
   For now it might be difficult to determine what's the next artwork to be displayed.

   2. Add identifiers, or IDs, in the form of sequential numbers that begin with 1 for each artwork.

   It's now clear that the next artwork refers to the artwork that has the next ID in the sequence.

   Because you don't have an infinite number of artwork pieces, you may also want to determine the
   behavior of the **Next** button when you display the last artwork piece in your series. A common
   behavior is to go back to display the first artwork piece after the last artwork piece.

   3. Write in pseudocode first to capture the logic of the code without the Kotlin syntax.

   If there are three artwork pieces to show, the pseudocode for the logic for the **Next** button
   may look something like this code snippet:

   .. code:: prettyprint

      if (current artwork is the first artwork) {
          // Update states to show the second artwork.
      }
      else if (current artwork is the second artwork) {
          // Update states to show the third artwork.
      }
      else if (current artwork is the last artwork) {
         // Update state to show the first artwork.
      }

   4. Convert the pseudocode to Kotlin code.

   You may use the ``when`` statement to build the conditional logic instead of ``if else``
   statements to make your code more readable when it manages a large number of artwork cases.

   5. For this logic to be executed upon a button tap, put it inside the ``Button`` composables
      ``onClick()`` argument.
   6. Repeat the same steps to construct the logic for the **Previous** button.
   7. Run your app and then tap the buttons to confirm that they change the display to the previous
      or next artwork.


4. Challenge: Build for different screen sizes
--------------------------------------------------------------------------------

   One of the strengths of Android is that it supports many devices and screen sizes, which means
   that the app that you build can reach a wide range of audiences and be used in a multitude of
   ways. To ensure the best experience for all users, you should test your apps on devices that your
   app intends to support. For example, in the current sample app, you may have initially designed,
   built, and tested the app for mobile devices in portrait mode. However, some of your users might
   find your app enjoyable to use on a larger screen in landscape mode.

   While tablets aren't the primary supported device for this app, you still want to ensure that the
   app won't break if users use it on a larger screen.

   Test your app for a larger screen on a tablet:

   1. If you don't have an Android tablet device, `create an Android Virtual Device (AVD) <https://developer.android.google.cn/studio/run/managing-avds#createavd>`__.
   2. Build and run the app in a tablet AVD in landscape mode.
   3. Visually inspect that nothing looks unacceptable, such as some UI elements that are cut off,
      jarred alignment, or button interaction that doesn't work as expected.

   |34818d2206882027.png|

   Figure 5. The app needs to be reworked to display correctly on a larger device.

   4. Modify the code to fix any bugs found. Refer to `large screen app quality basic compatibility guidelines <https://developer.android.google.cn/docs/quality-guidelines/large-screens-app-quality#basic-compat>`__
      as guidance.
   5. Test the app again for tablet and phone to ensure that the bug fix works on both types of
      devices.

   |5901ce896814ac17.png|

   Figure 6. The app now looks good on a large screen.

   **Note**: You may notice that many apps that support tablets and phones may look different on
   different form factors. This difference happens because, oftentimes, the app supports different
   layouts for different screen sizes. To learn more, see `Support different screen sizes <https://developer.android.google.cn/develop/ui/compose/layouts/adaptive/support-different-screen-sizes>`__.


5. Good luck!
--------------------------------------------------------------------------------

   Hopefully, this guide inspires you to create your own art space! Remember, you don't need to
   create the perfect app the first time around. You can build things from your current knowledge of
   Android and improve on it later on as your skills expand.

   After you're done, showcase your work in your portfolio and share it with your friends and
   family. If you'd like to share your work on social media, use the hashtag #AndroidBasics.

.. |fd250028b87ec08f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-art-space/img/fd250028b87ec08f.png
.. |888a90e67f8e2cc2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-art-space/img/888a90e67f8e2cc2.png
.. |34818d2206882027.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-art-space/img/34818d2206882027.png
.. |5901ce896814ac17.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-art-space/img/5901ce896814ac17.png


â­ Your first program in Kotlin
================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-first-program


1. Before you begin
-------------------


   In this course, you will build apps by writing code in the Kotlin programming language, which is
   the language recommended by Google when creating new Android apps.

   Kotlin is a modern programming language that helps developers be more productive. For example,
   Kotlin allows you to be more concise and write fewer lines of code for the same functionality
   compared to other programming languages. Apps that are built with Kotlin are also less likely to
   crash, resulting in a more stable and robust app for users. Essentially, with Kotlin, you can
   write better Android apps in a shorter amount of time. As a result, Kotlin is gaining momentum in
   the industry and is the language that the majority of professional Android developers use.

   To get started on building Android apps in Kotlin, it's important to first establish a solid
   foundation of programming concepts in Kotlin. With the codelabs in this pathway, you will learn
   about Kotlin programming basics before diving into app creation.


**What you'll build**

   -  Short programs in Kotlin that display messages when you run them.


**What you'll learn**

   -  How to write and run a simple Kotlin program.
   -  How to modify a simple program to change the output.


**What you'll need**

   -  A computer with internet access and a web browser.


2. Get started
--------------

   In this codelab, you explore and modify simple programs in Kotlin. You can think of a *program*
   as a series of instructions for a computer or mobile device to perform some action, such as
   display a message to a user or calculate the cost of items in a shopping cart. The step-by-step
   instructions for what the computer should do is called *code*. When you modify the code in a
   program, the output can change.

   You use a tool called a *code editor* to write and edit your code. It's similar to a text editor
   in which you can write and edit text, but a code editor also provides functionality to help you
   write code more accurately. For example, a code editor shows autocomplete suggestions while you
   type, and displays error messages when code is incorrect.

   To practice the basics of the Kotlin language, you will use an interactive code editor called the
   Kotlin Playground. You can access it from a web browser, so you don't need to install any
   software on your computer. You can edit and run Kotlin code directly in the Kotlin Playground and
   see the output.

   Note that you can't build Android apps within the Kotlin Playground. In later pathways, you will
   install and use a tool called Android Studio to write and edit your Android app code.

   Now that you have some context on Kotlin, take a look at your first program!


3. Open Kotlin Playground
-------------------------

   In a web browser on your computer, open the `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__.

   You should see a web page similar to this image:

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/7844a522159be53c.png

      This shows a screenshot of the Kotlin Playground. The code editor shows a simple program for
      printing out

   There's already some default code populated in the code editor. These three lines of code make up
   a simple program:

   .. code:: prettyprint

      fun main() {
          println("Hello, world!")
      }

   Even if you've never programmed before, can you guess what the program does?

   See if your guess is correct by moving onto the next section!


4. Run your first program
-------------------------

   Click |Run button| to run your program.

.. |Run button| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/35cd601a27edda82.png

   When you click the Run button, a lot happens. Code in the Kotlin programming language is meant to
   be understood by humans, so that people can more easily read, write, and collaborate on Kotlin
   programs. However, your computer doesn't immediately understand this language.

   You need something called the *Kotlin compiler*, which takes the Kotlin code you wrote, looks at
   it line by line, and translates it into something that the computer can understand. This process
   is called *compiling* your code.

   If your code compiles successfully, your program will run (or execute). When the computer
   executes your program, it performs each of your instructions. If you've ever followed a cooking
   recipe, performing each step in the recipe is considered executing each instruction.

   Here's a screenshot of what you should see when you run your program.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/bddc4519d348bd25.png

      This screenshot shows a portion of the webpage of the Kotlin Playground. The code editor
      displays code for a Hello world program. Below the code editor is an output pane that displays
      the phrase

   At the bottom of the code editor, you should see a pane that shows the output, or result, of your
   program:

   ::

      Hello, world!

   Cool! The purpose of this program is to print or display a message that says ``Hello, world!``.

   **Warning:** If you don't see this result, copy and paste the three lines of code from the
   previous section into the Kotlin Playground and try again.

   How does this work? A Kotlin program is required to have a *main function*, which is the specific
   place in your code where the program starts running. The main function is the entry point, or
   starting point, of the program.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/83ab3fdb0a8c2304.png

      There is an arrow pointing to the first line of the main function of a simple program with a
      label that says

   Now you may be wondering, what is a function?


5. Parts of a function
----------------------

   A *function* is a segment of a program that performs a specific task. Your program may have one
   or more functions.


**Define versus call a function**

   In your code, you *define* a function first. That means you specify all the instructions needed
   to perform that task.

   Once the function is defined, then you can *call* that function, so the instructions within that
   function can be performed or executed.

   Here's an analogy. You write out step-by-step instructions on how to bake a chocolate cake. This
   set of instructions can have a name: ``bakeChocolateCake``. Every time you want to bake a cake,
   you can execute the ``bakeChocolateCake`` instructions. If you want 3 cakes, you need to execute
   the ``bakeChocolateCake`` instructions 3 times. The first step is defining the steps and giving
   it a name, which is considered defining the function. Then you can refer to the steps anytime you
   want them to be executed, which is considered calling the function.

   **Note:** You may hear the alternate phrase "declare a function." The words declare and define
   can be used interchangeably and have the same meaning. You may also hear the term "function
   definition" or "function declaration", which refer to the exact code that defines a function. In
   some other programming languages, declare and define have different meanings.


**Define a function**

   These are the key parts needed to define a function:

   -  The function needs a **name**, so you can call it later.
   -  The function can also require some **inputs**, or information that needs to be provided when
      the function is called. The function uses these inputs to accomplish its purpose. Requiring
      inputs is optional, and some functions do not require inputs.
   -  The function also has a **body** which contains the instructions to perform the task.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/7132067d45048b93.png

      This diagram represents a function as a black box with the label

   To translate the above diagram into Kotlin code, use the following syntax, or format, for
   defining a function. The order of these elements matters. The ``fun`` word must come first,
   followed by the function name, followed by the inputs in parentheses, followed by curly braces
   around the function body.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/imge8b488369268e737.png

      This diagram shows the syntax (or format) for declaring a function in Kotlin code. The function
      starts with the word

   Notice the key parts of a function within the ``main`` function example you saw in the Kotlin
   Playground:

   -  The function definition starts with the word ``fun``.
   -  Then the name of the function is ``main``.
   -  There are no inputs to the function, so the parentheses are empty.
   -  There is one line of code in the function body, ``println("Hello, world!")``, which is located
      between the opening and closing curly braces of the function.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/59fb37516122697d.png

      The following main function code is shown in the image: fun main() { println(|

   Each part of the function is explained in more detail below.


**Function keyword**

   To indicate that you're about to define a function in Kotlin, use the special word ``fun`` (short
   for function) on a new line. You must type ``fun`` exactly as shown in all lowercase letters. You
   can't use func, function, or some alternative spelling because the Kotlin compiler won't
   recognize what you mean.

   These special words are called *keywords* in Kotlin and are reserved for a specific purpose, such
   as creating a new function in Kotlin.


**Function name**

   Functions have names so they can be distinguished from each other, similar to how people have
   names to identify themselves. The name of the function is found after the ``fun`` keyword.

   .. image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/ba432607f21752f4.png

   Choose an appropriate name for your function based on the purpose of the function. The name is
   usually a verb or verb phrase. It's recommended to avoid using a `Kotlin keyword <https://kotlinlang.org/docs/keyword-reference.html>`__ 
   as a function name.

   Function names should follow the *camel case* convention, where the first word of the function
   name is all lower case. If there are multiple words in the name, there are no spaces between
   words, and all other words should begin with a capital letter.

   Example function names:

   -  ``calculateTip``
   -  ``displayErrorMessage``
   -  ``takePhoto``


**Function inputs**

   Notice that the function name is always followed by parentheses. These parentheses are where you
   list inputs for the function.

   .. image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/6d0b9acf98a9d2e8.png

   An input is a piece of data that a function needs to perform its purpose. When you define a
   function, you can require that certain inputs be passed in when the function is called. If there
   are no inputs required for a function, the parentheses are empty ``()``.

   Here are some examples of functions with a different number of inputs:

   The following diagram shows a function that is called ``addOne``. The purpose of the function is
   to add 1 to a given number. There is one input, which is the given number. Inside the function
   body, there is code that adds 1 to the number passed into the function.

   .. image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/2aacdc39be4dafc8.png

   In this next example, there is a function called ``printFullName``. There are two inputs required
   for the function, one for the first name and one for the last name. The function body prints out
   the first name and last name in the output, to display the person's full name.

   .. image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/51f4d1b94b208dfe.png

   This last example shows a function that doesn't require any inputs to be passed in when the
   function is called. When you call the ``displayHello()`` function, a Hello message gets printed
   to the output.

   .. image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/2d4050e223850fcf.png


**Function body**

   The *function body* contains the instructions needed to achieve the purpose of the function. You
   can locate the function body by looking for the lines of code enclosed within the opening and
   closing curly braces.

   .. image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/e012dd6fe687506a.png


**Simple program explained**

   Look back at the simple program that you saw earlier in the codelab.

   .. image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/59fb37516122697d.png

   The program contains one function: the ``main`` function. ``main`` is a special function name in
   Kotlin. When you're writing your code in the Kotlin Playground, your code should be written
   inside the ``main()`` function or called from the ``main()`` function.

   There's only one line of code in the body of this ``main()`` function:

   .. code:: prettyprint

      println("Hello, world!")

   This line of code is a *statement* because it performs a specific action, which is to print the
   ``Hello, world!`` text in the output pane. More specifically, the ``println()`` function is being
   called on this line of code. `println() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/println.html>`__ 
   is a function that's already defined in the Kotlin language. That means the team of engineers who
   created the Kotlin language already wrote out the function declaration for the ``println()``
   function. The function requires one input, which is the message that should be printed.

   When you call the ``println()`` function, place the message text within parentheses after the
   function name. Be sure to use quotation marks around the text to display, such as
   ``"Hello, world!"``.

   When the program is executed, the message that was passed into the ``println()`` function is
   printed to the output:

   ::

      Hello, world!


**Try it**

   Now look back at the original code in the program. Can you modify the code in the Kotlin
   Playground so that the output shows this message instead?

   ::

      Hello, Android!


6. Modify your program
----------------------

   1. In order to change the message that's displayed in the output, modify the ``println()``
      function call on the second line of the program. Replace ``world`` with ``Android`` in the
      ``println()`` function. Make sure that ``"Hello, Android!"`` is still within quotation marks
      and within the parentheses.

   .. code:: prettyprint

      fun main() {
          println("Hello, Android!")
      }

   2. Run the program.
   3. The output should show this message:

   ::

      Hello, Android!

   Nice job, you modified your first program!

   Now can you change your code so that the message gets printed twice? See the desired output:

   ::

      Hello, Android!
      Hello, Android!


**Print more than one message**

   You can put as many lines of instructions inside a function as you need to accomplish a task.
   However, note that there should only be one statement per line in Kotlin. If you want to write
   another statement, put it on a new line of the function.

   To change your program to print multiple lines of text:

   1. Copy the initial ``println()`` statement and paste the second statement below it within the
      function body. Both ``println()`` statements must be contained within the curly braces of the
      main function. Now you have two statements within the function body.

   .. code:: prettyprint

      fun main() {
          println("Hello, Android!")
          println("Hello, Android!")
      }

   2. Run the program.
   3. When you run your program, the output should be:

   ::

      Hello, Android!
      Hello, Android!

   You can see how changes to the code affects the output.

   4. Change the code so that it says ``Hello,`` ``YOUR_NAME`` ``!``.


7. Kotlin style guide
---------------------

   Throughout this course, you'll learn about good coding practices to follow as an Android
   developer. One such practice is to follow Google's Android coding standards for code written in
   Kotlin. The complete guide is called a style guide and explains how code should be formatted in
   terms of visual appearance and the conventions to follow when writing your code. For example, the
   style guide includes recommendations on use of whitespace, indentation, naming, and more.

   The purpose of following the style guide is to make your code easier to read and more consistent
   with how other Android developers write their code. This consistency is important when
   collaborating on large projects together, so that the style of code is the same throughout all
   the files in the project.

   Here are some of the relevant style guide recommendations for what you've learned in Kotlin so
   far:

   -  Function names should be in camel case and should be verbs or verb phrases.
   -  Each statement should be on its own line.
   -  The opening curly brace should appear at the end of the line where the function begins.
   -  There should be a space before the opening curly brace.

   .. image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/83759a94e8b6622e.png

   -  The function body should be indented in by 4 spaces. Do not use a tab character to indent your
      code, type in 4 spaces.

   .. image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/3f24b3fe1eda0302.png

   -  The closing curly brace is on its own line after the last line of code in the function body.
      The closing brace should line up with the ``fun`` keyword at the beginning of the function.

   .. image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/22350528401a32f1.png

   You will learn more Android coding conventions as you build your knowledge in Kotlin. The full
   style guide is `here <https://developer.android.google.cn/kotlin/style-guide>`__, but don't worry
   that it covers other topics in Kotlin you haven't learned yet.


8. Fix errors in your code
--------------------------

   When you learn a human language, there are rules of syntax and grammar for the correct way to use
   words and form sentences. Similarly, for programming languages, there are specific rules for what
   makes valid code, which means code that compiles successfully.

   A normal part of the coding process involves making mistakes and accidentally writing invalid
   code. As a beginner, it may be confusing or overwhelming to encounter these mistakes. But don't
   worry, this is expected. Code rarely works perfectly the first time that it's written. Just like
   how writing a document takes many drafts, writing code can take many iterations until it works as
   expected.

   If the code can't compile successfully, there's an error. For example, if you have a typo, such
   as a missing quotation mark or parenthesis, the compiler won't understand your code and can't
   translate it into steps for the computer to perform. If your code doesn't work as expected, or
   you see an error message in your code editor, you have to go back to your code and fix it. The
   process of solving these errors is called *troubleshooting*.

   1. Copy and paste the following code snippet into the Kotlin Playground and run the program. What
      do you see?

   .. code:: prettyprint

      fun main() {
          println("Today is sunny!)
      }

   Ideally, you want to see the message ``Today is sunny!`` displayed. Instead, in the output pane,
   you see exclamation point icons with error messages.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-first-program/img/f811068764fa4aeb.png

      There are 2 error messages from running the program: Expecting

   *Error message from Kotlin Playground*

   The error messages start with the word "Expecting" because the Kotlin compiler is "expecting"
   something but not finding it in the code. In this case, the compiler is expecting a closing
   quotation mark and a closing parenthesis for the code on the second line of your program.

   In the ``println()`` statement, notice that the message to display has an opening quotation mark,
   but no closing quotation mark. Even though there is a closing parenthesis in the code, the
   compiler thinks the parenthesis is part of the text to print because there is no closing
   quotation mark before it.

   2. Add the closing quotation mark after the exclamation point, before the closing parenthesis.

   .. code:: prettyprint

      fun main() {
          println("Today is sunny!")
      }

   The main function contains one line of code, which is a ``println()`` statement, where the text
   is enclosed in quotation marks and placed within the parentheses: â€‹â€‹ ``"Today is sunny!"``.

   3. Run the program again.

   There shouldn't be any errors and the output pane should display this text:

   ::

      Today is sunny!

   Good work on fixing the error! Once you gain more experience in writing code and troubleshooting
   errors, you'll realize how important it is to pay attention to capitalization, spelling, spacing,
   symbols, and names when you're typing your code.

   In the next section, you work on a series of exercises to practice what you've learned. Solutions
   are provided at the end of the codelab, but try your best to find the answer on your own first.


9. Exercises
------------

   1. Can you read the code in this program and guess what the output is (without running it in
      Kotlin Playground)?

   .. code:: prettyprint

      fun main() {
          println("1")
          println("2")
          println("3")
      }

   Once you have a guess, copy and paste this code into the Kotlin Playground to check your answer.

   2. Use the Kotlin Playground to create a program that outputs the following messages:

   ::

      I'm
      learning
      Kotlin!

   3. Copy and paste this program into the Kotlin Playground.

   .. code:: prettyprint

      fun main() {
          println("Tuesday")
          println("Thursday")
          println("Wednesday")
          println("Friday")
          println("Monday")
      }

   Fix the program so that it prints this output:

   ::

      Monday
      Tuesday
      Wednesday
      Thursday
      Friday

   For some early practice on troubleshooting, fix the errors in the following exercises. For each
   exercise, copy the code into the Kotlin Playground in your browser. Try to run the program and
   you'll see an error message appear.

   4. Fix the error in this program, so that it produces the desired output.

   .. code:: prettyprint

      fun main() {
          println("Tomorrow is rainy")

   Desired output:

   ::

      Tomorrow is rainy

   5. Fix the error in this program, so that it produces the desired output.

   .. code:: prettyprint

      fun main() {
          printLine("There is a chance of snow")
      }

   Desired output:

   ::

      There is a chance of snow

   6. Fix the error in this program, so that it produces the desired output.

   .. code:: prettyprint

      fun main() {
          println("Cloudy") println("Partly Cloudy") println("Windy")
      }

   Desired output:

   ::

      Cloudy
      Partly Cloudy
      Windy

   7. Fix the error in this program, so that it produces the desired output.

   .. code:: prettyprint

      fun main() (
          println("How's the weather today?")
      )

   Desired output:

   ::

      How's the weather today?

   After you complete these exercises, check your answers against the solutions in the next section.


10. Solutions
-------------

   1. The output of the program is:

   ::

      1
      2
      3

   2. The code in your program should look like:

   .. code:: prettyprint

      fun main() {
          println("I'm")
          println("learning")
          println("Kotlin!")
      }

   3. This is the correct code for the program:

   .. code:: prettyprint

      fun main() {
          println("Monday")
          println("Tuesday")
          println("Wednesday")
          println("Thursday")
          println("Friday")
      }

   4. The closing curly brace that indicates the end of the function body for the ``main`` function
      is missing on the third line of the program.

   Correct code:

   .. code:: prettyprint

      fun main() {
          println("Tomorrow is rainy")
      }

   Output:

   ::

      Tomorrow is rainy

   5. When you run the program, you see an ``Unresolved reference: printLine`` error. This is
      because ``printLine()`` isn't a recognized function in Kotlin. You can also see the part of
      the code causing the error highlighted in red in the Kotlin Playground. Change the function
      name to ``println`` to print a line of text to the output, which fixes the error.

   Correct code:

   .. code:: prettyprint

      fun main() {
          println("There is a chance of snow")
      }

   Output:

   ::

      There is a chance of snow

   6. When you run the program, you see an ``Unresolved reference: println`` error. This message
      doesn't directly say how to fix the problem. This can sometimes happen when you troubleshoot
      an error, and it requires you to take a deeper look at the code to resolve the unexpected
      behavior.

   Upon closer look, the second ``println()`` function call in the code is red, which signals that's
   where the problem is. Kotlin expects just one statement on each line. In this case, you can move
   the second and third ``println()`` function calls onto separate new lines to solve the issue.

   Correct code:

   .. code:: prettyprint

      fun main() {
          println("Cloudy")
          println("Partly Cloudy")
          println("Windy")
      }

   Output:

   ::

      Cloudy
      Partly Cloudy
      Windy

   7. If you run the program, you see the error: ``Function 'main' must have a body``. A function
      body should be enclosed within an opening curly brace and a closing curly brace { }, not
      opening and closing parentheses ( ).

   Correct code:

   .. code:: prettyprint

      fun main() {
          println("How's the weather today?")
      }

   Output:

   ::

      How's the weather today?


11. Conclusion
--------------

   Great job on completing this introduction to Kotlin!

   You worked with simple programs in Kotlin and ran them to see text printed to the output. You
   modified the programs in different ways and observed how those changes affected the output. It's
   normal to make mistakes when programming, so you also began to learn about how to troubleshoot
   and correct errors in your code, which is an important skill that will help you in the future.

   Move on to the next codelab to learn how to use variables in Kotlin so that you can create more
   interesting programs!


Summary

   -  A Kotlin program requires a ``main`` function as the entry point of the program.
   -  To define a function in Kotlin, use the ``fun`` keyword, followed by the name of the function,
      any inputs enclosed in parentheses, followed by the function body enclosed in curly braces.
   -  The name of a function should follow camel case convention and start with a lowercase letter.
   -  Use the ``println()`` function call to print some text to the output.
   -  Refer to the Kotlin style guide for formatting and code conventions to follow when coding in
      Kotlin.
   -  Troubleshooting is the process of resolving errors in your code.


Learn more

   -  `Hello World <https://play.kotlinlang.org/byExample/01_introduction/01_Hello%20world>`__
   -  `Program entry point <https://kotlinlang.org/docs/basic-syntax.html#program-entry-point>`__
   -  `Print to the standard output <https://kotlinlang.org/docs/basic-syntax.html#print-to-the-standard-output>`__
   -  `Basic syntax of functions <https://kotlinlang.org/docs/basic-syntax.html#functions>`__
   -  `Keywords and operators <https://kotlinlang.org/docs/keyword-reference.html>`__
   -  `Functions Concept <https://kotlinlang.org/docs/functions.html>`__
   -  `println() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/println.html>`__
   -  `Kotlin style guide <https://developer.android.google.cn/kotlin/style-guide>`__


â­ Create and use variables in Kotlin
======================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-variables


1. Before you begin
-------------------


   In the apps that you use on your phone, notice that some parts of the app stay the same, while
   other parts change (or are variable).

   For example, the names of the categories within the Settings app stay the same â€“ Network &
   internet, Connected devices, Apps, and more.

   |72302735e50d7d85.png|

   On the other hand, if you look at a news app, the articles will change often. The article name,
   source, time posted, and images change.

   How do you write your code so that content changes over time? You can't rewrite the code in your
   app every time there are new articles to post, which happens every day, every hour, and every
   minute!

   In this codelab, you learn how to write code that uses variables so that certain parts of your
   program can change without having to write a whole new set of instructions. You will use the
   Kotlin Playground as you did in the previous codelab.


**What you'll build**

   -  Short programs in Kotlin that use variables.


**What you'll learn**
      :class: checklist

   -  How to define a variable and update its value.
   -  How to select an appropriate data type for a variable from the basic data types in Kotlin.
   -  How to add comments to your code.


**What you'll need**

   -  A computer with internet access and a web browser.


2. Variables and data types
---------------------------


   In computer programming, there's the concept of a *variable*, which is a container for a single
   piece of data. You can envision it as a box that contains a value. The box has a label, which is
   the name of the variable. By referring to the box by its name, you have access to the value it
   holds.

   :: 

          â•­â”€â”€â”€â”€â”€â”€â”€â•®
         â•­â”€â”€â”€â”€â”€â”€â”€â•®â”‚      â•­â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ name  â”‚â•¯<â”€â”€â”€â”€ â”‚ value â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â•¯       â•°â”€â”€â”€â”€â”€â”€â”€â•¯


   Why store the value in a box and reference the box by its name when you can simply use the value
   directly? The problem is that when your code uses values directly in all the instructions, your
   program will only work for that specific case.

   Here's an analogy that can make it easier to understand why variables are useful. The following
   is a letter for someone you recently met.

   *Dear Lauren,*

   *It was great meeting you today at the office. I look forward to seeing you on Friday.*

   *Have a nice day!*

   This letter is great, but it only works for your specific situation with Lauren. What if you find
   yourself writing the same letter many times but with slight variations for different people? It
   would be more efficient to create a single letter template, leaving blanks for the parts that can
   change.

   *Dear ____ ,*

   *It was great meeting you today at _____. I look forward to seeing you on ____ .*

   *Have a nice day!*

   You can also specify the type of information that goes in each blank space. This ensures that the
   letter template will be used as you expected.

   *Dear { name } ,*

   *It was great meeting you today at { location } . I look forward to seeing you on { date } .*

   *Have a nice day!*

   Conceptually, building an app is similar. You have placeholders for some data, while other parts
   of the app stay the same.

   :: 

      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      â”‚ News                                           â”‚
      â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
      â”‚                                                â”‚
      â”‚ Welcome, {Name} !                              â”‚
      â”‚                                                â”‚
      â”‚ Latest news for you:                           â”‚
      â”‚                                                â”‚
      â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                   â”‚
      â”‚  â”‚         â”‚ { Article name }                  â”‚
      â”‚  â”‚ article â”‚ { date }                          â”‚
      â”‚  â”‚  image  â”‚ { text }                          â”‚
      â”‚  â”‚         â”‚                                   â”‚
      â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                   â”‚
      â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                   â”‚
      â”‚  â”‚         â”‚ { Article name }                  â”‚
      â”‚  â”‚ article â”‚ { date }                          â”‚
      â”‚  â”‚  image  â”‚ { text }                          â”‚
      â”‚  â”‚         â”‚                                   â”‚
      â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                   â”‚
      â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                   â”‚
      â”‚  â”‚         â”‚ { Article name }                  â”‚
      â”‚  â”‚ article â”‚ { date }                          â”‚
      â”‚  â”‚  image  â”‚ { text }                          â”‚
      â”‚  â”‚         â”‚                                   â”‚
      â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                   â”‚
      â”‚                                                â”‚
      â”‚                   View more articles           â”‚
      â”‚                                                â”‚
      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   In the above illustration of a news app, the "Welcome" text, the "Latest news for you" heading,
   and the "View more articles" button text always stay the same. Conversely, the name of the user
   and the contents of each article will change, so that would be a great opportunity to use
   variables to hold each piece of information.

   :: 

          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®â”‚      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚     name      â”‚â•¯<â”€â”€â”€â”€ â”‚   "Alex"    â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯       â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®â”‚      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ article name  â”‚â•¯<â”€â”€â”€â”€ â”‚ "New movie comming out"   â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯       â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®â”‚      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ articleDate   â”‚â•¯<â”€â”€â”€â”€ â”‚ "June 9"    â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯       â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   You don't want to write the code (or instructions) in your news app to only work for a user named
   Alex, or for a news article that always has the same title and publication date. Instead, you
   want a more flexible app, so you should write your code by referencing variable names like
   ``name``, ``article1Name``, ``article1Date``, and so on. Then your code becomes general enough to
   work for many different use cases where the user's name could be different and the article
   details could be different.


**Example app with variables**

   Let's look at an app example to see where it may use variables.

   |a7e1f5184e4e3b15.png|

   In a maps app, you may find a details screen for each location, such as a restaurant or business.
   The above screenshot from the Google Maps app shows the details for Google's company
   headquarters, which is called the Googleplex. Which pieces of data do you think are stored as
   variables in the app?

   -  **Name** of the location
   -  **Star rating** of the location
   -  **Number of reviews** of the location
   -  Whether the user **saved** (or bookmarked) this location
   -  **Address** of the location

   Change the data that's stored in these variables and you have a maps app that's flexible enough
   to display the details of other locations too.


Data types

   When you decide what aspects of your app can be variable, it's important to specify *what type of
   data* can be stored in those variables. In Kotlin, there are some common basic data types. The
   table below shows a different data type in each row. For each data type, there's a description of
   what kind of data it can hold and example values.

   +--------------------------------+--------------------------------+--------------------------------+
   | **Kotlin data type**           | **What kind of data it can     | **Example literal values**     |
   |                                | contain**                      |                                |
   +--------------------------------+--------------------------------+--------------------------------+
   | ``String``                     | Text                           | | ``"Add contact"``            |
   |                                |                                | | ``"Search"``                 |
   |                                |                                | | ``"Sign in"``                |
   +--------------------------------+--------------------------------+--------------------------------+
   | ``Int``                        | Integer number                 | | ``32``                       |
   |                                |                                | | ``1293490``                  |
   |                                |                                | | ``-59281``                   |
   +--------------------------------+--------------------------------+--------------------------------+
   | ``Double``                     | Decimal number                 | | ``2.0``                      |
   |                                |                                | | ``501.0292``                 |
   |                                |                                | | ``-31723.99999``             |
   +--------------------------------+--------------------------------+--------------------------------+
   | ``Float``                      | Decimal number (that is less   | | ``5.0f``                     |
   |                                | precise than a ``Double``).    | | ``-1630.209f``               |
   |                                | Has an ``f`` or ``F`` at the   | | ``1.2940278F``               |
   |                                | end of the number.             |                                |
   +--------------------------------+--------------------------------+--------------------------------+
   | ``Boolean``                    | ``true`` or ``false``. Use     | | ``true``                     |
   |                                | this data type when there are  | | ``false``                    |
   |                                | only two possible values. Note |                                |
   |                                | that ``true`` and ``false``    |                                |
   |                                | are keywords in Kotlin.        |                                |
   +--------------------------------+--------------------------------+--------------------------------+

   **Note:** For the valid ranges for the numerical data types (``Int``, ``Double``, and ``Float``),
   see `Numbers <https://kotlinlang.org/docs/numbers.html>`__. For specifics on the difference
   between ``Double`` and ``Float``, look at `this table <https://kotlinlang.org/docs/numbers.html#floating-point-types>`__ 
   comparing the two data types.

   Now that you are aware of some common Kotlin data types, which data type would be appropriate for
   each of the variables identified in the location detail page you saw earlier?

   |a7e1f5184e4e3b15.png|

   -  **Name** of the location is text, so it can be stored in a variable whose data type is
      ``String``.

   -  **Star rating** of the location is a decimal number (such as 4.2 stars), so it can be stored
      as a ``Double``.

   -  **Number of reviews** of the location is a whole number, so it should be stored as an ``Int``.

   -  Whether the user **saved** this location only has two possible values (saved or not saved), so
      it's stored as a ``Boolean``, where ``true`` and ``false`` can represent each of those states.

   -  **Address** of the location is text, so it should be a ``String``.


   Practice on two more scenarios below. Identify the use of variables and their data types in the
   following apps.

   1. In an app for watching videos, such as the YouTube app, there's a video details screen. Where
      are variables likely used? What's the data type of those variables?

   |a1688b9b297c7501.png|

   There isn't a single correct answer, but in a video-watching app, variables can be used for the
   following pieces of data:

   -  **Name** of the video (``String``)
   -  **Name** of the channel (``String``)
   -  **Number of views** on the video (``Int``)
   -  **Number of likes** on the video (``Int``)
   -  **Number of comments** on the video (``Int``)

   2. In an app like Messages, the screen lists the most recent text messages received. Where are
      variables likely used? What's the data type of those variables?

   |f515a6481cc91bf2.png|

   Again, there isn't a single correct answer. In an text messaging app, variables can be used for
   the following pieces of data:

   -  **Phone number** of the sender (``String``)
   -  **Timestamp** of the message (``String``)
   -  **Preview** of the message contents (``String``)
   -  Whether the text message is **unread** (``Boolean``)


**Try it**

   1. Open your favorite app on your phone.
   2. Identify where you think variables are used in the app on that particular screen.
   3. Guess what data type those variables are.
   4. Share your answers on social media with a `screenshot <https://support.google.com/pixelphone/answer/2811098>`__ 
      of the app, an explanation of where you think variables are used, and the hashtag #AndroidBasics.

   Great work in this codelab so far! Move onto the next section to learn more about how variables
   and data types are used in your code.


3. Define and use variables
---------------------------


Define versus use a variable

   You must define a variable first in your code before you can use the variable. This is similar to
   what you learned in the last codelab about defining functions before calling them.

   When you *define* a variable, you assign a name to uniquely identify it. You also decide what
   type of data it can hold by specifying the data type. Lastly, you can provide an initial value
   that will be stored in the variable, but this is optional.

   **Note:** You may hear the alternate phrase "declare a variable." The words declare and define
   can be used interchangeably and have the same meaning. You may also hear the term "variable
   definition" or "variable declaration", which refer to the code that defines a variable. In other
   languages, declare and define have different meanings.

   Once you define a variable, you can *use* that variable in your program. To use a variable, type
   out the variable name in your code, which tells the Kotlin compiler that you want to use the
   variable's value at that point in the code.

   For example, define a variable for the number of unread messages in a user's inbox. The variable
   can have the name ``count``. Store a value such as the number ``2`` inside the variable,
   representing ``2`` unread messages in the user's inbox. (You can pick a different number to store
   in the variable, but for the purpose of this example, use the number ``2``.)

   :: 

          â•­â”€â”€â”€â”€â”€â”€â”€â•®
         â•­â”€â”€â”€â”€â”€â”€â”€â•®â”‚      â•­â”€â”€â”€â•®
         â”‚ count â”‚â•¯<â”€â”€â”€â”€ â”‚ 2 â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â•¯       â•°â”€â”€â”€â•¯

   Every time your code needs to access the number of unread messages, type ``count`` in your code.
   When executing your instructions, the Kotlin compiler sees the variable name in your code and
   uses the variable value in its place.

   Technically, there are more specific vocabulary words to describe this process:

   An *expression* is a small unit of code that evaluates to a value. An expression can be made up
   of variables, function calls, and more. In the following case, the *expression* is made up of one
   variable: the ``count`` variable. This expression evaluates to ``2``.

   ::

      expression              value
        count                   2

   *Evaluate* means determining the value of an expression. In this case, the expression evaluates
   to ``2``. The compiler evaluates expressions in the code and uses those values when executing the
   instructions in the program.

   :: 

          â•­â”€â”€â”€â”€â”€â”€â”€â•®
         â•­â”€â”€â”€â”€â”€â”€â”€â•®â”‚                  â•­â”€â”€â”€â•®
         â”‚ count â”‚â•¯â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚ 2 â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â•¯   evaluates to    â•°â”€â”€â”€â•¯


   To observe this behavior in the Kotlin Playground, run the program in the next section.


**Example**

   1. Open the `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__
      in a web browser.
   2. Replace the existing code in the Kotlin Playground with the following program.

   This program creates a variable called ``count`` with an initial value of ``2`` and uses it by
   printing out the value of the ``count`` variable to the output. Don't worry if you don't
   understand all aspects of the code syntax yet. It will be explained in more detail in upcoming
   sections.

   .. code:: prettyprint

      fun main() {
          val count: Int = 2
          println(count)
      }

   3. Run the program and the output should be:

   ::

      2


**Variable declaration**

   In the program you ran, the second line of code says:

   .. code:: prettyprint

      val count: Int = 2

   This statement creates an integer variable called ``count`` that holds the number ``2``.


   :: 

         â•­â”€â”€â”€â”€â”€â”€â”€â•®       â•­â”€â”€â”€â•®
         â”‚ count â”‚ <â”€â”€â”€â”€ â”‚ 2 â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â•¯       â•°â”€â”€â”€â•¯


   It can take a while to become familiar with reading the syntax (or format) for declaring a
   variable in Kotlin. The following diagram shows where each detail about the variable should be
   located, as well as the location of spaces and symbols.

   :: 

         â•­â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ naem â”‚  :  â”‚ data type â”‚  =  â”‚ initial value â”‚
         â•°â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   In the context of the ``count`` variable example, you can see that the variable declaration
   starts with the word ``val``. The name of the variable is ``count``. The data type is ``Int``,
   and the initial value is ``2``.


   :: 

         â•­â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ naem â”‚  :  â”‚ data type â”‚  =  â”‚ initial value â”‚
         â•°â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
            â”‚     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯           â•­â”€â”€â”€â”€â”€â”€â”€â•¯
            â”‚     â”‚                     â”‚
      val count: Int = 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   Each part of the variable declaration is explained in more detail below.


Keyword to define new variable

   To define a new variable, start with the Kotlin keyword ``val`` (which stands for value). Then
   the Kotlin compiler knows that a variable declaration is in this statement.


**Variable name**

   Just like you name a function, you also name a variable. In the variable declaration, the
   variable name follows the ``val`` keyword.


   :: 

               â•­â•â•â•â•â•â•â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         val   â”‚ naem â”‚  :  â”‚ data type â”‚  =  â”‚ initial value â”‚
               â•°â•â•â•â•â•â•â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   You can choose any variable name you want, but as a best practice, avoid using Kotlin
   `keywords <https://kotlinlang.org/docs/keyword-reference.html>`__ as a variable name.

   It's best to choose a name that describes the data that the variable holds so that your code is
   easier to read.

   Variable names should follow the camel case convention, as you learned with function names. The
   first word of the variable name is all lower case. If there are multiple words in the name, there
   are no spaces between words, and all other words should begin with a capital letter.

   Example variable names:

   -  ``numberOfEmails``
   -  ``cityName``
   -  ``bookPublicationDate``

   For the code example shown earlier, ``count`` is the name of the variable.

   .. code:: prettyprint

      val count: Int = 2


**Variable data type**

   After the variable name, you add a colon, a space, and then the data type of the variable. As
   mentioned earlier, ``String``, ``Int``, ``Double``, ``Float,`` and ``Boolean`` are some of the
   basic Kotlin data types. You'll learn more data types later in this course. Remember to spell
   data types exactly as shown and begin each with a capital letter.

   :: 

               â•­â”€â”€â”€â”€â”€â”€â•®     â•­â•â•â•â•â•â•â•â•â•â•â•â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         val   â”‚ naem â”‚  :  â”‚ data type â”‚  =  â”‚ initial value â”‚
               â•°â”€â”€â”€â”€â”€â”€â•¯     â•°â•â•â•â•â•â•â•â•â•â•â•â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   For the ``count`` variable example, ``Int`` is the data type of the variable.

   .. code:: prettyprint

      val count: Int = 2


**Assignment operator**

   In the variable declaration, the equal sign symbol (``=``) follows the data type. The equal sign
   symbol is called the *assignment operator*. The assignment operator assigns a value to the
   variable. In other words, the value on the right-hand side of the equal sign gets stored in the
   variable on the left-hand side of the equal sign.

   :: 

                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                  v          â”‚
            val count: Int = 2 


**Variable initial value**

   The variable value is the actual data that's stored in the variable.

   :: 

               â•­â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•®
         val   â”‚ naem â”‚  :  â”‚ data type â”‚  =  â”‚ initial value â”‚
               â•°â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¯

   For the ``count`` variable example, the number ``2`` is the initial value of the variable.

   .. code:: prettyprint

      val count: Int = 2

   You may also hear the phrase: "the ``count`` variable is *initialized* to ``2``." This means that
   ``2`` is the first value stored in the variable when the variable is declared.

   The initial value will be different depending on the data type declared for the variable.

   Refer to the following table which you may recognize from earlier in the codelab. The third
   column shows example values that can be stored in a variable of each corresponding type. These
   values are called *literals* because they are fixed or constant values (the value is constantly
   the same). As an example, the integer 32 is always going to have the value of 32. In contrast, a
   variable is not a literal because its value can change. You may hear these literal values
   referred to based on their type: string literal, integer literal, boolean literal, etc.

   +--------------------------------+--------------------------------+--------------------------------+
   | **Kotlin data type**           | **What kind of data it can     | **Example literal values**     |
   |                                | contain**                      |                                |
   +--------------------------------+--------------------------------+--------------------------------+
   | ``String``                     | Text                           | | ``"Add contact"``            |
   |                                |                                | | ``"Search"``                 |
   |                                |                                | | ``"Sign in"``                |
   +--------------------------------+--------------------------------+--------------------------------+
   | ``Int``                        | Integer number                 | | ``32``                       |
   |                                |                                | | ``1293490``                  |
   |                                |                                | | ``-59281``                   |
   +--------------------------------+--------------------------------+--------------------------------+
   | ``Double``                     | Decimal number                 | | ``2.0``                      |
   |                                |                                | | ``501.0292``                 |
   |                                |                                | | ``-31723.99999``             |
   +--------------------------------+--------------------------------+--------------------------------+
   | ``Float``                      | Decimal number (that is less   | | ``5.0f``                     |
   |                                | precise than a ``Double``).    | | ``-1630.209f``               |
   |                                | Has an ``f`` or ``F`` at the   | | ``1.2940278F``               |
   |                                | end of the number.             |                                |
   +--------------------------------+--------------------------------+--------------------------------+
   | ``Boolean``                    | ``true`` or ``false``. Use     | | ``true``                     |
   |                                | this data type when there are  | | ``false``                    |
   |                                | only two possible values. Note |                                |
   |                                | that ``true`` and ``false``    |                                |
   |                                | are keywords in Kotlin.        |                                |
   +--------------------------------+--------------------------------+--------------------------------+

   It's important to provide an appropriate and valid value according to the data type of the
   variable. For instance, you can't store a string literal like ``"Hello"`` inside a variable of
   type ``Int`` because the Kotlin compiler will give you an error.


**Use a variable**

   The following is the original program you ran in the Kotlin Playground. So far you learned that
   the second line of code creates a new integer variable called ``count`` with a value of ``2``.

   .. code:: prettyprint

      fun main() {
          val count: Int = 2
          println(count)
      }

   Now look at the third line of code. You are printing the ``count`` variable to the output:

   .. code:: prettyprint

      println(count)

   Notice there are no quotation marks around the word ``count``. It is a variable name, not a
   string literal. (You would find quotation marks around the word if it was a string literal.) When
   you run the program, the Kotlin compiler evaluates the expression inside the parentheses, which
   is ``count``, for the ``println()`` instruction. Since the expression evaluates to ``2``, then
   the ``println()`` method is called with ``2`` as the input: ``println(2)``.

   Hence the output of the program is:

   ::

      2

   The number by itself in the output is not very useful. It would be more helpful to have a more
   detailed message printed in the output to explain what the ``2`` represents.


String template

   A more helpful message to display in the output is:

   ::

      You have 2 unread messages.

   Follow these steps so that the program outputs a more helpful message.

   1. Update your program in the Kotlin Playground with the following code. For the ``println()``
      call, pass in a string literal that contains the ``count`` variable name. Remember to surround
      the text with quotation marks. Note that this will not give you the results you expect. You'll
      fix the issue in a later step.

   .. code:: prettyprint

      fun main() {
          val count: Int = 2
          println("You have count unread messages.")
      }

   2. Run the program and the output should display:

   ::

      You have count unread messages.

   That sentence doesn't make sense! You want the value of the ``count`` variable to be displayed in
   the message, not the variable name.

   3. To fix the output, you need a string template. This is a *string template* because it contains
      a *template expression*, which is a dollar sign (``$``) followed by a variable name. A
      template expression is evaluated, and its value gets substituted into the string.


   :: 

                            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         "string contents $ â”‚ variable name â”‚ rest of string"
                            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   Add a dollar sign ``$`` before the ``count`` variable. In this case, the template expression
   ``$count`` evaluates to ``2``, and the ``2`` gets substituted into the string where the
   expression was located.

   .. code:: prettyprint

      fun main() {
          val count: Int = 2
          println("You have $count unread messages.")
      }

   4. When you run the program, the output matches the desired goal:

   ::

      You have 2 unread messages.

   That sentence makes much more sense to the user!

   5. Now change the initial value of the ``count`` variable to a different integer literal. For
      example, you could choose the number ``10``. Leave the rest of the code in the program
      unchanged.

   .. code:: prettyprint

      fun main() {
          val count: Int = 10
          println("You have $count unread messages.")
      }

   6. Run the program. Notice that the output changes accordingly and you didn't even need to change
      the ``println()`` statement in your program.

   ::

      You have 10 unread messages.

   You can see how useful a string template can be. You only wrote the string template once in your
   code (``"You have $count unread messages."``). If you change the initial value of the ``count``
   variable, the ``println()`` statement still works. Your code is more flexible now!

   To further emphasize this point, compare the following two programs. The first program uses a
   string literal, with the exact number of unread messages directly in the string. This program
   only works when your user has 10 unread messages.

   .. code:: prettyprint

      fun main() {
          println("You have 10 unread messages.")
      }

   By using a variable and a string template in the second program, your code can adapt to more
   scenarios. This second program is more flexible!

   .. code:: prettyprint

      fun main() {
          val count: Int = 10
          println("You have $count unread messages.")
      }


**Type inference**

   Here's a tip that allows you to write less code when declaring variables.

   Type inference is when the Kotlin compiler can infer (or determine) what data type a variable
   should be, without the type being explicitly written in the code. That means you can omit the
   data type in a variable declaration, if you provide an initial value for the variable. The Kotlin
   compiler looks at the data type of the initial value, and assumes that you want the variable to
   hold data of that type.

   The following syntax is for a variable declaration that uses type inference:

   :: 

            â•­â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      val   â”‚ naem â”‚  =  â”‚ initial value â”‚
            â•°â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   Returning to the ``count`` example, the program initially contained this line of code:

   .. code:: prettyprint

      val count: Int = 2

   However, this line of code can also be written as follows. Notice that the colon symbol (``:``)
   and ``Int`` data type are omitted. The updated syntax has fewer words to type, and it achieves
   the same outcome of creating an ``Int`` variable called ``count`` with a value of ``2``.

   .. code:: prettyprint

      val count = 2

   The Kotlin compiler knows that you want to store ``2`` (a whole number integer) into the variable
   ``count``, so it can infer that the ``count`` variable is of type ``Int``. Convenient, right?
   This is one example of how writing Kotlin code is more concise!

   **Note:** If you don't provide an initial value when you declare a variable, you must specify the
   type.

   In this line of code, no initial value is provided, so you must specify the data type:

   ``val count: Int``

   In this line of code, an assigned value is provided, so you can omit the data type:

   ``val count = 2``

   Even though this example only discusses a variable of type ``Int``, the concept of type inference
   applies to all data types in Kotlin.


**Basic math operations with integers**

   What is the difference between an ``Int`` variable with value ``2`` and a ``String`` variable
   with value ``"2"``? When they both get printed to the output, they look the same.

   The advantage to storing integers as an ``Int`` (as opposed to a ``String``) is that you can
   perform math operations with ``Int`` variables, such as addition, subtraction, division, and
   multiplication (see other `operators <https://kotlinlang.org/docs/keyword-reference.html#operators-and-special-symbols>`__).
   For example, two integer variables can be added together to get their sum. There are certainly
   cases where it's reasonable to have integers stored as Strings, but the purpose of this section
   is to show you what you can do with ``Int`` variables.

   1. Return to the Kotlin Playground and remove all the code in the code editor.
   2. Create a new program where you define an integer variable for the number of unread emails in
      an inbox, and initialize it to a value such as ``5``. You can pick a different number if you'd
      like. Define a second integer variable for the number of read emails in an inbox. Initialize
      it to a value such as ``100``. You can pick a different number if you'd like. Then print out
      the total number of messages in the inbox by adding the two integer numbers together.

   .. code:: prettyprint

      fun main() {
          val unreadCount = 5
          val readCount = 100
          println("You have ${unreadCount + readCount} total messages in your inbox.")
      }

   3. Run the program and it should display the total number of messages in the inbox:

   ::

      You have 105 total messages in your inbox.

   For a string template, you learned that you can put the ``$`` symbol before a single variable
   name. However, if you have a more complex expression, you must enclose the expression in curly
   braces with the ``$`` symbol before the curly braces: ``${unreadCount + readCount}``. The
   expression within the curly braces, ``unreadCount + readCount``, evaluates to ``105``. Then the
   value ``105`` is substituted within the string literal.

   :: 

      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      â”‚      expression       â”‚     â”‚    value    â”‚
      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

      unreadCount  +  readCount           105


   **Warning:** If you forget the curly braces around the template expression, you will get
   unexpected results. You can test that out in the Kotlin Playground by changing the ``println()``
   statement to ``println("You have $unreadCount + readCount total messages in your inbox.")`` and
   observing the output.

   4. To explore this topic further, create variables with different names and different initial
      values, and use template expressions to print messages to the output.

   For example, modify your program to print this out:

   ::

      100 photos
      10 photos deleted
      90 photos left

   Here's one way that you can write your program, though there are other correct ways to write it
   too!

   .. code:: prettyprint

      fun main() {
          val numberOfPhotos = 100
          val photosDeleted = 10
          println("$numberOfPhotos photos")
          println("$photosDeleted photos deleted")
          println("${numberOfPhotos - photosDeleted} photos left")
      }


4. Update variables
-------------------


   When an app is running, the value of a variable may need to be updated. For example, in a
   shopping app, as the user adds items to the shopping cart, the cart total increases.

   Let's simplify the shopping use case into a simple program. The logic is written out below with
   human language, not in Kotlin. This is called *pseudocode* because it describes the key points of
   how the code will be written, but it doesn't contain all the details of the code.

   **Note:** Pseudocode is not meant to be working code that can be compiled, that's why it's called
   pseudo code.

   In the main function of a program:

   -  Create an integer ``cartTotal`` variable that starts at the value ``0``.
   -  The user adds a sweater that costs $20 to their shopping cart.
   -  Update the ``cartTotal`` variable to ``20``, which is the current cost of the items in their
      shopping cart.
   -  Print the total cost of the items in their cart, which is the ``cartTotal`` variable, to the
      output.

   To further simplify the code, you don't need to write the code for when the user adds items to
   the shopping cart. (You haven't learned about how a program can respond to user input yet. That
   will come in a later unit.) Hence, focus on the parts where you create, update, and print out the
   ``cartTotal`` variable.

   1. Replace the existing code in the Kotlin Playground with the below program. In line 2 of the
      program, you initialize the ``cartTotal`` variable to the value ``0``. Since you provide an
      initial value, there's no need to specify the ``Int`` data type due to type inference. In line
      3 of the program, you attempt to update the ``cartTotal`` variable to ``20`` with the
      assignment operator (``=``). In line 4 of the program, you print out the ``cartTotal``
      variable using a string template.

   .. code:: prettyprint

      fun main() {
          val cartTotal = 0
          cartTotal = 20
          println("Total: $cartTotal")
      }

   2. Run the program, and you will get a compile error.
   3. Notice the error says that the ``val`` can't be reassigned. The error is on the third line of
      the program, which tries to change the value of the ``cartTotal`` variable to ``20.`` The
      ``val`` ``cartTotal`` can't be reassigned to another value (``20``) after it's been assigned
      an initial value (``0``).

   ::

      Val cannot be reassigned

   If you need to update the value of a variable, declare the variable with the Kotlin keyword
   ``var``, instead of ``val``.

   -  ``val`` keyword - Use when you expect the variable value will not change.
   -  ``var`` keyword - Use when you expect the variable value can change.

   With ``val``, the variable is *read-only*, which means you can only read, or access, the value of
   the variable. Once the value is set, you cannot edit or modify its value. With ``var``, the
   variable is *mutable*, which means the value can be changed or modified. The value can be
   mutated.

   To remember the difference, think of ``val`` as a fixed *value* and ``var`` as *variable*. In
   Kotlin, it's recommended to use the ``val`` keyword over the ``var`` keyword when possible.

   4. Update the variable declaration for ``cartTotal`` on line 2 of the program to use ``var``
      instead of ``val``. This is how the code should look:

   .. code:: prettyprint

      fun main() {
          var cartTotal = 0
          cartTotal = 20
          println("Total: $cartTotal")
      }

   5. Notice the syntax of the code on line 3 of the program which updates the variable.

   .. code:: prettyprint

      cartTotal = 20

   Use the assignment operator (``=``) to assign a new value (``20``) to the existing variable
   (``cartTotal``). You don't need to use the ``var`` keyword again because the variable is already
   defined.

   :: 

                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®
                  v        â”‚
            val carTotal = 20


   Using the box analogy, picture the value ``20`` being stored in the box labeled ``cartTotal``.

   :: 

         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®       â•­â”€â”€â”€â”€â•®
         â”‚ carTotal â”‚ <â”€â”€â”€â”€ â”‚ 20 â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯       â•°â”€â”€â”€â”€â•¯

   Here's a diagram for the general syntax for updating a variable, which has already been declared
   on an earlier line of code. Start the statement with the name of the variable you want to update.
   Add a space, the equal sign, followed by another space. Then write out the updated value for the
   variable.


   :: 

         â•­â”€â”€â”€â”€â”€â”€â•®       â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ name â”‚   =   â”‚ updated value â”‚
         â•°â”€â”€â”€â”€â”€â”€â•¯       â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   6. Run your program and the code should successfully compile. It should print this output :

   ::

      Total: 20

   7. To see how the variable value changes while the program is running, print the ``cartTotal``
      variable to the output after the variable is initially declared. See the code changes below.
      Line 3 has a new ``println()`` statement. There's also a blank line added on line 4 of the
      code. Blank lines do not have any impact on how the compiler understands the code. Add a blank
      line where it would make it easier to read your code by separating out related blocks of code.

   .. code:: prettyprint

      fun main() {
          var cartTotal = 0
          println("Total: $cartTotal")

          cartTotal = 20
          println("Total: $cartTotal")
      }

   8. Run the program again and the output should be:

   .. code:: prettyprint

      Total: 0
      Total: 20

   You can see that initially the shopping cart total is ``0``. Then it updates to ``20``. You
   successfully updated a variable! This was possible because you changed ``cartTotal`` from a
   read-only variable (with ``val``) to a mutable variable (with ``var``).

   Remember that you should only use ``var`` to declare a variable if you expect the value to
   change. Otherwise you should default to using ``val`` to declare a variable. This practice makes
   your code safer. Using ``val`` ensures that variables won't get updated in your program if you
   don't expect them to. Once a ``val`` is assigned a value, it always stays that value.

   **Note:** If you are familiar with other programming languages, declaring a ``val`` is like
   declaring a constant value because it is a read-only variable. There are additional conventions
   to follow when declaring constants in Kotlin, which is more advanced for this codelab, but you
   can find them in the `Constants <https://developer.android.google.cn/kotlin/style-guide#constant_names>`__ 
   section of the style guide.


**Increment and decrement operators**

   Now you know that a variable must be declared as a ``var`` in order to update its value. Apply
   this knowledge to the email message example below that should look familiar.

   1. Replace the code in the Kotlin Playground with this program:

   .. code:: prettyprint

      fun main() {
          val count: Int = 10
          println("You have $count unread messages.")
      }

   2. Run the program. It should print out:

   ::

      You have 10 unread messages.

   3. Replace the ``val`` keyword with the ``var`` keyword to make the ``count`` variable a mutable
      variable. There should be no change in the output when you run the program.

   .. code:: prettyprint

      fun main() {
          var count: Int = 10
          println("You have $count unread messages.")
      }

   4. However, now you can update the ``count`` to a different value. For example, when one new
      email arrives in the user's inbox, you can increase ``count`` by 1. (You don't need to write
      the code for the arrival of an email. Getting data from the internet is a more advanced topic
      for a much later unit.) For now, focus on the ``count`` variable increasing by ``1`` with this
      line of code:

   .. code:: prettyprint

      count = count + 1

   The expression to the right of the equal sign is ``count + 1`` and evaluates to ``11``. That is
   because the current value of ``count`` is ``10`` (which is on line 2 of the program) and
   ``10 + 1`` equals ``11``. Then with the assignment operator, the value ``11`` gets assigned or
   stored in the ``count`` variable.

   ::

                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                  â”‚           â”‚
                  v      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            val count =  â”‚ count + 1 â”‚
                         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   Add this line of code to your program at the bottom of the ``main()`` function. Your code should
   look like the following:

   .. code:: prettyprint

      fun main() {
          var count = 10
          println("You have $count unread messages.")
          count = count + 1
      }

   If you run the program now, the output is the same as before because you haven't added any code
   to use the ``count`` variable after you updated it.

   5. Add another print statement that prints out the number of unread messages after the variable
      has been updated.

   .. code:: prettyprint

      fun main() {
          var count = 10
          println("You have $count unread messages.")
          count = count + 1
          println("You have $count unread messages.")
      }

   6. Run the program. The second message should display the updated ``count`` of ``11`` messages.

   ::

      You have 10 unread messages.
      You have 11 unread messages.

   7. For shorthand, if you want to increase a variable by ``1``, you can use the *increment
      operator* (``++``) which is made up of two plus symbols. By using these symbols directly after
      a variable name, you tell the compiler that you want to add 1 to the current value of the
      variable, and then store the new value in the variable. The following two lines of code are
      equivalent, but using the ``++`` increment operator involves less typing.

   .. code:: prettyprint

      count = count + 1

   .. code:: prettyprint

      count++

   Make this modification to your code and then run your program. There should be no spaces between
   the variable name and the increment operator.

   .. code:: prettyprint

      fun main() {
          var count = 10
          println("You have $count unread messages.")
          count++
          println("You have $count unread messages.")
      }

   8. Run the program. The output is the same, but now you learned about a new operator!

   ::

      You have 10 unread messages.
      You have 11 unread messages.

   9. Now modify line 4 of your program to use the *decrement operator* (``--``) after the ``count``
      variable name. The decrement operator is made up of two minus symbols. By placing the
      decrement operator after the variable name, you tell the compiler that you want to decrease
      the value of the variable by ``1`` and store the new value into the variable.

   .. code:: prettyprint

      fun main() {
          var count = 10
          println("You have $count unread messages.")
          count--
          println("You have $count unread messages.")
      }

   10. Run the program. It should print this output:

   ::

      You have 10 unread messages.
      You have 9 unread messages.

   In this section, you learned how to update a mutable variable using the increment operator
   (``++``) and the decrement operator (``--``). More specifically, ``count++`` is the same as
   ``count = count + 1`` and ``count--`` is the same as ``count = count - 1``.


5. Explore other data types
---------------------------


   Earlier in the codelab, you were introduced to some common basic data types: ``String``, ``Int``,
   ``Double``, and ``Boolean``. You just used the ``Int`` data type, now you will explore other data
   types.

   ==================== ================================================
   **Kotlin data type** **What kind of data it can contain**
   ``String``           Text
   ``Int``              Integer number
   ``Double``           Decimal number
   ``Boolean``          ``true`` or ``false`` (only two possible values)
   ==================== ================================================

   Try these programs in the Kotlin Playground to see what the output is.


Double

   When you need a variable with a decimal value, use a ``Double`` variable. To learn about its
   valid range, refer to `this table <https://kotlinlang.org/docs/numbers.html#floating-point-types>`__ 
   and look at the decimal digits it can store for example.

   **Note:** The name of the ``Double`` data type comes from the data type having double precision
   compared to the ``Float`` data type, which has single precision. Precision is how many decimal
   digits they can hold. Hence, a ``Double`` variable can store a more precise value. `This table <https://kotlinlang.org/docs/numbers.html#floating-point-types>`__ 
   shows more details about the specific differences between ``Double`` and ``Float`` types if 
   you're curious. This section of the codelab focuses on using ``Double`` for working with decimal numbers.

   Imagine you're navigating to a destination, and your trip is split into three separate parts
   because you need to make stops along the way. This program displays the total distance left to
   reach your destination.

   1. Enter this code in the Kotlin Playground. Can you understand what is happening on each line of
      code?

   .. code:: prettyprint

      fun main() {
          val trip1: Double = 3.20
          val trip2: Double = 4.10
          val trip3: Double = 1.72
          val totalTripLength: Double = 0.0
          println("$totalTripLength miles left to destination")
      }

   Three variables called ``trip1``, ``trip2``, and ``trip3`` are declared to represent the distance
   of each part of the trip. All of them are ``Double`` variables because they store decimal values.
   Use ``val`` to declare each variable because their values do not change over the course of the
   program. The program also creates a fourth variable called ``totalTripLength`` which is currently
   initialized to ``0.0``. The last line of the program prints a message with the value of the
   ``totalTripLength`` variable.

   2. Fix the code so that the ``totalTripLength`` variable is the sum of all three trip lengths.

   .. code:: prettyprint

      val totalTripLength: Double = trip1 + trip2 + trip3

   The expression on the right of the equal sign evaluates to ``9.02`` because
   ``3.20 + 4.10 + 1.72`` equals ``9.02``. The value of ``9.02`` gets stored into the
   ``totalTripLength`` variable.

   ::

                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                  â”‚                                  â”‚
                  v                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      val totalTripLength: Double =  â”‚ trip1 + trip2 + trip3 â”‚
                                     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   Your whole program should look like the below code:

   .. code:: prettyprint

      fun main() {
          val trip1: Double = 3.20
          val trip2: Double = 4.10
          val trip3: Double = 1.72
          val totalTripLength: Double = trip1 + trip2 + trip3
          println("$totalTripLength miles left to destination")
      }

   3. Run the program. It should print this out:

   ::

      9.02 miles left to destination

   4. Update your code to remove the unnecessary ``Double`` data type from the variable declarations
      because of type inference. The Kotlin compiler can infer that these variables are ``Double``
      data types based on the decimal numbers provided as initial values.

   .. code:: prettyprint

      fun main() {
          val trip1 = 3.20
          val trip2 = 4.10
          val trip3 = 1.72
          val totalTripLength = trip1 + trip2 + trip3
          println("$totalTripLength miles left to destination")
      }

   5. Run your code again to ensure that your code still compiles. The output should be the same,
      but now your code is simpler!


**String**

   When you need a variable that can store text, use a ``String`` variable. Remember to use
   quotation marks around String literal values, such as ``"Hello Kotlin"``, whereas the ``Int`` and
   ``Double`` literal values do not have quotes around them.

   1. Copy and paste this program into the Kotlin Playground.

   .. code:: prettyprint

      fun main() {
          val nextMeeting = "Next meeting:"
          val date = "January 1"
          val reminder = nextMeeting + date
          println(reminder)
      }

   Notice that there are two ``String`` variables declared, a ``nextMeeting`` variable and a
   ``date`` variable. Then a third ``String`` variable called ``reminder`` is declared, which is set
   equal to the ``nextMeeting`` variable plus the ``date`` variable.

   With the + symbol, you can add two strings together, which is called *concatenation*. The two
   strings are combined together, one after the other. The result of the expression,
   ``nextMeeting + date`` is ``"Next meeting:January 1"`` as shown in the diagram below.

   ::

               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
               â”‚          evaluates to            â”‚
      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                      v
      â”‚ nextMeeting + date â”‚          "Next meeting:January 1"
      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   The value ``"Next meeting:January 1"`` is then stored into the ``reminder`` variable using the
   assignment operator on line 4 of the program.

   2. Run your program. It should print this out:

   ::

      Next meeting:January 1

   When you concatenate two strings together, there are no extra spaces added between the strings.
   If you want a space after the colon in the resulting string, you need to add the space to one
   string or the other.

   3. Update your ``nextMeeting`` variable to have an extra space at the end of the string before
      the closing quotation mark. (Alternatively, you could have added an extra space to the
      beginning of the ``date`` variable). Your program should look like the following:

   .. code:: prettyprint

      fun main() {
          val nextMeeting = "Next meeting: "
          val date = "January 1"
          val reminder = nextMeeting + date
          println(reminder)
      }

   4. Run your program again and now there should be a space after the colon in the output message.

   ::

      Next meeting: January 1

   5. Modify the code so that you concatenate - or add - another piece of text to the expression
      that gets stored in the ``reminder`` variable.

   Use the ``+`` symbol to add the string literal ``" at work"`` to the end of the ``reminder``
   string.

   6. Run the program.

   It should print this output:

   ::

      Next meeting: January 1 at work

   The code below shows you one way that you could implement the behavior.

   .. code:: prettyprint

      fun main() {
          val nextMeeting = "Next meeting: "
          val date = "January 1"
          val reminder = nextMeeting + date + " at work"
          println(reminder)
      }

   Notice that there are no quotation marks around ``nextMeeting`` and ``date`` because they are
   names of existing string variables (where their respective values are text with quotes around
   them). Conversely, the literal ``" at work"`` is not previously defined in any variable, so use
   quotations around this text in order for the compiler to know that this is a string that should
   be concatenated onto the other strings.

   Technically, you can achieve the same output by declaring a single ``String`` variable with the
   full text instead of using separate variables. However, the purpose of this exercise is to
   demonstrate how you can declare and manipulate ``String`` variables, especially how to
   concatenate separate strings.

   7. When reading code that contains strings, you may come across *escape sequences*. Escape
      sequences are characters that are preceded with a backslash symbol (``\``), which is also
      called an escaping backslash.

   An example is seeing ``\"`` within a string literal like in the below example. Copy and paste
   this code into the Kotlin Playground.

   .. code:: prettyprint

      fun main() {
          println("Say \"hello\"")
      }

   You learned earlier to use double quotation marks around a string literal. But what if you want
   to use the ``"`` symbol in your string? Then you need to add the backslash symbol before the
   double quotation mark as ``\"`` within your string. Remember that there should still be double
   quotation marks around the whole string.

   8. Run the program to see the output. It should show:

   ::

      Say "hello"

   In the output, there are quotation marks displayed around ``hello`` because we added ``\"``
   before and after ``hello`` in the ``println()`` statement.

   For other escape sequences supported in Kotlin, refer to the documentation page on 
   `escape sequences <https://kotlinlang.org/docs/characters.html>`__. 
   For example, if you want a new line in your string, use the ``\`` symbol before 
   the character n as in ``\n``.

   Now you've learned about concatenating strings and also escape sequences within strings. Move
   onto the last data type that this codelab covers.


**Boolean**

   The ``Boolean`` data type is useful when your variable only has two possible values represented
   by ``true`` or ``false``.

   An example is a variable that represents whether a device's airplane mode is on or off, or
   whether an app's notifications are enabled or disabled.

   1. Enter this code in the Kotlin Playground. In line 2 of this program, you declare a ``Boolean``
      variable called ``notificationsEnabled`` and initialize it to ``true``. Technically, you can
      omit ``: Boolean`` in the declaration, so you can remove it if you'd like. In line 3 of the
      program, you print out the value of the ``notificationsEnabled`` variable.

   .. code:: prettyprint

      fun main() {
          val notificationsEnabled: Boolean = true
          println(notificationsEnabled)
      }

   Run the program, and it should print this out:

   ::

      true

   2. Change the initial value of the ``Boolean`` to false on line 2 of the program.

   .. code:: prettyprint

      fun main() {
          val notificationsEnabled: Boolean = false
          println(notificationsEnabled)
      }

   Run the program, and it should print this out:

   ::

      false

   3. Other data types can be concatenated to ``Strings``. For example, you can concatenate
      ``Booleans`` to ``Strings``. Use the ``+`` symbol to concatenate (or append) the value of the
      ``notificationsEnabled`` boolean variable onto the end of the
      ``"Are notifications enabled? "`` string.

   .. code:: prettyprint

      fun main() {
          val notificationsEnabled: Boolean = false
          println("Are notifications enabled? " + notificationsEnabled)
      }

   Run the program to see the result of the concatenation. The program should print this output:

   ::

      Are notifications enabled? false

   You can see that it's possible to set the ``Boolean`` variable to a ``true`` or ``false`` value.
   ``Boolean`` variables enable you to code more interesting scenarios in which you execute some set
   of instructions when a ``Boolean`` variable has a ``true`` value. Or if the ``Boolean`` has a
   false value, you skip those instructions. You learn more about ``Booleans`` in a future codelab.


6. Coding conventions
---------------------


   In the previous codelab, you were introduced to the Kotlin style guide for writing Android code
   in a consistent way as recommended by Google and followed by other professional developers.

   Here are a couple of other formatting and coding conventions for you to follow based on the new
   topics you learned:

   -  Variable names should be in camel case and start with a lowercase letter.
   -  In a variable declaration, there should be a space after a colon when you specify the data
      type.

   ::

                   â•­â”€â”€â”€â”€â”€â”€ space
                   v 
      val discount: Double = .20


   -  There should be a space before and after an operator like the assignment (``=``), addition
      (``+``), subtraction (``-``), multiplication (``*``), division (``/``) operators and more.

   ::

             â•­â”€â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ space
             v v 
      var pet = "bird"

                 â•­â”€â•­â”€â”€â”€â”€â”€â”€ space
                 v v 
      val sum = 1 + 2

   -  As you write more complex programs, there is a recommended limit of 
      `100 characters per line <https://developer.android.google.cn/kotlin/style-guide#line_wrapping>`__. 
      That ensures that you can read all the code in a program easily on your computer screen, 
      without needing to scroll horizontally when reading code.


7. Commenting in your code
--------------------------


   When coding, another good practice to follow is to add *comments* that describe what the code is
   intended to do. Comments can help people who read your code follow it more easily. Two forward
   slash symbols, or ``//``, indicate that the text after it on the rest of the line is considered a
   comment, so it isn't interpreted as code. It's common practice to add a space after the two
   forward slash symbols.

   .. code:: prettyprint

      // This is a comment.

   A comment can also start in the middle of a line of code. In this example, ``height = 1`` is a
   normal coding statement. ``// Assume the height is 1 to start with`` is interpreted as a comment
   and not considered part of the code.

   .. code:: prettyprint

      height = 1 // Assume the height is 1 to start with

   If you want to describe the code in more detail with a long comment that exceeds 100 characters
   on a line, use a multi-line comment. Start the multi-line comment with a forward slash (``/``)
   and an asterisk symbol ( ``*`` ) as ``/*``. Add an asterisk at the beginning of each new line of
   the comment. Then finally end the comment with an asterisk and forward slash symbol ``*/``.

   .. code:: prettyprint

      /*
       * This is a very long comment that can
       * take up multiple lines.
       */

   This program contains single-line and multi-line comments that describe what's happening:

   .. code:: prettyprint

      /*
       * This program displays the number of messages
       * in the user's inbox.
       */
      fun main() {
          // Create a variable for the number of unread messages.
          var count = 10
          println("You have $count unread messages.")

          // Decrease the number of messages by 1.
          count--
          println("You have $count unread messages.")
      }

   As mentioned earlier, you can add blank empty lines to your code to group related statements
   together and make the code easier to read.

   1. Add some comments to an earlier code snippet that you used.
   2. Run the program to ensure that the behavior didn't change because comments shouldn't affect
      the output.


8. Conclusion
-------------


   Excellent work! You learned about variables in Kotlin, why variables are useful in programming,
   and how to create, update, and use them. You experimented with different basic data types in
   Kotlin, including the ``Int``, ``Double``, ``String``, and ``Boolean`` data types. You also
   learned about the difference between the ``val`` and ``var`` keywords.

   All of these concepts are critical building blocks on your journey to become a developer.

   See you in the next codelab!


**Summary**

   -  A variable is a container for a single piece of data.
   -  You must declare a variable first before you use it.
   -  Use the ``val`` keyword to define a variable that is read-only where the value cannot change
      once it's been assigned.
   -  Use the ``var`` keyword to define a variable that is mutable or changeable.
   -  In Kotlin, it's preferred to use ``val`` over ``var`` when possible.
   -  To declare a variable, start with the ``val`` or ``var`` keyword. Then specify the variable
      name, data type, and initial value. For example: ``val count: Int = 2``.
   -  With type inference, omit the data type in the variable declaration if an initial value is
      provided.
   -  Some common basic Kotlin data types include: ``Int``, ``String``, ``Boolean``, ``Float``, and
      ``Double``.
   -  Use the assignment operator (``=``) to assign a value to a variable either during declaration
      of the variable or updating the variable.
   -  You can only update a variable that has been declared as a mutable variable (with ``var``).
   -  Use the increment operator (``++``) or decrement operator (``--``) to increase or decrease the
      value of an integer variable by 1, respectively.
   -  Use the ``+`` symbol to concatenate strings together. You can also concatenate variables of
      other data types like ``Int`` and ``Boolean`` to ``Strings``.


**Learn more**

   -  `Variables <https://play.kotlinlang.org/byExample/01_introduction/03_Variables>`__
   -  `Basic types <https://kotlinlang.org/docs/basic-types.html>`__
   -  `String templates <https://kotlinlang.org/docs/basic-syntax.html#string-templates>`__
   -  `Keywords and operators <https://kotlinlang.org/docs/keyword-reference.html>`__
   -  `Basic syntax <https://kotlinlang.org/docs/basic-syntax.html>`__

.. |72302735e50d7d85.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-variables/img/72302735e50d7d85.png
.. |a7e1f5184e4e3b15.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-variables/img/a7e1f5184e4e3b15.png
.. |a1688b9b297c7501.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-variables/img/a1688b9b297c7501.png
.. |f515a6481cc91bf2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-variables/img/f515a6481cc91bf2.png


â­ Create and use functions in Kotlin
======================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-functions


1. Before you begin
-------------------

   In an earlier codelab, you saw a simple program that printed ``Hello, world!``. In the programs
   you've written so far, you've seen two functions:

   -  a ``main()`` function, which is required in every Kotlin program. It is the entry point, or
      starting point, of the program.
   -  a ``println()`` function, which you called from ``main()`` to output text.

   In this codelab, you will learn more about functions.

   Functions let you break up your code into reusable pieces, rather than include everything in
   ``main()``. Functions are an essential building block of Android apps and learning how to define
   and use them is a major step on your journey to become an Android developer.


Prerequisites

   -  Knowledge of Kotlin programming basics, including variables, and the ``println()`` and
      ``main()`` functions


What you'll learn

   -  How to define and call your own functions.
   -  How to return values from a function that you can store in a variable.
   -  How to define and call functions with multiple parameters.
   -  How to call functions with named arguments.
   -  How to set default values for function parameters.


What you'll need

   -  A web browser with access to Kotlin Playground


2. Define and call a function
-----------------------------

   Before exploring functions in-depth, let's review some basic terminology.

   -  Declaring (or defining) a function uses the ``fun`` keyword and includes code within the curly
      braces which contains the instructions needed to execute a task.
   -  Calling a function causes all the code contained in that function to execute.

   So far, you've written all your code in the ``main()`` function. The ``main()`` function doesn't
   actually get called anywhere in your code; the Kotlin compiler uses it as a starting point. The
   ``main()`` function is intended only to include other code you want to execute, such as calls to
   the ``println()`` function.

   The ``println()`` function is part of the Kotlin language. However, you can define your own
   functions. This allows your code to be reused if you need to call it more than once. Take the
   following program as an example.

   .. code:: prettyprint

      fun main() {
          println("Happy Birthday, Rover!")
          println("You are now 5 years old!")
      }

   The ``main()`` function consists of two ``println()`` statementsâ€”one to wish Rover a happy
   birthday, and another stating Rover's age.

   While Kotlin allows you to put all your code in the ``main()`` function, you might not always
   want to. For example, if you also want your program to contain a New Year's greeting, the main
   function would have to include those calls to ``println()`` as well. Or perhaps you want to greet
   Rover multiple times. You could simply copy and paste the code, or you could create a separate
   function for the birthday greeting. You'll do the latter. Creating separate functions for
   specific tasks has a number of benefits.

   -  Reusable code: Rather than copying and pasting code that you need to use more than once, you
      can simply call a function wherever needed.
   -  Readability: Ensuring functions do one and only one specific task helps other developers and
      teammates, as well as your future self to know exactly what a piece of code does.

   The syntax for defining a function is shown in the following diagram.

   ::

           â•­â”€â”€â”€â”€â”€â”€â•®  
      fun  â”‚ name â”‚ () {
           â•°â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ function body          â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   A function definition starts with the ``fun`` keyword, followed by the name of the function, a
   set of opening and closing parentheses, and a set of opening and closing curly braces. Contained
   in curly braces is the code that will run when the function is called.

   You'll create a new function to move the two ``println()`` statements out of the ``main()``
   function.

   1. In your browser, open the `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__ 
      and replace the contents with the following code.

   .. code:: prettyprint

      fun main() {
          println("Happy Birthday, Rover!")
          println("You are now 5 years old!")
      }

   2. After the ``main()`` function, define a new function named ``birthdayGreeting()``. This
      function is declared with the same syntax as the ``main()`` function.

   .. code:: prettyprint

      fun main() {
          println("Happy Birthday, Rover!")
          println("You are now 5 years old!")
      }

      fun birthdayGreeting() {
          
      }

   3. Move the two ``println()`` statements from ``main()`` into the curly braces of the
      ``birthdayGreeting()`` function.

   .. code:: prettyprint

      fun main() {
          
      }

      fun birthdayGreeting() {
          println("Happy Birthday, Rover!")
          println("You are now 5 years old!")
      }

   4. In the ``main()`` function, call the ``birthdayGreeting()`` function. Your finished code
      should look as follows:

   .. code:: prettyprint

      fun main() {
          birthdayGreeting()
      }

      fun birthdayGreeting() {
          println("Happy Birthday, Rover!")
          println("You are now 5 years old!")
      }

   5. Run your code. You should see the following output:

   ::

      Happy Birthday, Rover!
      You are now 5 years old!


3. Return a value from a function
---------------------------------

   In more complex apps, functions do more than print text.

   Kotlin functions can also generate data called a *return value* which is stored in a variable
   that you can use elsewhere in your code.

   When defining a function, you can specify the data type of the value you want it to return. The
   return type is specified by placing a colon (``:``) after the parentheses, a single blank space,
   and then the name of the type (``Int``, ``String``, etc). A single space is then placed between
   the return type and the opening curly brace. Within the function body, after all the statements,
   you use a return statement to specify the value you want the function to return. A return
   statement consists of the ``return`` keyword followed by the value, such as a variable, you want
   the function to return as an output.

   The syntax for declaring a function with a return type is as follows.


   ::

           â•­â”€â”€â”€â”€â”€â”€â•®      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      fun  â”‚ name â”‚ () : â”‚ return type â”‚ {
           â•°â”€â”€â”€â”€â”€â”€â•¯      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
           â”‚ function body          â”‚
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
           â”‚ ``return`` statement   â”‚
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


The ``Unit`` type

   By default, if you don't specify a return type, the default return type is ``Unit``. ``Unit``
   means the function doesn't return a value. ``Unit`` is equivalent to void return types in other
   languages (``void`` in Java and C; ``Void``/empty tuple ``()`` in Swift; ``None`` in Python,
   etc.). Any function that doesn't return a value implicitly returns ``Unit``. You can observe this
   by modifying your code to return ``Unit``.

   1. In the function declaration for ``birthdayGreeting()``, add a colon after the closing
      parenthesis and specify the return type as ``Unit``.

   .. code:: prettyprint

      fun main() {
          birthdayGreeting()
      }

      fun birthdayGreeting(): Unit {
          println("Happy Birthday, Rover!")
          println("You are now 5 years old!")
      }

   2. Run the code and observe that everything still works.

   ::

      Happy Birthday, Rover!
      You are now 5 years old!

   It's optional to specify the ``Unit`` return type in Kotlin. For functions that don't return
   anything, or returning ``Unit``, you don't need a return statement.

   **Note:** You'll see the ``Unit`` type again when you learn about a Kotlin feature called lambdas
   in a later codelab.


Return a ``String`` from ``birthdayGreeting()``

   To demonstrate how a function can return a value, you'll modify the ``birthdayGreeting()``
   function to return a string, rather than simply print the result.

   1. Replace the ``Unit`` return type with ``String``.

   .. code:: prettyprint

      fun birthdayGreeting(): String {
          println("Happy Birthday, Rover!")
          println("You are now 5 years old!")
      }

   2. Run your code. You'll get an error. If you declare a return type for a function (e.g.,
      ``String``), that function must include a ``return`` statement.

   ::

      A 'return' expression required in a function with a block body ('{...}')

   3. You can only return one string from a function, not two. Replace the ``println()`` statements
      with two variables, ``nameGreeting`` and ``ageGreeting,`` using the ``val`` keyword. Because
      you removed the calls to ``println()`` from ``birthdayGreeting()``, calling
      ``birthdayGreeting()`` won't print anything.

   .. code:: prettyprint

      fun birthdayGreeting(): String {
          val nameGreeting = "Happy Birthday, Rover!"
          val ageGreeting = "You are now 5 years old!"
      }

   4. Using the string formatting syntax you learned in an earlier codelab, add a ``return``
      statement to return a string from the function consisting of both greetings.

   In order to format the greetings on a separate line, you also need to use the ``\n`` escape
   character. This is just like the ``\"`` escape character you learned about in a previous codelab.
   The ``\n`` character is replaced for a newline so that the two greetings are each on a separate
   line.

   .. code:: prettyprint

      fun birthdayGreeting(): String {
          val nameGreeting = "Happy Birthday, Rover!"
          val ageGreeting = "You are now 5 years old!"
          return "$nameGreeting\n$ageGreeting"
      }

   5. In ``main()``, because ``birthdayGreeting()`` returns a value, you can store the result in a
      string variable. Declare a ``greeting`` variable using ``val`` to store the result of calling
      ``birthdayGreeting()``.

   .. code:: prettyprint

      fun main() {
          val greeting = birthdayGreeting()
      }

   6. In ``main()``, call ``println()`` to print the ``greeting`` string. The ``main()`` function
      should now look as follows.

   .. code:: prettyprint

      fun main() {
          val greeting = birthdayGreeting()
          println(greeting)
      }

   7. Run your code and then observe that the result is the same as before. Returning a value lets
      you store the result in a variable, but what do you think happens if you call the
      ``birthdayGreeting()`` function inside the ``println()`` function?

   ::

      Happy Birthday, Rover!
      You are now 5 years old!

   8. Remove the variable and then pass the result of calling the ``birthdayGreeting()`` function
      into the ``println()`` function:

   .. code:: prettyprint

      fun main() {
          println(birthdayGreeting())
      }

   9. Run your code and observe the output. The return value of calling ``birthdayGreeting()`` is
      passed directly into ``println()``.

   ::

      Happy Birthday, Rover!
      You are now 5 years old!


4. Add a parameter to the birthdayGreeting() function
-----------------------------------------------------

   As you've seen, when you call ``println()``, you can include a string within the parentheses or
   *pass a value* to the function. You can do the same with your ``birthdayGreeting()`` function.
   However, you first need to add a *parameter* to ``birthdayGreeting()``.

   A parameter specifies the name of a variable and a data type that you can pass into a function as
   data to be accessed inside the function. Parameters are declared within the parentheses after the
   function name.


   ::

           â•­â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      fun  â”‚ name â”‚ ( â”‚ parameters â”‚ ) : â”‚ return type â”‚ {
           â•°â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
           â”‚ function body          â”‚
           â”‚ ``return`` statement   â”‚
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   Each parameter consists of a variable name and data type, separated by a colon and a space.
   Multiple parameters are separated by a comma.

   Right now, the ``birthdayGreeting()`` function can only be used to greet Rover. You'll add a
   parameter to the ``birthdayGreeting()`` function so that you can greet any name that you pass
   into the function.

   1. Within the parentheses of the ``birthdayGreeting()`` function, add a ``name`` parameter of
      type ``String``, using the syntax ``name: String``.

   .. code:: prettyprint

      fun birthdayGreeting(name: String): String {
          val nameGreeting = "Happy Birthday, Rover!"
          val ageGreeting = "You are now 5 years old!"
          return "$nameGreeting\n$ageGreeting"
      }

   The parameter defined in the previous step works like a variable declared with the ``val``
   keyword. Its value can be used anywhere in the ``birthdayGreeting()`` function. In an earlier
   codelab, you learned about how you can insert the value of a variable into a string.

   2. Replace ``Rover`` in the ``nameGreeting`` string with the ``$`` symbol followed by the
      ``name`` parameter.

   .. code:: prettyprint

      fun birthdayGreeting(name: String): String {
          val nameGreeting = "Happy Birthday, $name!"
          val ageGreeting = "You are now 5 years old!"
          return "$nameGreeting\n$ageGreeting"
      }

   3. Run your code and observe the error. Now that you declared the ``name`` parameter, you need to
      pass in a ``String`` when you call ``birthdayGreeting()``. When you call a function that takes
      a parameter, you pass an argument to the function. The argument is the value that you pass,
      such as ``"Rover"``.

   ::

      No value passed for parameter 'name'

   4. Pass ``"Rover"`` into the ``birthdayGreeting()`` call in ``main()``.

   .. code:: prettyprint

      fun main() {
          println(birthdayGreeting("Rover"))
      }

   5. Run your code and observe the output. The name Rover comes from the ``name`` parameter.

   ::

      Happy Birthday, Rover!
      You are now 5 years old!

   6. Because ``birthdayGreeting()`` takes a parameter, you can call it with a name other than
      Rover. Add another call to ``birthdayGreeting()`` inside the call to ``println()``, passing in
      the argument ``"Rex"``.

   .. code:: prettyprint

      println(birthdayGreeting("Rover"))
      println(birthdayGreeting("Rex"))

   7. Run the code again and then observe that the output differs based on the argument passed into
      ``birthdayGreeting()``.

   ::

      Happy Birthday, Rover!
      You are now 5 years old!
      Happy Birthday, Rex!
      You are now 5 years old!

   **Note:** Although you often find them used interchangeably, a parameter and an argument aren't
   the same thing. When you define a function, you define the parameters that are to be passed to it
   when the function is called. When you call a function, you pass arguments for the parameters.
   Parameters are the variables accessible to the function, such as a ``name`` variable, while
   arguments are the actual values that you pass, such as the ``"Rover"`` string.

   **Warning:** Unlike in some languages, such as Java, where a function can change the value passed
   into a parameter, parameters in Kotlin are immutable. You cannot reassign the value of a
   parameter from within the function body.


5. Functions with multiple parameters
-------------------------------------

   Previously, you added a parameter to change the greeting based on the name. However, you can also
   define more than one parameter for a function, even parameters of different data types. In this
   section, you'll modify the greeting so that it also changes based on the dog's age.


   ::

           â•­â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®      
      fun  â”‚ name â”‚ ( â”‚ 1st parameters â”‚, â”‚ 2nd parameters â”‚, ...)
           â•°â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯      


   Parameter definitions are separated by commas. Similarly, when you call a function with multiple
   parameters, you separate the arguments passed in with commas as well. Let's see this in action.

   1. After the ``name`` parameter, add an ``age`` parameter of type ``Int``, to the
      ``birthdayGreeting()`` function. The new function declaration should have the two parameters,
      ``name`` and ``age``, separated by a comma:

   .. code:: prettyprint

      fun birthdayGreeting(name: String, age: Int): String {
          val nameGreeting = "Happy Birthday, $name!"
          val ageGreeting = "You are now 5 years old!"
          return "$nameGreeting\n$ageGreeting"
      }

   2. The new greeting string should use the ``age`` parameter. Update the ``birthdayGreeting()``
      function to use the value of the ``age`` parameter in the ``ageGreeting`` string.

   .. code:: prettyprint

      fun birthdayGreeting(name: String, age: Int): String {
          val nameGreeting = "Happy Birthday, $name!"
          val ageGreeting = "You are now $age years old!"
          return "$nameGreeting\n$ageGreeting"
      }

   3. Run the function and then notice the errors in the output:

   ::

      No value passed for parameter 'age'
      No value passed for parameter 'age'

   4. Modify the two calls to the ``birthdayGreeting()`` function in ``main()`` to pass in a
      different age for each dog. Pass in ``5`` for Rover's age and ``2`` for Rex's age.

   .. code:: prettyprint

      fun main() {
          println(birthdayGreeting("Rover", 5))
          println(birthdayGreeting("Rex", 2))
      }

   5. Run your code. Now that you passed in values for both parameters, the output should reflect
      the name and age of each dog when you call the function.

   ::

      Happy Birthday, Rover!
      You are now 5 years old!
      Happy Birthday, Rex!
      You are now 2 years old!


Function Signature

   So far you've seen how to define the function name, inputs (parameters), and outputs. The
   function name with its inputs (parameters) are collectively known as the *function signature*.
   The function signature consists of everything before the return type and is shown in the
   following code snippet.

   .. code:: prettyprint

      fun birthdayGreeting(name: String, age: Int)

   The parameters, separated by commas, are sometimes called the parameter list.

   You'll often see these terms in documentation for code written by other developers. The function
   signature tells you the name of the function and what data types can be passed in.

   You've learned a lot of new syntax around defining functions. Take a look at the following
   diagram for a recap of function syntax.

   ::

                   name               parameters      return type
                     â”‚                    â”‚                â”‚
              â•­â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â•®  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”´â”€â”€â•®
          fun birthdayGreeting (name: String, age: Int): String 
          {
              val nameGreeting = "Happy Birthday, $name!"        â”€â•®
                                                                  â”‚
              val ageGreeting = "You are now $age years old!"     â”œâ”€â”€ body
                                                                  â”‚
              return "$nameGreeting\n$ageGreeting"               â”€â•¯
          }  â•°â”€â”€â”¬â”€â”€â”€â•¯
                â”‚
             return statement


6. Named arguments
------------------

   In the previous examples, you didn't need to specify the parameter names, ``name`` or ``age``,
   when you called a function. However, you're able to do so if you choose. For example, you may
   call a function with many parameters or you may want to pass your arguments in a different order,
   such as putting the ``age`` parameter before the ``name`` parameter. When you include the
   parameter name when you call a function, it's called a `named argument <https://kotlinlang.org/docs/functions.html#named-arguments>`__. 
   Try using a named argument with the ``birthdayGreeting()`` function.

   1. Modify the call for Rex to use named arguments as shown in this code snippet. You can do this
      by including the parameter name followed by an equal sign, and then the value (e.g.
      ``name = "Rex"``).

   .. code:: prettyprint

      println(birthdayGreeting(name = "Rex", age = 2))

   2. Run the code and then observe that the output is unchanged:

   ::

      Happy Birthday, Rover!
      You are now 5 years old!
      Happy Birthday, Rex!
      You are now 2 years old!

   3. Reorder the named arguments. For example, put the ``age`` named argument before the ``name``
      named argument.

   .. code:: prettyprint

      println(birthdayGreeting(age = 2, name = "Rex"))

   4. Run the code and observe that the output remains the same. Even though you changed the order
      of the arguments, the same values are passed in for the same parameters.

   ::

      Happy Birthday, Rover!
      You are now 5 years old!
      Happy Birthday, Rex!
      You are now 2 years old!


7. Default arguments
--------------------

   Function parameters can also specify default arguments. Maybe Rover is your favorite dog, or you
   expect a function to be called with specific arguments in most cases. When you call a function,
   you can choose to omit arguments for which there is a default, in which case, the default is
   used.

   To add a default argument, you add the assignment operator (``=``) after the data type for the
   parameter and set it equal to a value. Modify your code to use a default argument.

   1. In the ``birthdayGreeting()`` function, set the ``name`` parameter to the default value
      ``"Rover"``.

   .. code:: prettyprint

      fun birthdayGreeting(name: String = "Rover", age: Int): String {
          return "Happy Birthday, $name! You are now $age years old!"
      }

   2. In the first call to ``birthdayGreeting()`` for Rover in ``main()``, set the ``age`` named
      argument to ``5``. Because the ``age`` parameter is defined after the ``name``, you need to
      use the named argument ``age``. Without named arguments, Kotlin assumes the order of arguments
      is the same order in which parameters are defined. The named argument is used to ensure Kotlin
      is expecting an ``Int`` for the ``age`` parameter.

   .. code:: prettyprint

      println(birthdayGreeting(age = 5))
      println(birthdayGreeting("Rex", 2))

   3. Run your code. The first call to the ``birthdayGreeting()`` function prints "Rover" as the
      name because you never specified the name. The second call to ``birthdayGreeting()`` still
      uses the ``Rex`` value, which you passed in for the ``name``.

   ::

      Happy Birthday, Rover! You are now 5 years old!
      Happy Birthday, Rex! You are now 2 years old!

   4. Remove the name from the second call to the ``birthdayGreeting()`` function. Again, because
      ``name`` is omitted, you need to use a named argument for the age.

   .. code:: prettyprint

      println(birthdayGreeting(age = 5))
      println(birthdayGreeting(age = 2))

   5. Run your code and then observe that now both calls to ``birthdayGreeting()`` print "Rover" as
      the name because no name argument is passed in.

   ::

      Happy Birthday, Rover! You are now 5 years old!
      Happy Birthday, Rover! You are now 2 years old!


8. Conclusion
-------------

   Congratulations! You learned how to define and call functions in Kotlin.


Summary

   -  Functions are defined with the ``fun`` keyword and contain reusable pieces of code.
   -  Functions help make larger programs easier to maintain and prevent the unnecessary repetition
      of code.
   -  Functions can return a value that you can store in a variable for later use.
   -  Functions can take parameters, which are variables available inside a function body.
   -  Arguments are the values that you pass in when you call a function.
   -  You can name arguments when you call a function. When you use named arguments, you can reorder
      the arguments without affecting the output.
   -  You can specify a default argument that lets you omit the argument when you call a function.


â­ Practice Problems: Kotlin Basics
===================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-intro-kotlin-practice-problems


1. Before you begin
-------------------

   While you've put in the hard work to gain knowledge of the basics of Kotlin programming, now it's
   time to put what you learned into practice.

   These exercises test your understanding of the concepts that you studied. They're themed around
   real-world use cases, some of which you probably encountered before.

   Follow the instructions to find a solution for each problem. If you get stuck, some of the
   exercises have hints that can help you. The solution code is available at the end, but it's
   strongly recommended that you solve the exercises before you check your answers.

   Consider the solutions as one way to solve the problems and feel free to experiment however you
   feel comfortable. You can solve some of the exercises in multiple ways, and use different names
   for the functions and variables.

   Work through the problems at a pace that's comfortable to you. There is a duration listed, but it
   is not necessary to adhere to those timings, as they are only estimates. You are encouraged to
   take as much time as you need to solve each problem thoughtfully.

   It's recommended that you use `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__ 
   to solve these exercises.


Prerequisites

   -  Familiarity with `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__
   -  Ability to define and call functions
   -  Knowledge of basic Kotlin data types
   -  Knowledge of immutable and mutable variables
   -  Knowledge of the ``println()`` function
   -  Completion of the `Your first program in Kotlin <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-first-program>`__,
      `Create and use variables in Kotlin <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-variables>`__,
      and `Create and use functions in Kotlin <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-functions>`__
      codelabs


What you'll need

   -  A computer with internet access and a web browser


2. Print messages
-----------------

   Tell your friends what you learned in this pathway.

   -  Can you write a ``main()`` function that prints these messages on four separate lines?

   ::

      Use the val keyword when the value doesn't change. 
      Use the var keyword when the value can change.
      When you define a function, you define the parameters that can be passed to it. 
      When you call a function, you pass arguments for the parameters.


3. Fix compile error
--------------------

   This program prints a message that notifies the user that they received a chat message from a
   friend.

   .. code:: prettyprint

      fun main() { 
          println("New chat message from a friend'}
      }

   1. Can you figure out the root cause of the compile errors in this program and fix them?
   2. Does the code use appropriate symbols to indicate the open and close of the string and
      function argument?

   **Hint:** You can use Kotlin Playground to run the code and view the compilation errors.

   After you fix the errors, the program should compile without errors and print this output:

   ::

      New chat message from a friend


4. String templates
-------------------

   This program informs users about the upcoming promotional sale on a particular item. It has a
   string template, which relies on the ``discountPercentage`` variable for the percent discount and
   the ``item`` variable for the item on sale. However, there are compilation errors in the code.

   .. code:: prettyprint

      fun main() {
          val discountPercentage: Int = 0
          val offer: String = ""
          val item = "Google Chromecast"
          discountPercentage = 20
          offer = "Sale - Up to $discountPercentage% discount on $item! Hurry up!"
          
          println(offer)
      }

   1. Can you figure out the root cause of the errors and fix them?
   2. Can you determine the output of this program before you run the code in Kotlin Playground?

   **Hint:** Can you re-assign a value to a read-only variable?

   After you fix the errors, the program should compile without errors and print this output:

   ::

      Sale - Up to 20% discount on Google Chromecast! Hurry up!


5. String concatenation
-----------------------

   This program displays the total party size. There are adults and kids at the party. The
   ``numberOfAdults`` variable holds the number of adults at the party and the ``numberOfKids``
   variable holds the number of kids.

   .. code:: prettyprint

      fun main() {
          val numberOfAdults = "20"
          val numberOfKids = "30"
          val total = numberOfAdults + numberOfKids
          println("The total party size is: $total")
      }


Step 1

   -  Can you determine the output of this program before you run the code in Kotlin Playground?

   After you determine the output, run the code in Kotlin Playground and then check if your output
   matches the output displayed.

   **Hint:** What happens when you use the ``+`` operator on two strings?


Step 2

   The code works and prints some output, but the output doesn't show the total number of people
   attending the party.

   -  Can you find the issue in the code and fix it so that it prints this output?

   ::

      The total party size is: 50


6. Message formatting
---------------------

   This program displays the total salary that an employee receives this month. The total salary is
   divided in two parts: the ``baseSalary`` variable, which the employee receives every month, and
   the ``bonusAmount`` variable, which is an additional bonus awarded to the employee.

   .. code:: prettyprint

      fun main() {
          val baseSalary = 5000
          val bonusAmount = 1000
          val totalSalary = "$baseSalary + $bonusAmount"
          println("Congratulations for your bonus! You will receive a total of $totalSalary (additional bonus).")
      }

   1. Can you figure out the output of this code before you run it in Kotlin Playground?
   2. When you run the code in Kotlin Playground, does it print the output that you expected?


7. Implement basic math operations
----------------------------------

   In this exercise, you write a program that performs basic math operations and prints the output.


Step 1

   This ``main()`` function contains one compile error:

   .. code:: prettyprint

      fun main() {
          val firstNumber = 10
          val secondNumber = 5
          
          println("$firstNumber + $secondNumber = $result")
      }

   -  Can you fix the error so that the program prints this output?

   ::

      10 + 5 = 15


Step 2

   The code works, but the logic for adding two numbers is located within the result variable,
   making your code less flexible to reuse. Instead, you can extract the addition operation into an
   ``add()`` function so that the code is reusable. To do this, update your code with the code
   listed below. Notice that the code now introduces a new ``val`` called ``thirdNumber`` and prints
   the result of this new variable with ``firstNumber``.

   .. code:: prettyprint

      fun main() {
          val firstNumber = 10
          val secondNumber = 5
          val thirdNumber = 8
          
          val result = add(firstNumber, secondNumber)
          val anotherResult = add(firstNumber, thirdNumber)

          println("$firstNumber + $secondNumber = $result")
          println("$firstNumber + $thirdNumber = $anotherResult")
      }

      // Define add() function below this line

   -  Can you define the ``add()`` function so that the program prints this output?

   ::

      10 + 5 = 15
      10 + 8 = 18


Step 3

   Now you have a reusable function to add two numbers.

   -  Can you implement the ``subtract()`` function the same way you implemented the ``add()``
      function? Modify the ``main()`` function as well to use the ``subtract()`` function so you can
      verify that it works as expected.

   **Hint:** Think about the difference between addition, subtraction and other math operations.
   Start work on the solution code from there.


8. Default parameters
---------------------

   Gmail has a feature that sends a notification to the user whenever a login attempt is made on a
   new device.

   In this exercise, you write a program that displays a message to users with this message
   template:

   ::

      There's a new sign-in request on operatingSystem for your Google Account emailId.

   You need to implement a function that accepts an ``operatingSystem`` parameter and an ``emailId``
   parameter, constructs a message in the given format, and returns the message.

   For example, if the function was called with "``Chrome OS``" for the ``operatingSystem`` and
   "``sample@gmail.com``" for the ``emailId``, it should return this string:

   ::

      There's a new sign-in request on Chrome OS for your Google Account sample@gmail.com.


Step 1

   1. Can you implement the ``displayAlertMessage()`` function in this program so that it prints the
      output displayed?

   .. code:: prettyprint

      fun main() {
          val operatingSystem = "Chrome OS"
          val emailId = "sample@gmail.com"

          println(displayAlertMessage(operatingSystem, emailId))
      }

      // Define your displayAlertMessage() below this line.

   2. Does your program print this output?

   ::

      There's a new sign-in request on Chrome OS for your Google Account sample@gmail.com.


Step 2

   Great job! You displayed the message. However, in some cases, you discover that you can't
   determine the user's operating system. In such cases, you need to specify the operating system
   name as ``Unknown OS``. You can further optimize the code so that you don't need to pass the
   ``Unknown OS`` argument each time that the function is called.

   1. Can you find a way to optimize the code with this information so that it prints this output?

   ::

      There's a new sign-in request on Unknown OS for your Google Account user_one@gmail.com.

      There's a new sign-in request on Windows for your Google Account user_two@gmail.com. 

      There's a new sign-in request on Mac OS for your Google Account user_three@gmail.com. 

   2. To print the above message, replace the ``main()`` function implementation with this one:

   .. code:: prettyprint

      fun main() {
          val firstUserEmailId = "user_one@gmail.com"

          // The following line of code assumes that you named your parameter as emailId. 
          // If you named it differently, feel free to update the name.
          println(displayAlertMessage(emailId = firstUserEmailId))
          println()

          val secondUserOperatingSystem = "Windows"
          val secondUserEmailId = "user_two@gmail.com"

          println(displayAlertMessage(secondUserOperatingSystem, secondUserEmailId))
          println()

          val thirdUserOperatingSystem = "Mac OS"
          val thirdUserEmailId = "user_three@gmail.com"

          println(displayAlertMessage(thirdUserOperatingSystem, thirdUserEmailId))
          println()
      }


9. Pedometer
------------

   The pedometer is an electronic device that counts the number of steps taken. Nowadays, almost all
   mobile phones, smart watches, and fitness gear come with pedometers built into them. The health
   and fitness app uses built-in pedometers to calculate the number of steps taken. This function
   calculates the number of calories that the user burns based on the user's number of steps.

   -  Can you rename the functions, function parameters, and variables in this program based on best
      practices?

   .. code:: prettyprint

      fun main() {
          val Steps = 4000
          val caloriesBurned = PEDOMETERstepsTOcalories(Steps);
          println("Walking $Steps steps burns $caloriesBurned calories") 
      }

      fun PEDOMETERstepsTOcalories(NumberOFStepS: Int): Double {
          val CaloriesBURNEDforEachStep = 0.04
          val TotalCALORIESburned = NumberOFStepS * CaloriesBURNEDforEachStep
          return TotalCALORIESburned
      }


10. Compare two numbers
-----------------------

   Modern mobile phones have a built-in feature that tracks screen time, or the time you spend on
   your phone each day.

   In this exercise, you implement a function that compares the time in minutes that you spent on
   your phone today versus the time spent yesterday. The function accepts two integer parameters and
   returns a boolean value.

   The first parameter holds the number of minutes that you spent today and the second parameter
   holds the number of minutes that you spent yesterday. The function returns a ``true`` value if
   you spent more time on the phone today compared to yesterday. Otherwise, it returns a ``false``
   value.

   For example, if you called the function with these named arguments:

   -  ``timeSpentToday = 300`` and ``timeSpentYesterday = 250``, the function returns a ``true``
      value.
   -  ``timeSpentToday = 300`` and ``timeSpentYesterday = 300``, the function returns a ``false``
      value.
   -  ``timeSpentToday = 200`` and ``timeSpentYesterday = 220``, the function returns a ``false``
      value.

   **Hint:** The ``>`` comparison operator returns a ``true`` value if the value before the operator
   is greater than the value after it. Otherwise, it returns a ``false`` value.


11. Move duplicate code into a function
---------------------------------------

   This program displays the weather for different cities. It includes the city name, the high and
   low temperature for the day, and the chance of rain.

   .. code:: prettyprint

      fun main() {
          println("City: Ankara")
          println("Low temperature: 27, High temperature: 31")
          println("Chance of rain: 82%")
          println()

          println("City: Tokyo")
          println("Low temperature: 32, High temperature: 36")
          println("Chance of rain: 10%")
          println()
          
          println("City: Cape Town")
          println("Low temperature: 59, High temperature: 64")
          println("Chance of rain: 2%")
          println()
          
          println("City: Guatemala City")
          println("Low temperature: 50, High temperature: 55")
          println("Chance of rain: 7%")
          println()
      }

   There are many similarities in the code that prints the weather for each city. For example, there
   are phrases that are repeated multiple times, such as ``"City:"`` and ``"Low temperature:"``.
   Similar, repeated code creates the risk of errors in your program. For one of the cities, you may
   have a typo or you may forget one of the weather details.

   1. Can you create a function that prints the weather details for a single city to reduce the
      repetition in the ``main()`` function and then do the same for the remaining cities?
   2. Can you update the ``main()`` function to call the function that you created for each city and
      pass in the appropriate weather details as arguments?


12. Solution code
-----------------


Print messages

   The solution uses the ``println()`` function to print the messages on each line.

   .. code:: prettyprint

      fun main() {
          println("Use the val keyword when the value doesn't change.")
          println("Use the var keyword when the value can change.")
          println("When you define a function, you define the parameters that can be passed to it.")
          println("When you call a function, you pass arguments for the parameters.")
      }


Fix compile error

   The code contained two compilation errors:

   1. The string should end with a double quotation mark rather than a single quotation mark.
   2. The function argument should end with a parenthesis rather than a curly bracket.

   .. code:: prettyprint

      fun main() { 
          println("New chat message from a friend")
      }


String templates

   The compilation errors are the result from the assignment of the ``discountPercentage`` and
   ``offer`` read-only variables to new values; this assignment isn't allowed.

   .. code:: prettyprint

      fun main() {
          val discountPercentage = 20
          val item = "Google Chromecast"
          val offer = "Sale  - Up to $discountPercentage% discount off $item! Hurry Up!"

          println(offer)
      }

   As an alternative solution, you could declare the ``discountPercentage`` integer and ``offer``
   string with the ``var`` keyword. However, their values are immutable in the context of the
   program, so you can stick with the ``val`` keyword.


String concatenation


Step 1

   The program prints this output:

   ::

      The total party size is: 2030 

   This was a trick question. When the ``+`` operator is used on ``String`` values, it produces a
   concatenated string. The integers are wrapped in double quotation marks, so they're treated as
   strings instead of integers, hence the output of ``2030``.


Step 2

   You could remove the double quotation marks around the ``numberOfAdults`` and ``numberOfKids``
   variables to convert them to ``Int`` variables.

   .. code:: prettyprint

      fun main() {
          val numberOfAdults = 20
          val numberOfKids = 30
          val total = numberOfAdults + numberOfKids
          println("The total party size is: $total")
      }

   If you remember, the Kotlin compiler can infer the type of variables based on the values assigned
   to them. In this case, the compiler infers that the ``numberOfAdults`` and ``numberOfKids``
   variables are ``Int`` types.


Message formatting

   The program prints this output:

   ::

      Congratulations for your bonus! You will receive a total of 5000 + 1000 (additional bonus).

   ``"$baseSalary + $bonusAmount"`` uses the template expressions syntax. In template expressions,
   the code is evaluated first and then the result is concatenated in a string.

   In the question, the ``$baseSalary`` variable is evaluated to a ``5000`` value and the
   ``$bonusAmount`` variable is evaluated to a ``1000`` value. Then, the result is concatenated to
   produce ``"5000 + 1000"`` and assigned to the ``result`` variable.


Implement basic math operations


Step 1

   Define an immutable ``result`` variable with the ``val`` keyword and then assign the result of
   the addition operation to it:

   .. code:: prettyprint

      fun main() {
          val firstNumber = 10
          val secondNumber = 5
          
          val result = firstNumber + secondNumber
          println("$firstNumber + $secondNumber = $result")
      }


Step 2

   1. Create an ``add()`` function that accepts a ``firstNumber`` parameter and ``secondNumber``
      parameter, both of ``Int`` type, and returns an ``Int`` value.
   2. Enter the code for the addition operation inside the ``add()`` function body and then use the
      ``return`` keyword to return the result of the operation.

   .. code:: prettyprint

      fun add(firstNumber: Int, secondNumber: Int): Int {
          return firstNumber + secondNumber
      }


Step 3

   1. Define a ``subtract()`` function that accepts a ``firstNumber`` parameter and ``secondNumber``
      parameter, both of ``Int`` type, and returns an ``Int`` value.
   2. Enter the code for the subtraction operation inside the ``subtract()`` function body and then
      use the ``return`` keyword to return the result of the operation.

   .. code:: prettyprint

      fun subtract(firstNumber: Int, secondNumber: Int): Int {
          return firstNumber - secondNumber
      }

   3. Modify the ``main()`` function to use the new ``subtract()`` function. An example solution
      could look like this:

   .. code:: prettyprint

      fun main() {
          val firstNumber = 10
          val secondNumber = 5
          val thirdNumber = 8
          
          val result = add(firstNumber, secondNumber)
          val anotherResult = subtract(firstNumber, thirdNumber)

          println("$firstNumber + $secondNumber = $result")
          println("$firstNumber - $thirdNumber = $anotherResult")
      }

      fun add(firstNumber: Int, secondNumber: Int): Int {
          return firstNumber + secondNumber
      }

      fun subtract(firstNumber: Int, secondNumber: Int): Int {
          return firstNumber - secondNumber
      }


Default parameters


Step 1

   1. Create a ``displayAlertMessage()`` function that accepts an ``operatingSystem`` parameter and
      ``emailId`` parameter, both of ``String`` type, and returns a ``String`` value.
   2. In the function body, use a template expression to update the message and return it.

   .. code:: prettyprint

      fun displayAlertMessage(operatingSystem: String, emailId: String): String {
          return "There is a new sign-in request on $operatingSystem for your Google Account $emailId."
      }


Step 2

   -  Assign an ``"Unknown OS"`` value to the ``operatingSystem`` parameter.

   .. code:: prettyprint

      fun displayAlertMessage(
          operatingSystem: String = "Unknown OS",
          emailId: String
      ): String {
          return "There is a new sign-in request on $operatingSystem for your Google Account $emailId."
      }


Pedometer

   Function names and variable names should follow the *camel case* convention.

   If the names contain multiple words, lowercase the first letter of the first word, capitalize the
   first letter of subsequent words, and remove any spaces between the words.

   Example function names include:

   -  ``calculateTip``
   -  ``displayMessage``
   -  ``takePhoto``

   Example variable names include:

   -  ``numberOfEmails``
   -  ``cityName``
   -  ``bookPublicationDate``

   To learn more about names, see `Naming rules <https://kotlinlang.org/docs/coding-conventions.html#naming-rules>`__.

   Avoid using a `Kotlin keyword <https://kotlinlang.org/docs/keyword-reference.html>`__ as a
   function name because those words are already assigned specific meanings in the Kotlin language.

   Your solution code should look something like this code snippet:

   .. code:: prettyprint

      fun main() {
          val steps = 4000
          val caloriesBurned = pedometerStepsToCalories(steps)
          println("Walking $steps steps burns $caloriesBurned calories") 
      }

      fun pedometerStepsToCalories(numberOfSteps: Int): Double {
          val caloriesBurnedForEachStep = 0.04
          val totalCaloriesBurned = numberOfSteps * caloriesBurnedForEachStep
          return totalCaloriesBurned
      }


Compare two numbers

   -  Create a ``compareTime()`` function that accepts a ``timeSpentToday`` parameter and a
      ``timeSpentYesterday`` parameter, both of ``Int`` type, and returns a ``Boolean`` value.

   The solution relies on the ``>`` comparison operator. The operator evaluates to a ``Boolean``
   value, so the ``compareTime()`` function simply returns the result of
   ``timeSpentToday > timeSpentYesterday``.

   For example, if you pass a ``300`` argument to the ``timeSpentToday`` parameter and a ``250``
   argument to the ``timeSpentYesterday`` parameter, the function body evaluates to ``300 > 250``,
   which returns a ``true`` value because 300 is greater than 250.

   .. code:: prettyprint

      fun main() {
          println("Have I spent more time using my phone today: ${compareTime(300, 250)}")
          println("Have I spent more time using my phone today: ${compareTime(300, 300)}")
          println("Have I spent more time using my phone today: ${compareTime(200, 220)}")
      }

      fun compareTime(timeSpentToday: Int, timeSpentYesterday: Int): Boolean {
          return timeSpentToday > timeSpentYesterday
      }

   ::

      Have I spent more time using my phone today: true
      Have I spent more time using my phone today: false
      Have I spent more time using my phone today: false


Move duplicate code into a function

   1. Create a function that prints out the weather details for the city of Ankara after the
      ``main()`` function.

   For the function name, you can use ``printWeatherForCity()`` or something similar.

   2. Call the function from the ``main()`` function.

   The program should print the weather details for Ankara.

   .. code:: prettyprint

      fun main() {
          printWeatherForCity()
      }

      fun printWeatherForCity() {
          println("City: Ankara")
          println("Low temperature: 27, High temperature: 31")
          println("Chance of rain: 82%")
          println()
      }

   Now you can create another function that's more flexible so that it can print weather details for
   other cities.

   3. Replace the Ankara-specific parts of the ``println()`` statements with variables.

   Remember to use camel case convention for the variable names and the ``$`` symbol before the
   variable so that the value of the variable gets used instead of the variable name. These are
   string templates which you learned about in an earlier codelab.

   .. code:: prettyprint

      fun printWeatherForCity() {
          println("City: $cityName")
          println("Low temperature: $lowTemp, High temperature: $highTemp")
          println("Chance of rain: $chanceOfRain%")
          println()
      }

   4. Change the function definition so that those variables are parameters that must be passed into
      the function when it's called and specify the data type for each parameter.

   The ``cityName`` parameter is of ``String`` type, while the ``lowTemp``, ``highTemp``, and
   ``chanceOfRain`` parameters are of ``Int`` type.

   There's no ``return`` value needed in the function definition because the messages are printed to
   the output.

   .. code:: prettyprint

      fun printWeatherForCity(cityName: String, lowTemp: Int, highTemp: Int, chanceOfRain: Int) {
          println("City: $cityName")
          println("Low temperature: $lowTemp, High temperature: $highTemp")
          println("Chance of rain: $chanceOfRain%")
          println()
      }

   5. Update the ``main()`` function to call the ``printWeatherForCity()`` function and pass in the
      weather details for Ankara.

   The city name is ``"Ankara"``, the low temperature is ``27``, the high temperature is ``31``, and
   the chance of rain is ``82``.

   .. code:: prettyprint

      fun main() {
          printWeatherForCity("Ankara", 27, 31, 82)
      }

      fun printWeatherForCity(cityName: String, lowTemp: Int, highTemp: Int, chanceOfRain: Int) {
          println("City: $cityName")
          println("Low temperature: $lowTemp, High temperature: $highTemp")
          println("Chance of rain: $chanceOfRain%")
          println()
      }

   6. Run the program to verify that the output shows the weather details for Ankara.
   7. Call the ``printWeatherForCity()`` function with the weather details for the other cities.

   .. code:: prettyprint

      fun main() {
          printWeatherForCity("Ankara", 27, 31, 82)
          printWeatherForCity("Tokyo", 32, 36, 10)
          printWeatherForCity("Cape Town", 59, 64, 2)
          printWeatherForCity("Guatemala City", 50, 55, 7)
      }

      fun printWeatherForCity(cityName: String, lowTemp: Int, highTemp: Int, chanceOfRain: Int) {
          println("City: $cityName")
          println("Low temperature: $lowTemp, High temperature: $highTemp")
          println("Chance of rain: $chanceOfRain%")
          println()
      }

   8. Run the program.

   It should print the same output as the original program, but now your code is more concise and
   doesn't contain unnecessary repetition! All the code for printing weather details of a city is
   centralized in a single place: the ``printWeatherForCity()`` function. If you ever want to change
   how weather details are displayed, you can change them in a single place that applies to all the
   cities.


13. Additional Practice
-----------------------

   For more practice on the Kotlin language, check out the `Kotlin Core track by JetBrains Academy <https://hyperskill.org/tracks/18>`__. 
   To jump to a specific topic, go to the `knowledge map <https://hyperskill.org/knowledge-map>`__ 
   to view the list of topics covered in the track.


â­ Write conditionals in Kotlin
================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-conditionals


1. Before you begin

   Conditionals are one of the most important foundations of programming. Conditionals are commands
   in programming languages that handle decisions. With conditionals, code is dynamic, which means
   that it can behave differently given a different condition.

   This codelab teaches you how to use the ``if/else`` and ``when`` statements and expressions to
   write conditionals in Kotlin.


**Prerequisites**


   -  Knowledge of Kotlin programming basics, including variables, and the ``println()`` and
      ``main()`` functions


**What** **you'll** **learn**


   -  How to write boolean expressions.
   -  How to write ``if/else`` statements.
   -  How to write ``when`` statements.
   -  How to write ``if/else`` expressions.
   -  How to write ``when`` expressions.
   -  How to use commas to define common behavior for multiple branches in ``when`` conditionals.
   -  How to use the ``in`` range to define common behavior for a range of branches in ``when``
      conditionals.
   -  How to use the ``is`` keyword to write ``when`` conditional statements.


**What** **you'll** **need**


   -  A web browser with access to Kotlin Playground


2. Use if/else statements to express conditions

   In life, it's common to do things differently based on the situation that you face. For example,
   if the weather is cold, you wear a jacket, whereas if the weather is warm, you don't wear a
   jacket.

   ::

                                 â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                                 â”‚   start   â”‚
                        YES      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     NO
                     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                     â”‚                                   â”‚
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚      Wear a jacket     â”‚         â”‚  Dont't wear a jacket  â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   Decision-making is also a fundamental concept in programming. You write instructions about how a
   program should behave in a given situation so that it can act or react accordingly when the
   situation occurs. In Kotlin, when you want your program to perform different actions based on a
   condition, you can use an ``if/else`` statement. In the next section, you write an ``if``
   statement.


Write ``if`` conditions with boolean expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   Imagine that you build a program that tells drivers what they should do when they're at a traffic
   light. Focus on the first condition: a red traffic light. What do you do at a red traffic light?
   Stop!

   ::

                                 â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                                 â”‚   start   â”‚
                                 â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     
                                       â”‚           
                     YES   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                     â•­â”€â”€â”€â”€â”€â”‚  Is traffic light red  â”‚
                     â”‚     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚         Stop!          â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯



   In Kotlin, you can express this condition with an ``if`` statement. Take a look at the anatomy of
   an ``if`` statement:

   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      if ( â”‚ condition â”‚ ) {
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body             â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   To use ``if`` statements, you need to use the ``if`` keyword followed by the condition that you
   want to evaluate. You need to express the condition with a boolean expression. *Expressions*
   combine values, variables, and operators that return a value. Boolean expressions return a
   boolean value.

   Previously, you learned about *assignment operators*, such as:

   .. code:: prettyprint

      val number = 1

   The ``=`` assignment operator assigns the ``number`` variable a ``1`` value.

   In contrast, boolean expressions are constructed with *comparison operators*, which compare
   values or variables on both sides of the equation. Take a look at a comparison operator.

   .. code:: prettyprint

      1 == 1

   The ``==`` comparison operator compares the values to each other. Which boolean value do you
   think this expression returns?

   Find the boolean value of this expression:

   1. Use `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__ to
      run your code.
   2. In the function body, add a ``println()`` function and then pass it the ``1 == 1`` expression
      as an argument:

   .. code:: prettyprint

      fun main() {
          println(1 == 1)
      }

   3. Run the program and then view the output:

   ::

      true

   The first ``1`` value is equal to the second ``1`` value, so the boolean expression returns a
   ``true`` value, which is a boolean value.


Try it


   Besides the ``==`` comparison operator, there are additional *comparison operators* that you can
   use to create boolean expressions:

   -  Less than: ``<``
   -  Greater than: ``>``
   -  Less than or equal to: ``<=``
   -  Greater than or equal to: ``>=``
   -  Not equal to: ``!=``

   Practice the use of comparison operators with simple expressions:

   1. In the argument, replace the ``==`` comparison operator with the ``<`` comparison operator:

   .. code:: prettyprint

      fun main() {
          println(1 < 1)
      }

   2. Run the program and then view the output:

   The output returns a ``false`` value because the first ``1`` value *isn't* less than the second
   ``1`` value.

   ::

      false

   3. Repeat the first two steps with the other comparison operators and numbers.


Write a simple ``if`` statement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   Now that you saw a few examples of how to write boolean expressions, you can write your first
   ``if`` statement. The syntax for an ``if`` statement is as follows:

   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      if ( â”‚ condition â”‚ ) {
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body             â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   |A diagram that describes an if statement with the if keyword followed by a pair of parentheses
   with a condition inside them. After that, there's a pair of curly braces with a body inside them.
   The body block is highlighted.|

   An ``if`` statement starts with the ``if`` keyword followed by a condition, which is a boolean
   expression inside parentheses and a set of curly braces. The body is a series of statements or
   expressions that you put inside a pair of curly braces after the condition. These statements or
   expressions only execute when the condition is met. In other words, the statements within the
   curly braces only execute when a boolean expression in the ``if`` branch returns a ``true``
   value.

   Write an ``if`` statement for the red traffic-light condition:

   1. Inside the ``main()`` function, create a ``trafficLightColor`` variable and assign it a
      ``"Red"`` value:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Red"
      }

   2. Add an ``if`` statement for the red traffic-light condition and then pass it a
      ``trafficLightColor == "Red"`` expression:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Red"

          if (trafficLightColor == "Red") {
              
          } 
      }

   3. In the body of the ``if`` statement, add a ``println()`` function and then pass it a
      ``"Stop"`` argument:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Red"

          if (trafficLightColor == "Red") {
              println("Stop")
          } 
      }

   4. Run the program and then view the output:

   ::

      Stop

   The ``trafficLightColor == "Red"`` expression returns a ``true`` value, so the
   ``println("Stop")`` statement is executed, which prints the ``Stop`` message.

   ::

               boolean expression
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚                          â”‚
      if (trafficLightColor == "Red") {

         println("Stop")               <---- execute if ture

      }



Add an ``else`` branch
~~~~~~~~~~~~~~~~~~~~~~


   Now you can extend the program so that it tells drivers to *go* when the traffic light isn't red.


   ::

                                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                                  â”‚  Start  â”‚
                                  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                       â”‚
                            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                            â”‚ Is traffic light red? â”‚
                   YES      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     NO
                     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                     â”‚                                   â”‚
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚         Stop!          â”‚         â”‚           Go           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   You need to add an ``else`` branch to create an ``if/else`` statement. A *branch* is an
   incomplete part of code that you can join to form statements or expressions. An ``else`` branch
   needs to follow an ``if`` branch.


   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      if ( â”‚ condition â”‚ ) {
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body 1           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      } else {
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body 2           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   After the closing curly brace of the ``if`` statement, you add the ``else`` keyword followed by a
   pair of curly braces. Inside the curly braces of the ``else`` statement, you can add a second
   body that only executes when the condition in the ``if`` branch is false.

   Add an ``else`` branch to your program:

   1. After the closing curly brace of the ``if`` statement, add the ``else`` keyword followed by
      another pair of curly braces:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Red"

          if (trafficLightColor == "Red") {
              println("Stop")
          } else {

          }
      }

   2. Inside the ``else`` keyword's curly braces, add a ``println()`` function and then pass it a
      ``"Go"`` argument:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Red"

          if (trafficLightColor == "Red") {
              println("Stop")
          } else {
              println("Go")
          }
      }

   3. Run this program and then view the output:

   ::

      Stop

   The program still behaves the same way as it did before you added the ``else`` branch, but it
   doesn't print a ``Go`` message.

   4. Reassign the ``trafficLightColor`` variable to a ``"Green"`` value because you want drivers to
      *go* on green:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Green"

          if (trafficLightColor == "Red") {
              println("Stop")
          } else {
              println("Go")
          }
      }

   5. Run this program and then view the output:

   ::

      Go

   As you can see, now the program prints a ``Go`` message instead of a ``Stop`` message.

   ::

                  boolean expression
             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
             â”‚                          â”‚
          if (trafficLightColor == "Red") {
              println("Stop")       <â”€â”€â”€â”€â”€â”€â”€â”€â”€ execute if true
          } else {
              println("Go")         <â”€â”€â”€â”€â”€â”€â”€â”€â”€ execute if false
          }


   You reassigned the ``trafficLightColor`` variable to a ``"Green"`` value, so the
   ``trafficLightColor == "Red"`` expression evaluated in the ``if`` branch returns a ``false``
   value because the ``"Green"`` value isn't equal to the ``"Red"`` value.

   As a result, the program skips all statements in the ``if`` branch and instead executes all
   statements inside the ``else`` branch. This means that the ``println("Go")`` function is
   executed, but the ``println("Stop")`` function isn't executed.


Add an ``else if`` branch
~~~~~~~~~~~~~~~~~~~~~~~~~


   Typically, a traffic light also has a yellow color that tells drivers to proceed slowly. You can
   expand the program's decision-making process to reflect this.


   ::

                                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                                  â”‚  Start  â”‚
                                  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                       â”‚
                            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                            â”‚ Is traffic light red? â”‚
                     YES    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   NO
                     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                     â”‚                                   â”‚
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚         Stop!          â”‚          â”‚ Is traffic light red? â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    YES   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    NO
                                       â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                                       â”‚                                   â”‚
                           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                           â”‚         Slow           â”‚         â”‚           Go           â”‚
                           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   You learned to write conditionals that cater to a single decision point with ``if/else``
   statements that contain a single ``if`` and a single ``else`` branch. How can you handle more
   complex branching with multiple decision points? When you face multiple decision points, you need
   to create conditionals with multiple layers of conditions, which you can do when you add
   ``else if`` branches to ``if/else`` statements.

   After the closing curly brace of the ``if`` branch, you need to add the ``else if`` keyword.
   Inside the parentheses of the ``else if`` keyword, you need to add a boolean expression as the
   condition for the ``else if`` branch followed by a body inside a pair of curly braces. The body
   is only executed if condition 1 fails, but condition 2 is satisfied.


   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      if ( â”‚ condition 1 â”‚ ) {
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body 1           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      } else if ( â”‚ condition 2 â”‚ ) {
                  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body 2           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      } else {
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body 3           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   The ``else if`` branch is always located after the ``if`` branch, but before the ``else`` branch.
   You can use multiple ``else if`` branches in a statement:

   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      if ( â”‚ condition 1 â”‚ ) {
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body 1           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®      â”€â”€â”€â”€â•®
      } else if ( â”‚ condition 2 â”‚ ) {      â”‚
                  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯          â”‚
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®        â”‚
         â”‚ block body 2           â”‚        â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯        â”œ multiple else if branchs
                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®          â”‚
      } else if ( â”‚ condition 3 â”‚ ) {      â”‚
                  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯          â”‚
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®        â”‚
         â”‚ block body 3           â”‚        â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â”€â”€â”€â”€â•¯
      } else {
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body 4           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   The ``if`` statement can also contain the ``if`` branch and ``else if`` branches without any
   ``else`` branch:


   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      if ( â”‚ condition 1 â”‚ ) {
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body 1           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     
      } else if ( â”‚ condition 2 â”‚ ) { 
                  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   
         â”‚ block body 2           â”‚   
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   
      }


   Add an ``else if`` branch to your program:

   1. After the closing curly brace of the ``if`` statement, add an
      ``else if (trafficLightColor == "Yellow")`` expression followed by curly braces:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Green"

          if (trafficLightColor == "Red") {
              println("Stop")
          } else if (trafficLightColor == "Yellow") {

          } else {
              println("Go")
          }
      }

   2. Inside the curly braces of the ``else if`` branch, add a ``println()`` statement and then pass
      it a ``"Slow"`` string argument:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Green"

          if (trafficLightColor == "Red") {
              println("Stop")
          } else if (trafficLightColor == "Yellow") {
              println("Slow")
          } else {
              println("Go")
          }
      }

   3. Reassign the ``trafficLightColor`` variable to a ``"Yellow"`` string value:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Yellow"

          if (trafficLightColor == "Red") {
              println("Stop")
          } else if (trafficLightColor == "Yellow") {
              println("Slow")
          } else {
              println("Go")
          }
      }

   4. Run this program and then view the output:

   ::

      Slow

   Now the program prints a ``Slow`` message, instead of a ``Stop`` or ``Go`` message.

   ::

              â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
          if  â”‚ (trafficLightColor == "Red") â”‚ { â‘ 
              â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
              println("Stop")        <â”€â”€â”€â”€â”€â”€â”€â”€ execute if â‘  true
                    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
          } else if â”‚ (trafficLightColor == "Yellow") â”‚ { â‘¡
                    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
              println("Slow")        <â”€â”€â”€â”€â”€â”€â”€â”€ execute if â‘  false and â‘¡ true

          } else {
              println("Go")          <â”€â”€â”€â”€â”€â”€â”€â”€ execute if â‘  and â‘¡ false
          }

   Here's why it only prints a ``Slow`` message and not the other lines:

   -  The ``trafficLightColor`` variable is assigned a ``"Yellow"`` value.
   -  The ``"Yellow"`` value isn't equal to the ``"Red"`` value, so the boolean expression of the
      ``if`` branch (denoted as 1 in the image) returns a ``false`` value. The program skips all
      statements inside the ``if`` branch and doesn't print a ``Stop`` message.
   -  Since the ``if`` branch yields a ``false`` value, the program proceeds to evaluate the boolean
      expression inside the ``else if`` branch.
   -  The ``"Yellow"`` value is equal to the ``"Yellow"`` value, so the boolean expression of the
      ``else if`` branch (denoted as 2 in the image) returns a ``true`` value. The program executes
      all statements inside the ``else if`` branch and prints a ``Slow`` message.
   -  Since the boolean expression of the ``else if`` branch returns a ``true`` value, the program
      skips the rest of the branches. Thus, all statements in the ``else`` branch aren't executed
      and the program doesn't print a ``Go`` message.


Try it


   Have you noticed that the current program contains a bug?

   In Unit 1, you learned about a type of bug called a *compile error* in which Kotlin can't compile
   the code due to a syntactical error in your code and the program can't run. Here, you face
   another type of bug called a *logic error* in which the program can run, but doesn't produce an
   output as intended.

   Supposedly, you only want drivers to drive only when the traffic-light color is green. What if
   the traffic light is broken and turned off? Would you want the driver to drive or receive a
   warning that something is wrong?

   Unfortunately, in the current program, if the traffic-light color is anything *else* other than
   red or yellow, the driver is still advised to *go*.

   Fix this problem:

   1. Reassign the ``trafficLightColor`` variable to a ``"Black"`` value to illustrate a traffic
      light that is turned off:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          if (trafficLightColor == "Red") {
              println("Stop")
          } else if (trafficLightColor == "Yellow") {
              println("Slow")
          } else {
              println("Go")
          }
      }

   2. Run this program and then view the output:

   ::

      Go

   Notice that the program prints a ``Go`` message even though the ``trafficLightColor`` variable
   isn't assigned a ``"Green"`` value. Can you fix this program so that it reflects the correct
   behavior?


   ::

                                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                                  â”‚  Start  â”‚
                                  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                       â”‚
                            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                            â”‚ Is traffic light red? â”‚
                     YES    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   NO
                     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                     â”‚                                   â”‚
               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                 â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
               â”‚   Stop!   â”‚                 â”‚ Is traffic light red? â”‚
               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯            YES  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                                  â”‚                      â”‚
                           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                           â”‚  Slow    â”‚      â”‚ Is traffic light red? â”‚
                           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ YES  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                                  â”‚                      â”‚
                           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®              â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®
                           â”‚  Slow    â”‚              â”‚   Go   â”‚
                           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯              â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   You need to modify the program so that it prints:

   -  A ``Go`` message only when the ``trafficLightColor`` variable is assigned a ``"Green"`` value.
   -  An ``Invalid traffic-light color`` message when the ``trafficLightColor`` variable isn't
      assigned a ``"Red"``, ``"Yellow"``, or ``"Green"`` value.


Fix the ``else`` branch
~~~~~~~~~~~~~~~~~~~~~~~


   The ``else`` branch is always located at the end of an ``if/else`` statement because it's a
   catchall branch. It automatically executes when all other conditions in the preceding branches
   aren't satisfied. As such, the ``else`` branch isn't suitable when you want an action to execute
   only when it satisfies a specific condition. In the case of the traffic light, you can use the
   ``else if`` branch to specify the condition for green lights.

   Use the ``else if`` branch to evaluate the green traffic-light condition:

   1. After the current ``else if`` branch, add another ``else if (trafficLightColor == "Green")``
      branch:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          if (trafficLightColor == "Red") {
              println("Stop")
          } else if (trafficLightColor == "Yellow") {
              println("Slow")
          } else if (trafficLightColor == "Green") {
              println("Go")
          }
      }

   2. Run this program and then view the output.

   The output is empty because you don't have an ``else`` branch that executes when the previous
   conditions aren't satisfied.

   3. After the last ``else if`` branch, add an ``else`` branch with a
      ``println("Invalid traffic-light color")`` statement inside:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          if (trafficLightColor == "Red") {
              println("Stop")
          } else if (trafficLightColor == "Yellow") {
              println("Slow")
          } else if (trafficLightColor == "Green") {
              println("Go")
          } else {
              println("Invalid traffic-light color")
          }

      }

   4. Run this program and then view the output:

   ::

      Invalid traffic-light color

   5. Assign the ``trafficLightColor`` variable another value besides ``"Red"``, ``"Yellow"``, or
      ``"Green"`` and then rerun the program.

   What's the output of the program?

   It's good programming practice to have an explicit ``else if`` branch as input validation for the
   green color and an ``else`` branch to catch other invalid inputs. This ensures that drivers are
   directed to *go*, only when the traffic light is green. For other cases, there's an explicit
   message relayed that the traffic light isn't behaving as expected.


3. Use a when statement for multiple branches

   Your ``trafficLightColor`` program looks more complex with multiple conditions, also known as
   branching. You may wonder whether you can simplify a program with an even larger number of
   branches.

   In Kotlin, when you deal with multiple branches, you can use the ``when`` statement instead of
   the ``if/else`` statement because it improves readability, which refers to how easy it is for
   human readers, typically developers, to read the code. It's very important to consider
   readability when you write your code because it's likely that other developers need to review and
   modify your code throughout its lifetime. Good readability ensures that developers can correctly
   understand your code and don't inadvertently introduce bugs into it.

   ``when`` statements are preferred when there are more than two branches to consider.

   ::

             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      when ( â”‚  parameter  â”‚ ) {
             â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ condition 1 â”‚ -> â”‚ block body 1           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ condition 2 â”‚ -> â”‚ block body 2           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                         .
                         .
                         .
      }


   |A diagram that shows the anatomy of a when statement. It starts with a when keyword followed by
   a pair of curly braces with a parameter block inside them. Next, inside a pair curly braces,
   there are three lines of cases. Inside each line, there's a condition block followed by an arrow
   symbol and a body block. It's noted that each of the lines of cases are evaluated sequentially.|

   A ``when`` statement accepts a single value through the parameter. The value is then evaluated
   against each of the conditions sequentially. The corresponding body of the first condition that's
   met is then executed. Each condition and body are separated by an arrow (``->``). Similar to
   ``if/else`` statements, each pair of condition and body is called a branch in ``when``
   statements. Also similar to the ``if/else`` statement, you can add an ``else`` branch as your
   final condition in a ``when`` statement that works as a catchall branch.


Rewrite an ``if/else`` statement with a ``when`` statement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   In the traffic-light program, there are already multiple branches:

   -  Red traffic-light color
   -  Yellow traffic-light color
   -  Green traffic-light color
   -  Other traffic-light color

   Convert the program to use a ``when`` statement:

   1. In the ``main()`` function, remove the ``if/else`` statement:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

      }

   2. Add a ``when`` statement and then pass it the ``trafficLightColor`` variable as an argument:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          when (trafficLightColor) {
          }
      }

   3. In the body of the ``when`` statement, add the ``"Red"`` condition followed by an arrow and a
      ``println("Stop")`` body:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          when (trafficLightColor) {
              "Red" -> println("Stop")
          }
      }

   4. On the next line, add the ``"Yellow"`` condition followed by an arrow and a
      ``println("Slow")`` body:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          when (trafficLightColor) {
              "Red" -> println("Stop")
              "Yellow" -> println("Slow")
          }
      }

   5. On the next line, add the ``"Green"`` condition followed by an arrow and then a
      ``println("Go")`` body:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          when (trafficLightColor) {
              "Red" -> println("Stop")
              "Yellow" -> println("Slow")
              "Green" -> println("Go")
          }
      }

   6. On the next line, add the ``else`` keyword followed by an arrow and then a
      ``println("Invalid traffic-light color")`` body:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          when (trafficLightColor) {
              "Red" -> println("Stop")
              "Yellow" -> println("Slow")
              "Green" -> println("Go")
              else -> println("Invalid traffic-light color")
          }
      }

   7. Reassign the ``trafficLightColor`` variable to a ``"Yellow"`` value:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Yellow"

          when (trafficLightColor) {
              "Red" -> println("Stop")
              "Yellow" -> println("Slow")
              "Green" -> println("Go")
              else -> println("Invalid traffic-light color")
          }
      }

   When you run this program, what do you think the output will be?

   8. Run the program and then view the output:

   ::

      Slow

   ::

      when (trafficLightColor) {
      âŠ    "Red" -> println("Stop")
      â‹    "Yellow" -> println("Slow")
      âŒ    "Green" -> println("Go")
      â    else -> println("Invalid traffic-light color")
      }

   The output is a ``Slow`` message because:

   -  The ``trafficLightColor`` variable is assigned a ``"Yellow"`` value.
   -  The program evaluates each condition one-by-one in sequence.
   -  The ``"Yellow"`` value isn't equal to the ``"Red"`` value, so the program skips the first
      body.
   -  The ``"Yellow"`` value is equal to the ``"Yellow"`` value, so the program executes the second
      body and prints a ``Slow`` message.
   -  A body was executed, so the program ignores the third and fourth branches, and leaves the
      ``when`` statement.

   **Note:** There's a variant of the ``when`` statement that doesn't take any parameters and is
   used as a replacement of an ``if/else`` chain. To learn more, see `When expression <https://kotlinlang.org/docs/control-flow.html#when-expression>`__.


Write more complex conditions in a ``when`` statement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   So far you learned how to write ``when`` conditions for a single equal condition, such as when
   the ``trafficLightColor`` variable is assigned a ``"Yellow"`` value. Next, you learn to use the
   comma (``,``), the ``in`` keyword, and the ``is`` keyword to form more complex ``when``
   conditions.

   Build a program that determines whether a number between 1 and 10 is a prime number:

   1. Open `Kotlin playground <https://developer.android.google.cn/training/kotlinplayground>`__ in
      a separate window.

   You return to the traffic-light program later.

   2. Define an ``x`` variable and then assign it a ``3`` value:

   .. code:: prettyprint

      fun main() {
          val x = 3
      }

   3. Add a ``when`` statement that includes multiple branches for ``2``, ``3``, ``5`` and ``7``
      conditions and follow each with a ``println("x is prime number between 1 and 10.")`` body:

   .. code:: prettyprint

      fun main() {
          val x = 3

          when (x) {
              2 -> println("x is a prime number between 1 and 10.")
              3 -> println("x is a prime number between 1 and 10.")
              5 -> println("x is a prime number between 1 and 10.")
              7 -> println("x is a prime number between 1 and 10.")
          }
      }

   4. Add an ``else`` branch with a ``println("x is not prime number between 1 and 10.")`` body:

   .. code:: prettyprint

      fun main() {
          val x = 3

          when (x) {
              2 -> println("x is a prime number between 1 and 10.")
              3 -> println("x is a prime number between 1 and 10.")
              5 -> println("x is a prime number between 1 and 10.")
              7 -> println("x is a prime number between 1 and 10.")
              else -> println("x isn't a prime number between 1 and 10.")
          }
      }

   5. Run the program and then verify that the output is as expected:

   ::

      x is a prime number between 1 and 10.


Use a comma (``,`` **) for multiple conditions**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   The prime-number program contains a lot of repetition of ``println()`` statements. When you write
   a ``when`` statement, you can use a comma (``,``) to denote multiple conditions that correspond
   to the same body.


   ::

             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      when ( â”‚  parameter  â”‚ ) {
             â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ condition 1 â”‚,  â”‚ condition 2 â”‚ -> â”‚ block body 1 & 2       â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ condition 3 â”‚ -> â”‚ block body 3           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   In the previous diagram, if either the first or second condition is fulfilled, the corresponding
   body is executed.

   Rewrite the prime number program with this concept:

   1. In the branch for the ``2`` condition, add ``3``, ``5`` and ``7`` separated by commas (``,``):

   .. code:: prettyprint

      fun main() {
          val x = 3

          when (x) {
              2, 3, 5, 7 -> println("x is a prime number between 1 and 10.")
              3 -> println("x is a prime number between 1 and 10.")
              5 -> println("x is a prime number between 1 and 10.")
              7 -> println("x is a prime number between 1 and 10.")
              else -> println("x isn't a prime number between 1 and 10.")
          }
      }

   2. Remove the individual branches for the ``3``, ``5`` and ``7`` conditions:

   .. code:: prettyprint

      fun main() {
          val x = 3

          when (x) {
              2, 3, 5, 7 -> println("x is a prime number between 1 and 10.")
              else -> println("x isn't a prime number between 1 and 10.")
          }
      }

   3. Run the program and then verify that the output is as expected:

   ::

      x is a prime number between 1 and 10.


Use the ``in`` **keyword for a range of conditions**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   Besides the comma (``,``) symbol to denote multiple conditions, you can also use the ``in``
   keyword and a range of values in ``when`` branches.


   ::

             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      when ( â”‚  parameter  â”‚ ) {
             â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         in â”‚ range start â”‚ .. â”‚ range end â”‚ -> â”‚ block body 1           â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ condition 2 â”‚ -> â”‚ block body 2           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   To use a range of values, add a number that denotes the start of the range followed by two
   periods without any spaces and then close it with another number that denotes the end of the
   range.

   When the value of the parameter is equal to any value in the range between start of the range and
   the end of the range, the first body executes.

   In your prime-number program, can you print a message if the number is between 1 and 10, but not
   a prime number?

   Add another branch with the ``in`` keyword:

   1. After the first branch of the ``when`` statement, add a second branch with the ``in`` keyword
      followed by a ``1..10`` range and a
      ``println("x is a number between 1 and 10, but not a prime number.")`` body:

   .. code:: prettyprint

      fun main() {
          val x = 3

          when (x) {
              2, 3, 5, 7 -> println("x is a prime number between 1 and 10.")
              in 1..10 -> println("x is a number between 1 and 10, but not a prime number.")
              else -> println("x isn't a prime number between 1 and 10.")
          }
      }

   2. Change the ``x`` variable to a ``4`` value:

   .. code:: prettyprint

      fun main() {
          val x = 4

          when (x) {
              2, 3, 5, 7 -> println("x is a prime number between 1 and 10.")
              in 1..10 -> println("x is a number between 1 and 10, but not a prime number.")
              else -> println("x isn't a prime number between 1 and 10.")
          }
      }

   3. Run the program and then verify the output:

   ::

      x is a number between 1 and 10, but not a prime number.

   The program prints the message of the second branch, but not the message of the first or third
   branch.

   ::

      when (x) {
      âŠ       2, 3, 5, 7 -> println("x is a prime number between 1 and 10.")
      â‹       in 1..10 -> println("x is a number between 1 and 10, but not a prime number.")
      âŒ       else -> println("x isn't a prime number between 1 and 10.")
      }

   Here's how this program works:

   -  The ``x`` variable is assigned a ``4`` value.
   -  The program proceeds to evaluate conditions for the first branch. The ``4`` value isn't the
      ``2``, ``3``, ``5``, or ``7`` values, so the program skips the execution of the body of the
      first branch and proceeds to the second branch.
   -  The ``4`` value is between ``1`` and ``10``, so the message of
      ``x is a number between 1 and 10, but not a prime number.`` body is printed.
   -  One body is executed, so the program proceeds to leave the ``when`` statement and ignores the
      ``else`` branch.


Use the ``is`` keyword to check data type
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   You can use the ``is`` keyword as a condition to check the data type of an evaluated value.


   ::

             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      when ( â”‚  parameter  â”‚ ) {
             â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         is â”‚    type     â”‚ -> â”‚ block body 1           â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ condition 2 â”‚ -> â”‚ block body 2           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }



   In the previous diagram, if the value of the argument is of the data type stated, the first body
   is executed.

   In your prime-number program, can you print a message if the input is an integer number that's
   outside the range of 1 to 10?

   Add another branch with the ``is`` keyword:

   1. Modify ``x`` to be of type ``Any``. This is to indicate that ``x`` can be of value other than
      ``Int`` type.

   .. code:: prettyprint

      fun main() {
          val x: Any = 4

          when (x) {
              2, 3, 5, 7 -> println("x is a prime number between 1 and 10.")
              in 1..10 -> println("x is a number between 1 and 10, but not a prime number.")
              else -> println("x isn't a prime number between 1 and 10.")
          }
      }

   2. After the second branch of the ``when`` statement, add the ``is`` keyword and an ``Int`` data
      type with a ``println("x is an integer number, but not between 1 and 10.")`` body:

   .. code:: prettyprint

      fun main() {
          val x: Any = 4

          when (x) {
              2, 3, 5, 7 -> println("x is a prime number between 1 and 10.")
              in 1..10 -> println("x is a number between 1 and 10, but not a prime number.")
              is Int -> println("x is an integer number, but not between 1 and 10.")
              else -> println("x isn't a prime number between 1 and 10.")
          }
      }

   3. In the ``else`` branch, change the body to a ``println("x isn't an integer number.")`` body:

   .. code:: prettyprint

      fun main() {
          val x: Any = 4

          when (x) {
              2, 3, 5, 7 -> println("x is a prime number between 1 and 10.")
              in 1..10 -> println("x is a number between 1 and 10, but not a prime number.")
              is Int -> println("x is an integer number, but not between 1 and 10.")
              else -> println("x isn't an integer number.")
          }
      }

   4. Change the ``x`` variable to a ``20`` value:

   .. code:: prettyprint

      fun main() {
          val x: Any = 20

          when (x) {
              2, 3, 5, 7 -> println("x is a prime number between 1 and 10.")
              in 1..10 -> println("x is a number between 1 and 10, but not a prime number.")
              is Int -> println("x is an integer number, but not between 1 and 10.")
              else -> println("x isn't an integer number.")
          }
      }

   5. Run the program and then verify the output:

   ::

      x is an integer number, but not between 1 and 10.

   The program prints the message of the third branch, but not the messages of the first, second, or
   fourth branches.

   ::

          when (x) {
          âŠ   2, 3, 5, 7 -> println("x is a prime number between 1 and 10.")
          â‹   in 1..10 -> println("x is a number between 1 and 10, but not a prime number.")
          âŒ   is Int -> println("x is an integer number, but not between 1 and 10.")
          â   else -> println("x isn't an integer number.")
          }

   Here's how the program works:

   -  The ``x`` variable is assigned a ``20`` value.
   -  The program proceeds to evaluate conditions for the first branch. The ``20`` value isn't the
      ``2``, ``3``, ``5`` or ``7`` values, so the program skips the execution of the body of the
      first branch and proceeds to the second branch.
   -  The ``20`` value isn't inside the ``1`` to ``10`` range, so the program skips the execution of
      the body of the second branch and proceeds to the third branch.
   -  The ``20`` value is of ``Int`` type, so the
      ``x is an integer number, but not between 1 and 10`` body is printed.
   -  One body is executed, so the program proceeds to leave the ``when`` statement and ignores the
      ``else`` branch.


Try it


   Now practice what you learned in your traffic-light program.

   Imagine that there's an amber traffic-light color in some countries that warns drivers the same
   way as a yellow traffic light in other countries. Can you modify the program so that this
   additional condition is covered and maintain the original conditions?


Add an additional condition with the same body
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   Add an additional condition to the traffic-light program:

   1. If you still have it open, go back to the instance of Kotlin Playground with your
      traffic-light program.
   2. If you closed it, open a new instance of Kotlin Playground and enter this code:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Yellow"

          when (trafficLightColor) {
              "Red" -> println("Stop")
              "Yellow" -> println("Slow")
              "Green" -> println("Go")
              else -> println("Invalid traffic-light color")
          }
      }

   3. In the second branch of the ``when`` statement, add a comma after the ``"Yellow"`` condition
      and then an ``"Amber"`` condition:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Yellow"

          when (trafficLightColor) {
              "Red" -> println("Stop")
              "Yellow", "Amber" -> println("Slow")
              "Green" -> println("Go")
              else -> println("Invalid traffic-light color")
          }
      }

   4. Change the ``trafficLightColor`` variable to an ``"Amber"`` value:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Amber"

          when (trafficLightColor) {
              "Red" -> println("Stop")
              "Yellow", "Amber" -> println("Slow")
              "Green" -> println("Go")
              else -> println("Invalid traffic-light color")
          }
      }

   5. Run this program and then verify the output:

   ::

      Slow


4. Use if/else and when as expressions

   You learned how to use ``if/else`` and ``when`` as statements. When you use conditionals as
   statements, you let each branch execute different actions in the body based on the conditions.

   You can also use conditionals as expressions to return different values for each branch of
   condition. When the body of each branch appears similar, you can use conditional expressions to
   improve code readability compared to conditional statements.


   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®        â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      val  â”‚    name     â”‚ = if ( â”‚  condition  â”‚ ) {
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯        â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body 1           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      } else {
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ block body 2           â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   The syntax for conditionals as expressions is similar to statements, but the last line of bodies
   in each branch need to return a value or an expression, and the conditionals are assigned to a
   variable.

   If the bodies only contain a return value or expression, you can remove the curly braces to make
   the code more concise.

   ::

           â•­â”€â”€â”€â”€â”€â”€â•®        â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
      val  â”‚ name â”‚ = if ( â”‚  condition  â”‚ ) â”‚ expression 1 â”‚ else â”‚ expression 2 â”‚ 
           â•°â”€â”€â”€â”€â”€â”€â•¯        â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 

   In the next section, you take a look at ``if/else`` expressions through the traffic-light
   program.


Convert an ``if`` statement to an expression
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   There's a lot of ``println()`` statement repetition in this ``if/else`` statement:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          if (trafficLightColor == "Red") {
              println("Stop")
          } else if (trafficLightColor == "Yellow") {
              println("Slow")
          } else if (trafficLightColor == "Green") {
              println("Go")
          } else {
              println("Invalid traffic-light color")
          }

      }

   Convert this ``if/else`` statement to an ``if/else`` expression and remove this repetition:

   1. In Kotlin playground, enter the previous traffic-light program.
   2. Define a ``message`` variable and then assign it an ``if/else`` statement:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          val message = if (trafficLightColor == "Red") {
              println("Stop")
          } else if (trafficLightColor == "Yellow") {
              println("Slow")
          } else if (trafficLightColor == "Green") {
              println("Go")
          } else {
              println("Invalid traffic-light color")
          }

      }

   3. Remove all ``println()`` statements and their curly braces, but leave the values inside them:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          val message = 
            if (trafficLightColor == "Red") "Stop"
            else if (trafficLightColor == "Yellow") "Slow"
            else if (trafficLightColor == "Green") "Go"
            else "Invalid traffic-light color"
      }

   4. Add a ``println()`` statement to the end of the program and then pass it the ``message``
      variable as an argument:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Black"

          val message = 
            if (trafficLightColor == "Red") "Stop"
            else if (trafficLightColor == "Yellow") "Slow"
            else if (trafficLightColor == "Green") "Go"
            else "Invalid traffic-light color"

          println(message)
      }

   5. Run this program and then view the output:

   ::

      Invalid traffic-light color


Try it


   Convert the traffic-light program to use a ``when`` expression instead of a ``when`` statement:

   1. In Kotlin Playground, enter this code:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Amber"

          when (trafficLightColor) {
              "Red" -> println("Stop")
              "Yellow", "Amber" -> println("Slow")
              "Green" -> println("Go")
              else -> println("Invalid traffic-light color")
          }
      }

   Can you convert the ``when`` statement to an expression so that you don't repeat the
   ``println()`` statements?

   2. Create a ``message`` variable and assign it to the ``when`` expression:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Amber"

          val message = when(trafficLightColor) {
              "Red" -> "Stop"
              "Yellow", "Amber" -> "Slow"
              "Green" -> "Go"
              else -> "Invalid traffic-light color"
          }
      }

   3. Add a ``println()`` statement as the last line of the program and then pass it the
      ``message`` variable as an argument:

   .. code:: prettyprint

      fun main() {
          val trafficLightColor = "Amber"

          val message = when(trafficLightColor) {
              "Red" -> "Stop"
              "Yellow", "Amber" -> "Slow"
              "Green" -> "Go"
              else -> "Invalid traffic-light color"
          }
          println(message)
      }

   **Note:** A ``when`` statement doesn't need the ``else`` branch to be defined. However, in most
   cases, a ``when`` expression requires the ``else`` branch because the ``when`` expression needs
   to return a value. As such, the Kotlin compiler checks whether all the branches are exhaustive.
   An ``else`` branch ensures that there won't be a scenario in which the variable doesn't get
   assigned a value.


5. Conclusion

   Congratulations! You learned about conditionals and how to write them in Kotlin.


Summary


   -  In Kotlin, branching can be achieved with ``if/else`` or ``when`` conditionals.
   -  The body of an ``if`` branch in an ``if/else`` conditional is only executed when the boolean
      expression inside the ``if`` branch condition returns a ``true`` value.
   -  Subsequent ``else if`` branches in an ``if/else`` conditional get executed only when previous
      ``if`` or ``else if`` branches return ``false`` values.
   -  The final ``else`` branch in an ``if/else`` conditional only gets executed when all previous
      ``if`` or ``else if`` branches return ``false`` values.
   -  It's recommended to use the ``when`` conditional to replace an ``if/else`` conditional when
      there are more than two branches.
   -  You can write more complex conditions in ``when`` conditionals with the comma (``,``), ``in``
      ranges, and the ``is`` keyword.
   -  ``if/else`` and ``when`` conditionals can work as either statements or expressions.


Learn more


   -  `Conditions and loops <https://kotlinlang.org/docs/control-flow.html#break-and-continue-in-loops>`__


â­ Use nullability in Kotlin
=============================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-nullability


1. Before you begin
-------------------

   This codelab teaches you about nullability and the importance of ``null`` safety. Nullability is
   a concept commonly found in many programming languages. It refers to the ability of variables to
   have an absence of value. In Kotlin, nullability is intentionally treated to achieve ``null``
   safety.


Prerequisites

   -  Knowledge of Kotlin programming basics, including variables, accessing methods and properties
      from a variable and the ``println()`` and ``main()`` functions
   -  Familiarity with Kotlin conditionals, including ``if/else`` statements and Boolean expressions


What you'll learn

   -  What ``null`` is.
   -  The difference between nullable and non-nullable types.
   -  What ``null`` safety is, its importance, and how Kotlin achieves ``null`` safety.
   -  How to access methods and properties of nullable variables with the ``?.`` safe call operator
      and ``!!`` non-null assertion operator.
   -  How to perform ``null`` checks with ``if/else`` conditionals.
   -  How to convert a nullable variable to a non-nullable type with ``if/else`` expressions.
   -  How to provide a default value when a nullable variable is ``null`` with the ``if/else``
      expression or the ``?:`` Elvis operator.


**What you'll need**

   -  A web browser with access to Kotlin Playground


2. Use nullable variables
-------------------------


What is ``null`` **?**

   In Unit 1, you learned that when you declare a variable, you need to assign it a value
   immediately. For example, when you declare a ``favoriteActor`` variable, you may assign it a
   ``"Sandra Oh"`` string value immediately.

   .. code:: prettyprint

      val favoriteActor = "Sandra Oh"

   ::

      â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      â•‘               â•‘
      â•‘               â•‘
      â•‘ favoriteActor â•‘ <--- "Sandra Oh"
      â•‘               â•‘
      â•‘               â•‘
      â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


   However, what if you don't have a favorite actor? You might want to assign the variable a
   ``"Nobody"`` or ``"None"`` value. This isn't a good approach because your program interprets the
   ``favoriteActor`` variable to have a ``"Nobody"`` or ``"None"`` value rather than no value at
   all. In Kotlin, you can use ``null`` to indicate that there's no value associated with the
   variable.

   ::

      â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      â•‘               â•‘
      â•‘               â•‘
      â•‘ favoriteActor â•‘ <--- null
      â•‘               â•‘
      â•‘               â•‘
      â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


   To use ``null`` in code, follow these steps:

   1. In `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__,
      replace the content in the body of the ``main()`` function with a ``favoriteActor`` variable
      set to ``null``:

   .. code:: prettyprint

      fun main() {
          val favoriteActor = null
      }

   2. Print the value of the ``favoriteActor`` variable with the ``println()`` function and then run
      this program:

   .. code:: prettyprint

      fun main() {
          val favoriteActor = null
          println(favoriteActor)
      }

   The output looks like this code snippet:

   ::

      null


Variable reassignments with ``null``

   Previously, you learned that you can reassign variables defined with the ``var`` keyword to
   different values of the same type. For example, you can reassign a ``name`` variable that's
   declared with one name to another name as long as the new name is of ``String`` type.

   .. code:: prettyprint

      var favoriteActor: String = "Sandra Oh"
      favoriteActor = "Meryl Streep"

   There are occasions after you declare a variable when you may want to assign the variable to
   ``null``. For example, after you declare your favorite actor, you decide that you don't want to
   reveal your favorite actor at all. In this case, it's useful to assign the ``favoriteActor``
   variable to ``null``.


**Understand non-nullable and nullable variables**

   To reassign the ``favoriteActor`` variable to ``null``, follow these steps:

   1. Change the ``val`` keyword to a ``var`` keyword, and then specify that the ``favoriteActor``
      variable is a ``String`` type and assign it to the name of your favorite actor:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String = "Sandra Oh"
          println(favoriteActor)
      }

   2. Remove the ``println()`` function:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String = "Sandra Oh"
      }

   3. Reassign the ``favoriteActor`` variable to ``null`` and then run this program:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String = "Sandra Oh"
          favoriteActor = null
      }

   You get this error message:

   ::

      â“˜  Null can not be a value of non-null type String

   In Kotlin, there's a distinction between nullable and non-nullable types:

   -  Nullable types are variables that *can* hold ``null``.
   -  Non-null types are variables that *can't* hold ``null``.

   A type is only nullable if you explicitly let it hold ``null``. As the error message says, the
   ``String`` data type is a non-nullable type, so you can't reassign the variable to ``null``.

   ::

                      Nullable type
                      â•­â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â•®
            â•­â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â•®
      val   â”‚ name â”‚ : â”‚ type â”‚ ? = â”‚ value â”‚
            â•°â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â•¯


   To declare nullable variables in Kotlin, you need to add a ``?`` operator to the end of the type.
   For example, a ``String?`` type can hold either a string or ``null``, whereas a ``String`` type
   can only hold a string. To declare a nullable variable, you need to explicitly add the nullable
   type. Without the nullable type, the Kotlin compiler infers that it's a non-nullable type.

   4. Change the ``favoriteActor`` variable type from a ``String`` data type to a ``String?`` data
      type:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"
          favoriteActor = null
      }

   5. Print the ``favoriteActor`` variable before and after the ``null`` reassignment, and then run
      this program:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"
          println(favoriteActor)

          favoriteActor = null
          println(favoriteActor)
      }

   The output looks like this code snippet:

   ::

      Sandra Oh
      null

   The ``favoriteActor`` variable originally held a string and is then reassigned to ``null``.


**Try it**

   Now that you can use the nullable ``String?`` type, can you initialize a variable with an ``Int``
   value and reassign it to ``null``?


Write a nullable ``Int`` value

   1. Remove all the code in the ``main()`` function:

   .. code:: prettyprint

      fun main() {
          
      }

   2. Create a ``number`` variable of a nullable ``Int`` type and then assign it a ``10`` value:

   .. code:: prettyprint

      fun main() {
          var number: Int? = 10
      }

   3. Print the ``number`` variable and then run this program:

   .. code:: prettyprint

      fun main() {
          var number: Int? = 10
          println(number)
      }

   The output is as expected:

   ::

      10

   4. Reassign the ``number`` variable to ``null`` to confirm that the variable is nullable:

   .. code:: prettyprint

      fun main() {
          var number: Int? = 10
          println(number)
          
          number = null
      }

   5. Add another ``println(number)`` statement as the final line of the program and then run it:

   .. code:: prettyprint

      fun main() {
          var number: Int? = 10
          println(number)
          
          number = null
          println(number)
      }

   The output is as expected:

   ::

      10
      null

   **Note:** While you should use nullable variables for variables that can carry ``null``, you
   should use non-nullable variables for variables that can never carry ``null`` because the access
   of nullable variables requires more complex handling. You learn about various techniques to
   handle nullable variables in the next section.


3. Handle nullable variables
----------------------------

   Previously, you learned to use the ``.`` operator to access methods and properties of
   non-nullable variables. In this section, you learn how to use it to access methods and properties
   of nullable variables.

   To access a property of the non-nullable ``favoriteActor`` variable, follow these steps:

   1. Remove all the code in the ``main()`` function, and then declare a ``favoriteActor`` variable
      of ``String`` type and assign it to the name of your favorite actor:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String = "Sandra Oh"
      }

   2. Print the number of characters in the ``favoriteActor`` variable value with the `length <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/length.html>`__
      property and then run this program:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String = "Sandra Oh"
          println(favoriteActor.length)
      }

   The output is as expected:

   ::

      9

   There are *nine* characters in the value of the ``favoriteActor`` variable, which includes
   spaces. The number of characters in your favorite actor's name might be different.


Access a property of a nullable variable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Imagine that you want to make the ``favoriteActor`` variable nullable so that people who don't
   have a favorite actor can assign the variable to ``null``.

   To access a property of the nullable ``favoriteActor`` variable, follow these steps:

   -  Change the ``favoriteActor`` variable type to a nullable type and then run this program:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"
          println(favoriteActor.length)
      }

   You get this error message:

   ::

      â“˜ Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullabe receiver of type String?


   This error is a *compile error*. As mentioned in a previous codelab, a compile error happens when
   Kotlin isn't able to compile the code due to a syntax error in your code.

   Kotlin intentionally applies syntactic rules so that it can achieve ``null`` *safety*, which
   refers to a guarantee that *no accidental calls are made on potentially* ``null`` *variables*.
   This doesn't mean that variables can't be ``null``. It means that if a member of a variable is
   accessed, the variable can't be ``null``.

   This is critical because if there's an attempt to access a member of a variable that's ``null`` -
   known as ``null`` *reference -* during the running of an app, the app crashes because the
   ``null`` variable doesn't contain any property or method. This type of crash is known as a
   *runtime error* in which the error happens after the code has compiled and runs.

   Due to the ``null`` safety nature of Kotlin, such runtime errors are prevented because the Kotlin
   compiler forces a ``null`` *check* for nullable types. ``Null`` *check* refers to a process of
   checking whether a variable could be ``null`` before it's accessed and treated as a non-nullable
   type. If you wish to use a nullable value as its non-nullable type, you need to perform a
   ``null`` check explicitly. You learn about this in the **Use** ``if/else`` **conditionals**
   section later in this codelab.

   In this example, the code fails at compile time because the direct reference to the ``length``
   property for the ``favoriteActor`` variable isn't allowed because there's a possibility that the
   variable is ``null``.

   Next, you learn various techniques and operators to work with nullable types.


Use the ``?.`` safe call operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   You can use the ``?.`` safe call operator to access methods or properties of nullable variables.


   ::

            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚ nullable variable â”‚ ?. â”‚ method/property â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   To use the ``?.`` safe call operator to access a method or property, add a ``?`` symbol after the
   variable name and access the method or property with the ``.`` notation.

   The ``?.`` safe call operator allows safer access to nullable variables because the Kotlin
   compiler stops any attempt of member access to ``null`` references and returns ``null`` for the
   member accessed.

   To safely access a property of the nullable ``favoriteActor`` variable, follow these steps:

   1. In the ``println()`` statement, replace the ``.`` operator with the ``?.`` safe call operator:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"
          println(favoriteActor?.length)
      }

   2. Run this program and then verify that the output is as expected:

   ::

      9

   The number of characters of your favorite actor's name might differ.

   3. Reassign the ``favoriteActor`` variable to ``null`` and then run this program:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = null
          println(favoriteActor?.length)
      }

   You see this output:

   ::

      null

   Notice that the program doesn't crash despite an attempt to access the ``length`` property of a
   ``null`` variable. The safe call expression simply returns ``null``.

   **Note:** You can also use the ``?.`` safe call operators on non-nullable variables to access a
   method or property. While the Kotlin compiler won't give any error for this, it's unnecessary
   because the access of methods or properties for non-nullable variables is always safe.


Use the ``!!`` not-null assertion operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   You can also use the ``!!`` not-null assertion operator to access methods or properties of
   nullable variables.


   ::

            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚ nullable variable â”‚ !!. â”‚ method/property â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   After the nullable variable, you need to add the ``!!`` not-null assertion operator followed by
   the ``.`` operator and then the method or property without any spaces.

   As the name suggests, if you use the ``!!`` not-null assertion, it means that you assert that the
   value of the variable isn't ``null``, regardless of whether it is or isn't.

   Unlike ``?.`` safe-call operators, the use of a ``!!`` not-null assertion operator may result in
   a ``NullPointerException`` error being thrown if the nullable variable is indeed ``null``. Thus,
   it should be done only when the variable is always non-nullable or proper exception handling is
   set in place. When not handled, exceptions cause runtime errors. You learn about exception
   handling in later units of this course.

   To access a property of the ``favoriteActor`` variable with the ``!!`` not-null assertion
   operator, follow these steps:

   1. Reassign the ``favoriteActor`` variable to your favorite actor's name and then replace the
      ``?.`` safe-call operator with the ``!!`` not-null assertion operator in ``println()``
      statement:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"
          println(favoriteActor!!.length)
      }

   2. Run this program and then verify that the output is as expected:

   ::

      9

   The number of characters of your favorite actor's name might differ.

   3. Reassign the ``favoriteActor`` variable to ``null`` and then run this program:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = null
          println(favoriteActor!!.length)
      }

   You get a ``NullPointerException`` error:

   ::

      Exception in thread "main" java.lang.NullPointerException
         at FileKt.main (File.kt:3)
         at FileKt.main (File.kt:-1)
         at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (:-1)


   This Kotlin error shows that your program crashed during execution. As such, it's not recommended
   to use the ``!!`` not-null assertion operator unless you're sure that the variable isn't
   ``null``.

   **Note:** In other programming languages that don't contain the null-safety attribute, the
   ``NullPointerException`` error is the frequent cause of app crashes. As such, Kotlin eliminates a
   huge cause of program crashes because it includes ``null`` safety in the language.


Use the ``if/else`` conditionals
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   You can use the ``if`` branch in the ``if/else`` conditionals to perform ``null`` *checks*.


   ::

            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    
            â”‚ nullable variable â”‚ != null
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    


   To perform ``null`` checks, you can check that the nullable variable isn't equal to ``null`` with
   the ``!=`` comparison operator.


``if/else`` statements
~~~~~~~~~~~~~~~~~~~~~~

   An ``if/else`` statement can be used together with a ``null`` check as follows:


   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    
      if ( â”‚ nullable variable â”‚ ) {
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ body 1 â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯
       â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      }â”‚ else {            â”‚
       â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®       â”‚
       â”‚  â”‚ body 2 â”‚       â”‚ <-- optional
       â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯       â”‚
       â”‚}                  â”‚
       â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   The null check is useful when combined with an ``if/else`` statement:

   -  The ``null`` check of the ``nullableVariable != null`` expression is used as the ``if``
      condition.
   -  Body 1 inside the ``if`` branch assumes that the variable is not ``null``. Therefore, in this
      body, you can freely access methods or properties of the variable as if it's a non-nullable
      variable without using a ``?.`` safe-call operator or a ``!!`` not-null assertion operator.
   -  Body 2 inside the ``else`` branch assumes that the variable is ``null``. Therefore, in this
      body, you can add statements that should run when the variable is ``null``. The ``else``
      branch is optional. You can use only the ``if`` conditional to run a ``null`` check without
      providing default action when the ``null`` check fails.

   The ``null`` check is more convenient to use with the ``if`` condition when there are multiple
   lines of code that use the nullable variable. In contrast, the ``?.`` safe-call operator is more
   convenient for a single reference of the nullable variable.

   To write an ``if/else`` statement with a ``null`` check for the ``favoriteActor`` variable,
   follow these steps:

   1. Assign the ``favoriteActor`` variable to the name of your favorite actor again and then remove
      the ``println()`` statement:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"

      }

   2. Add an ``if`` branch with a ``favoriteActor != null`` condition:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"

          if (favoriteActor != null) {

          }
      }

   3. In the body of the ``if`` branch, add a ``println`` statement that accepts a
      ``"The number of characters in your favorite actor's name is ${favoriteActor.length}."``
      string and then run this program:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"

          if (favoriteActor != null) {
            println("The number of characters in your favorite actor's name is ${favoriteActor.length}.")
          }
      }

   The output is as expected.

   ::

      The number of characters in your favorite actor's name is 9.

   The number of characters in your favorite actor's name might differ.

   Notice that you can access the name's length method directly with the ``.`` operator because you
   access the ``length`` method inside the ``if`` branch after the ``null`` check. As such, the
   Kotlin compiler knows that there's no possibility that the ``favoriteActor`` variable is
   ``null``, so the compiler allows direct access to the property.

   4. Optional: Add an ``else`` branch to handle a situation in which the actor's name is ``null``:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"

          if (favoriteActor != null) {
            println("The number of characters in your favorite actor's name is ${favoriteActor.length}.")
          } else {

          }
      }

   5. In the body of the ``else`` branch, add a ``println`` statement that takes a
      ``"You didn't input a name."`` string:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"

          if (favoriteActor != null) {
            println("The number of characters in your favorite actor's name is ${favoriteActor.length}.")
          } else {
            println("You didn't input a name.")
          }
      }

   6. Assign the ``favoriteActor`` variable to ``null`` and then run this program:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = null

          if(favoriteActor != null) {
            println("The number of characters in your favorite actor's name is ${favoriteActor.length}.")
          } else {
            println("You didn't input a name.")
          }
      }

   The output is as expected:

   ::

      You didn't input a name.


``if/else`` **expressions**
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   You can also combine the ``null`` check with an ``if/else`` expression to convert a nullable
   variable to a non-nullable variable.

   ::

            â•­â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®        â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      val   â”‚ name â”‚ : â”‚ non-null type â”‚ = if ( â”‚  null check  â”‚ ) {
            â•°â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯        â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚    body 1     â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      } else {
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚    body 2     â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   To assign an ``if/else`` expression to a non-nullable type:

   -  The ``nullableVariable != null`` ``null`` check is used as the ``if`` condition.
   -  Body 1 inside the ``if`` branch assumes that the variable is not ``null``. Therefore, in this
      body, you can access methods or properties of the variable as if it's a non-nullable variable
      without a ``?.`` safe call operator or a ``!!`` not-null assertion operator.
   -  Body 2 inside the ``else`` branch assumes that the variable is ``null``. Therefore, in this
      body you can add statements that should run when the variable is ``null``.
   -  In the final line of body 1 and 2, you need to use an expression or value that results in a
      non-nullable type so that it's assigned to the non-nullable variable when the ``null`` check
      passes or fails respectively.

   To use the ``if/else`` expression to rewrite the program so that it only uses one ``println``
   statement, follow these steps:

   1. Assign the ``favoriteActor`` variable to the name of your favorite actor:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"

          if (favoriteActor != null) {
            println("The number of characters in your favorite actor's name is ${favoriteActor.length}.")
          } else {
            println("You didn't input a name.")
          }
      }

   2. Create a ``lengthOfName`` variable and then assign it to the ``if/else`` expression:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"

          val lengthOfName = if (favoriteActor != null) {
            println("The number of characters in your favorite actor's name is ${favoriteActor.length}.")
          } else {
            println("You didn't input a name.")
          }
      }

   3. Remove both ``println()`` statements from the ``if`` and ``else`` branches:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"

          val lengthOfName = if (favoriteActor != null) {
            
          } else {
            
          }
      }

   4. In the body of the ``if`` branch, add a ``favoriteActor.length`` expression:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"

          val lengthOfName = if (favoriteActor != null) {
            favoriteActor.length
          } else {
            
          }
      }

   The ``length`` property of the ``favoriteActor`` variable is accessed directly with the ``.``
   operator.

   5. In the body of the ``else`` branch, add a ``0`` value:

   .. code:: prettyprint

      fun main() {
         var favoriteActor: String? = "Sandra Oh"

          val lengthOfName = if (favoriteActor != null) {
            favoriteActor.length
          } else {
            0
          }
      }

   The ``0`` value serves as the default value when the name is ``null``.

   6. At the end of the ``main()`` function, add a ``println`` statement that takes a
      ``"The number of characters in your favorite actor's name is $lengthOfName."`` string and then
      run this program:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"

          val lengthOfName = if (favoriteActor != null) {
            favoriteActor.length
          } else {
            0
          }

          println("The number of characters in your favorite actor's name is $lengthOfName.")
      }

   The output is as expected:

   ::

      The number of characters in your favorite actor's name is 9.

   The number of characters of the name that you used might differ.

   **Note:** You can also use the ``==`` comparison operator for ``null`` checks instead of the
   ``!=`` operator. When doing so, note that the two bodies are reversed. The body of the ``if``
   branch assumes that the variable is ``null`` and the body of the ``else`` branch assumes that the
   variable is not ``null``.


Use the ``?:`` Elvis operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The ``?:`` Elvis operator is an operator that you can use together with the ``?.`` safe-call
   operator. With the ``?:`` Elvis operator, you can add a default value when the ``?.`` safe-call
   operator returns ``null``. It's similar to an ``if/else`` expression, but in a more idiomatic
   way.

   If the variable *isn't* ``null``, the expression before the ``?:`` Elvis operator executes. If
   the variable *is* ``null``, the expression after the ``?:`` Elvis operator executes.


   ::

          â•­â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      val â”‚ name â”‚ = â”‚ nullable variable â”‚ ?. â”‚ method/property â”‚ ?: â”‚ default value â”‚
          â•°â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   To modify your previous program to use the ``?:`` Elvis operator, follow these steps:

   1. Remove the ``if/else`` conditional and then set the ``lengthOfName`` variable to the nullable
      ``favoriteActor`` variable and use the ``?.`` safe-call operator to call its ``length``
      property:

   .. code:: prettyprint

      fun main() {
         var favoriteActor: String? = "Sandra Oh"

          val lengthOfName = favoriteActor?.length

          println("The number of characters in your favorite actor's name is $lengthOfName.")
      }

   2. After the ``length`` property, add the ``?:`` Elvis operator followed by a ``0`` value and
      then run this program:

   .. code:: prettyprint

      fun main() {
          var favoriteActor: String? = "Sandra Oh"

          val lengthOfName = favoriteActor?.length ?: 0

          println("The number of characters in your favorite actor's name is $lengthOfName.")
      }

   The output is the same as the previous output:

   ::

      The number of characters in your favorite actor's name is 9.

   **Note:** The ``?:`` Elvis operator is named after `Elvis Presley <https://en.wikipedia.org/wiki/Elvis_Presley>`__, 
   the rock star, because it resembles an emoticon of his `quiff <https://en.wikipedia.org/wiki/Quiff>`__ 
   when you view it sideways.


4. Conclusion
-------------

   Congratulations! You learned about nullability and how to use various operators to manage it.


Summary

   -  A variable can be set to ``null`` to indicate that it holds no value.
   -  Non-nullable variables cannot be assigned ``null``.
   -  Nullable variables can be assigned ``null``.
   -  To access methods or properties of nullable variables, you need to use ``?.`` safe-call
      operators or ``!!`` not-null assertion operators.
   -  You can use ``if/else`` statements with ``null`` checks to access nullable variables in
      non-nullable contexts.
   -  You can convert a nullable variable to a non-nullable type with ``if/else`` expressions.
   -  You can provide a default value for when a nullable variable is ``null`` with the ``if/else``
      expression or the ``?:`` Elvis operator.


**Learn more**

   -  `Null safety <https://kotlinlang.org/docs/null-safety.html>`__


â­ Use classes and objects in Kotlin
=====================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-classes-and-objects


1. Before you begin
-------------------

   This codelab teaches you how to use classes and objects in Kotlin.

   Classes provide blueprints from which objects can be constructed. An object is an instance of a
   class that consists of data specific to that object. You can use objects or class instances
   interchangeably.

   As an analogy, imagine that you build a house. A class is similar to an architect's design plan,
   also known as a blueprint. The blueprint isn't the house; it's the instruction for how to build
   the house. The house is the actual thing, or object, which is built based on the blueprint.

   Just like the house blueprint specifies multiple rooms and each room has its own design and
   purpose, each class has its own design and purpose. To know how to design your classes, you need
   to get familiar with *object-oriented programming (OOP)*, a framework that teaches you to enclose
   data, logic, and behavior in objects.

   OOP helps you simplify complex, real-world problems into smaller objects. There are four basic
   concepts of OOP, each of which you learn more about later in this codelab:

   -  **Encapsulation.** Wraps the related properties and methods that perform action on those
      properties in a class. For example, consider your mobile phone. It encapsulates a camera,
      display, memory cards, and several other hardware and software components. You don't have to
      worry about how components are wired internally.
   -  **Abstraction.** An extension to encapsulation. The idea is to hide the internal
      implementation logic as much as possible. For example, to take a photo with your mobile phone,
      all you need to do is open the camera app, point your phone to the scene that you want to
      capture, and click a button to capture the photo. You don't need to know how the camera app is
      built or how the camera hardware on your mobile phone actually works. In short, the internal
      mechanics of the camera app and how a mobile camera captures the photos are abstracted to let
      you perform the tasks that matter.
   -  **Inheritance.** Enables you to build a class upon the characteristics and behavior of other
      classes by establishing a parent-child relationship. For example, there are different
      manufacturers who produce a variety of mobile devices that run Android OS, but the UI for each
      of the devices is different. In other words, the manufacturers inherit the Android OS feature
      and build their customizations on top of it.
   -  **Polymorphism.** The word is an adaptation of the Greek root *poly-*, which means many, and
      *-morphism*, which means forms. Polymorphism is the ability to use different objects in a
      single, common way. For example, when you connect a Bluetooth speaker to your mobile phone,
      the phone only needs to know that there's a device that can play audio over Bluetooth.
      However, there are a variety of Bluetooth speakers that you can choose from and your phone
      doesn't need to know how to work with each of them specifically.

   Lastly, you learn about property delegates, which provide reusable code to manage property values
   with a concise syntax. In this codelab, you learn these concepts when you build a class structure
   for a smart-home app.

   **Note**: Smart devices make our lives convenient and easier. There are many smart-home solutions
   available on the market that let you control smart devices with your smartphone. With a single
   tap on your mobile device, you can control a variety of devices, such as smart TVs, lights,
   thermostats, and other household appliances.


Prerequisites

   -  How to open, edit, and run code in `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__.
   -  Knowledge of Kotlin programming basics, including variables, functions, and the ``println()``
      and ``main()`` functions


What you'll learn

   -  An overview of OOP.
   -  What classes are.
   -  How to define a class with constructors, functions, and properties.
   -  How to instantiate an object.
   -  What inheritance is.
   -  The difference between IS-A and HAS-A relationships.
   -  How to override properties and functions.
   -  What visibility modifiers are.
   -  What a delegate is and how to use the ``by`` delegate.


What you'll build

   -  A smart-home class structure.
   -  Classes that represent smart devices, such as a smart TV and a smart light.

   **Note:** The code that you write won't interact with real hardware devices. Instead, you print
   actions in the console with the ``println()`` function to simulate the interactions.


What you'll need

   -  A computer with internet access and a web browser


2. Define a class
-----------------

   When you define a class, you specify the properties and methods that all objects of that class
   should have.

   A class definition starts with the ``class`` keyword, followed by a name and a set of curly
   braces. The part of the syntax before the opening curly brace is also referred to as the class
   header. In the curly braces, you can specify properties and functions for the class. You learn
   about properties and functions soon. You can see the syntax of a class definition in this
   diagram:


   ::

             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
      class  â”‚ class name â”‚  {
             â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ class body â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   These are the recommended naming conventions for a class:

   -  You can choose any class name that you want, but don't use Kotlin `keywords <https://kotlinlang.org/docs/keyword-reference.html>`__ 
      as a class name, such as the ``fun`` keyword.
   -  The class name is written in PascalCase, so each word begins with a capital letter and there
      are no spaces between the words. For example, in `SmartDevice` , the first letter of each
      word is capitalized and there isn't a space between the words.

   A class consists of three major parts:

   -  **Properties.** Variables that specify the attributes of the class's objects.
   -  **Methods.** Functions that contain the class's behaviors and actions.
   -  **Constructors.** A special member function that creates instances of the class throughout the
      program in which it's defined.

   This isn't the first time that you've worked with classes. In previous codelabs, you learned
   about data types, such as the ``Int``, ``Float``, ``String``, and ``Double`` data types. These
   data types are defined as classes in Kotlin. When you define a variable as shown in this code
   snippet, you create an object of the ``Int`` class, which is instantiated with a ``1`` value:

   .. code:: prettyprint

      val number: Int = 1

   Define a ``SmartDevice`` class:

   1. In `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__,
      replace the content with an empty ``main()`` function:

   .. code:: prettyprint

      fun main() {
      }

   2. On the line before the ``main()`` function, define a ``SmartDevice`` class with a body that
      includes an *``//``* *``empty``* *``body``* comment:

   .. code:: prettyprint

      class SmartDevice {
          // empty body
      }

      fun main() {
      }


3. Create an instance of a class
--------------------------------

   As you learned, a class is a blueprint for an object. The Kotlin runtime uses the class, or
   blueprint, to create an object of that particular type. With the ``SmartDevice`` class, you have
   a blueprint of what a smart device is. To have an *actual* smart device in your program, you need
   to create a ``SmartDevice`` object instance. The instantiation syntax starts with the class name
   followed by a set of parentheses as you can see in this diagram:


   ::

             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
             â”‚ ClassName â”‚  ( )
             â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 

   To use an object, you create the object and assign it to a variable, similar to how you define a
   variable. You use the ``val`` keyword to create an immutable variable and the ``var`` keyword for
   a mutable variable. The ``val`` or ``var`` keyword is followed by the name of the variable, then
   an ``=`` assignment operator, then the instantiation of the class object. You can see the syntax
   in this diagram:


   ::

          â•­â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
      val â”‚ name â”‚ = â”‚ ClassName â”‚ ( )
          â•°â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 

   **Note:** When you define the variable with the ``val`` keyword to reference the object, the
   variable itself is read-only, but the class object remains mutable. This means that you can't
   reassign another object to the variable, but you can change the object's state when you update
   its properties' values.

   Instantiate the ``SmartDevice`` class as an object:

   -  In the ``main()`` function, use the ``val`` keyword to create a variable named
      ``smartTvDevice`` and initialize it as an instance of the ``SmartDevice`` class:

   .. code:: prettyprint

      fun main() {
          val smartTvDevice = SmartDevice()
      }


4. Define class methods
-----------------------

   In Unit 1, you learned that:

   -  The definition of a function uses the ``fun`` keyword followed by a set of parentheses and a
      set of curly braces. The curly braces contain code, which are the instructions needed to
      execute a task.
   -  The calling of a function causes the code contained in that function to execute.

   Actions that the class can perform are defined as functions in the class. For example, imagine
   that you own a smart device, a smart TV, or a smart light, which you can switch on and off with
   your mobile phone. The smart device is translated to the ``SmartDevice`` class in programming,
   and the action to switch it on and off is represented by the ``turnOn()`` and ``turnOff()``
   functions, which enable the on and off behavior.

   The syntax to define a function in a class is identical to what you learned before. The only
   difference is that the function is placed in the class body. When you define a *function* in the
   class body, it's referred to as a member function or a *method*, and it represents the behavior
   of the class. For the rest of this codelab, functions are referred to as methods whenever they
   appear in the body of a class.

   Define a ``turnOn()`` and ``turnOff`(`` method in the ``SmartDevice`` class:

   1. In the body of the ``SmartDevice`` class, define a ``turnOn()`` method with an empty body:

   .. code:: prettyprint

      class SmartDevice {
          fun turnOn() {

          }
      }

   2. In the body of the ``turnOn()`` method, add a ``println()`` statement and then pass it a
      ``"Smart`` ``device`` ``is`` ``turned`` ``on."`` string:

   .. code:: prettyprint

      class SmartDevice {
          fun turnOn() {
              println("Smart device is turned on.")
          }
      }

   3. After the ``turnOn()`` method, add a ``turnOff()`` method that prints a ``"Smart`` ``device``
      ``is`` ``turned`` ``off."`` string:

   .. code:: prettyprint

      class SmartDevice {
          fun turnOn() {
              println("Smart device is turned on.")
          }

          fun turnOff() {
              println("Smart device is turned off.")
          }
      }


Call a method on an **object**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   So far, you defined a class that serves as a blueprint for a smart device, created an instance of
   the class, and assigned the instance to a variable. Now you use the ``SmartDevice`` class's
   methods to turn the device on and off.

   The call to a method in a class is similar to how you called other functions from the ``main()``
   function in the previous codelab. For example, if you need to call the ``turnOff()`` method from
   the ``turnOn()`` method, you can write something similar to this code snippet:

   .. code:: prettyprint

      class SmartDevice {
          fun turnOn() {
              // A valid use case to call the turnOff() method could be to turn off the TV when available power doesn't meet the requirement.
              turnOff()
              ...
          }

          ...
      }

   To call a class method outside of the class, start with the class object followed by the ``.``
   operator, the name of the function, and a set of parentheses. If applicable, the parentheses
   contain arguments required by the method. You can see the syntax in this diagram:

   ::

        â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
        â”‚ classObject â”‚.â”‚ methodName â”‚ ( â”‚   [Optional] Arugments   â”‚ )
        â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   Call the ``turnOn()`` and ``turnOff()`` methods on the object:

   1. In the ``main()`` function on the line after the ``smartTvDevice`` variable, call the
      ``turnOn()`` method:

   .. code:: prettyprint

      fun main() {
          val smartTvDevice = SmartDevice()
          smartTvDevice.turnOn()
      }

   2. On the line after the ``turnOn()`` method, call the ``turnOff()`` method:

   .. code:: prettyprint

      fun main() {
          val smartTvDevice = SmartDevice()
          smartTvDevice.turnOn()
          smartTvDevice.turnOff()
      }

   3. Run the code.

   The output is the following:

   ::

      Smart device is turned on.
      Smart device is turned off.


5. Define class properties
--------------------------

   In Unit 1, you learned about variables, which are containers for single pieces of data. You
   learned how to create a read-only variable with the ``val`` keyword and a mutable variable with
   the ``var`` keyword.

   While methods define the actions that a class can perform, the properties define the class's
   characteristics or data attributes. For example, a smart device has these properties:

   -  **Name.** Name of the device.
   -  **Category.** Type of smart device, such as entertainment, utility, or cooking.
   -  **Device status**. Whether the device is on, off, online, or offline. The device is considered
      online when it's connected to the internet. Otherwise, it's considered offline.

   Properties are basically variables that are defined in the class body instead of the function
   body. This means that the syntax to define properties and variables are identical. You define an
   immutable property with the ``val`` keyword and a mutable property with the ``var`` keyword.

   Implement the aforementioned characteristics as properties of the ``SmartDevice`` class:

   1. On the line before the ``turnOn`(`` method, define the ``name`` property and assign it to an
      ``"Android`` ``TV"`` string:

   .. code:: prettyprint

      class SmartDevice {

          val name = "Android TV"

          fun turnOn() {
              println("Smart device is turned on.")
          }

          fun turnOff() {
              println("Smart device is turned off.")
          }
      }

   2. On the line after the ``name`` property, define the ``category`` property and assign it to an
      ``"Entertainment"`` string, and then define a ``deviceStatus`` property and assign it to an
      ``"online"`` string:

   .. code:: prettyprint

      class SmartDevice {

          val name = "Android TV"
          val category = "Entertainment"
          var deviceStatus = "online"

          fun turnOn() {
              println("Smart device is turned on.")
          }

          fun turnOff() {
              println("Smart device is turned off.")
          }
      }

   3. On the line after the ``smartTvDevice`` variable, call the ``println()`` function and then
      pass it a ``"Device`` ``name`` ``is:`` ``${smartTvDevice.name}"`` string:

   .. code:: prettyprint

      fun main() {
          val smartTvDevice = SmartDevice()
          println("Device name is: ${smartTvDevice.name}")
          smartTvDevice.turnOn()
          smartTvDevice.turnOff()
      }

   4. Run the code.

   The output is the following:

   ::

      Device name is: Android TV
      Smart device is turned on.
      Smart device is turned off.


Getter and setter functions in properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Properties can do more than a variable can. For example, imagine that you create a class
   structure to represent a smart TV. One of the common actions that you perform is increase and
   decrease the volume. To represent this action in programming, you can create a property named
   ``speakerVolume``, which holds the current volume level set on the TV speaker, but there's a
   range in which the value for volume resides. The minimum volume one can set is 0, while the
   maximum is 100. To ensure that the ``speakerVolume`` property never exceeds 100 or falls below 0,
   you can write a *setter* function. When you update the value of the property, you need to check
   whether the value is in the range of 0 to 100. As another example, imagine that there's a
   requirement to ensure that the name is always in uppercase. You can implement a *getter* function
   to convert the ``name`` property to uppercase.

   Before going deeper into how to implement these properties, you need to understand the full
   syntax to declare them. The full syntax to define a *mutable* property starts with the variable
   definition followed by the optional ``get()`` and ``set()`` functions. You can see the syntax in
   this diagram:


   ::

          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
      var â”‚    name    â”‚ : â”‚ data type â”‚ = â”‚ initial value â”‚ 
          â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 
         get () {
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚ getter body      â”‚
            â”‚ return statement â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         set () {
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚ setter body â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   When you don't define the getter and setter function for a property, the Kotlin compiler
   internally creates the functions. For example, if you use the ``var`` keyword to define a
   ``speakerVolume`` property and assign it a ``2`` value, the compiler autogenerates the getter and
   setter functions as you can see in this code snippet:

   .. code:: prettyprint

      var speakerVolume = 2
          get() = field  
          set(value) {
              field = value    
          }

   You won't see these lines in your code because they're added by the compiler in the background.

   The full syntax for an ``immutable`` property has two differences:

   -  It starts with the ``val`` keyword.
   -  The variables of ``val`` type are read-only variables, so they don't have ``set()`` functions.

   Kotlin properties use a *backing field* to hold a value in memory. A *backing field* is basically
   a class variable defined internally in the properties. A *backing field* is scoped to a property,
   which means that you can only access it through the ``get()`` or ``set()`` property functions.

   To read the property value in the ``get()`` function or update the value in the ``set()``
   function, you need to use the property's *backing field*. It's autogenerated by the Kotlin
   compiler and referenced with a ``field`` identifier.

   For example, when you want to update the property's value in the ``set()`` function, you use the
   ``set()`` function's parameter, which is referred to as the ``value`` parameter, and assign it to
   the ``field`` variable as you can see in this code snippet:

   .. code:: prettyprint

      var speakerVolume = 2
          set(value) {
              field = value    
          }

   **Warning**: Don't use the property name to get or set a value. For example, in the ``set()``
   function, if you try to assign the ``value`` parameter to the ``speakerVolume`` property itself,
   the code enters an endless loop because the Kotlin runtime tries to update the value for the
   ``speakerVolume`` property, which triggers a call to the setter function repeatedly.

   For example, to ensure that the value assigned to the ``speakerVolume`` property is in the range
   of 0 to 100, you could implement the *setter* function as you can see in this code snippet:

   .. code:: prettyprint

      var speakerVolume = 2
          set(value) {
              if (value in 0..100) {
                  field = value
              }
          }

   The ``set()`` functions check whether the ``Int`` value is in a range of 0 to 100 by using the
   ``in`` keyword followed by the range of value. If the value is in the expected range, the
   ``field`` value is updated. If not, the property's value remains unchanged.

   You include this property in a class in the *Implement a relationship between classes* section of
   this codelab, so you don't need to add the setter function to the code now.


6. Define a constructor
-----------------------

   The primary purpose of the *constructor* is to specify how the objects of the class are created.
   In other words, constructors initialize an object and make the object ready for use. You did this
   when you instantiated the object. The code inside the constructor executes when the object of the
   class is instantiated. You can define a constructor with or without parameters.


Default constructor
~~~~~~~~~~~~~~~~~~~


   A default constructor is a constructor without parameters. You can define a default constructor
   as shown in this code snippet:

   .. code:: prettyprint

      class SmartDevice constructor() {
          ...
      }

   Kotlin aims to be concise, so you can remove the ``constructor`` keyword if there are no
   annotations or visibility modifiers, which you learn about soon, on the constructor. You can also
   remove the parentheses if the constructor has no parameters as shown in this code snippet:

   .. code:: prettyprint

      class SmartDevice {
          ...
      }

   The Kotlin compiler autogenerates the default constructor. You won't see the autogenerated
   default constructor in your code because it's added by the compiler in the background.


Define a parameterized constructor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In the ``SmartDevice`` class, the ``name`` and ``category`` properties are immutable. You need to
   ensure that all the instances of the ``SmartDevice`` class initialize the ``name`` and
   ``category`` properties. With the current implementation, the values for the ``name`` and
   ``category`` properties are hardcoded. This means that all the smart devices are named with the
   ``"Android`` ``TV"`` string and categorized with the ``"Entertainment"`` string.

   To maintain immutability but avoid hardcoded values, use a parameterized constructor to
   initialize them:

   -  In the ``SmartDevice`` class, move the ``name`` and ``category`` properties to the constructor
      without assigning default values:

   .. code:: prettyprint

      class SmartDevice(val name: String, val category: String) {

          var deviceStatus = "online"

          fun turnOn() {
              println("Smart device is turned on.")
          }

          fun turnOff() {
              println("Smart device is turned off.")
          }
      }

   The constructor now accepts parameters to set up its properties, so the way to instantiate an
   object for such a class also changes. You can see the full syntax to instantiate an object in
   this diagram:


   ::

             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
      class  â”‚ class name â”‚ ( â”‚ [Optional] constructor arguments â”‚ )
             â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 

   **Note:** If the class doesn't have a default constructor and you attempt to instantiate the
   object without arguments, the compiler reports an error.

   This is the code representation:

   .. code:: prettyprint

      SmartDevice("Android TV", "Entertainment")

   Both arguments to the constructor are strings. It's a bit unclear as to which parameter the value
   should be assigned. To fix this, similar to how you passed function arguments, you can create a
   constructor with named arguments as shown in this code snippet:

   .. code:: prettyprint

      SmartDevice(name = "Android TV", category = "Entertainment")

   There are two main types of constructors in Kotlin:

   -  **Primary constructor.** A class can have only one primary constructor, which is defined as
      part of the class header. A primary constructor can be a default or parameterized constructor.
      The primary constructor doesn't have a body. That means that it can't contain any code.
   -  **Secondary constructor.** A class can have multiple secondary constructors. You can define
      the secondary constructor with or without parameters. The secondary constructor can initialize
      the class and has a body, which can contain initialization logic. If the class has a primary
      constructor, each secondary constructor needs to initialize the primary constructor.

   You can use the primary constructor to initialize properties in the class header. The arguments
   passed to the constructor are assigned to the properties. The syntax to define a primary
   constructor starts with the class name followed by the ``constructor`` keyword and a set of
   parentheses. The parentheses contain the parameters for the primary constructor. If there's more
   than one parameter, commas separate the parameter definitions. You can see the full syntax to
   define a primary constructor in this diagram:


   ::

             â•­â”€â”€â”€â”€â”€â”€â•®               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
      class  â”‚ name â”‚ constructor ( â”‚ parameters â”‚ ) {
             â•°â”€â”€â”€â”€â”€â”€â•¯               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ class body â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   The secondary constructor is enclosed in the body of the class and its syntax includes three
   parts:

   -  **Secondary constructor declaration.** The secondary constructor definition starts with the
      ``constructor`` keyword followed by parentheses. If applicable, the parentheses contain the
      parameters required by the secondary constructor.
   -  **Primary constructor initialization.** The initialization starts with a colon followed by the
      ``this`` keyword and a set of parentheses. If applicable, the parentheses contain the
      parameters required by the primary constructor.
   -  **Secondary constructor body.** Initialization of the primary constructor is followed by a set
      of curly braces, which contain the secondary constructor's body.

   You can see the syntax in this diagram:


   ::
                                    
                                 Primary constructor
                                           â”‚
                                 â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â•®
             â•­â”€â”€â”€â”€â”€â”€â•®               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
      class  â”‚ name â”‚ constructor ( â”‚ parameters â”‚ ) {
             â•°â”€â”€â”€â”€â”€â”€â•¯               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 
             Secondary constructor declaration   Secondary constructor declaration
                              â”‚                                â”‚
                    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â•® â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                       â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         constructor ( â”‚ parameters â”‚ ) : this ( â”‚ Primary constructor parameters â”‚ ) {
                       â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ class body â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   For example, imagine that you want to integrate an API developed by a smart-device provider.
   However, the API returns status code of ``Int`` type to indicate initial device status. The API
   returns a ``0`` value if the device is *offline* and a ``1`` value if the device is *online*. For
   any other integer value, the status is considered *unknown*. You can create a secondary
   constructor in the ``SmartDevice`` class to convert this ``statusCode`` parameter to string
   representation as you can see in this code snippet:

   .. code:: prettyprint

      class SmartDevice(val name: String, val category: String) {
          var deviceStatus = "online"

          constructor(name: String, category: String, statusCode: Int) : this(name, category) {
              deviceStatus = when (statusCode) {
                  0 -> "offline"
                  1 -> "online"
                  else -> "unknown"
              }
          }
          ...
      }


7. Implement a relationship between classes
-------------------------------------------

   Inheritance lets you build a class upon the characteristics and behavior of another class. It's a
   powerful mechanism that helps you write reusable code and establish relationships between
   classes.

   For example, there are many smart devices in the market, such as smart TVs, smart lights, and
   smart switches. When you represent smart devices in programming, they share some common
   properties, such as a name, category, and status. They also have common behaviors, such as the
   ability to turn them on and off.

   However, the way to turn on or turn off each smart device is different. For example, to turn on a
   TV, you might need to turn on the display, and then set up the last known volume level and
   channel. On the other hand, to turn on a light, you might only need an increase or decrease to
   the brightness.

   Also, each of the smart devices has more functions and actions that they can perform. For
   example, with a TV, you can adjust the volume and change the channel. With a light, you can
   adjust the brightness or color.

   In short, all smart devices have different features, yet share some common characteristics. You
   can either duplicate these common characteristics to each of the smart device classes or make the
   code reusable with inheritance.

   To do so, you need to create a ``SmartDevice`` parent class, and define these common properties
   and behaviors. Then, you can create child classes, such as the ``SmartTvDevice`` and
   ``SmartLightDevice`` classes, which inherit the properties of the parent class.

   In programming terms, we say that the ``SmartTvDevice`` and ``SmartLightDevice`` classes *extend*
   the ``SmartDevice`` parent class. The parent class is also referred to as a *superclass* and the
   child class as a *subclass*. You can see the relationship between them in this diagram:

   ::

                              Superclass (parent)
                                â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                                â”‚ SmartDevice â”‚
                                â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                       â”‚
                   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                   â”‚              inheritance               â”‚
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚ SmartTvDevice â”‚                      â”‚ SmartLightDevice â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
             Subclass (child)                        Subclass (child)

   However, in Kotlin, all the classes are final by default, which means that you can't extend them,
   so you have to define the relationships between them.

   Define the relationship between the ``SmartDevice`` superclass and its subclasses:

   1. In the ``SmartDevice`` superclass, add an ``open`` keyword before the ``class`` keyword to
      make it extendable:

   .. code:: prettyprint

      open class SmartDevice(val name: String, val category: String) {
          ...
      }

   The ``open`` keyword informs the compiler that this class is extendable, so now other classes can
   extend it.

   The syntax to create a subclass starts with the creation of the class header as you've done so
   far. The constructor's closing parenthesis is followed by a space, a colon, another space, the
   superclass name, and a set of parentheses. If necessary, the parentheses include the parameters
   required by the superclass constructor. You can see the syntax in this diagram:

   ::
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      class â”‚ Subclass name â”‚ ( â”‚ [optional] parameters â”‚ ) :
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚ Subclass name â”‚ ( â”‚ [optional] parameters â”‚ )
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚     body      â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   2. Create a ``SmartTvDevice`` subclass that extends the ``SmartDevice`` superclass:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {
      }

   The ``constructor`` definition for ``SmartTvDevice`` doesn't specify whether the properties are
   mutable or immutable. This means that the ``deviceName`` and ``deviceCategory`` parameters are
   merely ``constructor`` parameters instead of class properties. You won't be able to use them in
   the class, but simply pass them to the superclass constructor.

   3. In the ``SmartTvDevice`` subclass body, add the ``speakerVolume`` property that you created
      when you learned about the getter and setter functions:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var speakerVolume = 2
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }
      }

   4. Define a ``channelNumber`` property assigned to a ``1`` value with a setter function that
      specifies a ``0..200`` range:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var speakerVolume = 2
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

          var channelNumber = 1
              set(value) {
                  if (value in 0..200) {
                      field = value
                  }
              }
      }

   5. Define an ``increaseSpeakerVolume()`` method that increases the volume and prints a
      ``"Speaker`` ``volume`` ``increased`` ``to`` ``$speakerVolume."`` string:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var speakerVolume = 2
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

           var channelNumber = 1
              set(value) {
                  if (value in 0..200) {
                      field = value
                  }
              }

          fun increaseSpeakerVolume() {
              speakerVolume++
              println("Speaker volume increased to $speakerVolume.")
          } 
      }

   6. Add a ``nextChannel()`` method that increases the channel number and prints a ``"Channel``
      ``number`` ``increased`` ``to`` ``$channelNumber."`` string:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var speakerVolume = 2
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

          var channelNumber = 1
              set(value) {
                  if (value in 0..200) {
                      field = value
                  }
              }
          
          fun increaseSpeakerVolume() {
              speakerVolume++
              println("Speaker volume increased to $speakerVolume.")
          }

          fun nextChannel() {
              channelNumber++
              println("Channel number increased to $channelNumber.")
          }
      }

   7. On the line after the ``SmartTvDevice`` subclass, define a ``SmartLightDevice`` subclass that
      extends the ``SmartDevice`` superclass:

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {
      }

   8. In the ``SmartLightDevice`` subclass body, define a ``brightnessLevel`` property assigned to a
      ``0`` value with a setter function that specifies a ``0..100`` range:

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var brightnessLevel = 0
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }
      }

   9. Define an ``increaseBrightness()`` method that increases the brightness of the light and
      prints a ``"Brightness`` ``increased`` ``to`` ``$brightnessLevel."`` string:

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var brightnessLevel = 0
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

          fun increaseBrightness() {
              brightnessLevel++
              println("Brightness increased to $brightnessLevel.")
          }
      }


Relationships between classes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   When you use inheritance, you establish a relationship between two classes in something called an
   *IS-A relationship*. An object is also an instance of the class from which it inherits. In a
   *HAS-A relationship*, an object can own an instance of another class without actually being an
   instance of that class itself. You can see a high-level representation of these relationships in
   this diagram:

   ::

                                â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                                â”‚ SmartDevice â”‚
                                â•°â”€â”€â”€â”€â”€â”€^â”€â”€â”€â”€â”€â”€â•¯
                                       â”‚
                   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´
                   â”‚  Inherits (IS-A)
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚ SmartTvDevice â”‚<â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”‚ SmartHome â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  contains/uses (HAS-A)  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

      |High level representation of HAS-A and IS-A relationship.|


IS-A **relationships**
~~~~~~~~~~~~~~~~~~~~~~

   When you specify an IS-A relationship between the ``SmartDevice`` superclass and
   ``SmartTvDevice`` subclass, it means that whatever the ``SmartDevice`` superclass can do, the
   ``SmartTvDevice`` subclass can do. The relationship is unidirectional, so you can say that every
   smart TV *is a* smart device, but you can't say that every smart device *is a* smart TV. The code
   representation for an IS-A relationship is shown in this code snippet:

   .. code:: prettyprint

      // Smart TV IS-A smart device.
      class SmartTvDevice : SmartDevice() {
      }

   Don't use inheritance only to achieve code reusability. Before you decide, check whether the two
   classes are related to each other. If they exhibit some relationship, check whether they really
   qualify for the IS-A relationship. Ask yourself, "Can I say a subclass is a superclass?". For
   example, Android *is an* operating system.


HAS-A **relationships**
~~~~~~~~~~~~~~~~~~~~~~~

   A HAS-A relationship is another way to specify the relationship between two classes. For example,
   you will probably use the smart TV in your home. In this case, there's a relationship between the
   smart TV and the home. The home contains a smart device or, in other words, the home *has a*
   smart device. The *HAS-A* relationship between two classes is also referred to as *composition*.

   So far, you created a couple of smart devices. Now, you create the ``SmartHome`` class, which
   contains smart devices. The ``SmartHome`` class lets you interact with the smart devices.

   Use a HAS-A relationship to define a ``SmartHome`` class:

   1. In between the ``SmartLightDevice`` class and ``main()`` function, define a ``SmartHome``
      class:

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          ...

      }

      class SmartHome {
      }

      fun main() { 
          ...
      }

   2. In the ``SmartHome`` class constructor, use the ``val`` keyword to create a ``smartTvDevice``
      property of ``SmartTvDevice`` type:

   .. code:: prettyprint

      // The SmartHome class HAS-A smart TV device.
      class SmartHome(val smartTvDevice: SmartTvDevice) {

      }

   3. In the body of the ``SmartHome`` class, define a ``turnOnTv`(`` method that calls the
      ``turnOn()`` method on the ``smartTvDevice`` property:

   .. code:: prettyprint

      class SmartHome(val smartTvDevice: SmartTvDevice) {

          fun turnOnTv() {
              smartTvDevice.turnOn()
          }
      }

   4. On the line after the ``turnOnTv()`` method, define a ``turnOffTv()`` method that calls the
      ``turnOff()`` method on the ``smartTvDevice`` property:

   .. code:: prettyprint

      class SmartHome(val smartTvDevice: SmartTvDevice) {

          fun turnOnTv() {
              smartTvDevice.turnOn()
          }

          fun turnOffTv() {
              smartTvDevice.turnOff()
          }

      }

   5. On the line after the ``turnOffTv()`` method, define an ``increaseTvVolume()`` method that
      calls the ``increaseSpeakerVolume()`` method on the ``smartTvDevice`` property and then define
      a ``changeTvChannelToNext()`` method that calls the ``nextChannel()`` method on the
      ``smartTvDevice`` property:

   .. code:: prettyprint

      class SmartHome(val smartTvDevice: SmartTvDevice) {

          fun turnOnTv() {
              smartTvDevice.turnOn()
          }

          fun turnOffTv() {
              smartTvDevice.turnOff()
          }

          fun increaseTvVolume() {
              smartTvDevice.increaseSpeakerVolume()
          }

          fun changeTvChannelToNext() {
              smartTvDevice.nextChannel()
          }
      }

   6. In the ``SmartHome`` class constructor, move the ``smartTvDevice`` property parameter to its
      own line followed by a comma:

   .. code:: prettyprint

      class SmartHome(
          val smartTvDevice: SmartTvDevice,
      ) {

          ...

      }

   7. On the line after the ``smartTvDevice`` property, use the ``val`` keyword to define a
      ``smartLightDevice`` property of ``SmartLightDevice`` type:

   .. code:: prettyprint

      // The SmartHome class HAS-A smart TV device and smart light.
      class SmartHome(
          val smartTvDevice: SmartTvDevice,
          val smartLightDevice: SmartLightDevice
      ) {

          ...

      }

   8. In the ``SmartHome`` body, define a ``turnOnLight()`` method that calls the ``turnOn()``
      method on the ``smartLightDevice`` object and a ``turnOffLight()`` method that calls the
      ``turnOff()`` method on the ``smartLightDevice`` object:

   .. code:: prettyprint

      class SmartHome(
          val smartTvDevice: SmartTvDevice,
          val smartLightDevice: SmartLightDevice
      ) {

          ...

          fun changeTvChannelToNext() {
              smartTvDevice.nextChannel()
          }

          fun turnOnLight() {
              smartLightDevice.turnOn()
          }

          fun turnOffLight() {
              smartLightDevice.turnOff()
          }
      }

   9. On the line after the ``turnOffLight`(`` method, define an ``increaseLightBrightness()``
      method that calls the ``increaseBrightness()`` method on the ``smartLightDevice`` property:

   .. code:: prettyprint

      class SmartHome(
          val smartTvDevice: SmartTvDevice,
          val smartLightDevice: SmartLightDevice
      ) {

          ...

          fun changeTvChannelToNext() {
              smartTvDevice.nextChannel()
          }

          fun turnOnLight() {
              smartLightDevice.turnOn()
          }

          fun turnOffLight() {
              smartLightDevice.turnOff()
          }

          fun increaseLightBrightness() {
              smartLightDevice.increaseBrightness()
          }
      }

   10. On the line after the ``increaseLightBrightness()`` method, define a ``turnOffAllDevices()``
       method that calls the ``turnOffTv()`` and ``turnOffLight()`` methods:.

   .. code:: prettyprint

      class SmartHome(
          val smartTvDevice: SmartTvDevice,
          val smartLightDevice: SmartLightDevice
      ) {

          ...

          fun turnOffAllDevices() {
              turnOffTv()
              turnOffLight()
          }
      }


Override superclass methods from subclasses
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   As discussed earlier, even though the turn-on and turn-off functionality is supported by all the
   smart devices, the way in which they perform the functionality differs. To provide this
   device-specific behavior, you need to override the ``turnOn()`` and ``turnOff()`` methods defined
   in the superclass. To override means to intercept the action, typically to take manual control.
   When you override a method, the method in the subclass interrupts the execution of the method
   defined in the superclass and provides its own execution.

   Override the ``SmartDevice`` class ``turnOn()`` and ``turnOff()`` methods:

   1. In the body of the ``SmartDevice`` superclass before the ``fun`` keyword of each method, add
      an ``open`` keyword:

   .. code:: prettyprint

      open class SmartDevice(val name: String, val category: String) {

          var deviceStatus = "online"

          open fun turnOn() {
              // function body
          }

          open fun turnOff() {
              // function body
          }
      }

   2. In the body of the ``SmartLightDevice`` class, define a ``turnOn()`` method with an empty
      body:

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var brightnessLevel = 0
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

          fun increaseBrightness() {
              brightnessLevel++
              println("Brightness increased to $brightnessLevel.")
          }

          fun turnOn() {
          }
      }

   3. In the body of the ``turnOn()`` method, set the ``deviceStatus`` property to the string
      "``on``", set the ``brightnessLevel`` property to a value of ``2``, and add a ``println()``
      statement and then pass it a ``"$name`` ``turned`` ``on.`` ``The`` ``brightness`` ``level``
      ``is`` ``$brightnessLevel."`` string:

   .. code:: prettyprint

          fun turnOn() {
              deviceStatus = "on"
              brightnessLevel = 2
              println("$name turned on. The brightness level is $brightnessLevel.")
          }

   4. In the body of the ``SmartLightDevice`` class, define a ``turnOff()`` method with an empty
      body:

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var brightnessLevel = 0
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

          fun increaseBrightness() {
              brightnessLevel++
              println("Brightness increased to $brightnessLevel.")
          }

          fun turnOn() {
              deviceStatus = "on"
              brightnessLevel = 2
              println("$name turned on. The brightness level is $brightnessLevel.")
          }

          fun turnOff() {
          }
      }

   5. In the body of the ``turnOff()`` method, set the ``deviceStatus`` property to the string
      "``off``", set the ``brightnessLevel`` property to a value of ``0``, and add a ``println()``
      statement and then pass it a ``"Smart`` ``Light`` ``turned`` ``off"`` string:

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var brightnessLevel = 0
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

          fun increaseBrightness() {
              brightnessLevel++
              println("Brightness increased to $brightnessLevel.")
          }

          fun turnOn() {
              deviceStatus = "on"
              brightnessLevel = 2
              println("$name turned on. The brightness level is $brightnessLevel.")
          }

          fun turnOff() {
              deviceStatus = "off"
              brightnessLevel = 0
              println("Smart Light turned off")
          }
      }

   6. In the ``SmartLightDevice`` subclass before the ``fun`` keyword of the ``turnOn()`` and
      ``turnOff()`` methods, add the ``override`` keyword:

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var brightnessLevel = 0
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

          fun increaseBrightness() {
              brightnessLevel++
              println("Brightness increased to $brightnessLevel.")
          }

          override fun turnOn() {
              deviceStatus = "on"
              brightnessLevel = 2
              println("$name turned on. The brightness level is $brightnessLevel.")
          }

          override fun turnOff() {
              deviceStatus = "off"
              brightnessLevel = 0
              println("Smart Light turned off")
          }
      }

   The ``override`` keyword informs the Kotlin runtime to execute the code enclosed in the method
   defined in the subclass.

   7. In the body of the ``SmartTvDevice`` class, define a ``turnOn()`` method with an empty body:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) : SmartDevice(name = deviceName, category = deviceCategory) {

          var speakerVolume = 2
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }
              
          var channelNumber = 1
              set(value) {
                  if (value in 0..200) {
                      field = value
                  }
              }
              
          fun increaseSpeakerVolume() {
              speakerVolume++
              println("Speaker volume increased to $speakerVolume.")
          }
          
          fun nextChannel() {
              channelNumber++
              println("Channel number increased to $channelNumber.")
          }

          fun turnOn() {
          }
      }

   8. In the body of the ``turnOn()`` method, set the ``deviceStatus`` property to the string
      "``on``" and add a ``println()`` statement and then pass it a
      ``"$name is turned on. Speaker volume is set to $speakerVolume and channel number is " + "set to $channelNumber."``
      string:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) : SmartDevice(name = deviceName, category = deviceCategory) {

          ...

          fun turnOn() {
              deviceStatus = "on"
              println(
                  "$name is turned on. Speaker volume is set to $speakerVolume and channel number is " +
                      "set to $channelNumber."
              )
          }
      }

   9. In the body of the ``SmartTvDevice`` class after the ``turnOn()`` method, define a
      ``turnOff()`` method with an empty body:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) : SmartDevice(name = deviceName, category = deviceCategory) {

          ...

          fun turnOn() {
              ...
          }

          fun turnOff() {
          }
      }

   10. In the body of the ``turnOff()`` method, set the ``deviceStatus`` property to the string
       "``off``" and add a ``println()`` statement and then pass it a ``"$name`` ``turned`` ``off"``
       string:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) : SmartDevice(name = deviceName, category = deviceCategory) {

          ...

          fun turnOn() {
              ...
          }

          fun turnOff() {
              deviceStatus = "off"
              println("$name turned off")
          }
      }

   11. In the ``SmartTvDevice`` class before the ``fun`` keyword of the ``turnOn()`` and
       ``turnOff()`` methods, add the ``override`` keyword:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var speakerVolume = 2
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

          var channelNumber = 1
              set(value) {
                  if (value in 0..200) {
                      field = value
                  }
              }

          fun increaseSpeakerVolume() {
              speakerVolume++
              println("Speaker volume increased to $speakerVolume.")
          }

          fun nextChannel() {
              channelNumber++
              println("Channel number increased to $channelNumber.")
          }

          override fun turnOn() {
              deviceStatus = "on"
              println(
                  "$name is turned on. Speaker volume is set to $speakerVolume and channel number is " +
                      "set to $channelNumber."
              )
          }

          override fun turnOff() {
              deviceStatus = "off"
              println("$name turned off")
          }
      }

   12. In the ``main()`` function, use the ``var`` keyword to define a ``smartDevice`` variable of
       ``SmartDevice`` type that instantiates a ``SmartTvDevice`` object that takes an ``"Android``
       ``TV"`` argument and an ``"Entertainment"`` argument:

   .. code:: prettyprint

      fun main() {
          var smartDevice: SmartDevice = SmartTvDevice("Android TV", "Entertainment")
      }

   13. On the line after the ``smartDevice`` variable, call the ``turnOn()`` method on the
       ``smartDevice`` object:

   .. code:: prettyprint

      fun main() {
          var smartDevice: SmartDevice = SmartTvDevice("Android TV", "Entertainment")
          smartDevice.turnOn()
      }

   14. Run the code.

   The output is the following:

   ::

      Android TV is turned on. Speaker volume is set to 2 and channel number is set to 1.

   15. On the line after the call to the ``turnOn()`` method, reassign the ``smartDevice`` variable
       to instantiate a ``SmartLightDevice`` class that takes a ``"Google`` ``Light"`` argument and
       a ``"Utility"`` argument, and then call the ``turnOn()`` method on the ``smartDevice`` object
       reference:

   .. code:: prettyprint

      fun main() {
          var smartDevice: SmartDevice = SmartTvDevice("Android TV", "Entertainment")
          smartDevice.turnOn()
          
          smartDevice = SmartLightDevice("Google Light", "Utility")
          smartDevice.turnOn()
      }

   16. Run the code.

   The output is the following:

   ::

      Android TV is turned on. Speaker volume is set to 2 and channel number is set to 1.
      Google Light turned on. The brightness level is 2.

   This is an example of polymorphism. The code calls the ``turnOn()`` method on a variable of
   ``SmartDevice`` type and, depending on what the actual value of the variable is, different
   implementations of the ``turnOn()`` method can be executed.


Reuse superclass code in subclasses with the ``super`` **keyword**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   When you take a close look at the ``turnOn`(`` and ``turnOff()`` methods, you notice that
   there's similarity in how the ``deviceStatus`` variable is updated whenever the methods are
   called in the ``SmartTvDevice`` and ``SmartLightDevice`` subclasses: the code duplicates. You can
   reuse the code when you update the status in the ``SmartDevice`` class.

   To call the overridden method in the superclass from the subclass, you need to use the ``super``
   keyword. Calling a method from the superclass is similar to calling the method from outside the
   class. Instead of using a ``.`` operator between the object and method, you need to use the
   ``super`` keyword, which informs the Kotlin compiler to call the method on the superclass instead
   of the subclass.

   The syntax to call the method from the superclass starts with a ``super`` keyword followed by the
   ``.`` operator, function name, and a set of parentheses. If applicable, the parentheses include
   the arguments. You can see the syntax in this diagram:

   ::

               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         super.â”‚ functionName â”‚ ( â”‚ [Optional] Arguments â”‚ )
               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   Reuse the code from the ``SmartDevice`` superclass:

   1. Remove the ``println()`` statements from the ``turnOn()`` and ``turnOff()`` methods and move
      the duplicated code from the ``SmartTvDevice`` and ``SmartLightDevice`` subclasses to the
      ``SmartDevice`` superclass:

   .. code:: prettyprint

      open class SmartDevice(val name: String, val category: String) {

          var deviceStatus = "online"

          open fun turnOn() {
              deviceStatus = "on"
          }

          open fun turnOff() {
              deviceStatus = "off"
          }
      }

   2. Use the ``super`` keyword to call the methods from the ``SmartDevice`` class in the
      ``SmartTvDevice`` and ``SmartLightDevice`` subclasses:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var speakerVolume = 2
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

           var channelNumber = 1
              set(value) {
                  if (value in 0..200) {
                      field = value
                  }
              }

          fun increaseSpeakerVolume() {
              speakerVolume++
              println("Speaker volume increased to $speakerVolume.")
          }

          fun nextChannel() {
              channelNumber++
              println("Channel number increased to $channelNumber.")
          }

          override fun turnOn() {
              super.turnOn()
              println(
                  "$name is turned on. Speaker volume is set to $speakerVolume and channel number is " +
                      "set to $channelNumber."
              )
          }

          override fun turnOff() {
              super.turnOff()
              println("$name turned off")
          }
      }

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          var brightnessLevel = 0
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

          fun increaseBrightness() {
              brightnessLevel++
              println("Brightness increased to $brightnessLevel.")
          }

          override fun turnOn() {
              super.turnOn()
              brightnessLevel = 2
              println("$name turned on. The brightness level is $brightnessLevel.")
          }

          override fun turnOff() {
              super.turnOff()
              brightnessLevel = 0
              println("Smart Light turned off")
          }
      }


Override superclass properties from subclasses
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Similar to methods, you can also override properties with the same steps.

   Override the ``deviceType`` property:

   1. In the ``SmartDevice`` superclass on the line after the ``deviceStatus`` property, use the
      ``open`` and ``val`` keywords to define a ``deviceType`` property set to an ``"unknown"``
      string:

   .. code:: prettyprint

      open class SmartDevice(val name: String, val category: String) {

          var deviceStatus = "online"

          open val deviceType = "unknown"
          ...
      }

   2. In the ``SmartTvDevice`` class, use the ``override`` and ``val`` keywords to define a
      ``deviceType`` property set to a ``"Smart`` ``TV"`` string:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          override val deviceType = "Smart TV"

          ...
      }

   3. In the ``SmartLightDevice`` class, use the ``override`` and ``val`` keywords to define a
      ``deviceType`` property set t `"` Smart`` ``Light"`` string:

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          override val deviceType = "Smart Light"

          ...

      }


8. Visibility modifiers
-----------------------

   Visibility modifiers play an important role to achieve encapsulation:

   -  In a *class*, they let you hide your properties and methods from unauthorized access outside
      the class.
   -  In a *package*, they let you hide the classes and interfaces from unauthorized access outside
      the package.

   Kotlin provides four visibility modifiers:

   -  ``publi``**.**`  Default visibility modifier. Makes the declaration accessible everywhere.
      The properties and methods that you want used outside the class are marked as public.
   -  ``privat``**.**`  Makes the declaration accessible in the same class or source file.

   There are likely some properties and methods that are only used inside the class, and that you
   don't necessarily want other classes to use. These properties and methods can be marked with the
   ``private`` visibility modifier to ensure that another class can't accidentally access them.

   -  ``protecte``**.**`  Makes the declaration accessible in subclasses. The properties and
      methods that you want used in the class that defines them and the subclasses are marked with
      the ``protected`` visibility modifier.
   -  ``interna``**.**`  Makes the declaration accessible in the same module. The internal modifier
      is similar to private, but you can access internal properties and methods from outside the
      class as long as it's being accessed in the same module.

   **Note:** A `module <https://developer.android.google.cn/studio/projects#ApplicationModules>`__
   is a collection of source files and build settings that let you divide your project into discrete
   units of functionality. Your project can have one or many modules. You can independently build,
   test, and debug each module.

   A *package* is like a directory or a folder that groups related classes, whereas a module
   provides a container for your app's source code, resource files, and app-level settings. A module
   can contain multiple packages.

   When you define a class, it's publicly visible and can be accessed by any package that imports
   it, which means that it's public by default unless you specify a visibility modifier. Similarly,
   when you define or declare properties and methods in the class, by default they can be accessed
   outside the class through the class object. It's essential to define proper visibility for code,
   primarily to hide properties and methods that other classes don't need to access.

   For example, consider how a car is made accessible to a driver. The specifics of what parts
   comprise the car and how the car works internally are hidden by default. The car is intended to
   be as intuitive to operate as possible. You wouldn't want a car to be as complex to operate as a
   commercial aircraft, similar to how you wouldn't want another developer or your future self to be
   confused as to what properties and methods of a class are meant to be used.

   Visibility modifiers help you surface the relevant parts of the code to other classes in your
   project and ensure that the implementation can't be unintentionally used, which makes for code
   that's easy to understand and less prone to bugs.

   The visibility modifier should be placed before the declaration syntax, while declaring the
   class, method, or properties as you can see in this diagram:

   ::

               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         super.â”‚ functionName â”‚ ( â”‚ [Optional] Arguments â”‚ )
               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


Specify a visibility modifier for properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The syntax to specify a visibility modifier for a property starts with the ``private``,
   ``protected``, or ``internal`` modifier followed by the syntax that defines a property. You can
   see the syntax in this diagram:

   ::

         â•­==========â•®     â•­â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ modifier â”‚ var â”‚ name â”‚ :  â”‚ data type â”‚ = â”‚ initial value â”‚
         â•°==========â•¯     â•°â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   For example, you can see how to make the ``deviceStatus`` property private in this code snippet:

   .. code:: prettyprint

      open class SmartDevice(val name: String, val category: String) {

          ...

          private var deviceStatus = "online"

          ...
      }

   You can also set the visibility modifiers to setter functions. The modifier is placed before the
   ``set`` keyword. You can see the syntax in this diagram:

   ::

          â•­â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      var â”‚ name â”‚ :  â”‚ data type â”‚ = â”‚ initial value â”‚
          â•°â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­==========â•®     
         â”‚ modifier â”‚ set (value) { 
         â•°==========â•¯     
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚  setter body  â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         }


   **Note:** If the visibility modifier for the getter function doesn't match with the visibility
   modifier for the property, the compiler reports an error.

   For the ``SmartDevice`` class, the value of the ``deviceStatus`` property should be readable
   outside of the class through class objects. However, only the class and its children should be
   able to update or write the value. To implement this requirement, you need to use the
   ``protected`` modifier on the ``set()`` function of the ``deviceStatus`` property.

   Use the ``protected`` modifier on the ``set()`` function of the ``deviceStatus`` property:

   1. In the ``SmartDevice`` superclass's ``deviceStatus`` property, add the ``protected`` modifier
      to the ``set()`` function:

   .. code:: prettyprint

      open class SmartDevice(val name: String, val category: String) {

          ...

          var deviceStatus = "online"
              protected set(value) {
                 field = value
             }

          ...
      }

   You aren't performing any actions or checks in the ``set()`` function. You are simply assigning
   the ``value`` parameter to the ``field`` variable. As you learned before, this is similar to the
   default implementation for property setters. You can omit the parentheses and body of the
   ``set()`` function in this case:

   .. code:: prettyprint

      open class SmartDevice(val name: String, val category: String) {

          ...

          var deviceStatus = "online"
              protected set

          ...
      }

   2. In the ``SmartHome`` class, define a ``deviceTurnOnCount`` property set to a ``0`` value with
      a private setter function:

   .. code:: prettyprint

      class SmartHome(
          val smartTvDevice: SmartTvDevice,
          val smartLightDevice: SmartLightDevice
      ) {

          var deviceTurnOnCount = 0
              private set

          ...
      }

   3. Add the ``deviceTurnOnCount`` property followed by the ``++`` arithmetic operator to the
      ``turnOnTv()`` and ``turnOnLight()`` methods, and then add the ``deviceTurnOnCount`` property
      followed by the ``--`` arithmetic operator to the ``turnOffTv()`` and ``turnOffLight()``
      methods:

   .. code:: prettyprint

      class SmartHome(
          val smartTvDevice: SmartTvDevice,
          val smartLightDevice: SmartLightDevice
      ) {

          var deviceTurnOnCount = 0
              private set

          fun turnOnTv() {
              deviceTurnOnCount++
              smartTvDevice.turnOn()
          }

          fun turnOffTv() {
              deviceTurnOnCount--
              smartTvDevice.turnOff()
          }
          
          ...

          fun turnOnLight() {
              deviceTurnOnCount++
              smartLightDevice.turnOn()
          }

          fun turnOffLight() {
              deviceTurnOnCount--
              smartLightDevice.turnOff()
          }

          ...

      }


Visibility modifiers for methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The syntax to specify a visibility modifier for a method starts with the ``private``,
   ``protected``, or ``internal`` modifiers followed by the syntax that defines a method. You can
   see the syntax in this diagram:

   ::

         â•­==========â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ modifier â”‚ fun â”‚  name  â”‚ ( ) { 
         â•°==========â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚      body     â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         }

   For example, you can see how to specify a ``protected`` modifier for the ``nextChannel()`` method
   in the ``SmartTvDevice`` class in this code snippet:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          ...

          protected fun nextChannel() {
              channelNumber++
              println("Channel number increased to $channelNumber.")
          }      

          ...
      }


Visibility modifiers for constructors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The syntax to specify a visibility modifier for a constructor is similar to defining the primary
   constructor with a couple of differences:

   -  The modifier is specified after the class name, but before the ``constructor`` keyword.
   -  If you need to specify the modifier for the primary constructor, it's necessary to keep the
      ``constructor`` keyword and parentheses even when there aren't any parameters.

   You can see the syntax in this diagram:

   ::

            â•­â”€â”€â”€â”€â”€â”€â”€â”€â•® â•­==========â•®              â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      class â”‚  name  â”‚ â”‚ modifier â”‚ constructor (â”‚ parameters â”‚ ) { 
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â•°==========â•¯              â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚      body     â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   For example, you can see how to add a ``protected`` modifier to the ``SmartDevice`` constructor
   in this code snippet:

   .. code:: prettyprint

      open class SmartDevice protected constructor (val name: String, val category: String) {

          ...

      }


Visibility modifiers for classes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The syntax to specify a visibility modifier for a class starts with the ``private``,
   ``protected``, or ``internal`` modifiers followed by the syntax that defines a class. You can see
   the syntax in this diagram:

   ::

      â•­==========â•®       â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®              â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      â”‚ modifier â”‚ class â”‚  name  â”‚ constructor (â”‚ parameters â”‚ ) { 
      â•°==========â•¯       â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯              â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚      body     â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }



   For example, you can see how to specify an ``internal`` modifier for the ``SmartDevice`` class in
   this code snippet:

   .. code:: prettyprint

      internal open class SmartDevice(val name: String, val category: String) {

          ...

      }

   Ideally, you should strive for strict visibility of properties and methods, so declare them with
   the ``private`` modifier as often as possible. If you can't keep them private, use the
   ``protected`` modifier. If you can't keep them protected, use the ``internal`` modifier. If you
   can't keep them internal, use the ``public`` modifier.


Specify appropriate visibility modifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This table helps you determine the appropriate visibility modifiers based on where the property
   or methods of a class or constructor should be accessible:

   +---------------+------------------+------------------+------------------+------------------+
   |   Modifier    |   Accessible in  |   Accessible in  |   Accessible in  |   Accessible     |
   |               |    same class    |     subclass     |    same module   | outside module   |
   +---------------+------------------+------------------+------------------+------------------+
   | ``private``   | âœ”                | ğ—«                | ğ—«                | ğ—«                |
   +---------------+------------------+------------------+------------------+------------------+
   | ``protected`` | âœ”                | âœ”                | ğ—«                | ğ—«                |
   +---------------+------------------+------------------+------------------+------------------+
   | ``internal``  | âœ”                | âœ”                | âœ”                | ğ—«                |
   +---------------+------------------+------------------+------------------+------------------+
   | ``public``    | âœ”                | âœ”                | âœ”                | âœ”                |
   +---------------+------------------+------------------+------------------+------------------+

   In the ``SmartTvDevice`` subclass, you shouldn't allow the ``speakerVolume`` and
   ``channelNumber`` properties to be controlled from outside the class. These properties should be
   controlled only through the ``increaseSpeakerVolume()`` and ``nextChannel()`` methods.

   Similarly, in the ``SmartLightDevice`` subclass, the ``brightnessLevel`` property should be
   controlled only through the ``increaseLightBrightness()`` method.

   Add the appropriate visibility modifiers to the ``SmartTvDevice`` and ``SmartLightDevice``
   subclasses:

   1. In the ``SmartTvDevice`` class, add a ``private`` visibility modifier to the ``speakerVolume``
      and ``channelNumber`` properties:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          private var speakerVolume = 2
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

          private var channelNumber = 1
              set(value) {
                  if (value in 0..200) {
                      field = value
                  }
              }

          ...
      }

   2. In the ``SmartLightDevice`` class, add a ``private`` modifier to the ``brightnessLevel``
      property:

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          ...

          private var brightnessLevel = 0
              set(value) {
                  if (value in 0..100) {
                      field = value
                  }
              }

          ...
      }


9. Define property delegates
----------------------------

   You learned in the previous section that properties in Kotlin use a *backing field* to hold their
   values in memory. You use the ``field`` identifier to reference it.

   When you look at the code so far, you can see the duplicated code to check whether the values are
   within range for the ``speakerVolume``, ``channelNumber``, and ``brightnessLevel`` properties in
   the ``SmartTvDevice`` and ``SmartLightDevice`` classes. You can reuse the range-check code in the
   setter function with *delegates*. Instead of using a field, and a getter and setter function to
   manage the value, the delegate manages it.

   The syntax to create property delegates starts with the declaration of a variable followed by the
   ``by`` keyword, and the delegate object that handles the getter and setter functions for the
   property. You can see the syntax in this diagram:

   ::

            â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      var   â”‚  name  â”‚ by â”‚     delegate object    â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


   Before you implement the class to which you can delegate the implementation, you need to be
   familiar with *interfaces*. An interface is a contract to which classes that implement it need to
   adhere. It focuses on *what to do* instead of *how to do* the action. In short, an interface
   helps you achieve *abstraction*.

   For example, before you build a house, you inform the architect about what you want. You want a
   bedroom, kid's room, living room, kitchen, and a couple of bathrooms. In short, you specify *what
   you want* and the architect specifies *how to achieve it*. You can see the syntax to create an
   interface in this diagram:

   ::

                â•­â”€â”€â”€â”€â”€â”€â”€â”€â•® 
      interface â”‚  name  â”‚ {
                â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚      body     â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   You already learned how to *extend* a class and *override* its functionality. With interfaces,
   the class *implements* the interface. The class provides implementation details for the methods
   and properties declared in the interface. You'll do something similar with the
   `ReadWriteProperty <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-read-write-property/>`__
   interface to create the delegate. You learn more about interfaces in the next unit.

   To create the delegate class for the ``var`` type, you need to implement the
   `ReadWriteProperty` interface. Similarly, you need to implement the `ReadOnlyProperty <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-read-only-property/>`__
   interface for the ``val`` type.

   Create the delegate for the ``var`` type:

   1. Before the ``main()`` function, create a ``RangeRegulator`` class that implements the
      ``ReadWriteProperty<Any?,`` ``Int>`` interface:

   .. code:: prettyprint

      class RangeRegulator() : ReadWriteProperty<Any?, Int> {

      }

      fun main() {
          ...
      }

   Don't worry about the angle brackets or the content inside them. They represent generic types and
   you learn about them in the next unit.

   2. In the ``RangeRegulator`` class's primary constructor, add an ``initialValue`` parameter, a
      private ``minValue`` property, and a private ``maxValue`` property, all of ``Int`` type:

   .. code:: prettyprint

      class RangeRegulator(
          initialValue: Int,
          private val minValue: Int,
          private val maxValue: Int
      ) : ReadWriteProperty<Any?, Int> {

      }

   3. In the ``RangeRegulator`` class's body, override the ``getValue()`` and ``setValue()``
      methods:

   .. code:: prettyprint

      class RangeRegulator(
          initialValue: Int,
          private val minValue: Int,
          private val maxValue: Int
      ) : ReadWriteProperty<Any?, Int> {

          override fun getValue(thisRef: Any?, property: KProperty<*>): Int {
          }

          override fun setValue(thisRef: Any?, property: KProperty<*>, value: Int) {
          }
      }

   These methods act as the properties' getter and setter functions.

   **Note:** The `KProperty <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/#kproperty>`__
   is an interface that represents a declared property and lets you access the metadata on a
   delegated property. It's good to have high-level information about what the `KProperty <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/#kproperty>`__
   is.

   4. On the line before the ``SmartDevice`` class, import the ``ReadWriteProperty`` and
      ``KProperty`` interfaces:

   .. code:: prettyprint

      import kotlin.properties.ReadWriteProperty
      import kotlin.reflect.KProperty

      open class SmartDevice(val name: String, val category: String) {
          ...
      }

      ...

      class RangeRegulator(
          initialValue: Int,
          private val minValue: Int,
          private val maxValue: Int
      ) : ReadWriteProperty<Any?, Int> {

          override fun getValue(thisRef: Any?, property: KProperty<*>): Int {
          }

          override fun setValue(thisRef: Any?, property: KProperty<*>, value: Int) {
          }
      }

      ...

   5. In the ``RangeRegulator`` class, on the line before the ``getValue()`` method, define a
      ``fieldData`` property and initialize it with ``initialValue`` parameter:

   .. code:: prettyprint

      class RangeRegulator(
          initialValue: Int,
          private val minValue: Int,
          private val maxValue: Int
      ) : ReadWriteProperty<Any?, Int> {

          var fieldData = initialValue

          override fun getValue(thisRef: Any?, property: KProperty<*>): Int {
          }

          override fun setValue(thisRef: Any?, property: KProperty<*>, value: Int) {
          }
      }

   This property acts as the *backing field* for the variable.

   6. In the ``getValue()`` method's body, return the ``fieldData`` property:

   .. code:: prettyprint

      class RangeRegulator(
          initialValue: Int,
          private val minValue: Int,
          private val maxValue: Int
      ) : ReadWriteProperty<Any?, Int> {

          var fieldData = initialValue

          override fun getValue(thisRef: Any?, property: KProperty<*>): Int {
              return fieldData
          }

          override fun setValue(thisRef: Any?, property: KProperty<*>, value: Int) {
          }
      }

   7. In the ``setValue()`` method's body, check whether the ``value`` parameter being assigned is
      in the ``minValue..maxValue`` range before you assign it to the ``fieldData`` property:

   .. code:: prettyprint

      class RangeRegulator(
          initialValue: Int,
          private val minValue: Int,
          private val maxValue: Int
      ) : ReadWriteProperty<Any?, Int> {

          var fieldData = initialValue

          override fun getValue(thisRef: Any?, property: KProperty<*>): Int {
              return fieldData
          }

          override fun setValue(thisRef: Any?, property: KProperty<*>, value: Int) {
              if (value in minValue..maxValue) {
                  fieldData = value
              }
          }
      }

   8. In the ``SmartTvDevice`` class, use the delegate class to define the ``speakerVolume`` and
      ``channelNumber`` properties:

   .. code:: prettyprint

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          override val deviceType = "Smart TV"

          private var speakerVolume by RangeRegulator(initialValue = 2, minValue = 0, maxValue = 100)

          private var channelNumber by RangeRegulator(initialValue = 1, minValue = 0, maxValue = 200)

          ...

      }

   9. In the ``SmartLightDevice`` class, use the delegate class to define the ``brightnessLevel``
      property:

   .. code:: prettyprint

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          override val deviceType = "Smart Light"

          private var brightnessLevel by RangeRegulator(initialValue = 0, minValue = 0, maxValue = 100)

          ...

      }


10. Test the solution
---------------------

   You can see the solution code in this code snippet:

   .. code:: prettyprint

      import kotlin.properties.ReadWriteProperty
      import kotlin.reflect.KProperty

      open class SmartDevice(val name: String, val category: String) {

          var deviceStatus = "online"
              protected set

          open val deviceType = "unknown"

          open fun turnOn() {
              deviceStatus = "on"
          }

          open fun turnOff() {
              deviceStatus = "off"
          }
      }

      class SmartTvDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          override val deviceType = "Smart TV"

          private var speakerVolume by RangeRegulator(initialValue = 2, minValue = 0, maxValue = 100)

          private var channelNumber by RangeRegulator(initialValue = 1, minValue = 0, maxValue = 200)

          fun increaseSpeakerVolume() {
              speakerVolume++
              println("Speaker volume increased to $speakerVolume.")
          }

          fun nextChannel() {
              channelNumber++
              println("Channel number increased to $channelNumber.")
          }

          override fun turnOn() {
              super.turnOn()
              println(
                  "$name is turned on. Speaker volume is set to $speakerVolume and channel number is " +
                      "set to $channelNumber."
              )
          }

          override fun turnOff() {
              super.turnOff()
              println("$name turned off")
          }
      }

      class SmartLightDevice(deviceName: String, deviceCategory: String) :
          SmartDevice(name = deviceName, category = deviceCategory) {

          override val deviceType = "Smart Light"

          private var brightnessLevel by RangeRegulator(initialValue = 0, minValue = 0, maxValue = 100)

          fun increaseBrightness() {
              brightnessLevel++
              println("Brightness increased to $brightnessLevel.")
          }

          override fun turnOn() {
              super.turnOn()
              brightnessLevel = 2
              println("$name turned on. The brightness level is $brightnessLevel.")
          }

          override fun turnOff() {
              super.turnOff()
              brightnessLevel = 0
              println("Smart Light turned off")
          }
      }

      class SmartHome(
          val smartTvDevice: SmartTvDevice,
          val smartLightDevice: SmartLightDevice
      ) {

          var deviceTurnOnCount = 0
              private set

          fun turnOnTv() {
              deviceTurnOnCount++
              smartTvDevice.turnOn()
          }

          fun turnOffTv() {
              deviceTurnOnCount--
              smartTvDevice.turnOff()
          }

          fun increaseTvVolume() {
              smartTvDevice.increaseSpeakerVolume()
          }

          fun changeTvChannelToNext() {
              smartTvDevice.nextChannel()
          }

          fun turnOnLight() {
              deviceTurnOnCount++
              smartLightDevice.turnOn()
          }

          fun turnOffLight() {
              deviceTurnOnCount--
              smartLightDevice.turnOff()
          }

          fun increaseLightBrightness() {
              smartLightDevice.increaseBrightness()
          }

          fun turnOffAllDevices() {
              turnOffTv()
              turnOffLight()
          }
      }

      class RangeRegulator(
          initialValue: Int,
          private val minValue: Int,
          private val maxValue: Int
      ) : ReadWriteProperty<Any?, Int> {

          var fieldData = initialValue

          override fun getValue(thisRef: Any?, property: KProperty<*>): Int {
              return fieldData
          }

          override fun setValue(thisRef: Any?, property: KProperty<*>, value: Int) {
              if (value in minValue..maxValue) {
                  fieldData = value
              }
          }
      }

      fun main() {
          var smartDevice: SmartDevice = SmartTvDevice("Android TV", "Entertainment")
          smartDevice.turnOn()

          smartDevice = SmartLightDevice("Google Light", "Utility")
          smartDevice.turnOn()
      }

   The output is the following:

   ::

      Android TV is turned on. Speaker volume is set to 2 and channel number is set to 1.
      Google Light turned on. The brightness level is 2.


11. Try this challenge
----------------------

   -  In the ``SmartDevice`` class, define a ``printDeviceInfo()`` method that prints a ``"Device``
      ``name:`` ``$name,`` ``category:`` ``$category,`` ``type:`` ``$deviceType"`` string.
   -  In the ``SmartTvDevice`` class, define a ``decreaseVolume()`` method that decreases the volume
      and a ``previousChannel()`` method that navigates to the previous channel.
   -  In the ``SmartLightDevice`` class, define a ``decreaseBrightness()`` method that decreases the
      brightness.
   -  In the ``SmartHome`` class, ensure that all actions can only be performed when each device's
      ``deviceStatus`` property is set to an ``"on"`` string. Also, ensure that the
      ``deviceTurnOnCount`` property is updated correctly.

   After you're done with the implementation:

   -  In the ``SmartHome`` class, define an ``decreaseTvVolume()``, ``changeTvChannelToPrevious()``,
      ``printSmartTvInfo()``, ``printSmartLightInfo()``, and ``decreaseLightBrightness()`` method.
   -  Call the appropriate methods from the ``SmartTvDevice`` and ``SmartLightDevice`` classes in
      the ``SmartHome`` class.
   -  In the ``main()`` function, call these added methods to test them.


12. Conclusion
--------------

   Congratulations! You learned how to define classes and instantiate objects. You also learned how
   to create relations between classes and create property delegates.


**Summary**

   -  There are four main principles of OOP: encapsulation, abstraction, inheritance, and
      polymorphism.
   -  Classes are defined with the ``class`` keyword, and contain properties and methods.
   -  Properties are similar to variables except properties can have custom getters and setters.
   -  A constructor specifies how to instantiate objects of a class.
   -  You can omit the ``constructor`` keyword when you define a primary constructor.
   -  Inheritance makes it easier to reuse code.
   -  The IS-A relationship refers to inheritance.
   -  The HAS-A relationship refers to composition.
   -  Visibility modifiers play an important role in the achievement of encapsulation.
   -  Kotlin provides four visibility modifiers: the ``public``, ``private``, ``protected``, and
      ``internal`` modifiers.
   -  A property delegate lets you reuse the getter and setter code in multiple classes.


Learn **more**

   -  `Built-in Delegates <https://medium.com/androiddevelopers/built-in-delegates-4811947e781f>`__


â­ Use function types and lambda expressions in Kotlin
=======================================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-function-types-and-lambda


1. Introduction
---------------

   This codelab teaches you about function types, how to use function types, and syntax specific to
   lambda expressions.

   In Kotlin, functions are considered first-class constructs. This means that functions can be
   treated as a data type. You can store functions in variables, pass them to other functions as
   arguments, and return them from other functions.

   Like other data types that you can express with literal valuesâ€”such as an ``Int`` type of a
   ``10`` value and a ``String`` type of a ``"Hello"`` valueâ€”you can also declare function literals,
   which are called lambda expressions or lambdas for short. You use lambda expressions extensively
   in Android development and more generally in Kotlin programming.


Prerequisites

   -  Familiarity with Kotlin programming, including functions, ``if/else`` statements, and
      nullability


What you'll learn

   -  How to define a function with lambda syntax.
   -  How to store functions in variables.
   -  How to pass functions as arguments to other functions.
   -  How to return functions from other functions.
   -  How to use nullable function types.
   -  How to make lambda expressions more concise.
   -  What a higher-order function is.
   -  How to use the ``repeat()`` function.


What you'll need

   -  A web browser with access to Kotlin Playground


2. Watch the code-along video (Optional)
----------------------------------------

   If you'd like to watch one of the course instructors complete the codelab, play the below video.

   It's recommended to expand the video to full screen (with this icon |This symbol shows 4 corners
   on a square highlighted, to indicate full screen mode.| in the corner of the video) so you can
   see the Kotlin Playground and the code more clearly.

   This step is optional. You can also skip the video and start the codelab instructions right away.

   .. image:: https://googledownloads.cn/cn-devsite/nG0e9OjVGDQ.mp4


3. Store a function in a variable
---------------------------------

   So far, you learned how to declare functions with the ``fun`` keyword. A function declared with
   the ``fun`` keyword can be called, which causes the code in the function body to execute.

   As a first-class construct, functions are also data types, so you can store functions in
   variables, pass them to functions, and return them from functions. Perhaps you want the ability
   to change the behavior of a piece of your app at runtime or nest composable functions to build
   layouts like you did in previous codelabs. All this is made possible by lambda expressions.

   You can see this in action with some `trick-or-treating <https://en.wikipedia.org/wiki/Trick-or-treating>`__, 
   which refers to the Halloween tradition in many countries during which children dressed in 
   costumes go from door to door and ask, "Trick or treat," usually in exchange for candy.

   Store a function in a variable:

   1. Navigate to `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__.
   2. After the ``main()`` function, define a ``trick()`` function with no parameters and no return
      value that prints ``"No treats!"``. The syntax is the same as that of other functions that you
      saw in previous codelabs.

   .. code:: prettyprint

      fun main() {
          
      }

      fun trick() {
          println("No treats!")
      }

   3. In the body of the ``main()`` function, create a variable called ``trickFunction`` and set it
      equal to ``trick``. You don't include the parentheses after ``trick`` because you want to
      store the function in a variable, not call the function.

   .. code:: prettyprint

      fun main() {
          val trickFunction = trick
      }

      fun trick() {
          println("No treats!")
      }

   4. Run your code. It produces an error because the Kotlin compiler recognizes ``trick`` as the
      name of the ``trick()`` function, but expects you to call the function, rather than assign it
      to a variable.

   ::

      Function invocation 'trick()' expected

   You tried to store ``trick`` in the ``trickFunction`` variable. However, to refer to a function
   as a value, you need to use the function reference operator (``::``). The syntax is illustrated
   in this image:

   ::

        â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      ::â”‚ function name â”‚
        â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   5. To refer to the function as a value, reassign ``trickFunction`` to ``::trick``.

   .. code:: prettyprint

      fun main() {
          val trickFunction = ::trick
      }

      fun trick() {
          println("No treats!")
      }

   6. Run your code to verify that there are no more errors. You see a warning that
      ``trickFunction`` is never used, but that's fixed in the next section.


Redefine the function with a lambda expression
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Lambda expressions provide a concise syntax to define a function without the ``fun`` keyword. You
   can store a lambda expression directly in a variable without a function reference on another
   function.

   Before the assignment operator (``=``), you add the ``val`` or ``var`` keyword followed by the
   name of the variable, which is what you use when you call the function. After the assignment
   operator (``=``) is the lambda expression, which consists of a pair of curly braces that form the
   function body. The syntax is illustrated in this image:

   ::

          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      val â”‚  variable name â”‚ { 
          â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ function body â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   When you define a function with a lambda expression, you have a variable that refers to the
   function. You can also assign its value to other variables like any other type and call the
   function with the new variable's name.

   Update the code to use a lambda expression:

   1. Rewrite the ``trick()`` function with a lambda expression. The name ``trick`` now refers to
      the name of a variable. The function body in the curly braces is now a lambda expression.

   .. code:: prettyprint

      fun main() {
          val trickFunction = ::trick
      }

      val trick = {
          println("No treats!")
      }

   2. In the ``main()`` function, remove the function reference operator (``::``) because ``trick``
      now refers to a variable, rather than a function name.

   .. code:: prettyprint

      fun main() {
          val trickFunction = trick
      }

      val trick = {
          println("No treats!")
      }

   3. Run your code. There are no errors and you can refer to the ``trick()`` function without the
      function reference operator (``::``). There's no output because you still haven't called the
      function.

   4. In the ``main()`` function, call the ``trick()`` function, but this time include the
      parentheses like you'd do when you call any other function.

   .. code:: prettyprint

      fun main() {
          val trickFunction = trick
          trick()
      }

      val trick = {
          println("No treats!")
      }

   5. Run your code. The body of the lambda expression is executed.

   ::

      No treats!

   6. In the ``main()`` function, call the ``trickFunction`` variable as if it were a function.

   .. code:: prettyprint

      fun main() {
          val trickFunction = trick
          trick()
          trickFunction()
      }

      val trick = {
          println("No treats!")
      }

   7. Run your code. The function is called twice, once for the ``trick()``\ function call and a
      second time for the ``trickFunction()`` function call.

   ::

      No treats!
      No treats!

   With lambda expressions, you can create variables that store functions, call these variables like
   functions, and store them in other variables that you can call like functions.


4. Use functions as a data type
-------------------------------

   You learned in a previous codelab that Kotlin has type inference. When you declare a variable,
   you often don't need to explicitly specify the type. In the previous example, the Kotlin compiler
   was able to infer that the value of ``trick`` was a function. However, if you want to specify the
   type of a function parameter or a return type, you need to know the syntax for expressing
   function types. Function types consist of a set of parentheses that contain an optional parameter
   list, the ``->`` symbol, and a return type. The syntax is illustrated in this image:


   ::

       â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      (â”‚ parameters (optional) â”‚ ) -> â”‚ return type â”‚ 
       â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   The data type of the ``trick`` variable that you declared earlier would be ``() -> Unit``. The
   parentheses are empty because the function doesn't have any parameters. The return type is
   ``Unit`` because the function doesn't return anything. If you had a function that took two
   ``Int`` parameters and returned an ``Int``, its data type would be ``(Int, Int) -> Int``.

   Declare another function with a lambda expression that explicitly specifies the function's type:

   1. After the ``trick`` variable, declare a variable called ``treat`` equal to a lambda expression
      with a body that prints ``"Have a treat!"``.

   .. code:: prettyprint

      val trick = {
          println("No treats!")
      }

      val treat = {
          println("Have a treat!")
      }

   2. Specify the ``treat`` variable's data type as ``() -> Unit``.

   .. code:: prettyprint

      val treat: () -> Unit = {
          println("Have a treat!")
      }

   3. In the ``main()`` function, call the ``treat()`` function.

   .. code:: prettyprint

      fun main() {
          val trickFunction = trick
          trick()
          trickFunction()
          treat()
      }

   4. Run the code. The ``treat()`` function behaves like the ``trick()`` function. Both variables
      have the same data type even though only the ``treat`` variable declares it explicitly.

   ::

      No treats!
      No treats!
      Have a treat!


Use a function as a return type
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A function is a data type, so you can use it like any other data type. You can even return
   functions from other functions. The syntax is illustrated in this image:

   ::

            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®       â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      func  â”‚ function name â”‚ ( ) : â”‚ function type â”‚ { 
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯       â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         // code
                â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         return â”‚ Name of another function â”‚
                â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   Create a function that returns a function.

   1. Delete the code from the ``main()`` function.

   .. code:: prettyprint

      fun main() {
          
      }

   2. After the ``main()`` function, define a ``trickOrTreat()`` function that accepts an
      ``isTrick`` parameter of type ``Boolean``.

   .. code:: prettyprint

      fun main() {
          
      }

      fun trickOrTreat(isTrick: Boolean): () -> Unit {
      }

      val trick = {
          println("No treats!")
      }

      val treat = {
          println("Have a treat!")
      }

   3. In the body of the ``trickOrTreat()`` function, add an ``if`` statement that returns the
      ``trick()`` function if ``isTrick`` is ``true`` and returns the ``treat()`` function if
      ``isTrick`` is false.

   .. code:: prettyprint

      fun trickOrTreat(isTrick: Boolean): () -> Unit {
          if (isTrick) {
              return trick
          } else {
              return treat
          }
      }

   4. In the ``main()`` function, create a variable called ``treatFunction`` and assign it to the
      result of calling ``trickOrTreat()``, passing in ``false`` for the ``isTrick`` parameter.
      Then, create a second variable, called ``trickFunction``, and assign it to the result of
      calling ``trickOrTreat()``, this time passing in ``true`` for the ``isTrick`` parameter.

   .. code:: prettyprint

      fun main() {
          val treatFunction = trickOrTreat(false)
          val trickFunction = trickOrTreat(true)
      }

   5. Call the ``treatFunction()`` and then call the ``trickFunction()`` on the next line.

   .. code:: prettyprint

      fun main() {
          val treatFunction = trickOrTreat(false)
          val trickFunction = trickOrTreat(true)
          treatFunction()
          trickFunction()
      }

   6. Run your code. You should see the output for each function. Even though you didn't call the
      ``trick()`` or ``treat()`` functions directly, you could still call them because you stored
      the return values from each time you called the ``trickOrTreat()`` function, and called the
      functions with the ``trickFunction`` and ``treatFunction`` variables.

   ::

      Have a treat!
      No treats!

   Now you know how functions can return other functions. You can also pass a function as an
   argument to another function. Perhaps you want to provide some custom behavior to the
   ``trickOrTreat()`` function to do something other than return either of the two strings. A
   function that takes another function as an argument lets you pass in a different function each
   time that it's called.


**Pass a function to another function as an argument**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In some parts of the world that celebrate Halloween, children receive spare change instead of
   candy or they receive both. You'll modify your ``trickOrTreat()`` function to allow an additional
   treat represented by a function to be provided as an argument.

   The function that ``trickOrTreat()`` uses as a parameter also needs to take a parameter of its
   own. When declaring function types, the parameters aren't labeled. You only need to specify the
   data types of each parameter, separated by a comma. The syntax is illustrated in this image:


   ::

      Parameters (types only)
                â”‚
            â•­â”€â”€â”€â”´â”€â”€â•®
         (String, Int) -> Int

   When you write a lambda expression for a function that takes a parameter, the parameters are
   given names in the order that they occur. Parameter names are listed after the opening curly
   braces and each name is separated by a comma. An arrow (``->``) separates the parameter names
   from the function body. The syntax is illustrated in this image:

   ::

          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
      val â”‚ function name â”‚ = { â”‚ parameters 1 â”‚, â”‚ parameters 2 â”‚ -> 
          â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ function body â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }


   Update the ``trickOrTreat()`` function to take a function as a parameter:

   1. After the ``isTrick`` parameter, add an ``extraTreat`` parameter of type ``(Int) -> String``.

   .. code:: prettyprint

      fun trickOrTreat(isTrick: Boolean, extraTreat: (Int) -> String): () -> Unit {

   2. In the ``else`` block, before the ``return`` statement, call ``println()``, passing in a call
      to the ``extraTreat()`` function. Pass ``5`` into the call to ``extraTreat()``.

   .. code:: prettyprint

      fun trickOrTreat(isTrick: Boolean, extraTreat: (Int) -> String): () -> Unit {
          if (isTrick) {
              return trick
          } else {
              println(extraTreat(5))
              return treat
          }
      }

   3. Now when you call the ``trickOrTreat()`` function, you need to define a function with a lambda
      expression and pass it in for the ``extraTreat`` parameter. In the ``main()``\ function before
      the calls to the ``trickOrTreat()`` function, add a ``coins()`` function. The ``coins()``
      function gives the ``Int`` parameter the name ``quantity`` and returns a ``String``. You may
      notice the absence of the ``return`` keyword, which can't be used in lambda expressions.
      Instead, the result of the last expression in the function becomes the return value.

   .. code:: prettyprint

      fun main() {
          val coins: (Int) -> String = { quantity ->
              "$quantity quarters"
          }
          
          val treatFunction = trickOrTreat(false)
          val trickFunction = trickOrTreat(true)
          treatFunction()
          trickFunction()
      }

   4. After the ``coins()`` function, add a ``cupcake()`` function as shown. Name the ``Int``
      parameter ``quantity`` and separate it from the function body using the ``->`` operator. Now
      you can pass either the ``coins()`` or ``cupcake()`` function into the ``trickOrTreat()``
      function.

   .. code:: prettyprint

      fun main() {
          val coins: (Int) -> String = { quantity ->
              "$quantity quarters"
          }

          val cupcake: (Int) -> String = { quantity ->
              "Have a cupcake!"
          }

          val treatFunction = trickOrTreat(false)
          val trickFunction = trickOrTreat(true)
          treatFunction()
          trickFunction()
      }

   5. In the ``cupcake()`` function, remove the ``quantity`` parameter and the ``->`` symbol.
      They're not used, so you can omit them.

   .. code:: prettyprint

      val cupcake: (Int) -> String = {
          "Have a cupcake!"
      }

   **Note:** In the ``coins()`` function, the ``Int`` parameter is named ``quantity``. However, it
   could be named anything as long as the parameter name and the variable name in the string are the
   same.

   6. Update the calls to the ``trickOrTreat()`` function. For the first call, when ``isTrick`` is
      ``false``, pass in the ``coins()`` function. For the second call, when ``isTrick`` is
      ``true``, pass in the ``cupcake()`` function.

   .. code:: prettyprint

      fun main() {
          val coins: (Int) -> String = { quantity ->
              "$quantity quarters"
          }

          val cupcake: (Int) -> String = {
              "Have a cupcake!"
          }

          val treatFunction = trickOrTreat(false, coins)
          val trickFunction = trickOrTreat(true, cupcake)
          treatFunction()
          trickFunction()
      }

   7. Run your code. The ``extraTreat()`` function is only called when the ``isTrick`` parameter is
      set to a ``false`` argument, so the output includes 5 quarters, but no cupcakes.

   ::

      5 quarters
      Have a treat!
      No treats!


Nullable function types
~~~~~~~~~~~~~~~~~~~~~~~

   Like other data types, function types can be declared as nullable. In these cases, a variable
   could contain a function or it could be ``null``.

   To declare a function as nullable, surround the function type in parentheses followed by a ``?``
   symbol outside the ending parenthesis. For example, if you want to make the ``() -> String`` type
   nullable, declare it as a ``(() -> String)?`` type. The syntax is illustrated in this image:

   ::

          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      ( ( â”‚ parameters (optional) â”‚ ) -> â”‚ return type â”‚ ) ?
          â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   Make the ``extraTreat`` parameter nullable so that you don't have to provide an ``extraTreat()``
   function every time that you call the ``trickOrTreat()`` function:

   1. Change the ``extraTreat`` parameter's type to ``(() -> String)?``.

   .. code:: prettyprint

      fun trickOrTreat(isTrick: Boolean, extraTreat: ((Int) -> String)?): () -> Unit {

   2. Modify the call to the ``extraTreat()`` function to use an ``if`` statement to only call the
      function if it's non-null. The ``trickOrTreat()`` function should now look like this code
      snippet:

   .. code:: prettyprint

      fun trickOrTreat(isTrick: Boolean, extraTreat: ((Int) -> String)?): () -> Unit {
          if (isTrick) {
              return trick
          } else {
              if (extraTreat != null) {
                  println(extraTreat(5))
              }
              return treat
          }
      }

   3. Remove the ``cupcake()`` function and then replace the ``cupcake`` argument with ``null`` in
      the second call to the ``trickOrTreat()`` function.

   .. code:: prettyprint

      fun main() {
          val coins: (Int) -> String = { quantity ->
              "$quantity quarters"
          }

          val treatFunction = trickOrTreat(false, coins)
          val trickFunction = trickOrTreat(true, null)
          treatFunction()
          trickFunction()
      }

   4. Run your code. The output should be unchanged. Now that you can declare function types as
      nullable, you no longer need to pass in a function for the ``extraTreat`` parameter.

   ::

      5 quarters
      Have a treat!
      No treats!


5. Write lambda expressions with shorthand syntax
-------------------------------------------------

   Lambda expressions provide a variety of ways to make your code more concise. You explore a few of
   them in this section because most of the lambda expressions that you encounter and write are
   written with shorthand syntax.


Omit parameter name
~~~~~~~~~~~~~~~~~~~

   When you wrote the ``coins()`` function, you explicitly declared the name ``quantity`` for the
   function's ``Int`` parameter. However, as you saw with the ``cupcake()`` function, you can omit
   the parameter name entirely. When a function has a single parameter and you don't provide a name,
   Kotlin implicitly assigns it the ``it`` name, so you can omit the parameter name and ``->``
   symbol, which makes your lambda expressions more concise. The syntax is illustrated in this
   image:

   ::

                                         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
          val coins: (Int) -> String = { â”‚ quantity â”‚ ->
                                         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
              "$quantity quarters"
          }
                           â”‚
                           â”‚
                           v

          val coins: (Int) -> String = {
                                        
              "$it quarters"
          }


   Update the ``coins()`` function to use the shorthand syntax for parameters:

   1. In the ``coins()`` function, remove the ``quantity`` parameter name and ``->`` symbol.

   .. code:: prettyprint

      val coins: (Int) -> String = {
          "$quantity quarters"
      }

   2. Change the ``"$quantity quarters"`` string template to refer to the single parameter using
      ``$it``.

   .. code:: prettyprint

      val coins: (Int) -> String = {
          "$it quarters"
      }

   3. Run your code. Kotlin recognizes the ``it`` parameter name of the ``Int`` parameter and still
      prints the number of quarters.

   ::

      5 quarters
      Have a treat!
      No treats!


Pass a lambda expression directly into a function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The ``coins()`` function is currently only used in one place. What if you could simply pass a
   lambda expression directly into the ``trickOrTreat()`` function without the need to first create
   a variable?

   Lambda expressions are simply function literals, just like ``0`` is an integer literal or
   ``"Hello"`` is a string literal. You can pass a lambda expression directly into a function call.
   The syntax is illustrated in this image:

   ::

                     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         var coins = â”‚ Lambda expression â”‚
                     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         trickOrTreat(false, coins)
                                       â”‚
                                       â”‚
                                       v
                              â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         trickOrTreat (false, â”‚ Lambda expression â”‚)
                              â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   Modify the code so that you can remove the ``coins`` variable:

   1. Move the lambda expression so that it's passed directly into the call to the
      ``trickOrTreat()`` function. You can also condense the lambda expression to a single line.

   .. code:: prettyprint

      fun main() {
          val coins: (Int) -> String = {
              "$it quarters"
          }
          val treatFunction = trickOrTreat(false, { "$it quarters" })
          val trickFunction = trickOrTreat(true, null)
          treatFunction()
          trickFunction()
      }

   2. Remove the ``coins`` variable because it's no longer being used.

   .. code:: prettyprint

      fun main() {
          val treatFunction = trickOrTreat(false, { "$it quarters" })
          val trickFunction = trickOrTreat(true, null)
          treatFunction()
          trickFunction()
      }

   3. Run the code. It still compiles and runs as expected.

   ::

      5 quarters
      Have a treat!
      No treats!


**Use trailing lambda syntax**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   You can use another shorthand option to write lambdas when a function type is the last parameter
   of a function. If so, you can place the lambda expression after the closing parenthesis to call
   the function. The syntax is illustrated in this image:

   ::

                             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         trickOrTreat(false, â”‚ Lambda expression â”‚
                             â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                       â”‚
                                       â”‚
                                       v
                              â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         trickOrTreat (false) â”‚ Lambda expression â”‚
                              â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   This makes your code more readable because it separates the lambda expression from the other
   parameters, but doesn't change what the code does.

   Update the code to use trailing lambda syntax:

   1. In the ``treatFunction`` variable, move the lambda expression ``{"$it quarters"}`` after the
      closing parenthesis in the call to ``trickOrTreat()``.

   .. code:: prettyprint

      val treatFunction = trickOrTreat(false) { "$it quarters" }

   2. Run your code. Everything still works!

   ::

      5 quarters
      Have a treat!
      No treats!

   **Note:** The composable functions that you used to declare your UI take functions as parameters
   and are typically called using trailing lambda syntax.


6. Use the repeat() function
----------------------------

   When a function returns a function *or* takes a function as an argument, it's called a
   higher-order function. The ``trickOrTreat()`` function is an example of a higher-order function
   because it takes a function of ``((Int) -> String)?`` type as a parameter and returns a function
   of ``() -> Unit`` type. Kotlin provides several useful higher-order functions, which you can take
   advantage of with your newfound knowledge of lambdas.

   The ```repeat()`` <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html>`__ function
   is one such higher-order function. The ``repeat()`` function is a concise way to express a
   ``for`` loop with functions. You use this and other higher-order functions frequently in later
   units. The ``repeat()`` function has this function signature:

   .. code:: prettyprint

      repeat(times: Int, action: (Int) -> Unit)

   The ``times`` parameter is the number of times that the action should happen. The ``action``
   parameter is a function that takes a single ``Int`` parameter and returns a ``Unit`` type. The
   ``action`` function's ``Int`` parameter is the number of times that the action has executed so
   far, such as a ``0`` argument for the first iteration or a ``1`` argument for the second
   iteration. You can use the ``repeat()`` function to repeat code a specified number of times,
   similar to a ``for`` loop. The syntax is illustrated in this image:


   ::

               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â•®
         for ( â”‚ iteration â”‚ in â”‚ start â”‚ .. â”‚ end â”‚ ) {
               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â•¯
            // code
         }
                                       â”‚
                                       â”‚
                                       v

                  â•­â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         repeat ( â”‚ items â”‚ ) { â”‚ iteration â”‚ ->
                  â•°â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
            // code
         }


   Instead of calling the ``trickFunction()`` function only once, you can call it multiple times
   with the ``repeat()`` function.

   Update your trick-or-treating code to see the ``repeat()`` function in action:

   1. In the ``main()`` function, call the ``repeat()`` function in-between the calls to
      ``treatFunction()`` and ``trickFunction()``. Pass in ``4`` for the ``times`` parameter and use
      trailing lambda syntax for the ``action`` function. You don't need to provide a name for the
      lambda expression's ``Int`` parameter.

   .. code:: prettyprint

      fun main() {
          val treatFunction = trickOrTreat(false) { "$it quarters" }
          val trickFunction = trickOrTreat(true, null)
          treatFunction()
          trickFunction()
          repeat(4) {
              
          }
      }

   2. Move the call to the ``treatFunction()`` function into the ``repeat()`` function's lambda
      expression.

   .. code:: prettyprint

      fun main() {
          val treatFunction = trickOrTreat(false) { "$it quarters" }
          val trickFunction = trickOrTreat(true, null)
          repeat(4) {
              treatFunction()
          }
          trickFunction()
      }

   3. Run your code. The ``"Have a treat"`` string should print four times.

   ::

      5 quarters
      Have a treat!
      Have a treat!
      Have a treat!
      Have a treat!
      No treats!


7. Conclusion
-------------

   Congratulations! You learned the basics of function types and lambda expressions. Familiarity
   with these concepts helps you as you learn more about the Kotlin language. The use of function
   types, higher-order functions, and shorthand syntax also makes your code more concise and easier
   to read.


**Summary**

   -  Functions in Kotlin are first-class constructs and can be treated like data types.
   -  Lambda expressions provide a shorthand syntax to write functions.
   -  You can pass function types into other functions.
   -  You can return a function type from another function.
   -  A lambda expression returns the value of the last expression.
   -  If a parameter label is omitted in a lambda expression with a single parameter, it's referred
      to with the ``it`` identifier.
   -  Lambdas can be written inline without a variable name.
   -  If a function's last parameter is a function type, you can use trailing lambda syntax to move
      the lambda expression after the last parenthesis when you call a function.
   -  Higher-order functions are functions that take other functions as parameters or return a
      function.
   -  The ``repeat()`` function is a higher-order function that works similarly to a ``for`` loop.


**Learn more**

   -  `High-order functions and lambdas <https://kotlinlang.org/docs/lambdas.html>`__


â­ Practice: Kotlin Fundamentals
=================================


1. Before you begin
-------------------

   Now that you put in the hard work to learn the basics of Kotlin programming, it's time to put
   what you learned into practice.

   These exercises test your understanding of the concepts that you studied. They're based on
   real-world use cases, some of which you probably encountered before as a user.

   Follow the instructions to find a solution for each exercise in `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__. 
   If you get stuck, some exercises have hints that can help you. The solution code for 
   each exercise is available at the end, but it's recommended that you solve the 
   exercises before you check your answers.

   Work through the exercises at a pace that's comfortable for you. There are duration estimates for
   the exercises, but they're only estimates, so you don't have to adhere to them. Take as much time
   as you need to solve each problem thoughtfully. The solutions are only one way to solve the
   exercises, so feel free to experiment however you feel comfortable.


Prerequisites

   -  Familiarity with the `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__
   -  Ability to define and call functions.
   -  Knowledge of Kotlin programming basics, including variables, and the ``println()`` and
      ``main()`` functions.
   -  Familiarity with Kotlin conditionals, including ``if/else`` and ``when`` statements and
      expressions
   -  Familiarity with Kotlin lambda expressions
   -  Knowledge of how to handle nullable variables.
   -  Knowledge of how to create Kotlin classes and objects.
   -  Completion of the `Write conditionals in Kotlin <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-conditionals#0>`__,
      `Use nullability in Kotlin <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-nullability#0>`__,
      `Use classes and objects in Kotlin <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-classes-and-objects#0>`__,
      and `Use function types and lambda expressions in Kotlin <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-function-types-and-lambda#0>`__
      codelabs.


What you'll need

   -  Kotlin Playground


2. Mobile notifications
-----------------------

   Typically, your phone provides you with a summary of notifications.

   In the initial code provided in the following code snippet, write a program that prints the
   summary message based on the number of notifications that you received. The message should
   include:

   -  The exact number of notifications when there are less than 100 notifications.
   -  ``99+`` as the number of notifications when there are 100 notifications or more.

   .. code:: prettyprint

      fun main() {
          val morningNotification = 51
          val eveningNotification = 135
          
          printNotificationSummary(morningNotification)
          printNotificationSummary(eveningNotification)
      }


      fun printNotificationSummary(numberOfMessages: Int) {
          // Fill in the code.
      }

   Complete the ``printNotificationSummary()`` function so that the program prints these lines:

   ::

      You have 51 notifications.
      Your phone is blowing up! You have 99+ notifications.


3. Movie-ticket price
---------------------

   Movie tickets are typically priced differently based on the age of moviegoers.

   In the initial code provided in the following code snippet, write a program that calculates these
   age-based ticket prices:

   -  A children's ticket price of $15 for people 12 years old or younger.
   -  A standard ticket price of $30 for people between 13 and 60 years old. On Mondays, discount
      the standard ticket price to $25 for this same age group.
   -  A senior ticket price of $20 for people 61 years old and older. Assume that the maximum age of
      a moviegoer is 100 years old.
   -  A ``-1`` value to indicate that the price is invalid when a user inputs an age outside of the
      age specifications.

   .. code:: prettyprint

      fun main() {
          val child = 5
          val adult = 28
          val senior = 87
          
          val isMonday = true
          
          println("The movie ticket price for a person aged $child is \$${ticketPrice(child, isMonday)}.")
          println("The movie ticket price for a person aged $adult is \$${ticketPrice(adult, isMonday)}.")
          println("The movie ticket price for a person aged $senior is \$${ticketPrice(senior, isMonday)}.")
      }

      fun ticketPrice(age: Int, isMonday: Boolean): Int {
          // Fill in the code.
      }

   Complete the ``ticketPrice()`` function so that the program prints these lines:

   ::

      The movie ticket price for a person aged 5 is $15.
      The movie ticket price for a person aged 28 is $25.
      The movie ticket price for a person aged 87 is $20.


4. Temperature converter
------------------------

   There are three main temperature scales used in the world: Celsius, Fahrenheit, and Kelvin.

   In the initial code provided in the following code snippet, write a program that converts a
   temperature from one scale to another with these formulas:

   -  Celsius to Fahrenheit: Â°F = 9/5 (Â°C) + 32
   -  Kelvin to Celsius:     Â°C = K - 273.15
   -  Fahrenheit to Kelvin:  K = 5/9 (Â°F - 32) + 273.15

   Note that the ``String.format("%.2f", /* measurement */ )`` method is used to convert a number
   into a ``String`` type with 2 decimal places.

   .. code:: prettyprint

      fun main() {
          // Fill in the code.
      }


      fun printFinalTemperature(
          initialMeasurement: Double, 
          initialUnit: String, 
          finalUnit: String, 
          conversionFormula: (Double) -> Double
      ) {
          val finalMeasurement = String.format("%.2f", conversionFormula(initialMeasurement)) // two decimal places
          println("$initialMeasurement degrees $initialUnit is $finalMeasurement degrees $finalUnit.")
      }

   Complete the ``main()`` function so that it calls the ``printFinalTemperature()`` function and
   prints the following lines. You need to pass arguments for the temperature and conversion
   formula. *Hint:* you may want to use ``Double`` values to avoid ``Integer`` truncation during
   division operations.

   ::

      27.0 degrees Celsius is 80.60 degrees Fahrenheit.
      350.0 degrees Kelvin is 76.85 degrees Celsius.
      10.0 degrees Fahrenheit is 260.93 degrees Kelvin.


5. Song catalog
---------------

   Imagine that you need to create a music-player app.

   Create a class that can represent the structure of a song. The ``Song`` class must include these
   code elements:

   -  Properties for the title, artist, year published, and play count
   -  A property that indicates whether the song is popular. If the play count is less than 1,000,
      consider it unpopular.
   -  A method that prints a song description in this format:

   "[Title], performed by [artist], was released in [year published]."


6. Internet profile
-------------------

   Oftentimes, you're required to complete profiles for online websites that contain mandatory and
   non-mandatory fields. For example, you can add your personal information and link to other people
   who referred you to sign up for the profile.

   In the initial code provided in the following code snippet, write a program which prints out a
   person's profile details.

   .. code:: prettyprint

      fun main() {    
          val amanda = Person("Amanda", 33, "play tennis", null)
          val atiqah = Person("Atiqah", 28, "climb", amanda)
          
          amanda.showProfile()
          atiqah.showProfile()
      }


      class Person(val name: String, val age: Int, val hobby: String?, val referrer: Person?) {
          fun showProfile() {
             // Fill in code 
          }
      }

   Complete the ``showProfile()`` function so that the program prints these lines:

   ::

      Name: Amanda
      Age: 33
      Likes to play tennis. Doesn't have a referrer.

      Name: Atiqah
      Age: 28
      Likes to climb. Has a referrer named Amanda, who likes to play tennis.


7. Foldable phones
------------------

   Typically, a phone screen turns on and off when the power button is pressed. In contrast, if a
   foldable phone is folded, the main inner screen on a foldable phone doesn't turn on when the
   power button is pressed.

   In the initial code provided in the following code snippet, write a ``FoldablePhone`` class that
   inherits from the ``Phone`` class. It should contain the following:

   -  A property that indicates whether the phone is folded.
   -  A different ``switchOn()`` function behavior than the ``Phone`` class so that it only turns
      the screen on when the phone isn't folded.
   -  Methods to change the folding state.

   .. code:: prettyprint

      class Phone(var isScreenLightOn: Boolean = false){
          fun switchOn() {
              isScreenLightOn = true
          }
          
          fun switchOff() {
              isScreenLightOn = false
          }
          
          fun checkPhoneScreenLight() {
              val phoneScreenLight = if (isScreenLightOn) "on" else "off"
              println("The phone screen's light is $phoneScreenLight.")
          }
      }


8. Special auction
------------------

   Typically in an auction, the highest bidder determines the price of an item. In this special
   auction, if there's no bidder for an item, the item is automatically sold to the auction house at
   the minimum price.

   In the initial code provided in the following code snippet, you're given an ``auctionPrice()``
   function that accepts a nullable ``Bid?`` type as an argument:

   .. code:: prettyprint

      fun main() {
          val winningBid = Bid(5000, "Private Collector")
          
          println("Item A is sold at ${auctionPrice(winningBid, 2000)}.")
          println("Item B is sold at ${auctionPrice(null, 3000)}.")
      }

      class Bid(val amount: Int, val bidder: String)
       
      fun auctionPrice(bid: Bid?, minimumPrice: Int): Int {
         // Fill in the code.
      }

   Complete the ``auctionPrice()`` function so that the program prints these lines:

   ::

      Item A is sold at 5000.
      Item B is sold at 3000.


9. Solution code
----------------


Mobile notifications

   The solution uses an ``if/else`` statement to print the appropriate notification summary message
   based on the number of notification messages received:

   .. code:: prettyprint

      fun main() {
          val morningNotification = 51
          val eveningNotification = 135
          
          printNotificationSummary(morningNotification)
          printNotificationSummary(eveningNotification)
      }


      fun printNotificationSummary(numberOfMessages: Int) {
          if (numberOfMessages < 100) {
              println("You have ${numberOfMessages} notifications.")
          } else {
              println("Your phone is blowing up! You have 99+ notifications.")
          }
      }


**Movie-ticket price**

   The solution uses a ``when`` expression to return the appropriate ticket price based on the
   moviegoer's age. It also uses a simple ``if/else`` expression for one of the ``when``
   expression's branches to add the additional condition for the standard ticket pricing.

   The ticket price in the ``else`` branch returns a ``-1`` value, which indicates that the price
   set is invalid for the ``else`` branch. A better implementation is for the ``else`` branch to
   throw an exception. You learn about exception handling in future units.

   .. code:: prettyprint

      fun main() {
          val child = 5
          val adult = 28
          val senior = 87
          
          val isMonday = true
          
          println("The movie ticket price for a person aged $child is \$${ticketPrice(child, isMonday)}.")
          println("The movie ticket price for a person aged $adult is \$${ticketPrice(adult, isMonday)}.")
          println("The movie ticket price for a person aged $senior is \$${ticketPrice(senior, isMonday)}.")
      }
       
      fun ticketPrice(age: Int, isMonday: Boolean): Int {
          return when(age) {
              in 0..12 -> 15
              in 13..60 -> if (isMonday) 25 else 30
              in 61..100 -> 20
              else -> -1
          }
      }


**Temperature converter**

   The solution requires you to pass a function as a parameter to the ``printFinalTemperature()``
   function. The most succinct solution passes lambda expressions as the arguments, uses the ``it``
   parameter reference in place of the parameter names, and makes use of trailing lambda syntax.

   .. code:: prettyprint

      fun main() {    
              printFinalTemperature(27.0, "Celsius", "Fahrenheit") { 9.0 / 5.0 * it + 32 }
              printFinalTemperature(350.0, "Kelvin", "Celsius") { it - 273.15 }
              printFinalTemperature(10.0, "Fahrenheit", "Kelvin") { 5.0 / 9.0 * (it - 32) + 273.15 }
      }


      fun printFinalTemperature(
          initialMeasurement: Double, 
          initialUnit: String, 
          finalUnit: String, 
          conversionFormula: (Double) -> Double
      ) {
          val finalMeasurement = String.format("%.2f", conversionFormula(initialMeasurement)) // two decimal places
          println("$initialMeasurement degrees $initialUnit is $finalMeasurement degrees $finalUnit.")
      }


**Song catalog**

   The solution contains a ``Song`` class with a default constructor that accepts all required
   parameters. The ``Song`` class also has an ``isPopular`` property that uses a custom getter
   function, and a method that prints the description of itself. You can create an instance of the
   class in the ``main()`` function and call its methods to test whether the implementation is
   correct. You can use underscores when writing large numbers such as the ``1_000_000`` value to
   make it more readable.

   .. code:: prettyprint

      fun main() {    
          val brunoSong = Song("We Don't Talk About Bruno", "Encanto Cast", 2022, 1_000_000)
          brunoSong.printDescription()
          println(brunoSong.isPopular)
      }


      class Song(
          val title: String, 
          val artist: String, 
          val yearPublished: Int, 
          val playCount: Int
      ){
          val isPopular: Boolean
              get() = playCount >= 1000

          fun printDescription() {
              println("$title, performed by $artist, was released in $yearPublished.")
          }   
      }

   When you call the ``println()`` function on the instance's methods, the program may print this
   output:

   ::

      We Don't Talk About Bruno, performed by Encanto Cast, was released in 2022.
      true


**Internet profile**

   The solution contains null checks in various ``if/else`` statements to print different text based
   on whether various class properties are ``null``:

   .. code:: prettyprint

      fun main() {    
          val amanda = Person("Amanda", 33, "play tennis", null)
          val atiqah = Person("Atiqah", 28, "climb", amanda)
          
          amanda.showProfile()
          atiqah.showProfile()
      }


      class Person(val name: String, val age: Int, val hobby: String?, val referrer: Person?) {
          fun showProfile() {
              println("Name: $name")
              println("Age: $age")
              if(hobby != null) {
                  print("Likes to $hobby. ")
              }
              if(referrer != null) {
                  print("Has a referrer named ${referrer.name}")
                  if(referrer.hobby != null) {
                      print(", who likes to ${referrer.hobby}.")
                  } else {
                      print(".")
                  }
              } else {
                  print("Doesn't have a referrer.")
              }
              print("\n\n")
          }
      }


**Foldable phones**

   For the ``Phone`` class to be a parent class, you need to make the class open by adding the
   ``open`` keyword before the class name. To override the ``switchOn()`` method in the
   ``FoldablePhone`` class, you need to make the method in the ``Phone`` class open by adding the
   ``open`` keyword before the method.

   The solution contains a ``FoldablePhone`` class with a default constructor that contains a
   default argument for the ``isFolded`` parameter. The ``FoldablePhone`` class also has two methods
   to change the ``isFolded`` property to either a ``true`` or ``false`` value. It also overrides
   the ``switchOn()`` method inherited from the ``Phone`` class.

   You can create an instance of the class in the ``main()`` function and call its methods to test
   if the implementation is correct.

   .. code:: prettyprint

      open class Phone(var isScreenLightOn: Boolean = false){
          open fun switchOn() {
              isScreenLightOn = true
          }
          
          fun switchOff() {
              isScreenLightOn = false
          }
          
          fun checkPhoneScreenLight() {
              val phoneScreenLight = if (isScreenLightOn) "on" else "off"
              println("The phone screen's light is $phoneScreenLight.")
          }
      }

      class FoldablePhone(var isFolded: Boolean = true): Phone() {
          override fun switchOn() {
              if (!isFolded) {
                  isScreenLightOn = true
              }
          }
          
          fun fold() {
              isFolded = true
          }
          
          fun unfold() {
              isFolded = false
          }
      }

      fun main() {    
          val newFoldablePhone = FoldablePhone()
          
          newFoldablePhone.switchOn()
          newFoldablePhone.checkPhoneScreenLight()
          newFoldablePhone.unfold()
          newFoldablePhone.switchOn()
          newFoldablePhone.checkPhoneScreenLight()
      }

   The output is the following:

   ::

      The phone screen's light is off.
      The phone screen's light is on.


**Special auction**

   The solution uses the ``?.`` safe call operator and the ``?:`` Elvis operator to return the
   correct price:

   .. code:: prettyprint

      fun main() {
          val winningBid = Bid(5000, "Private Collector")
          
          println("Item A is sold at ${auctionPrice(winningBid, 2000)}.")
          println("Item B is sold at ${auctionPrice(null, 3000)}.")
      }

      class Bid(val amount: Int, val bidder: String)

      fun auctionPrice(bid: Bid?, minimumPrice: Int): Int {
          return bid?.amount ?: minimumPrice
      }


10. Additional Practice
-----------------------

   For more practice on the Kotlin language, check out the `Kotlin Core track by JetBrains Academy <https://hyperskill.org/tracks/18>`__. 
   To jump to a specific topic, go to the `knowledge map <https://hyperskill.org/knowledge-map>`__ 
   to view the list of topics covered in the track.


â­ Generics, objects, and extensions
====================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-generics


1. Introduction
--------------------------------------------------------------------------------

   Over the decades, programmers devised several programming language features to help you write
   better codeâ€”expressing the same idea with less code, abstraction to express complex ideas, and
   writing code that prevents other developers from accidentally making mistakes are just a few
   examples. The Kotlin language is no exception, and there are a number of features intended to
   help developers write more expressive code.

   Unfortunately, these features can make things tricky if this is your first time programming.
   While they might sound useful, the extent of their usefulness and the problems they solve may not
   always be apparent. Chances are you've already seen some features used in Compose and other
   libraries.

   While there's no substitute for experience, this codelab exposes you to several Kotlin concepts
   that help you structure larger apps:

   -  Generics
   -  Different kinds of classes (enum classes and data classes)
   -  Singleton and companion objects
   -  Extension properties and functions
   -  Scope functions

   By the end of this codelab, you should have a deeper knowledge of the code you've already seen in
   this course, and learn some examples of when you'll encounter or use these concepts in your own
   apps.


Prerequisites

   -  Familiarity with object-oriented programming concepts, including inheritance.
   -  How to define and implement interfaces.


What you'll learn

   -  How to define a generic type parameter for a class.
   -  How to instantiate a generic class.
   -  When to use enum and data classes.
   -  How to define a generic type parameter that must implement an interface.
   -  How to use scope functions to access class properties and methods.
   -  How to define singleton objects and companion objects for a class.
   -  How to extend existing classes with new properties and methods.


What you'll need

   -  A web browser with access to the Kotlin Playground.


2. Make a reusable class with generics
--------------------------------------------------------------------------------

   Let's say you're writing an app for an online quiz, similar to the quizzes you've seen in this
   course. There are often multiple types of quiz questions, such as fill-in-the-blank, or true or
   false. An individual quiz question can be represented by a class, with several properties.

   The question text in a quiz can be represented by a string. Quiz questions also need to represent
   the answer. However, different question typesâ€”such as true or falseâ€”may need to represent the
   answer using a different data type. Let's define three different types of questions.

   -  **Fill-in-the-blank question**: The answer is a word represented by a ``String``.
   -  **True or false question**: The answer is represented by a ``Boolean``.
   -  **Math problems**: The answer is a numeric value. The answer for a simple arithmetic problem
      is represented by an ``Int``.

   In addition, quiz questions in our example, regardless of the type of question, will also have a
   difficulty rating. The difficulty rating is represented by a string with three possible values:
   ``"easy"``, ``"medium"``, or ``"hard"``.

   Define classes to represent each type of quiz question:

   1. Navigate to the `Kotlin playground <https://developer.android.google.cn/training/kotlinplayground>`__.
   2. Above the ``main()`` function, define a class for fill-in-the-blank questions named
      ``FillInTheBlankQuestion``, consisting of a ``String`` property for the ``questionText``, a
      ``String`` property for the ``answer``, and a ``String`` property for the ``difficulty``.

   .. code:: prettyprint

      class FillInTheBlankQuestion(
          val questionText: String,
          val answer: String,
          val difficulty: String
      )

   3. Below the ``FillInTheBlankQuestion`` class, define another class named ``TrueOrFalseQuestion``
      for true or false questions, consisting of a ``String`` property for the ``questionText``, a
      ``Boolean`` property for the ``answer``, and a ``String`` property for the ``difficulty``.

   .. code:: prettyprint

      class TrueOrFalseQuestion(
          val questionText: String,
          val answer: Boolean,
          val difficulty: String
      )

   4. Finally, below the another class, define a ``NumericQuestion`` class, consisting of a
      ``String`` property for the ``questionText``, an ``Int`` property for the ``answer``, and a
      ``String`` property for the ``difficulty``.

   .. code:: prettyprint

      class NumericQuestion(
          val questionText: String,
          val answer: Int,
          val difficulty: String
      )

   5. Take a look at the code you wrote. Do you notice the repetition?

   .. code:: prettyprint

      class FillInTheBlankQuestion(
          val questionText: String,
          val answer: String,
          val difficulty: String
      )

      class TrueOrFalseQuestion(
          val questionText: String,
          val answer: Boolean,
          val difficulty: String
      )
      class NumericQuestion(
          val questionText: String,
          val answer: Int,
          val difficulty: String
      )

   All three classes have the exact same properties: the ``questionText``, ``answer``, and
   ``difficulty``. The only difference is the data type of the ``answer`` property. You might think
   that the obvious solution is to create a parent class with the ``questionText`` and
   ``difficulty``, and each subclass defines the ``answer`` property.

   However, using inheritance has the same problem as above. Every time you add a new type of
   question, you have to add an ``answer`` property. The only difference is the data type. It also
   looks strange to have a parent class ``Question`` that doesn't have an answer property.

   When you want a property to have differing data types, subclassing is not the answer. Instead,
   Kotlin provides something called *generic types* that allow you to have a single property that
   can have differing data types, depending on the specific use case.


What is a generic data type?

   Generic types, or *generics* for short, allow a data type, such as a class, to specify an unknown
   placeholder data type that can be used with its properties and methods. What exactly does this
   mean?

   In the above example, instead of defining an answer property for each possible data type, you can
   create a single class to represent any question, and use a placeholder name for the data type of
   the ``answer`` property. The actual data typeâ€”``String``, ``Int``, ``Boolean``, etc.â€”is specified
   when that class is instantiated. Wherever the placeholder name is used, the data type passed into
   the class is used instead. The syntax for defining a generic type for a class is shown below:

   ::

             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      class  â”‚ class name â”‚  <  â”‚ generic data type â”‚  > (
             â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ properites â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      )

   A generic data type is provided when instantiating a class, so it needs to be defined as part of
   the class signature. After the class name comes a left-facing angle bracket (``<``), followed by
   a placeholder name for the data type, followed by a right-facing angle bracket (``>``).

   The placeholder name can then be used wherever you use a real data type within the class, such as
   for a property.

   ::

             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      class  â”‚ class name â”‚  <  â”‚ generic data type â”‚  > (
             â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         val   â”‚ properites name â”‚ : â”‚ generic data type â”‚
               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      )


   This is identical to any other property declaration, except the placeholder name is used instead
   of the data type.

   How would your class ultimately know which data type to use? The data type that the generic type
   uses is passed as a parameter in angle brackets when you instantiate the class.

   ::

          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      val â”‚ instance name â”‚ = â”‚ class name â”‚  <  â”‚ generic data type â”‚  > ( â”‚ properites â”‚ )
          â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   After the class name comes a left-facing angle bracket (``<``), followed by the actual data type,
   ``String``, ``Boolean``, ``Int``, etc., followed by a right-facing bracket (``>``). The data type
   of the value that you pass in for the generic property must match the data type in the angle
   brackets. You'll make the answer property generic so that you can use one class to represent any
   type of quiz question, whether the answer is a ``String``, ``Boolean``, ``Int``, or any arbitrary
   data type.

   **Note:** The generic types passed in when instantiating a class are also called "parameters",
   although they're part of a separate parameter list than the property values placed inside the
   parentheses.

   **Note:** Like the example above, you'll often see a generic type named ``T`` (short for type),
   or other capital letters if the class has multiple generic types. However, there is definitely
   not a rule and you're welcome to use a more descriptive name for generic types.


Refactor your code to use generics

   Refactor your code to use a single class named ``Question`` with a generic answer property.

   1. Remove the class definitions for ``FillInTheBlankQuestion``, ``TrueOrFalseQuestion``, and
      ``NumericQuestion``.
   2. Create a new class named ``Question``.

   .. code:: prettyprint

      class Question()

   3. After the class name, but before the parentheses, add a generic type parameter using left- and
      right-facing angle brackets. Call the generic type ``T``.

   .. code:: prettyprint

      class Question<T>()

   4. Add the ``questionText``, ``answer``, and ``difficulty`` properties. The ``questionText``
      should be of type ``String``. The ``answer`` should be of type ``T`` because its data type is
      specified when instantiating the ``Question`` class. The ``difficulty`` property should be of
      type ``String``.

   .. code:: prettyprint

      class Question<T>(
          val questionText: String,
          val answer: T,
          val difficulty: String
      )

   5. To see how this works with multiple question typesâ€”fill-in-the-blank, true or false, etc.â€”
      create three instances of the ``Question`` class in ``main()``, as shown below.

   .. code:: prettyprint

      fun main() {
          val question1 = Question<String>("Quoth the raven ___", "nevermore", "medium")
          val question2 = Question<Boolean>("The sky is green. True or false", false, "easy")
          val question3 = Question<Int>("How many days are there between full moons?", 28, "hard")
      }

   6. Run your code to make sure everything works. You should now have three instances of the
      ``Question`` classâ€”each with different data types for the answerâ€”instead of three different
      classes, or instead of using inheritance. If you want to handle questions with a different
      answer type, you can reuse the same ``Question`` class.


3. Use an enum class
--------------------------------------------------------------------------------

   In the previous section, you defined a difficulty property with three possible values: "easy",
   "medium", and "hard". While this works, there are a couple of problems.

   1. If you accidentally mistype one of the three possible strings, you could introduce bugs.
   2. If the values change, for example, ``"medium"`` is renamed to ``"average"``, then you need to
      update all usages of the string.
   3. There's nothing stopping you or another developer from accidentally using a different string
      that isn't one of the three valid values.
   4. The code is harder to maintain if you add more difficulty levels.

   Kotlin helps you address these problems with a special type of class called an *enum class*. An
   enum class is used to create types with a limited set of possible values. In the real world, for
   example, the four cardinal directionsâ€”north, south, east, and westâ€”could be represented by an
   enum class. There's no need, and the code shouldn't allow, for the use of any additional
   directions. The syntax for an enum class is shown below.

   ::

                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      enum class  â”‚ enum name â”‚ {
                  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ Case 1 â”‚ , â”‚ Case 1 â”‚ , â”‚ Case 1 â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   Each possible value of an enum is called an *enum constant*. Enum constants are placed inside the
   curly braces separated by commas. The convention is to capitalize every letter in the constant
   name.

   You refer to enum constants using the dot operator.

   ::

         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ enum name â”‚ . â”‚ case name â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

Use an enum constant

   Modify your code to use an enum constant, instead of a ``String``, to represent the difficulty.

   1. Below the ``Question`` class, define an ``enum`` class called ``Difficulty``.

   .. code:: prettyprint

      enum class Difficulty {
          EASY, MEDIUM, HARD
      }

   2. In the ``Question`` class, change the data type of the ``difficulty`` property from ``String``
      to ``Difficulty``.

   .. code:: prettyprint

      class Question<T>(
          val questionText: String,
          val answer: T,
          val difficulty: Difficulty
      )

   3. When initializing the three questions, pass in the enum constant for the difficulty.

   .. code:: prettyprint

      val question1 = Question<String>("Quoth the raven ___", "nevermore", Difficulty.MEDIUM)
      val question2 = Question<Boolean>("The sky is green. True or false", false, Difficulty.EASY)
      val question3 = Question<Int>("How many days are there between full moons?", 28, Difficulty.HARD)


4. Use a data class
--------------------------------------------------------------------------------

   Many of the classes you've worked with so far, such as subclasses of ``Activity``, have several
   methods to perform different actions. These classes don't just represent data, but also contain a
   lot of functionality.

   Classes like the ``Question`` class, on the other hand, only contain data. They don't have any
   methods that perform an action. These can be defined as a *data class*. Defining a class as a
   data class allows the Kotlin compiler to make certain assumptions, and to automatically implement
   some methods. For example, ``toString()`` is called behind the scenes by the ``println()``
   function. When you use a data class, ``toString()`` and other methods are implemented
   automatically based on the class's properties.

   To define a data class, simply add the ``data`` keyword before the ``class`` keyword.

   ::

                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      data class  â”‚ class name â”‚ ( . . . )
                  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  

Convert ``Question`` to a data class

   First, you'll see what happens when you try to call a method like ``toString()`` on a class that
   isn't a data class. Then, you'll convert ``Question`` into a data class, so that this and other
   methods will be implemented by default.

   1. In ``main()``, print the result of calling ``toString()`` on ``question1``.

   .. code:: prettyprint

      fun main() {
          val question1 = Question<String>("Quoth the raven ___", "nevermore", Difficulty.MEDIUM)
          val question2 = Question<Boolean>("The sky is green. True or false", false, Difficulty.EASY)
          val question3 = Question<Int>("How many days are there between full moons?", 28, Difficulty.HARD)
          println(question1.toString())
      }

   2. Run your code. The output only shows the class name and a unique identifier for the object.

   ::

      Question@37f8bb67

   3. Make ``Question`` into a data class using the ``data`` keyword.

   .. code:: prettyprint

      data class Question<T>(
          val questionText: String,
          val answer: T,
          val difficulty: Difficulty
      )

   4. Run your code again. By marking this as a data class, Kotlin is able to determine how to
      display the class's properties when calling ``toString()``.

   ::

      Question(questionText=Quoth the raven ___, answer=nevermore, difficulty=MEDIUM)

   When a class is defined as a data class, the following methods are implemented.

   -  ``equals()``
   -  ``hashCode()``: you'll see this method when working with certain collection types.
   -  ``toString()``
   -  `componentN() <https://kotlinlang.org/docs/destructuring-declarations.html#example-returning-two-values-from-a-function>`__:
      ``component1()``, ``component2()``, etc.
   -  ``copy()``

   **Note:** A data class needs to have at least one parameter in its constructor, and all
   constructor parameters must be marked with ``val`` or ``var``. A data class also cannot be
   ``abstract``, ``open``, ``sealed``, or ``inner``.


5. Use a singleton object
--------------------------------------------------------------------------------

   There are many scenarios where you want a class to only have one instance. For example:

   1. Player stats in a mobile game for the current user.
   2. Interacting with a single hardware device, like sending audio through a speaker.
   3. An object to access a remote data source (such as a Firebase database).
   4. Authentication, where only one user should be logged in at a time.

   In the above scenarios, you'd probably need to use a class. However, you'll only ever need to
   instantiate one instance of that class. If there's only one hardware device, or only one user
   logged in at once, there would be no reason to create more than a single instance. Having two
   objects that access the same hardware device simultaneously could lead to some really strange and
   buggy behavior.

   You can clearly communicate in your code that an object should have only one instance by defining
   it as a singleton. A *singleton* is a class that can only have a single instance. Kotlin provides
   a special construct, called an *object*, that can be used to make a singleton class.


Define a singleton object

   ::

              â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      object  â”‚ object name â”‚ {
              â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ class body 1 â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   The syntax for an object is similar to that of a class. Simply use the ``object`` keyword instead
   of the ``class`` keyword. A singleton object can't have a constructor as you can't create
   instances directly. Instead, all the properties are defined within the curly braces and are given
   an initial value.

   Some of the examples given earlier might not seem obvious, especially if you haven't worked with
   specific hardware devices or dealt with authentication yet in your apps. However, you'll see
   singleton objects come up as you continue learning Android development. Let's see it in action
   with a simple example using an object for user state, in which only one instance is needed.

   For a quiz, it would be great to have a way to keep track of the total number of questions, and
   the number of questions the student answered so far. You'll only need one instance of this class
   to exist, so instead of declaring it as a class, declare it as a singleton object.

   1. Create an object named ``StudentProgress``.

   .. code:: prettyprint

      object StudentProgress {
      }

   2. For this example, we'll assume there are ten total questions, and that three of them are
      answered so far. Add two ``Int`` properties: ``total`` with a value of ``10``, and
      ``answered`` with a value of ``3``.

   .. code:: prettyprint

      object StudentProgress {
          var total: Int = 10
          var answered: Int = 3
      }


Access a singleton object

   Remember how you can't create an instance of a singleton object directly? How then are you able
   to access its properties?

   Because there's only one instance of ``StudentProgress`` in existence at one time, you access its
   properties by referring to the name of the object itself, followed by the dot operator (``.``),
   followed by the property name.

   ::

         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ object name â”‚ . â”‚ property name  â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   Update your ``main()`` function to access the properties of the singleton object.

   1. In ``main()``, add a call to ``println()`` that outputs the ``answered`` and ``total``
      questions from the ``StudentProgress`` object.

   .. code:: prettyprint

      fun main() {
          ...
          println("${StudentProgress.answered} of ${StudentProgress.total} answered.")
      }

   2. Run your code to verify that everything works.

   ::

      ...
      3 of 10 answered.


Declare objects as companion objects

   Classes and objects in Kotlin can be defined inside other types, and can be a great way to
   organize your code. You can define a singleton object inside another class using a *companion
   object*. A companion object allows you to access its properties and methods from inside the
   class, if the object's properties and methods belong to that class, allowing for more concise
   syntax.

   To declare a companion object, simply add the ``companion`` keyword before the ``object``
   keyword.

   ::

                        â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      companion object  â”‚ object name â”‚ {
                        â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ object body            â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   You'll create a new class called ``Quiz`` to store the quiz questions, and make
   ``StudentProgress`` a companion object of the ``Quiz`` class.

   1. Below the ``Difficulty`` enum, define a new class named ``Quiz``.

   .. code:: prettyprint

      class Quiz {
      }

   2. Move ``question1``, ``question2``, and ``question3`` from ``main()`` into the ``Quiz`` class.
      You also need to remove ``println(question1.toString())`` if you haven't already.

   .. code:: prettyprint

      class Quiz {
          val question1 = Question<String>("Quoth the raven ___", "nevermore", Difficulty.MEDIUM)
          val question2 = Question<Boolean>("The sky is green. True or false", false, Difficulty.EASY)
          val question3 = Question<Int>("How many days are there between full moons?", 28, Difficulty.HARD)

      }

   3. Move the ``StudentProgress`` object into the ``Quiz`` class.

   .. code:: prettyprint

      class Quiz {
          val question1 = Question<String>("Quoth the raven ___", "nevermore", Difficulty.MEDIUM)
          val question2 = Question<Boolean>("The sky is green. True or false", false, Difficulty.EASY)
          val question3 = Question<Int>("How many days are there between full moons?", 28, Difficulty.HARD)

          object StudentProgress {
              var total: Int = 10
              var answered: Int = 3
          }
      }

   4. Mark the ``StudentProgress`` object with the ``companion`` keyword.

   .. code:: prettyprint

      companion object StudentProgress {
          var total: Int = 10
          var answered: Int = 3
      }

   5. Update the call to ``println()`` to reference the properties with ``Quiz.answered`` and
      ``Quiz.total``. Even though these properties are declared in the ``StudentProgress`` object,
      they can be accessed with dot notation using only the name of the ``Quiz`` class.

   .. code:: prettyprint

      fun main() {
          println("${Quiz.answered} of ${Quiz.total} answered.")
      }

   6. Run your code to verify the output.

   ::

      3 of 10 answered.


6. Extend classes with new properties and methods
--------------------------------------------------------------------------------

   When working with Compose, you may have noticed some interesting syntax when specifying the size
   of UI elements. Numeric types, such as ``Double``, appear to have properties like ``dp`` and
   ``sp`` specifying dimensions.

   ::

      â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      â”‚        padding (16.dp)         â”‚
      â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   Why would the designers of the Kotlin language include properties and functions on built-in data
   types, specifically for building Android UI? Were they able to predict the future? Was Kotlin
   designed to be used with Compose even before Compose existed?

   Of course not! When you're writing a class, you often don't know exactly how another developer
   will use it, or plans to use it, in their app. It's not possible to predict all future use cases,
   nor is it wise to add unnecessary bloat to your code for some unforeseen use case.

   What the Kotlin language does, is give other developers the ability to extend existing data
   types, adding properties and methods that can be accessed with dot syntax, as if they were part
   of that data type. A developer who didn't work on the floating point types in Kotlin, for
   example, such as someone building the Compose library, might choose to add properties and methods
   specific to UI dimensions.

   Since you've seen this syntax when learning Compose in the first two units, it's about time for
   you to learn how this works under the hood. You'll add some properties and methods to extend
   existing types.


Add an extension property

   To define an extension property, add the type name and a dot operator (``.``) before the variable
   name.

   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      val  â”‚ type name   â”‚ . â”‚ perperty name â”‚ : â”‚ data type   â”‚
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
            â”‚ property getter â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   You'll refactor the code in the main() function to print the quiz progress with an extension
   property.

   1. Below the ``Quiz`` class, define an extension property of ``Quiz.StudentProgress`` named
      ``progressText`` of type ``String``.

   .. code:: prettyprint

      val Quiz.StudentProgress.progressText: String

   2. Define a getter for the extension property that returns the same string used before in
      ``main()``.

   .. code:: prettyprint

      val Quiz.StudentProgress.progressText: String
          get() = "${answered} of ${total} answered"

   3. Replace the code in the ``main()`` function with code that prints ``progressText``. Because
      this is an extension property of the companion object, you can access it with dot notation
      using the name of the class, ``Quiz``.

   .. code:: prettyprint

      fun main() {
          println(Quiz.progressText)
      }

   4. Run your code to verify it works.

   ::

      3 of 10 answered.

   **Note:** Extension properties can't store data, so they must be get-only.


Add an extension function

   To define an extension function, add the type name and a dot operator (``.``) before the function
   name.

   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      fun  â”‚ type name   â”‚ . â”‚ function name â”‚ ( â”‚ parameters  â”‚ ) : â”‚ return type â”‚ 
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ function body â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   You'll add an extension function to output the quiz progress as a progress bar. Since you can't
   actually make a progress bar in the Kotlin playground, you'll print out a retro-style progress
   bar using text!

   1. Add an extension function to the ``StudentProgress`` object called ``printProgressBar()``. The
      function should take no parameters and have no return value.

   .. code:: prettyprint

      fun Quiz.StudentProgress.printProgressBar() {
      }

   2. Print out the ``â–“`` character, ``answered`` number of times, using ``repeat()``. This
      dark-shaded portion of the progress bar represents the number of questions answered. Use
      ``print()`` because you don't want a new line after each character.

   .. code:: prettyprint

      fun Quiz.StudentProgress.printProgressBar() {
          repeat(Quiz.answered) { print("â–“") }
      }

   3. Print out the ``â–’`` character, the number of times equal to the difference between ``total``
      and ``answered``, using ``repeat()``. This light-shaded portion represents the remaining
      questions in the process bar.

   .. code:: prettyprint

      fun Quiz.StudentProgress.printProgressBar() {
          repeat(Quiz.answered) { print("â–“") }
          repeat(Quiz.total - Quiz.answered) { print("â–’") }
      }

   4. Print a new line using ``println()`` with no arguments, and then print ``progressText``.

   .. code:: prettyprint

      fun Quiz.StudentProgress.printProgressBar() {
          repeat(Quiz.answered) { print("â–“") }
          repeat(Quiz.total - Quiz.answered) { print("â–’") }
          println()
          println(Quiz.progressText)
      }

   5. Update the code in ``main()`` to call ``printProgressBar()``.

   .. code:: prettyprint

      fun main() {
          Quiz.printProgressBar()
      }

   6. Run your code to verify the output.

   ::

      â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’
      3 of 10 answered.

   Is it mandatory to do any of this? Certainly not. However, having the option of extension
   properties and methods gives you more options to expose your code to other developers. Using dot
   syntax on other types can make your code easier to read, both for yourself and for other
   developers.


7. Rewrite extension functions using interfaces
--------------------------------------------------------------------------------

   On the previous page, you saw how to add properties and methods to the ``StudentProgress`` object
   without adding code to it directly, using extension properties and extension functions. While
   this is a great way to add functionality to one class that's already defined, extending a class
   isn't always necessary if you have access to the source code. There are also situations where you
   don't know what the implementation should be, only that a certain method or property should
   exist. If you need multiple classes to have the same additional properties and methods, perhaps
   with differing behavior, you can define these properties and methods with an *interface*.

   For example, in addition to quizzes, let's say you also have classes for surveys, steps in a
   recipe, or any other ordered data that could use a progress bar. You can define something called
   an interface that specifies the methods and/or properties that each of these classes must
   include.

   ::

                           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                           â”‚ Progress interface â”‚
                           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                      â”‚
              â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
              â”‚                       â”‚                         â”‚
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®               â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®               â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚  Quiz  â”‚               â”‚ Survey â”‚               â”‚ Recipe â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯               â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯               â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   An interface is defined using the ``interface`` keyword, followed by a name in UpperCamelCase,
   followed by opening and closing curly braces. Within the curly braces, you can define any method
   signatures or get-only properties that any class conforming to the interface must implement.

   ::

                  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  
      interface   â”‚ Interface name â”‚ {
                  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ Interface body â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   An interface is a contract. A class that conforms to an interface is said to extend the
   interface. A class can declare that it would like to extend an interface using a colon (``:``),
   followed by a space, followed by the name of the interface.

   ::

            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      class â”‚ Class name â”‚ : â”‚ Interface name â”‚ {
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ Class body     â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      }

   In return, the class must implement all properties and methods specified in the interface. This
   lets you easily ensure that any class that needs to extend the interface implements the exact
   same methods with the exact same method signature. If you modify the interface in any way, such
   as add or remove properties or methods or change a method signature, the compiler requires you to
   update any class that extends the interface, keeping your code consistent and easier to maintain.

   Interfaces allow for variation in the behavior of classes that extend them. It's up to each class
   to provide the implementation.

   Let's see how you can rewrite the progress bar to use an interface, and make the Quiz class
   extend that interface.

   1. Above the ``Quiz`` class, define an interface named ``ProgressPrintable``. We've chosen the
      name ``ProgressPrintable`` because it makes any class that extends it able to print a progress
      bar.

   .. code:: prettyprint

      interface ProgressPrintable {
      }

   2. In the ``ProgressPrintable`` interface, define a property named ``progressText``.

   .. code:: prettyprint

      interface ProgressPrintable {
          val progressText: String
      }

   3. Modify the declaration of the ``Quiz`` class to extend the ``ProgressPrintable`` interface.

   .. code:: prettyprint

      class Quiz : ProgressPrintable {
          ... 
      }

   4. In the ``Quiz`` class, add a property named ``progressText`` of type ``String``, as specified
      in the ``ProgressPrintable`` interface. Because the property comes from ``ProgressPrintable``,
      precede ``val`` with the override keyword.

   .. code:: prettyprint

      override val progressText: String

   5. Copy the property getter from the old ``progressText`` extension property.

   .. code:: prettyprint

      override val progressText: String
              get() = "${answered} of ${total} answered"

   6. Remove the old ``progressText`` extension property.

   **Code to delete:**

   .. code:: prettyprint

      val Quiz.StudentProgress.progressText: String
          get() = "${answered} of ${total} answered"

   7. In the ``ProgressPrintable`` interface, add a method named ``printProgressBar`` that takes no
      parameters and has no return value.

   .. code:: prettyprint

      interface ProgressPrintable {
          val progressText: String
          fun printProgressBar()
      }

   8. In the ``Quiz`` class, add the ``printProgressBar()`` method using the ``override`` keyword.

   .. code:: prettyprint

      override fun printProgressBar() {
      }

   9. Move the code from the old ``printProgressBar()`` extension function into the new
      ``printProgressBar()`` from the interface. Modify the last line to refer to the new
      ``progressText`` variable from the interface by removing the reference to ``Quiz``.

   .. code:: prettyprint

      override fun printProgressBar() {
          repeat(Quiz.answered) { print("â–“") }
          repeat(Quiz.total - Quiz.answered) { print("â–’") }
          println()
          println(progressText)
      }

   10. Remove the extension function ``printProgressBar()``. This functionality now belongs to the
       ``Quiz`` class that extends ``ProgressPrintable``.

   **Code to delete:**

   .. code:: prettyprint

      fun Quiz.StudentProgress.printProgressBar() {
          repeat(Quiz.answered) { print("â–“") }
          repeat(Quiz.total - Quiz.answered) { print("â–’") }
          println()
          println(Quiz.progressText)
      }

   11. Update the code in ``main()``. As the ``printProgressBar()`` function is now a method of the
       ``Quiz`` class, you need to first instantiate a ``Quiz`` object and then call
       ``printProgressBar()``.

   .. code:: prettyprint

      fun main() {
          Quiz().printProgressBar()
      }

   12. Run your code. The output is unchanged, but your code is now more modular. As your codebases
       grow, you can easily add classes that conform to the same interface to reuse code without
       inheriting from a superclass.

   ::

      â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’
      3 of 10 answered.

   There are numerous use cases for interfaces to help structure your code and you'll start to see
   them used frequently in the common units. The following are some examples of interfaces you may
   encounter as you continue working with Kotlin.

   -  `Manual dependency injection <https://developer.android.google.cn/training/dependency-injection/manual>`__.
      Create an interface defining all the properties and methods of the dependency. Require the
      interface as the data type of the dependency (activity, test case, etc.) so that an instance
      of any class implementing the interface can be used. This allows you to swap out the
      underlying implementations.

   -  Mocking for automated tests. Both the mock class and the real class conform to the same
      interface.

   -  Accessing the same dependencies in a `Compose Multiplatform <https://github.com/JetBrains/compose-jb>`__ 
      app. For example, create an interface that provides a common set of properties and methods
      for Android and desktop, even if the underlying implementation differs for each platform.

   -  Several data types in Compose, such as `Modifier <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier>`__,
      are interfaces. This allows you to add new modifiers without needing to access or modify the
      underlying source code.


8. Use scope functions to access class properties and methods
--------------------------------------------------------------------------------

   As you've seen already, Kotlin includes a lot of features to make your code more concise.

   One such feature you'll encounter as you continue learning Android development is *scope
   functions*. Scope functions allow you to concisely access properties and methods from a class
   without having to repeatedly access the variable name. What exactly does this mean? Let's take a
   look at an example.


Eliminate repetitive object references with scope functions

   Scope functions are higher-order functions that allow you to access properties and methods of an
   object without referring to the object's name. These are called scope functions because the body
   of the function passed in takes on the scope of the object that the scope function is called
   with. For example, some scope functions allow you to access the properties and methods in a
   class, as if the functions were defined as a method of that class. This can make your code more
   readable by allowing you to omit the object name when including it is redundant.

   To better illustrate this, let's take a look at a few different scope functions that you'll
   encounter later in the course.


Replace long object names using ``let()``

   The ``let()`` function allows you to refer to an object in a lambda expression using the
   identifier ``it``, instead of the object's actual name. This can help you avoid using a long,
   more descriptive object name repeatedly when accessing more than one property. The ``let()``
   function is an extension function that can be called on any Kotlin object using dot notation.

   Try accessing the properties of ``question1``, ``question2``, and ``question3`` using ``let()``:

   1. Add a function to the ``Quiz`` class named ``printQuiz()``.

   .. code:: prettyprint

      fun printQuiz() {
          
      }

   2. Add the following code that prints the question's ``questionText``, ``answer``, and
      ``difficulty``. While multiple properties are accessed for ``question1``, ``question2``, and
      ``question3``, the entire variable name is used each time. If the variable's name changed,
      you'd need to update every usage.

   .. code:: prettyprint

      fun printQuiz() {
          println(question1.questionText)
          println(question1.answer)
          println(question1.difficulty)
          println()
          println(question2.questionText)
          println(question2.answer)
          println(question2.difficulty)
          println()
          println(question3.questionText)
          println(question3.answer)
          println(question3.difficulty)
          println()
      }

   3. Surround the code accessing the ``questionText``, ``answer``, and ``difficulty`` properties
      with a call to the ``let()`` function on ``question1``, ``question2``, and ``question3``.
      Replace the variable name in each lambda expression with it.

   .. code:: prettyprint

      fun printQuiz() {
          question1.let {
              println(it.questionText)
              println(it.answer)
              println(it.difficulty)
          }
          println()
          question2.let {
              println(it.questionText)
              println(it.answer)
              println(it.difficulty)
          }
          println()
          question3.let {
              println(it.questionText)
              println(it.answer)
              println(it.difficulty)
          }
          println()
      }

   4. Update the code in ``main()`` to create an instance of the ``Quiz`` class named ``quiz``.

   .. code:: prettyprint

      fun main() {
          val quiz = Quiz()
      }

   5. Call ``printQuiz()``.

   .. code:: prettyprint

      fun main() {
          val quiz = Quiz()
          quiz.printQuiz()
      }

   6. Run your code to verify that everything works.

   ::

      Quoth the raven ___
      nevermore
      MEDIUM

      The sky is green. True or false
      false
      EASY

      How many days are there between full moons?
      28
      HARD


Call an object's methods without a variable using apply()

   One of the cool features of scope functions is that you can call them on an object before that
   object has even been assigned to a variable. For example, the ``apply()`` function is an
   extension function that can be called on an object using dot notation. The ``apply()`` function
   also returns a reference to that object so that it can be stored in a variable.

   Update the code in ``main()`` to call the ``apply()`` function.

   1. Call ``apply()`` after the closing parenthesis when creating an instance of the ``Quiz``
      class. You can omit the parentheses when calling ``apply()``, and use trailing lambda syntax.

   .. code:: prettyprint

      val quiz = Quiz().apply {
      }

   2. Move the call to ``printQuiz()`` inside the lambda expression. You no longer need to reference
      the ``quiz`` variable or use dot notation.

   .. code:: prettyprint

      val quiz = Quiz().apply {
          printQuiz()
      }

   3. The ``apply()`` function returns the instance of the ``Quiz`` class, but since you're no
      longer using it anywhere, remove the ``quiz`` variable. With the ``apply()`` function, you
      don't even need a variable to call methods on the instance of ``Quiz``.

   .. code:: prettyprint

      Quiz().apply {
          printQuiz()
      }

   4. Run your code. Note that you were able to call this method without a reference to the instance
      of ``Quiz``. The ``apply()`` function returned the objects which were stored in ``quiz``.

   ::

      Quoth the raven ___
      nevermore
      MEDIUM

      The sky is green. True or false
      false
      EASY

      How many days are there between full moons?
      28
      HARD

   While using scope functions isn't mandatory to achieve the desired output, the above examples
   illustrate how they can make your code more concise and avoid repeating the same variable name.

   The above code demonstrates just two examples, but you're encouraged to bookmark and refer to the
   `Scope Functions documentation <https://kotlinlang.org/docs/scope-functions.html>`__ 
   as you encounter their usage later in the course.


9. Summary
--------------------------------------------------------------------------------

   You just got the chance to see several new Kotlin features in action. Generics allow data types
   to be passed as parameters to classes, enum classes define a limited set of possible values, and
   data classes help automatically generate some useful methods for classes.

   You also saw how to create a singleton objectâ€”which is restricted to one instance, how to make it
   a companion object of another class, and how to extend existing classes with new get-only
   properties and new methods. Finally, you saw some examples of how scope functions can provide a
   simpler syntax when accessing properties and methods.

   You'll see these concepts throughout the later units as you learn more about Kotlin, Android
   development, and Compose. You now have a better understanding of how they work and how they can
   improve the reusability and readability of your code.


10. Learn more
--------------------------------------------------------------------------------

   -  `Generics <https://kotlinlang.org/docs/generics.html>`__
   -  `Enum classes <https://kotlinlang.org/docs/enum-classes.html>`__
   -  `Data classes <https://kotlinlang.org/docs/data-classes.html>`__
   -  `Object expressions and declarations <https://kotlinlang.org/docs/object-declarations.html>`__
   -  `Scope functions <https://kotlinlang.org/docs/scope-functions.html>`__


â­ Use collections in Kotlin
=============================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-collections#4


1. Introduction
--------------------------------------------------------------------------------

   In many apps, you've probably seen data displayed as a list: contacts, settings, search results,
   etc.

   .. image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-collections/img/46df844b170f4272.png


   However, in the code you've written so far, you've mostly worked with data consisting of a single
   value, like a number or piece of text displayed on the screen. To build apps involving arbitrary
   amounts of data, you need to learn how to use collections.

   Collection types (sometimes called data structures) let you store multiple values, typically of
   the same data type, in an organized way. A collection might be an ordered list, a grouping of
   unique values, or a mapping of values of one data type to values of another. The ability to
   effectively use collections enables you to implement common features of Android apps, such as
   scrolling lists, as well as solve a variety of real-life programming problems that involve
   arbitrary amounts of data.

   This codelab discusses how to work with multiple values in your code, and introduces a variety of
   data structures, including arrays, lists, sets, and maps.


Prerequisites

   -  Familiarity with object-oriented programming in Kotlin, including classes, interfaces, and
      generics.


What you'll learn

   -  How to create and modify arrays.
   -  How to use ``List`` and ``MutableList``.
   -  How to use ``Set`` and ``MutableSet``.
   -  How to use ``Map`` and ``MutableMap``.


What you'll need

   -  A web browser with access to the Kotlin Playground.


2. Arrays in Kotlin
--------------------------------------------------------------------------------


What is an array?

   An array is the simplest way to group an arbitrary number of values in your programs.

   Like a grouping of solar panels is called a solar array, or how learning Kotlin opens up an array
   of possibilities for your programming career, an ``Array`` represents **more than one value**.
   Specifically, an array is a sequence of values that all have the same data type.

   ::

                        Single value
                           â•­â”€â”€â”€â•®
                           â”‚ 8 â”‚
                           â•°â”€â”€â”€â•¯

                           Array
               â•­â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â•®
               â”‚ 8 â”‚ 6 â”‚ 7 â”‚ 5 â”‚ 3 â”‚ 0 â”‚ 9 â”‚
               â•°â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â•¯

   -  An array contains multiple values called *elements*, or sometimes, *items*.
   -  The elements in an array are ordered and are accessed with an index.

   What's an index? An index is a whole number that corresponds to an element in the array. An index
   tells the distance of an item from the starting element in an array. This is called
   zero-indexing. The first element of the array is at index 0, the second element is at index 1,
   because it's one place from the first element, and so on.

   ::

                           Array
               â•­â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â•®
               â”‚ 8 â”‚ 6 â”‚ 7 â”‚ 5 â”‚ 3 â”‚ 0 â”‚ 9 â”‚
               â•°â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â•¯
                 0   1   2   3   4   5   6

   In the device's memory, elements in the array are stored next to each other. While the underlying
   details are beyond the scope of this codelab, this has two important implications:

   -  Accessing an array element by its index is fast. You can access any random element of an array
      by its index and expect it to take about the same amount of time to access any other random
      element. This is why it's said that arrays have *random access*.

   -  An array has a fixed size. This means that you can't add elements to an array beyond this
      size. Trying to access the element at index 100 in a 100 element array will throw an exception
      because the highest index is 99 (remember that the first index is 0, not 1). You can, however,
      modify the values at indexes in the array.

   **Note:** In this codelab, memory refers to the short-term Random Access Memory (RAM) of the
   device, not the long-term persistent storage. It's called "Random Access" because it allows for
   fast access to any arbitrary location in memory.

   To declare an array in code, you use the ``arrayOf()`` function.

   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®             â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   
      val  â”‚ vaiable name â”‚ = arrayOf < â”‚ data type â”‚ > ( â”‚ element 1 â”‚ , â”‚ element 2 â”‚ , ... ) 
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯             â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   

   The ``arrayOf()`` function takes the array elements as parameters, and returns an array of the
   type matching the parameters passed in. This might look a little different from other functions
   you've seen because ``arrayOf()`` has a varying number of parameters. If you pass in two
   arguments to ``arrayOf()``, the resulting array contains two elements, indexed 0 and 1. If you
   pass in three arguments, the resulting array will have 3 elements, indexed 0 through 2.

   Let's see arrays in action with a small exploration of the solar system!

   1. Navigate to the `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__.
   2. In ``main()``, create a ``rockPlanets`` variable. Call ``arrayOf()``, passing in the type
      ``String``, along with four stringsâ€”one for each of the rock planets in the solar system.

   .. code:: prettyprint

      val rockPlanets = arrayOf<String>("Mercury", "Venus", "Earth", "Mars")

   3. Because Kotlin uses type inference, you can omit the type name when calling ``arrayOf()``.
      Below the ``rockPlanets`` variable, add another variable ``gasPlanets``, without passing a
      type into the angle brackets.

   .. code:: prettyprint

      val gasPlanets = arrayOf("Jupiter", "Saturn", "Uranus", "Neptune")

   4. You can do some cool things with arrays. For example, just like the numeric types ``Int`` or
      ``Double``, you can add two arrays together. Create a new variable called ``solarSystem``, and
      set it equal to the result of ``rockPlanets`` and ``gasPlanets``, using the plus (``+``)
      operator. The result is a new array containing all the elements of the ``rockPlanets`` array
      and the elements of the ``gasPlanets`` array.

   .. code:: prettyprint

      val solarSystem = rockPlanets + gasPlanets

   5. Run your program to verify that it works. You shouldn't see any output yet.


Access an element in an array

   You can access an element of an array by its index.


   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â•® 
           â”‚ array name â”‚ [ â”‚ index â”‚ ]
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â•¯ 


   This is called subscript syntax. It consists of three parts:

   -  The name of the array.
   -  An opening (``[``) and closing (``]``) square bracket.
   -  The index of the array element in the square brackets.

   Let's access the elements of the ``solarSystem`` array by their indices.

   1. In ``main()``, access and print each element of the ``solarSystem`` array. Note how the first
      index is ``0`` and the last index is ``7``.

   .. code:: prettyprint

      println(solarSystem[0])
      println(solarSystem[1])
      println(solarSystem[2])
      println(solarSystem[3])
      println(solarSystem[4])
      println(solarSystem[5])
      println(solarSystem[6])
      println(solarSystem[7])

   2. Run your program. The elements are in the same order you listed them when calling
      ``arrayOf()``.

   ::

      Mercury
      Venus
      Earth
      Mars
      Jupiter
      Saturn
      Uranus
      Neptune

   You can also set the value of an array element by its index.


   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â•®      â•­â”€â”€â”€â”€â”€â”€â”€â•® 
           â”‚ array name â”‚ [ â”‚ index â”‚ ] =  â”‚ value â”‚ 
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â•¯      â•°â”€â”€â”€â”€â”€â”€â”€â•¯ 


   Accessing the index is the same as beforeâ€”the name of the array, followed by an opening and
   closing square bracket containing the index. This is then followed by the assignment operator
   (``=``) and a new value.

   Let's practice modifying values on the ``solarSystem`` array.

   1. Let's give Mars a new name for its future human settlers. Access the element at index ``3``
      and set it equal to ``"Little Earth"``.

   .. code:: prettyprint

      solarSystem[3] = "Little Earth"

   2. Print the element at index ``3``.

   .. code:: prettyprint

      println(solarSystem[3])

   3. Run your program. The fourth element of the array (at index ``3``) is updated.

   ::

      ...
      Little Earth

   4. Now let's say scientists made a discovery that there's a ninth planet beyond Neptune called
      Pluto. Earlier, we mentioned that you can't resize an array. What would happen if you tried?
      Let's try adding Pluto to the ``solarSystem`` array. Add Pluto at index ``8`` as this is the
      9th element in the array.

   .. code:: prettyprint

      solarSystem[8] = "Pluto"

   5. Run your code. It throws an ``ArrayIndexOutOfBounds`` exception. Because the array already had
      8 elements, as expected, you can't simply add a ninth element.

   ::

      Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 8 out of bounds for length 8

   6. Remove the addition of Pluto to the array.

   **Code to remove**

   .. code:: prettyprint

      solarSystem[8] = "Pluto"

   7. If you want to make an array larger than it already is, you need to create a new array. Define
      a new variable called ``newSolarSystem`` as shown. This array can store nine elements, instead
      of eight.

   .. code:: prettyprint

      val newSolarSystem = arrayOf("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune", "Pluto")

   8. Now try to print the element at index ``8``.

   .. code:: prettyprint

      println(newSolarSystem[8])

   9. Run your code and observe that it runs without any exceptions.

   ::

      ...
      Pluto

   Great job! With your knowledge of arrays, you can do almost anything with collections.

   Wait, not so fast! While arrays are one of the fundamental aspects of programming, using an array
   for tasks that require adding and removing elements, uniqueness in a collection, or mapping
   objects to other objects isn't exactly simple or straightforward, and your app's code would
   quickly become a mess.

   This is why most programming languages, including Kotlin, implement special collection types to
   handle situations that commonly occur in real-world apps. In the following sections, you'll learn
   about three common collections: ``List``, ``Set``, and ``Map``. You'll also learn the common
   properties and methods, and the situations in which to use these collection types.


3. Lists
--------------------------------------------------------------------------------

   A list is an ordered, resizable collection, typically implemented as a resizable array. When the
   array is filled to capacity and you try to insert a new element, the array is copied to a new
   bigger array.


   ::

                â•­â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â•®     â•­â”€â”€â”€â•®
      Old array â”‚ 8 â”‚ 6 â”‚ 7 â”‚ 5 â”‚ 3 â”‚     â”‚ 0 â”‚ not enough room for new element
                â•°â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â•¯     â•°â”€â”€â”€â•¯
                  0   1   2   3   4         â”‚
                  â”‚   â”‚   â”‚   â”‚   â”‚   â•­â”€â”€â”€â”€â”€â•¯
                  â”‚   â”‚   â”‚   â”‚   â”‚   â”‚
                â•­â”€vâ”€â”¬â”€vâ”€â”¬â”€vâ”€â”¬â”€vâ”€â”¬â”€vâ”€â”¬â”€vâ”€â•®
      New array â”‚ 8 â”‚ 6 â”‚ 7 â”‚ 5 â”‚ 3 â”‚ 0 â”‚
                â•°â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â•¯
                  0   1   2   3   4   5 

   With a list, you can also insert new elements between other elements at a specific index.

   ::

                             â•­â”€â”€â”€â•®
                             â”‚ 0 â”‚ insert an new element
                             â•°â”€â”€â”€â•¯
                               â”‚
                         â•­â”€â”€â”€â”€â”€â•¯
                         â”‚
                â•­â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â•®
      Old array â”‚ 8 â”‚ 6 â”‚ 7 â”‚ 5 â”‚ 3 â”‚
                â•°â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â•¯
                  0   1   2   3   4  
                          â•°â”€â”€â”€â”´â”€â”€â”€â•¯          all elements with 
                              â•°â”€â”€â”€â”€â”€â”€ higher indices will be moved

   This is how lists are able to add and remove elements. In most cases, it takes the same amount of
   time to add any element to a list, regardless of how many elements are in the list. Every once in
   a while, if adding a new element would put the array above its defined size, the array elements
   might have to move to make room for new elements. Lists do all of this for you, but behind the
   scenes, it's just an array that gets swapped out for a new array when needed.


``List`` and ``MutableList``

   The collection types you'll encounter in Kotlin implement one or more interfaces. As you learned
   in the `Generics, objects, and extensions <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-generics>`__
   codelab earlier in this unit, interfaces provide a standard set of properties and methods for a
   class to implement. A class that implements the ``List`` interface provides implementations for
   all the properties and methods of the ``List`` interface. The same is true for ``MutableList``.

   So what do ``List`` and ``MutableList`` do?

   -  ``List`` is an interface that defines properties and methods related to a read-only ordered
      collection of items.
   -  ``MutableList`` extends the ``List`` interface by defining methods to modify a list, such as
      adding and removing elements.

   These interfaces only specify the properties and methods of a ``List`` and/or ``MutableList``.
   It's up to the class that extends them to determine how each property and method is implemented.
   The array-based implementation described above is what you'll use most, if not all of the time,
   but Kotlin allows other classes to extend ``List`` and ``MutableList``.


The ``listOf()`` function

   Like ``arrayOf()``, the ``listOf()`` function takes the items as parameters, but returns a
   ``List`` rather than an array.

   1. Remove the existing code from ``main()``.
   2. In ``main()``, create a ``List`` of planets called ``solarSystem`` by calling ``listOf()``.

   .. code:: prettyprint

      fun main() {
          val solarSystem = listOf("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")
      }

   3. ``List`` has a ``size`` property to get the number of elements in the list. Print the ``size``
      of the ``solarSystem`` list.

   .. code:: prettyprint

      println(solarSystem.size) 

   4. Run your code. The size of the list should be 8.

   ::

      8


Access elements from a list

   Like an array, you can access an element at a specific index from a ``List`` using subscript
   syntax. You can do the same using the ``get()`` method. Subscript syntax and the ``get()`` method
   take an ``Int`` as a parameter and return the element at that index. Like ``Array``,
   ``ArrayList`` is zero-indexed, so for example, the fourth element would be at index ``3``.

   1. Print the planet at index ``2`` using subscript syntax.

   .. code:: prettyprint

      println(solarSystem[2])

   2. Print the element at index ``3`` by calling ``get()`` on the ``solarSystem`` list.

   .. code:: prettyprint

      println(solarSystem.get(3))

   3. Run your code. The element at index ``2`` is ``"Earth"`` and the element at index ``3`` is
      ``"Mars"``.

   ::

      ...
      Earth
      Mars

   In addition to getting an element by its index, you can also search for the index of a specific
   element using the ``indexOf()`` method. The ``indexOf()`` method searches the list for a given
   element (passed in as an argument), and returns the index of the first occurrence of that
   element. If the element doesn't occur in the list, it returns ``-1``.

   1. Print the result of calling ``indexOf()`` on the ``solarSystem`` list, passing in ``"Earth"``.

   .. code:: prettyprint

      println(solarSystem.indexOf("Earth"))

   2. Call ``indexOf()``, passing in ``"Pluto"``, and print the result.

   .. code:: prettyprint

      println(solarSystem.indexOf("Pluto"))

   3. Run your code. An element matches ``"Earth"``, so the index, ``2``, is printed. There isn't an
      element that matches ``"Pluto"``, so ``-1`` is printed.

   ::

      ...
      2
      -1


Iterate over list elements using a ``for`` loop

   When you learned about function types and lambda expressions, you saw how you could use the
   ``repeat()`` function to execute code multiple times.

   A common task in programming is to perform a task once for each element in a list. Kotlin
   includes a feature called a ``for`` loop to accomplish this with a concise and readable syntax.
   You'll often see this referred to as *looping* through a list or *iterating* over a list.


   ::

            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
      for ( â”‚ element name â”‚ in â”‚ collection name â”‚ ) {
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® 
         â”‚      body    â”‚ 
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ 
      }

   To loop through a list, use the ``for`` keyword, followed by a pair of opening and closing
   parentheses. Within the parentheses, include a variable name, followed by the ``in`` keyword,
   followed by the name of the collection. After the closing parenthesis comes a pair of opening and
   closing curly braces, where you include the code you want executed for each element in the
   collection. This is known as the *body* of the loop. Each time this code executes is known as an
   *iteration*.

   The variable before the ``in`` keyword isn't declared with ``val`` or ``var``â€”it's assumed to be
   get-only. You can name it anything you want. If a list is given a plural name, like ``planets``,
   it's common to name the variable the singular form, such as ``planet``. It's also common to name
   the variable ``item`` or ``element``.

   This will be used as a temporary variable corresponding to the current element in the
   collectionâ€”the element at index ``0`` for the first iteration, element at index ``1`` for the
   second iteration, and so on, and can be accessed within the curly braces.

   To see this in action, you'll print out each planet name on a separate line using a ``for`` loop.

   1. In ``main()``, below the most recent call to ``println()``, add a ``for`` loop. Within the
      parentheses, name the variable ``planet``, and loop through the ``solarSystem`` list.

   .. code:: prettyprint

      for (planet in solarSystem) {
      }

   2. Within the curly braces, print the value of ``planet`` using ``println()``.

   .. code:: prettyprint

      for (planet in solarSystem) {
          println(planet)
      }

   3. Run your code. The code within the body of the loop is executed for each item in the
      collection.

   ::

      ...
      Mercury
      Venus
      Earth
      Mars
      Jupiter
      Saturn
      Uranus
      Neptune


Add elements to a list

   The ability to add, remove, and update elements in a collection is exclusive to classes that
   implement the ``MutableList`` interface. If you were keeping track of newly discovered planets,
   you'd likely want the ability to frequently add elements to a list. You need to specifically call
   the ``mutableListOf()`` function, instead of ``listOf()``, when creating a list you wish to add
   and remove elements from.

   There are two versions of the ``add()`` function:

   -  The first ``add()`` function has a single parameter of the type of element in the list and
      adds it to the end of the list.
   -  The other version of ``add()`` has two parameters. The first parameter corresponds to an index
      at which the new element should be inserted. The second parameter is the element being added
      to the list.

   Let's see both in action.

   1. Change the initialization of ``solarSystem`` to call ``mutableListOf()`` instead of
      ``listOf()``. You can now call methods defined in ``MutableList``.

   .. code:: prettyprint

      val solarSystem = mutableListOf("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")

   2. Again, we might want to classify Pluto as a planet. Call the ``add()`` method on
      ``solarSystem``, passing in ``"Pluto"`` as the single argument.

   .. code:: prettyprint

      solarSystem.add("Pluto")

   3. Some scientists theorize a planet called Theia used to exist before colliding with Earth and
      forming the Moon. Insert ``"Theia"`` at index ``3``, between ``"Earth"`` and ``"Mars"``.

   .. code:: prettyprint

      solarSystem.add(3, "Theia")


Update elements at a specific index

   You can update existing elements with subscript syntax:

   1. Update the value at index ``3`` to ``"Future Moon"``.

   .. code:: prettyprint

      solarSystem[3] = "Future Moon"

   2. Print the value at indexes ``3`` and ``9`` using subscript syntax.

   .. code:: prettyprint

      println(solarSystem[3])
      println(solarSystem[9])

   3. Run your code to verify the output.

   ::

      Future Moon
      Pluto


Remove elements from a list

   Elements are removed using the ``remove()`` or ``removeAt()`` method. You can either remove an
   element by passing it into the ``remove()`` method or by its index using ``removeAt()``.

   Let's see both methods to remove an element in action.

   1. Call ``removeAt()`` on ``solarSystem``, passing in ``9`` for the index. This should remove
      ``"Pluto"`` from the list.

   .. code:: prettyprint

      solarSystem.removeAt(9)

   2. Call ``remove()`` on ``solarSystem``, passing in ``"Future Moon"`` as the element to remove.
      This should search the list, and if a matching element is found, it will be removed.

   .. code:: prettyprint

      solarSystem.remove("Future Moon")

   3. ``List`` provides the ``contains()`` method that returns a ``Boolean`` if an element exists in
      a list. Print the result of calling ``contains()`` for ``"Pluto"``.

   .. code:: prettyprint

      println(solarSystem.contains("Pluto"))

   4. An even more concise syntax is to use the ``in`` operator. You can check if an element is in a
      list using the element, the ``in`` operator, and the collection. Use the ``in`` operator to
      check if ``solarSystem`` contains ``"Future Moon"``.

   .. code:: prettyprint

      println("Future Moon" in solarSystem)

   5. Run your code. Both statements should print ``false``.

   ::

      ...
      false
      false


4. Sets
--------------------------------------------------------------------------------

   A set is a collection that does not have a specific order and does not allow duplicate values.

   ::

               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
               â”‚                                   â”‚
               â”‚       â•­â”€â”€â”€â•®              â•­â”€â”€â”€â•®    â”‚
               â”‚       â”‚ 6 â”‚      â•­â”€â”€â”€â•®   â”‚ 9 â”‚    â”‚
               â”‚       â•°â”€â”€â”€â•¯      â”‚ 3 â”‚   â•°â”€â”€â”€â•¯    â”‚
               â”‚                  â•°â”€â”€â”€â•¯            â”‚
               â”‚    â•­â”€â”€â”€â•®     â•­â”€â”€â”€â•®   â•­â”€â”€â”€â•®        â”‚
               â”‚    â”‚ 8 â”‚     â”‚ 7 â”‚   â”‚ 0 â”‚        â”‚
               â”‚    â•°â”€â”€â”€â•¯     â•°â”€â”€â”€â•¯   â•°â”€â”€â”€â•¯        â”‚
               â”‚          â•­â”€â”€â”€â•®                    â”‚
               â”‚          â”‚ 5 â”‚                    â”‚
               â”‚          â•°â”€â”€â”€â•¯                    â”‚
               â”‚                                   â”‚
               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   How is a collection like this possible? The secret is a *hash code*. A hash code is an ``Int``
   produced by the ``hashCode()`` method of any Kotlin class. It can be thought of as a semi-unique
   identifier for a Kotlin object. A small change to the object, such as adding one character to a
   ``String``, results in a vastly different hash value. While it's possible for two objects to have
   the same hash code (called a hash collision), the ``hashCode()`` function ensures some degree of
   uniqueness, where most of the time, two different values each have a unique hash code.

   .. code:: kotlin

      "Kotlin".hashCode()  // -204170231
      "Kotlin!".hashCode() // 1131585312

   .. Note::

      A set uses hash codes as array indices. Of course, there can be about 4 billion
      different hash codes, so a ``Set`` isn't just one giant array. Instead, you can think of a
      ``Set`` as an array of lists.

      ::

         Outer array. Hash codes turned int array indices
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
               â•­â”€â”€â”€â”€â”€â•®
               â”‚ 101 â”‚
               â•°â”€â”€â”€â”€â”€â•¯        â•­â”€â”€â”€â”€â”€â•®
               â”‚ 102 â”‚ â”€â”€â”€â”€â”€> â”‚ 576 â”‚
               â•°â”€â”€â”€â”€â”€â•¯        â•°â”€â”€â”€â”€â”€â•¯
               â”‚ 103 â”‚
               â•°â”€â”€â”€â”€â”€â•¯        Most of the lists have one element
               â”‚ 104 â”‚
               â•°â”€â”€â”€â”€â”€â•¯        â•­â”€â”€â”€â”€â•®
               â”‚ 105 â”‚ â”€â”€â”€â”€â”€> â”‚ 98 â”‚
               â•°â”€â”€â”€â”€â”€â•¯        â•°â”€â”€â”€â”€â•¯
               â”‚ 106 â”‚
               â•°â”€â”€â”€â”€â”€â•¯
               â”‚ 107 â”‚
               â•°â”€â”€â”€â”€â”€â•¯        â•­â”€â”€â”€â•® â•­â”€â”€â”€â”€â•®
               â”‚ 108 â”‚ â”€â”€â”€â”€â”€> â”‚ 5 â”‚ â”‚ 98 â”‚  Some object have the same hash code
               â•°â”€â”€â”€â”€â”€â•¯        â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â”€â•¯

      The outer arrayâ€”the numbers outlined in blue on the leftâ€”each correspond to a range (also known
      as a bucket) of possible hash codes. Each inner listâ€”shaded in green on the rightâ€”represents the
      individual items in the set. Since hash collisions are relatively uncommon, even when the
      potential indices are limited, the inner lists at each array index will only have one or two
      items each, unless tens or hundreds of thousands of elements are added.

   Sets have two important properties:

   1. Searching for a specific element in a set is fastâ€”compared with listsâ€”especially for large
      collections. While the ``indexOf()`` of a ``List`` requires checking each element from the
      beginning until a match is found, on average, it takes the same amount of time to check if an
      element is in a set, whether it's the first element or the hundred thousandth.
   2. Sets tend to use more memory than lists for the same amount of data, since more array indices
      are often needed than the data in the set.

   **Note:** Contrary to popular belief, the time it takes to check if a set contains an element is
   not fixed, and does in fact, depend on the amount of data in the set. However, as there will
   usually be few hash collisions, the number of elements that need to be checked is still orders of
   magnitude smaller than searching for an item in a list.

   The benefit of sets is ensuring uniqueness. If you were writing a program to keep track of newly
   discovered planets, a set provides a simple way to check if a planet has already been discovered.
   With large amounts of data, this is often preferable to checking if an element exists in a list,
   which requires iterating over all the elements.

   Like ``List`` and ``MutableList``, there's both a ``Set`` and a ``MutableSet``. ``MutableSet``
   implements ``Set``, so any class implementing ``MutableSet`` needs to implement both.

   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
           â”‚    Set     â”‚
           â•°â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â•¯
                  â”‚
           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
           â”‚ MutableSet â”‚
           â•°â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â•¯
                  â”‚
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚  LinkedHashSet â”‚
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

Use a ``MutableSet`` in Kotlin

   We'll use a ``MutableSet`` in the example to demonstrate how to add and remove elements.

   1. Remove the existing code from ``main()``.
   2. Create a ``Set`` of planets called ``solarSystem`` using ``mutableSetOf()``. This returns a
      ``MutableSet``, the default implementation of which is ``LinkedHashSet()``.

   .. code:: prettyprint

      val solarSystem = mutableSetOf("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")

   3. Print the size of the set using the ``size`` property.

   .. code:: prettyprint

      println(solarSystem.size)

   4. Like ``MutableList``, ``MutableSet`` has an ``add()`` method. Add ``"Pluto"`` to the
      ``solarSystem`` set using the ``add()`` method. It only takes a single parameter for the
      element being added. Elements in sets don't necessarily have an order, so there's no index!

   .. code:: prettyprint

      solarSystem.add("Pluto")

   5. Print the ``size`` of the set after adding the element.

   .. code:: prettyprint

      println(solarSystem.size)

   6. The ``contains()`` function takes a single parameter and checks if the specified element is
      contained in the set. If so, it returns true. Otherwise, it returns false. Call ``contains()``
      to check if ``"Pluto"`` is in ``solarSystem``.

   .. code:: prettyprint

      println(solarSystem.contains("Pluto"))

   7. Run your code. The size has increased and ``contains()`` now returns ``true``.

   ::

      8
      9
      true

   **Note**: Alternatively, you can use the ``in`` operator to check if an element is in a
   collection, for example: ``"Pluto" in solarSystem`` is equivalent to
   ``solarSystem.contains("Pluto")``.

   8. As mentioned before, sets can't contain duplicates. Try adding ``"Pluto"`` again.

   .. code:: prettyprint

      solarSystem.add("Pluto")

   9. Print the size of the set again.

   .. code:: prettyprint

      println(solarSystem.size)

   10. Run your code again. ``"Pluto"`` isn't added as it is already in the set. The size should not
       increase this time.

   ::

      ...
      9

   The ``remove()`` function takes a single parameter and removes the specified element from the
   set.

   1. Use the ``remove()`` function to remove ``"Pluto"``.

   .. code:: prettyprint

      solarSystem.remove("Pluto")

   **Note:** Remember that sets are an unordered collection. There's no way to remove a value from a
   set by its index, as sets don't have indices.

   2. Print the size of the collection and call ``contains()`` again to check if ``"Pluto"`` is
      still in the set.

   .. code:: prettyprint

      println(solarSystem.size)
      println(solarSystem.contains("Pluto"))

   3. Run your code. ``"Pluto"`` is no longer in the set and the size is now 8.

   ::

      ...
      8
      false


5. Map collection
--------------------------------------------------------------------------------

   A ``Map`` is a collection consisting of keys and values. It's called a map because unique keys
   are *mapped* to other values. A key and its accompanying value are often called a
   ``key-value pair``.

      ::

         Keys (planets)      Values (moons)
            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®        â•­â”€â”€â”€â”€â•®
            â”‚ Jupiter â”‚ â”€â”€â”€â”€â”€> â”‚ 78 â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯        â•°â”€â”€â”€â”€â•¯

            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®        â•­â”€â”€â”€â•®
            â”‚ Earth   â”‚ â”€â”€â”€â”€â”€> â”‚ 1 â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯        â•°â”€â”€â”€â•¯

            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®        â•­â”€â”€â”€â”€â•®
            â”‚ Neptune â”‚ â”€â”€â”€â”€â”€> â”‚ 14 â”‚
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯        â•°â”€â”€â”€â”€â•¯

   A map's keys are unique. A map's values, however, are not. Two different keys could map to the
   same value. For example, ``"Mercury"`` has ``0`` moons, and ``"Venus"`` has ``0`` moons.

   Accessing a value from a map by its key is generally faster than searching through a large list,
   such as with ``indexOf()``.

   Maps can be declared using the ``mapOf()`` or ``mutableMapOf()`` function. Maps require two
   generic types separated by a commaâ€”one for the keys and another for the values.

   ::

                     â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      mutableMapOf < â”‚ key type â”‚ , â”‚ value type â”‚ > ( )
                     â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   A map can also use type inference if it has initial values. To populate a map with initial
   values, each key value pair consists of the key, followed by the ``to`` operator, followed by the
   value. Each pair is separated by a comma.

   ::

            â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®         
      val   â”‚ map name â”‚ = mapOf(
            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯         
         â•­â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ key â”‚ to â”‚  value  â”‚,
         â•°â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ key â”‚ to â”‚  value  â”‚,
         â•°â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
         â”‚ key â”‚ to â”‚  value  â”‚,
         â•°â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
      )

   Let's take a closer look at how to use maps, and some useful properties and methods.

   1. Remove the existing code from ``main()``.
   2. Create a map called ``solarSystem`` using ``mutableMapOf()`` with initial values as shown.

   .. code:: prettyprint

      val solarSystem = mutableMapOf(
          "Mercury" to 0,
          "Venus" to 0,
          "Earth" to 1,
          "Mars" to 2,
          "Jupiter" to 79,
          "Saturn" to 82,
          "Uranus" to 27,
          "Neptune" to 14
      )

   3. Like lists and sets, ``Map`` provides a ``size`` property, containing the number of key-value
      pairs. Print the size of the ``solarSystem`` map.

   .. code:: prettyprint

      println(solarSystem.size)

   4. You can use subscript syntax to set additional key-value pairs. Set the key ``"Pluto"`` to a
      value of ``5``.

   .. code:: prettyprint

      solarSystem["Pluto"] = 5

   5. Print the size again, after inserting the element.

   .. code:: prettyprint

      println(solarSystem.size)

   6. You can use subscript syntax to get a value. Print the number of moons for the key
      ``"Pluto"``.

   .. code:: prettyprint

      println(solarSystem["Pluto"])

   7. You can also access values with the ``get()`` method. Whether you use subscript syntax or call
      ``get()``, it's possible that the key you pass in isn't in the map. If there isn't a key-value
      pair, it will return null. Print the number of moons for ``"Theia"``.

   .. code:: prettyprint

      println(solarSystem.get("Theia"))

   8. Run your code. The number of moons for Pluto should print. However, because Theia isn't in the
      map, calling ``get()`` returns null.

   ::

      8
      9
      5
      null

   The ``remove()`` method removes the key-value pair with the specified key. It also returns the
   removed value, or ``null``, if the specified key isn't in the map.

   1. Print the result from calling ``remove()`` and passing in ``"Pluto"``.

   .. code:: prettyprint

      solarSystem.remove("Pluto")

   2. To verify that the item was removed, print the size again.

   .. code:: prettyprint

      println(solarSystem.size)

   3. Run your code. The size of the map is 8 after removing the entry.

   ::

      ...
      8

   4. Subscript syntax, or the ``put()`` method, can also modify a value for a key that already
      exists. Use subscript syntax to update Jupiter's moons to 78 and print the new value.

   .. code:: prettyprint

      solarSystem["Jupiter"] = 78
      println(solarSystem["Jupiter"])

   5. Run your code. The value for the existing key, ``"Jupiter"``, is updated.

   ::

      ...
      78


6. Conclusion
--------------------------------------------------------------------------------

   Congratulations! You learned about one of the most foundational data types in programming, the
   array, and several convenient collection types built off of arrays, including ``List``, ``Set``,
   and ``Map``. These collection types allow you to group and organize values in your code. Arrays
   and lists provide fast access to elements by their index, while sets and maps use hash codes to
   make it easier to find elements in the collection. You'll see these collection types used
   frequently in future apps, and knowing how to use them will benefit you in your future
   programming career.


Summary

   -  Arrays store ordered data of the same type, and have a fixed size.
   -  Arrays are used to implement many of the other collection types.
   -  Lists are a resizable, ordered collection.
   -  Sets are unordered collections and cannot contain duplicates.
   -  Maps work similarly to sets and store pairs of keys and values of the specified type.


7. Learn more
--------------------------------------------------------------------------------

   -  `Collections <https://kotlinlang.org/docs/collections-overview.html>`__
   -  `List <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/>`__
   -  `Conditions and loops <https://kotlinlang.org/docs/control-flow.html>`__
   -  `MutableList <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/>`__
   -  `Set <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/>`__
   -  `hashCode() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/hash-code.html>`__
   -  `MutableSet <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-set/>`__
   -  `Map <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/>`__
   -  `MutableMap <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/>`__


â­ Higher-order functions with collections
==========================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-higher-order-functions


1. Introduction
--------------------------------------------------------------------------------

   In the `Use function types and lambda expressions in Kotlin <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-function-types-and-lambda>`__
   codelab, you learned about higher-order functions, which are functions that take other functions
   as parameters and/or return a function, such as ``repeat()``. Higher-order functions are
   especially relevant to collections as they help you perform common tasks, like sorting or
   filtering, with less code. Now that you have a solid foundation working with collections, it's
   time to revisit higher-order functions.

   In this codelab, you'll learn about a variety of functions that can be used on collection types,
   including ``forEach()``, ``map()``, ``filter()``, ``groupBy()``, ``fold()``, and ``sortedBy()``.
   In the process, you'll get additional practice working with lambda expressions.


Prerequisites

   -  Familiarity with function types and lambda expressions.
   -  Familiarity with trailing lambda syntax, such as with the ``repeat()`` function.
   -  Knowledge of various collection types in Kotlin, such as ``List``.


What you'll learn

   -  How to embed lambda expressions into strings.
   -  How to use various higher-order functions with the ``List`` collection, including
      ``forEach()``, ``map()``, ``filter()``, ``groupBy()``, ``fold()``, and ``sortedBy()``.


What you'll need

   -  A web browser with access to the Kotlin Playground.


2. forEach() and string templates with lambdas
--------------------------------------------------------------------------------


Starter code

   In the following examples, you'll take a ``List`` representing a bakery's cookie menu (how
   delicious!), and use higher-order functions to format the menu in different ways.

   Start by setting up the initial code.

   1. Navigate to the `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__.
   2. Above the ``main()`` function, add the ``Cookie`` class. Each instance of ``Cookie``
      represents an item on the menu, with a ``name``, ``price``, and other information about the
      cookie.

   .. code:: prettyprint

      class Cookie(
          val name: String,
          val softBaked: Boolean,
          val hasFilling: Boolean,
          val price: Double
      )

      fun main() {

      }

   3. Below the ``Cookie`` class, outside of ``main()``, create a list of cookies as shown. The type
      is inferred to be ``List<Cookie>``.

   .. code:: prettyprint

      class Cookie(
          val name: String,
          val softBaked: Boolean,
          val hasFilling: Boolean,
          val price: Double
      )

      val cookies = listOf(
          Cookie(
              name = "Chocolate Chip",
              softBaked = false,
              hasFilling = false,
              price = 1.69
          ),
          Cookie(
              name = "Banana Walnut", 
              softBaked = true, 
              hasFilling = false, 
              price = 1.49
          ),
          Cookie(
              name = "Vanilla Creme",
              softBaked = false,
              hasFilling = true,
              price = 1.59
          ),
          Cookie(
              name = "Chocolate Peanut Butter",
              softBaked = false,
              hasFilling = true,
              price = 1.49
          ),
          Cookie(
              name = "Snickerdoodle",
              softBaked = true,
              hasFilling = false,
              price = 1.39
          ),
          Cookie(
              name = "Blueberry Tart",
              softBaked = true,
              hasFilling = true,
              price = 1.79
          ),
          Cookie(
              name = "Sugar and Sprinkles",
              softBaked = false,
              hasFilling = false,
              price = 1.39
          )
      )

      fun main() {

      }


Loop over a list with ``forEach()``

   The first higher-order function that you learn about is the ``forEach()``\ function. The
   ``forEach()`` function executes the function passed as a parameter once for each item in the
   collection. This works similarly to the ``repeat()`` function, or a ``for`` loop. The lambda is
   executed for the first element, then the second element, and so on, until it's executed for each
   element in the collection. The method signature is as follows:

   .. code:: prettyprint

      forEach(action: (T) -> Unit)

   ``forEach()`` takes a single action parameterâ€”a function of type ``(T) -> Unit``.

   ``T`` corresponds to whatever data type the collection contains. Because the lambda takes a
   single parameter, you can omit the name and refer to the parameter with ``it``.

   Use the ``forEach()`` function to print the items in the ``cookies`` list.

   1. In ``main()``, call ``forEach()`` on the ``cookies`` list, using trailing lambda syntax.
      Because the trailing lambda is the only argument, you can omit the parentheses when calling
      the function.

   .. code:: prettyprint

      fun main() {
          cookies.forEach {
              
          }
      }

   2. In the lambda body, add a ``println()`` statement that prints ``it``.

   .. code:: prettyprint

      fun main() {
          cookies.forEach {
              println("Menu item: $it")
          }
      }

   3. Run your code and observe the output. All that prints is the name of the type (``Cookie``),
      and a unique identifier for the object, but not the contents of the object.

   ::

      Menu item: Cookie@5a10411
      Menu item: Cookie@68de145
      Menu item: Cookie@27fa135a
      Menu item: Cookie@46f7f36a
      Menu item: Cookie@421faab1
      Menu item: Cookie@2b71fc7e
      Menu item: Cookie@5ce65a89


Embed expressions in strings

   When you were first introduced to string templates, you saw how the dollar symbol (``$``) could
   be used with a variable name to insert it into a string. However, this doesn't work as expected
   when combined with the dot operator (``.``) to access properties.

   1. In the call to ``forEach()``, modify the lambda's body to insert ``$it.name`` into the string.

   .. code:: prettyprint

      cookies.forEach {
          println("Menu item: $it.name")
      }

   2. Run your code. Notice that this inserts the name of the class, ``Cookie``, and a unique
      identifier for the object followed by ``.name``. The value of the ``name`` property isn't
      accessed.

   ::

      Menu item: Cookie@5a10411.name
      Menu item: Cookie@68de145.name
      Menu item: Cookie@27fa135a.name
      Menu item: Cookie@46f7f36a.name
      Menu item: Cookie@421faab1.name
      Menu item: Cookie@2b71fc7e.name
      Menu item: Cookie@5ce65a89.name

   To access properties and embed them in a string, you need an expression. You can make an
   expression part of a string template by surrounding it with curly braces.

   ::

           â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
      " ${ â”‚ expression â”‚ } "
           â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   The lambda expression is placed between the opening and closing curly braces. You can access
   properties, perform math operations, call functions, etc., and the return value of the lambda is
   inserted into the string.

   Let's modify the code so that the name is inserted into the string.

   1. Surround ``it.name`` in curly braces to make it a lambda expression.

   .. code:: prettyprint

      cookies.forEach {
          println("Menu item: ${it.name}")
      }

   2. Run your code. The output contains the ``name`` of each ``Cookie``.

   ::

      Menu item: Chocolate Chip
      Menu item: Banana Walnut
      Menu item: Vanilla Creme
      Menu item: Chocolate Peanut Butter
      Menu item: Snickerdoodle
      Menu item: Blueberry Tart
      Menu item: Sugar and Sprinkles


3. map()
--------------------------------------------------------------------------------

   The ``map()`` function lets you transform a collection into a new collection with the same number
   of elements. For example, ``map()`` could transform a ``List<Cookie>`` into a ``List<String>``
   only containing the cookie's ``name``, provided you tell the ``map()`` function how to create a
   ``String`` from each ``Cookie`` item.

   ::

             â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•®
             â”‚ 8 â”‚ â”‚ 6 â”‚ â”‚ 7 â”‚ â”‚ 5 â”‚ â”‚ 3 â”‚ â”‚ 0 â”‚ â”‚ 9 â”‚
             â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯
                                 â”‚
                            â•­â”€â”€â”€â”€vâ”€â”€â”€â”€â•®
                            â”‚  map()  â”‚
                            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                 â”‚
      â•­â”€â”€â”€â”€â”€â•® â•­â”€â”€â”€â”€â”€â•® â•­â”€â”€â”€â”€â”€â•® â•­â”€â”€â”€â”€â”€â•® â•­â”€â”€â”€â”€â”€â•® â•­â”€â”€â”€â”€â”€â•® â•­â”€â”€â”€â”€â”€â•®
      â”‚ "8" â”‚ â”‚ "6" â”‚ â”‚ "7" â”‚ â”‚ "5" â”‚ â”‚ "3" â”‚ â”‚ "0" â”‚ â”‚ "9" â”‚
      â•°â”€â”€â”€â”€â”€â•¯ â•°â”€â”€â”€â”€â”€â•¯ â•°â”€â”€â”€â”€â”€â•¯ â•°â”€â”€â”€â”€â”€â•¯ â•°â”€â”€â”€â”€â”€â•¯ â•°â”€â”€â”€â”€â”€â•¯ â•°â”€â”€â”€â”€â”€â•¯

   Let's say you are writing an app that displays an interactive menu for a bakery. When the user
   navigates to the screen that shows the cookie menu, they might want to see the data presented in
   a logical manner, such as the name followed by the price. You can create a list of strings,
   formatted with the relevant data (name and price), using the ``map()`` function.

   1. Remove all the previous code from ``main()``. Create a new variable called ``fullMenu``, and
      set it equal to the result of calling ``map()`` on the ``cookies`` list.

   .. code:: prettyprint

      val fullMenu = cookies.map {
          
      }

   2. In the lambda's body, add a string formatted to include the ``name`` and ``price`` of ``it``.

   .. code:: prettyprint

      val fullMenu = cookies.map {
          "${it.name} - $${it.price}"
      }

   **Note:** There's a second ``$`` used before the expression. The first is treated as the dollar
   sign character ($) since it's not followed by a variable name or lambda expression.

   3. Print the contents of ``fullMenu``. You can do this using ``forEach()``. The ``fullMenu``
      collection returned from ``map()`` has type ``List<String>`` rather than ``List<Cookie>``.
      Each ``Cookie`` in ``cookies`` corresponds to a ``String`` in ``fullMenu``.

   .. code:: prettyprint

      println("Full menu:")
      fullMenu.forEach {
          println(it)
      }

   4. Run your code. The output matches the contents of the ``fullMenu`` list.

   ::

      Full menu:
      Chocolate Chip - $1.69
      Banana Walnut - $1.49
      Vanilla Creme - $1.59
      Chocolate Peanut Butter - $1.49
      Snickerdoodle - $1.39
      Blueberry Tart - $1.79
      Sugar and Sprinkles - $1.39


4. filter()
--------------------------------------------------------------------------------

   The ``filter()`` function lets you create a subset of a collection. For example, if you had a
   list of numbers, you could use ``filter()`` to create a new list that only contains numbers
   divisible by 2.

   ::

               â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•®
               â”‚ 8 â”‚ â”‚ 6 â”‚ â”‚ 7 â”‚ â”‚ 5 â”‚ â”‚ 3 â”‚ â”‚ 0 â”‚ â”‚ 9 â”‚
               â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯
                                   â”‚
                            â•­â”€â”€â”€â”€â”€â”€vâ”€â”€â”€â”€â”€â•®
                            â”‚  filter()  â”‚
                            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                   â”‚
                           â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•®
                           â”‚ 8 â”‚ â”‚ 6 â”‚ â”‚ 0 â”‚
                           â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯

   Whereas the result of the ``map()`` function always yields a collection of the same size,
   ``filter()`` yields a collection of the same size or smaller than the original collection. Unlike
   ``map()``, the resulting collection also has the same data type, so filtering a ``List<Cookie>``
   will result in another ``List<Cookie>``.

   Like ``map()`` and ``forEach()``, ``filter()`` takes a single lambda expression as a parameter.
   The lambda has a single parameter representing each item in the collection and returns a
   ``Boolean`` value.

   For each item in the collection:

   -  If the result of the lambda expression is ``true``, then the item is included in the new
      collection.
   -  If the result is ``false``, the item is not included in the new collection.

   This is useful if you want to get a subset of data in your app. For example, let's say the bakery
   wants to highlight its soft-baked cookies in a separate section of the menu. You can first
   ``filter()`` the ``cookies`` list, before printing the items.

   1. In ``main()``, create a new variable called ``softBakedMenu``, and set it to the result of
      calling ``filter()`` on the ``cookies`` list.

   .. code:: prettyprint

      val softBakedMenu = cookies.filter {
      }

   2. In the lambda's body, add a boolean expression to check if the cookie's ``softBaked`` property
      is equal to ``true``. Because ``softBaked`` is a ``Boolean`` itself, the lambda body only
      needs to contain ``it.softBaked``.

   .. code:: prettyprint

      val softBakedMenu = cookies.filter {
          it.softBaked
      }

   3. Print the contents of ``softBakedMenu`` using ``forEach()``.

   .. code:: prettyprint

      println("Soft cookies:")
      softBakedMenu.forEach {
          println("${it.name} - $${it.price}")
      }

   4. Run your code. The menu is printed as before, but only includes the soft-baked cookies.

   ::

      ...
      Soft cookies:
      Banana Walnut - $1.49
      Snickerdoodle - $1.39
      Blueberry Tart - $1.79


5. groupBy()
--------------------------------------------------------------------------------

   The ``groupBy()`` function can be used to turn a list into a map, based on a function. Each
   unique return value of the function becomes a key in the resulting map. The values for each key
   are all the items in the collection that produced that unique return value.

   ::

             â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â•®
             â”‚  List  â”‚â”€â”€â”€>â”‚  groupBy()  â”‚â”€â”€â”€>â”‚  Map  â”‚
             â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â•¯

   The data type of the keys is the same as the return type of the function passed into
   ``groupBy()``. The data type of the values is a list of items from the original list.

   **Note:** The value doesn't have to be the same type of the list. There's another version of
   ```groupBy()`` <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/group-by.html>`__
   that can transform the values into a different type. However, that version is not covered here.

   This can be hard to conceptualize, so let's start with a simple example. Given the same list of
   numbers as before, group them as odd or even.

   You can check if a number is odd or even by dividing it by ``2`` and checking if the remainder is
   ``0`` or ``1``. If the remainder is ``0``, the number is even. Otherwise, if the remainder is
   ``1``, the number is odd.

   This can be achieved with the modulo operator (``%``). The modulo operator divides the dividend
   on the left side of an expression by the divisor on the right.

   ::

                â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                â”‚  dividend  â”‚â”€â”€â”€>â”‚  divisor  â”‚
                â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

   Instead of returning the result of the division, like the division operator (``/``), the modulo
   operator returns the remainder. This makes it useful for checking if a number is even or odd.

   ::

               â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•®
               â”‚ 8 â”‚ â”‚ 6 â”‚ â”‚ 7 â”‚ â”‚ 5 â”‚ â”‚ 3 â”‚ â”‚ 0 â”‚ â”‚ 9 â”‚
               â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯
                                   â”‚
                        â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€vâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                        â”‚  groupBy { it % 2 } â”‚
                        â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                   â”‚
                   key      value  v
                  â•­â”€â”€â”€â•®    â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•®
                  â”‚ 0 â”‚â”€â”€â”€>â”‚ 8 â”‚ â”‚ 6 â”‚ â”‚ 0 â”‚          even numbers
                  â•°â”€â”€â”€â•¯    â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯
                  â•­â”€â”€â”€â•®    â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•®
                  â”‚ 1 â”‚â”€â”€â”€>â”‚ 7 â”‚ â”‚ 5 â”‚ â”‚ 3 â”‚ â”‚ 9 â”‚    odd numbers
                  â•°â”€â”€â”€â•¯    â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯

   The ``groupBy()`` function is called with the following lambda expression: ``{ it % 2 }``.

   The resulting map has two keys: ``0`` and ``1``. Each key has a value of type ``List<Int>``. The
   list for key ``0`` contains all even numbers, and the list for key ``1`` contains all odd
   numbers.

   A real-world use case might be a photos app that groups photos by the subject or location where
   they were taken. For our bakery menu, let's group the menu by whether or not a cookie is soft
   baked.

   Use ``groupBy()`` to group the menu based on the ``softBaked`` property.

   1. Remove the call to ``filter()`` from the previous step.

   **Code to remove**

   .. code:: prettyprint

      val softBakedMenu = cookies.filter {
          it.softBaked
      }
      println("Soft cookies:")
      softBakedMenu.forEach {
          println("${it.name} - $${it.price}")
      }

   2. Call ``groupBy()`` on the ``cookies`` list, storing the result in a variable called
      ``groupedMenu``.

   .. code:: prettyprint

      val groupedMenu = cookies.groupBy {}

   3. Pass in a lambda expression that returns ``it.softBaked``. The return type will be
      ``Map<Boolean, List<Cookie>>``.

   .. code:: prettyprint

      val groupedMenu = cookies.groupBy { it.softBaked }

   4. Create a ``softBakedMenu`` variable containing the value of ``groupedMenu[true]``, and a
      ``crunchyMenu`` variable containing the value of ``groupedMenu[false]``. Because the result of
      subscripting a ``Map`` is nullable, you can use the Elvis operator (``?:``) to return an empty
      list.

   .. code:: prettyprint

      val softBakedMenu = groupedMenu[true] ?: listOf()
      val crunchyMenu = groupedMenu[false] ?: listOf()

   **Note:** Alternatively, ``emptyList()`` creates an empty list and may be more readable.

   5. Add code to print the menu for soft cookies, followed by the menu for crunchy cookies.

   .. code:: prettyprint

      println("Soft cookies:")
      softBakedMenu.forEach {
          println("${it.name} - $${it.price}")
      }
      println("Crunchy cookies:")
      crunchyMenu.forEach {
          println("${it.name} - $${it.price}")
      }

   6. Run your code. Using the ``groupBy()`` function, you split the list into two, based on the
      value of one of the properties.

   ::

      ...
      Soft cookies:
      Banana Walnut - $1.49
      Snickerdoodle - $1.39
      Blueberry Tart - $1.79
      Crunchy cookies:
      Chocolate Chip - $1.69
      Vanilla Creme - $1.59
      Chocolate Peanut Butter - $1.49
      Sugar and Sprinkles - $1.39

   **Note:** If you only need to split a list in two, an alternative is the
   ```partition()`` <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html>`__
   function.


6. fold()
--------------------------------------------------------------------------------

   The ``fold()`` function is used to generate a single value from a collection. This is most
   commonly used for things like calculating a total of prices, or summing all the elements in a
   list to find an average.


   ::

               â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•®
               â”‚ 8 â”‚ â”‚ 6 â”‚ â”‚ 7 â”‚ â”‚ 5 â”‚ â”‚ 3 â”‚ â”‚ 0 â”‚ â”‚ 9 â”‚
               â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯
                                   â”‚
                            â•­â”€â”€â”€â”€â”€â”€vâ”€â”€â”€â”€â”€â•®
                            â”‚   fold()   â”‚
                            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                   â”‚
                                 â•­â”€â”€â”€â”€â•®
                                 â”‚ 38 â”‚
                                 â•°â”€â”€â”€â”€â•¯

   The ``fold()`` function takes two parameters:

   -  An initial value. The data type is inferred when calling the function (that is, an initial
      value of ``0`` is inferred to be an ``Int``).
   -  A lambda expression that returns a value with the same type as the initial value.

   The lambda expression additionally has two parameters:

   -  The first is known as the accumulator. It has the same data type as the initial value. Think
      of this as a running total. Each time the lambda expression is called, the accumulator is
      equal to the return value from the previous time the lambda was called.
   -  The second is the same type as each element in the collection.

   Like other functions you've seen, the lambda expression is called for each element in a
   collection, so you can use ``fold()`` as a concise way to sum all the elements.

   Let's use ``fold()`` to calculate the total price of all the cookies.

   1. In ``main()``, create a new variable called ``totalPrice`` and set it equal to the result of
      calling ``fold()`` on the ``cookies`` list. Pass in ``0.0`` for the initial value. Its type is
      inferred to be ``Double``.

   .. code:: prettyprint

      val totalPrice = cookies.fold(0.0) {
      }

   2. You'll need to specify both parameters for the lambda expression. Use ``total`` for the
      accumulator, and ``cookie`` for the collection element. Use the arrow (``->``) after the
      parameter list.

   .. code:: prettyprint

      val totalPrice = cookies.fold(0.0) {total, cookie ->
      }

   3. In the lambda's body, calculate the sum of ``total`` and ``cookie.price``. This is inferred to
      be the return value and is passed in for ``total`` the next time the lambda is called.

   .. code:: prettyprint

      val totalPrice = cookies.fold(0.0) {total, cookie ->
          total + cookie.price
      }

   4. Print the value of ``totalPrice``, formatted as a string for readability.

   .. code:: prettyprint

      println("Total price: $${totalPrice}")

   5. Run your code. The result should be equal to the sum of the prices in the ``cookies`` list.

   ::

      ...
      Total price: $10.83

   **Note:** ``fold()`` is sometimes called ``reduce()``. The ``fold()`` function in Kotlin works
   the same as the ``reduce()`` function found in JavaScript, Swift, Python, etc. Note that Kotlin
   also has its own function called `reduce() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reduce.html>`__,
   where the accumulator starts with the first element in the collection, rather than an initial
   value passed as an argument.

   **Note:** Kotlin collections also have a `sum() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sum.html>`__ function
   for numeric types, as well as a higher-order `sumOf() function. <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sum-of.html>`__


7. sortedBy()
--------------------------------------------------------------------------------

   When you first learned about collections, you learned that the ``sort()`` function could be used
   to sort the elements. However, this won't work on a collection of ``Cookie`` objects. The
   ``Cookie`` class has several properties and Kotlin won't know which properties (``name``,
   ``price``, etc.) you want to sort by.

   For these cases, Kotlin collections provide a ``sortedBy()`` function. ``sortedBy()`` lets you
   specify a lambda that returns the property you'd like to sort by. For example, if you'd like to
   sort by ``price``, the lambda would return ``it.price``. So long as the data type of the value
   has a natural sort orderâ€”strings are sorted alphabetically, numeric values are sorted in
   ascending orderâ€”it will be sorted just like a collection of that type.


   ::

               â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•®
               â”‚ 8 â”‚ â”‚ 6 â”‚ â”‚ 7 â”‚ â”‚ 5 â”‚ â”‚ 3 â”‚ â”‚ 0 â”‚ â”‚ 9 â”‚
               â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯
                                   â”‚
                            â•­â”€â”€â”€â”€â”€â”€vâ”€â”€â”€â”€â”€â•®
                            â”‚    sort()  â”‚
                            â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                                   â”‚
                                   v
               â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•® â•­â”€â”€â”€â•®
               â”‚ 0 â”‚ â”‚ 3 â”‚ â”‚ 5 â”‚ â”‚ 6 â”‚ â”‚ 7 â”‚ â”‚ 8 â”‚ â”‚ 9 â”‚
               â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯ â•°â”€â”€â”€â•¯

   You'll use ``sortedBy()`` to sort the list of cookies alphabetically.

   1. In ``main()``, after the existing code, add a new variable called ``alphabeticalMenu`` and set
      it equal to calling ``sortedBy()`` on the ``cookies`` list.

   .. code:: prettyprint

      val alphabeticalMenu = cookies.sortedBy {
      }

   2. In the lambda expression, return ``it.name``. The resulting list will still be of type
      ``List<Cookie>``, but sorted based on the ``name``.

   .. code:: prettyprint

      val alphabeticalMenu = cookies.sortedBy {
          it.name
      }

   3. Print the names of the cookies in ``alphabeticalMenu``. You can use ``forEach()`` to print
      each name on a new line.

   .. code:: prettyprint

      println("Alphabetical menu:")
      alphabeticalMenu.forEach {
          println(it.name)
      }

   4. Run your code. The cookie names are printed in alphabetical order.

   ::

      ...
      Alphabetical menu:
      Banana Walnut
      Blueberry Tart
      Chocolate Chip
      Chocolate Peanut Butter
      Snickerdoodle
      Sugar and Sprinkles
      Vanilla Creme

   **Note:** Kotlin collections also have a
   ```sort()`` <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort.html>`__
   function if the data type has a natural sort order.


8. Conclusion
--------------------------------------------------------------------------------

   Congratulations! You just saw several examples of how higher-order functions can be used with
   collections. Common operations, like sorting and filtering, can be performed in a single line of
   code, making your programs more concise and expressive.


Summary

   -  You can loop over each element in a collection using ``forEach()``.
   -  Expressions can be inserted into strings.
   -  ``map()`` is used to format the items in a collection, often as a collection of another data
      type.
   -  ``filter()`` can generate a subset of a collection.
   -  ``groupBy()`` splits a collection based on a function's return value.
   -  ``fold()`` turns a collection into a single value.
   -  ``sortedBy()`` is used to sort a collection by a specified property.


9. Learn more
--------------------------------------------------------------------------------

   -  `Higher-order functions and lambdas <https://kotlinlang.org/docs/lambdas.html>`__
   -  `forEach() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/for-each.html>`__
   -  `map() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map.html>`__
   -  `filter() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/filter.html>`__
   -  `groupBy() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/group-by.html>`__
   -  `fold() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/fold.html>`__
   -  `sortedBy() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-by.html>`__


â­ Practice: Classes and Collections
=====================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-classes-and-collections


1. Before you begin
--------------------------------------------------------------------------------

   In this pathway, you learned about generics, different types of classes, collections, and
   higher-order functions. To practice what you learned, you'll help your team improve their new
   events tracking app. The instructions for each step describe the current state of the app and the
   task you are expected to complete.

   It's recommended that you use `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__ 
   to solve these exercises.


Prerequisites

   -  Complete `Unit 3 Pathway 1 <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-3-pathway-1>`__
      of the **Android Basics with Compose** course and the pathways before it.
   -  Familiarity with the basics of the Kotlin programming language, including classes, objects,
      collections, and higher-order functions.


What you'll need

   -  A computer with internet access
   -  Access to `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__


2. App overview
--------------------------------------------------------------------------------

   You are the newest software engineer on the events tracking app team. The purpose of this app is
   to allow users to track their events. Your team will assign you tasks in order to help build out
   the app's functionality.

   At the end of each task, you should compare your solution with the one provided. There are
   different ways to achieve the desired functionality, so don't worry if your code doesn't match
   the provided solution code exactly.

   Use the solution code provided in the previous task as the starting code for the next task in
   order to begin at a common starting point.


3. Task 1
--------------------------------------------------------------------------------

   Another software engineer already completed some high-level work for the app and you are tasked
   with implementing the details.

   You need to implement the **``Event``** class. This class is used to hold the details of the
   event entered by the user. (**Hint**: This class does not need to define any methods or perform
   any actions.)

   For this task you need to create a data class named **``Event``**.

   An instance of this class should be able to store the:

   -  Event **title** as a string.
   -  Event **description** as a string (can be null).
   -  Event `daypart <https://en.wikipedia.org/wiki/Dayparting>`__ as a string. We only need to
      track if the event starts in the morning, afternoon, or evening.
   -  Event **duration** in minutes as an integer.

   Before continuing, try writing the code for yourself.

   Using your code, create an instance using the following information:

   -  **Title**: Study Kotlin
   -  **Description**: Commit to studying Kotlin at least 15 minutes per day.
   -  **Daypart**: Evening
   -  **Duration**: 15

   Try printing your object to verify that you get the following output:

   ::

      Event(title=Study Kotlin, description=Commit to studying Kotlin at least 15 minutes per day., daypart=Evening, durationInMinutes=15)

   Once you complete the task, or give it your best attempt, click **Next** to see how we coded it.


4. Task 1 Solution
--------------------------------------------------------------------------------

   Your solution should be similar to the following code:

   .. code:: prettyprint

      data class Event(
          val title: String,
          val description: String? = null,
          val daypart: String,
          val durationInMinutes: Int,
      )


5. Task 2
--------------------------------------------------------------------------------

   To keep the project on track, your manager decides to use the code we provided for the data
   class.

   After your team members used the ``Event`` class for some time, the senior teammate realizes that
   using a string for the daypart is not ideal.

   Some developers stored the value of "Morning", some used "morning", and still others used
   "MORNING".

   This caused many problems.

   Your task is to fix this issue by doing some `refactoring <https://en.wikipedia.org/wiki/Code_refactoring>`__.
   Refactoring is the process of improving your code without changing its functionality.
   Some examples are simplifying the logic or moving repeated code into separate functions.

   What type of class can be used to model a limited set of distinct values to help correct this
   problem?

   Your team wants you to change the daypart code to use an enum class. By using an enum class, your
   teammates are forced to choose one of the provided daypart values, which prevents these types of
   issues.

   The enum class should be named ``Daypart``. It should have three values:

   -  ``MORNING``
   -  ``AFTERNOON``
   -  ``EVENING``

   How would you create this enum class?

   How would you refactor your ``Event`` class to use it?

   Try coding your solution now before continuing.

   Click **Next** to see how we coded it.


6. Task 2 Solution
--------------------------------------------------------------------------------

   .. code:: prettyprint

      enum class Daypart {
          MORNING,
          AFTERNOON,
          EVENING,
      }

   The refactored ``Event`` data class now uses the enum class:

   .. code:: prettyprint

      data class Event(
          val title: String,
          val description: String? = null,
          val daypart: Daypart,
          val durationInMinutes: Int,
      )


7. Task 3
--------------------------------------------------------------------------------

   Your colleagues enjoy using the refactored ``Daypart``, but they have other issues.

   The following code is how they currently create and store the user's events.

   .. code:: prettyprint

      val event1 = Event(title = "Wake up", description = "Time to get up", daypart = Daypart.MORNING, durationInMinutes = 0)
      val event2 = Event(title = "Eat breakfast", daypart = Daypart.MORNING, durationInMinutes = 15)
      val event3 = Event(title = "Learn about Kotlin", daypart = Daypart.AFTERNOON, durationInMinutes = 30)
      val event4 = Event(title = "Practice Compose", daypart = Daypart.AFTERNOON, durationInMinutes = 60)
      val event5 = Event(title = "Watch latest DevBytes video", daypart = Daypart.AFTERNOON, durationInMinutes = 10)
      val event6 = Event(title = "Check out latest Android Jetpack library", daypart = Daypart.EVENING, durationInMinutes = 45)

   They created a lot of events, and each event currently requires its own variable. As more events
   are created, it becomes more difficult to keep track of them all. Using this approach, how
   difficult would it be to determine how many events the user scheduled?

   Can you think of a better way to organize the storage of these events?

   What way can you store all the events in one variable? (**Note**: It has to be flexible, as more
   events may be added. It also needs to efficiently return the count of the number of the events
   stored in the variable.)

   Which class or data type would you use? What is one way to add more events?

   Now it's your turn to implement this feature. Try to write the code before clicking **Next** to
   see our solution.


8. Task 3 Solution
--------------------------------------------------------------------------------

   .. code:: prettyprint

      val events = mutableListOf<Event>(event1, event2, event3, event4, event5, event6)


9. Task 4
--------------------------------------------------------------------------------

   Your manager likes how the app is coming along, but decides the user should be able to see a
   summary of their **short** events, based on the event's duration. For example, "You have 5 short
   events."

   A "short" event is an event that is less than 60 minutes.

   Using the ``events`` variable code from the previous task's solution, how would you achieve this
   result?

   **Note:** It might help to solve this problem in multiple steps. How would you filter the events
   based on their duration? Once you filter the desired events, how do you determine the quantity?

   Click **Next** to continue onto our solution.


10. Task 4 Solution
--------------------------------------------------------------------------------

   There are multiple ways this can be accomplished, and the following is what we decided on:

   .. code:: prettyprint

      val shortEvents = events.filter { it.durationInMinutes < 60 }
      println("You have ${shortEvents.size} short events.")


11. Task 5
--------------------------------------------------------------------------------

   Your teammates like how the app is coming along, but they want users to be able to see a summary
   of all the events and their daypart.

   The output should be similar to:

   ::

      Morning: 3 events
      Afternoon: 4 events
      Evening: 2 events

   Using the ``events`` variable code from the previous step, how can you achieve this result?

   **Note:** It might help to solve this problem in multiple steps. This is similar to the previous
   task, except instead of splitting the events into two groups, you need to split them into
   multiple groups. How would you group the events by their dayparts? Once you have them grouped,
   how do you count the events in each daypart?

   Click **Next** to see the solution code.


12. Task 5 Solution
--------------------------------------------------------------------------------

   The following is our solution, but other variations are acceptable.

   .. code:: prettyprint

      val groupedEvents = events.groupBy { it.daypart }
      groupedEvents.forEach { (daypart, events) ->
          println("$daypart: ${events.size} events")
      }


13. Task 6
--------------------------------------------------------------------------------

   Currently, your colleague finds and prints the last item by using its index. The code used is:
   ``println("Last event of the day: ${events[events.size - 1].title}")``.

   Your manager suggests checking the `Kotlin documentation <https://kotlinlang.org/docs/collection-elements.html#retrieve-by-position>`__
   for a function that could simplify this code.

   What function did you find?

   Try using it to confirm you get the same results to print.

   Click **Next** to see the solution.


14. Task 6 Solution
--------------------------------------------------------------------------------

   .. code:: prettyprint

      println("Last event of the day: ${events.last().title}")


15. Task 7
--------------------------------------------------------------------------------

   Your team likes the data class you designed, but finds it repetitive to write code each time they
   need an event's duration as a string:

   .. code:: prettyprint

      val durationOfEvent = if (events[0].durationInMinutes < 60) {
              "short"
          } else {
              "long"
          }
      println("Duration of first event of the day: $durationOfEvent")

   While you could fix this repetition by adding a method directly to the class, that is not ideal,
   as other teams started using your event class in their apps. If the class changes, they would
   need to retest all of their code to make sure nothing breaks because of your change.

   Without directly changing the data class, how can you write an extension property that returns
   the same values as the code above?

   When correctly implemented, you will be able to use the following code, and it will print the
   same message as the code shown at the start of this task.

   .. code:: prettyprint

      println("Duration of first event of the day: ${events[0].durationOfEvent}")

   Click **Next** to continue to the solution.


16. Task 7 Solution
--------------------------------------------------------------------------------

   .. code:: prettyprint

      val Event.durationOfEvent: String
          get() = if (this.durationInMinutes < 60) {
              "short"
          } else {
              "long"
          }


17. Additional Practice
--------------------------------------------------------------------------------

   For more practice on the Kotlin language, check out the 
   `Kotlin Core track by JetBrains Academy <https://hyperskill.org/tracks/18>`__.
   To jump to a specific topic, go to the `knowledge map <https://hyperskill.org/knowledge-map>`__
   to view the list of topics covered in the track.


â­ Introduction to Coroutines in Kotlin Playground
===================================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-coroutines-kotlin-playground


1. Before you begin
-------------------

   This codelab introduces you to concurrency, which is a critical skill for Android developers to
   understand in order to deliver a great user experience. **Concurrency** involves performing
   multiple tasks in your app at the same time. For example, your app can get data from a web server
   or save user data on the device, while responding to user input events and updating the UI
   accordingly.

   To do work concurrently in your app, you will be using Kotlin **coroutines**. Coroutines allow
   the execution of a block of code to be suspended and then resumed later, so that other work can
   be done in the meantime. Coroutines make it easier to write **asynchronous** code, which means
   one task doesn't need to finish completely before starting the next task, enabling multiple tasks
   to run concurrently.

   This codelab walks you through some basic examples in the Kotlin Playground, where you get
   hands-on practice with coroutines to become more comfortable with asynchronous programming.


Prerequisites

   -  Able to create a basic Kotlin program with a ``main()`` function
   -  Knowledge of Kotlin language basics, including functions and lambdas


**What you'll build**

   -  Short Kotlin program to learn and experiment with the basics of coroutines


What you'll learn

   -  How Kotlin coroutines can simplify asynchronous programming
   -  The purpose of structured concurrency and why it matters


What you'll need

   -  Internet access to use `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__


2. Synchronous code
-------------------


Simple Program
~~~~~~~~~~~~~~

   In **synchronous** code, only one conceptual task is in progress at a time. You can think of it
   as a sequential linear path. One task must finish completely before the next one is started.
   Below is an example of synchronous code.

   1. Open up `Kotlin Playground <https://developer.android.google.cn/training/kotlinplayground>`__.
   2. Replace the code with the following code for a program that shows a weather forecast of sunny
      weather. In the ``main()`` function, first we print out the text: ``Weather forecast``. Then
      we print out: ``Sunny``.

   .. code:: prettyprint

      fun main() {
          println("Weather forecast")
          println("Sunny")
      }

   3. Run the code. The output from running the above code should be:

   ::

      Weather forecast
      Sunny

   ``println()`` is a synchronous call because the task of printing the text to the output is
   completed before execution can move to the next line of code. Because each function call in
   ``main()`` is synchronous, the entire ``main()`` function is synchronous. Whether a function is
   synchronous or asynchronous is determined by the parts that it's composed of.

   A synchronous function returns only when its task is fully complete. So after the last print
   statement in ``main()`` is executed, all work is done. The ``main()`` function returns and the
   program ends.


Add a delay
~~~~~~~~~~~

   Now let's pretend that getting the weather forecast of sunny weather requires a network request
   to a remote web server. Simulate the network request by adding a delay in the code before
   printing that the weather forecast is sunny.

   1. First, add ``import kotlinx.coroutines.*`` at the top of your code before the ``main()``
      function. This imports functions you will be using from the Kotlin coroutines library.
   2. Modify your code to add a call to ``delay(1000)``, which delays execution of the remainder of
      the ``main()`` function by ``1000`` milliseconds, or 1 second. Insert this ``delay()`` call
      before the print statement for ``Sunny``.

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          println("Weather forecast")
          delay(1000)
          println("Sunny")
      }

   ``delay()`` is actually a special **suspending function** provided by the Kotlin coroutines
   library. Execution of the ``main()`` function will suspend (or pause) at this point, and then
   resume once the specified duration of the delay is over (one second in this case).

   If you try to run your program at this point, there will be a compile error:
   ``Suspend function 'delay' should be called only from a coroutine or another suspend function``.

   For the purposes of learning coroutines within the Kotlin Playground, you can wrap your existing
   code with a call to the ``runBlocking()`` function from the coroutines library. ``runBlocking()``
   runs an event loop, which can handle multiple tasks at once by continuing each task where it left
   off when it's ready to be resumed.

   3. Move the existing contents of the ``main()`` function into the body of the ``runBlocking {}``
      call. The body of ``runBlocking{}`` is executed in a new coroutine.

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              delay(1000)
              println("Sunny")
          }
      }

   ``runBlocking()`` is synchronous; it will not return until all work within its lambda block is
   completed. That means it will wait for the work in the ``delay()`` call to complete (until one
   second elapses), and then continue with executing the ``Sunny`` print statement. Once all the
   work in the ``runBlocking()`` function is complete, the function returns, which ends the program.

   4. Run the program. Here's the output:

   ::

      Weather forecast
      Sunny

   The output is the same as before. The code is still synchronous - it runs in a straight line and
   only does one thing at a time. However, the difference now is that it runs over a longer period
   of time due to the delay.

   The "co-" in coroutine means cooperative. The code cooperates to share the underlying event loop
   when it suspends to wait for something, which allows other work to be run in the meantime. (The
   "-routine" part in "coroutine" means a set of instructions like a function.) In the case of this
   example, the coroutine suspends when it reaches the ``delay()`` call. Other work can be done in
   that one second when the coroutine is suspended (even though in this program, there is no other
   work to do). Once the duration of the delay elapses, then the coroutine resumes execution and can
   proceed with printing ``Sunny`` to the output.

   **Note:** In general, only use ``runBlocking()`` within a ``main()`` function like this for
   learning purposes. In your Android app code, you do not need ``runBlocking()`` because Android
   provides an event loop for your app to process resumed work when it becomes ready.
   ``runBlocking()`` can be useful in your tests, however, and can let your test await specific
   conditions in your app before invoking the test assertions.


Suspending functions
~~~~~~~~~~~~~~~~~~~~

   If the actual logic to perform the network request to get the weather data becomes more complex,
   you may want to extract that logic out into its own function. Let's refactor the code to see its
   effect.

   1. Extract the code that simulates the network request for the weather data and move it into its
      own function called ``printForecast()``. Call ``printForecast()`` from the ``runBlocking()``
      code.

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              printForecast()
          }
      }

      fun printForecast() {
          delay(1000)
          println("Sunny")
      }

   If you run the program now, you will see the same compile error you saw earlier. A suspend
   function can only be called from a coroutine or another suspend function, so define
   ``printForecast()`` as a ``suspend`` function.

   2. Add the ``suspend`` modifier just before the ``fun`` keyword in the ``printForecast()``
      function declaration to make it a suspending function.

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              printForecast()
          }
      }

      suspend fun printForecast() {
          delay(1000)
          println("Sunny")
      }

   Remember that ``delay()`` is a suspending function, and now you've made ``printForecast()`` a
   suspending function too.

   A **suspending** function is like a regular function, but it can be suspended and resumed again
   later. To do this, suspend functions can only be called from other suspend functions that make
   this capability available.

   A suspending function may contain zero or more suspension points. A **suspension point** is the
   place within the function where execution of the function can suspend. Once execution resumes, it
   picks up where it last left off in the code and proceeds with the rest of the function.

   3. Practice by adding another suspending function to your code, below the declaration of the
      ``printForecast()`` function. Call this new suspending function ``printTemperature()``. You
      can pretend that this does a network request to get the temperature data for the weather
      forecast.

   Within the function, delay execution by ``1000`` milliseconds as well, and then print a
   temperature value to the output, such as ``30`` degrees Celsius. You can use the escape sequence
   ``"\u00b0"`` to print out the degree symbol, ``Â°``.

   .. code:: prettyprint

      suspend fun printTemperature() {
          delay(1000)
          println("30\u00b0C")
      }

   4. Call the new ``printTemperature()`` function from your ``runBlocking()`` code in the
      ``main()`` function. Here's the full code:

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              printForecast()
              printTemperature()
          }
      }

      suspend fun printForecast() {
          delay(1000)
          println("Sunny")
      }

      suspend fun printTemperature() {
          delay(1000)
          println("30\u00b0C")
      } 

   5. Run the program. The output should be:

   ::

      Weather forecast
      Sunny
      30Â°C

   In this code, the coroutine is first suspended with the delay in the ``printForecast()`` suspend
   function, and then resumes after that one-second delay. The ``Sunny`` text is printed to the
   output. The ``printForecast()`` function returns back to the caller.

   Next the ``printTemperature()`` function gets called. That coroutine suspends when it reaches the
   ``delay()`` call, and then resumes one second later and finishes printing the temperature value
   to the output. ``printTemperature()`` function has completed all work and returns.

   In the ``runBlocking()`` body, there are no further tasks to execute, so the ``runBlocking()``
   function returns, and the program ends.

   As mentioned earlier, ``runBlocking()`` is synchronous and each call in the body will be called
   sequentially. Note that a well-designed suspending function returns only once all work has been
   completed. As a result, these suspending functions run one after the other.

   6. (Optional) If you want to see how long it takes to execute this program with the delays, then
      you can wrap your code in a call to ``measureTimeMillis()`` which will return the time it in
      milliseconds that it takes to run the block of code passed in. Add the import statement
      (``import kotlin.system.*``) to have access to this function. Print out the execution time and
      divide by ``1000.0`` to convert milliseconds to seconds.

   .. code:: prettyprint

      import kotlin.system.*
      import kotlinx.coroutines.*

      fun main() {
          val time = measureTimeMillis {
              runBlocking {
                  println("Weather forecast")
                  printForecast()
                  printTemperature()
              }
          }
          println("Execution time: ${time / 1000.0} seconds")
      }
      suspend fun printForecast() {
          delay(1000)
          println("Sunny")
      }

      suspend fun printTemperature() {
          delay(1000)
          println("30\u00b0C")
      } 

   Output:

   ::

      Weather forecast
      Sunny
      30Â°C
      Execution time: 2.128 seconds

   The output shows that it took ~ 2.1 seconds to execute. (The precise execution time could be
   slightly different for you.) That seems reasonable because each of the suspending functions has a
   one-second delay.

   So far, you've seen that the code in a coroutine is invoked sequentially by default. You have to
   be explicit if you want things to run concurrently, and you will learn how to do that in the next
   section. You will make use of the cooperative event loop to perform multiple tasks at the same
   time, which will speed up the execution time of the program.


3. Asynchronous code
--------------------


**launch()**
~~~~~~~~~~~~

   Use the ``launch()`` function from the coroutines library to launch a new coroutine. To execute
   tasks concurrently, add multiple ``launch()`` functions to your code so that multiple coroutines
   can be in progress at the same time.

   Coroutines in Kotlin follow a key concept called `structured concurrency <https://kotlinlang.org/docs/coroutines-basics.html#structured-concurrency>`__, 
   where your code is sequential by default and cooperates with an underlying event loop, unless you
   explicitly ask for concurrent execution (e.g. using ``launch()``). The assumption is that if you
   call a function, it should finish its work completely by the time it returns regardless of how
   many coroutines it may have used in its implementation details. Even if it fails with an
   exception, once the exception is thrown, there are no more pending tasks from the function.
   Hence, all work is finished once control flow returns from the function, whether it threw an
   exception or completed its work successfully.

   1. Start with your code from earlier steps. Use the ``launch()`` function to move each call to
      ``printForecast()`` and ``printTemperature()`` respectively into their own coroutines.

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              launch {
                  printForecast()
              }
              launch {
                  printTemperature()
              }
          }
      }

      suspend fun printForecast() {
          delay(1000)
          println("Sunny")
      }

      suspend fun printTemperature() {
          delay(1000)
          println("30\u00b0C")
      } 

   2. Run the program. Here's the output:

   ::

      Weather forecast
      Sunny
      30Â°C

   The output is the same but you may have noticed that it is faster to run the program. Previously,
   you had to wait for the ``printForecast()`` suspend function to finish completely before moving
   onto the ``printTemperature()`` function. Now ``printForecast()`` and ``printTemperature()`` can
   run concurrently because they are in separate coroutines.

   |The println (Weather Forecast) statement is in a box at the top of the diagram. Below it, there
   is a vertical arrow pointing straight down. Off that vertical arrow, there is a branch going to
   the right with an arrow pointing to a box that contains the statement printForecast(). Off that
   original vertical arrow, there is also another branch going to the right with an arrow pointing
   to a box that contains the statement printTemperature().|

   The call to ``launch { printForecast() }`` can return before all the work in ``printForecast()``
   is completed. That is the beauty of coroutines. You can move onto the next ``launch()`` call to
   start the next coroutine. Similarly, the ``launch { printTemperature() }`` also returns even
   before all work is completed.

   3. (Optional) If you want to see how much faster the program is now, you could add the
      ``measureTimeMillis()`` code to check the execution time.

   .. code:: prettyprint

      import kotlin.system.*
      import kotlinx.coroutines.*

      fun main() {
          val time = measureTimeMillis {
              runBlocking {
                  println("Weather forecast")
                  launch {
                      printForecast()
                  }
                  launch {
                      printTemperature()
                  }
              }
          }
          println("Execution time: ${time / 1000.0} seconds")
      }

      ...

   Output:

   ::

      Weather forecast
      Sunny
      30Â°C
      Execution time: 1.122 seconds

   You can see that the execution time has gone down from ~ 2.1 seconds to ~ 1.1 seconds, so it's
   faster to execute the program once you add concurrent operations! You can remove this time
   measurement code before moving onto the next steps.

   What do you think happens if you add another print statement after the second ``launch()`` call,
   before the end of the ``runBlocking()`` code? Where would that message appear in the output?

   4. Modify the ``runBlocking()`` code to add an additional print statement before the end of that
      block.

   .. code:: prettyprint

      ...

      fun main() {
          runBlocking {
              println("Weather forecast")
              launch {
                  printForecast()
              }
              launch {
                  printTemperature()
              }
              println("Have a good day!")
          }
      }

      ...

   5. Run the program and here's the output:

   ::

      Weather forecast
      Have a good day!
      Sunny
      30Â°C

   From this output, you can observe that after the two new coroutines are launched for
   ``printForecast()`` and ``printTemperature()``, you can proceed with the next instruction which
   prints ``Have a good day!``. This demonstrates the "fire and forget" nature of ``launch()``. You
   fire off a new coroutine with ``launch()``, and don't have to worry about when its work is
   finished.

   Later the coroutines will complete their work, and print the remaining output statements. Once
   all the work (including all coroutines) in the body of the ``runBlocking()`` call have been
   completed, then ``runBlocking()`` returns and the program ends.

   Now you've changed your synchronous code into **asynchronous** code. When an asynchronous
   function returns, the task may not be finished yet. This is what you saw in the case of
   ``launch()``. The function returned, but its work was not completed yet. By using ``launch()``,
   multiple tasks can run concurrently in your code, which is a powerful capability to use in the
   Android apps you develop.


async()
~~~~~~~

   In the real world, you won't know how long the network requests for forecast and temperature will
   take. If you want to display a unified weather report when both tasks are done, then the current
   approach with ``launch()`` isn't sufficient. That's where ``async()`` comes in.

   Use the ``async()`` function from the coroutines library if you care about when the coroutine
   finishes and need a return value from it.

   The ``async()`` function returns an object of type ``Deferred``, which is like a promise that the
   result will be in there when it's ready. You can access the result on the ``Deferred`` object
   using ``await()``.

   1. First change your suspending functions to return a ``String`` instead of printing the forecast
      and temperature data. Update the function names from ``printForecast()`` and
      ``printTemperature()`` to ``getForecast()`` and ``getTemperature()``.

   .. code:: prettyprint

      ...

      suspend fun getForecast(): String {
          delay(1000)
          return "Sunny"
      }

      suspend fun getTemperature(): String {
          delay(1000)
          return "30\u00b0C"
      }

   2. Modify your ``runBlocking()`` code so that it uses ``async()`` instead of ``launch()`` for the
      two coroutines. Store the return value of each ``async()`` call in variables called
      ``forecast`` and ``temperature``, which are ``Deferred`` objects that hold a result of type
      ``String``. (Specifying the type is optional because of type inference in Kotlin, but it's
      included below so you can more clearly see what's being returned by the ``async()`` calls.)

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              val forecast: Deferred<String> = async {
                  getForecast()
              }
              val temperature: Deferred<String> = async {
                  getTemperature()
              }
              ...
          }
      }

      ...

   3. Later in the coroutine, after the two ``async()`` calls, you can access the result of those
      coroutines by calling ``await()`` on the ``Deferred`` objects. In this case, you can print the
      value of each coroutine using ``forecast.await()`` and ``temperature.await()``.

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              val forecast: Deferred<String> = async {
                  getForecast()
              }
              val temperature: Deferred<String> = async {
                  getTemperature()
              }
              println("${forecast.await()} ${temperature.await()}")
              println("Have a good day!")
          }
      }

      suspend fun getForecast(): String {
          delay(1000)
          return "Sunny"
      }

      suspend fun getTemperature(): String {
          delay(1000)
          return "30\u00b0C"
      }

   4. Run the program and the output will be:

   ::

      Weather forecast
      Sunny 30Â°C
      Have a good day!

   Neat! You created two coroutines that ran concurrently to get the forecast and temperature data.
   When they each completed, they returned a value. Then you combined the two return values into a
   single print statement: ``Sunny 30Â°C``.

   **Note:** As a real-world example of ``async(),`` you can check out this part of the `Now in
   Android app <https://github.com/android/nowinandroid>`__. In the
   `SyncWorker <https://github.com/android/nowinandroid/blob/main/sync/work/src/main/java/com/google/samples/apps/nowinandroid/sync/workers/SyncWorker.kt#L65>`__
   class, the call to ``sync()`` returns a boolean if the sync to a particular backend was
   successful. If any of the sync operations failed, then the app needs to perform a retry.


**Parallel Decomposition**
~~~~~~~~~~~~~~~~~~~~~~~~~~

   We can take this weather example a step further and see how coroutines can be useful in parallel
   decomposition of work. Parallel decomposition involves taking a problem and breaking it into
   smaller subtasks that can be solved in parallel. When the results of the subtasks are ready, you
   can combine them into a final result.

   In your code, extract out the logic of the weather report from the body of ``runBlocking()`` into
   a single ``getWeatherReport()`` function that returns the combined string of ``Sunny 30Â°C``.

   1. Define a new suspending function ``getWeatherReport()`` in your code.
   2. Set the function equal to the result of a call to the ``coroutineScope{}`` function with an
      empty lambda block that will eventually contain logic for getting the weather report.

   .. code:: prettyprint

      ...

      suspend fun getWeatherReport() = coroutineScope {
          
      }

      ...

   ``coroutineScope{}`` creates a local scope for this weather report task. The coroutines launched
   within this scope are grouped together within this scope, which has implications for cancellation
   and exceptions that you'll learn about soon.

   3. Within the body of the ``coroutineScope()``, create two new coroutines using ``async()`` to
      fetch the forecast and temperature data, respectively. Create the weather report string by
      combining these results from the two coroutines. Do this by calling ``await()`` on each of the
      ``Deferred`` objects returned by the ``async()`` calls. This ensures that each coroutine
      completes its work and returns its result, before we return from this function.

   .. code:: prettyprint

      ...

      suspend fun getWeatherReport() = coroutineScope {
          val forecast = async { getForecast() }
          val temperature = async { getTemperature() }
          "${forecast.await()} ${temperature.await()}"
      }

      ...

   4. Call this new ``getWeatherReport()`` function from ``runBlocking()``. Here's the full code:

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              println(getWeatherReport())
              println("Have a good day!")
          }
      }

      suspend fun getWeatherReport() = coroutineScope {
          val forecast = async { getForecast() }
          val temperature = async { getTemperature() }
          "${forecast.await()} ${temperature.await()}"
      }

      suspend fun getForecast(): String {
          delay(1000)
          return "Sunny"
      }

      suspend fun getTemperature(): String {
          delay(1000)
          return "30\u00b0C"
      }

   5. Run the program and you see this output:

   ::

      Weather forecast
      Sunny 30Â°C
      Have a good day!

   The output is the same, but there are some noteworthy takeaways here. As mentioned earlier,
   ``coroutineScope()`` will only return once all its work, including any coroutines it launched,
   have completed. In this case, both coroutines ``getForecast()`` and ``getTemperature()`` need to
   finish and return their respective results. Then the ``Sunny`` text and ``30Â°C`` are combined and
   returned from the scope. This weather report of ``Sunny 30Â°C`` gets printed to the output, and
   the caller can proceed to the last print statement of ``Have a good day!``.

   With ``coroutineScope()``, even though the function is internally doing work concurrently, it
   appears to the caller as a synchronous operation because ``coroutineScope`` won't return until
   all work is done.

   The key insight here for structured concurrency is that you can take multiple concurrent
   operations and put it into a single synchronous operation, where concurrency is an implementation
   detail. The only requirement on the calling code is to be in a suspend function or coroutine.
   Other than that, the structure of the calling code doesn't need to take into account the
   concurrency details.


4. Exceptions and cancellation
------------------------------

   Now let's talk about some situations where an error may occur, or some work may be cancelled.


Introduction to exceptions
~~~~~~~~~~~~~~~~~~~~~~~~~~

   An `exception <https://kotlinlang.org/docs/exceptions.html>`__ is an unexpected event that
   happens during execution of your code. You should implement appropriate ways of handling these
   exceptions, to prevent your app from crashing and impacting the user experience negatively.

   Here's an example of a program that terminates early with an exception. The program is intended
   to calculate the number of pizzas each person gets to eat, by dividing
   ``numberOfPizzas / numberOfPeople``. Say you accidentally forget to set the value of the
   ``numberOfPeople`` to an actual value.

   .. code:: prettyprint

      fun main() {
          val numberOfPeople = 0
          val numberOfPizzas = 20
          println("Slices per person: ${numberOfPizzas / numberOfPeople}")
      }

   When you run the program, it will crash with an arithmetic exception because you can't divide a
   number by zero.

   ::

      Exception in thread "main" java.lang.ArithmeticException: / by zero
       at FileKt.main (File.kt:4) 
       at FileKt.main (File.kt:-1) 
       at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0 (:-2)

   This issue has a straightforward fix, where you can change the initial value of
   ``numberOfPeople`` to a non-zero number. However, as your code gets more complex, there are
   certain cases where you can't anticipate and prevent all exceptions from happening.

   What happens when one of your coroutines fails with an exception? Modify the code from the
   weather program to find out.


Exceptions **with coroutines**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   1. Start with the weather program from the previous section.

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              println(getWeatherReport())
              println("Have a good day!")
          }
      }

      suspend fun getWeatherReport() = coroutineScope {
          val forecast = async { getForecast() }
          val temperature = async { getTemperature() }
          "${forecast.await()} ${temperature.await()}"
      }

      suspend fun getForecast(): String {
          delay(1000)
          return "Sunny"
      }

      suspend fun getTemperature(): String {
          delay(1000)
          return "30\u00b0C"
      }

   Within one of the suspending functions, intentionally throw an exception to see what the effect
   would be. This simulates that an unexpected error happened when fetching data from the server,
   which is plausible.

   2. In the ``getTemperature()`` function, add a line of code that throws an exception. Write a
      throw expression using the ``throw`` keyword in Kotlin followed by a new instance of an
      exception which extends from `Throwable <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/>`__.

   For example, you can throw an ``AssertionError`` and pass in a message string that describes the
   error in more detail: ``throw AssertionError("Temperature is invalid")``. Throwing this exception
   stops further execution of the ``getTemperature()`` function.

   .. code:: prettyprint

      ...

      suspend fun getTemperature(): String {
          delay(500)
          throw AssertionError("Temperature is invalid")
          return "30\u00b0C"
      }

   You can also change the delay to ``500`` milliseconds for the ``getTemperature()`` method, so
   that you know the exception will occur before the other ``getForecast()`` function can complete
   its work.

   3. Run the program to see the result.

   ::

      Weather forecast
      Exception in thread "main" java.lang.AssertionError: Temperature is invalid
       at FileKt.getTemperature (File.kt:24) 
       at FileKt$getTemperature$1.invokeSuspend (File.kt:-1) 
       at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith (ContinuationImpl.kt:33) 

   To understand this behavior, you'll need to know that there is a parent-child relationship among
   coroutines. You can launch a coroutine (known as the child) from another coroutine (parent). As
   you launch more coroutines from those coroutines, you can build up a whole hierarchy of
   coroutines.

   The coroutine executing ``getTemperature()`` and the coroutine executing ``getForecast()`` are
   child coroutines of the same parent coroutine. The behavior you're seeing with exceptions in
   coroutines is due to structured concurrency. When one of the child coroutines fails with an
   exception, it gets propagated upwards. The parent coroutine is cancelled, which in turn cancels
   any other child coroutines (e.g. the coroutine running ``getForecast()`` in this case). Lastly,
   the error gets propagated upwards and the program crashes with the ``AssertionError``.


Try-catch exceptions

   If you know that certain parts of your code can possibly throw an exception, then you can
   surround that code with a `try-catch <https://kotlinlang.org/docs/exceptions.html>`__ block. You
   can catch the exception and handle it more gracefully in your app, such as by showing the user a
   helpful error message. Here's a code snippet of how it might look:

   .. code:: prettyprint

      try {
          // Some code that may throw an exception
      } catch (e: IllegalArgumentException) {
          // Handle exception
      }

   This approach also works for asynchronous code with coroutines. You can still use a try-catch
   expression to catch and handle exceptions in coroutines. The reason is because with structured
   concurrency, the sequential code is still synchronous code so the try-catch block will still work
   in the same expected way.

   .. code:: prettyprint

      ...

      fun main() {
          runBlocking {
              ...
              try {
                  ...
                  throw IllegalArgumentException("No city selected")
                  ...
              } catch (e: IllegalArgumentException) {
                  println("Caught exception $e")
                  // Handle error
              }
          }
      }

      ...

   To become more comfortable with handling exceptions, modify the weather program to catch the
   exception you added earlier and print the exception to the output.

   1. Within the ``runBlocking()`` function, add a try-catch block around the code that calls
      ``getWeatherReport()``. Print out the error that is caught and also print out a message that
      the weather report is not available.

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              try {
                  println(getWeatherReport())
              } catch (e: AssertionError) {
                  println("Caught exception in runBlocking(): $e")
                  println("Report unavailable at this time")
              }
              println("Have a good day!")
          }
      }

      suspend fun getWeatherReport() = coroutineScope {
          val forecast = async { getForecast() }
          val temperature = async { getTemperature() }
          "${forecast.await()} ${temperature.await()}"
      }

      suspend fun getForecast(): String {
          delay(1000)
          return "Sunny"
      }

      suspend fun getTemperature(): String {
          delay(500)
          throw AssertionError("Temperature is invalid")
          return "30\u00b0C"
      }

   2. Run the program and now the error is handled gracefully, and the program can finish executing
      successfully.

   ::

      Weather forecast
      Caught exception in runBlocking(): java.lang.AssertionError: Temperature is invalid
      Report unavailable at this time
      Have a good day!

   From the output, you can observe that ``getTemperature()`` throws an exception. In the body of
   the ``runBlocking()`` function, you surround the ``println(getWeatherReport())`` call in a
   try-catch block. You catch the type of exception that was expected (``AssertionError`` in the
   case of this example). Then you print the exception to the output as ``"Caught exception"``
   followed by the error message string. To handle the error, you let the user know that the weather
   report is not available with an additional ``println()`` statement:
   ``Report unavailable at this time``.

   Note that this behavior means that if there's a failure with getting the temperature, then there
   will be no weather report at all (even if a valid forecast was retrieved).

   Depending on how you want your program to behave, there's an alternative way that you could have
   handled the exception in the weather program.

   3. Move the error handling so that the try-catch behavior actually happens within the coroutine
      launched by ``async()`` to fetch the temperature. That way, the weather report can still print
      the forecast, even if the temperature failed. Here's the code:

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              println(getWeatherReport())
              println("Have a good day!")
          }
      }

      suspend fun getWeatherReport() = coroutineScope {
          val forecast = async { getForecast() }
          val temperature = async {
              try {
                  getTemperature()
              } catch (e: AssertionError) {
                  println("Caught exception $e")
                  "{ No temperature found }"
              }
          }

          "${forecast.await()} ${temperature.await()}"
      }

      suspend fun getForecast(): String {
          delay(1000)
          return "Sunny"
      }

      suspend fun getTemperature(): String {
          delay(500)
          throw AssertionError("Temperature is invalid")
          return "30\u00b0C"
      }

   4. Run the program.

   ::

      Weather forecast
      Caught exception java.lang.AssertionError: Temperature is invalid
      Sunny { No temperature found }
      Have a good day!

   From the output, you can see that calling ``getTemperature()`` failed with an exception, but the
   code within ``async()`` was able to catch that exception and handle it gracefully by having the
   coroutine still return a ``String`` that says the temperature was not found. The weather report
   is still able to be printed, with a successful forecast of ``Sunny``. The temperature is missing
   in the weather report, but in its place, there is a message explaining that the temperature was
   not found. This is a better user experience than the program crashing with the error.

   A helpful way to think about this error handling approach is that ``async()`` is the producer
   when a coroutine is started with it. ``await()`` is the consumer because it's waiting to consume
   the result from the coroutine. The producer does the work and produces a result. The consumer
   consumes the result. If there's an exception in the producer, then the consumer will get that
   exception if it's not handled, and the coroutine will fail. However, if the producer is able to
   catch and handle the exception, then the consumer won't see that exception and will see a valid
   result.

   Here's the ``getWeatherReport()`` code again for reference:

   .. code:: prettyprint

      suspend fun getWeatherReport() = coroutineScope {
          val forecast = async { getForecast() }
          val temperature = async {
              try {
                  getTemperature()
              } catch (e: AssertionError) {
                  println("Caught exception $e")
                  "{ No temperature found }"
              }
          }

          "${forecast.await()} ${temperature.await()}"
      }

   In this case, the producer (``async()``) was able to catch and handle the exception and still
   return a ``String`` result of ``"{ No temperature found }"``. The consumer (``await()``) receives
   this ``String`` result and doesn't even need to know that an exception happened. This is another
   option to gracefully handle an exception that you expect could happen in your code.

   **Note:** Exceptions are propagated differently for coroutines started with ``launch()`` versus
   ``async()``. Within a coroutine started by ``launch()``, an exception is thrown immediately so
   you can surround code with a try-catch block if it's expected to throw an exception. See
   `example <https://developer.android.google.cn/kotlin/coroutines#handling-exceptions>`__.

   **Warning:** Within a try-catch statement in your coroutine code, avoid catching a general
   ``Exception`` because that includes a very broad range of exceptions. You could be inadvertently
   catching and suppressing an error that is actually a bug that should be fixed in your code.
   Another important reason is that cancellation of coroutines, which is discussed later in this
   section, depends on `CancellationException <https://kotlinlang.org/docs/exception-handling.html#cancellation-and-exceptions>`__.
   So if you catch any type of ``Exception`` including ``CancellationExceptions`` without rethrowing
   them, then the cancellation behavior within your coroutines may behave differently than expected.
   Instead, catch a specific type of exception that you expect will be thrown from your code.

   Now you've learned that exceptions propagate upwards in the tree of coroutines, unless they are
   handled. It's also important to be careful when the exception propagates all the way to the root
   of the hierarchy, which could crash your whole app. Learn more details about exception handling
   in the `Exceptions in coroutines <https://medium.com/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c>`__
   blogpost and `Coroutine exceptions handling <https://kotlinlang.org/docs/exception-handling.html>`__ article.


**Cancellation**

   A similar topic to exceptions is cancellation of coroutines. This scenario is typically
   user-driven when an event has caused the app to cancel work that it had previously started.

   For example, say that the user has selected a preference in the app that they no longer want to
   see temperature values in the app. They only want to know the weather forecast (e.g. ``Sunny``),
   but not the exact temperature. Hence, cancel the coroutine that is currently getting the
   temperature data.

   1. First start with the initial code below (without cancellation).

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("Weather forecast")
              println(getWeatherReport())
              println("Have a good day!")
          }
      }

      suspend fun getWeatherReport() = coroutineScope {
          val forecast = async { getForecast() }
          val temperature = async { getTemperature() }
          "${forecast.await()} ${temperature.await()}"
      }

      suspend fun getForecast(): String {
          delay(1000)
          return "Sunny"
      }

      suspend fun getTemperature(): String {
          delay(1000)
          return "30\u00b0C"
      }

   2. After some delay, cancel the coroutine that was fetching the temperature information, so that
      your weather report only displays the forecast. Change the return value of the
      ``coroutineScope`` block to only be the weather forecast string.

   .. code:: prettyprint

      ...

      suspend fun getWeatherReport() = coroutineScope {
          val forecast = async { getForecast() }
          val temperature = async { getTemperature() }
          
          delay(200)
          temperature.cancel()

          "${forecast.await()}"
      }

      ...

   3. Run the program. Now the output is as follows. The weather report only consists of the weather
      forecast ``Sunny``, but not the temperature because that coroutine was cancelled.

   ::

      Weather forecast
      Sunny
      Have a good day!

   What you've learned here is that a coroutine can be cancelled, but it won't affect other
   coroutines in the same scope and the parent coroutine will not be cancelled.

   **Note**: You can learn more about `Cancellation of Coroutines <https://medium.com/androiddevelopers/cancellation-in-coroutines-aa6b90163629>`__ 
   in this Android Developers blogpost. Cancellation must be cooperative, so you should implement your
   coroutine so that it can be cancelled.

   In this section, you saw how cancellation and exceptions behave in coroutines and how that's tied
   to the coroutine hierarchy. Let's learn more of the formal concepts behind coroutines, so that
   you can understand how all the important pieces come together.


5. Coroutine concepts
---------------------

   When executing work asynchronously or concurrently, there are questions that you need to answer
   about how the work will be executed, how long the coroutine should exist for, what should happen
   if it gets cancelled or fails with an error, and more. Coroutines follow the principle of
   **structured concurrency**, which enforces you to answer these questions when you use coroutines
   in your code using a combination of mechanisms.


**Job**

   When you launch a coroutine with the ``launch()`` function, it returns an instance of ``Job``.
   The Job holds a handle, or reference, to the coroutine, so you can manage its lifecycle.

   .. code:: prettyprint

      val job = launch { ... }

   **Note:** The ``Deferred`` object that is returned from a coroutine started with the ``async()``
   function is a ``Job`` as well, and it holds the future result of the coroutine.

   The job can be used to control the life cycle, or how long the coroutine lives for, such as
   cancelling the coroutine if you don't need the task anymore.

   .. code:: prettyprint

      job.cancel()

   With a job, you can check if it's active, cancelled, or completed. The job is completed if the
   coroutine and any coroutines that it launched have completed all of their work. Note that the
   coroutine could have completed due to a different reason, such as being cancelled, or failing
   with an exception, but the job is still considered completed at that point.

   Jobs also keep track of the parent-child relationship among coroutines.


Job hierarchy

   When a coroutine launches another coroutine, the job that returns from the new coroutine is
   called the child of the original parent job.

   .. code:: prettyprint

      val job = launch {
          ...            

          val childJob = launch { ... }

          ...
      }

   These parent-child relationships form a job hierarchy, where each job can launch jobs, and so on.

   |This diagram shows a tree hierarchy of jobs. At the root of the hierarchy is a parent job. It
   has 3 children called: Child 1 Job, Child 2 Job, and Child 3 Job. Then Child 1 Job has two
   children itself: Child 1a Job and Child 1b Job. Also, Child 2 Job has a single child called Child
   2a Job. Lastly, Child 3 Job has two children: Child 3a Job and Child 3b Job.|

   This parent-child relationship is important because it will dictate certain behavior for the
   child and parent, and other children belonging to the same parent. You saw this behavior in the
   earlier examples with the weather program.

   -  If a parent job gets cancelled, then its child jobs also get cancelled.
   -  When a child job is canceled using ``job.cancel()``, it terminates, but it does not cancel its
      parent.
   -  If a job fails with an exception, it cancels its parent with that exception. This is known as
      propagating the error upwards (to the parent, the parent's parent, and so on). .


**CoroutineScope**

   Coroutines are typically launched into a ``CoroutineScope``. This ensures that we don't have
   coroutines that are unmanaged and get lost, which could waste resources.

   ``launch()`` and ``async()`` are `extension functions <https://kotlinlang.org/docs/extensions.html>`__ 
   on ``CoroutineScope``. Call ``launch()`` or ``async()`` on the scope to create a new 
   coroutine within that scope.

   A ``CoroutineScope`` is tied to a lifecycle, which sets bounds on how long the coroutines within
   that scope will live. If a scope gets cancelled, then its job is cancelled, and the cancellation
   of that propagates to its child jobs. If a child job in the scope fails with an exception, then
   other child jobs get cancelled, the parent job gets cancelled, and the exception gets re-thrown
   to the caller.


CoroutineScope in Kotlin Playground

   In this codelab, you used ``runBlocking()`` which provides a ``CoroutineScope`` for your program.
   You also learned how to use ``coroutineScope { }`` to create a new scope within the
   ``getWeatherReport()`` function.


**CoroutineScope in Android apps**

   Android provides coroutine scope support in entities that have a well-defined lifecycle, such as
   ``Activity`` (``lifecycleScope``) and ``ViewModel`` (``viewModelScope``). Coroutines that are
   started within these scopes will adhere to the lifecycle of the corresponding entity, such as
   ``Activity`` or ``ViewModel``.

   For example, say you start a coroutine in an ``Activity`` with the provided coroutine scope
   called ``lifecycleScope``. If the activity gets destroyed, then the ``lifecycleScope`` will get
   canceled and all its child coroutines will automatically get canceled too. You just need to
   decide if the coroutine following the lifecycle of the ``Activity`` is the behavior you want.

   In the Race Tracker Android app you will be working on, you'll learn a way to scope your
   coroutines to the lifecycle of a composable.


**Implementation Details of CoroutineScope**

   If you check the source code for how `CoroutineScope.kt <https://cs.android.com/android/platform/superproject/+/master:external/kotlinx.coroutines/kotlinx-coroutines-core/common/src/CoroutineScope.kt?q=coroutinescope>`__
   is implemented in the Kotlin coroutines library, you can see that ``CoroutineScope`` is declared
   as an interface and it contains a ``CoroutineContext`` as a variable.

   The ``launch()`` and ``async()`` functions create a new child coroutine within that scope and the
   child also inherits the context from the scope. What is contained within the context? Let's
   discuss that next.


**CoroutineContext**

   The ``CoroutineContext`` provides information about the context in which the coroutine will be
   running in. The ``CoroutineContext`` is essentially a map that stores elements where each element
   has a unique key. These are not required fields, but here are some examples of what may be
   contained in a context:

   -  name - name of the coroutine to uniquely identify it
   -  job - controls the lifecycle of the coroutine
   -  dispatcher - dispatches the work to the appropriate thread
   -  exception handler - handles exceptions thrown by the code executed in the coroutine

   **Note:** These are default values for the ``CoroutineContext``, which will be used if you don't
   provide values for them:

   -  "coroutine" for the coroutine name
   -  no parent job
   -  ``Dispatchers.Default`` for the coroutine dispatcher
   -  no exception handler

   Each of the elements in a context can be appended together with the ``+`` operator. For example,
   one ``CoroutineContext`` could be defined as follows:

   .. code:: prettyprint

      Job() + Dispatchers.Main + exceptionHandler

   Because a name is not provided, the default coroutine name is used.

   Within a coroutine, if you launch a new coroutine, the child coroutine will inherit the
   ``CoroutineContext`` from the parent coroutine, but replace the job specifically for the
   coroutine that just got created. You can also override any elements that were inherited from the
   parent context by passing in arguments to the ``launch()`` or ``async()`` functions for the parts
   of the context that you want to be different.

   .. code:: prettyprint

      scope.launch(Dispatchers.Default) {
          ...
      }

   You can learn more about ``CoroutineContext`` and how the context gets inherited from the parent
   in this `KotlinConf conference video talk <https://youtu.be/w0kfnydnFWI?t=256>`__.

   You've seen the mention of dispatcher several times. Its role is to dispatch or assign the work
   to a thread. Let's discuss threads and dispatchers in more detail.


**Dispatcher**

   Coroutines use dispatchers to determine the thread to use for its execution. A **thread** can be
   started, does some work (executes some code), and then terminates when there's no more work to be
   done.

   When a user starts your app, the Android system creates a new process and a single thread of
   execution for your app, which is known as the **main thread**. The main thread handles many
   important operations for your app including Android system events, drawing the UI on the screen,
   handling user input events, and more. As a result, most of the code you write for your app will
   likely run on the main thread.

   There are two terms to understand when it comes to the threading behavior of your code:
   **blocking** and **non-blocking**. A regular function blocks the calling thread until its work is
   completed. That means it does not yield the calling thread until the work is done, so no other
   work can be done in the meantime. Conversely, non-blocking code yields the calling thread until a
   certain condition is met, so you can do other work in the meantime. You can use an asynchronous
   function to perform non-blocking work because it returns before its work is completed.

   In the case of Android apps, you should only call blocking code on the main thread if it will
   execute fairly quickly. The goal is to keep the main thread unblocked, so that it can execute
   work immediately if a new event is triggered. This main thread is the **UI thread** for your
   activities and is responsible for UI drawing and UI related events. When there's a change on the
   screen, the UI needs to be redrawn. For something like an animation on the screen, the UI needs
   to be redrawn frequently so that it appears like a smooth transition. If the main thread needs to
   execute a long-running block of work, then the screen won't update as frequently and the user
   will see an abrupt transition (known as "jank") or the app may hang or be slow to respond.

   Hence we need to move any long-running work items off the main thread and handle it in a
   different thread. Your app starts off with a single main thread, but you can choose to create
   multiple threads to perform additional work. These additional threads can be referred to as
   worker threads. It's perfectly fine for a long-running task to block a worker thread for a long
   time, because in the meantime, the main thread is unblocked and can actively respond to the user.

   There are some built-in dispatchers that Kotlin provides:

   -  **Dispatchers.Main:** Use this dispatcher to run a coroutine on the main Android thread. This
      dispatcher is used primarily for handling UI updates and interactions, and performing quick
      work.
   -  **Dispatchers.IO:** This dispatcher is optimized to perform disk or network I/O outside of the
      main thread. For example, read from or write to files, and execute any network operations.
   -  **Dispatchers.Default:** This is a default dispatcher used when calling ``launch()`` and
      ``async()``, when no dispatcher is specified in their context. You can use this dispatcher to
      perform computationally-intensive work outside of the main thread. For example, processing a
      bitmap image file.

   **Note:** There's also ``Executor.asCoroutineDispatcher()`` and
   ``Handler.asCoroutineDispatcher()`` extensions, if you need to make a ``CoroutineDispatcher``
   from a ``Handler`` or ``Executor`` that you already have available.

   Try the following example in Kotlin Playground to better understand coroutine dispatchers.

   1. Replace any code you have in Kotlin Playground with the following code:

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              launch {
                  delay(1000)
                  println("10 results found.")
              }
              println("Loading...")
          }
      }

   2. Now wrap the contents of the launched coroutine with a call to ``withContext()`` to change the
      ``CoroutineContext`` that the coroutine is executed within, and specifically override the
      dispatcher. Switch to using the ``Dispatchers.Default`` (instead of ``Dispatchers.Main`` which
      is currently being used for the rest of the coroutine code in the program).

   .. code:: prettyprint

      ...

      fun main() {
          runBlocking {
              launch {
                  withContext(Dispatchers.Default) {
                      delay(1000)
                      println("10 results found.")
                  }
              }
              println("Loading...")
          }
      }

   Switching dispatchers is possible because `withContext() <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html>`__
   is itself a suspending function. It executes the provided block of code using a new
   ``CoroutineContext``. The new context comes from the context of the parent job (the outer
   ``launch()`` block), except it overrides the dispatcher used in the parent context with the one
   specified here: ``Dispatchers.Default``. This is how we are able to go from executing work with
   ``Dispatchers.Main`` to using ``Dispatchers.Default``.

   3. Run the program. The output should be:

   ::

      Loading...
      10 results found.

   4. Add print statements to see what thread you are on by calling ``Thread.currentThread().name``.

   .. code:: prettyprint

      import kotlinx.coroutines.*

      fun main() {
          runBlocking {
              println("${Thread.currentThread().name} - runBlocking function")
                      launch {
                  println("${Thread.currentThread().name} - launch function")
                  withContext(Dispatchers.Default) {
                      println("${Thread.currentThread().name} - withContext function")
                      delay(1000)
                      println("10 results found.")
                  }
                  println("${Thread.currentThread().name} - end of launch function")
              }
              println("Loading...")
          }
      }

   5. Run the program. The output should be:

   ::

      main @coroutine#1 - runBlocking function
      Loading...
      main @coroutine#2 - launch function
      DefaultDispatcher-worker-1 @coroutine#2 - withContext function
      10 results found.
      main @coroutine#2 - end of launch function

   From this output, you can observe that most of the code is executed in coroutines on the main
   thread. However, for the portion of your code in the ``withContext(Dispatchers.Default)`` block,
   that is executed in a coroutine on a Default Dispatcher worker thread (which is not the main
   thread). Notice that after ``withContext()`` returns, the coroutine returns to running on the
   main thread (as evidenced by output statement: ``main @coroutine#2 - end of launch function``).
   This example demonstrates that you can switch the dispatcher by modifying the context that is
   used for the coroutine.

   If you have coroutines that were started on the main thread, and you want to move certain
   operations off the main thread, then you can use ``withContext`` to switch the dispatcher being
   used for that work. Choose appropriately from the available dispatchers: ``Main``, ``Default``,
   and ``IO`` depending on the type of operation it is. Then that work can be assigned to a thread
   (or group of threads called a thread pool) designated for that purpose. Coroutines can suspend
   themselves, and the dispatcher also influences how they resume.

   Note that when working with popular libraries like Room and Retrofit (in this unit and the next
   one), you may not have to explicitly switch the dispatcher yourself if the library code already
   handles doing this work using an alternative coroutine dispatcher like ``Dispatchers.IO.`` In
   those cases, the ``suspend`` functions that those libraries reveal may already be **main-safe**
   and can be called from a coroutine running on the main thread. The library itself will handle
   switching the dispatcher to one that uses worker threads.

   Now you've got a high-level overview of the important parts of coroutines and the role that
   ``CoroutineScope``, ``CoroutineContext``, ``CoroutineDispatcher``, and ``Jobs`` play in shaping
   the lifecycle and behavior of a coroutine.


6. Conclusion
-------------

   Great work on this challenging topic of coroutines! You have learned that coroutines are very
   useful because their execution can be suspended, freeing up the underlying thread to do other
   work, and then the coroutine can be resumed later. This allows you to run concurrent operations
   in your code.

   Coroutine code in Kotlin follows the principle of structured concurrency. It is sequential by
   default, so you need to be explicit if you want concurrency (e.g. using ``launch()`` or
   ``async()``). With structured concurrency, you can take multiple concurrent operations and put it
   into a single synchronous operation, where concurrency is an implementation detail. The only
   requirement on the calling code is to be in a suspend function or coroutine. Other than that, the
   structure of the calling code doesn't need to take into account the concurrency details. That
   makes your asynchronous code easier to read and reason about.

   Structured concurrency keeps track of each of the launched coroutines in your app and ensures
   that they are not lost. Coroutines can have a hierarchyâ€”tasks might launch subtasks, which in
   turn can launch subtasks. Jobs maintain the parent-child relationship among coroutines, and allow
   you to control the lifecycle of the coroutine.

   Launch, completion, cancellation, and failure are four common operations in the coroutine's
   execution. To make it easier to maintain concurrent programs, structured concurrency defines
   principles that form the basis for how the common operations in the hierarchy are managed:

   1. **Launch:** Launch a coroutine into a scope that has a defined boundary on how long it lives
      for.
   2. **Completion:** The job is not complete until its child jobs are complete.
   3. **Cancellation:** This operation needs to propagate downward. When a coroutine is canceled,
      then the child coroutines need to also be canceled.
   4. **Failure:** This operation should propagate upward. When a coroutine throws an exception,
      then the parent will cancel all of its children, cancel itself, and propagate the exception up
      to its parent. This continues until the failure is caught and handled. It ensures that any
      errors in the code are properly reported and never lost.

   Through hands-on practice with coroutines and understanding the concepts behind coroutines, you
   are now better equipped to write concurrent code in your Android app. By using coroutines for
   asynchronous programming, your code is simpler to read and reason about, more robust in
   situations of cancellations and exceptions, and delivers a more optimal and responsive experience
   for end users.


**Summary**

   -  Coroutines enable you to write long running code that runs concurrently without learning a new
      style of programming. The execution of a coroutine is sequential by design.
   -  Coroutines follow the principle of structured concurrency, which helps ensure that work is not
      lost and tied to a scope with a certain boundary on how long it lives. Your code is sequential
      by default and cooperates with an underlying event loop, unless you explicitly ask for
      concurrent execution (e.g. using ``launch()`` or ``async()``). The assumption is that if you
      call a function, it should finish its work completely (unless it fails with an exception) by
      the time it returns regardless of how many coroutines it may have used in its implementation
      details.
   -  The ``suspend`` modifier is used to mark a function whose execution can be suspended and
      resumed at a later point.
   -  A ``suspend`` function can be called only from another suspending function or from a
      coroutine.
   -  You can start a new coroutine using the ``launch()`` or ``async()`` extension functions on
      ``CoroutineScope``.
   -  Jobs plays an important role to ensure structured concurrency by managing the lifecycle of
      coroutines and maintaining the parent-child relationship.
   -  A ``CoroutineScope`` controls the lifetime of coroutines through its Job and enforces
      cancellation and other rules to its children and their children recursively.
   -  A ``CoroutineContext`` defines the behavior of a coroutine, and can include references to a
      job and coroutine dispatcher.
   -  Coroutines use a ``CoroutineDispatcher`` to determine the threads to use for its execution.


Learn more

   -  `Kotlin coroutines on Android <https://developer.android.google.cn/kotlin/coroutines>`__
   -  `Additional resources for Kotlin coroutines and flow <https://developer.android.google.cn/kotlin/coroutines/additional-resources>`__
   -  `Coroutines guide <https://kotlinlang.org/docs/coroutines-guide.html>`__
   -  `Coroutine context and dispatchers <https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html>`__
   -  `Cancellations and exceptions in Coroutines <https://medium.com/androiddevelopers/coroutines-first-things-first-e6187bf3bb21>`__
   -  `Coroutines on Android <https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb>`__
   -  `Kotlin coroutines 101 <https://www.youtube.com/watch?v=ZTDXo0-SKuU&t=2s&sa=D&source=docs&ust=1664866751197807&usg=AOvVaw19xcRyp5y7Sdx1dzcf-YQP>`__
   -  `KotlinConf 2019: Coroutines! Gotta catch â€˜em all! <https://www.youtube.com/watch?v=w0kfnydnFWI>`__


.. |The println (Weather Forecast) statement is in a box at the top of the diagram. Below it, there is a vertical arrow pointing straight down. Off that vertical arrow, there is a branch going to the right with an arrow pointing to a box that contains the statement printForecast(). Off that original vertical arrow, there is also another branch going to the right with an arrow pointing to a box that contains the statement printTemperature().| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-kotlin-playground/img/32ec693170f3c1d7.png
.. |This diagram shows a tree hierarchy of jobs. At the root of the hierarchy is a parent job. It has 3 children called: Child 1 Job, Child 2 Job, and Child 3 Job. Then Child 1 Job has two children itself: Child 1a Job and Child 1b Job. Also, Child 2 Job has a single child called Child 2a Job. Lastly, Child 3 Job has two children: Child 3a Job and Child 3b Job.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-kotlin-playground/img/d6f120976b283e0.png


â­ Introduction to Coroutines in Android Studio
================================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-coroutines-android-studio


1. Before you begin
-------------------


   In the previous codelab, you learned about coroutines. You used Kotlin Playground to write
   concurrent code using coroutines. In this codelab, you'll apply your knowledge of coroutines
   within an Android app and its lifecycle. You'll add code to launch new coroutines concurrently
   and learn how to test them.


Prerequisites


   -  Knowledge of Kotlin language basics, including functions and lambdas
   -  Able to build layouts in Jetpack Compose
   -  Able to write unit tests in Kotlin (refer to `Write unit tests for ViewModel codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-viewmodel#0>`__)
   -  How threads and concurrency work
   -  Basic knowledge of coroutines and CoroutineScope


**What you'll build**


   -  Race Tracker app that simulates race progress between two players. Consider this app as a
      chance to experiment and learn more about different aspects of coroutines.


What you'll learn


   -  Using coroutines in Android app lifecycle.
   -  The principles of structured concurrency.
   -  How to write unit tests to test the coroutines.


What you'll need


2. App overview
---------------


   The Race Tracker app simulates two players running a race. The app UI consists of two buttons,
   **Start** / **Pause** and **Reset**, and two progress bars to show the progress of the racers.
   Players 1 and 2 are set to "run" the race at different speeds. When the race starts Player 2
   progresses twice as fast as Player 1.

   ======================= ======================= =======================
   |i598ee57f8ba58a52.png| |e2104fd6ef629969.png|  |74dd6c68328224e7.png|
   ======================= ======================= =======================

   You will use coroutines in the app to ensure:

   -  Both players "run the race" concurrently.
   -  The app UI is responsive and the progress bars increments during the race.

   The starter code has the UI code ready for the Race Tracker app. The main focus of this part of
   the codelab is to get you familiar with Kotlin coroutines inside an Android app.


Get the starter code


   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-race-tracker/archive/refs/heads/starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-race-tracker.git
      $ cd basic-android-kotlin-compose-training-race-tracker
      $ git checkout starter

   **Note:** The starter code is in the ``starter`` branch of the downloaded repository.

   You can browse the starter code in the `Race Tracker <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-race-tracker>`__
   GitHub repository.


Starter code walkthrough


   You can start the race by clicking the **Start** button. The text of the **Start** button changes
   to **Pause** while the race is in progress.

   |2ee492f277625f0a.png|

   At any point in time, you can use this button to pause or continue the race.

   |50e992f4cf6836b7.png|

   When the race starts, you can see the progress of each player through a status indicator. The
   ``StatusIndicator`` composable function displays the progress status of each player. It uses the
   ``LinearProgressIndicator`` composable to display the progress bar. You'll be using coroutines to
   update the value for progress.

   |79cf74d82eacae6f.png|

   ``RaceParticipant`` provides the data for progress increment. This class is a state holder for
   each of the players and maintains the ``name`` of the participant, the ``maxProgress`` to reach
   to finish the race, the delay duration between progress increments, ``currentProgress`` in race
   and the ``initialProgress``.

   In the next section, you will use coroutines to implement the functionality to simulate the race
   progress without blocking the app UI.


3. Implement race progress
--------------------------


   You need the ``run()`` function which compares the player's ``currentProgress`` with the
   ``maxProgress``, which reflects the total progress of the race, and uses the ``delay()`` suspend
   function to add a slight delay between progress increments. This function must be a ``suspend``
   function since it is calling another suspend function ``delay()``. Also, you will call this
   function later in the codelab from a coroutine. Follow these steps to implement the function:

   1. Open ``RaceParticipant`` class, which is part of the starter code.
   2. Inside the ``RaceParticipant`` class, define a new ``suspend`` function named ``run()``.

   .. code:: prettyprint

      class RaceParticipant(
          ...
      ) {
          var currentProgress by mutableStateOf(initialProgress)
              private set

          suspend fun run() {
              
          }
          ...
      }

   3. To simulate the progress of the race, add a ``while`` loop that runs until ``currentProgress``
      reaches the value ``maxProgress``, which is set to ``100``.

   .. code:: prettyprint

      class RaceParticipant(
          ...
          val maxProgress: Int = 100,
          ...
      ) {
          var currentProgress by mutableStateOf(initialProgress)
              private set

          suspend fun run() {
              while (currentProgress < maxProgress) {
                  
              }
          }
          ...
      }

   4. The value of the ``currentProgress`` is set to ``initialProgress``, which is ``0``. To
      simulate the participant's progress, increment the value ``currentProgress`` by the value of
      ``progressIncrement`` property inside the while loop. Note that the default value of
      ``progressIncrement`` is ``1``.

   .. code:: prettyprint

      class RaceParticipant(
          ...
          val maxProgress: Int = 100,
          ...
          private val progressIncrement: Int = 1,
          private val initialProgress: Int = 0
      ) {
          ...
          var currentProgress by mutableStateOf(initialProgress)
              private set

          suspend fun run() {
              while (currentProgress < maxProgress) {
                  currentProgress += progressIncrement
              }
          }
      }

   5. To simulate different progress intervals in the race, use the ``delay()`` suspend function.
      Pass the value of the ``progressDelayMillis`` property as an argument.

   .. code:: prettyprint

      suspend fun run() {
          while (currentProgress < maxProgress) {
              delay(progressDelayMillis)
              currentProgress += progressIncrement
          }
      }

   When you look at the code you just added, you will see an icon on the left of the call to the
   ``delay()`` function in Android Studio, as shown in the screenshot below: |11b5df57dcb744dc.png|

   This icon indicates the suspension point when the function might suspend and resume again later.

   The main thread is not blocked while the coroutine is waiting to complete the delay duration, as
   shown in the following diagram:

   |a3c314fb082a9626.png|

   The coroutine suspends (but doesn't block) the execution after calling the ``delay()`` function
   with the desired interval value. Once the delay is complete, the coroutine resumes the execution
   and updates the value of the ``currentProgress`` property.


4. Start the race
-----------------


   When the user presses the **Start** button, you need to "start the race" by calling the ``run()``
   suspend function on each of the two player instances. To do this, you need to launch a coroutine
   to call the ``run()`` function.

   When you launch a coroutine to trigger the race, you need to ensure the following aspects for
   both participants:

   -  They start running as soon as the **Start** button is clickedâ€”that is, the coroutines launch.
   -  They pause or stop running when the **Pause** or **Reset** button is clicked,
      respectivelyâ€”that is, the coroutines are canceled.
   -  When the user closes the app, the cancellation is properly managedâ€”that is, all the coroutines
      are canceled and bound to a lifecycle.

   In the first codelab you learned that you can only call a suspend function from another suspend
   function. To call suspend functions safely from inside a composable, you need to use the
   ``LaunchedEffect()`` composable. ``LaunchedEffect()`` composable runs the provided suspending
   function for as long as it remains in the composition. You can use the ``LaunchedEffect()``
   composable function to accomplish all of the following:

   -  The ``LaunchedEffect()`` composable allows you to safely call suspend functions from
      composables.
   -  When the ``LaunchedEffect()`` function enters the Composition, it launches a coroutine with
      the code block passed as a parameter. It runs the provided suspend function as long as it
      remains in the composition. When a user clicks the **Start** button in the RaceTracker app,
      the ``LaunchedEffect()`` enters the composition and launches a coroutine to update progress.
   -  The coroutine is canceled when the ``LaunchedEffect()`` exits the composition. In the app, if
      the user clicks the **Reset** / **Pause** button, ``LaunchedEffect()`` is removed from the
      composition and the underlying coroutines are canceled.

   For the RaceTracker app, you don't have to provide a Dispatcher explicitly, since
   ``LaunchedEffect()`` takes care of it.

   To start the race call the ``run()`` function for each participant and perform the following
   steps:

   1. Open the ``RaceTrackerApp.kt`` file located in the ``com.example.racetracker.ui`` package.
   2. Navigate to ``RaceTrackerApp()`` composable and add a call to the ``LaunchedEffect()``
      composable on the line after the definition of ``raceInProgress``.

   .. code:: prettyprint

      @Composable
      fun RaceTrackerApp() {
          ...
          var raceInProgress by remember { mutableStateOf(false) }

          LaunchedEffect {
          
          }
          RaceTrackerScreen(...)
      }

   3. To ensure that if the instances of ``playerOne`` or ``playerTwo`` are replaced with different
      instances, then ``LaunchedEffect()`` needs to cancel and relaunch the underlying coroutines,
      add the ``playerOne`` and ``playerTwo`` objects as ``key`` to the ``LaunchedEffect``. Similar
      to how a ``Text()`` composable gets recomposed when its text value changes, if any of the key
      arguments of the ``LaunchedEffect()`` changes, the underlying coroutine is canceled and
      relaunched.

   .. code:: prettyprint

      LaunchedEffect(playerOne, playerTwo) {
      }

   4. Add a call to the ``playerOne.run()`` and ``playerTwo.run()`` functions.

   .. code:: prettyprint

      @Composable
      fun RaceTrackerApp() {
          ...
          var raceInProgress by remember { mutableStateOf(false) }

          LaunchedEffect(playerOne, playerTwo) {
              playerOne.run()
              playerTwo.run()
          }
          RaceTrackerScreen(...)
      }

   5. Wrap the ``LaunchedEffect()`` block with an ``if`` condition. The initial value for this state
      is ``false``. The value for the ``raceInProgress`` state is updated to ``true`` when the user
      clicks the **Start** button and the ``LaunchedEffect()`` executes.

   .. code:: prettyprint

      if (raceInProgress) {
          LaunchedEffect(playerOne, playerTwo) {
              playerOne.run()
              playerTwo.run() 
          }
      }

   6. Update the ``raceInProgress`` flag to ``false`` to finish the race. This value is set to
      ``false`` when the user clicks on **Pause** too. When this value is set to ``false`` the
      ``LaunchedEffect()`` ensures that all the launched coroutines are canceled.

   .. code:: prettyprint

      LaunchedEffect(playerOne, playerTwo) {
          playerOne.run()
          playerTwo.run()
          raceInProgress = false 
      }

   7. Run the app and click **Start**. You should see player one completes the race before player
      two starts running, as shown in the following video:

   |fa0630395ee18f21.gif|

   This doesn't look like a fair race! In the next section, you will learn how to launch concurrent
   tasks so that both players can run at the same time, understand the concepts, and implement this
   behavior.


5. Structured concurrency
-------------------------


   The way you write code using coroutines is called structured concurrency. This style of
   programming improves the readability and development time of your code. The idea of structured
   concurrency is that coroutines have a hierarchyâ€”tasks might launch subtasks, which might launch
   subtasks in turn. The unit of this hierarchy is referred to as a coroutine scope. Coroutine
   scopes should always be associated with a lifecycle.

   The Coroutines APIs adhere to this structured concurrency by design. You cannot call a suspend
   function from a function which is not marked suspend. This limitation ensures that you call the
   suspend functions from coroutine builders, such as ``launch``. These builders are, in turn, tied
   to a ``CoroutineScope``.


6. Launch concurrent tasks
--------------------------


   1. To allow both participants to run concurrently, you need to launch two separate coroutines and
      move each call to the ``run()`` function inside those coroutines. Wrap the call to the
      ``playerOne.run()`` with ``launch`` builder.

   .. code:: prettyprint

      LaunchedEffect(playerOne, playerTwo) {
          launch { playerOne.run() }
          playerTwo.run()
          raceInProgress = false 
      }

   2. Similarly, wrap the call to the ``playerTwo.run()`` function with the ``launch`` builder. With
      this change, the app launches two coroutines that execute concurrently. Both players can now
      run at the same time.

   .. code:: prettyprint

      LaunchedEffect(playerOne, playerTwo) {
          launch { playerOne.run() }
          launch { playerTwo.run() }
          raceInProgress = false 
      }

   3. Run the app and click **Start**. While you expect the race to start, the text of the button
      immediately changes back to **Start** unexpectedly.

   |c46c2aa7c580b27b.png|

   When both the players complete their run, the Race Tracker app should reset the text for the
   **Pause** button back to **Start**. However, right now the app updates the ``raceInProgress``
   right away after launching the coroutines without waiting the players to complete the race:

   .. code:: prettyprint

      LaunchedEffect(playerOne, playerTwo) {
          launch {playerOne.run() }
          launch {playerTwo.run() }
          raceInProgress = false // This will update the state immediately, without waiting for players to finish run() execution.
      }

   The ``raceInProgress`` flag is updated immediately because:

   -  The ``launch`` builder function launches a coroutine to execute ``playerOne.run()`` and
      immediately returns to execute the next line in the code block.
   -  The same execution flow happens with the second ``launch`` builder function that executes
      ``playerTwo.run()`` function.
   -  As soon as the second ``launch`` builder returns, the ``raceInProgress`` flag is updated. This
      immediately changes the button text to **Start** and the race does not begin.


Coroutine Scope


   The ``coroutineScope`` suspend function creates a ``CoroutineScope`` and calls the specified
   suspend block with the current scope. The scope inherits its ``coroutineContext`` from the
   ``LaunchedEffect()`` scope.

   The scope returns as soon as the given block and all its children coroutines are complete. For
   the ``RaceTracker`` app, it returns once both participant objects finish executing the ``run()``
   function.

   1. To ensure the ``run()`` function of ``playerOne`` and ``playerTwo`` completes execution before
      updating the ``raceInProgress`` flag, wrap both launch builders with a ``coroutineScope``
      block.

   .. code:: prettyprint

      LaunchedEffect(playerOne, playerTwo) {
          coroutineScope {
              launch { playerOne.run() }
              launch { playerTwo.run() }
          }
          raceInProgress = false
      }

   2. Run the app on an emulator/Android device. You should see following screen:

   |598ee57f8ba58a52.png|

   3. Click the **Start** button. Player 2 runs faster than Player 1. After the race is complete,
      which is when both players reach 100% progress, the label for the **Pause** button changes to
      **Start**. You can click the **Reset** button to reset the race and re-execute the simulation.
      The race is shown in the following video.

   |c1035eecc5513c58.gif|

   The execution flow is shown in the following diagram:

   |cf724160fd66ff21.png|

   -  When the ``LaunchedEffect()`` block executes, the control is transferred to the
      ``coroutineScope{..}`` block.
   -  The ``coroutineScope`` block launches both coroutines concurrently and waits for them to
      finish execution.
   -  Once the execution is complete, the ``raceInProgress`` flag updates.

   The ``coroutineScope`` block only returns and moves on after all the code inside the block
   completes execution. For the code outside of the block, the presence or absence of concurrency
   becomes a mere implementation detail. This coding style provides a structured approach to
   concurrent programming and is referred to as structured concurrency.

   When you click the **Reset** button after the race completes, the coroutines are canceled, and
   the progress for both players is reset to ``0``.

   To see how coroutines are canceled when the user clicks the **Reset** button, follow these steps:

   1. Wrap the body of the ``run()`` method in a try-catch block as shown in the following code:

   .. code:: prettyprint

      suspend fun run() {
          try {
              while (currentProgress < maxProgress) {
                  delay(progressDelayMillis)
                  currentProgress += progressIncrement
              }
          } catch (e: CancellationException) {
              Log.e("RaceParticipant", "$name: ${e.message}")
              throw e // Always re-throw CancellationException.
          }
      }

   2. Run the app and click the **Start** button.
   3. After some progress increments, click the **Reset** button.
   4. Make sure you see the following message printed in Logcat:

   ::

      Player 1: StandaloneCoroutine was cancelled
      Player 2: StandaloneCoroutine was cancelled


7. Write unit tests to test coroutines
--------------------------------------


   Unit testing code that uses coroutines requires some extra attention, as their execution can be
   asynchronous and happen across multiple threads.

   To call suspending functions in tests, you need to be in a coroutine. As JUnit test functions
   themselves aren't suspending functions, you need to use the ``runTest`` coroutine builder. This
   builder is part of the ``kotlinx-coroutines-test`` library and is designed to execute tests. The
   builder executes the test body in a new coroutine.

   **Note**: Coroutines can be started not only directly in the test body, but also by the objects
   being used in the test using ``runTest``.

   Since ``runTest`` is part of the ``kotlinx-coroutines-test`` library, you need to add its
   dependency.

   To add the dependency, complete the following steps:

   1. Open the app module's **``build.gradle.kts``** file, located in the **``app``** directory in
      the **Project** pane.

   |e7c9e573c41199c6.png|

   2. Inside the file, scroll down until you find the ``dependencies{}`` block.
   3. Add a dependency using the ``testImplementation`` config to the ``kotlinx-coroutines-test``
      library.

   .. code:: prettyprint

      plugins {
          ...
      }

      android {
          ...
      }

      dependencies {
          ...
          testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.6.4")
      }

   4. In the notification bar at the top of the **build.gradle.kts** file, click **Sync Now** to let
      the import and build finish, as shown in the following screenshot:

   |1c20fc10750ca60c.png|

   Once the build is complete, you can start writing tests.


Implement unit tests for starting and finishing the race


   To ensure the race progress updates correctly during different phases of the race, your unit
   tests need to cover different scenarios. For this codelab, two scenarios are covered:

   -  Progress after the race starts.
   -  Progress after the race finishes.

   To check if the race progress updates correctly after the start of the race, you need to assert
   that the current progress is set to 1 after the ``raceParticipant.progressDelayMillis`` duration
   is passed.

   To implement the test scenario, follow these steps:

   1. Navigate to the ``RaceParticipantTest.kt`` file located under the test source set.
   2. To define the test, after the ``raceParticipant`` definition, create a
      ``raceParticipant_RaceStarted_ProgressUpdated()`` function and annotate it with the ``@Test``
      annotation. Since the test block needs to be placed in the ``runTest`` builder, use the
      expression syntax to return the ``runTest()`` block as a test result.

   .. code:: prettyprint

      class RaceParticipantTest {
          private val raceParticipant = RaceParticipant(
              ...
          )

          @Test
          fun raceParticipant_RaceStarted_ProgressUpdated() = runTest {
          }
      }

   3. Add a read-only ``expectedProgress`` variable and set it to ``1``.

   .. code:: prettyprint

      @Test
      fun raceParticipant_RaceStarted_ProgressUpdated() = runTest {
          val expectedProgress = 1
      }

   4. To simulate the race start, use the ``launch`` builder to launch a new coroutine and call the
      ``raceParticipant.run()`` function.

   .. code:: prettyprint

      @Test
      fun raceParticipant_RaceStarted_ProgressUpdated() = runTest {
          val expectedProgress = 1
          launch { raceParticipant.run() }
      }

   **Note:** You can directly call the ``raceParticipant.run()`` in the ``runtTest`` builder, but
   the default test implementation ignores the call to ``delay()``. As a result, the ``run()``
   finishes executing before you can analyze the progress.

   The value of the ``raceParticipant.progressDelayMillis`` property determines the duration after
   which the race progress updates. In order to test the progress after ``progressDelayMillis`` time
   has elapsed, you need to add some form of delay to your test.

   5. Use the ``advanceTimeBy()`` helper function to advance the time by the value of
      ``raceParticipant.progressDelayMillis``. The ``advanceTimeBy()`` function helps to reduce the
      test execution time.

   .. code:: prettyprint

      @Test
      fun raceParticipant_RaceStarted_ProgressUpdated() = runTest {
          val expectedProgress = 1
          launch { raceParticipant.run() }
          advanceTimeBy(raceParticipant.progressDelayMillis)
      }

   6. Since ``advanceTimeBy()`` doesn't run the task scheduled at the given duration, you need to
      call the ``runCurrent()`` function. This function executes any pending tasks at the current
      time.

   .. code:: prettyprint

      @Test
      fun raceParticipant_RaceStarted_ProgressUpdated() = runTest {
          val expectedProgress = 1
          launch { raceParticipant.run() }
          advanceTimeBy(raceParticipant.progressDelayMillis)
          runCurrent()
      }

   7. To ensure the progress updates, add a call to the ``assertEquals()`` function to check if the
      value of the ``raceParticipant.currentProgress`` property matches the value of the
      ``expectedProgress`` variable.

   .. code:: prettyprint

      @Test
      fun raceParticipant_RaceStarted_ProgressUpdated() = runTest {
          val expectedProgress = 1
          launch { raceParticipant.run() }
          advanceTimeBy(raceParticipant.progressDelayMillis)
          runCurrent()
          assertEquals(expectedProgress, raceParticipant.currentProgress)
      }

   8. Run the test to confirm that it passes.

   To check if the race progress updates correctly after the race finishes, you need to assert that
   when the race finishes, the current progress is set to ``100``.

   Follow these steps to implement the test:

   1. After the ``raceParticipant_RaceStarted_ProgressUpdated()`` test function, create a
      ``raceParticipant_RaceFinished_ProgressUpdated()`` function and annotate it with the ``@Test``
      annotation. The function should return a test result from the ``runTest{}`` block.

   .. code:: prettyprint

      class RaceParticipantTest {
          ...

          @Test
          fun raceParticipant_RaceStarted_ProgressUpdated() = runTest {
              ...
          }

          @Test
          fun raceParticipant_RaceFinished_ProgressUpdated() = runTest {
          }
      }

   2. Use ``launch`` builder to launch a new coroutine and add a call to the
      ``raceParticipant.run()`` function in it.

   .. code:: prettyprint

      @Test
      fun raceParticipant_RaceFinished_ProgressUpdated() = runTest {
          launch { raceParticipant.run() }
      }

   3. To simulate the race finish, use the ``advanceTimeBy()`` function to advance the dispatcher's
      time by ``raceParticipant.maxProgress * raceParticipant.progressDelayMillis``:

   .. code:: prettyprint

      @Test
      fun raceParticipant_RaceFinished_ProgressUpdated() = runTest {
          launch { raceParticipant.run() }
          advanceTimeBy(raceParticipant.maxProgress * raceParticipant.progressDelayMillis)
      }

   4. Add a call to the ``runCurrent()`` function to execute any pending tasks.

   .. code:: prettyprint

      @Test
      fun raceParticipant_RaceFinished_ProgressUpdated() = runTest {
          launch { raceParticipant.run() }
          advanceTimeBy(raceParticipant.maxProgress * raceParticipant.progressDelayMillis)
          runCurrent()
      }

   5. To ensure the progress updates correctly, add a call to the ``assertEquals()`` function to
      check if the value of the ``raceParticipant.currentProgress`` property is equal to ``100``.

   .. code:: prettyprint

      @Test
      fun raceParticipant_RaceFinished_ProgressUpdated() = runTest {
          launch { raceParticipant.run() }
          advanceTimeBy(raceParticipant.maxProgress * raceParticipant.progressDelayMillis)
          runCurrent()
          assertEquals(100, raceParticipant.currentProgress)
      }

   6. Run the test to confirm that it passes.


**Try this challenge**


   Apply the test strategies discussed in the `Write unit tests for ViewModel <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-viewmodel#0>`__
   codelab. Add the tests to cover the happy path, error cases, and boundary cases.

   Compare the test you write with the ones available in the solution code.


8. Get the solution code
------------------------


   To download the code for the finished codelab, you can use these git commands:

   ::

      git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-race-tracker.git 
      cd basic-android-kotlin-compose-training-race-tracker

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-race-tracker/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the code repository.

   If you want to see the solution code, `view it on GitHub <https://github.com/google-developer-training/basic-android-kotlin-compose-training-race-tracker>`__.


9. Conclusion
-------------


   Congratulations! You just learned how to use coroutines to handle concurrency. Coroutines help
   manage long-running tasks that might otherwise block the main thread and cause your app to become
   unresponsive. You also learned how to write unit tests to test the coroutines.

   The following features are some of the benefits of coroutines:

   -  **Readability:** The code you write with coroutines provides a clear understanding of the
      sequence that executes the lines of code.
   -  **Jetpack integration:** Many Jetpack libraries, such as Compose and ViewModel, include
      extensions that provide full coroutines support. Some libraries also provide their own
      coroutine scope that you can use for structured concurrency.
   -  **Structured concurrency:** Coroutines make concurrent code safe and easy to implement,
      eliminate unnecessary boilerplate code, and ensure that coroutines launched by the app are not
      lost or keep wasting resources.


**Summary**


   -  Coroutines enable you to write long running code that runs concurrently without learning a new
      style of programming. The execution of a coroutine is sequential by design.
   -  The ``suspend`` keyword is used to mark a function, or function type, to indicate its
      availability to execute, pause, and resume a set of code instructions.
   -  A ``suspend`` function can be called only from another suspend function.
   -  You can start a new coroutine using the ``launch`` or ``async`` builder function.
   -  Coroutine context, coroutine builders, Job, coroutine scope and Dispatcher are the major
      components for implementing coroutines.
   -  Coroutines use dispatchers to determine the threads to use for its execution.
   -  Job plays an important role to ensure structured concurrency by managing the lifecycle of
      coroutines and maintaining the parent-child relationship.
   -  A ``CoroutineContext`` defines the behavior of a coroutine using Job and a coroutine
      dispatcher.
   -  A ``CoroutineScope`` controls the lifetime of coroutines through its Job and enforces
      cancellation and other rules to its children and their children recursively.
   -  Launch, completion, cancellation, and failure are four common operations in the coroutine's
      execution.
   -  Coroutines follow a principle of structured concurrency.


Learn more


   -  `Kotlin coroutines on Android <https://developer.android.google.cn/kotlin/coroutines>`__
   -  `Additional resources for Kotlin coroutines and flow <https://developer.android.google.cn/kotlin/coroutines/additional-resources>`__
   -  `Exceptions in Coroutines <https://medium.com/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c>`__
   -  `Coroutines on Android (part 1) <https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb>`__
   -  `Kotlin coroutines 101 <https://www.youtube.com/watch?v=ZTDXo0-SKuU&t=2s&sa=D&source=docs&ust=1664866751197807&usg=AOvVaw19xcRyp5y7Sdx1dzcf-YQP>`__


.. |598ee57f8ba58a52.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/598ee57f8ba58a52.png
.. |e2104fd6ef629969.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/e2104fd6ef629969.png
.. |74dd6c68328224e7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/74dd6c68328224e7.png
.. |2ee492f277625f0a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/2ee492f277625f0a.png
.. |50e992f4cf6836b7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/50e992f4cf6836b7.png
.. |79cf74d82eacae6f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/79cf74d82eacae6f.png
.. |11b5df57dcb744dc.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/11b5df57dcb744dc.png
.. |a3c314fb082a9626.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/a3c314fb082a9626.png
.. |fa0630395ee18f21.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/fa0630395ee18f21.gif
.. |c46c2aa7c580b27b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/c46c2aa7c580b27b.png
.. |598ee57f8ba58a52.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/598ee57f8ba58a52.png
.. |c1035eecc5513c58.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/c1035eecc5513c58.gif
.. |cf724160fd66ff21.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/cf724160fd66ff21.png
.. |e7c9e573c41199c6.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/e7c9e573c41199c6.png
.. |1c20fc10750ca60c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/1c20fc10750ca60c.png


â­ Get data from the internet
==============================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-getting-data-internet


1. Before you begin
-------------------

   Most Android apps in the market connect to the internet to perform network operations, such as
   retrieving emails, messages, or other information from a backend server. Gmail, YouTube, and
   Google Photos are example apps that connect to the internet to display the user data.

   In this codelab, you will use open source and community-driven libraries to build a data layer
   and get data from a backend server. This greatly simplifies fetching the data and also helps the
   app follow Android best practices, such as perform operations on a background thread. You will
   also display an error message if the internet is slow or unavailable, which will keep the user
   informed about any network connectivity issues.


Prerequisites


   -  Basic knowledge of how to create Composable functions.
   -  Basic knowledge of how to use Android architecture components ``ViewModel``.
   -  Basic knowledge of how to use coroutines for long-running tasks.
   -  Basic knowledge of how to add dependencies in ``build.gradle.kts``.


**What you'll learn**


   -  What a `REST <https://en.wikipedia.org/wiki/Representational_state_transfer>`__ web service
      is.
   -  How to use the `Retrofit <https://square.github.io/retrofit/>`__ library to connect to a REST
      web service on the internet and get a response.
   -  How to use the `Serialization (kotlinx.serialization) <https://kotlinlang.org/docs/serialization.html#0>`__ 
      library to parse the JSON response into a data object.


**What you'll do**


   -  Modify a starter app to make a web service API request and handle the response.
   -  Implement a data layer for your app using the Retrofit library.
   -  Parse the JSON response from the web service into your app's list of data objects with the
      *kotlinx.serialization* library, and attach it to the UI state.
   -  Use Retrofit's support for coroutines to simplify the code.


**What you need**


   -  A computer with Android Studio
   -  Starter code for the Mars Photos app


2. App overview
---------------

   You work with the app named **Mars Photos**, which shows images of the Mars surface. This app
   connects to a web service to retrieve and display Mars photos. The images are real-life photos
   from Mars, captured from NASA's Mars rovers. The following image is a screenshot of the final
   app, which contains a grid of images.

   |68f4ff12cc1e2d81.png|

   **Note**: The preceding image is a screenshot of the final app that you will build at the end of
   this unit, after additional updates in later codelabs. The screenshot is shown in this codelab to
   give you a better idea of the overall app functionality.

   The version of the app you build in this codelab won't have a lot of visual flash. This codelab
   focuses on the data layer part of the app to connect to the internet and download the raw
   property data using a web service. To ensure that the app correctly retrieves and parses this
   data, you can print the number of photos received from the backend server in a ``Text``
   composable.

   |a59e55909b6e9213.png|


3. Explore the Mars Photos starter app
--------------------------------------


Download starter code


   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos/archive/refs/heads/starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos.git
      $ cd basic-android-kotlin-compose-training-mars-photos
      $ git checkout starter

   **Note:** The starter code is in the ``starter`` branch of the downloaded repository.

   You can browse the code in the `Mars Photos <https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos/tree/starter>`__
   GitHub repository.


Run starter code


   1. Open the downloaded project in Android Studio. The folder name of the project is
      ``basic-android-kotlin-compose-training-mars-photos``.
   2. In the **Android** pane, expand **app** > **kotlin + java**. Notice that the app has a package
      folder called ``ui``. This is the UI layer of the app.

   |de3d8666ecee9d1c.png|

   3. Run the app. When you compile and run the app, you see the following screen with placeholder
      text in the center. At the end of this codelab, you update this placeholder text with the
      number of photos retrieved.

   |95328ffbc9d7104b.png|


**Starter code walkthrough**


   In this task, you familiarize yourself with the structure of the project. The following lists
   provide a walkthrough of the important files and folders in the project.

   ``ui\MarsPhotosApp.kt``:

   -  This file contains the composable, ``MarsPhotosApp``, which displays the contents on the
      screen, such as the top app bar and the ``HomeScreen`` composable. The placeholder text in the
      previous step is displayed in this composable.
   -  In the next codelab, this composable displays the data received from the Mars photos backend
      server.

   ``screens\MarsViewModel.kt``:

   -  This file is the corresponding view model for the ``MarsPhotosApp``.
   -  This class contains a ``MutableState`` property named ``marsUiState``. Updating the value of
      this property updates the placeholder text displayed on the screen.
   -  The ``getMarsPhotos()`` method updates the placeholder response. Later in the codelab, you use
      this method to display the data fetched from the server. The goal for this codelab is to
      update the ``MutableState`` within the ``ViewModel`` using data you get from the internet.

   ``screens\HomeScreen.kt``:

   -  This file contains the ``HomeScreen`` and ``ResultScreen`` composables. The ``ResultScreen``
      has a simple ``Box`` layout that displays the value of ``marsUiState`` in a ``Text``
      composable.

   ``MainActivity.kt``:

   -  The only task for this activity is to load the ``ViewModel`` and display the ``MarsPhotosApp``
      composable.


4. Introduction to web services
-------------------------------

   In this codelab, you create a layer for the network service that communicates with the backend
   server and fetches the required data. You use a third-party library, called
   `Retrofit <https://square.github.io/retrofit/>`__, to implement this task. You learn more about
   this later. The ``ViewModel`` communicates with the data layer, and the rest of the app is
   transparent to this implementation.

   |76551dbe9fc943aa.png|

   The ``MarsViewModel`` is responsible for making the network call to get the Mars photos data. In
   the ``ViewModel``, you use ``MutableState`` to update the app UI when the data changes.

   **Note**: In later codelabs, you will add a Repository to your data layer. The Repository then
   communicates with the Retrofit service to fetch the data. The Repository is responsible for
   exposing the data to the rest of the app.


5. Web services and Retrofit
----------------------------

   The Mars photos data is stored on a web server. To get this data into your app, you need to
   establish a connection and communicate with the server on the internet.

   |301162f0dca12fcf.png|

   |7ced9b4ca9c65af3.png|

   **Note**: In this codelab, you only retrieve the number of records (URLs), not the Mars photos.
   In a later codelab, you retrieve the Mars photos and display them in a grid.

   Most web servers today run web services using a common stateless web architecture known as
   `REST <https://en.wikipedia.org/wiki/Representational_state_transfer>`__, which stands for
   **REpresentational State Transfer**. Web services that offer this architecture are
   known as RESTful services.

   Requests are made to RESTful web services in a standardized way, via `Uniform Resource
   Identifiers <https://en.wikipedia.org/wiki/Uniform_Resource_Identifier>`__ (URIs). A URI
   identifies a resource in the server by name, without implying its location or how to access it.
   For example, in the app for this lesson, you retrieve the image URLs using the following server
   URI. (This server hosts both Mars real estate and Mars photos):

   `android-kotlin-fun-mars-server.appspot.com <https://android-kotlin-fun-mars-server.appspot.com>`__

   **Note**: The aforementioned server is being accessed by a different sample app where it
   showcases Mars real estate, so this server has two different endpoints: one for Mars real estate
   and one for photos. For this course, you use the server to retrieve Mars photos.

   A URL (Uniform Resource Locator) is a subset of a URI that specifies where a resource exists and
   the mechanism for retrieving it.

   **For example:**

   The following URL gets a list of available real estate properties on Mars:

   https://android-kotlin-fun-mars-server.appspot.com/realestate

   The following URL gets a list of Mars photos:

   https://android-kotlin-fun-mars-server.appspot.com/photos

   These URLs refer to an identified resource, such as
   `/realestate <https://android-kotlin-fun-mars-server.appspot.com/realestate>`__ or
   `/photos <https://android-kotlin-fun-mars-server.appspot.com/photos>`__, that is obtainable via
   the Hypertext Transfer Protocol (*http:*) from the network. You are using the
   `/photos <https://android-kotlin-fun-mars-server.appspot.com/photos>`__ endpoint in this codelab.
   An endpoint is a URL that allows you to access a web service running on a server.

   **Note**: The familiar web URL is actually a type of URI. This course uses both URL and URI
   interchangeably.


**Web service request**


   Each web service request contains a URI and is transferred to the server using the same HTTP
   protocol that's used by web browsers, like Chrome. HTTP requests contain an operation to tell the
   server what to do.

   Common HTTP operations include:

   -  GET for retrieving server data.
   -  POST for creating new data on the server.
   -  PUT for updating existing data on the server.
   -  DELETE for deleting data from the server.

   Your app makes an HTTP GET request to the server for the Mars photos information, and then the
   server returns a response to your app, including the image URLs.

   |5bbeef4ded3e84cf.png|

   |83e8a6eb79249ebe.png|

   The response from a web service is formatted in one of the common data formats, like XML
   (eXtensible Markup Language) or JSON (JavaScript Object Notation). The JSON format represents
   structured data in key-value pairs. An app communicates with the REST API using JSON, which you
   learn more about in a later task.

   In this task, you establish a network connection to the server, communicate with the server, and
   receive a JSON response. You will be using a backend server that is already written for you. In
   this codelab, you use the Retrofit library, a third-party library, to communicate with the
   backend server.


**External Libraries**


   External libraries, or third-party libraries, are like extensions to the core Android APIs. The
   libraries you use in this course are open source, community-developed, and maintained by the
   collective contributions from the huge Android community around the world. These resources help
   Android developers like you to build better apps.

   **Warning**: Using community-developed and maintained libraries can be a huge timesaver. However,
   you must choose these libraries wisely because your app is ultimately responsible for what the
   code does in these libraries.


Retrofit Library


   The Retrofit library that you use in this codelab to talk to the RESTful Mars web service is a
   good example of a well-supported and maintained library. You can tell this by looking at its
   `GitHub <https://github.com/square/retrofit>`__ page and reviewing the open and closed issues
   (some are feature requests). If the developers are regularly resolving the issues and responding
   to the feature requests, the library is likely well-maintained and a good candidate to use in the
   app. You can also refer to `Retrofit <https://square.github.io/retrofit/>`__ documentation to
   learn more about the library.

   The Retrofit library communicates with the REST backend. It generates the code, but you need to
   provide the URIs for the web service based on the parameters we pass to it. You learn more about
   this topic in later sections.

   |26043df178401c6a.png|


Add Retrofit dependencies


   Android Gradle lets you add external libraries to your project. In addition to the library
   dependency, you also need to include the repository where the library is hosted.

   1. Open the module-level gradle file ``build.gradle.kts (Module :app)``.
   2. In the ``dependencies`` section, add the following lines for the Retrofit libraries:

   .. code:: prettyprint

      // Retrofit 
      implementation("com.squareup.retrofit2:retrofit:2.9.0")
      // Retrofit with Scalar Converter
      implementation("com.squareup.retrofit2:converter-scalars:2.9.0")

   The two libraries work together. The first dependency is for the Retrofit2 library itself, and
   the second dependency is for the Retrofit scalar converter. Retrofit2 is the updated version of
   the Retrofit library. This scalar converter enables Retrofit to return the JSON result as a
   ``String``. JSON is a format for storing and transporting data between client and server. You
   will learn about JSON in a later section.

   3. Click **Sync Now** to rebuild the project with the new dependencies.


6. Connecting to the Internet
-----------------------------

   You use the Retrofit library to talk to the Mars web service and display the raw JSON response as
   a ``String``. The placeholder ``Text`` either displays the returned JSON response string or a
   message indicating a connection error.

   Retrofit creates a network API for the app based on the content from the web service. It fetches
   data from the web service and routes it through a separate converter library that knows how to
   decode the data and return it in the form of objects, like ``String``. Retrofit includes built-in
   support for popular data formats, such as XML and JSON. Retrofit ultimately creates the code to
   call and consume this service for you, including critical details, such as running the requests
   on background threads.

   |8c3a5c3249570e57.png|

   In this task, you add a data layer to your **Mars Photos** project that your ``ViewModel`` uses
   to communicate with the web service. You implement the Retrofit service API with the following
   steps:

   -  Create a data source, ``MarsApiService`` class.
   -  Create a Retrofit object with the base URL and the converter factory to convert strings.
   -  Create an interface that explains how Retrofit talks to the web server.
   -  Create a Retrofit service and expose the instance to the api service to the rest of the app.

   Implement the above steps:

   1. Right-click on the package com.example.marsphotos in your Android project pane and select
      **New > Package**.
   2. In the popup, append **network** to the end of the suggested package name.
   3. Create a new Kotlin file under the new package. Name it ``MarsApiService``.
   4. Open ``network/MarsApiService.kt``.
   5. Add the following constant for the base URL for the web service.

   .. code:: prettyprint

      private const val BASE_URL = 
         "https://android-kotlin-fun-mars-server.appspot.com"

   6. Add a Retrofit builder just below that constant to build and create a Retrofit object.

   .. code:: prettyprint

      import retrofit2.Retrofit

      private val retrofit = Retrofit.Builder()

   Retrofit needs the base URI for the web service and a converter factory to build a web services
   API. The converter tells Retrofit what to do with the data it gets back from the web service. In
   this case, you want Retrofit to fetch a JSON response from the web service and return it as a
   ``String``. Retrofit has a ``ScalarsConverter`` that supports strings and other primitive types.

   7. Call ``addConverterFactory()`` on the builder with an instance of ``ScalarsConverterFactory``.

   .. code:: prettyprint

      import retrofit2.converter.scalars.ScalarsConverterFactory

      private val retrofit = Retrofit.Builder()
         .addConverterFactory(ScalarsConverterFactory.create())

   8. Add the base URL for the web service using the ``baseUrl()`` method.
   9. Call ``build()`` to create the Retrofit object.

   .. code:: prettyprint

      private val retrofit = Retrofit.Builder()
         .addConverterFactory(ScalarsConverterFactory.create())
         .baseUrl(BASE_URL)
         .build()

   10. Below the call to the Retrofit builder, define an interface called ``MarsApiService`` that
       defines how Retrofit talks to the web server using HTTP requests.

   .. code:: prettyprint

      interface MarsApiService {
      }

   11. Add a function called ``getPhotos()`` to the ``MarsApiService`` interface to get the response
       string from the web service.

   .. code:: prettyprint

      interface MarsApiService {    
          fun getPhotos()
      }

   12. Use the ``@GET`` annotation to tell Retrofit that this is a GET request and specify an
       endpoint for that web service method. In this case, the endpoint is ``photos``. As mentioned
       in the previous task, you will use the `/photos <https://android-kotlin-fun-mars-server.appspot.com/photos>`__ 
       endpoint in this codelab.

   .. code:: prettyprint

      import retrofit2.http.GET


      interface MarsApiService {
          @GET("photos") 
          fun getPhotos()
      }

   When the ``getPhotos()`` method is invoked, Retrofit appends the endpoint ``photos`` to the base
   URLâ€”which you defined in the Retrofit builderâ€”used to start the request.

   13. Add a return type of the function to ``String``.

   .. code:: prettyprint

      interface MarsApiService {
          @GET("photos") 
          fun getPhotos(): String
      }


**Object declarations**


   In Kotlin, `object declarations <https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations>`__
   are used to declare singleton objects. `Singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`__ 
   ensures that one, and only one, instance of an object is created and has one global point of 
   access to that object. Object initialization is thread-safe and done at first access.

   Following is an example of an object declaration and its access. Object declaration always has a
   name following the ``object`` keyword.

   **Example:**

   .. code:: prettyprint

      // Example for Object declaration, do not copy over

      object SampleDataProvider {
          fun register(provider: SampleProvider) {
              // ...
          }
      â€‹
          // ...
      }

      // To refer to the object, use its name directly.
      SampleDataProvider.register(...)

   **Warning**: Singleton pattern is not a recommended practice. Singletons represent global states
   that are hard to predict, particularly in tests. Objects should define which dependencies they
   need, instead of describing how to create them.

   Use `Dependency injection <https://developer.android.google.cn/training/dependency-injection>`__
   over singleton pattern, you will learn how to implement Dependency injection in a later codelab.

   The call to ``create()`` function on a Retrofit object is expensive in terms of memory, speed,
   and performance. The app needs *only one* instance of the Retrofit API service, so you expose the
   service to the rest of the app using *object declaration*.

   1. Outside the ``MarsApiService`` interface declaration, define a public object called
      ``MarsApi`` to initialize the Retrofit service. This object is the public singleton object
      that the rest of the app can access.

   .. code:: prettyprint

      object MarsApi {}

   2. Inside the ``MarsApi`` object declaration, add a lazily initialized retrofit object property
      named ``retrofitService`` of the type ``MarsApiService``. You make this lazy initialization to
      make sure it is initialized at its first usage. Ignore the error, which you fix in the next
      steps.

   **Note**: Remember "lazy initialization" is when object creation is purposely delayed, until you
   actually need that object, to avoid unnecessary computation or use of other computing resources.
   Kotlin has `first-class support <https://kotlinlang.org/docs/reference/delegated-properties.html#lazy>`__ 
   for lazy instantiation.

   .. code:: prettyprint

      object MarsApi {
          val retrofitService : MarsApiService by lazy {}
      }

   3. Initialize the ``retrofitService`` variable using the ``retrofit.create()`` method with the
      ``MarsApiService`` interface.

   .. code:: prettyprint

      object MarsApi {
          val retrofitService : MarsApiService by lazy { 
             retrofit.create(MarsApiService::class.java)
          }
      }

   The Retrofit setup is done! Each time your app calls ``MarsApi.retrofitService``, the caller
   accesses the same singleton Retrofit object that implements ``MarsApiService``, which is created
   on the first access. In the next task, you use the Retrofit object you implemented.


Call the web service in MarsViewModel


   In this step, you implement the ``getMarsPhotos()`` method that calls the REST service and then
   handles the returned JSON string.

   **Note**: The recommended approach is to call webservice from a repository, which isolates the
   data layer from the rest of the app. In a later codelab, you add a repository to your app.


ViewModelScope


   A `viewModelScope <https://developer.android.google.cn/topic/libraries/architecture/coroutines#viewmodelscope>`__
   is the built-in coroutine scope defined for each ``ViewModel`` in your app. Any coroutine
   launched in this scope is automatically canceled if the ``ViewModel`` is cleared.

   You can use ``viewModelScope`` to launch the coroutine and make the web service request in the
   background. Since the ``viewModelScope`` belongs to the ``ViewModel``, the request continues even
   if the app goes through a configuration change.

   1. In the ``MarsApiService.kt`` file, make ``getPhotos()`` a suspend function to make it
      asynchronous and not block the calling thread. You call this function from inside a
      `viewModelScope <https://developer.android.google.cn/topic/libraries/architecture/coroutines#viewmodelscope>`__.

   .. code:: prettyprint

      @GET("photos")
      suspend fun getPhotos(): String

   2. Open the ``ui/screens/MarsViewModel.kt`` file. Scroll down to the ``getMarsPhotos()`` method.
      Delete the line that sets the status response to ``"Set the Mars API Response here!"`` so that
      the method ``getMarsPhotos()`` is empty.

   .. code:: prettyprint

      private fun getMarsPhotos() {}

   3. Inside ``getMarsPhotos()``, launch the coroutine using ``viewModelScope.launch``.

   .. code:: prettyprint

      import androidx.lifecycle.viewModelScope
      import kotlinx.coroutines.launch


      private fun getMarsPhotos() {
          viewModelScope.launch {}
      }

   4. Inside ``viewModelScope``, use the singleton object ``MarsApi`` to call the ``getPhotos()``
      method from the ``retrofitService`` interface. Save the returned response in a ``val`` called
      ``listResult``.

   .. code:: prettyprint

      import com.example.marsphotos.network.MarsApi

      viewModelScope.launch {
          val listResult = MarsApi.retrofitService.getPhotos()
      }

   5. Assign the result just received from the backend server to the ``marsUiState``. The
      ``marsUiState`` is a mutable state object that represents the status of the most recent web
      request.

   .. code:: prettyprint

      val listResult = MarsApi.retrofitService.getPhotos()
      marsUiState = listResult

   6. Run the app. Notice that the app closes immediately, and it may or may not display an error
      popup. This is an app crash.

   7. Click the **Logcat** tab in Android Studio and note the error in the log, which starts with a
      line like this: "``------- beginning of crash``"

   ::

          --------- beginning of crash
      22803-22865/com.example.android.marsphotos E/AndroidRuntime: FATAL EXCEPTION: OkHttp Dispatcher
          Process: com.example.android.marsphotos, PID: 22803
          java.lang.SecurityException: Permission denied (missing INTERNET permission?)
      ...

   This error message indicates the app might be missing the ``INTERNET`` permissions. The next task
   describes how to add internet permissions to the app and resolve this issue.


7. Add Internet permission and Exception Handling
-------------------------------------------------


**Android Permissions**


   The purpose of permissions on Android is to protect the privacy of an Android user. Android apps
   must declare or request permissions to access sensitive user data, such as contacts, call logs,
   and certain system features, such as camera or internet.

   In order for your app to access the Internet, it needs the ``INTERNET`` permission. Connecting to
   the internet introduces security concerns, which is why apps do not have internet connectivity by
   default. You need to explicitly declare that the app needs access to the internet. This
   declaration is considered a normal permission. To learn more about Android permissions and its
   types, please refer to the `Permissions on Android <https://developer.android.google.cn/guide/topics/permissions/overview>`__.

   In this step, your app declares the permission(s) it requires by including ``<uses-permission>``
   tags in the ``AndroidManifest.xml`` file.

   1. Open ``manifests/AndroidManifest.xml``. Add this line just before the ``<application>`` tag:

   .. code:: prettyprint

      <uses-permission android:name="android.permission.INTERNET" />

   2. Compile and run the app again.

   If you have a working internet connection, you see the JSON text containing data related to the
   Mars photos. Observe how the ``id`` and ``img_src`` are repeated for every image record. You
   learn more about the JSON format later in the codelab.

   |b82ddb79eff61995.png|

   3. Tap the **Back** button in your device or emulator to close the app.


**Exception Handling**


   There is a bug in your code. Perform the following steps to see it:

   1. Put your device or emulator into Airplane Mode to simulate a network connection error.
   2. Reopen the app from the Recents menu, or run the app from Android Studio.
   3. Click the **Logcat** tab in Android Studio and note the fatal exception in the log, which
      looks like the following:

   ::

      3302-3302/com.example.android.marsphotos E/AndroidRuntime: FATAL EXCEPTION: main
          Process: com.example.android.marsphotos, PID: 3302

   This error message indicates the application tried to connect and timed out. Exceptions like this
   one are very common in real time. Unlike the permission issue, this error is not something you
   can fix, but you can handle it. In the next step, you learn how to handle such exceptions.


**Exceptions**


   `Exceptions <https://developer.android.google.cn/reference/java/lang/Exception>`__ are errors
   that can occur during runtime, not compile time, and they terminate the app abruptly without
   notifying the user. This can result in a poor user experience. *Exception handling* is a
   mechanism by which you prevent the app from terminating abruptly and handle the situation in a
   user-friendly way.

   The reason for exceptions could be as simple as division by zero or an error with the network
   connection. These exceptions are similar to the ``IllegalArgumentException`` that a previous
   codelab discusses.

   Examples of potential issues while connecting to a server include the following:

   -  The URL or URI used in the API is incorrect.
   -  The server is unavailable, and the app could not connect to it.
   -  A network latency issue.
   -  Poor or no internet connection on the device.

   These exceptions can't be handled during compile time, but you can use a ``try-catch`` block to
   handle the exception in runtime. For further learning, refer to
   `Exceptions <https://kotlinlang.org/docs/reference/exceptions.html>`__.

   **Example syntax for try-catch block**

   .. code:: prettyprint

      try {
          // some code that can cause an exception.
      }
      catch (e: SomeException) {
          // handle the exception to avoid abrupt termination.
      }

   Inside the ``try`` block, you add the code where you anticipate an exception. In your app, this
   is a network call. In the ``catch`` block, you need to implement the code that prevents abrupt
   termination of the app. If there is an exception, then the ``catch`` block executes to recover
   from the error instead of terminating the app abruptly.

   1. In ``getMarsPhotos()``, inside the ``launch`` block, add a ``try`` block around the
      ``MarsApi`` call to handle exceptions.
   2. Add a ``catch`` block after the ``try`` block.

   .. code:: prettyprint

      import java.io.IOException


      viewModelScope.launch {
         try {
             val listResult = MarsApi.retrofitService.getPhotos()
             marsUiState = listResult
         } catch (e: IOException) {

         }
      }

   3. Run the app one more time. Notice that the app does not crash this time.


Add State UI


   In the ``MarsViewModel`` class, the status of the most recent web request, ``marsUiState``, is
   saved as a mutable state object. However, this class lacks the ability to save the different
   status: loading, success, and failure.

   -  **Loading** status indicates the app is waiting for data.
   -  **Success** status indicates the data was successfully retrieved from the web service.
   -  **Error** status indicates any network or connection errors.

   To represent these three states in your application, you use a *sealed interface*. A
   ``sealed interface`` makes it easy to manage state by limiting the possible values. In the Mars
   Photos app, you restrict the ``marsUiState`` web response to three states (data class objects):
   loading, success, and error, which looks like the following code:

   .. code:: prettyprint

      // No need to copy over
      sealed interface MarsUiState {
         data class Success : MarsUiState
         data class Loading : MarsUiState
         data class Error : MarsUiState
      }

   In the above code snippet, in the case of a successful response, you receive Mars photo
   information from the server. In order to store the data, add a constructor parameter to the
   ``Success`` data class.

   In the case of ``Loading`` and ``Error`` states, you don't need to set new data and create new
   objects; you are just passing the web response. Change the ``data`` class to ``Object`` to create
   the objects for the web responses.

   1. Open the ``ui/MarsViewModel.kt`` file. After the import statements, add the ``MarsUiState``
      sealed interface. This addition makes the values ``MarsUiState`` object can have exhaustive.

   .. code:: prettyprint

      sealed interface MarsUiState {
          data class Success(val photos: String) : MarsUiState
          object Error : MarsUiState
          object Loading : MarsUiState
      }

   2. Inside the ``MarsViewModel`` class, update the ``marsUiState`` definition. Change the type to
      ``MarsUiState`` and ``MarsUiState.Loading`` as its default value. Make the setter private to
      protect writes to the ``marsUiState``.

   .. code:: prettyprint

      var marsUiState: MarsUiState by mutableStateOf(MarsUiState.Loading)
        private set

   3. Scroll down to the ``getMarsPhotos()`` method. Update the ``marsUiState`` value to
      ``MarsUiState.Success`` and pass the ``listResult``.

   .. code:: prettyprint

      val listResult = MarsApi.retrofitService.getPhotos()
      marsUiState = MarsUiState.Success(listResult)

   4. Inside the ``catch`` block, handle the failure response. Set ``MarsUiState`` to ``Error``.

   .. code:: prettyprint

      catch (e: IOException) {
         marsUiState = MarsUiState.Error
      }

   5. You can lift the ``marsUiState`` assignment out of the ``try-catch`` block. Your completed
      function should look like the following code:

   .. code:: prettyprint

      private fun getMarsPhotos() {
         viewModelScope.launch {
             marsUiState = try {
                 val listResult = MarsApi.retrofitService.getPhotos()
                 MarsUiState.Success(listResult)
             } catch (e: IOException) {
                 MarsUiState.Error
             }
         }
      }

   6. In the ``screens/HomeScreen.kt`` file, add a ``when`` expression on the ``marsUiState``. If
      the ``marsUiState`` is ``MarsUiState.Success``, call ``ResultScreen`` and pass in
      ``marsUiState.photos``. Ignore the errors for now.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.fillMaxWidth

      fun HomeScreen(
         marsUiState: MarsUiState,
         modifier: Modifier = Modifier
      ) {
          when (marsUiState) {
              is MarsUiState.Success -> ResultScreen(
                  marsUiState.photos, modifier = modifier.fillMaxWidth()
              )
          }
      }

   **Note**: The ``marsUiState`` property is not a string any longer. You changed it to a
   ``MarsUiState`` sealed interface, which can have three different object values:
   ``MarsUiState.Loading``, ``MarsUiState.Success``, and ``MarsUiState.Error``.

   7. Inside the ``when`` block, add checks for ``MarsUiState.Loading`` and ``MarsUiState.Error``.
      Have the app display the ``LoadingScreen``, ``ResultScreen``, and ``ErrorScreen`` composables,
      which you implement later.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.fillMaxSize

      fun HomeScreen(
         marsUiState: MarsUiState,
         modifier: Modifier = Modifier
      ) {
          when (marsUiState) {
              is MarsUiState.Loading -> LoadingScreen(modifier = modifier.fillMaxSize())
              is MarsUiState.Success -> ResultScreen(
                  marsUiState.photos, modifier = modifier.fillMaxWidth()
              )

              is MarsUiState.Error -> ErrorScreen( modifier = modifier.fillMaxSize())
          }
      }

   **Note**: If you implement ``MarsUiState`` ``interface`` without a ``sealed`` keyword, it
   requires you to add a Success, Error, Loading and ``else`` branch. Since there is no fourth
   option (else), you use a ``sealed`` interface to tell the compiler that there are only three
   options (thus making the conditionals exhaustive).

   8. Open ``res/drawable/loading_animation.xml``. This drawable is an animation that rotates an
      image drawable, ``loading_img.xml``, around the center point. (You don't see the animation in
      the preview.)

   |92a448fa23b6d1df.png|

   9. In the ``screens/HomeScreen.kt`` file, below the ``HomeScreen`` composable, add the following
      ``LoadingScreen`` composable function to display the loading animation. The ``loading_img``
      drawable resource is included in the starter code.

   .. code:: prettyprint

      import androidx.compose.ui.res.painterResource
      import androidx.compose.ui.unit.dp
      import androidx.compose.foundation.layout.size
      import androidx.compose.foundation.Image


      @Composable
      fun LoadingScreen(modifier: Modifier = Modifier) {
          Image(
              modifier = modifier.size(200.dp),
              painter = painterResource(R.drawable.loading_img),
              contentDescription = stringResource(R.string.loading)
          )
      }

   10. Below the ``LoadingScreen`` composable, add the following ``ErrorScreen`` composable function
       so the app can display the error message.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Arrangement
      import androidx.compose.foundation.layout.Column
      import androidx.compose.foundation.layout.padding

      @Composable
      fun ErrorScreen(modifier: Modifier = Modifier) {
          Column(
              modifier = modifier,
              verticalArrangement = Arrangement.Center,
              horizontalAlignment = Alignment.CenterHorizontally
          ) {
              Image(
                  painter = painterResource(id = R.drawable.ic_connection_error), contentDescription = ""
              )
              Text(text = stringResource(R.string.loading_failed), modifier = Modifier.padding(16.dp))
          }
      }

   11. Run the app again with Airplane Mode turned on. The app does not close abruptly this time,
       and it displays the following error message:

   |28ba37928e0a9334.png|

   12. Turn off Airplane Mode on your phone or emulator. Run and test your app to make sure
       everything works correctly and you are able to see the JSON string.

   ====================== ======================
   |3931a215bc8e35fb.png| |b82ddb79eff61995.png|
   ====================== ======================


8. Parse the JSON response with kotlinx.serialization
---------------------------------------------------

**JSON**


   The requested data is typically formatted in one of the common data formats like XML or JSON.
   Each call returns structured data, and your app needs to know what that structure is in order to
   read the data from the response.

   For example, in this app, you are retrieving the data from the
   `https:// <https://mars.udacity.com/realestate>`__
   `android-kotlin-fun-mars-server.appspot.com/photos <https://android-kotlin-fun-mars-server.appspot.com/photos>`__
   server. When you enter this URL in the browser, you see a list of IDs and image URLs of the
   surface of Mars in a JSON format!


**Structure of sample JSON response**


   |showing keys values and JSON object|

   The structure of a JSON response has the following features:

   -  JSON response is an array, indicated by the square brackets. The array contains JSON objects.
   -  JSON objects are surrounded by curly brackets.
   -  Each JSON object contains a set of key-value pairs separated by a comma.
   -  A colon separates the key and value in a pair.
   -  Names are surrounded by quotes.
   -  Values can be numbers, strings, a boolean, an array, an object (JSON object), or null.

   For example, the ``img_src`` is a URL, which is a string. When you paste the URL into a web
   browser, you see a Mars surface image.

   |b4f9f196c64f02c3.png|

   In your app, now you're getting a JSON response from the Mars web service, which is a great
   start. But what you really need to display the images are Kotlin objects, not a big JSON string.
   This process is called *deserialization*.

   `Serialization <https://kotlinlang.org/docs/serialization.html>`__ is the process of converting
   data used by an application to a format that can be transferred over a network. As opposed to
   *serialization*, *deserialization* is the process of reading data from an external source (like a
   server) and converting it into a runtime object. They are both essential components of most
   applications that exchange data over the network.

   The ``kotlinx.serialization`` provides sets of libraries that convert a JSON string into Kotlin
   objects. There is a community developed third party library that works with Retrofit, 
   `Kotlin Serialization Converter <https://github.com/JakeWharton/retrofit2-kotlinx-serialization-converter#kotlin-serialization-converter>`__.

   In this task, you use the ``kotlinx.serialization`` library, to parse the JSON response from the
   web service into useful Kotlin objects that represent Mars photos. You change the app so that
   instead of displaying the raw JSON, the app displays the number of Mars photos returned.


Add ``kotlinx.serialization`` library dependencies


   1. Open ``build.gradle.kts (Module :app)``.
   2. In the ``plugins`` block, add ``kotlinx serialization`` plugin.

   .. code:: prettyprint

      id("org.jetbrains.kotlin.plugin.serialization") version "1.8.10"

   3. In the ``dependencies`` section, add the following code to include the
      ``kotlinx.serialization`` dependency. This dependency provides JSON serialization for Kotlin
      projects.

   .. code:: prettyprint

      // Kotlin serialization 
      implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.5.1")

   4. Locate the lines for the Retrofit scalar converter in the ``dependencies`` block and change it
      to use ``kotlinx-serialization-converter``:

   **Replace the following code**

   .. code:: prettyprint

      // Retrofit with scalar Converter
      implementation("com.squareup.retrofit2:converter-scalars:2.9.0")

   **with the following code**

   .. code:: prettyprint

      // Retrofit with Kotlin serialization Converter

      implementation("com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter:1.0.0")
      implementation("com.squareup.okhttp3:okhttp:4.11.0")

   5. Click **Sync Now** to rebuild the project with the new dependencies.

   **Note:** The project may show compiler errors related to the removed Retrofit scalar dependency.
   You fix those in the next steps.


**Implement the Mars Photo data class**


   A sample entry of the JSON response you get from the web service looks something like the
   following, similar to what you saw earlier:

   .. code:: prettyprint

      [
          {
              "id":"424906",
              "img_src":"http://mars.jpl.nasa.gov/msl-raw-images/msss/01000/mcam/1000ML0044631300305227E03_DXXX.jpg"
          },
      ...]

   In the example above, notice that each Mars photo entry has the following JSON key and value
   pairs:

   -  **``id``:** the ID of the property, as a string. Since it is wrapped in quotes (``" "``), it
      is of the type ``String``, not ``Integer``.
   -  **``img_src``:** The image's URL, as a string.

   kotlinx.serialization parses this JSON data and converts it into Kotlin objects. To do this,
   kotlinx.serialization needs to have a Kotlin data class to store the parsed results. In this
   step, you create the data class ``MarsPhoto``.

   1. Right-click on the **network** package and select **New > Kotlin File/Class**.
   2. In the dialog, select **Class** and enter ``MarsPhoto`` as the name of the class. This action
      creates a new file called ``MarsPhoto.kt`` in the ``network`` package.
   3. Make ``MarsPhoto`` a data class by adding the ``data`` keyword before the class definition.
   4. Change the curly braces ``{}`` to parentheses ``()``. This change gives you an error because
      data classes must have at least one property defined.

   .. code:: prettyprint

      data class MarsPhoto()

   5. Add the following properties to the ``MarsPhoto`` class definition.

   .. code:: prettyprint

      data class MarsPhoto(
          val id: String,  val img_src: String
      )

   6. To make ``MarsPhoto`` class serializable annotating it with ``@Serializable``.

   .. code:: prettyprint

      import kotlinx.serialization.Serializable

      @Serializable
      data class MarsPhoto(
          val id: String,  val img_src: String
      )

   Notice that each of the variables in the ``MarsPhoto`` class corresponds to a key name in the
   JSON object. To match the types in our specific JSON response, you use ``String`` objects for all
   the values.

   When ``kotlinx serialization`` parses the JSON, it matches the keys by name and fills the data
   objects with appropriate values.


**@SerialName Annotation**


   Sometimes the key names in a JSON response can make confusing Kotlin properties or may not match
   recommended coding style. For example, in the JSON file, the ``img_src`` key uses an underscore,
   whereas Kotlin convention for properties uses upper and lowercase letters (camel case).

   To use variable names in your data class that differ from the key names in the JSON response, use
   the ``@SerialName`` annotation. In the following example, the name of the variable in the data
   class is ``imgSrc``. The variable can be mapped to the JSON attribute ``img_src`` using
   ``@SerialName(value = "img_src")``.

   1. Replace the line for the ``img_src`` key with the line shown below.

   .. code:: prettyprint

      import kotlinx.serialization.SerialName

      @SerialName(value = "img_src") 
      val imgSrc: String


Update MarsApiService and MarsViewModel


   In this task, you will use the ``kotlinx.serialization`` converter to convert the JSON object to
   Kotlin objects.

   1. Open ``network/MarsApiService.kt``.
   2. Notice the unresolved reference errors for ``ScalarsConverterFactory``. These errors are a
      result of the Retrofit dependency change in a previous section.
   3. Delete the import for ``ScalarConverterFactory``. You fix the other error later.

   **Remove:**

   .. code:: prettyprint

      import retrofit2.converter.scalars.ScalarsConverterFactory

   4. In the *``retrofit``* object declaration, change the Retrofit builder to use the
      ``kotlinx.serialization`` instead of the ``ScalarConverterFactory``.

   .. code:: prettyprint

      import com.jakewharton.retrofit2.converter.kotlinx.serialization.asConverterFactory
      import kotlinx.serialization.json.Json
      import okhttp3.MediaType

      private val retrofit = Retrofit.Builder()
              .addConverterFactory(Json.asConverterFactory("application/json".toMediaType()))
              .baseUrl(BASE_URL)
              .build()

   **Note**: If Android Studio shows you any warning regarding
   ``kotlinx.serialization.ExperimentalSerializationApi`` ignore it for now. You don't have to worry
   about this warning. It will be resolved in the later versions of Kotlin.

   |857006993db2a1a3.png|

   Now that you have the ``kotlinx.serialization`` in place, you can ask Retrofit to return a list
   of ``MarsPhoto`` objects from the JSON array, instead of returning a JSON string.

   5. Update the ``MarsApiService`` interface for Retrofit to return a list of ``MarsPhoto`` objects
      instead of returning a ``String``.

   .. code:: prettyprint

      interface MarsApiService {
          @GET("photos")
          suspend fun getPhotos(): List<MarsPhoto>
      }

   6. Make similar changes to the ``viewModel``. Open ``MarsViewModel.kt`` and scroll down to the
      ``getMarsPhotos()`` method.

   In the ``getMarsPhotos()`` method, ``listResult`` is a ``List<MarsPhoto>`` and not a ``String``
   anymore. The size of that list is the number of photos that were received and parsed.

   7. To print the number of photos retrieved, update ``marsUiState`` as follows:

   .. code:: prettyprint

      val listResult = MarsApi.retrofitService.getPhotos()
      marsUiState = MarsUiState.Success(
         "Success: ${listResult.size} Mars photos retrieved"
      )

   8. Make sure Airplane Mode is turned *off* on your device or emulator. Compile and run the app.

   This time, the message should show the number of properties returned from the web service, and
   not a big JSON string:

   |a59e55909b6e9213.png|

   **Note:** If your internet connection is not working, make sure that you turn off Airplane Mode
   on your device or emulator.


9. Solution code
----------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos.git
      $ cd basic-android-kotlin-compose-training-mars-photos
      $ git checkout repo-starter

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos/archive/refs/heads/repo-starter.zip>`__

   **Note:** The solution code is in the ``repo-starter`` branch of the downloaded repository.

   If you want to see the solution code for this codelab, view it on
   `GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-mars-photos/tree/repo-starter>`__.


10. Summary
-----------


**REST web services**


   -  A *web service* is software-based functionality, offered over the internet, that enables your
      app to make requests and get data back.
   -  Common web services use a `REST <https://en.wikipedia.org/wiki/Representational_state_transfer>`__ 
      architecture. Web services that offer REST architecture are known as *RESTful* services. 
      RESTful web services are built using standard web components and protocols.
   -  You make a request to a REST web service in a standardized way via URIs.
   -  To use a web service, an app must establish a network connection and communicate with the
      service. Then the app must receive and parse response data into a format the app can use.
   -  The `Retrofit <https://square.github.io/retrofit/>`__ library is a client library that enables
      your app to make requests to a REST web service.
   -  Use converters to tell Retrofit what to do with the data it sends to the web service and gets
      back from the web service. For example, the ``ScalarsConverter`` treats the web service data
      as a ``String`` or other primitive.
   -  To enable your app to make connections to the internet, add the
      ``"android.permission.INTERNET"`` permission in the Android manifest.
   -  Lazy initialization delegates the creation of an object to the first time it is used. It
      creates the reference but not the object. When an object is accessed for the first time, a
      reference is created and used every time thereafter.


**JSON parsing**


   -  The response from a web service is often formatted in `JSON <https://www.json.org/>`__, a
      common format to represent structured data.
   -  A JSON object is a collection of key-value pairs.
   -  A collection of JSON objects is a JSON array. You get a JSON array as a response from a web
      service.
   -  The keys in a key-value pair are surrounded by quotes. The values can be numbers or strings.
   -  In Kotlin, data serialization tools are available in a separate component,
      `kotlinx.serialization <https://github.com/Kotlin/kotlinx.serialization>`__. The
      *kotlinx.serialization* provides sets of libraries that convert a JSON string into Kotlin
      objects.
   -  There is a community developed Kotlin Serialization Converter library for Retrofit:
      `retrofit2-kotlinx-serialization-converter <https://github.com/JakeWharton/retrofit2-kotlinx-serialization-converter#kotlin-serialization-converter>`__.
   -  The *kotlinx.serialization* matches the keys in a JSON response with properties in a data
      object that have the same name.
   -  To use a different property name for a key, annotate that property with the ``@SerialName``
      annotation and the JSON key ``value``.


11. Learn more
--------------

   Android developer documentation:

   -  `Guide to app architecture \| Android Developers <https://developer.android.google.cn/topic/architecture>`__
   -  `ViewModel overview <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__
   -  `ViewModelScope <https://developer.android.google.cn/topic/libraries/architecture/coroutines#viewmodelscope>`__

   Kotlin documentation:

   -  `Exceptions: try, catch, finally, throw, Nothing <https://kotlinlang.org/docs/reference/exceptions.html>`__
   -  `Coroutines, official documentation <https://kotlinlang.org/docs/reference/coroutines-overview.html>`__
   -  `Coroutine context and dispatchers <https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html>`__
   -  `Serialization \| Kotlin <https://kotlinlang.org/docs/serialization.html#0>`__

   Other:

   -  `Retrofit <https://square.github.io/retrofit/>`__
   -  `Retrofit 2 Converter.Factory for Kotlin serialization <https://github.com/JakeWharton/retrofit2-kotlinx-serialization-converter>`__

.. |68f4ff12cc1e2d81.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/68f4ff12cc1e2d81.png
.. |a59e55909b6e9213.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/a59e55909b6e9213.png
.. |de3d8666ecee9d1c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/de3d8666ecee9d1c.png
.. |95328ffbc9d7104b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/95328ffbc9d7104b.png
.. |76551dbe9fc943aa.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/76551dbe9fc943aa.png
.. |301162f0dca12fcf.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/301162f0dca12fcf.png
.. |7ced9b4ca9c65af3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/7ced9b4ca9c65af3.png
.. |5bbeef4ded3e84cf.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/5bbeef4ded3e84cf.png
.. |83e8a6eb79249ebe.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/83e8a6eb79249ebe.png
.. |26043df178401c6a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/26043df178401c6a.png
.. |8c3a5c3249570e57.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/8c3a5c3249570e57.png
.. |b82ddb79eff61995.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/b82ddb79eff61995.png
.. |92a448fa23b6d1df.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/92a448fa23b6d1df.png
.. |28ba37928e0a9334.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/28ba37928e0a9334.png
.. |3931a215bc8e35fb.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/3931a215bc8e35fb.png
.. |b82ddb79eff61995.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/b82ddb79eff61995.png
.. |showing keys values and JSON object| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/fde4f6f199990ae8.png
.. |b4f9f196c64f02c3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/b4f9f196c64f02c3.png
.. |857006993db2a1a3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/857006993db2a1a3.png
â­ Add repository and Manual DI
================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-repository


1. Before you begin
-------------------


**Introduction**


   In the previous codelab, you learned how to get data from a web service by having the
   ``ViewModel`` retrieve the URLs of Mars photos from the network using an API service. While this
   approach works and is simple to implement, it does not scale well as your app grows and needs to
   work with more than one data source. To address this issue, Android architecture best practices
   recommend separating out your UI layer and data layer.

   In this codelab, you will refactor the **Mars Photos** app into separate UI and data layers. You
   will learn how to implement the repository pattern and use dependency injection. Dependency
   injection creates a more flexible coding structure that helps with development and testing.


**Prerequisites**


   -  Able to retrieve JSON from a REST web service and parse that data into Kotlin objects using
      the `Retrofit <https://square.github.io/retrofit/>`__ and `Serialization (kotlinx.serialization) <https://kotlinlang.org/docs/serialization.html>`__ 
      libraries.
   -  Knowledge of how to use a `REST <https://en.wikipedia.org/wiki/Representational_state_transfer>`__ 
      web service.
   -  Able to implement coroutines in your app.


**What you'll learn**


   -  Repository pattern
   -  Dependency injection


**What you'll build**


   -  Modify the **Mars Photos** app to separate the app into a UI layer and a data layer.
   -  While separating out the data layer, you will implement the repository pattern.
   -  Use dependency injection to create a loosely coupled codebase.


**What you need**


   -  A computer with a modern web browser, such as the latest version of
      `Chrome <https://www.google.com/chrome/>`__


Get the starter code


   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos/archive/refs/heads/repo-starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos.git
      $ cd basic-android-kotlin-compose-training-mars-photos
      $ git checkout repo-starter

   **Note:** The starter code is in the ``repo-starter`` branch of the cloned repository.

   You can browse the code in the `Mars Photos <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-mars-photos/tree/repo-starter>`__
   GitHub repository.


2. Separate the UI layer and Data layer
---------------------------------------


**Why different layers?**


   Separating the code into different layers makes your app more scalable, more robust, and easier
   to test. Having multiple layers with clearly defined boundaries also makes it easier for multiple
   developers to work on the same app without negatively impacting each other.

   `Android's Recommended app architecture <https://developer.android.google.cn/topic/architecture#recommended-app-arch>`__
   states that an app should have at least a UI layer and a data layer.

   In this codelab, you concentrate on the data layer and make changes so your app follows the
   recommended best practices.


**What is a data layer?**


   A data layer is responsible for the business logic of your app and for sourcing and saving data
   for your app. The data layer exposes data to the UI layer using the `Unidirectional Data Flow <https://developer.android.google.cn/topic/architecture#unidirectional-data-flow>`__
   pattern. Data can come from multiple sources, like a network request, a local database, or from a
   file on the device.

   An app may even have more than one source of data. When the app opens, it retrieves data from a
   local database on the device, which is the first source. While the app is running, it makes a
   network request to the second source to retrieve newer data.

   By having the data in a separate layer from the UI code, you can make changes in one part of the
   code without affecting another. This approach is part of a design principle called 
   `separation of concerns <https://en.wikipedia.org/wiki/Separation_of_concerns>`__. 
   A section of code focuses on its own concern and encapsulates its inner workings from other code. 
   Encapsulation is a form of hiding how the code internally works from other sections of code.
   When one section of code needs to interact with another section of code, it does it through 
   an interface.

   The UI layer's concern is displaying the data it is provided. The UI no longer retrieves the data
   as that is the data layer's concern.

   The data layer is made up of one or more repositories. Repositories themselves contain zero or
   more data sources.

   |dbf927072d3070f0.png|

   Best practices require the app to have a repository for each type of data source your app uses.

   In this codelab, the app has one data source, so it has one repository after you refactor the
   code. For this app, the repository that retrieves data from the internet completes the data
   source's responsibilities. It does so by making a network request to an API. If the data source
   coding is more complex or additional data sources are added, the data source responsibilities are
   encapsulated in separate data source classes, and the repository is responsible for managing all
   the data sources.


**What is a repository?**


   In general a repository class:

   -  Exposes data to the rest of the app.
   -  Centralizes changes to data.
   -  Resolves conflicts between multiple data sources.
   -  Abstracts sources of data from the rest of the app.
   -  Contains business logic.

   The **Mars Photos** app has a single data source, which is the network API call. It does not have
   any business logic, as it is just retrieving data. The data is exposed to the app through the
   repository class, which abstracts away the source of the data.

   |ff7a7cd039402747.png|


3. Create Data layer
--------------------

   First, you need to create the repository class. The Android developers guide states that
   repository classes are named after the data they're responsible for. 
   The `repository naming convention <https://developer.android.google.cn/topic/architecture/data-layer#naming-conventions>`__
   is **type of data + Repository**. In your app, this is ``MarsPhotosRepository``.


**Create repository**


   1. Right-click on **com.example.marsphotos** and select **New > Package**.
   2. In the dialog, enter ``data``.
   3. Right-click on the ``data`` package and select **New > Kotlin Class/File.**
   4. In the dialog, select **Interface** and enter ``MarsPhotosRepository`` as the name of the
      interface.
   5. Inside the ``MarsPhotosRepository`` interface, add an abstract function called
      ``getMarsPhotos()``, which returns a list of ``MarsPhoto`` objects. It is called from a
      coroutine, so declare it with ``suspend``.

   .. code:: prettyprint

      import com.example.marsphotos.model.MarsPhoto

      interface MarsPhotosRepository {
          suspend fun getMarsPhotos(): List<MarsPhoto>
      }

   6. Below the interface declaration, create a class named ``NetworkMarsPhotosRepository`` for
      implementing the ``MarsPhotosRepository`` interface.
   7. Add interface ``MarsPhotosRepository`` to the class declaration.

   Because you did not override the abstract method of the interface, an error message appears. The
   next step addresses this error.

   |Android studio screenshot showing MarsPhotosRepository interface and class
   NetworkMarsPhotosRepository|

   8. Inside the ``NetworkMarsPhotosRepository`` class, override the abstract function
      ``getMarsPhotos()``. This function returns the data from calling
      ``MarsApi.retrofitService.getPhotos()``.

   .. code:: prettyprint

      import com.example.marsphotos.network.MarsApi

      class NetworkMarsPhotosRepository() : MarsPhotosRepository {
         override suspend fun getMarsPhotos(): List<MarsPhoto> {
             return MarsApi.retrofitService.getPhotos()
         }
      }

   Next, you need to update the ``ViewModel`` code to use the repository to get the data as Android
   best practices suggest.

   9.  Open the ``ui/screens/MarsViewModel.kt`` file.
   10. Scroll down to the ``getMarsPhotos()`` method.
   11. Replace the line "``val listResult = MarsApi.retrofitService.getPhotos()``" with the
       following code:

   .. code:: prettyprint

      import com.example.marsphotos.data.NetworkMarsPhotosRepository

      val marsPhotosRepository = NetworkMarsPhotosRepository()
      val listResult = marsPhotosRepository.getMarsPhotos()

   |5313985852c151aa.png|

   12. Run the app. Notice that the results displayed are the same as the previous results.

   Instead of the ``ViewModel`` directly making the network request for the data, the repository
   provides the data. The ``ViewModel`` no longer directly references the ``MarsApi`` code. |flow
   diagram to show how the data layer is accessed directly from Viewmodel before. Now we have Mars
   photos repository|

   This approach helps make the code retrieving the data loosely coupled from ``ViewModel``. Being
   loosely coupled allows changes to be made to the ``ViewModel`` or the repository without
   adversely affecting the other, as long as the repository has a function called
   ``getMarsPhotos()``.

   We are now able to make changes to the implementation inside the repository without affecting the
   caller. For larger apps, this change can support multiple callers.


4. Dependency injection
-----------------------

   Many times, classes require objects of other classes to function. When a class requires another
   class, the required class is called a **dependency**.

   In the following examples, the ``Car`` object depends on an ``Engine`` object.

   There are two ways for a class to get these required objects. One way is for the class to
   instantiate the required object itself.

   .. code:: prettyprint

      interface Engine {
          fun start()
      }

      class GasEngine : Engine {
          override fun start() {
              println("GasEngine started!")
          }
      }

      class Car {

          private val engine = GasEngine()

          fun start() {
              engine.start()
          }
      }

      fun main() {
          val car = Car()
          car.start()
      }

   The other way is by passing the required object in as an argument.

   .. code:: prettyprint

      interface Engine {
          fun start()
      }

      class GasEngine : Engine {
          override fun start() {
              println("GasEngine started!")
          }
      }

      class Car(private val engine: Engine) {
          fun start() {
              engine.start()
          }
      }

      fun main() {
          val engine = GasEngine()
          val car = Car(engine)
          car.start()
      }

   Having a class instantiate the required objects is easy, but this approach makes the code
   inflexible and more difficult to test as the class and the required object are tightly coupled.

   The calling class needs to call the object's constructor, which is an implementation detail. If
   the constructor changes, the calling code needs to change, too.

   To make the code more flexible and adaptable, a class must not instantiate the objects it depends
   on. The objects it depends on must be instantiated outside the class and then passed in. This
   approach creates more flexible code, as the class is no longer hardcoded to one particular
   object. The implementation of the required object can change without needing to modify the
   calling code.

   Continuing with the preceding example, if an ``ElectricEngine`` is needed, it can be created and
   passed into the ``Car`` class. The ``Car`` class does not need to be modified in any way.

   .. code:: prettyprint

      interface Engine {
          fun start()
      }

      class ElectricEngine : Engine {
          override fun start() {
              println("ElectricEngine started!")
          }
      }

      class Car(private val engine: Engine) {
          fun start() {
              engine.start()
          }
      }

      fun main() {
          val engine = ElectricEngine()
          val car = Car(engine)
          car.start()
      }

   Passing in the required objects is called *dependency injection* (DI). It is also known as
   `inversion of control <https://en.wikipedia.org/wiki/Inversion_of_control>`__.

   DI is when a dependency is provided at runtime instead of being hardcoded into the calling class.

   Implementing dependency injection:

   -  **Helps with the reusability of code.** Code is not dependent on a specific object, which
      allows for greater flexibility.
   -  **Makes refactoring easier.** Code is loosely coupled, so refactoring one section of code does
      not impact another section of code.
   -  **Helps with testing.** Test objects can be passed in during testing.

   One example of how DI can help with testing is when testing the network calling code. For this
   test, you are really trying to test that the network call is made and that data is returned. If
   you had to pay each time you made a network request during a test, you might decide to skip
   testing this code, as it can get expensive. Now, imagine if we can fake the network request for
   testing. How much happier (and wealthier) does that make you? For testing, you can pass a test
   object to the repository that returns fake data when called without actually performing a real
   network call. |1ea410d6670b7670.png|

   We want to make the ``ViewModel`` testable, but it currently depends on a repository that makes
   actual network calls. When testing with the real production repository, it makes many network
   calls. To fix this issue, instead of the ``ViewModel`` creating the repository, we need a way to
   decide and pass a repository instance to use for production and test dynamically.

   This process is done by implementing an application container that provides the repository to
   ``MarsViewModel``.

   A `container <https://developer.android.google.cn/training/dependency-injection/manual#dependencies-container>`__
   is an object that contains the dependencies that the app requires. These dependencies are used
   across the whole application, so they need to be in a common place that all activities can use.
   You can create a subclass of the Application class and store a reference to the container.


Create an Application Container


   1. Right-click on the ``data`` package and select **New > Kotlin Class/File**.
   2. In the dialog, select **Interface**, and enter ``AppContainer`` as the name of the interface.
   3. Inside the ``AppContainer`` interface, add an abstract property called
      ``marsPhotosRepository`` of type ``MarsPhotosRepository``. |7ed26c6dcf607a55.png|
   4. Below the interface definition, create a class called ``DefaultAppContainer`` that implements
      the interface ``AppContainer``.
   5. From ``network/MarsApiService.kt``, move the code for variables ``BASE_URL``, ``retrofit``,
      and ``retrofitService`` into the ``DefaultAppContainer`` class so that they are all located
      within the container that maintains the dependencies.

   .. code:: prettyprint

      import retrofit2.Retrofit
      import com.example.marsphotos.network.MarsApiService
      import com.jakewharton.retrofit2.converter.kotlinx.serialization.asConverterFactory
      import kotlinx.serialization.json.Json
      import okhttp3.MediaType.Companion.toMediaType

      class DefaultAppContainer : AppContainer {

          private const val BASE_URL =
              "https://android-kotlin-fun-mars-server.appspot.com"

          private val retrofit: Retrofit = Retrofit.Builder()
              .addConverterFactory(Json.asConverterFactory("application/json".toMediaType()))
              .baseUrl(BASE_URL)
              .build()

          private val retrofitService: MarsApiService by lazy {
              retrofit.create(MarsApiService::class.java)
          }

      }

   6. For variable ``BASE_URL``, remove the ``const`` keyword. Removing ``const`` is necessary
      because ``BASE_URL`` is no longer a top level variable and is now a property of the
      ``DefaultAppContainer`` class. Refactor it to camelcase ``baseUrl``.
   7. For variable ``retrofitService``, add a ``private`` visibility modifier. The ``private``
      modifier is added because variable ``retrofitService`` is only used inside the class by
      property ``marsPhotosRepository``, so it does not need to be accessible outside the class.
   8. The ``DefaultAppContainer`` class implements the interface ``AppContainer``, so we need to
      override the ``marsPhotosRepository`` property. After the variable ``retrofitService``, add
      the following code:

   .. code:: prettyprint

      override val marsPhotosRepository: MarsPhotosRepository by lazy {
          NetworkMarsPhotosRepository(retrofitService)
      }

   Completed ``DefaultAppContainer`` class should look like this:

   .. code:: prettyprint

      class DefaultAppContainer : AppContainer {

          private val baseUrl =
              "https://android-kotlin-fun-mars-server.appspot.com"

          /**
           * Use the Retrofit builder to build a retrofit object using a kotlinx.serialization converter
           */
          private val retrofit = Retrofit.Builder()
              .addConverterFactory(Json.asConverterFactory("application/json".toMediaType()))
              .baseUrl(baseUrl)
              .build()
          
          private val retrofitService: MarsApiService by lazy {
              retrofit.create(MarsApiService::class.java)
          }

          override val marsPhotosRepository: MarsPhotosRepository by lazy {
              NetworkMarsPhotosRepository(retrofitService)
          }
      }

   9.  Open the ``data/MarsPhotosRepository.kt`` file. We are now passing ``retrofitService`` to
       ``NetworkMarsPhotosRepository``, and you need to modify the ``NetworkMarsPhotosRepository``
       class.
   10. In the ``NetworkMarsPhotosRepository`` class declaration, add the constructor parameter
       ``marsApiService`` as shown in the following code.

   .. code:: prettyprint

      import com.example.marsphotos.network.MarsApiService

      class NetworkMarsPhotosRepository(
          private val marsApiService: MarsApiService
      ) : MarsPhotosRepository {

   11. In the ``NetworkMarsPhotosRepository`` class, in the ``getMarsPhotos()`` function, change the
       return statement to retrieve data from ``marsApiService``.

   .. code:: prettyprint

      override suspend fun getMarsPhotos(): List<MarsPhoto> = marsApiService.getPhotos()
      }

   12. Remove the following import from the ``MarsPhotosRepository.kt`` file.

   .. code:: prettyprint

      // Remove
      import com.example.marsphotos.network.MarsApi

   From the ``network/MarsApiService.kt`` file, we moved all the code out of the object. We can now
   delete the remaining object declaration as it is no longer needed.

   13. Delete the following code:

   .. code:: prettyprint

      object MarsApi {

      }


5. Attach application container to the app
------------------------------------------

   The steps in this section connect the application object to the application container as shown in
   the following figure.

   |92e7d7b79c4134f0.png|

   1. Right-click on ``com.example.marsphotos`` and select **New > Kotlin Class/File**.
   2. In the dialog, enter ``MarsPhotosApplication``. This class inherits from the application
      object, so you need to add it to the class declaration.

   .. code:: prettyprint

      import android.app.Application

      class MarsPhotosApplication : Application() {
      }

   3. Inside the ``MarsPhotosApplication`` class, declare a variable called ``container`` of the
      type ``AppContainer`` to store the ``DefaultAppContainer`` object. The variable is initialized
      during the call to ``onCreate()``, so the variable needs to be marked with the ``lateinit``
      modifier.

   .. code:: prettyprint

      import com.example.marsphotos.data.AppContainer
      import com.example.marsphotos.data.DefaultAppContainer

      lateinit var container: AppContainer
      override fun onCreate() {
          super.onCreate()
          container = DefaultAppContainer()
      }

   4. The complete ``MarsPhotosApplication.kt`` file should look like the following code:

   .. code:: prettyprint

      package com.example.marsphotos

      import android.app.Application
      import com.example.marsphotos.data.AppContainer
      import com.example.marsphotos.data.DefaultAppContainer

      class MarsPhotosApplication : Application() {
          lateinit var container: AppContainer
          override fun onCreate() {
              super.onCreate()
              container = DefaultAppContainer()
          }
      }

   5. You need to update the Android manifest so the app uses the application class you just
      defined. Open the ``manifests/AndroidManifest.xml`` file.

   |759144e4e0634ed8.png|

   6. In the ``application`` section, add the ``android:name`` attribute with a value of application
      class name ``".MarsPhotosApplication"``.

   .. code:: prettyprint

      <application
         android:name=".MarsPhotosApplication"
         android:allowBackup="true"
      ...
      </application>


6. Add repository to ViewModel
------------------------------

   Once you complete these steps, the ``ViewModel`` can call the repository object to retrieve Mars
   data.

   |7425864315cb5e6f.png|

   1. Open the ``ui/screens/MarsViewModel.kt`` file.
   2. In the class declaration for ``MarsViewModel``, add a private constructor parameter
      ``marsPhotosRepository`` of type ``MarsPhotosRepository``. The value for the constructor
      parameter comes from the application container because the app is now using dependency
      injection.

   .. code:: prettyprint

      import com.example.marsphotos.data.MarsPhotosRepository


      class MarsViewModel(private val marsPhotosRepository: MarsPhotosRepository) : ViewModel(){

   3. In the ``getMarsPhotos()`` function, remove the following line of code as
      ``marsPhotosRepository`` is now being populated in the constructor call.

   .. code:: prettyprint

      val marsPhotosRepository = NetworkMarsPhotosRepository()

   4. Because the Android framework does not allow a ``ViewModel`` to be passed values in the
      constructor when created, we implement a ``ViewModelProvider.Factory`` object, which lets us
      get around this limitation.

   The `Factory pattern <https://en.wikipedia.org/wiki/Factory_method_pattern>`__ is a creational
   pattern used to create objects. The ``MarsViewModel.Factory`` object uses the application
   container to retrieve the ``marsPhotosRepository``, and then passes this repository to the
   ``ViewModel`` when the ``ViewModel`` object is created.

   5. Below the function ``getMarsPhotos()``, type the code for the companion object.

   A companion object helps us by having a single instance of an object that is used by everyone
   without needing to create a new instance of an expensive object. This is an implementation
   detail, and separating it lets us make changes without impacting other parts of the app's code.

   The ``APPLICATION_KEY`` is part of the ``ViewModelProvider.AndroidViewModelFactory.Companion``
   object and is used to find the app's ``MarsPhotosApplication`` object, which has the
   ``container`` property used to retrieve the repository used for dependency injection.

   .. code:: prettyprint

      import androidx.lifecycle.ViewModelProvider
      import androidx.lifecycle.ViewModelProvider.AndroidViewModelFactory.Companion.APPLICATION_KEY
      import androidx.lifecycle.viewModelScope
      import androidx.lifecycle.viewmodel.initializer
      import androidx.lifecycle.viewmodel.viewModelFactory
      import com.example.marsphotos.MarsPhotosApplication

      companion object {
         val Factory: ViewModelProvider.Factory = viewModelFactory {
             initializer {
                 val application = (this[APPLICATION_KEY] as MarsPhotosApplication)
                 val marsPhotosRepository = application.container.marsPhotosRepository
                 MarsViewModel(marsPhotosRepository = marsPhotosRepository)
             }
         }
      }

   6. Open the ``theme/MarsPhotosApp.kt`` file, inside the ``MarsPhotosApp()`` function, update the
      ``viewModel()`` to use the factory.

   .. code:: prettyprint

      Surface(
                  // ...
              ) {
                  val marsViewModel: MarsViewModel =
         viewModel(factory = MarsViewModel.Factory)
                  // ...
              }

   This ``marsViewModel`` variable is populated by the call to the ``viewModel()`` function that is
   passed the ``MarsViewModel.Factory`` from the companion object as an argument to create the
   ``ViewModel``.

   7. Run the app to confirm it is still behaving as it was previously.

   Congratulations on refactoring the **Mars Photos** app to use a repository and dependency
   injection! By implementing a data layer with a repository, the UI and data source code have been
   separated to follow Android best practices.

   By using dependency injection, it is easier to test the ``ViewModel``. Your app is now more
   flexible, robust, and ready to scale.

   After making these improvements, it is now time to learn how to test them. Testing keeps your
   code behaving as expected and reduces the possibility of introducing bugs as you continue to work
   on the code.


7. Get setup for local tests
----------------------------

   In the previous sections, you have implemented a repository to abstract direct interaction with
   the REST API service away from the ``ViewModel``. This practice lets you test small pieces of
   code that have a limited purpose. Tests for small pieces of code with limited functionality are
   easier to build, implement, and understand than tests written for large pieces of code that have
   multiple functionalities.

   You also have implemented the repository by leveraging interfaces, inheritance, and dependency
   injection. In the coming sections, you learn why these architectural best practices make testing
   easier. Additionally, you have used Kotlin coroutines to make the network request. Testing code
   that uses coroutines requires additional steps to account for the asynchronous execution of code.
   These steps are covered later in this codelab.


**Add the local test dependencies**


   Add the following dependencies to ``app/build.gradle.kts``.

   .. code:: prettyprint

      testImplementation("junit:junit:4.13.2")
      testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.1")


**Create the local test directory**


   1. Create a local test directory by right-clicking the **src** directory in the project view and
      selecting **New > Directory > test/java**.
   2. Create a new package in the test directory named ``com.example.marsphotos``.


8. Create fake data and dependencies for tests
----------------------------------------------

   In this section, you learn how dependency injection can help you write local tests. Earlier in
   the codelab, you created a repository that depends on an API service. You then modified the
   ``ViewModel`` to depend on the repository.

   Each local test needs to only test one thing. For example, when you test the functionality of the
   view model, you do not want to test the functionality of the repository or the API service.
   Likewise, when you test the repository, you do not want to test the API service.

   By using interfaces and subsequently using dependency injection to include classes that inherit
   from those interfaces, you can simulate the functionality of those dependencies using fake
   classes made solely for the purpose of testing. Injecting fake classes and data sources for
   testing allows code to be tested in isolation, with repeatability and consistency.

   This first thing you need is fake data to use in the fake classes that you create later.

   1. In the test directory, create a package under ``com.example.marsphotos`` called ``fake``.
   2. Create a new Kotlin object in the ``fake`` directory called ``FakeDataSource``.
   3. In this object, create a property set to a list of ``MarsPhoto`` objects. The list does not
      have to be long, but it should contain at least two objects.

   **Note:** For the purposes of the tests you will write in this codelab, the data stored in the
   objects does not necessarily need to be representative of the data that the API returns. In other
   words, you don't need to include valid IDs or URLs.

   .. code:: prettyprint

      object FakeDataSource {

         const val idOne = "img1"
         const val idTwo = "img2"
         const val imgOne = "url.1"
         const val imgTwo = "url.2"
         val photosList = listOf(
             MarsPhoto(
                 id = idOne,
                 imgSrc = imgOne
             ),
             MarsPhoto(
                 id = idTwo,
                 imgSrc = imgTwo
             )
         )
      }

   It was mentioned earlier in this codelab that the repository depends on the API service. To
   create a repository test, there must be a fake API service that returns the fake data you just
   created. When this fake API service is passed into the repository, the repository receives the
   fake data when the methods in the fake API service are called.

   1. In the ``fake`` package, create a new class called ``FakeMarsApiService``.
   2. Set up the ``FakeMarsApiService`` class to inherit from the ``MarsApiService`` interface.

   .. code:: prettyprint

      class FakeMarsApiService : MarsApiService {
      }

   3. Override the ``getPhotos()`` function.

   .. code:: prettyprint

      override suspend fun getPhotos(): List<MarsPhoto> {
      }

   4. Return the list of fake photos from the ``getPhotos()`` method.

   .. code:: prettyprint

      override suspend fun getPhotos(): List<MarsPhoto> {
         return FakeDataSource.photosList
      }

   Remember, if you are still unclear on the purpose of this class, that's okay! The uses of this
   fake class are explained in greater detail in the next section.


9. Write a repository test
--------------------------

   In this section, you test the ``getMarsPhotos()`` method of the ``NetworkMarsPhotosRepository``
   class. This section clarifies the usage of fake classes and demonstrates how to test coroutines.

   1. In the fake directory, create a new class called ``NetworkMarsRepositoryTest``.
   2. Create a new method in the class you just created called
      ``networkMarsPhotosRepository_getMarsPhotos_verifyPhotoList()`` and annotate it with
      ``@Test``.

   .. code:: prettyprint

      @Test
      fun networkMarsPhotosRepository_getMarsPhotos_verifyPhotoList(){
      }

   To test the repository, you will need an instance of the ``NetworkMarsPhotosRepository``. Recall
   that this class depends on the ``MarsApiService`` interface. This is where you leverage the fake
   API service from the previous section.

   3. Create an instance of the ``NetworkMarsPhotosRepository`` and pass the ``FakeMarsApiService``
      as the ``marsApiService`` parameter.

   .. code:: prettyprint

      @Test
      fun networkMarsPhotosRepository_getMarsPhotos_verifyPhotoList(){
          val repository = NetworkMarsPhotosRepository(
             marsApiService = FakeMarsApiService()
          )
      }

   By passing the fake API service, any calls to the ``marsApiService`` property in the repository
   result in a call to the ``FakeMarsApiService``. By passing fake classes for dependencies, you can
   control exactly what the dependency returns. This approach ensures that the code you are testing
   doesn't depend on untested code or APIs that could change or have unforeseen problems. Such
   situations can cause your test to fail, even when nothing is wrong with the code you wrote. Fakes
   help create a more consistent test environment, reduce test flakiness, and facilitate concise
   tests that test a single functionality.

   4. Assert that the data returned by the ``getMarsPhotos()`` method is equal to the
      ``FakeDataSource.photosList``.

   .. code:: prettyprint

      @Test
      fun networkMarsPhotosRepository_getMarsPhotos_verifyPhotoList(){
          val repository = NetworkMarsPhotosRepository(
             marsApiService = FakeMarsApiService()
          )assertEquals(FakeDataSource.photosList, repository.getMarsPhotos())
      }

   Note that in your IDE, the ``getMarsPhotos()`` method call is underlined in red.

   |2bd5f8999e0f3ec2.png|

   If you hover your mouse over the method, you can see a tooltip indicating that "Suspend function
   â€˜getMarsPhotos' should be called only from a coroutine or another suspend function:"

   |d2d3b6d770677ef6.png|

   In ``data/MarsPhotosRepository.kt``, looking at the ``getMarsPhotos()`` implementation in the
   ``NetworkMarsPhotosRepository``, you see that the ``getMarsPhotos()`` function is a suspend
   function.

   .. code:: prettyprint

      class NetworkMarsPhotosRepository(
         private val marsApiService: MarsApiService
      ) : MarsPhotosRepository {
         /** Fetches list of MarsPhoto from marsApi*/
         override suspend fun getMarsPhotos(): List<MarsPhoto> = marsApiService.getPhotos()
      }

   Remember when you called this function from the ``MarsViewModel``, you called this method from a
   coroutine by calling it from a lambda passed to ``viewModelScope.launch()``. You must also call
   suspend functions, like ``getMarsPhotos()``, from a coroutine in a test. However, the approach is
   different. The next section discusses how to solve this problem.


**Test coroutines**


   In this section, you modify the ``networkMarsPhotosRepository_getMarsPhotos_verifyPhotoList()``
   test so that the body of the test method is run from a coroutine.

   1. Modify in the ``NetworkMarsRepositoryTest.kt`` the
      ``networkMarsPhotosRepository_getMarsPhotos_verifyPhotoList()`` function to be an expression.

   .. code:: prettyprint

      @Test
      fun networkMarsPhotosRepository_getMarsPhotos_verifyPhotoList() =

   2. Set the expression equal to the ``runTest()`` function. This method expects a lambda.

   .. code:: prettyprint

      ...
      import kotlinx.coroutines.test.runTest
      ...

      @Test
      fun networkMarsPhotosRepository_getMarsPhotos_verifyPhotoList() =
          runTest {}

   The coroutine test library provides the ``runTest()`` function. The function takes the method
   that you passed in the lambda and runs it from ``TestScope``, which inherits from
   ``CoroutineScope``.

   **Note:** For reference, when you call the repository in the ViewModel you created, you call the
   ``getMarsPhotos()`` using the ``viewModelScope``, which is ultimately a ``CoroutineScope``.

   3. Move the contents of the test function into the lambda function.

   .. code:: prettyprint

      @Test
      fun networkMarsPhotosRepository_getMarsPhotos_verifyPhotoList() =
         runTest {
             val repository = NetworkMarsPhotosRepository(
                 marsApiService = FakeMarsApiService()
             )
             assertEquals(FakeDataSource.photosList, repository.getMarsPhotos())
         }

   Notice that the red line under ``getMarsPhotos()`` is now gone. If you run this test, it passes!


10. Write a ViewModel test
--------------------------

   In this section, you write a test for the ``getMarsPhotos()`` function from the
   ``MarsViewModel``. The ``MarsViewModel`` depends on the ``MarsPhotosRepository``. Therefore, to
   write this test, you need to create a fake ``MarsPhotosRepository``. Additionally, there are some
   extra steps to take into account for coroutines beyond using the ``runTest()`` method.


**Create the fake repository**


   The goal of this step is to create a fake class that inherits from the ``MarsPhotosRepository``
   interface and overrides the ``getMarsPhotos()`` function to return fake data. This approach is
   similar to the one you took with the fake API service, the difference being that this class
   extends the ``MarsPhotosRepository`` interface instead of the ``MarsApiService``.

   1. Create a new class in the ``fake`` directory called ``FakeNetworkMarsPhotosRepository``.
   2. Extend this class with the ``MarsPhotosRepository`` interface.

   .. code:: prettyprint

      class FakeNetworkMarsPhotosRepository : MarsPhotosRepository{
      }

   3. Override the ``getMarsPhotos()`` function.

   .. code:: prettyprint

      class FakeNetworkMarsPhotosRepository : MarsPhotosRepository{
         override suspend fun getMarsPhotos(): List<MarsPhoto> {
         }
      }

   4. Return ``FakeDataSource.photosList`` from the ``getMarsPhotos()`` function.

   .. code:: prettyprint

      class FakeNetworkMarsPhotosRepository : MarsPhotosRepository{
         override suspend fun getMarsPhotos(): List<MarsPhoto> {
             return FakeDataSource.photosList
         }
      }


**Write the ViewModel test**


   1. Create a new class called ``MarsViewModelTest``.
   2. Create a function called ``marsViewModel_getMarsPhotos_verifyMarsUiStateSuccess()`` and
      annotate it with ``@Test``.

   .. code:: prettyprint

      @Test
      fun marsViewModel_getMarsPhotos_verifyMarsUiStateSuccess()

   3. Make this function an expression set to the result of the ``runTest()`` method to ensure that
      the test is run from a coroutine, just like the repository test in the previous section.

   .. code:: prettyprint

      @Test
      fun marsViewModel_getMarsPhotos_verifyMarsUiStateSuccess() =
          runTest{
          }

   4. In the lambda body of ``runTest()``, create an instance of the ``MarsViewModel`` and pass it
      an instance of the fake repository you created.

   .. code:: prettyprint

      @Test
      fun marsViewModel_getMarsPhotos_verifyMarsUiStateSuccess() =
          runTest{
              val marsViewModel = MarsViewModel(
                  marsPhotosRepository = FakeNetworkMarsPhotosRepository()
               )
          }

   5. Assert that the ``marsUiState`` of your ``ViewModel`` instance matches the result of a
      successful call to ``MarsPhotosRepository.getMarsPhotos()``.

   **Note:** You do not need to directly call ``MarsViewlModel.getMarsPhotos()`` to trigger a call
   to ``MarsPhotosRepository.getMarsPhotos()``. ``MarsViewModel.getMarsPhotos()`` is called when the
   ``ViewModel`` is initialized.

   .. code:: prettyprint

      @Test
      fun marsViewModel_getMarsPhotos_verifyMarsUiStateSuccess() =
         runTest {
             val marsViewModel = MarsViewModel(
                 marsPhotosRepository = FakeNetworkMarsPhotosRepository()
             )
             assertEquals(
                 MarsUiState.Success("Success: ${FakeDataSource.photosList.size} Mars " +
                         "photos retrieved"),
                 marsViewModel.marsUiState
             )
         }

   If you try to run this test as is, it will fail. The error looks something like the following
   example:

   .. code:: prettyprint

      Exception in thread "Test worker @coroutine#1" java.lang.IllegalStateException: Module with the Main dispatcher had failed to initialize. For tests Dispatchers.setMain from kotlinx-coroutines-test module can be used

   Recall that the ``MarsViewModel`` calls the repository using ``viewModelScope.launch()``. This
   instruction launches a new coroutine under the default coroutine dispatcher, which is called the
   ``Main`` dispatcher. The ``Main`` dispatcher wraps the Android UI thread. The reason for the
   preceding error is the Android UI thread is not available in a unit test. Unit tests are executed
   on your workstation, not an Android device or Emulator. If code under a local unit test
   references the ``Main`` dispatcher, an exception (like the one above) is thrown when the unit
   tests are run. To overcome this issue, you must explicitly define the default dispatcher when
   running unit tests. Head to the next section to learn how to do so.


Create a test dispatcher


   Since the ``Main`` dispatcher is only available in a UI context, you must replace it with a
   unit-test-friendly dispatcher. The Kotlin Coroutines library provides a coroutine dispatcher for
   this purpose called ``TestDispatcher``. The ``TestDispatcher`` needs to be used instead of the
   ``Main`` dispatcher for any unit test in which a new coroutine is made, as is the case with the
   ``getMarsPhotos()`` function from the view model.

   To replace the ``Main`` dispatcher with a ``TestDispatcher`` in all cases, use the
   ``Dispatchers.setMain()`` function. You can use the ``Dispatchers.resetMain()`` function to reset
   the thread dispatcher back to the ``Main`` dispatcher. To avoid duplicating the code that
   replaces the ``Main`` dispatcher in each test, you can extract it into a JUnit test rule. A
   TestRule provides a way to control the environment under which a test is run. A TestRule may add
   additional checks, it may perform necessary setup or cleanup for tests, or it may observe test
   execution to report it elsewhere. They can be easily shared between test classes.

   Create a dedicated class to write the TestRule to replace the ``Main`` dispatcher. To implement a
   custom TestRule, complete the following steps:

   1. Create a new package in the test directory called ``rules``.
   2. In the rules directory, create a new class called ``TestDispatcherRule``.
   3. Extend the ``TestDispatcherRule`` with ``TestWatcher``. The ``TestWatcher`` class enables you
      to take actions on different execution phases of a test.

   .. code:: prettyprint

      class TestDispatcherRule(): TestWatcher(){

      }

   4. Create a ``TestDispatcher`` constructor parameter for the ``TestDispatcherRule``.

   This parameter enables the use of different dispatchers, such as ``StandardTestDispatcher``. This
   constructor parameter needs to have a default value set to an instance of the
   ``UnconfinedTestDispatcher`` object. The `UnconfinedTestDispatcher <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-unconfined-test-dispatcher.html>`__
   class inherits from the ``TestDispatcher`` class and it specifies that tasks must not be executed
   in any particular order. This pattern of execution is good for simple tests as coroutines are
   handled automatically. Unlike ``UnconfinedTestDispatcher``, the ``StandardTestDispatcher`` class
   enables full control over coroutine execution. This way is preferable for complicated tests that
   require a manual approach, but it is not necessary for the tests in this codelab.

   .. code:: prettyprint

      class TestDispatcherRule(
          val testDispatcher: TestDispatcher = UnconfinedTestDispatcher(),
      ) : TestWatcher() {

      }

   5. The primary goal of this test rule is to replace the ``Main`` dispatcher with a test
      dispatcher before a test begins to execute. The ``starting()`` function of the ``TestWatcher``
      class executes before a given test executes. Override the ``starting()`` function.

   .. code:: prettyprint

      class TestDispatcherRule(
          val testDispatcher: TestDispatcher = UnconfinedTestDispatcher(),
      ) : TestWatcher() {
          override fun starting(description: Description) {
              
          }
      }

   6. Add a call to ``Dispatchers.setMain()``, passing in ``testDispatcher`` as an argument.

   .. code:: prettyprint

      class TestDispatcherRule(
          val testDispatcher: TestDispatcher = UnconfinedTestDispatcher(),
      ) : TestWatcher() {
          override fun starting(description: Description) {
              Dispatchers.setMain(testDispatcher)
          }
      }

   7. After test execution is finished, reset the ``Main`` dispatcher by overriding the
      ``finished()`` method. Call the ``Dispatchers.resetMain()`` function.

   .. code:: prettyprint

      class TestDispatcherRule(
          val testDispatcher: TestDispatcher = UnconfinedTestDispatcher(),
      ) : TestWatcher() {
          override fun starting(description: Description) {
              Dispatchers.setMain(testDispatcher)
          }

          override fun finished(description: Description) {
              Dispatchers.resetMain()
          }
      }

   The ``TestDispatcherRule`` rule is ready for reuse.

   8. Open the ``MarsViewModelTest.kt`` file.
   9. In the ``MarsViewModelTest`` class, instantiate the ``TestDispatcherRule`` class and assign it
      to a ``testDispatcher`` read-only property.

   .. code:: prettyprint

      class MarsViewModelTest {
          
          val testDispatcher = TestDispatcherRule()
          ...
      }

   10. To apply this rule to your tests, add the ``@get:Rule`` annotation to the ``testDispatcher``
       property.

   .. code:: prettyprint

      class MarsViewModelTest {
          @get:Rule
          val testDispatcher = TestDispatcherRule()
          ...
      }

   11. Re-run the test. Confirm that it passes this time.


11. Get the solution code
-------------------------

   To download the code for the finished codelab, you can use these commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos.git
      $ cd basic-android-kotlin-compose-training-mars-photos
      $ git checkout coil-starter

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos/archive/refs/heads/coil-starter.zip>`__

   **Note:** The solution code is in the ``coil-starter`` branch of the downloaded repository.

   If you want to see the solution code for this codelab, view it on
   `GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-mars-photos/tree/coil-starter>`__.


12. Conclusion
--------------

   Congratulations on completing this codelab and refactoring the **Mars Photos** app to implement
   the repository pattern and dependency injection!

   The app's code is now following Android best practices for the data layer, which means it is more
   flexible, robust, and easily scalable.

   These changes also helped make the app more easily testable. This benefit is very important, as
   the code can continue to evolve while making sure it still behaves as expected.

   Don't forget to share your work on social media with *#AndroidBasics*!


13. Learn more
--------------

   Android developer documentation:

   -  `Dependency injection in Android <https://developer.android.google.cn/training/dependency-injection>`__
   -  `Guide to app architecture - Data layer <https://developer.android.google.cn/topic/architecture/data-layer>`__

   Other:

   -  `Coupling <https://en.wikipedia.org/wiki/Coupling_(computer_programming)>`__


.. |dbf927072d3070f0.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/dbf927072d3070f0.png
.. |ff7a7cd039402747.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/ff7a7cd039402747.png
.. |Android studio screenshot showing MarsPhotosRepository interface and class NetworkMarsPhotosRepository| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/9859856f31d7ec3c.png
.. |5313985852c151aa.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/5313985852c151aa.png
.. |flow diagram to show how the data layer is accessed directly from Viewmodel before. Now we have Mars photos repository| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/283b298f85030fc4.png
.. |1ea410d6670b7670.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/1ea410d6670b7670.png
.. |7ed26c6dcf607a55.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/7ed26c6dcf607a55.png
.. |92e7d7b79c4134f0.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/92e7d7b79c4134f0.png
.. |759144e4e0634ed8.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/759144e4e0634ed8.png
.. |7425864315cb5e6f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/7425864315cb5e6f.png
.. |2bd5f8999e0f3ec2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/2bd5f8999e0f3ec2.png
.. |d2d3b6d770677ef6.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-add-repository/img/d2d3b6d770677ef6.png


â­ Load and display images from the internet
=============================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-load-images


1. Before you begin
-------------------


**Introduction**

   In previous codelabs, you learned how to get data from a web service using a repository pattern
   and parse the response into a Kotlin object. In this codelab, you build on that knowledge to load
   and display photos from a web URL. You also revisit how to build a ``LazyVerticalGrid`` and use
   it to display a grid of images on the overview page.


Prerequisites

   -  Knowledge of how to retrieve JSON from a REST web service and the parsing of that data into
      Kotlin objects using the `Retrofit <https://square.github.io/retrofit/>`__ and
      `Gson <https://github.com/google/gson>`__ libraries
   -  Knowledge of a `REST <https://en.wikipedia.org/wiki/Representational_state_transfer>`__ web
      service
   -  Familiarity with Android architecture components, such as a `data
      laye <https://developer.android.google.cn/topic/architecture/data-layer>`__\ r and repository
   -  Knowledge of `dependency
      injection <https://developer.android.google.cn/training/dependency-injection>`__
   -  Knowledge of ``ViewModel`` and ``ViewModelProvider.Factory``
   -  Knowledge of coroutine implementation for your app
   -  Knowledge of the repository pattern


What you'll learn

   -  How to use the `Coil <https://coil-kt.github.io/coil/>`__ library to load and display an image
      from a web URL.
   -  How to use a ``LazyVerticalGrid`` to display a grid of images.
   -  How to handle potential errors as the images download and display.


What you'll build

   -  Modify the Mars Photos app to get the image URL from the Mars data, and use Coil to load and
      display that image.
   -  Add a loading animation and error icon to the app.
   -  Add status and error handling to the app.


What you'll need

   -  A computer with a modern web browser, such as the latest version of
      `Chrome <https://www.google.com/chrome/>`__
   -  Starter code for the **Mars Photos** app with REST web services


2. App overview
---------------


   In this codelab, you continue working with the **Mars Photos** app from a previous codelab. The
   **Mars Photos** app connects to a web service to retrieve and display the number of Kotlin
   objects retrieved using Gson. These Kotlin objects contain the URLs of real-life photos from the
   Mars surface captured from NASA's Mars Rovers.

   |a59e55909b6e9213.png|

   The version of the app you build in this codelab displays Mars photos in a grid of images. The
   images are part of the data that your app retrieves from the web service. Your app uses the
   `Coil <https://coil-kt.github.io/coil/>`__ library to load and display the images and a
   ``LazyVerticalGrid`` to create the grid layout for the images. Your app will also handle network
   errors gracefully by displaying an error message.

   |68f4ff12cc1e2d81.png|


Get the starter code

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos/archive/refs/heads/coil-starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos.git
      $ cd basic-android-kotlin-compose-training-mars-photos
      $ git checkout coil-starter

   **Note:** The starter code is in the ``coil-starter`` branch of the downloaded repository.

   You can browse the code in the `Mars Photos <https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos/tree/coil-starter>`__
   GitHub repository.


3. Display a downloaded image
-----------------------------


   Displaying a photo from a web URL might sound straightforward, but there is quite a bit of
   engineering to make it work well. The image has to be downloaded, internally stored(cached), and
   decoded from its compressed format to an image that Android can use. You can cache the image to
   an in-memory cache, a storage-based cache, or both. All this has to happen in low-priority
   background threads so the UI remains responsive. Also, for the best network and CPU performance,
   you might want to fetch and decode more than one image at once.

   Fortunately, you can use a community-developed library called `Coil <https://coil-kt.github.io/coil/>`__ 
   to download, buffer, decode, and cache your images.
   Without the use of Coil, you would have much more work to do.

   Coil basically needs two things:

   -  The URL of the image you want to load and display.
   -  An ``AsyncImage`` composable to actually display that image.

   In this task, you learn how to use Coil to display a single image from the Mars web service. You
   display the image of the first Mars photo in the list of photos that the web service returns. The
   following images display the before and after screenshots:

   ====================== ======================
   |a59e55909b6e9213.png| |1b670f284109bbf5.png|
   ====================== ======================


**Add Coil dependency**

   1. Open the `Mars Photos solution <https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos/tree/coil-starter>`__
      app from the `Add repository and Manual DI <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-repository>`__
      codelab.
   2. Run the app to confirm that it shows the count of Mars photos retrieved.
   3. Open **build.gradle.kts (Module :app)**.
   4. In the ``dependencies`` section, add this line for the Coil library:

   .. code:: prettyprint

      // Coil
      implementation("io.coil-kt:coil-compose:2.4.0")

   Check and update the latest version of the library from the `Coil <https://coil-kt.github.io/coil/#download>`__ 
   documentation page.

   5. Click **Sync Now** to rebuild the project with the new dependency.


Display the Image URL

   In this step, you retrieve and display the URL of the first Mars photo.

   1. In ``ui/screens/MarsViewModel.kt``, inside the ``getMarsPhotos()`` method, inside the ``try``
      block, find the line that sets the data retrieved from the web service to ``listResult``.

   .. code:: prettyprint

      // No need to copy, code is already present
      try {
         val listResult = marsPhotosRepository.getMarsPhotos()
         //...
      }

   2. Update this line by changing ``listResult`` to ``result`` and assigning the first Mars photo
      retrieved to the new variable ``result``. Assign the first photo object at index ``0``.

   .. code:: prettyprint

      try {
         val result = marsPhotosRepository.getMarsPhotos()[0]
         //...
      }

   3. In the next line, update the parameter passed to the ``MarsUiState.Success()`` function call
      to the string in the following code. Use the data from the new property instead of
      ``listResult``. Display the first image URL from the photo ``result``.

   .. code:: prettyprint

      try {
         ...
         MarsUiState.Success("First Mars image URL: ${result.imgSrc}")
      }

   The complete ``try`` block now looks like the following code:

   .. code:: prettyprint

      marsUiState = try {
         val result = marsPhotosRepository.getMarsPhotos()[0]
         MarsUiState.Success(
             "   First Mars image URL : ${result.imgSrc}"
         )
      }

   4. Run the app. The ``Text`` composable now displays the URL of the first Mars photo. The next
      section describes how to make the app display the image in this URL.

   |b5daaa892fe8dad7.png|


Add ``AsyncImage`` **composable**

   In this step, you'll add an ``AsyncImage`` composable function to load and display a single Mars
   photo. ``AsyncImage`` is a composable that executes an image request asynchronously and renders
   the result.

   .. code:: prettyprint

      // Example code, no need to copy over
      AsyncImage(
          model = "https://android.com/sample_image.jpg",
          contentDescription = null
      )

   The ``model`` argument can either be the ``ImageRequest.data`` value or the ``ImageRequest``
   itself. In the preceding example, you assign the ``ImageRequest.data`` valueâ€”that is, the image
   URL, which is ``"https://android.com/sample_image.jpg"``. The following example code shows how to
   assign the ``ImageRequest`` itself to the ``model``.

   .. code:: prettyprint

      // Example code, no need to copy over

      AsyncImage(
          model = ImageRequest.Builder(LocalContext.current)
              .data("https://example.com/image.jpg")
              .crossfade(true)
              .build(),
          placeholder = painterResource(R.drawable.placeholder),
          contentDescription = stringResource(R.string.description),
          contentScale = ContentScale.Crop,
          modifier = Modifier.clip(CircleShape)
      )

   ``AsyncImage`` supports the same arguments as the standard Image composable. Additionally, it
   supports setting ``placeholder`` / ``error`` / ``fallback`` painters and
   ``onLoading`` / ``onSuccess`` / ``onError`` callbacks. The preceding example code loads the image
   with a circle crop and crossfade and sets a placeholder.

   ``contentDescription`` sets the text used by accessibility services to describe what this image
   represents.

   Add an ``AsyncImage`` composable to your code to display the first Mars photo retrieved.

   1. In ``ui/screens/HomeScreen.kt``, add a new composable function called ``MarsPhotoCard()``,
      which takes ``MarsPhoto`` and ``Modifier``.

   .. code:: prettyprint

      @Composable
      fun MarsPhotoCard(photo: MarsPhoto, modifier: Modifier = Modifier) {
      }

   2. Inside the ``MarsPhotoCard()`` composable function, add the ``AsyncImage()`` function as
      follows:

   .. code:: prettyprint

      import coil.compose.AsyncImage
      import coil.request.ImageRequest
      import androidx.compose.ui.platform.LocalContext


      @Composable
      fun MarsPhotoCard(photo: MarsPhoto, modifier: Modifier = Modifier) {
          AsyncImage(
              model = ImageRequest.Builder(context = LocalContext.current)
                  .data(photo.imgSrc)
                  .build(),
              contentDescription = stringResource(R.string.mars_photo),
              modifier = Modifier.fillMaxWidth()
          )
      }

   In the preceding code, you build an ``ImageRequest`` using the image URL (``photo.imgSrc``) and
   pass it to the ``model`` argument. You use ``contentDescription`` to set the text for
   accessibility readers.

   3. Add ``crossfade(true)`` to the ``ImageRequest`` to enable a crossfade animation when the
      request completes successfully.

   .. code:: prettyprint

      @Composable
      fun MarsPhotoCard(photo: MarsPhoto, modifier: Modifier = Modifier) {
          AsyncImage(
              model = ImageRequest.Builder(context = LocalContext.current)
                  .data(photo.imgSrc)
                  .crossfade(true)
                  .build(),
              contentDescription = stringResource(R.string.mars_photo),
              modifier = Modifier.fillMaxWidth()
          )
      }

   4. Update the ``HomeScreen`` composable to display the ``MarsPhotoCard`` composable instead of
      the ``ResultScreen`` composable when the request successfully completes. You fix the type
      mismatch error in the next step.

   .. code:: prettyprint

      @Composable
      fun HomeScreen(
          marsUiState: MarsUiState,
          modifier: Modifier = Modifier
      ) {
          when (marsUiState) {
              is MarsUiState.Loading -> LoadingScreen(modifier = modifier.fillMaxSize()) 
              is MarsUiState.Success -> MarsPhotoCard(photo = marsUiState.photos, modifier = modifier.fillMaxSize())
              else -> ErrorScreen(modifier = modifier.fillMaxSize())
          }
      }

   5. In the ``MarsViewModel.kt`` file, update the ``MarsUiState`` interface to accept a
      ``MarsPhoto`` object instead of a ``String``.

   .. code:: prettyprint

      sealed interface MarsUiState {
          data class Success(val photos: MarsPhoto) : MarsUiState
          //...
      }

   6. Update ``getMarsPhotos()`` function to pass the first Mars photo object to
      ``MarsUiState.Success()``. Delete the ``result`` variable.

   .. code:: prettyprint

      marsUiState = try {
          MarsUiState.Success(marsPhotosRepository.getMarsPhotos()[0])
      }

   7. Run the app and confirm that it displays a single Mars image.

   |d4421a2458f38695.png|

   8. The Mars photo is not filling the entire screen. To fill available space on screen, in
      ``HomeScreen.kt`` in ``AsyncImage``, set the ``contentScale`` to ``ContentScale.Crop``.

   .. code:: prettyprint

      import androidx.compose.ui.layout.ContentScale

      @Composable
      fun MarsPhotoCard(photo: MarsPhoto, modifier: Modifier = Modifier) {
         AsyncImage(
             model = ImageRequest.Builder(context = LocalContext.current)
                 .data(photo.imgSrc)
                 .crossfade(true)
                 .build(),
             contentDescription = stringResource(R.string.mars_photo),
             contentScale = ContentScale.Crop,
             modifier = modifier,
         )
      }

   9. Run the app and confirm that the image fills the screen both horizontally and vertically.

   |1b670f284109bbf5.png|


Add loading and error images

   You can improve the user experience in your app by showing a placeholder image while loading the
   image. You can also display an error image if the loading fails due to an issue, such as a
   missing or corrupt image file. In this section, you add both error and placeholder images using
   ``AsyncImage``.

   1. Open ``res/drawable/ic_broken_image.xml`` and click the **Design** or **Split** tab on the
      right. For the error image, use the broken-image icon that's available in the built-in icon
      library. This vector drawable uses the ``android:tint`` attribute to color the icon gray.

   |70e008c63a2a1139.png|

   2. Open ``res/drawable/loading_img.xml``. This drawable is an animation that rotates an image
      drawable, ``loading_img.xml``, around the center point. (You don't see the animation in the
      preview.)

   |92a448fa23b6d1df.png|

   3. Return to the ``HomeScreen.kt`` file. In the ``MarsPhotoCard`` composable, update the call to
      ``AsyncImage()`` to add ``error`` and ``placeholder`` attributes as shown in the following
      code:

   .. code:: prettyprint

      import androidx.compose.ui.res.painterResource

      @Composable
      fun MarsPhotoCard(photo: MarsPhoto, modifier: Modifier = Modifier) {
          AsyncImage(
              // ...
              error = painterResource(R.drawable.ic_broken_image),
              placeholder = painterResource(R.drawable.loading_img),
              // ...
          )
      }

   This code sets the placeholder loading image to use while loading (the ``loading_img`` drawable).
   It also sets the image to use if image loading fails (the ``ic_broken_image`` drawable).

   The complete ``MarsPhotoCard`` composable now looks like the following code:

   .. code:: prettyprint

      @Composable
      fun MarsPhotoCard(photo: MarsPhoto, modifier: Modifier = Modifier) {
          AsyncImage(
              model = ImageRequest.Builder(context = LocalContext.current)
                  .data(photo.imgSrc)
                  .crossfade(true)
                  .build(),
              error = painterResource(R.drawable.ic_broken_image),
              placeholder = painterResource(R.drawable.loading_img),
              contentDescription = stringResource(R.string.mars_photo),
              contentScale = ContentScale.Crop
          )
      }

   4. Run the app. Depending on the speed of your network connection, you might briefly see the
      loading image as Coil downloads and displays the property image. But you won't see the
      broken-image icon yet, even if you turn off your networkâ€”you fix that in the last task of the
      codelab.

   |d684b0e096e57643.gif|


4. Display a grid of images with a LazyVerticalGrid
---------------------------------------------------

   Your app now loads a Mars photo from the internet, the first ``MarsPhoto`` list item. You've used
   the image URL from that Mars photo data to populate an ``AsyncImage``. However, the goal is for
   your app to display a grid of images. In this task, you use a ``LazyVerticalGrid`` with a Grid
   layout manager to display a grid of images.

**Lazy grids**

   The `LazyVerticalGrid <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/grid/package-summary#LazyVerticalGrid(androidx.compose.foundation.lazy.grid.GridCells,androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.grid.LazyGridState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__
   and `LazyHorizontalGrid <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/grid/package-summary#LazyHorizontalGrid(androidx.compose.foundation.lazy.grid.GridCells,androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.grid.LazyGridState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__
   composables provide support to display items in a grid. A lazy vertical grid displays its items
   in a vertically scrollable container, spanned across multiple columns, while a lazy horizontal
   grid has the same behavior on the horizontal axis.


   |27680e208333ed5.png|

   From a design perspective, Grid Layout is best for displaying Mars photos as icons or images.

   The ``columns`` parameter in `LazyVerticalGrid <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/grid/package-summary#LazyVerticalGrid(androidx.compose.foundation.lazy.grid.GridCells,androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.grid.LazyGridState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__
   and ``rows`` parameter in `LazyHorizontalGrid <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/grid/package-summary#LazyHorizontalGrid(androidx.compose.foundation.lazy.grid.GridCells,androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.grid.LazyGridState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__
   control how cells are formed into columns or rows. The following example code displays items in a
   grid, using `GridCells.Adaptive <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/grid/GridCells.Adaptive>`__
   to set each column to be at least ``128.dp`` wide:

   .. code:: prettyprint

      // Sample code - No need to copy over

      @Composable
      fun PhotoGrid(photos: List<Photo>) {
          LazyVerticalGrid(
              columns = GridCells.Adaptive(minSize = 150.dp)
          ) {
              items(photos) { photo ->
                  PhotoItem(photo)
              }
          }
      }

   ``LazyVerticalGrid`` lets you specify a width for items, and the grid then fits as many columns
   as possible. After calculating the number of columns, the grid distributes any remaining width
   equally among the columns. This adaptive way of sizing is especially useful for displaying sets
   of items across different screen sizes.

   **Note**: If you know the exact amount of columns to be used, you can instead provide an instance
   of `GridCells.Fixed <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/grid/GridCells.Fixed>`__
   containing the number of required columns.

   In this codelab, to display Mars photos, you use the ``LazyVerticalGrid`` composable with
   ``GridCells.Adaptive``, with each column set to ``150.dp`` wide.


**Item keys**

   When the user scrolls through the grid (a ``LazyRow`` within a ``LazyColumn``), the list item
   position changes. However, due to an orientation change or if the items are added or removed, the
   user can lose the scroll position within the row. Item keys help you maintain the scroll position
   based on the key.

   By providing keys, you help Compose handle reorderings correctly. For example, if your item
   contains a remembered state, setting keys allows Compose to move this state together with the
   item when its position changes.


**Add LazyVerticalGrid**

   Add a composable to display a list of Mars photos in a vertical grid.

   1. In the ``HomeScreen.kt`` file, create a new composable function named ``PhotosGridScreen()``,
      which takes a list of ``MarsPhoto`` and a ``modifier`` as arguments.

   .. code:: prettyprint

      @Composable
      fun PhotosGridScreen(
          photos: List<MarsPhoto>,
          modifier: Modifier = Modifier,
          contentPadding: PaddingValues = PaddingValues(0.dp),
      ) {
      }

   2. Inside the ``PhotosGridScreen`` composable, add a ``LazyVerticalGrid`` with the following
      parameters.

   .. code:: prettyprint

      import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
      import androidx.compose.foundation.lazy.grid.GridCells
      import androidx.compose.foundation.layout.fillMaxWidth
      import androidx.compose.foundation.layout.PaddingValues
      import androidx.compose.ui.unit.dp

      @Composable
      fun PhotosGridScreen(
          photos: List<MarsPhoto>,
          modifier: Modifier = Modifier,
          contentPadding: PaddingValues = PaddingValues(0.dp),
      ) {
          LazyVerticalGrid(
              columns = GridCells.Adaptive(150.dp),
              modifier = modifier.padding(horizontal = 4.dp),
              contentPadding = contentPadding,
         ) {
           }
      }

   3. To add a list of items, inside the ``LazyVerticalGrid`` lambda, call the ``items()`` function
      passing in the list of ``MarsPhoto`` and an item key as ``photo.id``.

   .. code:: prettyprint

      import androidx.compose.foundation.lazy.grid.items

      @Composable
      fun PhotosGridScreen(
          photos: List<MarsPhoto>,
          modifier: Modifier = Modifier,
          contentPadding: PaddingValues = PaddingValues(0.dp),
      ) {
         LazyVerticalGrid(
             // ...
         ) {
             items(items = photos, key = { photo -> photo.id }) {
             }
         }
      }

   4. To add the content displayed by a single list item, define the ``items`` lambda expression.
      Call ``MarsPhotoCard``, passing in the ``photo``.

   .. code:: prettyprint

      items(items = photos, key = { photo -> photo.id }) {
         photo -> MarsPhotoCard(photo)
      }

   5. Update the ``HomeScreen`` composable to display the ``PhotosGridScreen`` composable instead of
      the ``MarsPhotoCard`` composable on completing the request successfully.

   .. code:: prettyprint

      when (marsUiState) {
             // ...
             is MarsUiState.Success -> PhotosGridScreen(marsUiState.photos, modifier)
             // ...
      }

   6. In the ``MarsViewModel.kt`` file, update the ``MarsUiState`` interface to accept a list of
      ``MarsPhoto`` objects instead of a single ``MarsPhoto``. The ``PhotosGridScreen`` composable
      accepts a list of ``MarsPhoto`` objects.

   .. code:: prettyprint

      sealed interface MarsUiState {
          data class Success(val photos: List<MarsPhoto>) : MarsUiState
          //...
      }

   7. In the ``MarsViewModel.kt`` file, update the ``getMarsPhotos()`` function to pass a list of
      Mars photo objects to ``MarsUiState.Success()``.

   .. code:: prettyprint

      marsUiState = try {
          MarsUiState.Success(marsPhotosRepository.getMarsPhotos())
      }

   8. Run the app.

   |2eaec198c56b5eed.png|

   Notice there is no padding around each photo, and the aspect ratio is different for different
   photos. You can add a ``Card`` composable to fix these issues.


**Add card composable**

   1. In the ``HomeScreen.kt`` file, in the ``MarsPhotoCard`` composable, add a ``Card`` with
      ``8.dp`` elevation around the ``AsyncImage``. Assign the ``modifier`` argument to the ``Card``
      composable.

   .. code:: prettyprint

      import androidx.compose.material.Card
      import androidx.compose.foundation.layout.aspectRatio
      import androidx.compose.foundation.layout.padding

      @Composable
      fun MarsPhotoCard(photo: MarsPhoto, modifier: Modifier = Modifier) {

          Card(
              modifier = modifier,
              elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)
          ) {

              AsyncImage(
                  model = ImageRequest.Builder(context = LocalContext.current)
                      .data(photo.imgSrc)
                      .crossfade(true)
                      .build(),
                  error = painterResource(R.drawable.ic_broken_image),
                  placeholder = painterResource(R.drawable.loading_img),
                  contentDescription = stringResource(R.string.mars_photo),
                  contentScale = ContentScale.Crop,
                  modifier = Modifier.fillMaxWidth()
              )
          }
      }

   2. To fix the aspect ratio, in ``PhotosGridScreen()`` update the modifier for the
      ``MarsPhotoCard()``.

   .. code:: prettyprint

      @Composable
      fun PhotosGridScreen(photos: List<MarsPhoto>, modifier: Modifier = Modifier) {
         LazyVerticalGrid(
             //...
         ) {
             items(items = photos, key = { photo -> photo.id }) { photo ->
                 MarsPhotoCard(
                     photo,
                     modifier = modifier
                         .padding(4.dp)
                         .fillMaxWidth()
                         .aspectRatio(1.5f)
                 )
             }
         }
      }

   3. Update the result screen preview to preview ``PhotosGridScreen()``. Mock data with empty image
      URLs.

   ::

      @Preview(showBackground = true)
      @Composable
      fun PhotosGridScreenPreview() {
         MarsPhotosTheme {
             val mockData = List(10) { MarsPhoto("$it", "") }
             PhotosGridScreen(mockData)
         }
      }

   **Mock Data:** Some functions might depend on other objects or data. To isolate the behavior of
   these functions, you need to replace the other objects or data with mock or fake objects and data
   to simulate the real object's behavior.

   Mocking is the process of creating objects that mimic the behavior of real objects.

   Mocking is primarily used in unit testing.

   Since the mock data has empty URLs, you see loading images in the photo grid preview.

   |Preview of the photo grid screen preview with loading image|

   4. Run the app.

   |b56acd074ce0f9c7.png|

   5. While the app is running, turn on Airplane Mode.
   6. Scroll the images in the emulator. Images that have not yet loaded appear as broken-image
      icons. This is the image drawable that you passed to the Coil image library to display in case
      any network error or image cannot be fetched.

   |9b72c1d4206c7331.png|

   Good job! You simulated the network connection error by turning on Airplane Mode in your emulator
   or device.


5. Add retry action
-------------------


   In this section you will add a retry action button and retrieve the photos when the button is
   clicked.

   |60cdcd42bc540162.png|

   1. Add a button to the error screen. In the ``HomeScreen.kt`` file, update the ``ErrorScreen()``
      composable to include a ``retryAction`` lambda parameter and a button.

   .. code:: prettyprint

      @Composable
      fun ErrorScreen(retryAction: () -> Unit, modifier: Modifier = Modifier) {
          Column(
              // ...
          ) {
              Image(
                  // ...
              )
              Text(//...)
              Button(onClick = retryAction) {
                  Text(stringResource(R.string.retry))
              }
          }
      }

   **Note:** Make sure ErrorScreenPreview() matches the following code snippet:

   |2a7ea9a88f997e7e.png|

   Check the preview

   |55cf0c45f5be219f.png|

   2. Update the ``HomeScreen()`` composable to pass in retry lambda.

   .. code:: prettyprint

      @Composable
      fun HomeScreen(
         marsUiState: MarsUiState, retryAction: () -> Unit, modifier: Modifier = Modifier
      ) {
         when (marsUiState) {
             //...

             is MarsUiState.Error -> ErrorScreen(retryAction, modifier = modifier.fillMaxSize())
         }
      }

   3. In the ``ui/theme/MarsPhotosApp.kt`` file, update the ``HomeScreen()`` function call to set
      the ``retryAction`` lambda parameter to ``marsViewModel::getMarsPhotos``. This will retrieve
      the mars photos from the server.

   .. code:: prettyprint

      HomeScreen(
         marsUiState = marsViewModel.marsUiState,
         retryAction = marsViewModel::getMarsPhotos
      )


6. Update the ViewModel test
----------------------------


   The ``MarsUiState`` and the ``MarsViewModel`` now accommodate a list of photos instead of a
   single photo. In its current state, the ``MarsViewModelTest`` expects the ``MarsUiState.Success``
   data class to contain a string property. Therefore, the test does not compile. You need to update
   the ``marsViewModel_getMarsPhotos_verifyMarsUiStateSuccess()`` test to assert that the
   ``MarsViewModel.marsUiState`` is equal to the ``Success`` state that contains the list of photos.

   1. Open the ``rules/MarsViewModelTest.kt`` file.
   2. In the ``marsViewModel_getMarsPhotos_verifyMarsUiStateSuccess()``\ test, modify the
      ``assertEquals()`` function call to compare a ``Success`` state (passing the fake photos list
      to the photos parameter) to the ``marsViewModel.marsUiState``.

   .. code:: prettyprint

      @Test
          fun marsViewModel_getMarsPhotos_verifyMarsUiStateSuccess() =
              runTest {
                  val marsViewModel = MarsViewModel(
                      marsPhotosRepository = FakeNetworkMarsPhotosRepository()
                  )
                  assertEquals(
                      MarsUiState.Success(FakeDataSource.photosList),
                      marsViewModel.marsUiState
                  )
              }

   The test now compiles, runs, and passes!


7. Get the solution code
------------------------


   To download the code for the finished codelab, you can use this git command:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos.git

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-mars-photos/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the downloaded repository.

   If you want to see the solution code for this codelab, view it on
   `GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-mars-photos/tree/main>`__.


8. Conclusion
-------------


   Congratulations on completing this codelab and building out the Mars Photos app! It's time to
   show off your app with real life Mars pictures to your family and friends.

   Don't forget to share your work on social media with *#AndroidBasics*!


9. Learn more
-------------


   Android developer documentation:

   -  `Lists and grids \| Jetpack Compose \| Android Developers <https://developer.android.google.cn/jetpack/compose/lists>`__
   -  `Lazy grids \| Jetpack Compose \| Android Developers <https://developer.android.google.cn/jetpack/compose/lists#lazy-grids>`__
   -  `ViewModel Overview <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__

   Other:

   -  `Coil <https://coil-kt.github.io/coil/>`__

.. |a59e55909b6e9213.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/a59e55909b6e9213.png
.. |68f4ff12cc1e2d81.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/68f4ff12cc1e2d81.png
.. |1b670f284109bbf5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/1b670f284109bbf5.png
.. |b5daaa892fe8dad7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/b5daaa892fe8dad7.png
.. |d4421a2458f38695.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/d4421a2458f38695.png
.. |70e008c63a2a1139.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/70e008c63a2a1139.png
.. |92a448fa23b6d1df.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/92a448fa23b6d1df.png
.. |d684b0e096e57643.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/d684b0e096e57643.gif
.. |27680e208333ed5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/27680e208333ed5.png
.. |2eaec198c56b5eed.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/2eaec198c56b5eed.png
.. |Preview of the photo grid screen preview with loading image| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/e737cfaa0dd37e17.png
.. |b56acd074ce0f9c7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/b56acd074ce0f9c7.png
.. |9b72c1d4206c7331.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/9b72c1d4206c7331.png
.. |60cdcd42bc540162.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/60cdcd42bc540162.png
.. |2a7ea9a88f997e7e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/2a7ea9a88f997e7e.png
.. |55cf0c45f5be219f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-load-images/img/55cf0c45f5be219f.png



ğŸš€ Add a scrollable list
========================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-training-add-scrollable-list

1. Before you begin
--------------------------------------------------------------------------------

   In this codelab, you learn how to make a scrollable list in your app using Jetpack
   Compose.

   You will be working with the **Affirmations** app, which displays a list of affirmations
   paired with beautiful images to bring positivity to your day!

   The data is already there, all you need to do is take that data and display it in the
   UI.


Prerequisites

   -  Familiarity with lists in Kotlin
   -  Experience building layouts with Jetpack Compose
   -  Experience running apps on a device or emulator


What you'll learn

   -  How to create a material design card using Jetpack Compose
   -  How to create a scrollable list using Jetpack Compose


What you'll build

   -  You will take an existing application and add a scrollable list to the UI

   The finished product will look like this:

   |286f5132aa155fa6.png|


What you'll need

   -  A computer with internet access, a web browser, and Android Studio
   -  Access to GitHub


Download the starter code

   In Android Studio, open the ``basic-android-kotlin-compose-training-affirmations``
   folder.

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-affirmations

   **Branch name with starter code:** ``starter``

   The app is expected to display a blank screen when built from the ``starter`` branch code.

   |3beea0789e2eeaba.png|


2. Create a list item data class
--------------------------------------------------------------------------------


Create a data class for an Affirmation

   In Android apps, lists are made up of list items. For single pieces of data, this could
   be something simple like a string or an integer. For list items that have multiple
   pieces of data, like an image and text, you will need a class that contains all of these
   properties. Data classes are a type of class that only contain properties, they can
   provide some utility methods to work with those properties.

   1. Create a new package under **com.example.affirmations**.

   |89c8d8485c685fac.png|

   Name the new package **model.** The model package will contain the data model that will
   be represented by a data class. The data class will be comprised of properties that
   represent the information relevant to what will be an "Affirmation," which will consist
   of a string resource and an image resource. Packages are directories that contain
   classes and even other directories.

   |b54fb6bf57de44c8.png|

   2. Create a new class in the **com.example.affirmations.model** package.

   |58510a651bd49100.png|

   Name the new class **Affirmation** and make it a **Data class**.

   |7f94b65ee3d8407f.png|

   3. Each ``Affirmation`` consists of one image and one string. Create two ``val``
      properties in the ``Affirmation`` data class. One should be called
      ``stringResourceId`` and the other ``imageResourceId``. They should both be integers.

   **``Affirmation.kt``**

   .. code:: prettyprint

      data class Affirmation(
          val stringResourceId: Int,
          val imageResourceId: Int
      )

   4. Annotate the ``stringResourceId`` property with the ``@StringRes`` annotation and
      annotate the ``imageResourceId`` with the ``@DrawableRes`` annotation. The
      ``stringResourceId`` represents an ID for the affirmation text stored in a string
      resource. The ``imageResourceId`` represents an ID for the affirmation image stored
      in a drawable resource.

   **``Affirmation.kt``**

   .. code:: prettyprint

      import androidx.annotation.DrawableRes
      import androidx.annotation.StringRes

      data class Affirmation(
          @StringRes val stringResourceId: Int,
          @DrawableRes val imageResourceId: Int
      )

   5. In the **com.example.affirmations.data** package, open the **Datasource.kt** file and
      uncomment the two import statements and the contents of the ``Datasource`` class.

   **``Datasource.kt``**

   .. code:: prettyprint

      import com.example.affirmations.R
      import com.example.affirmations.model.Affirmation

      class Datasource() {
          fun loadAffirmations(): List<Affirmation> {
              return listOf<Affirmation>(
                  Affirmation(R.string.affirmation1, R.drawable.image1),
                  Affirmation(R.string.affirmation2, R.drawable.image2),
                  Affirmation(R.string.affirmation3, R.drawable.image3),
                  Affirmation(R.string.affirmation4, R.drawable.image4),
                  Affirmation(R.string.affirmation5, R.drawable.image5),
                  Affirmation(R.string.affirmation6, R.drawable.image6),
                  Affirmation(R.string.affirmation7, R.drawable.image7),
                  Affirmation(R.string.affirmation8, R.drawable.image8),
                  Affirmation(R.string.affirmation9, R.drawable.image9),
                  Affirmation(R.string.affirmation10, R.drawable.image10))
          }
      }

   **Note:** The ``loadAffirmations()`` method gathers all of the data provided in the
   starter code and returns it as a list. You will use this later to build the scrollable
   list.


3. Add a list to your app
--------------------------------------------------------------------------------


Create a list item card

   This app is meant to display a list of affirmations. The first step in configuring the
   UI to display a list is to create a list item. Each affirmation item consists of an
   image and a string. The data for each of these items comes with the starter code, and
   you will create the UI component to display such an item.

   The item will be comprised of a ``Card`` composable, containing an ``Image`` and a
   ``Text`` composable. In Compose, a ``Card`` is a surface that displays content and
   actions in a single container. The Affirmation card will look like this in the preview:

   |4f657540712a069f.png|

   The card shows an image with some text beneath it. This vertical layout can be achieved
   using a ``Column`` composable wrapped in a ``Card`` composable. You can give it a try on
   your own, or follow the steps below to achieve this.

   1. Open the **MainActivity.kt** file.
   2. Create a new method beneath the ``AffirmationsApp()`` method, called
      ``AffirmationCard()``, and annotate it with the ``@Composable`` annotation.

   **``MainActivity.kt``**

   .. code:: prettyprint

      @Composable
      fun AffirmationsApp() {
      }

      @Composable
      fun AffirmationCard() {

      }

   3. Edit the method signature to take an ``Affirmation`` object as a parameter. The
      ``Affirmation`` object comes from the ``model`` package.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import com.example.affirmations.model.Affirmation

      @Composable
      fun AffirmationCard(affirmation: Affirmation) {

      }

   4. Add a ``modifier`` parameter to the signature. Set a default value of ``Modifier``
      for the parameter.

   **``MainActivity.kt``**

   .. code:: prettyprint

      @Composable
      fun AffirmationCard(affirmation: Affirmation, modifier: Modifier = Modifier) {

      }

   **Note:** It is a best practice to pass a modifier to every composable and set it to a
   default value.

   5. Inside of the ``AffirmationCard`` method, call the ``Card`` composable. Pass in the
      ``modifier`` parameter.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import androidx.compose.material3.Card

      @Composable
      fun AffirmationCard(affirmation: Affirmation, modifier: Modifier = Modifier) {
          Card(modifier = modifier) {

          }
      }

   6. Add a ``Column`` composable inside of the ``Card`` composable. Items within a
      ``Column`` composable arrange themselves vertically in the UI. This allows you to
      place an image above the associated text. Conversely, a ``Row`` composable arranges
      its contained items horizontally.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Column

      @Composable
      fun AffirmationCard(affirmation: Affirmation, modifier: Modifier = Modifier) {
          Card(modifier = modifier) {
              Column {

              }
          }

      }

   7. Add an ``Image`` composable inside of the lambda body of the ``Column`` composable.
      Recall that an ``Image`` composable always requires a resource to display, and a
      ``contentDescription``. The resource should be a ``painterResource`` passed to the
      ``painter`` parameter. The ``painterResource`` method will load either vector
      drawables or rasterized asset formats like PNGs. Also, pass a ``stringResource`` for
      the ``contentDescription`` parameter.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import androidx.compose.foundation.Image
      import androidx.compose.ui.res.painterResource
      import androidx.compose.ui.res.stringResource

      @Composable
      fun AffirmationCard(affirmation: Affirmation, modifier: Modifier = Modifier) {
          Card(modifier = modifier) {
              Column {
                  Image(
                      painter = painterResource(affirmation.imageResourceId),
                      contentDescription = stringResource(affirmation.stringResourceId),
                  )
              }
          }
      }

   8. In addition to the ``painter`` and ``contentDescription`` parameters, pass a
      ``modifier`` and a ``contentScale``. A ``contentScale`` determines how the image
      should be scaled and displayed. The ``Modifier`` object should have the
      ``fillMaxWidth`` attribute set and a height of ``194.dp``. The ``contentScale``
      should be ``ContentScale.Crop``.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import androidx.compose.foundation.layout.fillMaxWidth
      import androidx.compose.foundation.layout.height
      import androidx.compose.ui.unit.dp
      import androidx.compose.ui.layout.ContentScale

      @Composable
      fun AffirmationCard(affirmation: Affirmation, modifier: Modifier = Modifier) {
          Card(modifier = modifier) {
              Column {
                  Image(
                      painter = painterResource(affirmation.imageResourceId),
                      contentDescription = stringResource(affirmation.stringResourceId),
                      modifier = Modifier
                          .fillMaxWidth()
                          .height(194.dp),
                      contentScale = ContentScale.Crop
                  )
              }
          }
      }

   9. Inside of the ``Column``, create a ``Text`` composable after the ``Image``
      composable. Pass a ``stringResource`` of the ``affirmation.stringResourceId`` to the
      ``text`` parameter, pass a ``Modifier`` object with the ``padding`` attribute set to
      ``16.dp``, and set a text theme by passing ``MaterialTheme.typography.headlineSmall``
      to the ``style`` parameter.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import androidx.compose.material3.Text
      import androidx.compose.foundation.layout.padding
      import androidx.compose.ui.platform.LocalContext

      @Composable
      fun AffirmationCard(affirmation: Affirmation, modifier: Modifier = Modifier) {
          Card(modifier = modifier) {
              Column {
                  Image(
                      painter = painterResource(affirmation.imageResourceId),
                      contentDescription = stringResource(affirmation.stringResourceId),
                      modifier = Modifier
                          .fillMaxWidth()
                          .height(194.dp),
                      contentScale = ContentScale.Crop
                  )
                  Text(
                      text = LocalContext.current.getString(affirmation.stringResourceId),
                      modifier = Modifier.padding(16.dp),
                      style = MaterialTheme.typography.headlineSmall
                  )
              }
          }
      }


Preview the AffirmationCard composable

   The card is the core of the UI for the **Affirmations** app, and you worked hard to
   create it! To check that the card looks correct, you can create a composable that can be
   previewed without launching the entire app.

   1. Create a private method called ``AffirmationCardPreview()``. Annotate the method with
      ``@Preview`` and ``@Composable``.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import androidx.compose.ui.tooling.preview.Preview

      @Preview
      @Composable
      private fun AffirmationCardPreview() {

      }

   2. Inside of the method, call the ``AffirmationCard`` composable, and pass it a new
      ``Affirmation`` object with the ``R.string.affirmation1`` string resource and the
      ``R.drawable.image1`` drawable resource passed into its constructor.

   **``MainActivity.kt``**

   .. code:: prettyprint

      @Preview
      @Composable
      private fun AffirmationCardPreview() {
          AffirmationCard(Affirmation(R.string.affirmation1, R.drawable.image1))
      }

   3. Open the **Split** tab and you will see a preview of the ``AffirmationCard``. If
      necessary, click **Build & Refresh** in the **Design** pane to display the preview.

   |924a4df2c1db236c.png|


Create the list

   The list item component is the building block of the list. Once the list item is
   created, you can leverage it to make the list component itself.

   1. Create a function called ``AffirmationList()``, annotate it with the ``@Composable``
      annotation, and declare a ``List`` of ``Affirmation`` objects as a parameter in the
      method signature.

   **``MainActivity.kt``**

   .. code:: prettyprint

      @Composable
      fun AffirmationList(affirmationList: List<Affirmation>) {
          
      }

   2. Declare a ``modifier`` object as a parameter in the method signature with a default
      value of ``Modifier``.

   **``MainActivity.kt``**

   .. code:: prettyprint

      @Composable
      fun AffirmationList(affirmationList: List<Affirmation>, modifier: Modifier = Modifier) {

      }

   3. In Jetpack Compose, a scrollable list can be made using the ``LazyColumn``
      composable. The difference between a ``LazyColumn`` and a ``Column`` is that a
      ``Column`` should be used when you have a small number of items to display, as
      Compose loads them all at once. A ``Column`` can only hold a predefined, or fixed,
      number of composables. A ``LazyColumn`` can add content on demand, which makes it
      good for long lists and particularly when the length of the list is unknown. A
      ``LazyColumn`` also provides scrolling by default, without additional code. Declare a
      ``LazyColumn`` composable inside of the ``AffirmationList()`` function. Pass the
      ``modifier`` object as an argument to the ``LazyColumn``.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import androidx.compose.foundation.lazy.LazyColumn

      @Composable
      fun AffirmationList(affirmationList: List<Affirmation>, modifier: Modifier = Modifier) {
          LazyColumn(modifier = modifier) {

          }
      }

   4. In the lambda body of the ``LazyColumn``, call the ``items()`` method, and pass in
      the ``affirmationList``. The ``items()`` method is how you add items to the
      ``LazyColumn``. This method is somewhat unique to this composable, and is otherwise
      not a common practice for most composables.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import androidx.compose.foundation.lazy.items

      @Composable
      fun AffirmationList(affirmationList: List<Affirmation>, modifier: Modifier = Modifier) {
          LazyColumn(modifier = modifier) {
              items(affirmationList) {

              }
          }
      }

   5. A call to the ``items()`` method requires a lambda function. In that function,
      specify a parameter of ``affirmation`` that represents one affirmation item from the
      ``affirmationList``.

   **``MainActivity.kt``**

   .. code:: prettyprint

      @Composable
      fun AffirmationList(affirmationList: List<Affirmation>, modifier: Modifier = Modifier) {
          LazyColumn(modifier = modifier) {
              items(affirmationList) { affirmation ->

              }
          }
      }

   6. For each affirmation in the list, call the ``AffirmationCard()`` composable. Pass it
      the ``affirmation`` and a ``Modifier`` object with the ``padding`` attribute set to
      ``8.dp``.

   **``MainActivity.kt``**

   .. code:: prettyprint

      @Composable
      fun AffirmationList(affirmationList: List<Affirmation>, modifier: Modifier = Modifier) {
          LazyColumn(modifier = modifier) {
              items(affirmationList) { affirmation ->
                  AffirmationCard(
                      affirmation = affirmation,
                      modifier = Modifier.padding(8.dp)
                  )
              }
          }
      }


Display the list

   1. In the ``AffirmationsApp`` composable, retrieve the current layout directions and
      save them in a variable. These will be used to configure the padding later.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import com.example.affirmations.data.Datasource

      @Composable
      fun AffirmationsApp() {
          val layoutDirection = LocalLayoutDirection.current
      }

   2. Now create a ``Surface`` composable. This composable will set the padding for the
      ``AffirmationsList`` composable.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import com.example.affirmations.data.Datasource

      @Composable
      fun AffirmationsApp() {
          val layoutDirection = LocalLayoutDirection.current
          Surface() {
          }
      }

   3. Pass a ``Modifier`` to the ``Surface`` composable that fills the max width and height
      of its parent, sets status bar padding, and sets the start and end padding to the
      ``layoutDirection``. Here's an example of how to translate a ``LayoutDirection``
      object into padding:
      ``WindowInsets.safeDrawing.asPaddingValues().calculateStartPadding(layoutDirection)``.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import com.example.affirmations.data.Datasource

      @Composable
      fun AffirmationsApp() {
          val layoutDirection = LocalLayoutDirection.current
          Surface(
              Modifier = Modifier
              .fillMaxSize()
              .statusBarsPadding()
              .padding(
                  start = WindowInsets.safeDrawing.asPaddingValues()
                          .calculateStartPadding(layoutDirection),
                  end = WindowInsets.safeDrawing.asPaddingValues()
                          .calculateEndPadding(layoutDirection),
              ),
          ) {
          }
      }

   4. In the lambda for the ``Surface`` composable, call the ``AffirmationList``
      composable, and pass ``DataSource().loadAffirmations()`` to the ``affirmationList``
      parameter.

   **Note:** The ``DataSource`` class is found in the ``data`` package.

   **``MainActivity.kt``**

   .. code:: prettyprint

      import com.example.affirmations.data.Datasource

      @Composable
      fun AffirmationsApp() {
          val layoutDirection = LocalLayoutDirection.current
          Surface(
              Modifier = Modifier
              .fillMaxSize()
              .statusBarsPadding()
              .padding(
                  start = WindowInsets.safeDrawing.asPaddingValues()
                          .calculateStartPadding(layoutDirection),
                  end = WindowInsets.safeDrawing.asPaddingValues()
                          .calculateEndPadding(layoutDirection),
              ),
          ) {
              AffirmationsList(
                  affirmationList = Datasource().loadAffirmations(),
              )
          }
      }

   Run the **Affirmations** app on a device or emulator and see the finished product!

   |286f5132aa155fa6.png|


4. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-affirmations.git
      $ cd basic-android-kotlin-compose-training-affirmations
      $ git checkout intermediate

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-affirmations/archive/refs/heads/intermediate.zip>`__

   **Note:** The solution code is in the ``intermediate`` branch of the downloaded
   repository.

   If you want to see the solution code, 
   `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-affirmations/tree/intermediate>`__.


5. Conclusion
--------------------------------------------------------------------------------

   You now know how to create cards, list items, and scrollable lists using Jetpack
   Compose! Keep in mind that these are just basic tools for creating a list. You can let
   your creativity roam and customize list items however you like!


Summary

   -  Use `Card <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Card(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.material3.CardColors,androidx.compose.material3.CardElevation,androidx.compose.foundation.BorderStroke,kotlin.Function1)>`__
      composables to create list items.
   -  Modify the UI contained within a ``Card`` composable.
   -  Create a scrollable list using the
      `LazyColumn <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyColumn(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__
      composable.
   -  Build a list using custom list items.

.. |286f5132aa155fa6.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-add-scrollable-list/img/286f5132aa155fa6.png
.. |3beea0789e2eeaba.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-add-scrollable-list/img/3beea0789e2eeaba.png
.. |89c8d8485c685fac.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-add-scrollable-list/img/89c8d8485c685fac.png
.. |b54fb6bf57de44c8.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-add-scrollable-list/img/b54fb6bf57de44c8.png
.. |58510a651bd49100.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-add-scrollable-list/img/58510a651bd49100.png
.. |7f94b65ee3d8407f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-add-scrollable-list/img/7f94b65ee3d8407f.png
.. |4f657540712a069f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-add-scrollable-list/img/4f657540712a069f.png
.. |924a4df2c1db236c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-add-scrollable-list/img/924a4df2c1db236c.png


ğŸš€ Change the app icon
======================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-training-change-app-icon


1. Before you begin
--------------------------------------------------------------------------------

   An app icon is an important way to differentiate your app by adding a distinct style and
   appearance. The app icon appears in a number of places, including the Home screen, the
   All Apps screen, and the Settings app.

   You may also hear an app icon referred to as a **launcher** icon. Launcher refers to the
   experience when you hit the Home button on an Android device to view and organize your
   apps, add widgets and shortcuts, and more.

   |ec0237fb600dd2a9.png| |e7a9b86b35f7d6c3.png|

   If you've used different Android devices, you may have noticed that the launcher
   experience may look different, depending on the device manufacturer. Sometimes device
   manufacturers create a custom launcher experience that's signature to their brand. For
   example, different manufacturers may display app icons in a different shape than the
   circular icon shape shown above.

   They may display all the app icons in a square shape, rounded square, or squircle
   (between a square and circle), for example.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/16e235142627947.png

      An image of the different app icon shapes

   Regardless of the shape the device manufacturer chooses, the goal is for all the app
   icons on a single device to have a uniform shape for a consistent user experience.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/3c94e41bcbfd9a3c.png

      An image demonstrating the uniform shape of icons.

   That's why the Android platform introduced support for **adaptive icons** (as of API
   level 26). By implementing an adaptive icon for your app, your app is able to
   accommodate a large range of devices by tailoring the launcher icon based on a device's
   display.

   This codelab provides you with image source files for the **Affirmations** app launcher
   icon. You will use a tool in Android Studio, called **Image Asset Studio**, to generate
   different versions of the launcher icons. Afterwards, you can take what you learned and
   apply it to app icons for other apps!

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/7ddbfb08a71c2742.png

      And image of the Affirmations App launcher icon.


Prerequisites

   -  Able to navigate the files of a basic Android project, including the resource files.
   -  Able to install an Android app from Android Studio on the emulator or physical
      device.


What you'll learn

   -  How to change the launcher icon of an app.
   -  How to use Image Asset Studio in Android Studio to generate launcher icon assets.
   -  What an adaptive icon is and why it's two layers.


What you'll make

   -  A custom launcher icon for the **Affirmations** app.


What you need

   -  A computer with the latest stable version of Android Studio installed.
   -  An internet connection to download the image resource files.
   -  Access to GitHub


Download the starter code

   In Android Studio, open the ``basic-android-kotlin-compose-training-affirmations``
   folder.

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-affirmations

   **Branch name with starter code:** ``intermediate``

   1. Navigate to the provided GitHub repository page for the project.
   2. Verify that the branch name matches the branch name specified in the codelab. For
      example, in the following screenshot the branch name is **main**.

   |1e4c0d2c081a8fd2.png|

   3. On the GitHub page for the project, click the **Code** button, which brings up a
      popup.

   |1debcf330fd04c7b.png|

   4. In the popup, click the **Download ZIP** button to save the project to your computer.
      Wait for the download to complete.
   5. Locate the file on your computer (likely in the **Downloads** folder).
   6. Double-click the ZIP file to unpack it. This creates a new folder that contains the
      project files.


Open the project in Android Studio

   1. Start Android Studio.
   2. In the **Welcome to Android Studio** window, click **Open**.

   |d8e9dbdeafe9038a.png|

   Note: If Android Studio is already open, instead, select the **File** > **Open** menu
   option.

   |8d1fda7396afe8e5.png|

   3. In the file browser, navigate to where the unzipped project folder is located (likely
      in your **Downloads** folder).
   4. Double-click on that project folder.
   5. Wait for Android Studio to open the project.
   6. Click the **Run** button |8de56cba7583251f.png| to build and run the app. Make sure
      it builds as expected.


2. Launcher Icons
--------------------------------------------------------------------------------

   The goal is for your launcher icon to look crisp and clear, regardless of the device
   model or screen density. Screen density refers to how many pixels per inch or dots per
   inch (dpi) are on the screen. For a medium-density device (mdpi), there are 160 dots per
   inch on the screen, while an extra-extra-extra-high-density device (xxxhdpi) has 640
   dots per inch on the screen.

   To account for devices across a range of screen densities, you'll need to provide
   different versions of your app icon.


Explore launcher icon files

   1. To see what the launcher icons look like within a project, open the project in
      Android Studio.
   2. In the **Project window**, switch to the **Project** view. This shows you the file
      structure of your project.

   |eef1b274888f2a1c.png|

   3. Navigate to the resources directory (**app > src > main > res**) and expand some of
      the ``mipmap`` folders. These ``mipmap`` folders are where you will put the launcher
      icon assets for your Android app.

   |b725c14ee21fce54.png|

   The drawable folders contain the vectors for the launcher icon in XML files. A vector,
   in the case of a drawable icon, is a series of instructions that draw an image when it
   is compiled. ``mdpi``, ``hdpi``, ``xhdpi``, etc., are density qualifiers that you can
   append onto the name of a resource directory, like ``mipmap,`` to indicate that they are
   resources for devices of a certain screen density. Below is a list of 
   `density qualifiers <https://developer.android.google.cn/training/multiscreen/screendensities#TaskProvideAltBmp>`__
   on Android:

   =========== ================================================================
   ``mdpi``    - (~160 dpi) resources for medium-density screens 
   ``hdpi``    - (~240 dpi) resources for high-density screens 
   ``xhdpi``   - (~320 dpi) resources for extra-high-density screens 
   ``xxhdpi``  - (~480 dpi) resources for extra-extra-high-density screens 
   ``xxxhdpi`` - (~640 dpi) resources for extra-extra-extra-high-density screens 
   ``nodpi``   - resources that are not meant to be scaled, regardless of the screen's pixel density
   ``anydpi``  - resources that scale to any density
   =========== ================================================================

   **Note:** You may wonder why launcher icon assets are located in ``mipmap`` directories,
   separate from other app assets located in ``drawable`` directories. This is because some
   launchers may display your app icon at a larger size than what's provided by the
   device's default density bucket. For example, on an ``hdpi`` device, a certain device
   launcher may use the ``xhdpi`` version of the app icon instead. These directories hold
   the icons that account for devices that require icons with a density that is higher or
   lower than the default density.

   4. If you click on the image files, you'll see a preview. The ``ic_launcher.webp`` files
      contain the square version of the icon, while the ``ic_launcher_round.webp`` files
      contain the circular version of the icon. Both are provided in each mipmap directory.

   For example, this is what **res > mipmap-xxxhdpi > ic_launcher_round.webp** looks like.
   Notice the size of the asset is in the top right. This image is 192px x 192px in size.

   |1da42b08b39e8560.png|

   This is what **res > mipmap-mdpi > ic_launcher_round.webp** looks like. It's only 48px x
   48px in size.

   |5a5eaf5d0c2f67de.png|

   As you can see, these bitmap image files are composed of a fixed grid of pixels. They
   were created for a certain screen resolution. Hence, the quality can degrade as you
   resize them.

   **Note**: To avoid a blurry app icon, be sure to provide different bitmap images of the
   icon for each density bucket (``mdpi``, ``hdpi``, ``xhdpi``, etc.). Note that device
   screen densities won't be precisely 160 dpi, 240 dpi, 320 dpi, etc. Based on the
   device's screen density, Android selects the resource at the closest larger density
   bucket and then scales it down.

   Now that you have some background on launcher icons, you'll learn about adaptive icons.


3. Adaptive Icons
--------------------------------------------------------------------------------


Foreground and Background Layers

   As of the `Android 8.0 release (API level 26) <https://developer.android.google.cn/about/versions/oreo>`__,
   there is support for adaptive icons, which allows for more flexibility and interesting
   visual effects. For developers, that means that your app icon is made up of two layers:
   a foreground layer and a background layer.

   |1af36983e3677abe.gif|

   In the above example, the white Android icon is in the foreground layer, while the blue
   and white grid is in the background layer. The foreground layer is stacked on top of the
   background layer. A mask, circular mask in this case, is then applied on top to produce
   a circular shaped app icon.


Explore adaptive icon files

   Look at the default adaptive icon files already provided in your **Affirmations** app
   code.

   1. In the **Project window** of Android Studio, find and expand the **res >
      mipmap-anydpi-v26** resource directory.

   |29758558d7509497.png|

   **Note**: Adaptive icons were added in API level 26 of the platform, so they should be
   declared in the ``mipmap`` resource directory that has the ``-v26`` resource qualifier
   on it. That means the resources in this directory will only be applied on devices that
   are running API 26 (Android 8.0) or higher. The resource files in this directory are
   ignored on devices running version 25 or older in favor of the density bucketed mipmap
   directories.

   2. Open the ``ic_launcher.xml`` file. You will see this:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
          <background android:drawable="@drawable/ic_launcher_background"/>
          <foreground android:drawable="@drawable/ic_launcher_foreground"/>
          <monochrome android:drawable="@drawable/ic_launcher_foreground"/>
      </adaptive-icon>

   3. Notice how the ``<adaptive-icon>`` element is used to declare the ``<background>``
      and ``<foreground>`` layers of the app icon by providing resource drawables for each.
   4. Go back to the **Project** view and locate the background and foreground drawables:
      **res > drawable > ic_launcher_background.xml** and **res > drawable >
      ic_launcher_foreground.xml**.
   5. Switch to **Design** view to see a preview of each:

   ==================================  ==================================
   Background: |b24d4a67be43b6d9.png|  Foreground: |c05923559b5541f1.png|
   ==================================  ==================================

   6. These are both vector drawable files. They don't have a fixed size in pixels. If you
      switch to **Code** view, you can see the XML declaration for the vector drawable
      using the ``<vector>`` element.

   **``ic_launcher_foreground.xml``**

   .. code:: prettyprint

      <!--
          Copyright (C) 2023 The Android Open Source Project

          Licensed under the Apache License, Version 2.0 (the "License");
          you may not use this file except in compliance with the License.
          You may obtain a copy of the License at

               https://www.apache.org/licenses/LICENSE-2.0

          Unless required by applicable law or agreed to in writing, software
          distributed under the License is distributed on an "AS IS" BASIS,
          WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
          See the License for the specific language governing permissions and
          limitations under the License.
      -->

      <vector xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:aapt="http://schemas.android.com/aapt"
          android:width="108dp"
          android:height="108dp"
          android:viewportWidth="108"
          android:viewportHeight="108">
        <path android:pathData="M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z">
          <aapt:attr name="android:fillColor">
            <gradient
                android:endX="85.84757"
                android:endY="92.4963"
                android:startX="42.9492"
                android:startY="49.59793"
                android:type="linear">
              <item
                  android:color="#44000000"
                  android:offset="0.0" />
              <item
                  android:color="#00000000"
                  android:offset="1.0" />
            </gradient>
          </aapt:attr>
        </path>
        <path
            android:fillColor="#FFFFFF"
            android:fillType="nonZero"
            android:pathData="M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z"
            android:strokeWidth="1"
            android:strokeColor="#00000000" />
      </vector>

   While a vector drawable and a bitmap image both describe a graphic, there are important
   differences.

   A bitmap image doesn't understand much about the image that it holds, except for the
   color information at each pixel. On the other hand, a vector graphic knows how to draw
   the shapes that define an image. These instructions are composed of a set of points,
   lines, and curves along with color information. The advantage is that a vector graphic
   can be scaled for any canvas size, for any screen density, without losing quality.

   A `vector drawable <https://developer.android.google.cn/develop/ui/views/graphics/vector-drawable-resources>`__
   is Android's implementation of vector graphics, intended to be flexible on mobile
   devices. You can define them in XML with these `possible elements <https://developer.android.google.cn/reference/kotlin/android/graphics/drawable/VectorDrawable>`__.
   Instead of providing versions of a bitmap asset for all density buckets, you only need
   to define the image once. Thus, reducing the size of your app and making it easier to
   maintain.

   **Note:** There are `tradeoffs <https://medium.com/androiddevelopers/understanding-androids-vector-image-format-vectordrawable-ab09e41d5c68>`__
   to using a vector drawable versus a bitmap image. For example, icons can be ideal as
   vector drawables because they are made up of simple shapes, while a photograph would be
   harder to describe as a series of shapes. It would be more efficient to use a bitmap
   asset in that case.

   Now it's time to move on to actually changing the app icon!


4. Download new assets
--------------------------------------------------------------------------------

   Download the following two new assets that enable you to create an adaptive icon for the
   **Affirmations** app. You don't need to worry about understanding every detail of the
   vector drawable files. Their contents are auto-generated for you from design tools.

   1. Download `ic_launcher_background.xml <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-affirmations/blob/main/app/src/main/res/drawable/ic_launcher_background.xml>`__,
      which is the vector drawable for the background layer. If your browser shows the file
      instead of downloading it, select **File > Save Page As...** to save it to your
      computer.
   2. Download `ic_launcher_foreground.xml <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-affirmations/blob/main/app/src/main/res/drawable/ic_launcher_foreground.xml>`__,
      which is the vector drawable for the foreground layer.

   Note that there are certain requirements for these foreground and background layer
   assets, such as both must be 108 dpi x 108 dpi in size. You can view more details in the
   `AdaptiveIconDrawable docs <https://developer.android.google.cn/reference/kotlin/android/graphics/drawable/AdaptiveIconDrawable>`__
   and you can also view design guidance on `Android icons <https://m3.material.io/styles/icons/overview>`__
   on the Material Design site.

   Because the edges of your icon could get clipped, depending on the shape of the mask
   from the device manufacturer, it's important to put the key information about your icon
   in the " `safe zone <https://medium.com/google-design/designing-adaptive-icons-515af294c783>`__."
   The safe zone is a circle of diameter 66 dpi in the center of the foreground layer. The
   content outside of the safe zone should not be essential, such as the background color,
   and okay if it gets clipped.


5. Change the app icon
--------------------------------------------------------------------------------

   Go back to Android Studio to use the new assets you just downloaded.

   1. First, delete the old drawable resources that contain the Android icon and green grid
      background. In the **Project view**, right-click on the file and choose **Delete**.

      Delete:

      .. code:: prettyprint

         drawable/ic_launcher_background.xml
         drawable/ic_launcher_foreground.xml

      Delete:

      .. code:: prettyprint

         mipmap-anydpi-v26/
         mipmap-hdpi/
         mipmap-mdpi/
         mipmap-xhdpi/
         mipmap-xxhdpi/
         mipmap-xxxhdpi/

      You can uncheck the box **Safe delete (with usage search)** and click **OK**. The **Safe
      delete (with usage search)** feature searches the code for usages of the resource you
      are about to delete. In this case, you will replace these folders with new ones of the
      same name, so you don't need to worry about **Safe delete**.

   2. Create a new **Image Asset**. You can either right-click on the **res** directory and
      choose **New > Image Asset**, or you can click on the **Resource Manager** tab, click
      the **+** icon, then select **Image Asset** from the dropdown.

      |dbe59156de9fde40.png|

   3. Android Studio's **Image Asset Studio** tool opens.
   4. Leave the default settings:

      -  **Icon Type:** Launcher Icons (Adaptive and Legacy)
      -  **Name:** ic_launcher

      |4729e4abc9542d87.png|

   5. With the **Foreground Layer** tab already selected, go to the **Source Asset**
      subsection. In the **Path** field, click the folder icon.
   6. A prompt pops up to browse your computer and select a file. Find the location of the
      new ``ic_launcher_foreground.xml`` file you just downloaded. It may be in the
      **Downloads** folder of your computer. Once you find it, click **Open**.
   7. The **Path** is now updated with the location of the new foreground vector drawable.
      Leave **Layer Name** as **ic_launcher_foreground** and **Asset Type** as **Image**.

      |2f59e5ac70a8a033.png|

   8.  Next, switch to the **Background Layer** tab of the interface. Leave the default values.
   9.  Click the folder icon in the **Path** field.
   10. Find the location of the ``ic_launcher_background.xml`` file you just downloaded.
       Click **Open**.

      |dc0aee541c8039e7.png|

   11. The preview should update as you select the new resource files. This is what it
       should look like with the new foreground and background layers.

      |a111303e7703fc99.png|

      By representing your app icon in two layers, device manufacturersâ€”called original
      equipment manufacturers or OEMs for shortâ€”can create different shapes, depending on the
      Android device, as shown in the preview above. The OEM provides a mask that gets applied
      to all app icons on the device.

      When a circular mask is applied to both layers of your app icon, the result is a
      circular icon with an Android image and a blue grid background (left image above).
      Alternatively, a rounded square mask could be applied to produce the app icon in the
      above right.

      Having both a foreground and a background layer allows for interesting visual effects
      because the two layers can move independently of one another, and be scaled. For some
      fun examples of how the visual effects can look, view the 
      `Designing Adaptive Icons blogpost <https://medium.com/google-design/designing-adaptive-icons-515af294c783>`__
      under Design Considerations. Because you don't know what device your user will have or
      what mask the OEM will apply to your icon, you need to set up your adaptive icon so
      important information doesn't get clipped.

   12. If important content is clipped or appears too small, then you can use the
       **Resize** slider bar under the **Scaling** section of each layer to make sure
       everything appears in the safe zone. To ensure nothing is clipped, resize the
       foreground and background images to 99% by dragging the **Resize** slider in the
       **Foreground Layer** and **Background Layer** tabs.

      |57fec53a0411f206.png|

   13. Click **Next**.
   14. This step is to **Confirm Icon Path**. You can click the individual files to see the
       preview.

      |4b0a24f0cbd9a2a2.png|

   15. Click **Finish**.
   16. Verify all the generated assets look correct in the ``mipmap`` folders. Examples:

      |339af1a3b9ff550c.png| |31bc221b0e4b8206.png|

   Great work! Now you'll make one more change.


Test your app

   1. Test that your new app icon appears. Run the app on your device (emulator or physical
      device).
   2. Hit the **Home** button on your device.
   3. Swipe up to show the **All Apps** list.
   4. Look for the app you just updated. You should see the new app icon displayed.

   |c943f8c37c450545.png|

   **Note:** Depending on your device model, you may see a launcher icon of a different
   shape. Nevertheless, it should show your foreground layer on top of your background
   layer with some type of mask applied to it.

   Nice job! The new app icon looks great.


Adaptive and legacy launcher icons

   Now that your adaptive icon works well, you may wonder why you can't get rid of all the
   app icon bitmap images. You still need those files so that your app icon appears
   high-quality on older versions of Android, which is referred to as backwards
   compatibility.

   For devices running **Android 8.0 or higher** (API version 26 and above), **Adaptive
   icons** can be used (combination of foreground vector drawable, background vector
   drawable, with an OEM mask applied on top of it). These are the relevant files in your
   project:

   .. code:: prettyprint

      res/drawable/ic_launcher_background.xml
      res/drawable/ic_launcher_foreground.xml
      res/mipmap-anydpi-v26/ic_launcher.xml
      res/mipmap-anydpi-v26/ic_launcher_round.xml

   On devices running anything **below Android 8.0** (but above the minimum required API
   level of your app), **Legacy launcher icons** are used (the bitmap images in the
   ``mipmap`` folders of different density buckets). These are the relevant files in your
   project:

   .. code:: prettyprint

      res/mipmap-mdpi/ic_launcher.webp
      res/mipmap-mdpi/ic_launcher_round.webp
      res/mipmap-hdpi/ic_launcher.webp
      res/mipmap-hdpi/ic_launcher_round.webp
      res/mipmap-xhdpi/ic_launcher.png
      res/mipmap-xhdpi/ic_launcher_round.webp
      res/mipmap-xxhdpi/ic_launcher.webp
      res/mipmap-xxhdpi/ic_launcher_round.webp
      res/mipmap-xxxhdpi/ic_launcher.webp
      res/mipmap-xxxhdpi/ic_launcher_round.webp

   Essentially, Android falls back to the bitmap images on older devices without adaptive
   icon support.

   Congratulations, you completed all the steps for changing an app icon!


6. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-affirmations.git
      $ cd basic-android-kotlin-compose-training-affirmations
      $ git checkout main

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-affirmations/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the downloaded repository.

   If you want to see the solution code, 
   `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-affirmations>`__.

   1. Navigate to the provided GitHub repository page for the project.
   2. Verify that the branch name matches the branch name specified in the codelab. For
      example, in the following screenshot the branch name is **main**.

      |1e4c0d2c081a8fd2.png|

   3. On the GitHub page for the project, click the **Code** button, which brings up a
      popup.

      |1debcf330fd04c7b.png|

   4. In the popup, click the **Download ZIP** button to save the project to your computer.
      Wait for the download to complete.
   5. Locate the file on your computer (likely in the **Downloads** folder).
   6. Double-click the ZIP file to unpack it. This creates a new folder that contains the
      project files.


Open the project in Android Studio

   1. Start Android Studio.
   2. In the **Welcome to Android Studio** window, click **Open**.

      |d8e9dbdeafe9038a.png|

      Note: If Android Studio is already open, instead, select the **File** > **Open** menu
      option.

      |8d1fda7396afe8e5.png|

   3. In the file browser, navigate to where the unzipped project folder is located (likely
      in your **Downloads** folder).
   4. Double-click on that project folder.
   5. Wait for Android Studio to open the project.
   6. Click the **Run** button |8de56cba7583251f.png| to build and run the app. Make sure
      it builds as expected.


7. Summary
--------------------------------------------------------------------------------

   -  Place app icon files in the ``mipmap`` resource directories.
   -  Provide different versions of an app icon bitmap image in each density bucket
      (``mdpi``, ``hdpi``, ``xhdpi``, ``xxhdpi``, ``xxxhdpi``) for backwards compatibility
      with older versions of Android.
   -  Add resource qualifiers onto resource directories to specify resources that should be
      used on devices with a certain configuration (``v24`` or ``v26``).
   -  Vector drawables are Android's implementation of vector graphics. They are defined in
      XML as a set of points, lines, and curves, along with associated color information.
      Vector drawables can be scaled for any density without loss of quality.
   -  Adaptive icons were introduced to the Android platform in API 26. They are made up of
      a foreground and background layer that follow specific requirements, so that your app
      icon looks high-quality on a range of devices with different OEM masks.
   -  Use **Image Asset Studio** in Android Studio to create legacy and adaptive icons for
      your app.


8. Learn more
--------------------------------------------------------------------------------

   -  `Design guidelines on Android icons <https://m3.material.io/styles/icons/designing-icons>`__
   -  `Adaptive Icons <https://developer.android.google.cn/guide/practices/ui_guidelines/icon_design_adaptive>`__
   -  `Understanding Android Adaptive Icons <https://medium.com/google-design/understanding-android-adaptive-icons-cee8a9de93e2>`__
   -  `Designing Adaptive Icons <https://medium.com/google-design/designing-adaptive-icons-515af294c783>`__
   -  `Implementing Adaptive Icons <https://medium.com/androiddevelopers/implementing-adaptive-icons-1e4d1795470e>`__
   -  `Adaptive Icon Playground app <https://github.com/nickbutcher/AdaptiveIconPlayground>`__
   -  `Create Adaptive and Legacy Launcher icons <https://developer.android.google.cn/studio/write/image-asset-studio#create-adaptive>`__
   -  `Supporting different pixel densities <https://developer.android.google.cn/training/multiscreen/screendensities#TaskProvideAltBmp>`__
   -  `Put app icons in mipmap directories <https://developer.android.google.cn/training/multiscreen/screendensities#mipmap>`__
   -  `Vector Drawables Overview <https://developer.android.google.cn/guide/topics/graphics/vector-drawable-resources>`__
   -  `VectorDrawable class <https://developer.android.google.cn/reference/kotlin/android/graphics/drawable/VectorDrawable>`__

.. |ec0237fb600dd2a9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/ec0237fb600dd2a9.png
.. |e7a9b86b35f7d6c3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/e7a9b86b35f7d6c3.png
.. |1e4c0d2c081a8fd2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/1e4c0d2c081a8fd2.png
.. |1debcf330fd04c7b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/1debcf330fd04c7b.png
.. |d8e9dbdeafe9038a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/d8e9dbdeafe9038a.png
.. |8d1fda7396afe8e5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/8d1fda7396afe8e5.png
.. |8de56cba7583251f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/8de56cba7583251f.png
.. |eef1b274888f2a1c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/eef1b274888f2a1c.png
.. |b725c14ee21fce54.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/b725c14ee21fce54.png
.. |1da42b08b39e8560.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/1da42b08b39e8560.png
.. |5a5eaf5d0c2f67de.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/5a5eaf5d0c2f67de.png
.. |1af36983e3677abe.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/1af36983e3677abe.gif
.. |29758558d7509497.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/29758558d7509497.png
.. |b24d4a67be43b6d9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/b24d4a67be43b6d9.png
.. |c05923559b5541f1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/c05923559b5541f1.png
.. |dbe59156de9fde40.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/dbe59156de9fde40.png
.. |4729e4abc9542d87.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/4729e4abc9542d87.png
.. |2f59e5ac70a8a033.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/2f59e5ac70a8a033.png
.. |dc0aee541c8039e7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/dc0aee541c8039e7.png
.. |a111303e7703fc99.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/a111303e7703fc99.png
.. |57fec53a0411f206.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/57fec53a0411f206.png
.. |4b0a24f0cbd9a2a2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/4b0a24f0cbd9a2a2.png
.. |339af1a3b9ff550c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/339af1a3b9ff550c.png
.. |31bc221b0e4b8206.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/31bc221b0e4b8206.png
.. |c943f8c37c450545.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-training-change-app-icon/img/c943f8c37c450545.png


ğŸš€ Practice: Build a grid
=========================


1. Before you begin
--------------------------------------------------------------------------------

   Congratulations! You built your first app with a scrollable list. Now you're ready to
   put what you learned into practice.

   This exercise focuses on creating the components necessary to build a scrollable list.
   The material expands upon what you learned in the `Add a scrollable list`_
   codelab, and allows you to apply that knowledge to build a scrollable grid.

   Some sections might require you to use composables or modifiers, which you may not have
   seen before. In such cases, see the **References** available for each problem, where you
   can find links to documentation related to the modifiers, properties, or composables
   that you are not familiar with. You can read the documentation and determine how to
   incorporate the concepts in the app. The ability to understand documentation is an
   essential skill that you should develop to grow your knowledge.

   The solution code is available at the end, but try to solve the exercises before you
   check the answers. Consider the solution as one way to implement the app.

.. _Add a scrollable list: https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-training-add-scrollable-list

Prerequisites

   -  Complete the Android Basics in Compose coursework through the 
      `Add a scrollable list`_ codelab.


What you'll need

   -  A computer with internet access and Android Studio installed.


Resources

   You will need the following resources to complete the code for these practice problems

   -  `Topic images <https://github.com/google-developer-training/basic-android-kotlin-compose-training-courses/blob/main/topics.zip>`__.
      These images represent each topic in the list.
   -  `ic_grain.xml <https://github.dev/android/compose-samples/blob/main/Owl/app/src/main/res/drawable/ic_grain.xml>`__.
      This is the decorative icon that appears next to the number of courses in the topic.


What you'll build

   In these practice problems, you will build out the **Courses** app from scratch. The
   **Courses** app displays a list of course topics.

   The practice problems are split into sections, where you will build:

   -  A course topic data class:

      The topic data will have an image, a name, and the number of associated courses in that
      topic.

   -  A composable to represent a course topic grid item:

      Each topic item will display the image, the name, the number of associated courses, and
      a decorative icon.

   -  A composable to display a grid of those course topic items.

      The final app will look like this:

      |97c449bee4a2029d.png|


2. Get started
--------------------------------------------------------------------------------

   Create a New Project with the **Empty Activity** template and a minimum SDK of 24.


3. Topic data class
--------------------------------------------------------------------------------

   In this section, you build a class to hold the data for each course topic.

   Take a look at the items from the final app.

   |bf68e7995b2f47bd.png|

   Each course topic holds three pieces of unique information. Using the unique content of
   each item as a reference, create a class to hold this data.


4. Data source
--------------------------------------------------------------------------------

   In this section, you create a data set for the grid of courses.

   Copy the following items into **app/src/main/res/values/strings.xml**:

   .. code:: prettyprint

      <string name="architecture">Architecture</string>
      <string name="crafts">Crafts</string>
      <string name="business">Business</string>
      <string name="culinary">Culinary</string>
      <string name="design">Design</string>
      <string name="fashion">Fashion</string>
      <string name="film">Film</string>
      <string name="gaming">Gaming</string>
      <string name="drawing">Drawing</string>
      <string name="lifestyle">Lifestyle</string>
      <string name="music">Music</string>
      <string name="painting">Painting</string>
      <string name="photography">Photography</string>
      <string name="tech">Tech</string>

   Create an empty file called **DataSource.kt**. Copy the following code into the file:

   .. code:: prettyprint

      object DataSource {
          val topics = listOf(
              Topic(R.string.architecture, 58, R.drawable.architecture),
              Topic(R.string.crafts, 121, R.drawable.crafts),
              Topic(R.string.business, 78, R.drawable.business),
              Topic(R.string.culinary, 118, R.drawable.culinary),
              Topic(R.string.design, 423, R.drawable.design),
              Topic(R.string.fashion, 92, R.drawable.fashion),
              Topic(R.string.film, 165, R.drawable.film),
              Topic(R.string.gaming, 164, R.drawable.gaming),
              Topic(R.string.drawing, 326, R.drawable.drawing),
              Topic(R.string.lifestyle, 305, R.drawable.lifestyle),
              Topic(R.string.music, 212, R.drawable.music),
              Topic(R.string.painting, 172, R.drawable.painting),
              Topic(R.string.photography, 321, R.drawable.photography),
              Topic(R.string.tech, 118, R.drawable.tech)
          )
      }


5. Topic grid item
--------------------------------------------------------------------------------

   Create a composable to represent a topic grid item.


Final screenshot

   After you finish the implementation, your topic item layout should match the screenshot
   below:

   |f7e47f86ab7ea8b3.png|


UI specifications

   Use the following UI specifications:

   |3bdfc5ea4f3d619d.png|

   |b051bb634fa06501.png|

   `Text Styling <https://developer.android.google.cn/jetpack/compose/themes/material#text-styles>`__

   **Hint:** Which composable arranges its children vertically and which arranges its
   children horizontally?


References

   -  `Typography <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/Typography>`__
   -  `Standard layout components <https://developer.android.google.cn/jetpack/compose/layouts/basics#standard-layouts>`__
   -  `Box <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Box(androidx.compose.ui.Modifier)>`__
   -  `Column <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Column(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,kotlin.Function1)>`__
   -  `Row <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Row(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,kotlin.Function1)>`__
   -  `aspectRatio <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier).aspectRatio(kotlin.Float,kotlin.Boolean)>`__
   -  `painterResource <https://developer.android.google.cn/jetpack/compose/resources#vector-assets>`__


6. Courses grid
--------------------------------------------------------------------------------

   Once the topic grid item is created, it can be used to make a grid of course topics.

   In this exercise, you use your grid item composable to make a grid with two columns.

   .. code:: kotlin

      import androidx.compose.foundation.Image
      import androidx.compose.foundation.layout.Arrangement
      import androidx.compose.foundation.layout.Box
      import androidx.compose.foundation.layout.Column
      import androidx.compose.foundation.layout.Row
      import androidx.compose.foundation.lazy.grid.GridCells
      import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
      import androidx.compose.foundation.lazy.grid.items
      import androidx.compose.material3.Card
      import androidx.compose.material3.Icon
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Surface
      import androidx.compose.material3.Text
      ...

      @Composable
      fun TopicGrid(modifier: Modifier = Modifier) {
         LazyVerticalGrid(
            columns = GridCells.Fixed(2),
            verticalArrangement = Arrangement.spacedBy(dimensionResource(R.dimen.padding_small)),
            horizontalArrangement = Arrangement.spacedBy(dimensionResource(R.dimen.padding_small)),
            modifier = modifier
         ) {
            items(DataSource.topics) { topic ->
                  TopicCard(topic)
            }
         }
      }

      @Composable
      fun TopicCard(topic: Topic, modifier: Modifier = Modifier) {
         Card {
            Row {
                  Box {
                     Image(
                        painter = painterResource(id = topic.imageRes),
                        contentDescription = null,
                        modifier = modifier
                              .size(width = 68.dp, height = 68.dp)
                              .aspectRatio(1f),
                        contentScale = ContentScale.Crop
                     )
                  }

                  Column {
                     Text(
                        text = stringResource(id = topic.name),
                        style = MaterialTheme.typography.bodyMedium,
                        modifier = Modifier.padding(
                              start = dimensionResource(R.dimen.padding_medium),
                              top = dimensionResource(R.dimen.padding_medium),
                              end = dimensionResource(R.dimen.padding_medium),
                              bottom = dimensionResource(R.dimen.padding_small)
                        )
                     )
                     Row(verticalAlignment = Alignment.CenterVertically) {
                        Icon(
                              painter = painterResource(R.drawable.ic_grain),
                              contentDescription = null,
                              modifier = Modifier
                                 .padding(start = dimensionResource(R.dimen.padding_medium))
                        )
                        Text(
                              text = topic.availableCourses.toString(),
                              style = MaterialTheme.typography.labelMedium,
                              modifier = Modifier.padding(start = dimensionResource(R.dimen.padding_small))
                        )
                     }
                  }
            }
         }
      }


Final screenshot

   After you finish the implementation, your design should match the screenshot below:

   |97c449bee4a2029d.png|


UI specification

   Use the following UI specifications:

   |aee57a3a525e91bb.png|


References

   -  `Lists and grids <https://developer.android.google.cn/jetpack/compose/lists#grids>`__
   -  `Fixed grid cells <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/grid/GridCells.Fixed>`__
   -  `Lists: Content spacing <https://developer.android.google.cn/jetpack/compose/lists#content-spacing>`__
   -  `Codelab: Add a scrollable list <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-training-add-scrollable-list>`__


7. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use this git command:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-courses.git

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-courses/archive/refs/heads/main.zip>`__

   If you want to see the solution code, 
   `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-courses>`__.

   The app that you built in this exercise is a modified version of the Owl app courses
   screen. The `Owl app <https://github.com/android/compose-samples/tree/main/Owl>`__ 
   is a comprehensive sample app demonstrating the capabilities of Compose. Other Compose sample
   apps can be found in the GitHub repository: `compose-samples <https://github.com/android/compose-samples>`__.

.. |97c449bee4a2029d.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-practice-grid/img/97c449bee4a2029d.png
.. |bf68e7995b2f47bd.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-practice-grid/img/bf68e7995b2f47bd.png
.. |f7e47f86ab7ea8b3.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-practice-grid/img/f7e47f86ab7ea8b3.png
.. |3bdfc5ea4f3d619d.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-practice-grid/img/3bdfc5ea4f3d619d.png
.. |b051bb634fa06501.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-practice-grid/img/b051bb634fa06501.png
.. |aee57a3a525e91bb.png| image:: https://developer.android.google.cn//static/codelabs/basic-android-kotlin-compose-practice-grid/img/aee57a3a525e91bb.png


ğŸš€ Material Theming with Jetpack Compose
========================================

   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-material-theming



1. Before you begin
--------------------------------------------------------------------------------

   `Material Design <https://material.io/>`__ is a design system built and supported by
   Google designers and developers to build high-quality digital experiences for Android,
   as well as other mobile and web platforms. It provides guidelines on how to build your
   app UI in a readable, attractive, and consistent manner.

   In this codelab, you learn about Material Theming, which allows you to use Material
   Design in your app, with guidance on customizing colors, typography, and shapes. You can
   customize as little, or as much, as you like for your app. You also learn how to add a
   top app bar to display the app's name and icon.


Prerequisites

   -  Familiar with the Kotlin language, including syntax, functions, and variables.
   -  Able to build layouts in Compose, including rows and columns with padding.
   -  Able to create simple lists in Compose.


What you'll learn

   -  How to apply Material Theming to a Compose app.
   -  How to add a custom color palette to your app.
   -  How to add custom fonts to your app.
   -  How to add custom shapes to elements in your app.
   -  How to add a top app bar to your app.


What you'll build

   -  You will build a beautiful app that incorporates Material Design best practices.


What you'll need

   -  The latest version of Android Studio.
   -  An internet connection to download the starter code and fonts.


2. App overview
--------------------------------------------------------------------------------

   In this codelab, you create **Woof**, an app that displays a list of dogs and uses
   Material Design to create a beautiful app experience.

   |92eca92f64b029cf.png|

   Through this codelab, we will show you some of what is possible using Material Theming.
   Use this codelab for ideas of how to use Material Theming to improve the look and feel
   of the apps you create in the future.


Color palette

   Below are the color palettes for both light and dark themes that we will create.

   |This image has the light color scheme for the Woof app.|

   |This image has the dark color scheme for the Woof app.|

   Here is the final app in both light theme and dark theme.

   ====================== =====================
   **Light theme**         **Dark theme**
   |92eca92f64b029cf.png|  |883428064ccbc9.png|
   ====================== =====================


Typography

   Below are the type styles you will use in the app.

   |8ea685b3871d5ffc.png|


Theme file

   The **Theme.kt** file is the file that holds all the information about the theme of the
   app, which is defined through color, typography, and shape. This is an important file
   for you to know. Inside of the file is the composable ``WoofTheme()``, which sets the
   colors, typography, and shapes of the app.

   .. code:: prettyprint

      @Composable
      fun WoofTheme(
          darkTheme: Boolean = isSystemInDarkTheme(),
          // Dynamic color is available on Android 12+
          dynamicColor: Boolean = false,
          content: @Composable () -> Unit
      ) {
          val colorScheme = when {
              dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
                  val context = LocalContext.current
                  if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
              }

              darkTheme -> DarkColors
              else -> LightColors
          }
          val view = LocalView.current
          if (!view.isInEditMode) {
              SideEffect {
                  setUpEdgeToEdge(view, darkTheme)
              }
          }

          MaterialTheme(
              colorScheme = colorScheme,
              shapes = Shapes,
              typography = Typography,
              content = content
          )
      }

      /**
       * Sets up edge-to-edge for the window of this [view]. The system icon colors are set to either
       * light or dark depending on whether the [darkTheme] is enabled or not.
       */
      private fun setUpEdgeToEdge(view: View, darkTheme: Boolean) {
          val window = (view.context as Activity).window
          WindowCompat.setDecorFitsSystemWindows(window, false)
          window.statusBarColor = Color.Transparent.toArgb()
          val navigationBarColor = when {
              Build.VERSION.SDK_INT >= 29 -> Color.Transparent.toArgb()
              Build.VERSION.SDK_INT >= 26 -> Color(0xFF, 0xFF, 0xFF, 0x63).toArgb()
              // Min sdk version for this app is 24, this block is for SDK versions 24 and 25
              else -> Color(0x00, 0x00, 0x00, 0x50).toArgb()
          }
          window.navigationBarColor = navigationBarColor
          val controller = WindowCompat.getInsetsController(window, view)
          controller.isAppearanceLightStatusBars = !darkTheme
          controller.isAppearanceLightNavigationBars = !darkTheme
      }

   In **MainActivity.kt**, the ``WoofTheme()`` is added to provide the Material Theming for
   the entire app.

   .. code:: prettyprint

      class MainActivity : ComponentActivity() {
         override fun onCreate(savedInstanceState: Bundle?) {
             super.onCreate(savedInstanceState)
             setContent {
                 WoofTheme {
                     Surface(
                         modifier = Modifier.fillMaxSize()
                     ) {
                         WoofApp()
                     }
                 }
             }
         }
      }

   Take a look at the ``WoofPreview()``. The ``WoofTheme()`` is added to provide the
   Material Theming you see in the ``WoofPreview()``.

   .. code:: prettyprint

      @Preview
      @Composable
      fun WoofPreview() {
          WoofTheme(darkTheme = false) {
              WoofApp()
          }
      }


3. Get the starter code
--------------------------------------------------------------------------------

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof/archive/refs/heads/starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof.git
      $ cd basic-android-kotlin-compose-training-woof
      $ git checkout starter

   **Note:** The starter code is in the ``starter`` branch of the downloaded repository.

   You can browse the code in the
   `Woof app <https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof/tree/starter>`__
   GitHub repository.


Explore the starter code

   1.  Open the starter code in Android Studio.
   2.  Open **com.example.woof** > **data** > **Dog.kt**. This contains the
       ``Dog data class`` that will be used to represent the dog's photo, name, age, and
       hobbies. It also contains a list of dogs and the information that you will use as
       the data in your app.
   3.  Open **res** > **drawable**. This contains all the image assets that you need for
       this project, including the app icon, dog images, and icons.
   4.  Open **res** > **values** > **strings.xml**. This contains the strings you use in
       this app, including the app name, dog names, their descriptions, and more.
   5.  Open **MainActivity.kt**. This contains the code to create a simple list that
       displays a photo of a dog, the dog's name, and the dog's age.
   6.  ``WoofApp()`` contains a ``LazyColumn`` that displays the ``DogItem``\ s.
   7.  ``DogItem()`` contains a ``Row`` that displays a photo of the dog and information
       about it.
   8.  ``DogIcon()`` displays a photo of the dog.
   9.  ``DogInformation()`` displays the dog's name and age.
   10. ``WoofPreview()`` allows you to see a preview of the app in the **Design** pane.

   **Note**: You may notice that each ``@Composable`` method has a Modifier added as a
   parameter. In Compose, it is best practice to pass a modifier parameter to composable
   functions. This is because it allows a parent composable to pass contextual information
   to a child composable.

   For example, given a button, one parent might want its child button to use the full
   available size, while the another parent might want it to wrap content. This makes the
   code more reusable. This parameter is typically named "modifier" and should appear as
   the first optional parameter in the function's parameter list. This modifier is applied
   to the first child of the method. Read more about it in the 
   `API Guidelines for Jetpack Compose <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/compose/docs/compose-api-guidelines.md#elements-accept-and-respect-a-modifier-parameter>`__.


Ensure your emulator/device is in light theme

   In this codelab, you will be working with both light and dark themes, however, most of
   the codelab is in light theme. Before you get started, ensure that your device/emulator
   is in light theme.

   In order to view your app in light theme, on your emulator or physical device:

   1. Go to the **Settings** app on the device.
   2. Search for **Dark theme** and click into it.
   3. If **Dark theme** is on, switch it off.

   Run the starter code to see what you're starting with; it's a list that displays dogs
   with their photos, names, and ages. It is functional, but it doesn't look great, so we
   are going to fix that.

   |6d253ae50c63014d.png|


4. Add color
--------------------------------------------------------------------------------

   The first thing you are going to modify in the **Woof** app is the color scheme.

   A color scheme is the combination of colors that your app uses. Different color
   combinations evoke different moods, which influences how people feel when they use your
   app.

   Color, in the Android system, is represented by a hexadecimal (hex) color value. A hex
   color code starts with a pound (#) character, and is followed by six letters and/or
   numbers that represent the red, green, and blue (RGB) components of that color. The
   first two letters/numbers refer to red, the next two refer to green, and the last two
   refer to blue.

   |This shows the hexadecimal numbers that is used to create colors.|

   A color can also include an alpha valueâ€”letters and/or numbersâ€”which represents the
   transparency of the color (#00 is 0% opacity (fully transparent), #FF is 100% opacity
   (fully opaque)). When included, the alpha value is the first two characters of the hex
   color code after the pound (#) character. If an alpha value is not included, it is
   assumed to be #FF, which is 100% opacity (fully opaque).

   Below are some example colors and their hex values.

   |2753d8cdd396c449.png|


Use Material Theme Builder to create a color scheme

   To create a custom color scheme for our app, we will use the Material Theme Builder.

   1. Click this link to go to the `Material Theme Builder <https://m3.material.io/theme-builder#/custom>`__.
   2. On the left pane you will see the Core Colors, click on Primary:

   |This shows four core colors in the Material Theme Builder|

   3. The HCT color picker will open.

   |This is the HCT Color Picker to choose a custom color in the Material Theme Builder.|

   4. To create the color scheme shown in the app screenshots, you will change the primary
      color in this color picker. In the text box replace the current text with
      **#006C4C**. This will make the primary color of the app green.

   |This shows the HCT Color picker set to green|

   Notice how this updates the apps on the screen to adopt a green color scheme.

   |This shows the Material Theme Builder's apps reacting to the change in color from the
   HCT color picker.|

   5. Scroll down the page and you will see the full color scheme for light and dark theme
      generated off of the color you inputted.

   |Material Theme Builder Light Scheme|

   |Dark Scheme generated by Material Theme Builder|

   You may wonder what all these roles are and how they are utilized, here are a few of the
   main ones:

   -  The **primary** colors are used for key components across the UI.
   -  The **secondary** colors are used for less prominent components in the UI.
   -  The **tertiary** colors are used for contrasting accents that can be used to balance
      primary and secondary colors or bring heightened attention to an element, such as an
      input field.
   -  The **on** color elements appear **on top** of other colors in the palette, and are
      primarily applied to text, iconography, and strokes. In our color palette, we have an
      **onSurface** color, which appears on top of the **surface** color, and an
      **onPrimary** color, which appears on top of the **primary** color.

   Having these slots leads to a cohesive design system, where related components are
   colored similarly.

   Enough theory about colorsâ€”time to add this beautiful color palette to the app!


Add color palette to theme

   On the Material Theme Builder page, there is the option to click the **Export** button
   to download a **Color.kt** file and **Theme.kt** file with the custom theme you created
   in the Theme Builder.

   This will work to add the custom theme we create to your app. However, because the
   generated **Theme.kt** file does not include the code for dynamic color which we will
   cover later in the codelab, copy the files in.

   **Note**: If you do decide to use the files generated from the Material Theme Builder
   for a different project, you will need to update the package name to the package name of
   your project.

   1. Open the **Color.kt** file and replace the contents with the code below to copy in
      the new color scheme.

   .. code:: prettyprint

      package com.example.woof.ui.theme

      import androidx.compose.ui.graphics.Color

      val md_theme_light_primary = Color(0xFF006C4C)
      val md_theme_light_onPrimary = Color(0xFFFFFFFF)
      val md_theme_light_primaryContainer = Color(0xFF89F8C7)
      val md_theme_light_onPrimaryContainer = Color(0xFF002114)
      val md_theme_light_secondary = Color(0xFF4D6357)
      val md_theme_light_onSecondary = Color(0xFFFFFFFF)
      val md_theme_light_secondaryContainer = Color(0xFFCFE9D9)
      val md_theme_light_onSecondaryContainer = Color(0xFF092016)
      val md_theme_light_tertiary = Color(0xFF3D6373)
      val md_theme_light_onTertiary = Color(0xFFFFFFFF)
      val md_theme_light_tertiaryContainer = Color(0xFFC1E8FB)
      val md_theme_light_onTertiaryContainer = Color(0xFF001F29)
      val md_theme_light_error = Color(0xFFBA1A1A)
      val md_theme_light_errorContainer = Color(0xFFFFDAD6)
      val md_theme_light_onError = Color(0xFFFFFFFF)
      val md_theme_light_onErrorContainer = Color(0xFF410002)
      val md_theme_light_background = Color(0xFFFBFDF9)
      val md_theme_light_onBackground = Color(0xFF191C1A)
      val md_theme_light_surface = Color(0xFFFBFDF9)
      val md_theme_light_onSurface = Color(0xFF191C1A)
      val md_theme_light_surfaceVariant = Color(0xFFDBE5DD)
      val md_theme_light_onSurfaceVariant = Color(0xFF404943)
      val md_theme_light_outline = Color(0xFF707973)
      val md_theme_light_inverseOnSurface = Color(0xFFEFF1ED)
      val md_theme_light_inverseSurface = Color(0xFF2E312F)
      val md_theme_light_inversePrimary = Color(0xFF6CDBAC)
      val md_theme_light_shadow = Color(0xFF000000)
      val md_theme_light_surfaceTint = Color(0xFF006C4C)
      val md_theme_light_outlineVariant = Color(0xFFBFC9C2)
      val md_theme_light_scrim = Color(0xFF000000)

      val md_theme_dark_primary = Color(0xFF6CDBAC)
      val md_theme_dark_onPrimary = Color(0xFF003826)
      val md_theme_dark_primaryContainer = Color(0xFF005138)
      val md_theme_dark_onPrimaryContainer = Color(0xFF89F8C7)
      val md_theme_dark_secondary = Color(0xFFB3CCBE)
      val md_theme_dark_onSecondary = Color(0xFF1F352A)
      val md_theme_dark_secondaryContainer = Color(0xFF354B40)
      val md_theme_dark_onSecondaryContainer = Color(0xFFCFE9D9)
      val md_theme_dark_tertiary = Color(0xFFA5CCDF)
      val md_theme_dark_onTertiary = Color(0xFF073543)
      val md_theme_dark_tertiaryContainer = Color(0xFF244C5B)
      val md_theme_dark_onTertiaryContainer = Color(0xFFC1E8FB)
      val md_theme_dark_error = Color(0xFFFFB4AB)
      val md_theme_dark_errorContainer = Color(0xFF93000A)
      val md_theme_dark_onError = Color(0xFF690005)
      val md_theme_dark_onErrorContainer = Color(0xFFFFDAD6)
      val md_theme_dark_background = Color(0xFF191C1A)
      val md_theme_dark_onBackground = Color(0xFFE1E3DF)
      val md_theme_dark_surface = Color(0xFF191C1A)
      val md_theme_dark_onSurface = Color(0xFFE1E3DF)
      val md_theme_dark_surfaceVariant = Color(0xFF404943)
      val md_theme_dark_onSurfaceVariant = Color(0xFFBFC9C2)
      val md_theme_dark_outline = Color(0xFF8A938C)
      val md_theme_dark_inverseOnSurface = Color(0xFF191C1A)
      val md_theme_dark_inverseSurface = Color(0xFFE1E3DF)
      val md_theme_dark_inversePrimary = Color(0xFF006C4C)
      val md_theme_dark_shadow = Color(0xFF000000)
      val md_theme_dark_surfaceTint = Color(0xFF6CDBAC)
      val md_theme_dark_outlineVariant = Color(0xFF404943)
      val md_theme_dark_scrim = Color(0xFF000000)

   2. Open the **Theme.kt** file and replace the contents with the code below to add the
      new colors to the theme.

   .. code:: prettyprint

      package com.example.woof.ui.theme

      import android.app.Activity
      import android.os.Build
      import android.view.View
      import androidx.compose.foundation.isSystemInDarkTheme
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.darkColorScheme
      import androidx.compose.material3.dynamicDarkColorScheme
      import androidx.compose.material3.dynamicLightColorScheme
      import androidx.compose.material3.lightColorScheme
      import androidx.compose.runtime.Composable
      import androidx.compose.runtime.SideEffect
      import androidx.compose.ui.graphics.Color
      import androidx.compose.ui.graphics.toArgb
      import androidx.compose.ui.platform.LocalContext
      import androidx.compose.ui.platform.LocalView
      import androidx.core.view.WindowCompat

      private val LightColors = lightColorScheme(
          primary = md_theme_light_primary,
          onPrimary = md_theme_light_onPrimary,
          primaryContainer = md_theme_light_primaryContainer,
          onPrimaryContainer = md_theme_light_onPrimaryContainer,
          secondary = md_theme_light_secondary,
          onSecondary = md_theme_light_onSecondary,
          secondaryContainer = md_theme_light_secondaryContainer,
          onSecondaryContainer = md_theme_light_onSecondaryContainer,
          tertiary = md_theme_light_tertiary,
          onTertiary = md_theme_light_onTertiary,
          tertiaryContainer = md_theme_light_tertiaryContainer,
          onTertiaryContainer = md_theme_light_onTertiaryContainer,
          error = md_theme_light_error,
          errorContainer = md_theme_light_errorContainer,
          onError = md_theme_light_onError,
          onErrorContainer = md_theme_light_onErrorContainer,
          background = md_theme_light_background,
          onBackground = md_theme_light_onBackground,
          surface = md_theme_light_surface,
          onSurface = md_theme_light_onSurface,
          surfaceVariant = md_theme_light_surfaceVariant,
          onSurfaceVariant = md_theme_light_onSurfaceVariant,
          outline = md_theme_light_outline,
          inverseOnSurface = md_theme_light_inverseOnSurface,
          inverseSurface = md_theme_light_inverseSurface,
          inversePrimary = md_theme_light_inversePrimary,
          surfaceTint = md_theme_light_surfaceTint,
          outlineVariant = md_theme_light_outlineVariant,
          scrim = md_theme_light_scrim,
      )


      private val DarkColors = darkColorScheme(
          primary = md_theme_dark_primary,
          onPrimary = md_theme_dark_onPrimary,
          primaryContainer = md_theme_dark_primaryContainer,
          onPrimaryContainer = md_theme_dark_onPrimaryContainer,
          secondary = md_theme_dark_secondary,
          onSecondary = md_theme_dark_onSecondary,
          secondaryContainer = md_theme_dark_secondaryContainer,
          onSecondaryContainer = md_theme_dark_onSecondaryContainer,
          tertiary = md_theme_dark_tertiary,
          onTertiary = md_theme_dark_onTertiary,
          tertiaryContainer = md_theme_dark_tertiaryContainer,
          onTertiaryContainer = md_theme_dark_onTertiaryContainer,
          error = md_theme_dark_error,
          errorContainer = md_theme_dark_errorContainer,
          onError = md_theme_dark_onError,
          onErrorContainer = md_theme_dark_onErrorContainer,
          background = md_theme_dark_background,
          onBackground = md_theme_dark_onBackground,
          surface = md_theme_dark_surface,
          onSurface = md_theme_dark_onSurface,
          surfaceVariant = md_theme_dark_surfaceVariant,
          onSurfaceVariant = md_theme_dark_onSurfaceVariant,
          outline = md_theme_dark_outline,
          inverseOnSurface = md_theme_dark_inverseOnSurface,
          inverseSurface = md_theme_dark_inverseSurface,
          inversePrimary = md_theme_dark_inversePrimary,
          surfaceTint = md_theme_dark_surfaceTint,
          outlineVariant = md_theme_dark_outlineVariant,
          scrim = md_theme_dark_scrim,
      )

      @Composable
      fun WoofTheme(
          darkTheme: Boolean = isSystemInDarkTheme(),
          // Dynamic color is available on Android 12+
          dynamicColor: Boolean = false,
          content: @Composable () -> Unit
      ) {
          val colorScheme = when {
              dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
                  val context = LocalContext.current
                  if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
              }

              darkTheme -> DarkColors
              else -> LightColors
          }
          val view = LocalView.current
          if (!view.isInEditMode) {
              SideEffect {
                  setUpEdgeToEdge(view, darkTheme)
              }
          }

          MaterialTheme(
              colorScheme = colorScheme,
              shapes = Shapes,
              typography = Typography,
              content = content
          )
      }

      /**
       * Sets up edge-to-edge for the window of this [view]. The system icon colors are set to either
       * light or dark depending on whether the [darkTheme] is enabled or not.
       */
      private fun setUpEdgeToEdge(view: View, darkTheme: Boolean) {
          val window = (view.context as Activity).window
          WindowCompat.setDecorFitsSystemWindows(window, false)
          window.statusBarColor = Color.Transparent.toArgb()
          val navigationBarColor = when {
              Build.VERSION.SDK_INT >= 29 -> Color.Transparent.toArgb()
              Build.VERSION.SDK_INT >= 26 -> Color(0xFF, 0xFF, 0xFF, 0x63).toArgb()
              // Min sdk version for this app is 24, this block is for SDK versions 24 and 25
              else -> Color(0x00, 0x00, 0x00, 0x50).toArgb()
          }
          window.navigationBarColor = navigationBarColor
          val controller = WindowCompat.getInsetsController(window, view)
          controller.isAppearanceLightStatusBars = !darkTheme
          controller.isAppearanceLightNavigationBars = !darkTheme
      }

   In ``WoofTheme()`` the ``colorScheme val`` uses a ``when`` statement

   -  If ``dynamicColor`` is true and the build version is S or higher, it checks if the
      device is in ``darkTheme`` or not.
   -  If it is in dark theme, ``colorScheme`` will be set to ``dynamicDarkColorScheme``.
   -  If it is not in dark theme, it will be set to ``dynamicLightColorScheme``.
   -  If the app is not using ``dynamicColorScheme``, it checks if your app is in
      ``darkTheme``. If so then ``colorScheme`` will be set to ``DarkColors``.
   -  If neither of those are true then ``colorScheme`` will be set to ``LightColors``.

   The copied in **Theme.kt** file has ``dynamicColor`` set to false and the devices we are
   working with are in light mode so the ``colorScheme`` will be set to ``LightColors``.

   .. code:: prettyprint

      val colorScheme = when {
             dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
                 val context = LocalContext.current
                 if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
             }

             darkTheme -> DarkColors
             else -> LightColors
         }

   3. Re-run your app, notice that the app bar has automatically changed color.

   |b48b3fa2ecec9b86.png|


Color mapping

   Material components are automatically mapped to color slots. Other key components across
   the UI like Floating Action Buttons also default to the Primary color. This means that
   you don't need to explicitly assign a color to a component; it is automatically mapped
   to a color slot when you set the color theme in your app. You can override this by
   explicitly setting a color in the code. Read more about color roles
   `here <https://m3.material.io/styles/color/the-color-system/color-roles>`__.

   In this section we will wrap the ``Row`` that contains the ``DogIcon()`` and
   ``DogInformation()`` with a ``Card`` to differentiate the list item colors with the
   background.

   1. In ``DogItem()`` composable function, wrap the ``Row()`` with a ``Card()``.

   .. code:: prettyprint

      Card() {
         Row(
             modifier = modifier
                 .fillMaxWidth()
                 .padding(dimensionResource(id = R.dimen.padding_small))
         ) {
             DogIcon(dog.imageResourceId)
             DogInformation(dog.name, dog.age)
         }
      }

   2. Since ``Card`` is now the first child composable in ``DogItem()``, pass in the
      modifier from ``DogItem()`` to the ``Card``, and update the ``Row``'s modifier to a
      new instance of ``Modifier``.

   .. code:: prettyprint

      Card(modifier = modifier) {
         Row(
             modifier = Modifier
                 .fillMaxWidth()
                 .padding(dimensionResource(id = R.dimen.padding_small))
         ) {
             DogIcon(dog.imageResourceId)
             DogInformation(dog.name, dog.age)
         }
      }

   3. Take a look at ``WoofPreview()``. The list items have now automatically changed color
      because of the ``Card`` Composables. The colors look great, but there is no spacing
      between the list items.

   |6d49372a1ef49bc7.png|


Dimens file

   Just like you use the **strings.xml** to store the strings in your app, it is also a
   good practice to use a file called **dimens.xml** to store dimension values. This is
   helpful so you don't hard code values and so if you need to, you can change them in a
   single place.

   Go to **app** > **res** > **values** > **dimens.xml** and take a look at the file. It
   stores dimension values for ``padding_small``, ``padding_medium``, and ``image_size``.
   These dimensions will be used throughout the app.

   .. code:: prettyprint

      <resources>
         <dimen name="padding_small">8dp</dimen>
         <dimen name="padding_medium">16dp</dimen>
         <dimen name="image_size">64dp</dimen>
      </resources>

   To add a value from the **dimens.xml** file, this the correct format:

   |Shows how to properly format adding values from the dimension resource|

   For example, to add ``padding_small``, you would pass in
   ``dimensionResource(id = R.dimen.``\ *``padding_small``*\ ``)``.

   1. In ``WoofApp()``, add a ``modifier`` with ``padding_small`` in the call to
      ``DogItem()``.

   .. code:: prettyprint

      @Composable
      fun WoofApp() {
          Scaffold { it ->
              LazyColumn(contentPadding = it) {
                  items(dogs) {
                      DogItem(
                          dog = it,
                          modifier = Modifier.padding(dimensionResource(R.dimen.padding_small))
                      )
                  }
              }
          }
      }

   In ``WoofPreview()``, there is now more definition between list items.

   |c54f870f121fe02.png|


Dark theme

   In the Android system, there is the option to switch your device to a dark theme. A dark
   theme uses darker, more subdued colors, and:

   -  Can reduce power usage by a significant amount (depending on the device's screen
      technology).
   -  Improves visibility for users with low vision and those who are sensitive to bright
      light.
   -  Makes it easier for anyone to use a device in a low-light environment.

   Your app can opt-in to `Force Dark <https://developer.android.google.cn/guide/topics/ui/look-and-feel/darktheme#force-dark>`__,
   which means the system will implement a dark theme for you. However, it is a better
   experience for your users if you implement the dark theme, so that you maintain full
   control over the app theme.

   When choosing your own dark theme, it is important to note that colors for a dark theme
   need to meet `accessibility contrast standards <https://webaim.org/resources/contrastchecker/>`__. 
   Dark themes use a dark surface color, with limited color accents.


View dark theme in preview

   You already added the colors for dark theme in the previous step. To see the dark theme
   in action, you will add another Preview Composable to **MainActivity.kt**. That way,
   when you change the UI layout in your code, you can see how the light theme and dark
   theme previews look simultaneously.

   1. Under ``WoofPreview()``, create a new function called ``WoofDarkThemePreview()`` and
      annotate it with ``@Preview`` and ``@Composable``.

   .. code:: prettyprint

      @Preview
      @Composable
      fun WoofDarkThemePreview() {

      }

   2. Inside ``DarkThemePreview()``, add the ``WoofTheme()``. Without adding
      ``WoofTheme()``, you wouldn't see any of the styling we added in the app. Set the
      ``darkTheme`` parameter to **true.**

   .. code:: prettyprint

      @Preview
      @Composable
      fun WoofDarkThemePreview() {
         WoofTheme(darkTheme = true) {

         }
      }

   3. Call ``WoofApp()`` inside of ``WoofTheme()``.

   .. code:: prettyprint

      @Preview
      @Composable
      fun WoofDarkThemePreview() {
         WoofTheme(darkTheme = true) {
             WoofApp()
         }
      }

   Now scroll down in the **Design** pane to see the app in dark theme, including the
   darker app/list item background and the lighter text. Compare the differences between
   the dark and light themes.

   ====================== ======================
   **Dark theme**         **Light theme**
   |92e2efb9dfd4ca6d.png| |b444fd0900815b2a.png|
   ====================== ======================


View dark theme on your device or emulator

   In order to view your app in dark theme on the emulator or physical device:

   1. Go to the **Settings** app on the device.
   2. Search for **Dark theme** and click into it.
   3. Toggle on **Dark theme**.
   4. Reopen the **Woof** app and it will be in **dark theme**.

   |bc31a94207265b08.png|

   This codelab focuses more on the light theme, so before you move forward with the app,
   turn off the dark theme.

   1. Go to the **Settings** app on the device.
   2. Select **Display**.
   3. Toggle off **Dark theme**.

   Compare how the app looked at the beginning of the section versus now. The list items
   and text are more defined, and the color scheme is more visually appealing.

   ====================== ============================ ===========================
   **Without color**      **With color (light theme)** **With color (dark theme)**
   |6d253ae50c63014d.png| |bc31a94207265b08.png||      |bc31a94207265b08.png|
   ====================== ============================ ===========================


Dynamic Color

   Material 3 strongly focuses on user personalization - a new feature in Material 3 is
   Dynamic Color which creates a theme for your app based on the user's wallpaper. This way
   if the user loves green and has a blue phone background, their Woof app will also be
   blue to reflect that. Dynamic theming is only on certain devices that are running
   Android 12 and up.

   A custom theme can be used for apps that have strong branding colors and also needs to
   be implemented for devices that don't support dynamic theming so that your app is still
   themed.

   1. To enable dynamic color, open **Theme.kt** and go to the ``WoofTheme()`` composable
      and set the ``dynamicColor`` parameter to **true**.

   .. code:: prettyprint

      @Composable
      fun WoofTheme(
         darkTheme: Boolean = isSystemInDarkTheme(),
         dynamicColor: Boolean = true,
         content: @Composable () -> Unit
      )

   2. To change the background of a device or an emulator, go to **Settings**, then search
      for **Wallpaper**.
   3. Change the wallpaper to a color or set of colors.
   4. Rerun your app to see the dynamic theme (note that your device or emulator must be
      Android 12+ to see dynamic color), feel free to play around with this with different
      wallpapers!

   |710bd13f6b189dc5.png|

   5. This codelab does focus on custom theming, so disable ``dynamicColor`` before you
      move on.

   .. code:: prettyprint

      @Composable
      fun WoofTheme(
         darkTheme: Boolean = isSystemInDarkTheme(),
         dynamicColor: Boolean = false,
         content: @Composable () -> Unit
      )


5. Add shape
--------------------------------------------------------------------------------

   Applying a shape can change so much about the look and feel of a composable. Shapes
   direct attention, identify components, communicate state, and express brand.

   Many shapes are defined using
   `RoundedCornerShape <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/shape/RoundedCornerShape>`__,
   which describes a rectangle with rounded corners. The number passed in defines how round
   the corners are. If ``RoundedCornerShape(0.dp)`` is used, the rectangle has no rounded
   corners; if ``RoundedCornerShape(50.dp)`` is used, the corners will be fully circular.

   ============================= ======== ========
   0.dp                          25.dp    50.dp
   |Woof list item with shaping| |d0661b773c703f57.png| |78bbef6f504eff53.png|
   ============================= ======== ========

   You can also customize shapes further by adding different rounding percentages on each
   corner. It's pretty fun to play around with shapes!

   +--------------------------------+--------------------------------+--------------------------------+
   | | Top left: 50.dp              | | Top left: 15.dp              | | Top left: 0.dp               |
   | | Bottom left: 25.dp           | | Bottom left: 50.dp           | | Bottom left: 50.dp           |
   | | Top right: 0.dp              | | Top right: 50.dp             | | Top right: 0.dp              |
   | | Bottom right: 15.dp          | | Bottom right: 15.dp          | | Bottom right: 50.dp          |
   +--------------------------------+--------------------------------+--------------------------------+
   | |35e7aa917b0b6d4.png|                      | |5c030ab0f4557b21.png|                      | |56a7b7b62313ef89.png|                      |
   +--------------------------------+--------------------------------+--------------------------------+

   The **Shape.kt** file is used to define shapes of components in Compose. There are three
   types of components: small, medium, and large. In this section, you will modify the
   ``Card`` component, which is defined as ``medium`` size. Components are grouped into
   `shape categories <https://m3.material.io/styles/shape/shape-scale-tokens#b09934f1-1b0f-4ce4-ade6-4a1f138add6c>`__
   based on their size.

   In this section, you will shape the image of the dog into a circle, and modify the shape
   of the list item.


Shape the dog image into a circle

   1. Open the **Shape.kt** file and notice that the small parameter is set to
      ``RoundedCornerShape(50.dp)``. This will be used to shape the image into a circle.

   .. code:: prettyprint

      val Shapes = Shapes(
         small = RoundedCornerShape(50.dp),
      )

   2. Open **MainActivity.kt**. In ``DogIcon()``, add a
      `clip <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).clip(androidx.compose.ui.graphics.Shape)>`__
      attribute to the ``modifier`` of the ``Image``; this will clip the image into a
      shape. Pass in the ``MaterialTheme.shapes.small``.

   .. code:: prettyprint

      import androidx.compose.ui.draw.clip

      @Composable
      fun DogIcon(
         @DrawableRes dogIcon: Int,
         modifier: Modifier = Modifier
      ) {
         Image(
             modifier = modifier
                 .size(dimensionResource(id = R.dimen.image_size))
                 .padding(dimensionResource(id = R.dimen.padding_small))
                 .clip(MaterialTheme.shapes.small),

   When you look at the ``WoofPreview()``, you'll notice that the dog icons are circular!
   However, some photos are cut off on the sides and not showing up as fully circular.

   |1d4d1e5eaaddf71e.png|

   3. To make all the photos circular, add in a
      `ContentScale <https://developer.android.google.cn/reference/kotlin/androidx/glance/layout/ContentScale>`__
      and a
      `Crop <https://developer.android.google.cn/reference/kotlin/androidx/glance/layout/ContentScale#Crop()>`__
      attribute; this crops the image to fit. Note that ``contentScale`` is an attribute of
      ``Image``, and not part of the ``modifier``.

   .. code:: prettyprint

      import androidx.compose.ui.layout.ContentScale

      @Composable
      fun DogIcon(
         @DrawableRes dogIcon: Int,
         modifier: Modifier = Modifier
      ) {
         Image(
             modifier = modifier
                 .size(dimensionResource(id = R.dimen.image_size))
                 .padding(dimensionResource(id = R.dimen.padding_small))
                 .clip(MaterialTheme.shapes.small),
             contentScale = ContentScale.Crop,

   This is the full ``DogIcon()`` Composable.

   .. code:: prettyprint

      @Composable
      fun DogIcon(
          @DrawableRes dogIcon: Int,
          modifier: Modifier = Modifier
      ) {
          Image(
              modifier = modifier
                  .size(dimensionResource(R.dimen.image_size))
                  .padding(dimensionResource(R.dimen.padding_small))
                  .clip(MaterialTheme.shapes.small),
              contentScale = ContentScale.Crop,
              painter = painterResource(dogIcon),

              // Content Description is not needed here - image is decorative, and setting a null content
              // description allows accessibility services to skip this element during navigation.

              contentDescription = null
          )
      }

   Now in ``WoofPreview()``, the icons are circular.

   |fc93106990f5e161.png|


Add a shape to the list item

   In this section, you will add a shape to the list item. The list item is already being
   displayed through a ``Card``. A ``Card`` is a surface that can contain a single
   composable and contains options for decoration. The decoration can be added through the
   border, shape, and more. In this section, you will use the ``Card`` to add a shape to
   the list item.

   |The Woof list item with shape dimensions added to it|

   1. Open the **Shape.kt** file. A ``Card`` is a medium component, so you add the medium
      parameter of the ``Shapes`` object. For this app, the top right and bottom left
      corners of the list item, but not make them fully circular. To achieve that, pass in
      ``16.dp`` to the ``medium`` attribute.

   .. code:: prettyprint

      medium = RoundedCornerShape(bottomStart = 16.dp, topEnd = 16.dp)

   Since a ``Card``, by default, already uses the medium shape, you do not have to
   explicitly set it to the medium shape. Check out the **Preview** and to see the newly
   shaped ``Card``!

   |Woof preview with shaped cards|

   If you go back to the **Theme.kt** file in ``WoofTheme()``, and look at the
   ``MaterialTheme()``, you'll see the ``shapes`` attribute is set to the ``Shapes``
   ``val`` that you just updated.

   .. code:: prettyprint

      MaterialTheme(
         colors = colors,
         typography = Typography,
         shapes = Shapes,
         content = content
      )

   Below is a side-by-side look of the list items before and after shaping. Notice how much
   more visually appealing the app is with shaping added to it.

   ======================= ======================
   **Without shaping**     **With shaping**
   |618b091614c6bc5b.png|  |87d476f7a7f786dd.png|
   ======================= ======================


6. Add typography
--------------------------------------------------------------------------------


The Material Design type scale

   A type scale is a selection of font styles that can be used across an app, ensuring a
   flexible, yet consistent, style. 
   The `Material Design type scale <https://m3.material.io/styles/typography/type-scale-tokens>`__ 
   includes fifteen font styles that are supported by the type system. The naming and grouping have been
   simplified to: display, headline, title, body, and label, with large, medium, and small
   sizes for each. You only need to use these choices if you want to customize your app. If
   you don't know what to set for each type scale category, know that there is a default
   typography scale that you can use.

   |999a161dcd9b0ec4.png|

   The type scale contains reusable categories of text, each with an intended application
   and meaning.


**Display**

   As the largest text on the screen, display styles are reserved for short, important text
   or numerals. They work best on large screens.


**Headline**

   Headlines are best-suited for short, high-emphasis text on smaller screens. These styles
   can be good for marking primary passages of text or important regions of content.


**Title**

   Titles are smaller than headline styles, and should be used for medium-emphasis text
   that remains relatively short.


**Body**

   Body styles are used for longer passages of text in your app.


**Label**

   Label styles are smaller, utilitarian styles, used for things like the text inside
   components or for very small text in the content body, such as captions.


Fonts

   The Android platform provides a variety of fonts, but you may want to customize your app
   with a font not provided by default. Custom fonts can add personality and be used for
   branding.

   In this section, you will add custom fonts called **Abril Fatface**, **Montserrat
   Bold**, and **Montserrat Regular.** You will use the displayLarge and displayMedium
   headlines, and the bodyLarge text from the Material Type system, and add these to the
   text in your app.


Create a font Android Resource Directory.

   Before you add fonts to your app, you will need to add a font directory.

   1. In the project view of Android Studio, right-click on the **res** folder.
   2. Select **New** > **Android Resource Directory**.

   |This image shows navigating the file structure to the Android Resource Directory.|

   1. Name the Directory **font**, set the Resource type as **font**, and click **OK**.

   |This image shows adding a font directory using the New Resource Directory.|

   2. Open your new font resource directory located at **res > font**.


Download custom fonts

   Since you are using fonts that are not provided by the Android platform, you need to
   download the custom fonts.

   1. Go to https://fonts.google.com/.
   2. Search for `Montserrat <https://fonts.google.com/specimen/Montserrat?query=mon>`__
      and click **Download family**.
   3. Unzip the zip file.
   4. Open the downloaded **Montserrat** folder. In the **static** folder, find
      **Montserrat-Bold.ttf** and **Montserrat-Regular.ttf** (**ttf** stands for TrueType
      Font and is the format for font files). Select both fonts and drag them into the font
      resource directory in your project in Android Studio.

   |This image shows the contents of the static folder of Montserrat fonts.|

   5. In your font folder, rename **Montserrat-Bold.ttf** to **montserrat_bold.ttf** and
      rename **Montserrat-Regular.ttf** to **montserrat_regular.ttf**.
   6. Search for `Abril Fatface <https://fonts.google.com/specimen/Abril+Fatface?query=abril>`__ and click
      **Download family**.
   7. Open the downloaded **Abril_Fatface** folder. Select **AbrilFatface-Regular.ttf** and
      drag it into the font resource directory.
   8. In your font folder, rename **Abril_Fatface_Regular.ttf** to
      **abril_fatface_regular.ttf**.

   This is what the font resource directory in your project should look like with the three
   custom font files:

   |This image shows the font files being added to the font folder.|


Initialize fonts

   1. In the project window, open **ui.theme** > **Type.kt**. Initialize the downloaded
      fonts below the import statements and above the ``Typography`` ``val``. First,
      initialize **Abril Fatface** by setting it equal to ``FontFamily`` and passing in
      ``Font`` with the font file ``abril_fatface_regular``.

   .. code:: prettyprint

      import androidx.compose.ui.text.font.Font
      import androidx.compose.ui.text.font.FontFamily
      import com.example.woof.R

      val AbrilFatface = FontFamily(
         Font(R.font.abril_fatface_regular)
      )

   2. Initialize **Montserrat**, underneath **Abril Fatface**, by setting it equal to
      ``FontFamily`` and passing in ``Font`` with the font file ``montserrat_regular``. For
      ``montserrat_bold``, also include ``FontWeight.Bold``. Even though you do pass in the
      bold version of the font file, Compose doesn't know that the file is bold, so you
      need to explicitly link the file to ``FontWeight.Bold``.

   .. code:: prettyprint

      import androidx.compose.ui.text.font.FontWeight

      val AbrilFatface = FontFamily(
         Font(R.font.abril_fatface_regular)
      )

      val Montserrat = FontFamily(
         Font(R.font.montserrat_regular),
         Font(R.font.montserrat_bold, FontWeight.Bold)
      )

   Next, you set the different types of headlines to the fonts you just added. The
   ``Typography`` object has parameters for 13 different typefaces discussed above. You can
   define as many as you need. In this app, we will set ``displayLarge``,
   ``displayMedium``, and ``bodyLarge``. In the next part of this app, you use
   ``labelSmall``, so you will add it here.

   Below is a table that shows you the font, weight and size of each headline you are
   adding.

   |8ea685b3871d5ffc.png|

   3. For the ``displayLarge`` attribute, set it equal to ``TextStyle``, and fill in the
      ``fontFamily``, ``fontWeight``, and ``fontSize`` with the information from the table
      above. This means that all the text set to ``displayLarge`` will have **Abril
      Fatface** as the font, with a normal font weight, and a ``fontSize`` of ``36.sp``.

   Repeat this process for ``displayMedium``, ``labelSmall``, and ``bodyLarge``.

   .. code:: prettyprint

      import androidx.compose.ui.text.TextStyle
      import androidx.compose.ui.unit.sp


      val Typography = Typography(
         displayLarge = TextStyle(
             fontFamily = AbrilFatface,
             fontWeight = FontWeight.Normal,
             fontSize = 36.sp
         ),
         displayMedium = TextStyle(
             fontFamily = Montserrat,
             fontWeight = FontWeight.Bold,
             fontSize = 20.sp
         ),
         labelSmall = TextStyle(
             fontFamily = Montserrat,
             fontWeight = FontWeight.Bold,
             fontSize = 14.sp
         ),
         bodyLarge = TextStyle(
             fontFamily = Montserrat,
             fontWeight = FontWeight.Normal,
             fontSize = 14.sp
         )
      )

   If you go to the **Theme.kt** file in ``WoofTheme()`` and look at the
   ``MaterialTheme()``, the ``typography`` parameter is equal to the ``Typography val``
   that you just updated.

   .. code:: prettyprint

      MaterialTheme(
         colors = colors,
         typography = Typography,
         shapes = Shapes,
         content = content
      )


Add typography to app text

   Now you'll add the headline types to each instance of text in the app.

   1. Add ``displayMedium`` as the style for the ``dogName`` because it is a short,
      important piece of information. Add ``bodyLarge`` as the style for the ``dogAge``
      because it works well with smaller text sizes.

   .. code:: prettyprint

      @Composable
      fun DogInformation(
         @StringRes dogName: Int,
         dogAge: Int,
         modifier: Modifier = Modifier
      ) {
         Column(modifier = modifier) {
             Text(
                 text = stringResource(dogName),
                 style = MaterialTheme.typography.displayMedium,
                 modifier = Modifier.padding(top = dimensionResource(id = R.dimen.padding_small))
             )
             Text(
                 text = stringResource(R.string.years_old, dogAge),
                 style = MaterialTheme.typography.bodyLarge
             )
         }
      }

   2. Now in the ``WoofPreview()``, the dog's name displays the bold **Montserrat** font in
      ``20.sp``, and the dog's age displays the normal **Montserrat** font in ``14.sp``.

   |Woof preview with typography added|

   Below is a side-by-side look at the list items before and after adding typography.
   Notice the font difference between the dog name and the dog age.

   ====================== =====================
   **Without typography** **With typography**
   |be21970ae4c0e847.png| |165489157cee3532.png|
   ====================== =====================


7. Add a top bar
--------------------------------------------------------------------------------

   A `Scaffold <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Scaffold(androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,androidx.compose.material3.FabPosition,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.foundation.layout.WindowInsets,kotlin.Function1)>`__
   is a layout that provides slots for various components and screen elements, such as an
   ``Image``, ``Row``, or ``Column``. A ``Scaffold`` also provides a slot for a
   `TopAppBar <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#TopAppBar(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function1,androidx.compose.foundation.layout.WindowInsets,androidx.compose.material3.TopAppBarColors,androidx.compose.material3.TopAppBarScrollBehavior)>`__,
   which you will use in this section.

   A ``TopAppBar`` can be used for many purposes, but in this case, you will use it for
   branding and to give your app personality. There are four different types of
   ``TopAppBar``: center, small, medium and large. In this codelab you will implement a
   center top app bar. You will create a composable that looks like the screenshot below,
   and slot it into the ``topBar`` section of a ``Scaffold``.

   |172417c7b64372f7.png|

   For this app, our top bar consists of a ``Row`` with an image of a logo and text of the
   app title. The logo features a cute gradient paw and the title of the app!

   |736f411f5067e0b5.png|


Add image and text to the top bar

   1. In **MainActivity.kt**, create a composable called ``WoofTopAppBar()`` with an
      optional ``modifier``.

   .. code:: prettyprint

      @Composable
      fun WoofTopAppBar(modifier: Modifier = Modifier) {
        
      }

   2. `Scaffold <https://developer.android.google.cn/jetpack/compose/layouts/material#scaffold>`__
      supports the ``contentWindowInsets`` parameter which can help to specify insets for
      the scaffold content.
      `WindowInsets <https://developer.android.google.cn/reference/android/view/WindowInsets>`__
      are the parts of your screen where your app can intersect with the system UI, these
      ones are to be passed to the content slot via the ``PaddingValues`` parameters. Read
      more `here <https://developer.android.google.cn/develop/ui/views/layout/insets>`__.

   The ``contentWindowInsets`` value is passed to the ``LazyColumn`` as the
   ``contentPadding``.

   .. code:: prettyprint

      @Composable
      fun WoofApp() {
          Scaffold { it ->
              LazyColumn(contentPadding = it) {
                  items(dogs) {
                      DogItem(
                          dog = it,
                          modifier = Modifier.padding(dimensionResource(R.dimen.padding_small))
                      )
                  }
              }
          }
      }

   3. Within the ``Scaffold``, add a ``topBar`` attribute and set it to
      ``WoofTopAppBar()``.

   .. code:: prettyprint

      Scaffold(
         topBar = {
             WoofTopAppBar()
         }
      )

   Below is how the ``WoofApp()`` composable will look:

   .. code:: prettyprint

      @Composable
      fun WoofApp() {
          Scaffold(
              topBar = {
                  WoofTopAppBar()
              }
          ) { it ->
              LazyColumn(contentPadding = it) {
                  items(dogs) {
                      DogItem(
                          dog = it,
                          modifier = Modifier.padding(dimensionResource(R.dimen.padding_small))
                      )
                  }
              }
          }
      }

   Nothing has changed in ``WoofPreview()`` because there is nothing in the
   ``WoofTopAppBar()``. Let's change that!

   |Woof Preview with typography|

   4. Within the ``WoofTopAppBar() Composable``, add in a ``CenterAlignedTopAppBar()`` and
      set the modifier parameter to the modifier passed into ``WoofTopAppBar()``.

   .. code:: prettyprint

      import androidx.compose.material3.CenterAlignedTopAppBar

      @Composable
      fun WoofTopAppBar(modifier: Modifier = Modifier) {
         CenterAlignedTopAppBar(
             modifier = modifier
         )
      }

   5. For the title parameter, pass in a ``Row`` which will hold the ``Image`` and ``Text``
      of the ``CenterAlignedTopAppBar``.

   .. code:: prettyprint

      @Composable
      fun WoofTopAppBar(modifier: Modifier = Modifier){
         CenterAlignedTopAppBar(
             title = {
                 Row() {
                    
                 }
             },
             modifier = modifier
         )
      }

   6. Add the logo ``Image`` into the ``Row``.

   -  Set the image size in the ``modifier`` as the ``image_size`` in the ``dimens.xml``
      file and the padding as ``padding_small`` from the ``dimens.xml`` file.
   -  Use ``painter`` to set the ``Image`` as ``ic_woof_logo`` from the drawable folder.
   -  Set the ``contentDescription`` as **null**. In this situation, the app logo does not
      add any semantic information for users with impaired vision, so we do not have to add
      a content description.

   .. code:: prettyprint

      Row() {
         Image(
             modifier = Modifier
                 .size(dimensionResource(id = R.dimen.image_size))
                 .padding(dimensionResource(id = R.dimen.padding_small)),
             painter = painterResource(R.drawable.ic_woof_logo),
             contentDescription = null
         )
      }

   7. Next, add a ``Text`` Composable inside the ``Row`` after the ``Image.``

   -  Use *``stringResource()``* to set it to the value of ``app_name``. This sets the text
      to the name of the app, which is stored in ``strings.xml``.
   -  Set the style of the text to ``displayLarge`` since the app name is short and
      important text.

   .. code:: prettyprint

      Text(
         text = stringResource(R.string.app_name),
         style = MaterialTheme.typography.displayLarge
      )

   |Woof Preview with top app bar|

   This is what shows up in ``WoofPreview()``, it looks a little off because the icon and
   text are not vertically aligned.

   8. To fix that, add in a ``verticalAlignment`` value-parameter to the ``Row`` and set it
      equal to ``Alignment.CenterVertically``.

   .. code:: prettyprint

      import androidx.compose.ui.Alignment

      Row(
         verticalAlignment = Alignment.CenterVertically
      )

   |Woof Preview with vertically centered top app bar|

   That looks a lot better!

   This is the full ``WoofTopAppBar()`` Composable:

   .. code:: prettyprint

      @Composable
      fun WoofTopAppBar(modifier: Modifier = Modifier) {
         CenterAlignedTopAppBar(
             title = {
                 Row(
                     verticalAlignment = Alignment.CenterVertically
                 ) {
                     Image(
                         modifier = Modifier
                             .size(dimensionResource(id = R.dimen.image_size))
                             .padding(dimensionResource(id = R.dimen.padding_small)),
                         painter = painterResource(R.drawable.ic_woof_logo),

                         contentDescription = null
                     )
                     Text(
                         text = stringResource(R.string.app_name),
                         style = MaterialTheme.typography.displayLarge
                     )
                 }
             },
             modifier = modifier
         )
      }

   Run the app and admire how beautifully the ``TopAppBar`` ties the app together.

   ======================= ======================
   **Without top app bar** **With top app bar**
   |70225afc97adee46.png|  |8de41607e8ff2c79.png|
   ======================= ======================

   Now, check out the final app in dark theme!

   |2776e6a45cf3434a.png|

   Congratulations, you made it to the end of the codelab!


8. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof.git
      $ cd basic-android-kotlin-compose-training-woof
      $ git checkout material

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof/archive/refs/heads/material.zip>`__

   **Note:** The solution code is in the ``material`` branch of the downloaded repository.

   If you want to see the solution code, `view it on GitHub <https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof/tree/material>`__.


9. Conclusion
--------------------------------------------------------------------------------

   You just created your first Material app! You created a custom color palette for both
   light and dark themes, created shapes for different components, downloaded fonts and
   added them to the app, and created a beautiful top bar to tie it all together. Take the
   skills you learned in this codelab and change colors, shapes, and typography to make
   apps completely your own!


Summary

   -  Material Theming allows you to use Material Design in your app, with guidance on
      customizing colors, typography, and shapes.
   -  The **Theme.kt** file is where the theme is defined, through a composable named
      ``[your app name]+Theme()``â€”``WoofTheme()`` in the case of this app. Within this
      function, the ``MaterialTheme`` object sets the ``color``, ``typography``,
      ``shapes``, and ``content`` of the app.
   -  **Color.kt** is where you list the colors you use in the app. Then in **Theme.kt**,
      you assign the colors in ``LightColorPalette`` and ``DarkColorPalette`` to specific
      slots. Not all slots need to be assigned.
   -  Your app can opt-in to `Force Dark <https://developer.android.google.cn/guide/topics/ui/look-and-feel/darktheme#force-dark>`__,
      which means the system will implement a dark theme for you. However, it is a better
      experience for your users if you implement the dark theme so that you maintain full
      control over the app theme.
   -  **Shape.kt** is where you define your app shapes. There are three shape sizes (small,
      medium, large), and you can specify how the corners are rounded.
   -  Shapes direct attention, identify components, communicate state, and express brand.
   -  **Type.kt** is where you initialize your fonts and assign ``fontFamily``,
      ``fontWeight``, and ``fontSize`` for the Material Design type scale.
   -  The `Material Design type scale <https://m3.material.io/styles/typography/type-scale-tokens>`__ includes a
      range of contrasting styles that support the needs of your app and its content. The
      type scale is a combination of 15 styles that are supported by the type system.


10. Learn more
--------------------------------------------------------------------------------

   -  `Material Design <https://m3.material.io/>`__
   -  `Typography <https://m3.material.io/styles/typography/overview>`__
   -  `Shape <https://m3.material.io/styles/shape/overview>`__
   -  `Color <https://m3.material.io/styles/color/overview>`__
   -  `Modifier parameters <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/compose/docs/compose-api-guidelines.md#elements-accept-and-respect-a-modifier-parameter>`__
   -  `Force Dark <https://developer.android.google.cn/guide/topics/ui/look-and-feel/darktheme#force-dark>`__
   -  `Accessibility Contrast Standards <https://webaim.org/resources/contrastchecker/>`__
   -  `Clip <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).clip(androidx.compose.ui.graphics.Shape)>`__
   -  `ContentScale <https://developer.android.google.cn/reference/kotlin/androidx/glance/layout/ContentScale>`__
   -  `Crop <https://developer.android.google.cn/reference/kotlin/androidx/glance/layout/ContentScale#Crop()>`__
   -  `Card <https://material.io/components/cards>`__
   -  `Scaffold <https://developer.android.google.cn/jetpack/compose/layouts/material#scaffold>`__

.. |92eca92f64b029cf.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/92eca92f64b029cf.png
.. |This image has the light color scheme for the Woof app.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/d6b2e7b613386dfe.png
.. |This image has the dark color scheme for the Woof app.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/5087303587b44563.png
.. |883428064ccbc9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/883428064ccbc9.png
.. |8ea685b3871d5ffc.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/8ea685b3871d5ffc.png
.. |6d253ae50c63014d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/6d253ae50c63014d.png
.. |This shows the hexadecimal numbers that is used to create colors.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/e0349c33dd6fbafe.png
.. |2753d8cdd396c449.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/2753d8cdd396c449.png
.. |This shows four core colors in the Material Theme Builder| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/c58fc807f4378d4d.png
.. |This is the HCT Color Picker to choose a custom color in the Material Theme Builder.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/62c87ab4b476cf92.png
.. |This shows the HCT Color picker set to green| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/ead81a6bf86d2170.png
.. |This shows the Material Theme Builder's apps reacting to the change in color from the HCT color picker.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/1e3f080002e0174.png
.. |Material Theme Builder Light Scheme| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/d6b2e7b613386dfe.png
.. |Dark Scheme generated by Material Theme Builder| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/5087303587b44563.png
.. |b48b3fa2ecec9b86.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/b48b3fa2ecec9b86.png
.. |6d49372a1ef49bc7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/6d49372a1ef49bc7.png
.. |Shows how to properly format adding values from the dimension resource| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/550d49d70146013b.png
.. |c54f870f121fe02.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/c54f870f121fe02.png
.. |92e2efb9dfd4ca6d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/92e2efb9dfd4ca6d.png
.. |b444fd0900815b2a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/b444fd0900815b2a.png
.. |bc31a94207265b08.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/bc31a94207265b08.png
.. |3d3d99c8b3643cf7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/3d3d99c8b3643cf7.png
.. |710bd13f6b189dc5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/710bd13f6b189dc5.png
.. |Woof list item with shaping| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/7aa47654fba1869a.png
.. |d0661b773c703f57.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/d0661b773c703f57.png
.. |78bbef6f504eff53.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/78bbef6f504eff53.png
.. |35e7aa917b0b6d4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/35e7aa917b0b6d4.png
.. |5c030ab0f4557b21.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/5c030ab0f4557b21.png
.. |56a7b7b62313ef89.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/56a7b7b62313ef89.png
.. |1d4d1e5eaaddf71e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/1d4d1e5eaaddf71e.png
.. |fc93106990f5e161.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/fc93106990f5e161.png
.. |The Woof list item with shape dimensions added to it| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/244cf8727b603de9.png
.. |Woof preview with shaped cards| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/ff657577b77964ae.png
.. |618b091614c6bc5b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/618b091614c6bc5b.png
.. |87d476f7a7f786dd.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/87d476f7a7f786dd.png
.. |999a161dcd9b0ec4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/999a161dcd9b0ec4.png
.. |This image shows navigating the file structure to the Android Resource Directory.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/8ea7753261102f61.png
.. |This image shows adding a font directory using the New Resource Directory.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/d8b11c1535ac8372.png
.. |This image shows the contents of the static folder of Montserrat fonts.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/195ecec4cb8bd27e.png
.. |This image shows the font files being added to the font folder.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/90bc5dc3a03699c8.png
.. |Woof preview with typography added| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/c26c588948ec3253.png
.. |be21970ae4c0e847.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/be21970ae4c0e847.png
.. |165489157cee3532.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/165489157cee3532.png
.. |172417c7b64372f7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/172417c7b64372f7.png
.. |736f411f5067e0b5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/736f411f5067e0b5.png
.. |Woof Preview with typography| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/b15d5423bc726a5e.png
.. |Woof Preview with top app bar| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/85b82dfc6c8fc964.png
.. |Woof Preview with vertically centered top app bar| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/9cbc3aa6a315c938.png
.. |70225afc97adee46.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/70225afc97adee46.png
.. |8de41607e8ff2c79.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/8de41607e8ff2c79.png
.. |2776e6a45cf3434a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-material-theming/img/2776e6a45cf3434a.png


ğŸš€ Simple animation with Jetpack Compose
========================================

   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-woof-animation


1. Before you begin
--------------------------------------------------------------------------------

   In this codelab, you learn how to add a simple animation to your Android app. Animations
   can make your app more interactive, interesting, and easier for users to interpret.
   Animating individual updates on a screen full of information can help the user see what
   changed.

   There are many types of animations that can be used in an app's user interface. Items
   can fade in as they appear and fade out as they disappear, they can move on or off of
   the screen, or they can transform in interesting ways. This helps make the app's UI
   expressive and easy to use.

   Animations can also add a polished look to your app, which gives it an elegant look and
   feel, and also helps the user at the same time.


Prerequisites

   -  Knowledge of Kotlin, including functions, lambdas, and stateless composables.
   -  Basic knowledge of how to build layouts in Jetpack Compose.
   -  Basic knowledge of how to create lists in Jetpack Compose.
   -  Basic knowledge of Material Design.


What you'll learn

   -  How to build a simple spring animation with Jetpack Compose.


What you'll build

   -  You will build on the **Woof** app from the 
      `Material Theming with Jetpack Compose <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-material-theming#0>`__
      codelab, and add a simple animation to acknowledge the user's action.


What you'll need

   -  The latest stable version of Android Studio.
   -  Internet connection to download starter code.


2. App Overview
--------------------------------------------------------------------------------

   In the `Material Theming with Jetpack
   Compose <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-material-theming#0>`__
   codelab, you created the **Woof** app using Material Design which displays a list of
   dogs and their information.

   |36c6cabd93421a92.png|

   In this codelab, you will add animation to the **Woof** app. You'll add hobby
   information which will display when you expand the list item. You'll also add a spring
   animation to animate the list item being expanded.

   |c0d0a52463332875.gif|


**Get the starter code**

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof/archive/refs/heads/material.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof.git
      $ cd basic-android-kotlin-compose-training-woof
      $ git checkout material

   **Note:** The starter code is in the ``material`` branch of the downloaded repository.

   You can browse the code in the
   `Woof app <https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof/tree/material>`__
   GitHub repository.


3. Add expand more icon
--------------------------------------------------------------------------------

   In this section you will add the **Expand More** |30c384f00846e69b.png| 
   and **Expand Less** |f88173321938c003.png| icons to your app.

   |def59d71015c0fbe.png|


Icons

   Icons are symbols that can help users understand a user interface by visually
   communicating the intended function. They often take inspiration from objects in the
   physical world that a user is expected to have experienced. Icon design often reduces
   the level of detail to the minimum required to be familiar to a user. For example, a
   pencil in the physical world is used for writing, so its icon counterpart usually
   indicates **create** or **edit**.

   |Black and white pencil icon| 

   |Pencil on notebook| Photo by `Angelina Litvin <https://unsplash.com/@linalitvina?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText>`__ 
   on `Unsplash <https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText>`__

   Material Design provides a `number of icons <https://material.io/resources/icons/?style=baseline>`__, 
   arranged in common categories, for most of your needs.

   |Material Icon library|


Add Gradle dependency

   Add the ``material-icons-extended`` library dependency to your project. You will use the
   ``Icons.Filled.ExpandLess`` |30c384f00846e69b.png| and ``Icons.Filled.ExpandMore`` |f88173321938c003.png| icons from
   this library.

   **Note on Gradle dependency:** To add a dependency to your project, specify a dependency
   configuration such as implementation in the ``dependencies`` block of your module's
   ``build.gradle.kts`` file. When you build your app, the build system compiles the
   library module and packages the resulting compiled contents in the app.

   You will learn more about adding libraries to your app in later units.

   1. In the **Project** pane, open **Gradle Scripts > build.gradle.kts (Module :app)**.
   2. Scroll to the end of the ``build.gradle.kts (Module :app)`` file. In the
      ``dependencies{}`` block, add the following line:

   .. code:: prettyprint

      implementation("androidx.compose.material:material-icons-extended")

   **Tip:** Whenever you modify the Gradle files, Android Studio may have to import or
   update libraries and run some background tasks. Android Studio displays a pop-up that
   asks you to sync your project. Click **Sync Now**.

   |772f8f274e7d3f44.png|


Add the icon composable

   Add a function to display the **Expand More** icon from the Material icons library and
   use it as a button.

   1. In ``MainActivity.kt``, after the ``DogItem()`` function, create a new composable
      function called ``DogItemButton()``.
   2. Pass in a ``Boolean`` for the expanded state, a lambda expression for the button
      onClick handler, and an optional ``Modifier`` as follows:

   .. code:: prettyprint

      @Composable
      private fun DogItemButton(
         expanded: Boolean,
         onClick: () -> Unit,
         modifier: Modifier = Modifier
      ) {
       
      }

   3. Inside the ``DogItemButton()`` function, add an
      `IconButton() <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/package-summary#IconButton(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function0)>`__
      composable that accepts an ``onClick`` named parameter, a lambda using trailing
      lambda syntax, that is invoked when this icon is pressed and an optional
      ``modifier``. Set the ``IconButton's onClick`` and ``modifier value parameters``
      equal to the ones passed in to ``DogItemButton``.

   .. code:: prettyprint

      @Composable
      private fun DogItemButton(
         expanded: Boolean,
         onClick: () -> Unit,
         modifier: Modifier = Modifier
      ){
         IconButton(
             onClick = onClick,
             modifier = modifier
         ) {

         }
      }

   4. Inside the ``IconButton()`` lambda block, add in an
      `Icon <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/icons/Icons>`__
      composable and set the ``imageVector value-parameter`` to
      ``Icons.Filled.ExpandMore``. This is what will display at the end of the list item
      |f88173321938c003.png|. Android Studio shows you a warning for the ``Icon()`` composable parameters
      that you will fix in the next step.

   .. code:: prettyprint

      import androidx.compose.material.icons.filled.ExpandMore
      import androidx.compose.material.icons.Icons
      import androidx.compose.material3.Icon
      import androidx.compose.material3.IconButton

      IconButton(
         onClick = onClick,
         modifier = modifier
      ) {
         Icon(
             imageVector = Icons.Filled.ExpandMore
         )
      }

   5. Add the value parameter ``tint``, and set the color of the icon to
      ``MaterialTheme.colorScheme.secondary``. Add the named parameter
      ``contentDescription``, and set it to the string resource
      ``R.string.expand_button_content_description``.

   .. code:: prettyprint

      IconButton(
         onClick = onClick,
         modifier = modifier
      ){
         Icon(
             imageVector = Icons.Filled.ExpandMore,
             contentDescription = stringResource(R.string.expand_button_content_description),
             tint = MaterialTheme.colorScheme.secondary
         )
      }


Display the icon

   Display the ``DogItemButton()`` composable by adding it to the layout.

   1. At the beginning of ``DogItem()``, add a ``var`` to save the expanded state of the
      list item. Set the initial value to ``false``.

   .. code:: prettyprint

      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.mutableStateOf
      import androidx.compose.runtime.remember
      import androidx.compose.runtime.setValue

      var expanded by remember { mutableStateOf(false) }

   **Refresher on remember() and mutableStateOf():**

   Use the ``mutableStateOf()`` function so Compose observes any changes to the state
   value, and triggers a recomposition to update the UI. Wrap the ``mutableStateOf()``
   function call with the ``remember()`` function to store the value in the Composition
   during initial composition, and the stored value is returned during recomposition.

   2. Display the icon button within the list item. In the ``DogItem()`` composable, at the
      end of the ``Row`` block, after the call to ``DogInformation()``, add
      ``DogItemButton()``. Pass in the ``expanded`` state and an empty lambda for the
      callback. You will define the ``onClick`` action in a later step.

   .. code:: prettyprint

      Row(
         modifier = Modifier
             .fillMaxWidth()
             .padding(dimensionResource(R.dimen.padding_small))
      ) {
         DogIcon(dog.imageResourceId)
         DogInformation(dog.name, dog.age)
         DogItemButton(
             expanded = expanded,
             onClick = { /*TODO*/ }
         )
      }

   3. Check out ``WoofPreview()`` in the **Design** pane.

   |5bbf09cd2828b6.png|

   Notice the expand more button is not aligned to the end of the list item. You will fix
   that in the next step.


Align the expand more button

   To align the expand more button to the end of the list item, you need to add a spacer in
   the layout with the
   `Modifier.weight() <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/RowScope#(androidx.compose.ui.Modifier).weight(kotlin.Float,kotlin.Boolean)>`__
   attribute.

   **Note:**
   `Modifier.weight() <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/RowScope#(androidx.compose.ui.Modifier).weight(kotlin.Float,kotlin.Boolean)>`__
   sets the UI element's width/height proportionally to the element's weight, relative to
   its weighted siblings (other child elements in the row or column).

   Example: Consider three child elements in a row with weights ``1f``, ``1f``, and ``2f``.
   All child elements have assigned weights in this case. The available space for the row
   is divided proportionally to the specified weight value, with more available space going
   to children with higher weight values. The child elements will distribute the weight as
   shown below:

   |197842fd06abf239.png|

   In the above row, the first child composable has Â¼ of the row's width, the second also
   has Â¼ of the row's width, and the third has Â½ of the row's width.

   If the children don't have assigned weights, (weight is an optional parameter), then the
   child composable's height/width would default to wrap content (wrapping the contents of
   what's inside the UI element).

   **Note on Float values:** Float values in Kotlin are decimal numbers, represented with
   an ``f`` or ``F`` at the end of the number.

   In the **Woof** app, each list item row contains a dog image, dog information, and an
   expand more button. You will add a ``Spacer`` composable before the expand more button
   with weight ``1f`` to properly align the button icon. Since the spacer is the only
   weighted child element in the row, it will fill the space remaining in the row after
   measuring the other unweighted child elements' width.

   |733f6d9ef2939ab5.png|


Add the spacer to the list item row

   1. In ``DogItem()``, between ``DogInformation()`` and ``DogItemButton()``, add a
      ``Spacer``. Pass in a ``Modifier`` with ``weight(1f)``. The
      `Modifier.weight() <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/RowScope#(androidx.compose.ui.Modifier).weight(kotlin.Float,kotlin.Boolean)>`__
      causes the spacer to fill the space remaining in the row.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Spacer

      Row(
         modifier = Modifier
             .fillMaxWidth()
             .padding(dimensionResource(R.dimen.padding_small))
      ) {
         DogIcon(dog.imageResourceId)
         DogInformation(dog.name, dog.age)
         Spacer(modifier = Modifier.weight(1f))
         DogItemButton(
             expanded = expanded,
             onClick = { /*TODO*/ }
         )
      }

   2. Check out ``WoofPreview()`` in the **Design** pane. Notice that the expand more
      button is now aligned to the end of the list item.

   |8df42b9d85a5dbaa.png|


4. Add Composable to display hobby
--------------------------------------------------------------------------------

   In this task, you'll add ``Text`` composables to display the dog's hobby information.

   |bba8146c6332cc37.png|

   1. Create a new composable function called ``DogHobby()`` that takes in a dog's hobby
      string resource ID and an optional ``Modifier``.

   .. code:: prettyprint

      @Composable
      fun DogHobby(
         @StringRes dogHobby: Int,
         modifier: Modifier = Modifier
      ) {
      }

   2. Inside the ``DogHobby()`` function, create a ``Column`` and pass in the modifier
      passed into ``DogHobby()``.

   .. code:: prettyprint

      @Composable
      fun DogHobby(
         @StringRes dogHobby: Int,
         modifier: Modifier = Modifier
      ){
         Column(
             modifier = modifier
         ) { 

         }
      }

   3. Inside the ``Column`` block, add two ``Text`` composables â€“ one to display the
      **About** text above the hobby information, and another to display the hobby
      information.

   Set the first one's ``text`` to the ``about`` from the **strings.xml** file and set the
   ``style`` as ``labelSmall``. Set the second one's ``text`` to ``dogHobby`` which is
   passed in and set the ``style`` to ``bodyLarge``.

   .. code:: prettyprint

      Column(
         modifier = modifier
      ) {
         Text(
             text = stringResource(R.string.about),
             style = MaterialTheme.typography.labelSmall
         )
         Text(
             text = stringResource(dogHobby),
             style = MaterialTheme.typography.bodyLarge
         )
      }

   4. In ``DogItem()``, the ``DogHobby()`` composable will go below the ``Row`` that
      contains the ``DogIcon()``, ``DogInformation()``, ``Spacer()`` and
      ``DogItemButton()``. To do this, wrap the ``Row`` with a ``Column`` so that the hobby
      can be added below the ``Row``.

   .. code:: prettyprint

      Column() {
         Row(
             modifier = Modifier
                 .fillMaxWidth()
                 .padding(dimensionResource(R.dimen.padding_small))
         ) {
             DogIcon(dog.imageResourceId)
             DogInformation(dog.name, dog.age)
             Spacer(modifier = Modifier.weight(1f))
             DogItemButton(
                 expanded = expanded,
                 onClick = { /*TODO*/ }
             )
         }
      }

   5. Add ``DogHobby()`` after the ``Row`` as a second child of the ``Column``. Pass in
      ``dog.hobbies`` which contains the unique hobby of the dog passed in and a
      ``modifier`` with the padding for the ``DogHobby()`` composable.

   .. code:: prettyprint

      Column() {
         Row() {
            ...
         }
         DogHobby(
             dog.hobbies,
             modifier = Modifier.padding(
                 start = dimensionResource(R.dimen.padding_medium),
                 top = dimensionResource(R.dimen.padding_small),
                 end = dimensionResource(R.dimen.padding_medium),
                 bottom = dimensionResource(R.dimen.padding_medium)
             )
         )
      }

   **Note on dog hobbies:** Dog hobby information for all the dogs is already provided for
   you as part of the starter code. To see this in your code, open ``data/Dog.kt`` file,
   observe the ``dogs`` list prefilled with the dogs information.

   The complete ``DogItem()`` function should look like this:

   .. code:: prettyprint

      @Composable
      fun DogItem(
         dog: Dog,
         modifier: Modifier = Modifier
      ) {
         var expanded by remember { mutableStateOf(false) }
         Card(
             modifier = modifier
         ) {
             Column() {
                 Row(
                     modifier = Modifier
                         .fillMaxWidth()
                         .padding(dimensionResource(R.dimen.padding_small))
                 ) {
                     DogIcon(dog.imageResourceId)
                     DogInformation(dog.name, dog.age)
                     Spacer(Modifier.weight(1f))
                     DogItemButton(
                         expanded = expanded,
                         onClick = { /*TODO*/ },
                     )
                 }
                 DogHobby(
                     dog.hobbies, 
                     modifier = Modifier.padding(
                         start = dimensionResource(R.dimen.padding_medium),
                         top = dimensionResource(R.dimen.padding_small),
                         end = dimensionResource(R.dimen.padding_medium),
                         bottom = dimensionResource(R.dimen.padding_medium)
                     )
                 )
             }
         }
      }

   6. Check out ``WoofPreview()`` in the **Design** pane. Notice the dog's hobby displays.

   |Woof Preview with expanded list items|


5. Show or hide the hobby on button click
--------------------------------------------------------------------------------

   Your app has an **Expand More** button for every list item, but it doesn't do anything
   yet! In this section, you will add the option to hide or reveal the hobby information
   when the user clicks the expand more button.

   1. In the ``DogItem()`` composable function, in the ``DogItemButton()`` function call,
      define the ``onClick()`` lambda expression, change the ``expanded`` boolean state
      value to ``true`` when the button is clicked, and change it back to ``false`` if the
      button is clicked again.

   .. code:: prettyprint

      DogItemButton(
         expanded = expanded,
         onClick = { expanded = !expanded }
      )

   **Note:** The logical NOT operator ( ! ) returns the negated value of the ``Boolean``
   expression.

   For example, if ``expanded`` is ``true``, then ``!expanded`` evaluates to ``false``.

   2. In the ``DogItem()`` function, wrap the ``DogHobby()`` function call with an ``if``
      check on the ``expanded`` boolean.

   .. code:: prettyprint

      @Composable
      fun DogItem(
         dog: Dog,
         modifier: Modifier = Modifier
      ) {
         var expanded by remember { mutableStateOf(false) }
         Card(
             ...
         ) {
             Column(
                 ...
             ) {
                 Row(
                     ...
                 ) {
                     ...
                 }
                 if (expanded) {
                     DogHobby(
                         dog.hobbies, modifier = Modifier.padding(
                             start = dimensionResource(R.dimen.padding_medium),
                             top = dimensionResource(R.dimen.padding_small),
                             end = dimensionResource(R.dimen.padding_medium),
                             bottom = dimensionResource(R.dimen.padding_medium)
                         )
                     )
                 }
             }
         }
      }

   Now, the dog's hobby information only displays if the value of ``expanded`` is ``true``.

   3. The preview can show you what the UI looks like, and you can also interact with it.
      To interact with the UI preview, hover above the WoofPreview text in the **Design**
      Pane, then click the **Interactive Mode** button |42379dbe94a7a497.png| in the
      top-right corner of the **Design** pane. This starts the preview in interactive mode.

   |74e1624d68fb4131.png|

   4. Interact with the preview by clicking the expand more button. Notice the dog's hobby
      information is hidden and revealed when you click the expand more button.

   |Animation of Woof list items expanding and contracting|

   **Note:** To stop the interactive mode, click **Stop Interactive Mode** on the top-left
   corner of the preview pane.

   |60829fbffe4d8302.png|

   Notice that the expand more button icon remains the same when the list item is expanded.
   For a better user experience, you'll change the icon so that ``ExpandMore`` displays the
   downward arrow |c761ef298c2aea5a.png|, and ``ExpandLess`` displays the upward arrow
   |b380f933be0b6ff4.png|.

   5. In the ``DogItemButton()`` function, add an ``if`` statement that updates the
      ``imageVector`` value based on the ``expanded`` state as follows:

   .. code:: prettyprint

      import androidx.compose.material.icons.filled.ExpandLess


      @Composable
      private fun DogItemButton(
         ...
      ) {
         IconButton(onClick = onClick) {
             Icon(
                 imageVector = if (expanded) Icons.Filled.ExpandLess else Icons.Filled.ExpandMore,
                 ...
             )
         }
      }

   Notice how you wrote ``if-else`` in the previous code snippet.

   ``if (expanded) Icons.Filled.ExpandLess else Icons.Filled.ExpandMore``

   This is the same as using the curly braces { } in the following code:

   ``if (expanded) {``

   .. code:: prettyprint

      `Icons.Filled.ExpandLess`

   ``} else {``

   .. code:: prettyprint

      `Icons.Filled.ExpandMore`

   ``}``

   The curly braces are optional if there is a single line of code for the ``if``-``else``
   statement.

   6. Run the app on a device or emulator, or use the interactive mode in the preview
      again. Notice the icon alternates between the ``ExpandMore`` |c761ef298c2aea5a.png| and the
      ``ExpandLess`` |b380f933be0b6ff4.png| icons.

   |de5dc4a953f11e65.gif|

   **Note on interactive mode**: Interactive mode allows you to interact with a preview the
   same way you would interact on a device. However, the preview mode is not a substitute
   for running your app on a device for testing.

   Good job updating the icon!

   When you expanded the list item, did you notice the abrupt height change? The abrupt
   height change doesn't look like a polished app. To resolve this issue, you will next add
   an animation to your app.


6. Add animation
--------------------------------------------------------------------------------

   Animations can add visual cues that notify users about what's going on in your app. They
   are especially useful when the UI changes state, such as when new content loads or new
   actions become available. Animations can also add a polished look to your app.

   In this section you will add a spring animation to animate the change in height of the
   list item.


Spring Animation

   `Spring
   animation <https://developer.android.google.cn/jetpack/compose/animation#spring>`__ is a
   physics-based animation driven by a **spring force**. With a spring animation, the value
   and velocity of movement are calculated based on the spring force that is applied.

   For example, if you drag an app icon around the screen and then release it by lifting
   your finger, the icon jumps back to its original location by an invisible force.

   The following animation demonstrates the spring effect. Once the finger is released from
   the icon, the icon jumps back, mimicking a spring.

   |Spring release effect|

   *Spring effect*

   Spring force is guided by the following two properties:

   -  **Damping ratio**: The bounciness of the spring.
   -  **Stiffness level**: The stiffness of the spring, that is, how fast the spring moves
      toward the end.

   Below are some examples of animations with 
   `different damping ratios and stiffness levels <https://developer.android.google.cn/reference/kotlin/androidx/compose/animation/core/Spring>`__.

   ============================== ==================================
   |Spring effect| *High Bounce*  |32eac117de778099.gif| *No Bounce*
   ============================== ==================================

   ======================================== ====================================
   |7ba20cf822ecb900.gif| *High Stiffness*  |low stiffness| *Very low Stiffness*
   ======================================== ====================================

   Take a look at the ``DogHobby()`` function call in the ``DogItem()`` composable
   function. The dog's hobby information is included in the composition, based on the
   ``expanded`` boolean value. The height of the list item changes, depending on whether
   the hobby information is visible or hidden. Currently, the transition is jarring. In
   this section you will use the
   `animateContentSize <https://developer.android.google.cn/jetpack/compose/animation/composables-modifiers#animateContentSize>`__
   modifier to add a smoother transition between the expanded and not expanded states.

   .. code:: prettyprint

      // No need to copy over
      @Composable
      fun DogItem(...) {
        ...
          if (expanded) {
             DogHobby(
                dog.hobbies, 
                modifier = Modifier.padding(
                    start = dimensionResource(R.dimen.padding_medium),
                    top = dimensionResource(R.dimen.padding_small),
                    end = dimensionResource(R.dimen.padding_medium),
                    bottom = dimensionResource(R.dimen.padding_medium)
                )
            )
         }
      }

   1. In ``MainActivity.kt``, in ``DogItem()``, add a ``modifier`` parameter to the
      ``Column`` layout.

   .. code:: prettyprint

      @Composable
      fun DogItem(
         dog: Dog, 
         modifier: Modifier = Modifier
      ) {
         ...
         Card(
             ...
         ) {
             Column(
                modifier = Modifier
             ){
                 ...
             }
         }
      }

   2. Chain the modifier with the
      `animateContentSize <https://developer.android.google.cn/jetpack/compose/animation#animateContentSize>`__
      modifier to animate the size (list item height) change.

   .. code:: prettyprint

      import androidx.compose.animation.animateContentSize

      Column(
         modifier = Modifier
             .animateContentSize()
      )

   In the current implementation, you are animating the list item height in your app. But,
   the animation is so subtle that it is difficult to discern when you run the app. To
   resolve this, use an optional
   `animationSpec <https://developer.android.google.cn/reference/kotlin/androidx/compose/animation/core/AnimationSpec>`__
   parameter that lets you customize the animation.

   3. For Woof, the animation eases in and out with no bounce. To achieve that, add the
      ``animationSpec`` parameter to the ``animateContentSize()`` function call. Set it to
      a spring animation with
      `DampingRatioNoBouncy <https://developer.android.google.cn/reference/kotlin/androidx/compose/animation/core/Spring#DampingRatioNoBouncy()>`__
      so that there isn't a bounce to it and a
      `StiffnessMedium <https://developer.android.google.cn/reference/kotlin/androidx/compose/animation/core/Spring#StiffnessMedium()>`__
      parameter to make the spring a bit stiffer.

   .. code:: prettyprint

      import androidx.compose.animation.core.Spring
      import androidx.compose.animation.core.spring

      Column(
         modifier = Modifier
             .animateContentSize(
                 animationSpec = spring(
                     dampingRatio = Spring.DampingRatioNoBouncy,
                     stiffness = Spring.StiffnessMedium
                 )
             )
      )

   4. Check out ``WoofPreview()`` in the **Design** pane, and use the interactive mode or
      run your app on an emulator or device to see your spring animation in action.

   |c0d0a52463332875.gif|

   You did it! Enjoy your beautiful app with animations.


7. (Optional) Experiment with other animations
--------------------------------------------------------------------------------


animate*AsState

   The
   `animate*AsState() <https://developer.android.google.cn/jetpack/compose/animation/value-based#animate-as-state>`__
   functions are one of the simplest animation APIs in Compose for animating a single
   value. You only provide the end value (or target value), and the API starts animation
   from the current value to the specified end value.

   Compose provides ``animate*AsState()`` functions for ``Float``, ``Color``, ``Dp``,
   ``Size``, ``Offset``, and ``Int``, to name a few. You can easily add support for other
   data types using ``animateValueAsState()`` that takes a generic type.

   Try using the ``animateColorAsState()`` function to change the color when a list item is
   expanded.

   1. In ``DogItem()``, declare a color and delegate its initialization to
      ``animateColorAsState()`` function.

   .. code:: prettyprint

      import androidx.compose.animation.animateColorAsState

      @Composable
      fun DogItem(
         dog: Dog,
         modifier: Modifier = Modifier
      ) {
         var expanded by remember { mutableStateOf(false) }
         val color by animateColorAsState()
         ...
      }

   2. Set the ``targetValue`` named parameter, depending on the ``expanded`` boolean value.
      If the list item is expanded, set the list item to ``tertiaryContainer`` color. Else,
      set it to ``primaryContainer`` color.

   .. code:: prettyprint

      import androidx.compose.animation.animateColorAsState

      @Composable
      fun DogItem(
         dog: Dog,
         modifier: Modifier = Modifier
      ) {
         var expanded by remember { mutableStateOf(false) }
         val color by animateColorAsState(
             targetValue = if (expanded) MaterialTheme.colorScheme.tertiaryContainer
             else MaterialTheme.colorScheme.primaryContainer,
         )
         ...
      }

   3. Set the ``color`` as the background modifier to the ``Column``.

   .. code:: prettyprint

      @Composable
      fun DogItem(
         dog: Dog, 
         modifier: Modifier = Modifier
      ) {
         ...
         Card(
             ...
         ) {
             Column(
                 modifier = Modifier
                     .animateContentSize(
                         ...
                         )
                     )
                     .background(color = color)
             ) {...}
      }

   4. Check out how the color changes when the list item is expanded. Non expanded list
      items are ``primaryContainer`` color and expanded list items are
      ``tertiaryContainer`` color.

   |animateAsState animation|


8. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use this git command:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof.git

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the downloaded repository.

   If you want to see the solution code, 
   `view it on GitHub <https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof/tree/main>`__.


9. Conclusion
--------------------------------------------------------------------------------

   Congratulations! You added a button to hide and reveal information about the dog. You
   enhanced the user experience using spring animations. You also learned how to use
   interactive mode in the **Design** pane.

   You can also try a different type of 
   `Jetpack Compose Animation <https://developer.android.google.cn/jetpack/compose/animation>`__. Don't
   forget to share your work on social media with #AndroidBasics!


**Learn more**

   -  `Jetpack Compose Animation <https://developer.android.google.cn/jetpack/compose/animation>`__
   -  Codelab: `Animating elements in Jetpack Compose <https://developer.android.google.cn/codelabs/jetpack-compose-animation>`__
   -  Video: `Animation Reimagined <https://www.youtube.com/watch?v=Z_T1bVjhMLk>`__
   -  Video: `Jetpack Compose: Animation <https://youtu.be/7yY2OocGiQU>`__

.. |36c6cabd93421a92.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/36c6cabd93421a92.png
.. |c0d0a52463332875.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/c0d0a52463332875.gif
.. |30c384f00846e69b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/30c384f00846e69b.png
.. |f88173321938c003.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/f88173321938c003.png
.. |def59d71015c0fbe.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/def59d71015c0fbe.png
.. |Pencil on notebook| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/1c71e91aa04d3837.jpeg
.. |Black and white pencil icon| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/b718af58f961d2b4.png
.. |Material Icon library| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/254688426772346f.png
.. |772f8f274e7d3f44.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/772f8f274e7d3f44.png
.. |5bbf09cd2828b6.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/5bbf09cd2828b6.png
.. |197842fd06abf239.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/197842fd06abf239.png
.. |733f6d9ef2939ab5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/733f6d9ef2939ab5.png
.. |8df42b9d85a5dbaa.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/8df42b9d85a5dbaa.png
.. |bba8146c6332cc37.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/bba8146c6332cc37.png
.. |Woof Preview with expanded list items| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/2704a4ef191ef458.png
.. |42379dbe94a7a497.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/42379dbe94a7a497.png
.. |74e1624d68fb4131.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/74e1624d68fb4131.png
.. |Animation of Woof list items expanding and contracting| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/e4c793196993a9ae.gif
.. |60829fbffe4d8302.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/60829fbffe4d8302.png
.. |c761ef298c2aea5a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/c761ef298c2aea5a.png
.. |b380f933be0b6ff4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/b380f933be0b6ff4.png
.. |de5dc4a953f11e65.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/de5dc4a953f11e65.gif
.. |Spring release effect| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/af35a9d327d1cab0.gif
.. |Spring effect| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/d8e850d6eeec30a5.gif
.. |32eac117de778099.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/32eac117de778099.gif
.. |7ba20cf822ecb900.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/7ba20cf822ecb900.gif
.. |low stiffness| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/710c9cad92e2d7ad.gif
.. |animateAsState animation| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-woof-animation/img/b45e86eb53fd7d88.png


ğŸš€ Testing for Accessibility
=============================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-accessibility


1. Introduction
--------------------------------------------------------------------------------

   In this codelab, you will learn how to test and improve the accessibility of your apps.

   People with impaired vision, color blindness, impaired hearing, impaired dexterity, cognitive
   disabilities, and many other disabilities use Android devices to complete tasks in their
   day-to-day lives. When you develop apps with accessibility in mind, you make the user experience
   better, particularly for users with these and other accessibility needs.

   During this codelab, you will use **TalkBack** and **Switch Access** to test the accessibility of
   the **Woof** app.

   -  **TalkBack** allows users to have eyes free control of their devices.
   -  **Switch Access** allows users to navigate an app using switches instead of the touch screen.


**What you'll learn**

   -  How to interact with an app using TalkBack.
   -  How to interact with an app using Switch Access instead of the touch screen.
   -  How to optimize your UI for better accessibility.


**What you'll need**

   -  A computer with Android Studio installed.
   -  An Android device or emulator that has access to the Google Play Store app, or already has the
      Android Accessibility Suite installed.
   -  The solution code for the **Woof** app.


2. Getting set up
--------------------------------------------------------------------------------


Download the starter code

   In Android Studio, open the ``android-basics-kotlin-compose-woof`` folder.

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof

   **Branch name with starter code:** ``main``

   Open the **Woof** app code in Android Studio.


**Setup your device**

   If you already have the Android Accessibility Suite installed on your device or emulator, then
   you can skip this part. If you need to install the Android Accessibility Suite (for access to
   TalkBack and Switch Access), follow the instructions below.

   **Note:** It is recommended that you use a physical device for this codelab if you have one
   available to you. If you have a physical device, you will not have to go through the following
   setup steps.


**Configure a device with the Google Play Store app**

   If you are using a physical device, make sure you:

   -  Have access to the Play Store app.
   -  Are logged in to your Google account.
   -  Have the necessary permissions on your device to download apps from the Play Store app.

   If you are using an emulator, follow these steps to set up an emulator that has Play Store app
   access:

   1. In Android Studio, open the **Device Manager** and select **Create Device**.
   2. Make sure you select **Pixel 8** or any device with a Play Store app icon in the **Play
      Store** column. The icon indicates that this emulator comes with the Google Play Store app.

   |fef200739a6b0e6d.png|

   3. Click **Next** and proceed with the emulator creation. If you need a refresher on how to
      finish creating a new hardware profile, follow the video in `this codelab section <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-emulator?continue=https%3A%2F%2Fdeveloper.android.com%2Fcourses%2Fpathways%2Fandroid-basics-compose-unit-1-pathway-2%23codelab-https%3A%2F%2Fdeveloper.android.com%2Fcodelabs%2Fbasic-android-kotlin-compose-emulator#1>`__.
   4. Once your emulator is created, launch it from the **Device Manager** by clicking the arrow
      icon.

   |91619522d628e743.png|

   5. Launch the Play Store app on the emulator and sign in with a valid Google account.

   **Note:** If you don't see the Play Store app launcher in the location shown below, you can find
   it in the **All Apps** screen.

   |f5bb7cf9f5ae9410.png|


Install the Android Accessibility Suite app

   The Android Accessibility Suite contains a collection of accessibility apps. You will need it to
   use **TalkBack** and **Switch Access** later in this codelab.

   1. Within the Google Play Store app, install the `Android Accessibility Suite <https://play.google.com/store/apps/details?id=com.google.android.marvin.talkback>`__
      app.

   |942030e19c564e59.png|


Install the Woof app

   If you created a new Pixel 4 hardware profile at the beginning of this section, you will need to
   install the **Woof** app from the solution code you downloaded.


3. Use Woof with TalkBack
--------------------------------------------------------------------------------

   `TalkBack <https://support.google.com/accessibility/android/answer/6283677>`__ is a Google screen
   reader that provides spoken feedback so users can navigate their device without looking at the
   screen. This is especially helpful for people with impaired vision.

   Once TalkBack is enabled, users can navigate their device through spoken feedback and
   gestureséˆ¥æ”•uch as swipes and taps. Navigating with TalkBack is a great way for you to test for
   areas of improvement in your app.

   Follow these steps to gain more familiarity with TalkBack:

   **Note:** When **TalkBack** is on, tap to select an item, then double-tap to activate. Use two
   fingers for swipe and system navigation.

   1. Watch the following video to learn how to configure and use TalkBack.

      https://googledownloads.cn/cn-devsite/_1yRVwhEv5I.mp4

   **Note:** If you can't access this video, check out the
   `documentation <https://support.google.com/accessibility/android/answer/6283677>`__.

   2. Once you familiarize yourself with **TalkBack**, apply what you learned to the **Woof** app!

   **Note:** The TalkBack audio on an emulator may be low volume or poor quality. If you experience
   this, try turning up the volume on the emulator.

   3. Disable the **TalkBack** feature before proceeding to the next section. Take the following
      steps to disable **Talkback**:

   On your device or emulator, open **Settings**.

   Select **Accessibility** and then **TalkBack**.

   Turn **Use TalkBack** off.

   Select **Ok**.

   You can learn more ways to disable TalkBack in the `support documentation <https://support.google.com/accessibility/android/answer/6007100>`__.
   Keep in mind that some of these options will not be possible on an emulator and 
   others may be deprecated on certain Android versions.


4. Use Woof with Switch Access
--------------------------------------------------------------------------------

   Switch Access lets you interact with your Android device using one or more switches instead of
   the touchscreen. This alternative to using the touchscreen for users is especially helpful to
   users with limited dexterity.

   Switch Access scans the items on your screen, highlighting each item in turn, until you make a
   selection.

   To use Switch Access, you'll first need one or more switches. There are several kinds of
   switches, but in this codelab we will be using the built-in volume buttons on an Android device.

   1. Watch the following video to learn how to configure and use `Switch Access <https://support.google.com/accessibility/android/answer/6122836>`__.

   **Note:** If you can't access this video, check out the
   `documentation <https://support.google.com/accessibility/android/answer/6122836>`__.

   2. If you configured the volume buttons as instructed by the video, Switch Access allows you to
      click the volume down button to navigate to different elements in the app. Once an element is
      highlighted, it can be selected using the volume up button.

   For items with a simple click action, selecting the item is the same as performing a tap action
   on it. For items that have custom accessibility actions available, selecting the item presents
   the user with different actions they can take on the item.

   When Switch Access is enabled, there is a **Menu** tab at the top of the device's screen. When
   selected, the tab opens a global menu with navigation options, such as **Back** and **Home**,
   which are equivalent to the gestures on the device screen. Some options customize Switch Access
   behavior.

   3. Once you familiarize yourself with **Switch Access**, apply what you learned to the **Woof**
      app!
   4. Disable **Switch Access** before proceeding to the next section.


5. Improving UI accessibility
--------------------------------------------------------------------------------

   There are a number of UI design choices to consider when trying to create a more accessible app.
   In addition to attributes and behaviors that allow for effective usage of TalkBack and Switch
   Access, below are some UI optimizations you can make to improve the accessibility of your app.


**Content description**

   Users of accessibility services, such as screen readers (like TalkBack), rely on content
   descriptions to understand the meaning of elements in an interface.

   In some cases, such as when information is conveyed graphically within an element, content
   descriptions can provide a text description of the meaning or action associated with the element.

   If elements in a user interface don't provide content labels, it can be difficult for some users
   to understand the information presented to them, or to perform actions in the interface. In
   Compose, you can describe visual elements using the ``contentDescription`` attribute. For
   strictly decorative visual elements, it's okay to set the ``contentDescription`` to ``null``.
   Read more about how to apply content descriptions in the `documentation <https://developer.android.google.cn/jetpack/compose/accessibility#describe-visual>`__.


Touch target size

   Any on-screen element that someone can interact with must be large enough for reliable
   interaction. The minimum touch target size for something clickable is 48dp high x 48dp wide.
   There are a number of Material Design components for which Compose automatically assigns the
   correct minimum target size. Keep in mind that the minimum touch target size refers to clickable
   components smaller than 48dp. Components larger than 48dp will have a touch target that is at
   least the size of the component. Follow these resources for more information on touch target
   size:

   1. Read about minimum target size in the `Accessibility in Compose documentation <https://developer.android.google.cn/jetpack/compose/accessibility#minimum-target-sizes>`__.
   2. Watch the touch target sizes section of the `What's new in Google Accessibility video <https://youtu.be/6LsaP6oKxMY?t=166>`__.

   Take a look at the code for the **Woof** app. In **MainActivity.kt**, the ``DogItemButton``
   composable uses an ``IconButton`` composable.

   .. code:: prettyprint

      @Composable
      private fun DogItemButton(
         expanded: Boolean,
         onClick: () -> Unit,
         modifier: Modifier = Modifier
      ) {
         IconButton(onClick = onClick) {
             Icon(
                 imageVector = if (expanded) Icons.Filled.ExpandLess else Icons.Filled.ExpandMore,
                 tint = MaterialTheme.colors.secondary,
                 contentDescription = stringResource(R.string.expand_button_content_description),
             )
         }
      }

   The ``IconButton`` is a Material Design component. The `documentation for the IconButton <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/package-summary#IconButton(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function0)>`__
   composable indicates that the minimum touch target size is 48dp x 48dp.

   The code below is the source code for the ``IconButton``. Notice that the modifier sets the
   ``minimumTouchTargetSize()``.

   .. code:: prettyprint

      @Composable
      fun IconButton(
         onClick: () -> Unit,
         modifier: Modifier = Modifier,
         enabled: Boolean = true,
         interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
         content: @Composable () -> Unit
      ) {
         Box(
             modifier = modifier
                 .minimumTouchTargetSize()
                 .clickable(
                     onClick = onClick,
                     enabled = enabled,
                     role = Role.Button,
                     interactionSource = interactionSource,
                     indication = rememberRipple(bounded = false, radius = RippleRadius)
                 ),
             contentAlignment = Alignment.Center
         ) {
             val contentAlpha = if (enabled) LocalContentAlpha.current else ContentAlpha.disabled
             CompositionLocalProvider(LocalContentAlpha provides contentAlpha, content = content)
         }
      }

   **Note**: The code that you see above for the ``IconButton`` cannot be found directly in the
   **Woof** app code. This is the source code for the ``IconButton`` that comes from the Compose
   Material library. As an optional step, if you want to find this code for yourself, you can
   right-click on the call to ``IconButton`` in the ``MainActivity``, and select **Go To >
   Declaration or Usages**.


Color contrast

   The colors you choose for your app interface affect how easily users can read and understand it.
   Sufficient color contrast makes text and images easier to read and comprehend.

   Along with benefiting users with various visual impairments, sufficient color contrast helps all
   users when viewing an interface on devices in extreme lighting conditions, such as when exposed
   to direct sunlight or on a display with low brightness.

   You can read more about how to optimize for color contrast in the 
   `Android Accessibility Help documentation <https://support.google.com/accessibility/android/answer/7158390>`__. 
   In that link, you will find information on contrast ratios to help guide your decision on which 
   colors to use. Additionally, you can use `this tool <https://webaim.org/resources/contrastchecker/>`__
   to test your background and foreground colors for sufficient color contrast ratio. Small text has a
   recommended ratio of 4.5 : 1 and large text has a recommended ratio of 3.0 : 1.

   For the **Woof** app, our designer picked the colors for us, and ensured they had enough 
   color contrast. When you create your own app, remember to check the color contrast.
   The `Color Tool <https://material.io/resources/color/#!/?view.left=0&view.right=0>`__ 
   for Material Design has an accessibility tab where you can see appropriate text colors 
   https://googledownloads.cn/cn-devsite/_1yRVwhEv5I.mp4on top of 
   the primary and secondary colors.


6. Conclusion
--------------------------------------------------------------------------------

   It is important to keep accessibility in mind as you create new apps and add new features to
   existing apps. By integrating accessibility features and services, you can improve your app's
   usability, particularly for users with disabilities.


Learn more

   -  `Accessibility on Android <https://www.youtube.com/playlist?list=PLWz5rJ2EKKc8OENfLdh3zM5T6IRdlVYKj>`__
   -  `Accessible design <https://m3.material.io/foundations/accessible-design/overview>`__
   -  `Accessibility in Jetpack Compose <https://developer.android.google.cn/codelabs/jetpack-compose-accessibility#0>`__
   -  `Make your Android app more accessible <https://developer.android.google.cn/courses/pathways/make-your-android-app-accessible>`__

.. |fef200739a6b0e6d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-accessibility/img/fef200739a6b0e6d.png
.. |91619522d628e743.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-accessibility/img/91619522d628e743.png
.. |f5bb7cf9f5ae9410.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-accessibility/img/f5bb7cf9f5ae9410.png
.. |942030e19c564e59.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-accessibility/img/942030e19c564e59.png


ğŸš€ Practice: Build Superheroes app
===================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-superheroes


1. Before you begin
--------------------------------------------------------------------------------

   Congratulations! In this pathway you learned the basics of Material Design, and how to add simple
   animations to your app. Now it is time to put what you learned into practice.

   In this practice set, you'll build on the concepts you learned in this pathway by creating a
   **Superheroes** app. This app focuses on creating the components necessary to build a scrollable
   list and a polished UI using the Material Design principles you learned in 
   `Material Theming with Jetpack Compose codelab. <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-material-theming>`__

   The solution code is available at the end, but try to solve the exercises before you check it.
   Consider the solutions as one way to implement the app. There's a lot of room for improvement, so
   feel free to experiment and try different things.

   Work through the problems at a pace that's comfortable to you. You're encouraged to take as much
   time as you need to solve each problem thoughtfully.


Prerequisites

   -  Complete Android Basics in Compose course work through the 
      `Simple Animation with Jetpack Compose <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-woof-animation#1>`__.


What you'll need

   -  A computer with internet access and Android Studio installed.


What you'll build

   A **Superheroes** app that displays a list of superheroes.

   The final app will look like the following in both light and dark theme:

   ===================== =====================
   |319d310070d8f51.png| |2f152529c4cadcb1.png|
   ===================== =====================


2. Get started
--------------------------------------------------------------------------------

   In this task, you set up the project and create the dummy data for the superheroes.

   1. Create a new project with the **Empty Activity** template and a minimum SDK of 24.

   2. Download the assets for the app: superhero images, and app logo from
      `here <https://github.com/google-developer-training/basic-android-kotlin-compose-training-superheroes/raw/main/Image%20assets.zip>`__.
      Refer to the `Change the app icon <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-training-change-app-icon>`__
      codelab for a refresher on how to add an app icon. Refer to 
      `Create an interactive Dice Roller app <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-build-a-dice-roller-app>`__
      codelab for a refresher on how to add images to your app.

   3. Download the Cabin bold and Cabin regular font files from https://fonts.google.com. Explore
      the different font files available. Refer to `Material Theming with Jetpack Compose <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-material-theming#6>`__
      codelab for customizing the typography in your app.

   4. Create a data class to hold the data for each superhero. Create a new package named ``model``
      for the ``Hero`` data class to organize your code. Your list item can look something like the
      following:

   |268233a1e2b3b407.png|

   Each superhero list item displays three pieces of unique information: name, description, and an
   image.

   5. In the same ``model`` package, create another file for all the heroes information you would
      like to display. For example, name, description, and image resource. The following is a sample
      data set for your inspiration.

   .. code:: prettyprint

      object HeroesRepository {
          val heroes = listOf(
              Hero(
                  nameRes = R.string.hero1,
                  descriptionRes = R.string.description1,
                  imageRes = R.drawable.android_superhero1
              ),
              Hero(
                  nameRes = R.string.hero2,
                  descriptionRes = R.string.description2,
                  imageRes = R.drawable.android_superhero2
              ),
              Hero(
                  nameRes = R.string.hero3,
                  descriptionRes = R.string.description3,
                  imageRes = R.drawable.android_superhero3
              ),
              Hero(
                  nameRes = R.string.hero4,
                  descriptionRes = R.string.description4,
                  imageRes = R.drawable.android_superhero4
              ),
              Hero(
                  nameRes = R.string.hero5,
                  descriptionRes = R.string.description5,
                  imageRes = R.drawable.android_superhero5
              ),
              Hero(
                  nameRes = R.string.hero6,
                  descriptionRes = R.string.description6,
                  imageRes = R.drawable.android_superhero6
              )
          )
      }

   6. Add the heroes name and description strings in the **strings.xml** file.

   .. code:: prettyprint

      <resources>
          <string name="app_name">Superheroes</string>
          <string name="hero1">Nick the Night and Day</string>
          <string name="description1">The Jetpack Hero</string>
          <string name="hero2">Reality Protector</string>
          <string name="description2">Understands the absolute truth</string>
          <string name="hero3">Andre the Giant</string>
          <string name="description3">Mimics the light and night to blend in</string>
          <string name="hero4">Benjamin the Brave</string>
          <string name="description4">Harnesses the power of canary to develop bravely</string>
          <string name="hero5">Magnificent Maru</string>
          <string name="description5">Effortlessly glides in to save the day</string>
          <string name="hero6">Dynamic Yasmine</string>
          <string name="description6">Ability to shift to any form and energize</string>
      </resources>


3. Material Theming
--------------------------------------------------------------------------------

   In this section you will add the app's color palette, typography, and shapes to improve the look
   and feel of the app.

   The following Color, Type, and Shape are just recommendations for the theme. Explore and modify
   different color schemes.

   Use `Material Theme Builder <https://m3.material.io/theme-builder#/custom>`__ to create a new
   theme for the app.

   **Color**

   ``ui.theme/Color.kt``

   .. code:: prettyprint

      import androidx.compose.ui.graphics.Color

      val md_theme_light_primary = Color(0xFF466800)
      val md_theme_light_onPrimary = Color(0xFFFFFFFF)
      val md_theme_light_primaryContainer = Color(0xFFC6F181)
      val md_theme_light_onPrimaryContainer = Color(0xFF121F00)
      val md_theme_light_secondary = Color(0xFF596248)
      val md_theme_light_onSecondary = Color(0xFFFFFFFF)
      val md_theme_light_secondaryContainer = Color(0xFFDDE6C6)
      val md_theme_light_onSecondaryContainer = Color(0xFF161E0A)
      val md_theme_light_tertiary = Color(0xFF396661)
      val md_theme_light_onTertiary = Color(0xFFFFFFFF)
      val md_theme_light_tertiaryContainer = Color(0xFFBCECE6)
      val md_theme_light_onTertiaryContainer = Color(0xFF00201D)
      val md_theme_light_error = Color(0xFFBA1A1A)
      val md_theme_light_errorContainer = Color(0xFFFFDAD6)
      val md_theme_light_onError = Color(0xFFFFFFFF)
      val md_theme_light_onErrorContainer = Color(0xFF410002)
      val md_theme_light_background = Color(0xFFFEFCF5)
      val md_theme_light_onBackground = Color(0xFF1B1C18)
      val md_theme_light_surface = Color(0xFFFEFCF5)
      val md_theme_light_onSurface = Color(0xFF1B1C18)
      val md_theme_light_surfaceVariant = Color(0xFFE1E4D4)
      val md_theme_light_onSurfaceVariant = Color(0xFF45483D)
      val md_theme_light_outline = Color(0xFF75786C)
      val md_theme_light_inverseOnSurface = Color(0xFFF2F1E9)
      val md_theme_light_inverseSurface = Color(0xFF30312C)
      val md_theme_light_inversePrimary = Color(0xFFABD468)
      val md_theme_light_surfaceTint = Color(0xFF466800)
      val md_theme_light_outlineVariant = Color(0xFFC5C8B9)
      val md_theme_light_scrim = Color(0xFF000000)

      val md_theme_dark_primary = Color(0xFFABD468)
      val md_theme_dark_onPrimary = Color(0xFF223600)
      val md_theme_dark_primaryContainer = Color(0xFF344E00)
      val md_theme_dark_onPrimaryContainer = Color(0xFFC6F181)
      val md_theme_dark_secondary = Color(0xFFC1CAAB)
      val md_theme_dark_onSecondary = Color(0xFF2B331D)
      val md_theme_dark_secondaryContainer = Color(0xFF414A32)
      val md_theme_dark_onSecondaryContainer = Color(0xFFDDE6C6)
      val md_theme_dark_tertiary = Color(0xFFA0D0CA)
      val md_theme_dark_onTertiary = Color(0xFF013733)
      val md_theme_dark_tertiaryContainer = Color(0xFF1F4E4A)
      val md_theme_dark_onTertiaryContainer = Color(0xFFBCECE6)
      val md_theme_dark_error = Color(0xFFFFB4AB)
      val md_theme_dark_errorContainer = Color(0xFF93000A)
      val md_theme_dark_onError = Color(0xFF690005)
      val md_theme_dark_onErrorContainer = Color(0xFFFFDAD6)
      val md_theme_dark_background = Color(0xFF1B1C18)
      val md_theme_dark_onBackground = Color(0xFFE4E3DB)
      val md_theme_dark_surface = Color(0xFF1B1C18)
      val md_theme_dark_onSurface = Color(0xFFE4E3DB)
      val md_theme_dark_surfaceVariant = Color(0xFF45483D)
      val md_theme_dark_onSurfaceVariant = Color(0xFFC5C8B9)
      val md_theme_dark_outline = Color(0xFF8F9285)
      val md_theme_dark_inverseOnSurface = Color(0xFF1B1C18)
      val md_theme_dark_inverseSurface = Color(0xFFE4E3DB)
      val md_theme_dark_inversePrimary = Color(0xFF466800)
      val md_theme_dark_surfaceTint = Color(0xFFABD468)
      val md_theme_dark_outlineVariant = Color(0xFF45483D)
      val md_theme_dark_scrim = Color(0xFF000000)

   **Shape**

   ``ui.theme/Shape.kt``

   .. code:: prettyprint

      import androidx.compose.foundation.shape.RoundedCornerShape
      import androidx.compose.material3.Shapes
      import androidx.compose.ui.unit.dp

      val Shapes = Shapes(
          small = RoundedCornerShape(8.dp),
          medium = RoundedCornerShape(16.dp),
          large = RoundedCornerShape(16.dp)
      )

   **Typography**

   ``ui.theme/Type.kt``

   .. code:: prettyprint

      import androidx.compose.material3.Typography
      import androidx.compose.ui.text.TextStyle
      import androidx.compose.ui.text.font.Font
      import androidx.compose.ui.text.font.FontFamily
      import androidx.compose.ui.text.font.FontWeight
      import androidx.compose.ui.unit.sp
      import com.example.superheroes.R


      val Cabin = FontFamily(
          Font(R.font.cabin_regular, FontWeight.Normal),
          Font(R.font.cabin_bold, FontWeight.Bold)
      )
      // Set of Material typography styles to start with
      val Typography = Typography(
          bodyLarge = TextStyle(
              fontFamily = Cabin,
              fontWeight = FontWeight.Normal,
              fontSize = 16.sp,
              lineHeight = 24.sp,
              letterSpacing = 0.5.sp
          ),
          displayLarge = TextStyle(
              fontFamily = Cabin,
              fontWeight = FontWeight.Normal,
              fontSize = 30.sp
          ),
          displayMedium = TextStyle(
              fontFamily = Cabin,
              fontWeight = FontWeight.Bold,
              fontSize = 20.sp
          ),
          displaySmall = TextStyle(
              fontFamily = Cabin,
              fontWeight = FontWeight.Bold,
              fontSize = 20.sp
          )
      )

   **Theme**

   ``ui.theme/Theme.kt``

   .. code:: prettyprint

      import android.app.Activity
      import android.os.Build
      import androidx.compose.foundation.isSystemInDarkTheme
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.darkColorScheme
      import androidx.compose.material3.dynamicDarkColorScheme
      import androidx.compose.material3.dynamicLightColorScheme
      import androidx.compose.material3.lightColorScheme
      import androidx.compose.runtime.Composable
      import androidx.compose.runtime.SideEffect
      import androidx.compose.ui.graphics.toArgb
      import androidx.compose.ui.platform.LocalContext
      import androidx.compose.ui.platform.LocalView
      import androidx.core.view.WindowCompat

      private val LightColors = lightColorScheme(
         primary = md_theme_light_primary,
         onPrimary = md_theme_light_onPrimary,
         primaryContainer = md_theme_light_primaryContainer,
         onPrimaryContainer = md_theme_light_onPrimaryContainer,
         secondary = md_theme_light_secondary,
         onSecondary = md_theme_light_onSecondary,
         secondaryContainer = md_theme_light_secondaryContainer,
         onSecondaryContainer = md_theme_light_onSecondaryContainer,
         tertiary = md_theme_light_tertiary,
         onTertiary = md_theme_light_onTertiary,
         tertiaryContainer = md_theme_light_tertiaryContainer,
         onTertiaryContainer = md_theme_light_onTertiaryContainer,
         error = md_theme_light_error,
         errorContainer = md_theme_light_errorContainer,
         onError = md_theme_light_onError,
         onErrorContainer = md_theme_light_onErrorContainer,
         background = md_theme_light_background,
         onBackground = md_theme_light_onBackground,
         surface = md_theme_light_surface,
         onSurface = md_theme_light_onSurface,
         surfaceVariant = md_theme_light_surfaceVariant,
         onSurfaceVariant = md_theme_light_onSurfaceVariant,
         outline = md_theme_light_outline,
         inverseOnSurface = md_theme_light_inverseOnSurface,
         inverseSurface = md_theme_light_inverseSurface,
         inversePrimary = md_theme_light_inversePrimary,
         surfaceTint = md_theme_light_surfaceTint,
         outlineVariant = md_theme_light_outlineVariant,
         scrim = md_theme_light_scrim,
      )

      private val DarkColors = darkColorScheme(
         primary = md_theme_dark_primary,
         onPrimary = md_theme_dark_onPrimary,
         primaryContainer = md_theme_dark_primaryContainer,
         onPrimaryContainer = md_theme_dark_onPrimaryContainer,
         secondary = md_theme_dark_secondary,
         onSecondary = md_theme_dark_onSecondary,
         secondaryContainer = md_theme_dark_secondaryContainer,
         onSecondaryContainer = md_theme_dark_onSecondaryContainer,
         tertiary = md_theme_dark_tertiary,
         onTertiary = md_theme_dark_onTertiary,
         tertiaryContainer = md_theme_dark_tertiaryContainer,
         onTertiaryContainer = md_theme_dark_onTertiaryContainer,
         error = md_theme_dark_error,
         errorContainer = md_theme_dark_errorContainer,
         onError = md_theme_dark_onError,
         onErrorContainer = md_theme_dark_onErrorContainer,
         background = md_theme_dark_background,
         onBackground = md_theme_dark_onBackground,
         surface = md_theme_dark_surface,
         onSurface = md_theme_dark_onSurface,
         surfaceVariant = md_theme_dark_surfaceVariant,
         onSurfaceVariant = md_theme_dark_onSurfaceVariant,
         outline = md_theme_dark_outline,
         inverseOnSurface = md_theme_dark_inverseOnSurface,
         inverseSurface = md_theme_dark_inverseSurface,
         inversePrimary = md_theme_dark_inversePrimary,
         surfaceTint = md_theme_dark_surfaceTint,
         outlineVariant = md_theme_dark_outlineVariant,
         scrim = md_theme_dark_scrim,
      )

      @Composable
      fun SuperheroesTheme(
         darkTheme: Boolean = isSystemInDarkTheme(),
         // Dynamic color is available on Android 12+
         // Dynamic color in this app is turned off for learning purposes
         dynamicColor: Boolean = false,
         content: @Composable () -> Unit
      ) {
         val colorScheme = when {
             dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
                 val context = LocalContext.current
                 if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
             }

             darkTheme -> DarkColors
             else -> LightColors
         }
         val view = LocalView.current
         if (!view.isInEditMode) {
             SideEffect {
                 val window = (view.context as Activity).window
                 window.statusBarColor = colorScheme.background.toArgb()
                 WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = !darkTheme
             }
         }

         MaterialTheme(
             colorScheme = colorScheme,
             typography = Typography,
             shapes = Shapes,
             content = content
         )
      }


4. Display list
--------------------------------------------------------------------------------

   The first step in creating a list is to create a list item.

   1. Create a file called ``HeroesScreen.kt``, under the ``com.example.superheroes`` package. You
      will be creating a list item and list composables in this file.
   2. Create a composable to represent a superhero list item, which looks like the following
      screenshot and UI specifications. |268233a1e2b3b407.png|

   Follow this UI specification or be creative and design your own list item:

   -  Card elevation is ``2dp``
   -  Height of the list item is ``72dp`` with ``16dp`` padding
   -  Clip radius of the list item is ``16dp``
   -  ``Box`` layout with image with size ``72dp``
   -  Clip radius of the image is ``8dp``
   -  Space between the image and the text is ``16dp``
   -  Style for superhero's name is ``DisplaySmall``
   -  Style for superhero's description is ``BodyLarge``

   Explore different padding and size options, as per the Material 3 guidelines, padding should be
   increments of ``4dp``.

   |3b073896adfdcd7a.png|

   |6affe74f9559dc90.png|

   **Create the lazy column**

   1. Create another composable that takes the list of heroes and displays the list. This is where
      you use a ```LazyColumn`` <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyColumn(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__.

   2. Use the following UI specifications for the padding.

   |af5116f770dd0ad.png|

   After you finish the implementation, your app should match the following screenshot:

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-superheroes/img/6589c7a5fb4a2294.png

      Phone screen showing the list with out top app bar


5. Add Top app bar
--------------------------------------------------------------------------------

   Add a top app bar for your app.

   1. In ``MainActivity.kt``, add a composable to display the top app bar. Add text to the top app
      bar; it could be the app name. Align it in the center both horizontally and vertically.
   2. You could set the top app bar with style as ``DisplayLarge``.

   |2e8eeb35ac3e631b.png|

   3. Use ``scaffold`` to display the top app bar. Refer to the documentation if neededï¼š
      `Top app bar â€“ Material Design 3 <https://m3.material.io/components/top-app-bar/overview>`__ .


Customize status bar color

   To make your app `edge-to-edge <https://developer.android.google.cn/develop/ui/views/layout/edge-to-edge>`__, 
   you can customize the status bar color to match the background color.

   1. In the ``Theme.kt``, add this new method to change the status bar and navigation bar colors
      for edge to edge.

   .. code:: prettyprint

      /**
       * Sets up edge-to-edge for the window of this [view]. The system icon colors are set to either
       * light or dark depending on whether the [darkTheme] is enabled or not.
       */
      private fun setUpEdgeToEdge(view: View, darkTheme: Boolean) {
          val window = (view.context as Activity).window
          WindowCompat.setDecorFitsSystemWindows(window, false)
          window.statusBarColor = Color.Transparent.toArgb()
          val navigationBarColor = when {
              Build.VERSION.SDK_INT >= 29 -> Color.Transparent.toArgb()
              Build.VERSION.SDK_INT >= 26 -> Color(0xFF, 0xFF, 0xFF, 0x63).toArgb()
              // Min sdk version for this app is 24, this block is for SDK versions 24 and 25
              else -> Color(0x00, 0x00, 0x00, 0x50).toArgb()
          }
          window.navigationBarColor = navigationBarColor
          val controller = WindowCompat.getInsetsController(window, view)
          controller.isAppearanceLightStatusBars = !darkTheme
          controller.isAppearanceLightNavigationBars = !darkTheme
      }

   2. In the ``SuperheroesTheme()`` function, call the ``setUpEdgeToEdge()`` function from within
      the ``SideEffect`` block.

   .. code:: prettyprint

      fun SuperheroesTheme(
          darkTheme: Boolean = isSystemInDarkTheme(),
          // Dynamic color is available on Android 12+
          // Dynamic color in this app is turned off for learning purposes
          dynamicColor: Boolean = false,
          content: @Composable () -> Unit
      ) {
          //...
          val view = LocalView.current
          if (!view.isInEditMode) {
              SideEffect {
                  setUpEdgeToEdge(view, darkTheme)
              }
          }

          //...
      }

   ===================== =====================
   |319d310070d8f51.png| |2f152529c4cadcb1.png|
   ===================== =====================


6. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use this git command:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-superheroes.git

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-superheroes/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the downloaded repository.

   If you want to see the solution code, `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-superheroes>`__.

.. |319d310070d8f51.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-superheroes/img/319d310070d8f51.png
.. |2f152529c4cadcb1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-superheroes/img/2f152529c4cadcb1.png
.. |268233a1e2b3b407.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-superheroes/img/268233a1e2b3b407.png
.. |3b073896adfdcd7a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-superheroes/img/3b073896adfdcd7a.png
.. |6affe74f9559dc90.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-superheroes/img/6affe74f9559dc90.png
.. |af5116f770dd0ad.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-superheroes/img/af5116f770dd0ad.png
.. |2e8eeb35ac3e631b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-superheroes/img/2e8eeb35ac3e631b.png


ğŸš€ Project: Create a 30 Days App
=================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-30-days


1. Before you begin
--------------------------------------------------------------------------------


Prerequisites

   -  Ability to create and run a project in Android Studio.
   -  Experience with Kotlin syntax, collections, and classes.
   -  Ability to apply basic Jetpack Compose concepts.
   -  Experience with Compose layouts, ``Column``, and ``Row``.


What you'll build

   -  An Android app that can display multiple similar items in a scrollable list or grid.


What you'll need

   -  A computer with Android Studio installed.


2. Overview
--------------------------------------------------------------------------------

   Congratulations on reaching the end of Unit 3!

   To help reinforce what you learned in this unit, it is now your turn to use your new skills and
   abilities to create an app of your own!

   The general app guidelines are:

   -  Decide on a theme and create 30 tips related to this theme. One tip for each day of the month.
   -  At a minimum, each tip should contain relevant text and an image.
   -  The tips need to be displayed in a scrollable list (column or row) or a scrollable grid.
   -  Follow Material Design guidelines to create a distinct brand for the app.

   Make it unique! Make it special to you by showcasing what you learned! This is your chance to
   take an idea of your own from concept to reality.

   You should read this full project document before starting, as each section contains important
   information for building your app.

   We are sharing a screenshot of the user interface (UI) of our sample app so you have something to
   refer to, but use this opportunity to make an app your own by using your own imagery, text, and
   layout.

   Our sample app is titled "30 Days Of Wellness".

   |833cf0c0eda1eab7.png|

   We display a card for each day, with a tip in a scrollable column.

   Each card contains an indicator for the day of the month, a summary of the day's goal, an image,
   and additional text describing the goal for that day in detail.

   For styling, we chose a green color theme and the `Poppins font for the card's text. <https://fonts.google.com/specimen/Poppins>`__ 

   All photos by `Romain Guy <https://www.flickr.com/people/romainguy/>`__.


3. Decide on your app's theme, text, and images
--------------------------------------------------------------------------------


Decide on a theme

   Now it is your turn to decide on a theme for your app.

   What topic interests you and inspires you to create an app? If your topic is too broad, maybe a
   smaller subset of the topic would be suitable for the app's theme.

   If you are stuck, some potential themes are:

   -  Fitness theme - "30 Days of Fitness" with a different exercise for each day.
   -  Cooking theme - "30 Days of Recipes" with a different recipe for each day.
   -  Sewing theme - "30 Days of Sewing" with a different sewing skill for each day.


Decide on text and images

   The subject matter of your app is up to you. The cards can contain any images and text you want.
   This will help your project be unique among all the others.

   Gather or create the text and images you will use in your app.

   **Warning:** Don't use assets that you don't own, or have appropriate rights to use, for your
   app.


4. Decide on the layout for each tip and app
--------------------------------------------------------------------------------


Choose a layout for each tip

   On paper, sketch out some ideas on how you want to display each tip.

   Should the text be above or below the image? Do you prefer having the text and the image
   side-by-side?


Plan the layout for the app

   Now that you have an idea for how each tip will look, it is time to plan how the app will look
   displaying all your tips.

   Use a ``LazyColumn`` if your app displays a scrolling vertical list.

   Another design option to consider is a Lazy grid. 
   There are vertical versions (`LazyVerticalGrid <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/grid/package-summary#LazyVerticalGrid(androidx.compose.foundation.lazy.grid.GridCells,androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.grid.LazyGridState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__)
   and horizontal versions (`LazyHorizontalGrid <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/grid/package-summary#LazyHorizontalGrid(androidx.compose.foundation.lazy.grid.GridCells,androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.grid.LazyGridState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__),
   depending on how you choose to design your app.

   Be creative and choose the layout that's best for your app.


5. Material Design Considerations
--------------------------------------------------------------------------------

   Once you have sketched out your app idea, what colors, typography, and shaping would make it
   stand out?


Choose colors for your app

   Color is one way for your app to stand out. Using the `Material Design color system <https://m3.material.io/styles/color/the-color-system/key-colors-tones>`__ 
   as a reference, choose primary, secondary, and tertiary colors (if needed) that fit your app's aesthetic.

   It is also important to consider a color scheme for `dark theme <https://developer.android.google.cn/guide/topics/ui/look-and-feel/darktheme>`__. 
   This can be tested by `turning on dark theme <https://support.google.com/accessibility/android/answer/6151800>`__ 
   on your device.

   Feel free to use the `Material Theme Builder <https://m3.material.io/theme-builder#/custom>`__ 
   to experiment with your app's color palette. Material Theme Builder will determine appropriate
   colors for both a light theme and a dark theme.

   |989d8ef25da21a0b.png|


Choose fonts for your app

   Typography plays an important role in giving your app its distinct identity. The choice of font,
   whether it's serif or sans serif, cursive or block letters, bold or thin strokes, or even a
   combination, can add hierarchy to your app's content. You can use as many different styles of
   fonts for headers, text, captions, etc., but chances are you'll only need a few different
   variations of text. Somewhere between two and four different text styles should be all you need.

   If you're looking for a font with a specific look and feel, we recommend using `Google Fonts <https://fonts.google.com/>`__.
   There are over 1,000 font families to choose from, so you'll probably find something 
   that fits your app. Please check the license associated with the font before using it in your app.


Shapes

   Another design consideration is the shape of the widgets you display in your app.

   Do rounded corners accurately convey the feel of your app, or does a cut corner feel more
   appropriate?

   The Material Design documentation on `Shapes <https://m3.material.io/styles/shape/overview>`__
   has additional information that you might find useful while making these decisions.


6. Animations
--------------------------------------------------------------------------------

   You can use `animations <https://developer.android.google.cn/jetpack/compose/animation>`__ to
   convey meaningful motion in your app, such as navigation, or showing and hiding content. You may
   opt for an expandable card that shows a description for the selected item, or perhaps *touch &
   hold* an image to reveal additional text with a fade animation. These are just two examples, but
   how you incorporate animation into your app is entirely up to you.

   == ======================
   \  |1430320af109bfc7.gif|
   == ======================


7. Build your app
--------------------------------------------------------------------------------

   Once you've made your design decisions, it's time to build your app. This involves many of the
   Compose topics you learned in this unit. Even if you feel you've already learned each concept,
   it's not uncommon to refer back to the codelabs when trying to put them into practice.

   The following might be useful to you as you work on your project:

   -  Affirmations - `Codelab <https://developer.android.google.cn/codelabs/basic-android-compose-training-add-scrollable-list>`__,
      `Source Code <https://github.com/google-developer-training/basic-android-kotlin-compose-training-affirmations>`__
   -  Woof - `Codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-material-theming>`__,
      `Source Code <https://github.com/google-developer-training/basic-android-kotlin-compose-training-woof>`__

   Remember, this project gives you the opportunity to solidify your knowledge of Material Design
   and build UIs before moving on to the next unit.

.. |833cf0c0eda1eab7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-30-days/img/833cf0c0eda1eab7.png
.. |989d8ef25da21a0b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-30-days/img/989d8ef25da21a0b.png
.. |1430320af109bfc7.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-30-days/img/1430320af109bfc7.gif


ğŸš€ Stages of the Activity lifecycle
===================================

   https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-activity-lifecycle



1. Before you begin
--------------------------------------------------------------------------------

   In this codelab, you learn about a fundamental part of Android: the `activity lifecycle`.

   During its lifetime, an activity transitions through, and sometimes back to, various
   states. This transitioning of states is known as the activity lifecycle.

   In Android, an activity is the entry point for interacting with the user.

   In the past, one activity would display one screen in an app. With current best
   practices, one activity might display multiple screens by swapping them in and out as
   needed.

   The activity lifecycle extends from the creation of the activity to its destruction,
   when the system reclaims that activity's resources. As a user navigates in and out of an
   activity, each activity transitions between different states in the activity lifecycle.

   As an Android developer, you need to understand the activity lifecycle. If your
   activities do not correctly respond to lifecycle state changes, your app can generate
   strange bugs, confusing behavior for your users, or use too many Android system
   resources. Understanding the Android lifecycle and responding correctly to lifecycle
   state changes is an important part of Android development.


Prerequisites

   -  Knowledge of what an activity is and how to create one in your app
   -  Knowledge of what an activity's ``onCreate()`` method does and the kind of operations
      that are performed in that method


What you'll learn

   -  How to print logging information to the Logcat
   -  The basics of the ``Activity`` lifecycle and the callbacks that are invoked when the
      activity moves between states
   -  How to override lifecycle callback methods to perform operations at different times
      in the activity lifecycle


What you'll build

   -  Modify a starter app, called Dessert Clicker, to add logging information that's
      displayed in the Logcat.
   -  Override lifecycle callback methods and log changes to the activity state.
   -  Run the app and note the logging information that appears as the activity starts,
      stops, and resumes.
   -  Implement ``rememberSaveable`` to retain app data that may be lost if the device
      configuration changes.


2. App Overview
--------------------------------------------------------------------------------

   In this codelab, you work with a starter app called Dessert Clicker. In Dessert Clicker,
   each time the user taps a dessert on the screen, the app "purchases" the dessert for the
   user. The app updates values in the layout for the:

   -  Number of desserts that are "purchased"
   -  Total revenue for the "purchased" desserts

   |245d0bdfc09f4d54.png|

   This app contains several bugs related to the Android lifecycle. For example, in certain
   circumstances, the app resets the dessert values to 0. Understanding the Android
   lifecycle will help you understand why these problems happen and how to fix them.


**Download the starter code**

   In Android Studio, open the ``basic-android-kotlin-compose-training-dessert-clicker``
   folder.

   **Starter code URL:**
   `https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-clicker <https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-clicker/tree/starter>`__

   **Branch name:** ``starter``


3. Explore the lifecycle methods and add basic logging
--------------------------------------------------------------------------------

   Every activity has what is known as a *lifecycle*. This term is an allusion to plant and
   animal lifecycles, like the lifecycle of a butterflyâ€”the different states of the
   butterfly show its growth from egg to caterpillar to pupa to butterfly to death.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/2e74068b69dab83f.png

      Butterfly Lifecycle - growth from egg to caterpillar to pupa to butterfly to death.

   Similarly, the activity lifecycle consists of the different states that an activity can
   go through, from when the activity first initializes to its destruction, at which time
   the operating system (OS) reclaims its memory. Typically, the entry point of a program
   is the ``main()`` method. Android activities, however, begin with the ``onCreate()``
   method; this method would be the equivalent of the egg stage in the above example. You
   have used activities already, many times throughout this course, and you might recognize
   the ``onCreate()`` method. As the user starts your app, navigates between activities,
   navigates inside and outside of your app, the activity changes state.

   The following diagram shows all the activity lifecycle states. As their names indicate,
   these states represent the status of the activity. Notice that, unlike the butterfly
   lifecycle, an activity can go back and forth between states throughout the lifecycle,
   instead of only moving in a single direction.

   **Note:** An Android app can have multiple activities. However, it is recommended to
   have a single activity, and so far that is what you have been implementing in this
   course.

   |ca808edb1c95f07a.png|

   Often, you want to change some behavior, or run some code, when the activity lifecycle
   state changes. Therefore, the ``Activity`` class itself, and any subclasses of
   ``Activity`` such as ``ComponentActivity``, implement a set of lifecycle callback
   methods. Android invokes these callbacks when the activity moves from one state to
   another, and you can override those methods in your own activities to perform tasks in
   response to those lifecycle state changes. The following diagram shows the lifecycle
   states along with the available overridable callbacks.

   |The Activity Lifecycle scheme|

   **Note:** The asterisk on the ``onRestart()`` method indicates that this method is not
   called every time the state transitions between **Created** and **Started**. It is only
   called if ``onStop()`` was called and the activity is subsequently restarted.

   It's important to know when Android invokes the overridable callbacks and what to do in
   each callback method, but both of these diagrams are complex and can be confusing. In
   this codelab, instead of just reading what each state and callback means, you're going
   to do some detective work and build your understanding of the Android activity
   lifecycle.


Step 1: Examine the ``onCreate()`` method and add logging

   To figure out what's going on with the Android lifecycle, it's helpful to know when the
   various lifecycle methods are called. This information helps you identify where things
   are going wrong in the Dessert Clicker app.

   A simple way to determine this information is to use the Android logging functionality.
   Logging enables you to write short messages to a console while the app runs and use it
   to see when different callbacks are triggered.

   1. Run the Dessert Clicker app and tap several times on the picture of the dessert. Note
      how the value for **Desserts sold** and the total dollar amount changes.
   2. Open ``MainActivity.kt`` and examine the ``onCreate()`` method for this activity:

   .. code:: prettyprint

      override fun onCreate(savedInstanceState: Bundle?) {
          // ...
      }

   In the activity lifecycle diagram, you may recognize the ``onCreate()`` method, because
   you've used this callback before. It's the one method that every activity must
   implement. The ``onCreate()`` method is where you should do any one-time initializations
   for your activity. For example, in ``onCreate()``, you call ``setContent()``, which
   specifies the activity's UI layout.

   |The onCreate Lifecycle method|

   The ``onCreate()`` lifecycle method is called once, just after the activity
   *initializes*â€”when the OS creates the new ``Activity`` object in memory. After
   ``onCreate()`` executes, the activity is considered *created*.

   **Note:** When you override the ``onCreate()`` method, you must call the superclass
   implementation to complete the creation of the Activity, so within it, you must
   immediately call ``super.onCreate()``. The same is true for other lifecycle callback
   methods.

   3. Add the following constant at the top level of the ``MainActivity.kt``, above the
      class declaration ``class MainActivity``.

   A good convention is to declare a ``TAG`` constant in your file as its value will not
   change.

   To mark it as a compile-time constant, use ``const`` when declaring the variable. A
   compile-time constant is a value that is known during compilation.

   .. code:: prettyprint

      private const val TAG = "MainActivity"

   4. In the ``onCreate()`` method, just after the call to ``super.onCreate()``, add the
      following line:

   .. code:: prettyprint

      Log.d(TAG, "onCreate Called")

   5. Import the ``Log`` class, if necessary (press ``Alt+Enter``, or ``Option+Enter`` on a
      Mac, and select **Import**.) If you enabled auto imports, this should happen
      automatically.

   .. code:: prettyprint

      import android.util.Log

   The `Log <https://developer.android.google.cn/reference/kotlin/android/util/Log>`__
   class writes messages to the **Logcat**. The **Logcat** is the console for logging
   messages. Messages from Android about your app appear here, including the messages you
   explicitly send to the log with the ``Log.d()`` method or other ``Log`` class methods.

   There are three important aspects of the ``Log`` instruction:

   -  The **priority** of the log message, that is, how important the message is. In this
      case, the
      `Log.v() <https://developer.android.google.cn/reference/kotlin/android/util/Log#v_1>`__
      logs verbose messages.
      `Log.d() <https://developer.android.google.cn/reference/kotlin/android/util/Log#d>`__
      method writes a debug message. Other methods in the ``Log`` class include
      `Log.i() <https://developer.android.google.cn/reference/kotlin/android/util/Log#i_1>`__
      for informational messages,
      `Log.w() <https://developer.android.google.cn/reference/kotlin/android/util/Log#w(kotlin.String,%20kotlin.String)>`__
      for warnings, and
      `Log.e() <https://developer.android.google.cn/reference/kotlin/android/util/Log#e(kotlin.String,%20kotlin.String)>`__
      for error messages.
   -  The log ``tag`` (the first parameter), in this case ``"MainActivity"``. The tag is a
      string that lets you more easily find your log messages in the Logcat. The tag is
      typically the name of the class.
   -  The actual log message, called ``msg`` (the second parameter), is a short string,
      which in this case is ``"onCreate Called"``.

   |a4ff4aa74384ff6.png|

   6. Compile and run the Dessert Clicker app. You don't see any behavior differences in
      the app when you tap the dessert. In Android Studio, at the bottom of the screen,
      click the **Logcat** tab.

   |cedcce52592c6665.png|

   7. In the **Logcat** window, type ``tag:MainActivity`` into the search field.

   |37080c4e00561b0.png|

   The Logcat can contain many messages, most of which aren't useful to you. You can filter
   the Logcat entries in many ways, but searching is the easiest. Because you used
   ``MainActivity`` as the log tag in your code, you can use that tag to filter the log.
   Your log message includes the date and time, your log tag, the name of the package
   (``com.example.dessertclicker``), and the actual message. Because this message appears
   in the log, you know that ``onCreate()``\ was executed.


Step 2: Implement the ``onStart()`` method

   The ``onStart()`` lifecycle method is called just after ``onCreate()``. After
   ``onStart()`` runs, your activity is visible on the screen. Unlike ``onCreate()``, which
   is called only once to initialize your activity, ``onStart()``\ can be called by the
   system many times in the lifecycle of your activity.

   |a357d2291de472d9.png|

   Note that ``onStart()``\ is paired with a corresponding ``onStop()``\ lifecycle method.
   If the user starts your app and then returns to the device's home screen, the activity
   is stopped and is no longer visible on screen.

   1. In Android Studio, with ``MainActivity.kt`` open and the cursor within the
      ``MainActivity`` class, select **Code > Override Methods...** or press ``Control+O``.
      A dialog appears with a long list of all the methods you can override in this class.

   |20c34cbad8dce892.png|

   2. Start entering ``onStart`` to search for the correct method. To scroll to the next
      matching item, use the down arrow. Choose ``onStart()``\ from the list and click
      **OK** to insert the boilerplate override code. The code looks like the following
      example:

   .. code:: prettyprint

      override fun onStart() {
          super.onStart()
      }

   3. Inside the ``onStart()``\ method, add a log message:

   .. code:: prettyprint

      override fun onStart() {
          super.onStart()
          Log.d(TAG, "onStart Called")
      }

   4. Compile and run the Dessert Clicker app and open the **Logcat** pane.
   5. Type ``tag:MainActivity`` into the search field to filter the log. Notice that both
      the ``onCreate()``\ and ``onStart()``\ methods were called one after the other, and
      that your activity is visible on screen.
   6. Press the **Home** button on the device and then use the Recents screen to return to
      the activity. Notice that the activity resumes where it left off, with all the same
      values, and that ``onStart()`` is logged a second time to Logcat. Notice also that
      the ``onCreate()`` method is not called again.

   ::

      2024-04-26 14:54:48.721  5386-5386  MainActivity            com.example.dessertclicker           D  onCreate Called
      2024-04-26 14:54:48.756  5386-5386  MainActivity            com.example.dessertclicker           D  onStart Called
      2024-04-26 14:55:41.674  5386-5386  MainActivity            com.example.dessertclicker           D  onStart Called

   **Note:** As you experiment with your device and observe the lifecycle callbacks, you
   might notice unusual behavior when you rotate your device. You'll learn about that
   behavior later in this codelab.


Step 3: Add more log statements

   In this step, you implement logging for all the other lifecycle methods.

   1. Override the remainder of the lifecycle methods in your ``MainActivity`` and add log
      statements for each one, as shown in the following code:

   .. code:: prettyprint

      override fun onResume() {
          super.onResume()
          Log.d(TAG, "onResume Called")
      }

      override fun onRestart() {
          super.onRestart()
          Log.d(TAG, "onRestart Called")
      }

      override fun onPause() {
          super.onPause()
          Log.d(TAG, "onPause Called")
      }

      override fun onStop() {
          super.onStop()
          Log.d(TAG, "onStop Called")
      }

      override fun onDestroy() {
          super.onDestroy()
          Log.d(TAG, "onDestroy Called")
      }

   2. Compile and run Dessert Clicker again and examine Logcat.

   Notice that this time, in addition to ``onCreate()`` and ``onStart()``, there's a log
   message for the ``onResume()`` lifecycle callback.

   ::

      2024-04-26 14:56:48.684  5484-5484  MainActivity            com.example.dessertclicker           D  onCreate Called
      2024-04-26 14:56:48.709  5484-5484  MainActivity            com.example.dessertclicker           D  onStart Called
      2024-04-26 14:56:48.713  5484-5484  MainActivity            com.example.dessertclicker           D  onResume Called

   When an activity starts from the beginning, you see all three of these lifecycle
   callbacks called in order:

   -  ``onCreate()`` when the system creates the app.
   -  ``onStart()`` makes the app visible on the screen, but the user is not yet able to
      interact with it.
   -  ``onResume()`` brings the app to the foreground, and the user is now able to interact
      with it.

   Despite the name, the ``onResume()`` method is called at startup, even if there is
   nothing to resume.

   |2678d691f608762a.png|


4. Explore lifecycle use cases
--------------------------------------------------------------------------------

   Now that you have set up the Dessert Clicker app for logging, you're ready to start
   using the app and exploring how lifecycle callbacks are triggered.


Use case 1: Opening and closing the activity

   You start with the most basic use case, which is to start your app for the first time
   and then close the app.

   1. Compile and run the Dessert Clicker app, if it is not already running. As you've
      seen, the ``onCreate()``, ``onStart()``, and ``onResume()`` callbacks are called when
      the activity starts for the first time.

   ::

      2024-04-26 14:56:48.684  5484-5484  MainActivity            com.example.dessertclicker           D  onCreate Called
      2024-04-26 14:56:48.709  5484-5484  MainActivity            com.example.dessertclicker           D  onStart Called
      2024-04-26 14:56:48.713  5484-5484  MainActivity            com.example.dessertclicker           D  onResume Called

   2. Tap the cupcake a few times.
   3. Tap the **Back** button on the device.

   Notice in Logcat that ``onPause()`` and ``onStop()`` are called in that order.

   ::

      2024-04-26 14:58:19.984  5484-5484  MainActivity            com.example.dessertclicker           D  onPause Called
      2024-04-26 14:58:20.491  5484-5484  MainActivity            com.example.dessertclicker           D  onStop Called
      2024-04-26 14:58:20.517  5484-5484  MainActivity            com.example.dessertclicker           D  onDestroy Called

   In this case, using the **Back** button causes the activity (and the app) to be removed
   from the screen and moved to the back of the activity stack.

   The Android OS might close your activity if your code manually calls the activity's
   `finish() <https://developer.android.google.cn/reference/android/app/Activity.html#finish()>`__
   method or if the user force-quits the app. For example, the user can force-quit or close
   the app in the Recents screen. The OS might also shut down your activity on its own if
   your app has not been onscreen for a long time. Android does so to preserve battery life
   and to reclaim the resources the app was using so they are available to other apps.
   These are just a few examples of why the Android system destroys your activity. There
   are additional cases when the Android system destroys your activity without providing a
   warning.

   **Note:** ``onCreate()`` and ``onDestroy()``, which this codelab teaches later, are only
   called once during the lifetime of a single activity instance: ``onCreate()`` to
   initialize the app for the very first time, and ``onDestroy()`` to nullify, close, or
   destroy objects that the activity may have been using so that they don't continue to use
   resources, like memory.


Use case 2: Navigating away from and back to the activity

   Now that you've started the app and closed it, you've seen most of the lifecycle states
   for when the activity gets created for the first time. You've also seen most of the
   lifecycle states that the activity goes through when it gets closed. But as users
   interact with their Android devices, they switch between apps, return home, start new
   apps, and handle interruptions by other activities such as phone calls.

   Your activity does not close down entirely every time the user navigates away from that
   activity:

   -  When your activity is no longer visible on screen, the status is known as putting the
      activity into the *background*. The opposite of this is when the activity is in the
      *foreground*, or onscreen.
   -  When the user returns to your app, that same activity is restarted and becomes
      visible again. This part of the lifecycle is called the app's *visible* lifecycle.

   When your app is in the background, it generally should not be actively running to
   preserve system resources and battery life. You use the ``Activity`` lifecycle and its
   callbacks to know when your app is moving to the background so that you can pause any
   ongoing operations. You then restart the operations when your app comes into the
   foreground.

   In this step, you look at the activity lifecycle when the app goes into the background
   and returns again to the foreground.

   1. With the Dessert Clicker app running, click the cupcake a few times.
   2. Press the **Home** button on your device and observe the Logcat in Android Studio.
      Returning to the home screen puts your app into the background, rather than shutting
      down the app altogether. Notice that the ``onPause()`` and ``onStop()`` methods are
      called.

   ::

      2024-04-26 15:00:04.905  5590-5590  MainActivity            com.example.dessertclicker           D  onPause Called
      2024-04-26 15:00:05.430  5590-5590  MainActivity            com.example.dessertclicker           D  onStop Called

   When ``onPause()`` is called, the app no longer has focus. After ``onStop()``, the app
   is no longer visible on screen. Although the activity is stopped, the ``Activity``
   object is still in memory in the background. The Android OS has not destroyed the
   activity. The user might return to the app, so Android keeps your activity resources
   around.

   |c470ee28ab7f8a1a.png|

   3. Use the Recents screen to return to the app. On the emulator, the Recents screen can
      be accessed by the square system button shown in the image below.

   Notice in Logcat that the activity restarts with ``onRestart()`` and ``onStart()`` and
   then resumes with ``onResume()``.

   |bc156252d977e5ae.png|

   **Note**: ``onRestart()`` is only called by the system if the activity has already been
   created and eventually enters the **Created** state when ``onStop()`` is called, but
   returns back to the **Started** state instead of entering the **Destroyed** state. The
   ``onRestart()`` method is a place to put code that you only want to call if your
   activity is **not** being started for the first time.

   ::

      2024-04-26 15:00:39.371  5590-5590  MainActivity            com.example.dessertclicker           D  onRestart Called
      2024-04-26 15:00:39.372  5590-5590  MainActivity            com.example.dessertclicker           D  onStart Called
      2024-04-26 15:00:39.374  5590-5590  MainActivity            com.example.dessertclicker           D  onResume Called

   When the activity returns to the foreground, the ``onCreate()`` method is not called
   again. The activity object was not destroyed, so it doesn't need to be created again.
   Instead of ``onCreate()``, the ``onRestart()`` method is called. Notice that this time
   when the activity returns to the foreground, the **Desserts sold** number is retained.

   4. Start at least one app other than Dessert Clicker so that the device has a few apps
      in its Recents screen.
   5. Bring up the Recents screen and open another recent activity. Then go back to recent
      apps and bring Dessert Clicker back to the foreground.

   Notice that you see the same callbacks in Logcat here as when you pressed the **Home**
   button. ``onPause()`` and ``onStop()`` are called when the app goes into the background,
   and then ``onRestart()``, ``onStart()``, and ``onResume()`` are called when it comes
   back.

   **Note:** ``onStart()`` and ``onStop()`` are called multiple times as the user navigates
   to and from the activity.

   These methods are called when the app stops and moves into the background or when the
   app restarts and returns to the foreground. If you need to do some work in your app
   during these cases, then override the relevant lifecycle callback method.


Use case 3: Partially hide the activity

   You've learned that when an app is started and ``onStart()`` is called, the app becomes
   visible on the screen. When ``onResume()`` is called, the app gains the user focusâ€“that
   is, the user can interact with the app. The part of the lifecycle in which the app is
   fully onscreen and has user focus is called the 
   `foreground lifetime <https://developer.android.google.cn/reference/android/app/Activity#activity-lifecycle>`__.

   When the app goes into the background, the focus is lost after ``onPause()``, and the
   app is no longer visible after ``onStop()``.

   The difference between focus and visibility is important. An activity can be *partially*
   visible on the screen but not have the user focus. In this step, you look at one case in
   which an activity is partially visible but doesn't have user focus.

   1. With the Dessert Clicker app running, click the **Share** button in the top right of
      the screen.

   The sharing activity appears in the lower half of the screen, but the activity is still
   visible in the top half.

   |677c190d94e57447.png|\ |ca6285cbbe3801cf.png|

   2. Examine Logcat and note that only ``onPause()`` was called.

   ::

      2024-04-26 15:01:49.535  5590-5590  MainActivity            com.example.dessertclicker           D  onPause Called

   In this use case, ``onStop()`` is not called because the activity is still partially
   visible. But the activity does not have user focus, and the user can't interact with
   itâ€”the "share" activity that's in the foreground has the user focus.

   Why is this difference important? The interruption with only ``onPause()`` usually lasts
   a short time before returning to your activity or navigating to another activity or app.
   You generally want to keep updating the UI so the rest of your app doesn't appear to
   freeze.

   Whatever code runs in ``onPause()`` blocks other things from displaying, so keep the
   code in ``onPause()`` lightweight. For example, if a phone call comes in, the code in
   ``onPause()`` may delay the incoming-call notification.

   3. Click outside the share dialog to return to the app, and notice that ``onResume()``
      is called.

   Both ``onResume()`` and ``onPause()`` have to do with focus. The ``onResume()`` method
   is called when the activity gains focus, and ``onPause()`` is called when the activity
   loses focus.


5. Explore configuration changes
--------------------------------------------------------------------------------

   There's another case in managing the activity lifecycle that is important to understand:
   how configuration changes affect the lifecycle of your activities.

   A *configuration change* occurs when the state of the device changes so radically that
   the easiest way for the system to resolve the change is to completely shut down and
   rebuild the activity. For example, if the user changes the device language, the whole
   layout might need to change to accommodate different text directions and string lengths.
   If the user plugs the device into a dock or adds a physical keyboard, the app layout may
   need to take advantage of a different display size or layout. And if the device
   orientation changesâ€”if the device is rotated from portrait to landscape or back the
   other wayâ€”the layout might need to change to fit the new orientation. Let's look at how
   the app behaves in this scenario.

   The last lifecycle callback to demonstrate is ``onDestroy()``, which is called after
   ``onStop()``. It is called just before the activity is destroyed. This can happen when
   the app's code calls ``finish()``, or the system needs to destroy and recreate the
   activity because of a configuration change.


Configuration change causes ``onDestroy()`` to be called

   Screen rotation is one type of a configuration change that causes the activity to
   shutdown and restart. To simulate this configuration change and examine its effects,
   complete the following steps:

   1. Compile and run your app.
   2. Ensure the screen rotation lock in the emulator is disabled.
   3. Rotate the device or emulator to landscape mode. You can rotate the emulator left or
      right with the rotation buttons.
   4. Examine Logcat and understand that as the activity shuts down, it calls
      ``onPause()``, ``onStop()``, and ``onDestroy()``, in that order.

   ::

      2024-04-26 15:03:32.183  5716-5716  MainActivity            com.example.dessertclicker           D  onPause Called
      2024-04-26 15:03:32.185  5716-5716  MainActivity            com.example.dessertclicker           D  onStop Called
      2024-04-26 15:03:32.205  5716-5716  MainActivity            com.example.dessertclicker           D  onDestroy Called


Data loss on device rotation

   1. Compile and run your app and open Logcat.
   2. Click the cupcake a few times and note that the desserts sold and total revenue are
      not zero.
   3. Ensure the screen rotation lock in the emulator is disabled.
   4. Rotate the device or emulator to landscape mode. You can rotate the emulator left or
      right with the rotation buttons.

   |11c9d83a11651608.png|

   5. Examine the output in Logcat. Filter the output on ``MainActivity``.

   ::

      2024-04-26 15:04:29.356  5809-5809  MainActivity            com.example.dessertclicker           D  onCreate Called
      2024-04-26 15:04:29.378  5809-5809  MainActivity            com.example.dessertclicker           D  onStart Called
      2024-04-26 15:04:29.382  5809-5809  MainActivity            com.example.dessertclicker           D  onResume Called
      2024-04-26 15:06:52.168  5809-5809  MainActivity            com.example.dessertclicker           D  onPause Called
      2024-04-26 15:06:52.183  5809-5809  MainActivity            com.example.dessertclicker           D  onStop Called
      2024-04-26 15:06:52.219  5809-5809  MainActivity            com.example.dessertclicker           D  onDestroy Called
      2024-04-26 15:06:52.302  5809-5809  MainActivity            com.example.dessertclicker           D  onCreate Called
      2024-04-26 15:06:52.308  5809-5809  MainActivity            com.example.dessertclicker           D  onStart Called
      2024-04-26 15:06:52.312  5809-5809  MainActivity            com.example.dessertclicker           D  onResume Called

   Notice that when the device or emulator rotates the screen, the system calls all the
   lifecycle callbacks to shut down the activity. Then, as the activity is re-created, the
   system calls all the lifecycle callbacks to start the activity.

   When the device is rotated, and the activity is shut down and re-created, the activity
   re-starts with default valuesâ€”the dessert image, number of desserts sold, and total
   revenue reset back to zero.

   To learn why these values are being reset and how to correct them, you need to learn
   about the lifecycle of a composable and how it knows to observe and retain its state.


Lifecycle of a composable

   The UI of your app is initially built from running composable functions in a process
   called Composition.

   When the state of your app changes, a recomposition is scheduled. Recomposition is when
   Compose re-executes the composable functions whose state might have changed and creates
   an updated UI. The Composition is updated to reflect these changes.

   The only way to create or update a Composition is by its initial composition and
   subsequent recompositions.

   Composable functions have their own lifecycle that is independent of the Activity
   lifecycle. Its lifecycle is composed of the events: enters the Composition, recomposing
   0 or more times, and then leaving the Composition.

   In order for Compose to track and trigger a recomposition, it needs to know when state
   has changed. To indicate to Compose that it should track an object's state, the object
   needs to be of type
   `State <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/State>`__
   or
   `MutableState <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/MutableState>`__.
   The ``State`` type is immutable and can only be read. A ``MutableState`` type is mutable
   and allows reads and writes.

   You have already seen and used ``MutableState`` in the `Lemonade
   app <https://github.com/google-developer-training/basic-android-kotlin-compose-training-lemonade>`__
   and the `Tip Time
   app <https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator>`__
   in prior codelabs.

   To create the mutable variable ``revenue``, you declare it using ``mutableStateOf``.
   ``0`` is its initial default value.

   .. code:: prettyprint

      var revenue = mutableStateOf(0)

   While this is enough to have Compose trigger a recomposition when the revenue value
   changes, it is not enough to retain its updated value. Each time the composable is
   reexecuted, it will reinitialize the revenue value to its initial default value of
   ``0``.

   To instruct Compose to retain and reuse its value during recompositions, you need to
   declare it with the ``remember`` API.

   .. code:: prettyprint

      var revenue by remember { mutableStateOf(0) }

   If the value of ``revenue`` changes, Compose schedules all composable functions that
   read this value for recomposition.

   While Compose remembers the revenue state during recompositions, it does not retain this
   state during a configuration change. For Compose to retain the state during a
   configuration change, you must use ``rememberSaveable``.

   For additional practice and information, please refer to 
   `Intro to state in Compose <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-using-state>`__
   codelab.


Use ``rememberSaveable`` to save values across configuration changes

   You use the ``rememberSaveable`` function to save values that you need if Android OS
   destroys and recreates the activity.

   To save values during recompositions, you need to use ``remember``. Use
   ``rememberSaveable`` to save values during recompositions AND configuration changes.

   **Note:** Sometimes Android shuts down an entire app process, which includes every
   activity associated with the app. Android does this kind of shutdown when the system is
   stressed and in danger of visually lagging, so no additional callbacks or code is run at
   this point. Your app's process is simply shut down silently in the background. But to
   the user, it doesn't look like the app is closed. When the user navigates back to an app
   that the Android system shuts down, Android restarts that app. You want to ensure that
   the user doesn't experience any data loss when this happens.

   Saving the value using ``rememberSaveable`` ensures that it is available when the
   activity is restored, if it is needed.

   1. In ``MainActivity``, update the group of five variables that currently use
      ``remember`` to ``rememberSaveable``.

   .. code:: prettyprint

      var revenue by remember { mutableStateOf(0) }
      ...
      var currentDessertImageId by remember {
          mutableStateOf(desserts[currentDessertIndex].imageId)
      }

   .. code:: prettyprint

      var revenue by rememberSaveable { mutableStateOf(0) }
      ...
      var currentDessertImageId by rememberSaveable {
          mutableStateOf(desserts[currentDessertIndex].imageId)
      }

   2. Compile and run your app.
   3. Click the cupcake a few times and note that the desserts sold and total revenue are
      not zero.
   4. Rotate the device or emulator to landscape mode.
   5. Observe that after the activity is destroyed and recreated, the dessert image,
      desserts sold, and total revenue are restored to their previous values.


6. Solution code
--------------------------------------------------------------------------------

   **Solution code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-clicker
   
   **Branch name:** ``main``


7. Summary
--------------------------------------------------------------------------------


Activity lifecycle

   -  The *activity lifecycle* is a set of states through which an activity transitions.
      The activity lifecycle begins when the Android OS first creates the activity and ends
      when the OS destroys the activity.
   -  As the user navigates between activities, and inside and outside of your app, each
      activity moves between states in the activity lifecycle.
   -  Each state in the activity lifecycle has a corresponding callback method you can
      override in your ``Activity`` class. The core set of lifecycle methods are:
      `onCreate() <https://developer.android.google.cn/reference/android/app/Activity.html#onCreate(android.os.Bundle)>`__,
      `onRestart() <https://developer.android.google.cn/reference/android/app/Activity.html#onRestart()>`__,
      `onStart() <https://developer.android.google.cn/reference/android/app/Activity.html#onStart()>`__,
      `onResume() <https://developer.android.google.cn/reference/android/app/Activity.html#onResume()>`__,
      `onPause() <https://developer.android.google.cn/reference/android/app/Activity.html#onPause()>`__,
      `onStop() <https://developer.android.google.cn/reference/android/app/Activity.html#onStop()>`__,
      `onDestroy() <https://developer.android.google.cn/reference/android/app/Activity.html#onDestroy()>`__.
   -  To add behavior that occurs when your activity transitions into a lifecycle state,
      override the state's callback method.
   -  To add skeleton override methods to your classes in Android Studio, select **Code >
      Override Methods...** or press ``Control+O``.


Logging with Log

   -  The Android logging API, and specifically the
      `Log <https://developer.android.google.cn/reference/android/util/Log>`__ class,
      enables you to write short messages that are displayed in the Logcat within Android
      Studio.
   -  Use ``Log.d()`` to write a debug message. This method takes two arguments: the log
      *tag*, typically the name of the class, and the log *message*, a short string.
   -  Use the **Logcat** window in Android Studio to view the system logs, including the
      messages you write.


Configuration changes

   -  A *configuration change* occurs when the state of the device changes so radically
      that the easiest way for the system to resolve the change is to destroy and rebuild
      the activity.
   -  The most common example of a configuration change is when the user rotates the device
      from portrait to landscape mode, or from landscape to portrait mode. A configuration
      change can also occur when the device language changes or a user plugs in a hardware
      keyboard.
   -  When a configuration change occurs, Android invokes all the activity lifecycle's
      shutdown callbacks. Android then restarts the activity from scratch, running all the
      lifecycle startup callbacks.
   -  When Android shuts down an app because of a configuration change, it restarts the
      activity with ``onCreate()``.
   -  To save a value that needs to survive a configuration change, declare its variables
      with ``rememberSaveable``.


Learn more

   -  `Log <https://developer.android.google.cn/reference/android/util/Log>`__ class
   -  `View logs with Logcat <https://developer.android.google.cn/studio/debug/am-logcat>`__
   -  `Saveable API <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/package-summary>`__
   -  `Activity class <https://developer.android.google.cn/reference/android/app/Activity.html>`__
   -  `ComponentActivity class <https://developer.android.google.cn/reference/androidx/activity/ComponentActivity>`__
   -  `Activity Developer Guide <https://developer.android.google.cn/guide/components/activities/intro-activities#kotlin>`__

.. |245d0bdfc09f4d54.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/245d0bdfc09f4d54.png
.. |ca808edb1c95f07a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/ca808edb1c95f07a.png
.. |The Activity Lifecycle scheme| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/468988518c270b38.png
.. |The onCreate Lifecycle method| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/e3bc14c112d5363b.png
.. |a4ff4aa74384ff6.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/a4ff4aa74384ff6.png
.. |cedcce52592c6665.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/cedcce52592c6665.png
.. |37080c4e00561b0.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/37080c4e00561b0.png
.. |a357d2291de472d9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/a357d2291de472d9.png
.. |20c34cbad8dce892.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/20c34cbad8dce892.png
.. |2678d691f608762a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/2678d691f608762a.png
.. |c470ee28ab7f8a1a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/c470ee28ab7f8a1a.png
.. |bc156252d977e5ae.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/bc156252d977e5ae.png
.. |677c190d94e57447.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/677c190d94e57447.png
.. |ca6285cbbe3801cf.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/ca6285cbbe3801cf.png
.. |11c9d83a11651608.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-activity-lifecycle/img/11c9d83a11651608.png


ğŸš€ ViewModel and State in Compose
==================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-viewmodel-and-state


1. Before you begin
--------------------------------------------------------------------------------

   In the previous codelabs, you learned about the lifecycle of activities and the related
   lifecycle issues with configuration changes. When a configuration change occurs, you can
   save an app's data through different ways, such as using ``rememberSaveable`` or saving
   the instance state. However, these options can create problems. Most of the time, you
   can use ``rememberSaveable`` but that might mean keeping the logic in or near
   composables. When apps grow, you should move data and logic away from composables. In
   this codelab, you will learn about a robust way to design your app and preserve app data
   during configuration changes by taking advantage of the Android Jetpack library,
   ``ViewModel`` and Android app architecture guidelines.

   `Android Jetpack <https://developer.android.google.cn/jetpack>`__ libraries are a
   collection of libraries to make it easier for you to develop great Android apps. These
   libraries help you follow best practices, free you from writing boilerplate code, and
   simplify complex tasks so that you can focus on the code you care about, like the app
   logic.

   *App architecture* is a set of design rules for an app. Much like the blueprint of a
   house, your architecture provides the structure for your app. A good app architecture
   can make your code robust, flexible, scalable, testable, and maintainable for years to
   come. The `Guide to app architecture <https://developer.android.google.cn/topic/libraries/architecture>`__
   provides recommendations on app architecture and recommended best practices.

   In this codelab, you learn how to use ViewModel_,
   one of the architecture components from Android Jetpack libraries that can store your
   app data. The stored data is not lost if the framework destroys and recreates the
   activities during a configuration change or other events. However, the data is lost if
   the activity is destroyed because of process death. The ``ViewModel`` only caches data
   through quick activity recreations.

.. _ViewModel: https://developer.android.google.cn/topic/libraries/architecture/viewmodel

Prerequisites

   -  Knowledge of Kotlin, including functions, lambdas, and stateless composables
   -  Basic knowledge of how to build layouts in Jetpack Compose
   -  Basic knowledge of Material Design


What you'll learn

   -  Introduction to the `Android app architecture <https://developer.android.google.cn/topic/architecture#recommended-app-arch>`__
   -  How to use the ViewModel_ class in your app
   -  How to retain UI data through device configuration changes using a ViewModel_


What you'll build

   -  An `Unscramble <https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble>`__
      game app where the user can guess the scrambled words


What you'll need

   -  The latest version of Android Studio
   -  An internet connection to download starter code


2. App overview
--------------------------------------------------------------------------------


Game overview

   The Unscramble app is a single player word scrambler game. The app displays a scrambled
   word, and the player has to guess the word using all the letters shown. The player
   scores points if the word is correct. Otherwise, the player can try to guess the word
   any number of times. The app also has an option to skip the current word. In the top
   right corner, the app displays the word count, which is the number of scrambled words
   played in the current game. There are 10 scrambled words per game.

   ====================== ====================== ======================
   |ac79bf1ed6375a27.png| |a1bc55781d627b38.png| |c6727347fe0db265.png|
   ====================== ====================== ======================


**Get the starter code**

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble/archive/refs/heads/starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   .. code:: bash

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble.git
      $ cd basic-android-kotlin-compose-training-unscramble
      $ git checkout starter

   **Note:** The starter code is in the ``starter`` branch of the downloaded repository.

   You can browse the starter code in the
   `Unscramble <https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble/tree/starter>`__
   GitHub repository.


3. Starter app overview
--------------------------------------------------------------------------------

   To familiarize yourself with the starter code, complete the following steps:

   1. Open the project with the starter code in Android Studio.
   2. Run the app on an Android device or an emulator.
   3. Tap the **Submit** and **Skip** buttons to test the app.

   You will notice bugs in the app. The scrambled word does not display, but it is
   hardcoded to "scrambleun" and nothing happens when you tap the buttons.

   In this codelab, you will implement the game functionality using the Android app
   architecture.


Starter code walk through

   The starter code has the pre-designed game screen layout for you. In this pathway, you
   will implement the game logic. You will use architecture components to implement the
   recommended app architecture and resolve the above-mentioned issues. Here is a brief
   walkthrough of some files to get you started.

   **WordsData.kt**

   This file contains a list of the words used in the game, constants for the maximum
   number of words per game, and the number of points the player scores for every correct
   word.

   .. code:: prettyprint

      package com.example.android.unscramble.data

      const val MAX_NO_OF_WORDS = 10
      const val SCORE_INCREASE = 20

      // Set with all the words for the Game
      val allWords: Set<String> =
         setOf(
             "animal",
             "auto",
             "anecdote",
             "alphabet",
             "all",
             "awesome",
             "arise",
             "balloon",
             "basket",
             "bench",
            // ...
             "zoology",
             "zone",
             "zeal"
      )

   **WARNING**: It is not a recommended practice to hardcode strings in the code. Add
   strings to ``strings.xml`` for easier localization. Strings are hardcoded in this
   example app for simplicity and to enable you to focus on the app architecture.

   **MainActivity.kt**

   This file contains mostly template generated code. You display the ``GameScreen``
   composable in the ``setContent{}`` block.

   **GameScreen.kt**

   All the UI composables are defined in the **``GameScreen.kt``** file. The following
   sections provide a walkthrough of some composable functions.

   **GameStatus**

   ``GameStatus`` is a composable function that displays the game score at the bottom of
   the screen. The composable function contains a text composable in a ``Card``. For now,
   the score is hardcoded to ``0``.

   |1a7e4472a5638d61.png|

   .. code:: prettyprint

      // No need to copy, this is included in the starter code.

      @Composable
      fun GameStatus(score: Int, modifier: Modifier = Modifier) {
          Card(
              modifier = modifier
          ) {
              Text(
                  text = stringResource(R.string.score, score),
                  style = typography.headlineMedium,
                  modifier = Modifier.padding(8.dp)
              )
          }
      }

   **GameLayout**

   ``GameLayout`` is a composable function that displays the main game functionality, which
   includes the scrambled word, the game instructions, and a text field that accepts the
   user's guesses.

   |b6ddb1f07f10df0c.png|

   Notice the ``GameLayout`` code below contains a column inside a ``Card`` with three
   child elements: the scrambled word text, the instructions text, and the text field for
   the user's word ``OutlinedTextField``. For now, the scrambled word is hardcoded to be
   ``scrambleun``. Later in the codelab, you will implement functionality to display a word
   from the ``WordsData.kt`` file.

   .. code:: prettyprint

      // No need to copy, this is included in the starter code.

      @Composable
      fun GameLayout(modifier: Modifier = Modifier) {
         val mediumPadding = dimensionResource(R.dimen.padding_medium)
         Card(
             modifier = modifier,
             elevation = CardDefaults.cardElevation(defaultElevation = 5.dp)
         ) {
             Column(
                 verticalArrangement = Arrangement.spacedBy(mediumPadding),
                 horizontalAlignment = Alignment.CenterHorizontally,
                 modifier = Modifier.padding(mediumPadding)
             ) {
                 Text(
                     modifier = Modifier
                         .clip(shapes.medium)
                         .background(colorScheme.surfaceTint)
                         .padding(horizontal = 10.dp, vertical = 4.dp)
                         .align(alignment = Alignment.End),
                     text = stringResource(R.string.word_count, 0),
                     style = typography.titleMedium,
                     color = colorScheme.onPrimary
                 )
                 Text(
                     text = "scrambleun",
                     style = typography.displayMedium
                 )
                 Text(
                     text = stringResource(R.string.instructions),
                     textAlign = TextAlign.Center,
                     style = typography.titleMedium
                 )
                 OutlinedTextField(
                     value = "",
                     singleLine = true,
                     shape = shapes.large,
                     modifier = Modifier.fillMaxWidth(),
                     colors = TextFieldDefaults.textFieldColors(containerColor = colorScheme.surface),
                     onValueChange = { },
                     label = { Text(stringResource(R.string.enter_your_word)) },
                     isError = false,
                     keyboardOptions = KeyboardOptions.Default.copy(
                         imeAction = ImeAction.Done
                     ),
                     keyboardActions = KeyboardActions(
                         onDone = { }
                     )
                 )
             }
         }
      }

   The ``OutlinedTextField`` composable is similar to the ``TextField`` composable from
   apps in previous codelabs.

   Text fields come in two types:

   -  Filled text fields
   -  Outlined text fields

   |3df34220c3d177eb.png|

   Outlined text fields have less visual emphasis than filled text fields. When they appear
   in places like forms, where many text fields are placed together, their reduced emphasis
   helps simplify the layout.

   In the starter code, the ``OutlinedTextField`` does not update when the user enters a
   guess. You will update this feature in the codelab.

   **GameScreen**

   The ``GameScreen`` composable contains the ``GameStatus`` and ``GameLayout`` composable
   functions, game title, word count and the composables for the **Submit** and **Skip**
   buttons.

   |ac79bf1ed6375a27.png|

   .. code:: prettyprint

      @Composable
      fun GameScreen() {
          val mediumPadding = dimensionResource(R.dimen.padding_medium)

          Column(
              modifier = Modifier
                  .verticalScroll(rememberScrollState())
                  .padding(mediumPadding),
              verticalArrangement = Arrangement.Center,
              horizontalAlignment = Alignment.CenterHorizontally
          ) {

              Text(
                  text = stringResource(R.string.app_name),
                  style = typography.titleLarge,
              )

              GameLayout(
                  modifier = Modifier
                      .fillMaxWidth()
                      .wrapContentHeight()
                      .padding(mediumPadding)
              )
              Column(
                  modifier = Modifier
                      .fillMaxWidth()
                      .padding(mediumPadding),
                  verticalArrangement = Arrangement.spacedBy(mediumPadding),
                  horizontalAlignment = Alignment.CenterHorizontally
              ) {

                  Button(
                      modifier = Modifier.fillMaxWidth(),
                      onClick = { }
                  ) {
                      Text(
                          text = stringResource(R.string.submit),
                          fontSize = 16.sp
                      )
                  }

                  OutlinedButton(
                      onClick = { },
                      modifier = Modifier.fillMaxWidth()
                  ) {
                      Text(
                          text = stringResource(R.string.skip),
                          fontSize = 16.sp
                      )
                  }
              }

              GameStatus(score = 0, modifier = Modifier.padding(20.dp))
          }
      }

   Button click events are not implemented in the starter code. You will implement these
   events as part of the codelab.

   **FinalScoreDialog**

   The ``FinalScoreDialog`` composable displays a dialogâ€“that is, a small window that
   prompts the userâ€“with options to **Play Again** or **Exit** the game. Later in this
   codelab, you will implement logic to display this dialog at the end of the game.

   |dba2d9ea62aaa982.png|

   .. code:: prettyprint

      // No need to copy, this is included in the starter code.

      @Composable
      private fun FinalScoreDialog(
          score: Int,
          onPlayAgain: () -> Unit,
          modifier: Modifier = Modifier
      ) {
          val activity = (LocalContext.current as Activity)

          AlertDialog(
              onDismissRequest = {
                 // Dismiss the dialog when the user clicks outside the dialog or on the back
                 // button. If you want to disable that functionality, simply use an empty
                 // onDismissRequest.
              },
              title = { Text(text = stringResource(R.string.congratulations)) },
              text = { Text(text = stringResource(R.string.you_scored, score)) },
              modifier = modifier,
              dismissButton = {
                  TextButton(
                      onClick = {
                          activity.finish()
                      }
                  ) {
                      Text(text = stringResource(R.string.exit))
                  }
              },
              confirmButton = {
                  TextButton(onClick = onPlayAgain) {
                      Text(text = stringResource(R.string.play_again))
                  }
              }
          )
      }


4. Learn about app architecture
--------------------------------------------------------------------------------

   An app's architecture provides guidelines to help you allocate the app responsibilities
   between the classes. A well-designed app architecture helps you scale your app and
   extend it with additional features. Architecture can also simplify team collaboration.

   The most common `architectural principles <https://developer.android.google.cn/jetpack/guide#common-principles>`__ 
   are **separation of concerns** and **driving UI from a model**.

   **Separation of concerns**

   The separation of concerns design principle states that the app is divided into classes
   of functions, each with separate responsibilities.

   **Drive UI from a model**

   The drive UI from a model principle states that you should drive your UI from a model,
   preferably a persistent model. Models are components responsible for handling the data
   for an app. They're independent from the UI elements and app components in your app, so
   they're unaffected by the app's lifecycle and associated concerns.


Recommended app architecture

   Considering the common architectural principles mentioned in the previous section, each
   app should have at least two layers:

   -  **UI layer:** a layer that displays the app data on the screen but is independent of
      the data.
   -  **Data layer:** a layer that stores, retrieves, and exposes the app data.

   You can add another layer, called the domain layer, to simplify and reuse the
   interactions between the UI and data layers. This layer is optional and beyond the scope
   of this course.

   |a4da6fa5c1c9fed5.png|

   **Note**: The arrows in the diagrams in this guide represent dependencies between
   classes. For example, the domain layer depends on data layer classes.


UI layer

   The role of the UI layer, or presentation layer, is to display the application data on
   the screen. Whenever the data changes due to a user interaction, such as pressing a
   button, the UI should update to reflect the changes.

   The UI layer is made up of the following components:

   -  **UI elements:** components that render the data on the screen. You build these
      elements using `Jetpack Compose <https://developer.android.google.cn/jetpack/compose>`__.
   -  **State holders:** components that hold the data, expose it to the UI, and handle the
      app logic. An example state holder is
      `ViewModel <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__.

   |6eaee5b38ec247ae.png|


ViewModel

   The ``ViewModel`` component holds and exposes the state the UI consumes. The UI state is
   application data transformed by ``ViewModel``. ``ViewModel`` lets your app follow the
   architecture principle of driving the UI from the model.

   ``ViewModel`` stores the app-related data that isn't destroyed when the activity is
   destroyed and recreated by the Android framework. Unlike the activity instance,
   ``ViewModel`` objects are not destroyed. The app automatically retains ``ViewModel``
   objects during configuration changes so that the data they hold is immediately available
   after the recomposition.

   To implement ``ViewModel`` in your app, extend the ``ViewModel`` class, which comes from
   the architecture components library and stores app data within that class.


UI State

   The UI is what the user sees, and the UI state is what the app says they should see. The
   UI is the visual representation of the UI state. Any changes to the UI state immediately
   are reflected in the UI.

   |9cfedef1750ddd2c.png|

   *UI is a result of binding UI elements on the screen with the UI state.*

   .. code:: prettyprint

      // Example of UI state definition, do not copy over

      data class NewsItemUiState(
          val title: String,
          val body: String,
          val bookmarked: Boolean = false,
          ...
      )


**Immutability**

   The UI state definition in the example above is immutable. Immutable objects provide
   guarantees that multiple sources do not alter the state of the app at an instant in
   time. This protection frees the UI to focus on a single role: reading state and updating
   UI elements accordingly. Therefore, you should never modify the UI state in the UI
   directly, unless the UI itself is the sole source of its data. Violating this principle
   results in multiple sources of truth for the same piece of information, leading to data
   inconsistencies and subtle bugs.


5. Add a ViewModel
--------------------------------------------------------------------------------

   In this task, you add a ``ViewModel`` to your app to store your game UI state (scrambled
   word, word count, and score). To resolve the issue in the starter code that you noticed
   in the previous section, you need to save the game data in the ``ViewModel``.

   1. Open ``build.gradle.kts (Module :app)``, scroll to the ``dependencies`` block and add
      the following dependency for ``ViewModel``. This dependency is used for adding the
      lifecycle aware viewmodel to your compose app.

   .. code:: prettyprint

      dependencies {
      // other dependencies

          implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1")
      //...
      }

   2. In the ``ui`` package, create a Kotlin class/file called ``GameViewModel``. Extend it
      from the ``ViewModel`` class.

   .. code:: prettyprint

      import androidx.lifecycle.ViewModel

      class GameViewModel : ViewModel() {
      }

   3. In the ``ui`` package, add a model class for state UI called ``GameUiState``. Make it
      a data class and add a variable for the current scrambled word.

   .. code:: prettyprint

      data class GameUiState(
         val currentScrambledWord: String = ""
      )


StateFlow

   `StateFlow <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/>`__
   is a data holder observable flow that emits the current and new state updates. Its
   `value <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/value.html>`__
   property reflects the current state value. To update state and send it to the flow,
   assign a new value to the value property of the
   `MutableStateFlow <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/index.html>`__
   class.

   In Android, ``StateFlow`` works well with classes that must maintain an observable
   immutable state.

   A ``StateFlow`` can be exposed from the ``GameUiState`` so that the composables can
   listen for UI state updates and make the screen state survive configuration changes.

   In the ``GameViewModel`` class, add the following ``_uiState`` property.

   .. code:: prettyprint

      import kotlinx.coroutines.flow.MutableStateFlow

      // Game UI state
      private val _uiState = MutableStateFlow(GameUiState())


Backing property

   A backing property lets you return something from a getter other than the exact object.

   For ``var`` property, the Kotlin framework generates getters and setters.

   For getter and setter methods, you can override one or both of these methods and provide
   your own custom behavior. To implement a backing property, you override the getter
   method to return a read-only version of your data. The following example shows a backing
   property:

   .. code:: prettyprint

      //Example code, no need to copy over

      // Declare private mutable variable that can only be modified
      // within the class it is declared.
      private var _count = 0 

      // Declare another public immutable field and override its getter method. 
      // Return the private property's value in the getter method.
      // When count is accessed, the get() function is called and
      // the value of _count is returned. 
      val count: Int
          get() = _count

   As another example, say that you want the app data to be private to the ``ViewModel``:

   Inside the ``ViewModel`` class:

   -  The property ``_count`` is ``private`` and mutable. Hence, it is only accessible and
      editable within the ``ViewModel`` class.

   Outside the ``ViewModel`` class:

   -  The default visibility modifier in Kotlin is ``public``, so ``count`` is public and
      accessible from other classes like UI controllers. A ``val`` type cannot have a
      setter. It is immutable and read-only so you can only override the ``get()`` method.
      When an outside class accesses this property, it returns the value of ``_count`` and
      its value can't be modified. This backing property protects the app data inside the
      ``ViewModel`` from unwanted and unsafe changes by external classes, but it lets
      external callers safely access its value.

   1. In the ``GameViewModel.kt`` file, add a backing property to ``uiState`` named
      ``_uiState``. Name the property ``uiState`` and is of the type
      ``StateFlow<GameUiState>``.

   Now ``_uiState`` is accessible and editable only within the ``GameViewModel``. The UI
   can read its value using the read-only property, ``uiState``. You can fix the
   initialization error in the next step.

   .. code:: prettyprint

      import kotlinx.coroutines.flow.StateFlow

      // Game UI state

      // Backing property to avoid state updates from other classes
      private val _uiState = MutableStateFlow(GameUiState())
      val uiState: StateFlow<GameUiState> 

   2. Set ``uiState`` to ``_uiState.asStateFlow()``.

   The ``asStateFlow()`` makes this mutable state flow a *read-only* state flow.

   .. code:: prettyprint

      import kotlinx.coroutines.flow.StateFlow
      import kotlinx.coroutines.flow.asStateFlow

      // Game UI state
      private val _uiState = MutableStateFlow(GameUiState())
      val uiState: StateFlow<GameUiState> = _uiState.asStateFlow()


Display random scrambled word

   In this task, you add helper methods to pick a random word from the ``WordsData.kt`` and
   scramble the word.

   1. In the ``GameViewModel``, add a property called ``currentWord`` of the type
      ``String`` to save the current scrambled word.

   .. code:: prettyprint

      private lateinit var currentWord: String

   2. Add a helper method to pick a random word from the list and shuffle it. Name it
      ``pickRandomWordAndShuffle()`` with no input parameters and make it return a
      ``String``.

   .. code:: prettyprint

      import com.example.unscramble.data.allWords

      private fun pickRandomWordAndShuffle(): String {
         // Continue picking up a new random word until you get one that hasn't been used before
         currentWord = allWords.random()
         if (usedWords.contains(currentWord)) {
             return pickRandomWordAndShuffle()
         } else {
             usedWords.add(currentWord)
             return shuffleCurrentWord(currentWord)
         }
      }

   Android studio flags an error for the undefined variable and function.

   3. In the ``GameViewModel``, add the following property after the ``currentWord``
      property to serve as a mutable set to store used words in the game.

   .. code:: prettyprint

      // Set of words used in the game
      private var usedWords: MutableSet<String> = mutableSetOf()

   4. Add another helper method to shuffle the current word called ``shuffleCurrentWord()``
      that takes a ``String`` and returns the shuffled ``String``.

   .. code:: prettyprint

      private fun shuffleCurrentWord(word: String): String {
         val tempWord = word.toCharArray()
         // Scramble the word
         tempWord.shuffle()
         while (String(tempWord).equals(word)) {
             tempWord.shuffle()
         }
         return String(tempWord)
      }

   5. Add a helper function to initialize the game called ``resetGame()``. You use this
      function later to start and restart the game. In this function, clear all the words
      in the ``usedWords`` set, initialize the ``_uiState``. Pick a new word for
      ``currentScrambledWord`` using ``pickRandomWordAndShuffle()``.

   .. code:: prettyprint

      fun resetGame() {
         usedWords.clear()
         _uiState.value = GameUiState(currentScrambledWord = pickRandomWordAndShuffle())
      }

   6. Add an ``init`` block to the ``GameViewModel`` and call the ``resetGame()`` from it.

   .. code:: prettyprint

      init {
         resetGame()
      }

   When you build your app now, you still see no changes in the UI. You are not passing the
   data from the ``ViewModel`` to the composables in the ``GameScreen``.


6. Architecting your Compose UI
--------------------------------------------------------------------------------

   In Compose, the only way to update the UI is by changing the state of the app. What you
   can control is your UI state. Every time the state of the UI changes, Compose recreates
   the parts of the UI tree that changed. Composables can accept state and expose events.
   For example, a ``TextField``/``OutlinedTextField`` accepts a value and exposes a
   callback ``onValueChange`` that requests the callback handler to change the value.

   .. code:: prettyprint

      //Example code no need to copy over

      var name by remember { mutableStateOf("") }
      OutlinedTextField(
          value = name,
          onValueChange = { name = it },
          label = { Text("Name") }
      )

   Because composables accept state and expose events, the unidirectional data flow pattern
   fits well with Jetpack Compose. This section focuses on how to implement the
   unidirectional data flow pattern in Compose, how to implement events and state holders,
   and how to work with ``ViewModel``s in Compose.


**Unidirectional data flow**

   A `unidirectional data flow` (UDF) is a design pattern in which state flows down and
   events flow up. By following unidirectional data flow, you can decouple composables that
   display state in the UI from the parts of your app that store and change state.

   The UI update loop for an app using unidirectional data flow looks like the following:

   -  **Event:** Part of the UI generates an event and passes it upwardâ€”such as a button
      click passed to the ViewModel to handleâ€”or an event that is passed from other layers
      of your app, such as an indication that the user session has expired.
   -  **Update state:** An event handler might change the state.
   -  **Display state:** The state holder passes down the state, and the UI displays it.

   |61eb7bcdcff42227.png|

   The use of the UDF pattern for app architecture has the following implications:

   -  The ``ViewModel`` holds and exposes the state the UI consumes.
   -  The UI state is application data transformed by the ``ViewModel``.
   -  The UI notifies the ``ViewModel`` of user events.
   -  The ``ViewModel`` handles the user actions and updates the state.
   -  The updated state is fed back to the UI to render.
   -  This process repeats for any event that causes a mutation of state.


Pass the data

   Pass the ViewModel instance to the UIâ€“that is, from the ``GameViewModel`` to the
   ``GameScreen()`` in the **``GameScreen.kt``** file. In the ``GameScreen()``, use the
   ViewModel instance to access the ``uiState`` using ``collectAsState()``.

   The ``collectAsState()`` function collects values from this
   StateFlow_ and represents its latest value via State_.
   The Svalue_ is used as an initial value. Every time there would be a new value posted into the
   StateFlow_, the returned State_ updates, causing recomposition of every `Svalue.value()`_ usage.

.. _StateFlow: https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/index.html
.. _State: https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/State
.. _Svalue: https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/value.html
.. _Svalue.value(): https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/State#value()

   1. In the ``GameScreen`` function, pass a second argument of the type ``GameViewModel``
      with a default value of ``viewModel()``.

   .. code:: prettyprint

      import androidx.lifecycle.viewmodel.compose.viewModel

      @Composable
      fun GameScreen(
         gameViewModel: GameViewModel = viewModel()
      ) {
         // ...
      }

   |de93b81a92416c23.png|

   2. In the ``GameScreen()`` function, add a new variable called ``gameUiState``. Use the
      ``by`` delegate and call ``collectAsState()`` on ``uiState``.

   This approach ensures that whenever there is a change in the ``uiState`` value,
   recomposition occurs for the composables using the ``gameUiState`` value.

   .. code:: prettyprint

      import androidx.compose.runtime.collectAsState
      import androidx.compose.runtime.getValue

      @Composable
      fun GameScreen(
         // ...
      ) {
         val gameUiState by gameViewModel.uiState.collectAsState()
         // ...
      }

   3. Pass the ``gameUiState.currentScrambledWord`` to the ``GameLayout()`` composable. You
      add the argument in a later step, so ignore the error for now.

   .. code:: prettyprint

      GameLayout(
         currentScrambledWord = gameUiState.currentScrambledWord,
         modifier = Modifier
             .fillMaxWidth()
             .wrapContentHeight()
             .padding(mediumPadding)
      )

   4. Add ``currentScrambledWord`` as another parameter to the ``GameLayout()`` composable
      function.

   .. code:: prettyprint

      @Composable
      fun GameLayout(
         currentScrambledWord: String,
         modifier: Modifier = Modifier
      ) {
      }

   5. Update the ``GameLayout()`` composable function to display ``currentScrambledWord``.
      Set the ``text`` parameter of the first text field in the column to
      ``currentScrambledWord``.

   .. code:: prettyprint

      @Composable
      fun GameLayout(
         // ...
      ) {
         Column(
             verticalArrangement = Arrangement.spacedBy(24.dp)
         ) {
             Text(
                 text = currentScrambledWord,
                 fontSize = 45.sp,
                 modifier = modifier.align(Alignment.CenterHorizontally)
             )
          //... 
          }
      }

   6. Run and build the app. You should see the scrambled word.

   |6d93a8e1ba5dad6f.png|


Display the guess word

   In the ``GameLayout()`` composable, updating the user's guess word is one of event
   callbacks that flows up from ``GameScreen`` to the ``ViewModel``. The data
   ``gameViewModel.userGuess`` will flow down from the ``ViewModel`` to the ``GameScreen``.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/af3b1fed1f840c63.png

      the event callbacks keyboard done key press and user guess changes is passed from the
      UI to the view model

   1. In the **``GameScreen.kt``** file, in the ``GameLayout()`` composable, set
      ``onValueChange`` to ``onUserGuessChanged`` and ``onKeyboardDone()`` to ``onDone``
      keyboard action. You fix the errors in the next step.

   .. code:: prettyprint

      OutlinedTextField(
         value = "",
         singleLine = true,
         modifier = Modifier.fillMaxWidth(),
         onValueChange = onUserGuessChanged,
         label = { Text(stringResource(R.string.enter_your_word)) },
         isError = false,
         keyboardOptions = KeyboardOptions.Default.copy(
             imeAction = ImeAction.Done
         ),
         keyboardActions = KeyboardActions(
             onDone = { onKeyboardDone() }
         ),

   2. In the ``GameLayout()`` composable function, add two more arguments: the
      ``onUserGuessChanged`` lambda takes a ``String`` argument and returns nothing, and
      the ``onKeyboardDone`` takes nothing and returns nothing.

   .. code:: prettyprint

      @Composable
      fun GameLayout(
         onUserGuessChanged: (String) -> Unit,
         onKeyboardDone: () -> Unit,
         currentScrambledWord: String,
         modifier: Modifier = Modifier,
         ) {
      }

   3. In the ``GameLayout()`` function call, add lambda arguments for
      ``onUserGuessChanged`` and ``onKeyboardDone``.

   .. code:: prettyprint

      GameLayout(
         onUserGuessChanged = { gameViewModel.updateUserGuess(it) },
         onKeyboardDone = { },
         currentScrambledWord = gameUiState.currentScrambledWord,
      )

   You define ``updateUserGuess`` method in ``GameViewModel`` shortly.

   4. In the **``GameViewModel.kt``** file, add a method called ``updateUserGuess()`` that
      takes a ``String`` argument, the user's guess word. Inside the function, update the
      ``userGuess`` with the passed in ``guessedWord``.

   .. code:: prettyprint

        fun updateUserGuess(guessedWord: String){
           userGuess = guessedWord
        }

   You add ``userGuess`` in the ViewModel next.

   5. In the ``GameViewModel.kt`` file, add a var property called ``userGuess``. Use
      ``mutableStateOf()`` so that Compose observes this value and sets the initial value
      to ``""``.

   .. code:: prettyprint

      import androidx.compose.runtime.mutableStateOf
      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.setValue


      var userGuess by mutableStateOf("")
         private set

   6. In the ``GameScreen.kt`` file, inside ``GameLayout()``, add another ``String``
      parameter for ``userGuess``. Set the ``value`` parameter of the ``OutlinedTextField``
      to ``userGuess``.

   .. code:: prettyprint

      fun GameLayout(
         currentScrambledWord: String,
         userGuess: String,
         onUserGuessChanged: (String) -> Unit,
         onKeyboardDone: () -> Unit,
         modifier: Modifier = Modifier
      ) {
         Column(
             verticalArrangement = Arrangement.spacedBy(24.dp)
         ) {
             //...
             OutlinedTextField(
                 value = userGuess,
                 //..
             )
         }
      }

   7. In the ``GameScreen`` function, update the ``GameLayout()`` function call to include
      ``userGuess`` parameter.

   .. code:: prettyprint

      GameLayout(
         currentScrambledWord = gameUiState.currentScrambledWord,
         userGuess = gameViewModel.userGuess,
         onUserGuessChanged = { gameViewModel.updateUserGuess(it) },
         onKeyboardDone = { },
         //...
      )

   8. Build and run your app.
   9. Try to guess and enter a word. The text field can display the user's guess.

   |ed10c7f522495a.png|


7. Verify guess word and update score
--------------------------------------------------------------------------------

   In this task, you implement a method to verify the word a user guesses and then either
   update the game score or display an error. You will update the game state UI with the
   new score and the new word later.

   1. In ``GameViewModel``, add another method called ``checkUserGuess()``.
   2. In the ``checkUserGuess()`` function, add an ``if else`` block to verify if the
      user's guess is the same as the ``currentWord``. Reset ``userGuess`` to empty string.

   .. code:: prettyprint

      fun checkUserGuess() {
         
         if (userGuess.equals(currentWord, ignoreCase = true)) {
         } else {
         }
         // Reset user guess
         updateUserGuess("")
      }

   3. If the user's guess is wrong, set ``isGuessedWordWrong`` to ``true``.
      ```MutableStateFlow<T>. <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/index.html>`__
      ```u() <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/update.html>`__
      updates the
      ```Mvalue <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/value.html>`__
      using the specified value.

   .. code:: prettyprint

      import kotlinx.coroutines.flow.update

         if (userGuess.equals(currentWord, ignoreCase = true)) {
         } else {
             // User's guess is wrong, show an error
             _uiState.update { currentState ->
                 currentState.copy(isGuessedWordWrong = true)
             }
         }

   **Note on copy() method:** Use the ``copy()`` function to copy an object, allowing you
   to alter some of its properties while keeping the rest unchanged.

   Example:

   .. code:: kotlin

      val jack = User(name = "Jack", age = 1)

      val olderJack = jack.copy(age = 2)

   4. In the ``GameUiState`` class, add a ``Boolean`` called ``isGuessedWordWrong`` and
      initialize it to ``false``.

   .. code:: prettyprint

      data class GameUiState(
         val currentScrambledWord: String = "",
         val isGuessedWordWrong: Boolean = false,
      )

   Next, you pass the event callback ``checkUserGuess()`` up from ``GameScreen`` to
   ``ViewModel`` when the user clicks the **Submit** button or the done key in the
   keyboard. Pass the data, ``gameUiState.isGuessedWordWrong`` down from the ``ViewModel``
   to the ``GameScreen`` to set the error in the text field.

   |7f05d04164aa4646.png|

   1. In the ``GameScreen.kt`` file, at the end of the ``GameScreen()`` composable
      function, call ``gameViewModel.checkUserGuess()`` inside the ``onClick`` lambda
      expression of the **Submit** button.

   .. code:: prettyprint

      Button(
         modifier = modifier
             .fillMaxWidth()
             .weight(1f)
             .padding(start = 8.dp),
         onClick = { gameViewModel.checkUserGuess() }
      ) {
         Text(stringResource(R.string.submit))
      }

   2. In the ``GameScreen()`` composable function, update the ``GameLayout()`` function
      call to pass ``gameViewModel.checkUserGuess()`` in the ``onKeyboardDone`` lambda
      expression.

   .. code:: prettyprint

      GameLayout(
         currentScrambledWord = gameUiState.currentScrambledWord,
         userGuess = gameViewModel.userGuess,
         onUserGuessChanged = { gameViewModel.updateUserGuess(it) },
         onKeyboardDone = { gameViewModel.checkUserGuess() }
      )

   3. In the ``GameLayout()`` composable function, add a function parameter for the
      ``Boolean``, **``isGuessWrong``**. Set the **``isError``** parameter of the
      ``OutlinedTextField`` to **``isGuessWrong``** to display the error in the text field
      if the user's guess is wrong.

   .. code:: prettyprint

      fun GameLayout(
         currentScrambledWord: String,
         isGuessWrong: Boolean,
         userGuess: String,
         onUserGuessChanged: (String) -> Unit,
         onKeyboardDone: () -> Unit,
         modifier: Modifier = Modifier
      ) {
         Column(
             // ,...
             OutlinedTextField(
                 // ...
                 isError = isGuessWrong,
                 keyboardOptions = KeyboardOptions.Default.copy(
                     imeAction = ImeAction.Done
                 ),
                 keyboardActions = KeyboardActions(
                     onDone = { onKeyboardDone() }
                 ),
             )
      }
      }

   4. In the ``GameScreen()`` composable function, update the ``GameLayout()`` function
      call to pass ``isGuessWrong``.

   .. code:: prettyprint

      GameLayout(
         currentScrambledWord = gameUiState.currentScrambledWord,
         userGuess = gameViewModel.userGuess,
         onUserGuessChanged = { gameViewModel.updateUserGuess(it) },
         onKeyboardDone = { gameViewModel.checkUserGuess() },
         isGuessWrong = gameUiState.isGuessedWordWrong,
         // ...
      )

   5. Build and run your app.
   6. Enter a wrong guess and click **Submit**. Observe that the text field turns red,
      indicating the error.

   |a1bc55781d627b38.png|

   Notice the text field label still reads "Enter your word". To make it user friendly, you
   need to add some error text to indicate the word is wrong.

   7. In the **``GameScreen.kt``** file, in the ``GameLayout()`` composable, update the
      label parameter of the text field depending on the ``isGuessWrong`` as follows:

   .. code:: prettyprint

      OutlinedTextField(
         // ...
         label = {
             if (isGuessWrong) {
                 Text(stringResource(R.string.wrong_guess))
             } else {
                 Text(stringResource(R.string.enter_your_word))
             }
         },
         // ...
      )

   8. In the ``strings.xml`` file, add a string to the error label.

   .. code:: prettyprint

      <string name="wrong_guess">Wrong Guess!</string>

   9.  Build and run your app again.
   10. Enter a wrong guess and click **Submit**. Notice the error label.

   |8c17eb61e9305d49.png|


8. Update score and word count
--------------------------------------------------------------------------------

   In this task, you update the score and the word count as the user plays the game. The
   score must be part of ``_ uiState``.

   1. In ``GameUiState``, add a ``score`` variable and initialize it to zero.

   .. code:: prettyprint

      data class GameUiState(
         val currentScrambledWord: String = "",
         val isGuessedWordWrong: Boolean = false,
         val score: Int = 0
      )

   2. To update the score value, in ``GameViewModel``, in ``checkUserGuess()`` function,
      inside the ``if`` condition for when the user's guess is correct, increase the
      ``score`` value.

   .. code:: prettyprint

      import com.example.unscramble.data.SCORE_INCREASE

      fun checkUserGuess() {
         if (userGuess.equals(currentWord, ignoreCase = true)) {
             // User's guess is correct, increase the score
             val updatedScore = _uiState.value.score.plus(SCORE_INCREASE)
         } else {
             //...
         }
      }

   3. In ``GameViewModel``, add another method called ``updateGameState`` to update the
      score, increment the current word count and pick a new word from the ``WordsData.kt``
      file. Add an ``Int`` named ``updatedScore`` as the parameter. Update the game state
      UI variables as follows:

   .. code:: prettyprint

      private fun updateGameState(updatedScore: Int) {
         _uiState.update { currentState ->
             currentState.copy(
                 isGuessedWordWrong = false,
                 currentScrambledWord = pickRandomWordAndShuffle(),
                 score = updatedScore
             )
         }
      }

   4. In the ``checkUserGuess()`` function, if the user's guess is correct, make a call to
      ``updateGameState`` with the updated score to prepare the game for the next round.

   .. code:: prettyprint

      fun checkUserGuess() {
         if (userGuess.equals(currentWord, ignoreCase = true)) {
             // User's guess is correct, increase the score
             // and call updateGameState() to prepare the game for next round
             val updatedScore = _uiState.value.score.plus(SCORE_INCREASE)
             updateGameState(updatedScore)
         } else {
             //...
         }
      }

   The completed ``checkUserGuess()`` should look like the following:

   .. code:: prettyprint

      fun checkUserGuess() {
         if (userGuess.equals(currentWord, ignoreCase = true)) {
             // User's guess is correct, increase the score
             // and call updateGameState() to prepare the game for next round
             val updatedScore = _uiState.value.score.plus(SCORE_INCREASE)
             updateGameState(updatedScore)
         } else {
             // User's guess is wrong, show an error
             _uiState.update { currentState ->
                 currentState.copy(isGuessedWordWrong = true)
             }
         }
         // Reset user guess
         updateUserGuess("")
      }

   Next, similar to the updates for the score, you need to update the word count.

   5. Add another variable for the count in the ``GameUiState``. Call it
      ``currentWordCount`` and initialize it to ``1``.

   .. code:: prettyprint

      data class GameUiState(
         val currentScrambledWord: String = "",
         val currentWordCount: Int = 1,
         val score: Int = 0,
         val isGuessedWordWrong: Boolean = false,
      )

   6. In the ``GameViewModel.kt`` file, in the ``updateGameState()`` function, increase the
      word count as shown below. The ``updateGameState()`` function is called to prepare
      the game for the next round.

   .. code:: prettyprint

      private fun updateGameState(updatedScore: Int) {
         _uiState.update { currentState ->
             currentState.copy(
                 //...
                 currentWordCount = currentState.currentWordCount.inc(),
                 )
         }
      }


Pass score and word count

   Complete the following steps to pass the score and word count data down from
   ``ViewModel`` to the ``GameScreen``.

   |546e101980380f80.png|

   1. In the ``GameScreen.kt`` file, in the ``GameLayout()`` composable function, add word
      count as argument and pass the **``wordCount``** format arguments to the text
      element.

   .. code:: prettyprint

      fun GameLayout(
         onUserGuessChanged: (String) -> Unit,
         onKeyboardDone: () -> Unit,
         wordCount: Int,
         //...
      ) {
         //...

         Card(
             //...
         ) {
             Column(
                 // ...
             ) {
                 Text(
                     //..
                     text = stringResource(R.string.word_count, wordCount),
                     style = typography.titleMedium,
                     color = colorScheme.onPrimary
                 )


      // ...

      }

   2. Update the ``GameLayout()`` function call to include the word count.

   .. code:: prettyprint

      GameLayout(
         userGuess = gameViewModel.userGuess,
         wordCount = gameUiState.currentWordCount,
         //...
      )

   3. In the ``GameScreen()`` composable function, update the ``GameStatus()`` function
      call to include ``score`` parameters. Pass the score from the ``gameUiState``.

   .. code:: prettyprint

      GameStatus(score = gameUiState.score, modifier = Modifier.padding(20.dp))

   4. Build and run the app.
   5. Enter the guess word and click **Submit**. Notice the score and word count update.
   6. Click **Skip**, and notice nothing happens.

   To implement the skip functionality you need to pass the skip event callback to the
   ``GameViewModel``.

   7. In the ``GameScreen.kt`` file, in the ``GameScreen()`` composable function, make a
      call to ``gameViewModel.skipWord()`` in the ``onClick`` lambda expression.

   Android Studio displays an error because you have not implemented the function yet.You
   fix this error in the next step by adding the ``skipWord()`` method. When the user skips
   a word, you need to update the game variables and prepare the game for the next round.

   .. code:: prettyprint

      OutlinedButton(
         onClick = { gameViewModel.skipWord() },
         modifier = Modifier.fillMaxWidth()
      ) {
         //...
      }

   8. In ``GameViewModel``, add the method ``skipWord()``.
   9. Inside the ``skipWord()`` function, make a call to ``updateGameState()``, passing the
      score and reset the user guess.

   .. code:: prettyprint

      fun skipWord() {
         updateGameState(_uiState.value.score)
         // Reset user guess
         updateUserGuess("")
      }

   10. Run your app and play the game. You should now be able to skip words.

   |e87bd75ba1269e96.png|

   You can still play the game beyond 10 words. In your next task, you'll handle the last
   round of the game.


9. Handle last round of game
--------------------------------------------------------------------------------

   In the current implementation, users can skip or play beyond 10 words. In this task, you
   add logic to end the game.

   |d3fd67d92c5d3c35.png|

   To implement game-end logic, you first need to check if the user reaches the maximum
   number of words.

   1. In ``GameViewModel`` add an ``if-else`` block and move the existing function body
      inside the ``else`` block.
   2. Add an ``if`` condition to check the ``usedWords`` size is equal to
      ``MAX_NO_OF_WORDS``.

   .. code:: prettyprint

      import com.example.android.unscramble.data.MAX_NO_OF_WORDS


      private fun updateGameState(updatedScore: Int) {
         if (usedWords.size == MAX_NO_OF_WORDS){
             //Last round in the game
         } else{
             // Normal round in the game
             _uiState.update { currentState ->
                 currentState.copy(
                     isGuessedWordWrong = false,
                     currentScrambledWord = pickRandomWordAndShuffle(),
                     currentWordCount = currentState.currentWordCount.inc(),
                     score = updatedScore
                 )
             }
         }
      }

   3. Inside the ``if`` block, add the ``Boolean`` flag ``isGameOver`` and set the flag to
      ``true`` to indicate the end of the game.
   4. Update the ``score`` and reset ``isGuessedWordWrong`` inside the ``if`` block. The
      following code shows how your function should look:

   .. code:: prettyprint

      private fun updateGameState(updatedScore: Int) {
         if (usedWords.size == MAX_NO_OF_WORDS){
             //Last round in the game, update isGameOver to true, don't pick a new word
             _uiState.update { currentState ->
                 currentState.copy(
                     isGuessedWordWrong = false,
                     score = updatedScore,
                     isGameOver = true
                 )
             }
         } else{
             // Normal round in the game
             _uiState.update { currentState ->
                 currentState.copy(
                     isGuessedWordWrong = false,
                     currentScrambledWord = pickRandomWordAndShuffle(),
                     currentWordCount = currentState.currentWordCount.inc(),
                     score = updatedScore
                 )
             }
         }
      }

   5. In ``GameUiState``, add the ``Boolean`` variable ``isGameOver`` and set it to
      ``false``.

   .. code:: prettyprint

      data class GameUiState(
         val currentScrambledWord: String = "",
         val currentWordCount: Int = 1,
         val score: Int = 0,
         val isGuessedWordWrong: Boolean = false,
         val isGameOver: Boolean = false
      )

   6. Run your app and play the game. You cannot play beyond 10 words.

   |ac8a12e66111f071.png|

   When the game is over, it would be nice to let the user know and ask if they would like
   to play again. You will implement this feature in your next task.


Display game end dialog

   In this task, you pass ``isGameOver`` data down to ``GameScreen`` from the ViewModel and
   use it to display an alert dialog with options to end or restart the game.

   A dialog is a small window that prompts the user to make a decision or enter additional
   information. Normally, a dialog does not fill the entire screen, and it requires users
   to take an action before they can proceed. Android provides different types of dialogs.
   In this codelab, you learn about Alert Dialogs.


Anatomy of alert dialog

   |eb6edcdd0818b900.png|

   1. Container
   2. Icon (optional)
   3. Headline (optional)
   4. Supporting text
   5. Divider (optional)
   6. Actions

   The ``GameScreen.kt`` file in the starter code already provides a function that displays
   an alert dialog with options to exit or restart the game.

   |78d43c7aa01b414d.png|

   .. code:: prettyprint

      @Composable
      private fun FinalScoreDialog(
         onPlayAgain: () -> Unit,
         modifier: Modifier = Modifier
      ) {
         val activity = (LocalContext.current as Activity)

         AlertDialog(
             onDismissRequest = {
                 // Dismiss the dialog when the user clicks outside the dialog or on the back
                 // button. If you want to disable that functionality, simply use an empty
                 // onDismissRequest.
             },
             title = { Text(stringResource(R.string.congratulations)) },
             text = { Text(stringResource(R.string.you_scored, 0)) },
             modifier = modifier,
             dismissButton = {
                 TextButton(
                     onClick = {
                         activity.finish()
                     }
                 ) {
                     Text(text = stringResource(R.string.exit))
                 }
             },
             confirmButton = {
                 TextButton(
                     onClick = {
                         onPlayAgain()
                     }
                 ) {
                     Text(text = stringResource(R.string.play_again))
                 }
             }
         )
      }

   In this function, ``title`` and ``text`` parameters display the headline and supporting
   text in the alert dialog. The ``dismissButton`` and ``confirmButton`` are the text
   buttons. In ``dismissButton`` parameter, you display the text **Exit** and terminate the
   app by finishing the activity. In ``confirmButton`` parameter, you restart the game and
   display the text **Play Again**.

   |a24f59b84a178d9b.png|

   1. In the ``GameScreen.kt`` file, in the ``FinalScoreDialog()`` function, notice the
      parameter for the score to display the game score in the alert dialog.

   .. code:: prettyprint

      @Composable
      private fun FinalScoreDialog(
         score: Int,
         onPlayAgain: () -> Unit,
         modifier: Modifier = Modifier
      ) {

   2. In the ``FinalScoreDialog()`` function, notice the usage of the ``text`` parameter
      lambda expression to use ``score`` as format argument to the dialog text.

   .. code:: prettyprint

      text = { Text(stringResource(R.string.you_scored, score)) }

   3. In the ``GameScreen.kt`` file, at the end of the ``GameScreen()`` composable
      function, after the ``Column`` block, add an ``if`` condition to check
      ``gameUiState.isGameOver``.
   4. In the ``if`` block, display the alert dialog. Make a call to ``FinalScoreDialog()``
      passing in the ``score`` and ``gameViewModel.resetGame()`` for the ``onPlayAgain``
      event callback.

   .. code:: prettyprint

      if (gameUiState.isGameOver) {
         FinalScoreDialog(
             score = gameUiState.score,
             onPlayAgain = { gameViewModel.resetGame() }
         )
      }

   The ``resetGame()`` is an event callback that is passed up from the ``GameScreen`` to
   the ``ViewModel``.

   5. In the ``GameViewModel.kt`` file, recall the ``resetGame()`` function, initializes
      the ``_uiState``, and picks a new word.

   .. code:: prettyprint

      fun resetGame() {
         usedWords.clear()
         _uiState.value = GameUiState(currentScrambledWord = pickRandomWordAndShuffle())
      }

   6. Build and run your app.
   7. Play the game until the end, and observe the alert dialog with options to **Exit**
      the game or **Play Again**. Try the options displayed on the alert dialog.

   |c6727347fe0db265.png|


10. State in device rotation
--------------------------------------------------------------------------------

   In previous codelabs, you learned about configuration changes in Android. When a
   configuration change occurs, Android restarts the activity from scratch, running all the
   lifecycle startup callbacks.

   The `ViewModel <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__
   stores the app-related data that isn't destroyed when the Android framework destroys and
   recreates activity. ``ViewModel`` objects are automatically retained and they are not
   destroyed like the activity instance during configuration change. The data they hold is
   immediately available after the recomposition.

   In this task, you check if the app retains the state UI during a configuration change.

   1. Run the app and play some words. Change the configuration of the device from portrait
      to landscape, or vice versa.
   2. Observe that the data saved in the ``ViewModel``'s state UI is retained during the
      configuration change.

   |4a63084643723724.png|

   |4134470d435581dd.png|


11. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble.git
      $ cd basic-android-kotlin-compose-training-unscramble
      $ git checkout viewmodel

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble/archive/refs/heads/viewmodel.zip>`__

   `VS Code Online <https://vscode.dev/github/google-developer-training/basic-android-kotlin-compose-training-unscramble>`__

   **Note:** The solution code is in the ``viewmodel`` branch of the downloaded repository.

   If you want to see the solution code for this codelab, view it on
   `GitHub <https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble/tree/viewmodel>`__.


12. Conclusion
--------------------------------------------------------------------------------

   Congratulations! You have completed the codelab. Now you understand how the Android app
   architecture guidelines recommend separating classes that have different
   responsibilities and driving the UI from a model.

   Don't forget to share your work on social media with *#AndroidBasics*!


**Learn more**

   -  `Guide to app architecture \| Android Developers <https://developer.android.google.cn/topic/architecture>`__
   -  `UI layer \| Android Developers <https://developer.android.google.cn/topic/architecture/ui-layer>`__
   -  `Manage state with Unidirectional Data Flow \| Android Developers <https://developer.android.google.cn/topic/architecture/ui-layer#udf>`__
   -  Learning Pathway: `Modern Android App Architecture <https://developer.android.google.cn/courses/pathways/android-architecture>`__

.. |1a7e4472a5638d61.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/1a7e4472a5638d61.png
.. |b6ddb1f07f10df0c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/b6ddb1f07f10df0c.png
.. |3df34220c3d177eb.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/3df34220c3d177eb.png
.. |ac79bf1ed6375a27.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/ac79bf1ed6375a27.png
.. |dba2d9ea62aaa982.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/dba2d9ea62aaa982.png
.. |a4da6fa5c1c9fed5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/a4da6fa5c1c9fed5.png
.. |6eaee5b38ec247ae.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/6eaee5b38ec247ae.png
.. |9cfedef1750ddd2c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/9cfedef1750ddd2c.png
.. |61eb7bcdcff42227.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/61eb7bcdcff42227.png
.. |de93b81a92416c23.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/de93b81a92416c23.png
.. |6d93a8e1ba5dad6f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/6d93a8e1ba5dad6f.png
.. |ed10c7f522495a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/ed10c7f522495a.png
.. |7f05d04164aa4646.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/7f05d04164aa4646.png
.. |a1bc55781d627b38.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/a1bc55781d627b38.png
.. |8c17eb61e9305d49.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/8c17eb61e9305d49.png
.. |546e101980380f80.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/546e101980380f80.png
.. |e87bd75ba1269e96.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/e87bd75ba1269e96.png
.. |d3fd67d92c5d3c35.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/d3fd67d92c5d3c35.png
.. |ac8a12e66111f071.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/ac8a12e66111f071.png
.. |eb6edcdd0818b900.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/eb6edcdd0818b900.png
.. |78d43c7aa01b414d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/78d43c7aa01b414d.png
.. |a24f59b84a178d9b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/a24f59b84a178d9b.png
.. |c6727347fe0db265.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/c6727347fe0db265.png
.. |4a63084643723724.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/4a63084643723724.png
.. |4134470d435581dd.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-viewmodel-and-state/img/4134470d435581dd.png


ğŸš€ Write unit tests for ViewModel
=================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-viewmodel

1. Before you begin
--------------------------------------------------------------------------------

   This codelab teaches you to write unit tests to test the ``ViewModel`` component. You
   will add unit tests for the
   `Unscramble <https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble.git>`__
   game app. The Unscramble app is a fun word game where users have to guess a scrambled
   word and earn points for guessing correctly. The following image shows a preview of the
   app:

   |bb1e97c357603a27.png|

   In the `Write automated tests <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-write-automated-tests>`__
   codelab, you learned what automated tests are and why they are important. You also
   learned how to implement unit tests.

   You learned:

   -  Automated testing is code that verifies the accuracy of another piece of code.
   -  Testing is an important part of the app development process. By running tests against
      your app consistently, you can verify your app's functional behavior and usability
      before you release it publicly.
   -  With unit tests, you can test functions, classes, and properties.
   -  Local unit tests are executed on your workstation, which means they run in a
      development environment without the need for an Android device or emulator. In other
      words, local tests run on your computer.

   Before you proceed, make sure that you complete the 
   `Write automated tests <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-write-automated-tests>`__
   and `ViewModel and State in Compose <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-viewmodel-and-state>`__
   codelabs.


Prerequisites

   -  Knowledge of Kotlin, including functions, lambdas, and stateless composables
   -  Basic knowledge of how to build layouts in Jetpack Compose
   -  Basic knowledge of Material Design
   -  Basic knowledge of how to implement ViewModel


What you'll learn

   -  How to add dependencies for unit tests in the app module's **``build.gradle.kts``**
      file
   -  How to create a test strategy to implement unit tests
   -  How to write unit tests using JUnit4 and understand the test instance lifecycle
   -  How to run, analyze, and improve code coverage


What you'll build

   -  Unit tests for the
      `Unscramble <https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble.git>`__
      game app


What you'll need

   -  The latest version of Android Studio


Get the starter code

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble/archive/refs/heads/viewmodel.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble.git
      $ cd basic-android-kotlin-compose-training-unscramble
      $ git checkout viewmodel

   **Note:** The starter code is in the ``viewmodel`` branch of the downloaded repository.

   You can browse the code in the
   `Unscramble <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-unscramble/tree/viewmodel>`__
   GitHub repository.


2. Starter code overview
--------------------------------------------------------------------------------

   In Unit 2, you learned to place the unit test code in the **test** source set that is
   under the **src** folder, as shown in the following image:

   |1a2dceb0dd9c618d.png|

   The starter code has the following file:

   -  **``WordsData.kt``:** This file contains a list of words to use for testing and a
      ``getUnscrambledWord()`` helper function to get the unscrambled word from the
      scrambled word. You don't need to modify this file.

   **Note:** The ``allWords`` property in the test source set ``WordsData.kt`` file will be
   used by the ``GameViewModel``. When running tests, this replaces the ``allWords``
   property available in the app source set ``WordsData.kt`` file.

   In the next unit you will learn about a new technique, called Dependency Injection that
   promotes loose coupling and helps you to use different resources while running tests.


3. Add test dependencies
--------------------------------------------------------------------------------

   In this codelab, you use the JUnit framework to write unit tests. To use the framework,
   you need to add it as a dependency in your app module's **``build.gradle.kts``** file.

   You use the ``implementation`` configuration to specify the dependencies that your app
   requires. For example, to use the ``ViewModel`` library in your application, you must
   add a dependency to ``androidx.lifecycle:lifecycle-viewmodel-compose``, as shown in the
   following code snippet:

   .. code:: prettyprint

      dependencies {

          ...
          implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1")
      }

   You can now use this library in your app's source code, and Android studio will help to
   add it to the generated Application Package File (APK) file. However, you do not want
   your unit test code to be part of your APK file. The test code doesn't add any
   functionality that the user would use, and the code also has an impact on the APK size.
   The same goes for the dependencies required by your test code; you should keep them
   separate. To do so, you use the ``testImplementation`` configuration, which indicates
   that the configuration applies to the local test source code and not the application
   code.

   **Note:** Each Android application is compiled and packaged in a single file called an
   Application Package File (APK) that includes all of the application's code, resources,
   assets, and the manifest file. For convenience, an application package file is often
   referred to as an APK, and the file has the extension **.apk**. Android-powered devices
   use this file to install the app.

   To add a dependency to your project, specify a dependency configuration (such as
   ``implementation`` or ``testImplementation``) in the dependencies block of your
   **``build.gradle.kts``** file. Each dependency configuration provides Gradle with
   different instructions about how to use the dependency.

   To add a dependency:

   1. Open the ``app`` module's **``build.gradle.kts``** file, located in the **``app``**
      directory in the **Project** pane.

   |bc235c0754e4e0f2.png|

   2. Inside the file, scroll down until you find the ``dependencies{}`` block. Add a
      dependency using ``testImplementation`` config for ``junit``.

   .. code:: prettyprint

      plugins {
          ...
      }

      android {
          ...
      }

      dependencies {
          ...
          testImplementation("junit:junit:4.13.2")
      }

   3. In the notification bar at the top of the **build.gradle.kts** file, click **Sync
      Now** to let the import and build finish as shown in the following screenshot:

   |1c20fc10750ca60c.png|


**Compose Bill of Materials (BOM)**

   Compose BOM is the recommended way to manage Compose library versions. BOM lets you
   manage all of your Compose library versions by specifying only the BOM's version.

   Notice the dependency section in the ``app`` module's ``build.gradle.kts`` file.

   .. code:: prettyprint

      // No need to copy over
      // This is part of starter code
      dependencies {

         // Import the Compose BOM
          implementation (platform("androidx.compose:compose-bom:2023.06.01"))
          ...
          implementation("androidx.compose.material3:material3")
          implementation("androidx.compose.ui:ui")
          implementation("androidx.compose.ui:ui-graphics")
          implementation("androidx.compose.ui:ui-tooling-preview")
          ...
      }

   Observe the following:

   -  Compose library version numbers are not specified.
   -  BOM is imported using
      ``implementation platform("androidx.compose:compose-bom:2023.06.01")``

   This is because the BOM itself has links to the latest stable versions of the different
   Compose libraries, in such a way that they work well together. When using the BOM in
   your app, you don't need to add any version to the Compose library dependencies
   themselves. When you update the BOM version, all the libraries that you're using are
   automatically updated to their new versions.

   To use BOM with the compose testing libraries(instrumented tests) you need to import
   ``androidTestImplementation platform("androidx.compose:compose-bom:xxxx.xx.xx")``. You
   could create a variable and reuse it for ``implementation`` and
   ``androidTestImplementation`` as shown.

   .. code:: prettyprint

      // Example, not need to copy over
      dependencies {

         // Import the Compose BOM
          implementation(platform("androidx.compose:compose-bom:2023.06.01"))
          implementation("androidx.compose.material:material")
          implementation("androidx.compose.ui:ui")
          implementation("androidx.compose.ui:ui-tooling-preview")
          
          // ...
          androidTestImplementation(platform("androidx.compose:compose-bom:2023.06.01"))
          androidTestImplementation("androidx.compose.ui:ui-test-junit4")

      }

   **Note**: Compose BOM is only for Compose libraries, not for other libraries such as
   lifecycle ``androidx.lifecycle`` library.

   Great! You successfully added test dependencies to the app and learned about BOM. You
   are now ready to add some unit tests.


4. Test strategy
--------------------------------------------------------------------------------

   A good test strategy revolves around covering different paths and boundaries of your
   code. At a very basic level, you can categorize the tests in three scenarios: success
   path, error path, and boundary case.

   -  **Success path:** The success path tests - also known as happy path tests, focus on
      testing the functionality for a positive flow. A positive flow is a flow that has no
      exception or error conditions. Compared to the error path and boundary case
      scenarios, it is easy to create an exhaustive list of scenarios for success paths,
      since they focus on intended behavior for your app.

   An example of a success path in the Unscramble app is the correct update of the score,
   word count, and the scrambled word when the user enters a correct word and clicks the
   **Submit** button.

   -  **Error path:** The error path tests focus on testing the functionality for a
      negative flowâ€“that is, to check how the app responds to error conditions or invalid
      user input. It is quite challenging to determine all the possible error flows because
      there are lots of possible outcomes when intended behavior is not achieved.

   One piece of general advice is to list all the possible error paths, write tests for
   them, and keep your unit tests evolving as you discover different scenarios.

   An example of an error path in the Unscramble app is the user enters an incorrect word
   and clicks on the **Submit** button, which causes an error message to appear and the
   score and word count to not update.

   -  **Boundary case:** A boundary case focuses on testing boundary conditions in the app.
      In the Unscramble app, a boundary is checking the UI state when the app loads and the
      UI state after the user plays a maximum number of words.

   Creating test scenarios around these categories can serve as guidelines for your test
   plan.


Create tests

   A good unit test typically has following four properties:

   -  **Focused:** It should focus on testing a unit, such as a piece of code. This piece
      of code is often a class or a method. The test should be narrow and focus on
      validating the correctness of individual pieces of code, rather than multiple pieces
      of code at the same time.
   -  **Understandable:** It should be simple and easy to understand when you read the
      code. At a glance, a developer should be able to immediately understand the intention
      behind the test.
   -  **Deterministic:** It should consistently pass or fail. When you run the tests any
      number of times, without making any code changes, the test should yield the same
      result. The test shouldn't be flaky, with a failure in one instance and a pass in
      another instance despite no modification to the code.
   -  **Self-contained:** It does not require any human interaction or setup and runs in
      isolation.


**Success path**

   To write a unit test for the success path, you need to assert that, given that an
   instance of the ``GameViewModel`` was initialized, when the ``updateUserGuess()`` method
   is called with correct guess word followed by a call to ``checkUserGuess()`` method,
   then:

   -  The correct guess is passed to the ``updateUserGuess()`` method.
   -  The ``checkUserGuess()`` method is called.
   -  The value for the ``score`` and ``isGuessedWordWrong`` status updates correctly.

   Complete the following steps to create the test:

   1. Create a new package ``com.example.android.unscramble.ui.test`` under test source set
      and add file as shown in the following screenshot:

   |57d004ccc4d75833.png|

   |f98067499852bdce.png|

   To write a unit test for the ``GameViewModel`` class, you need an instance of the class
   so that you can call the class's methods and verify the state.

   2. In the body of the ``GameViewModelTest`` class, declare a ``viewModel`` property and
      assign an instance of the ``GameViewModel`` class to it.

   .. code:: prettyprint

      class GameViewModelTest {
          private val viewModel = GameViewModel()
      }

   3. To write an unit test for success path, create a
      ``gameViewModel_CorrectWordGuessed_ScoreUpdatedAndErrorFlagUnset()`` function and
      annotate it with ``@Test`` annotation.

   .. code:: prettyprint

      class GameViewModelTest {
          private val viewModel = GameViewModel()

          @Test
          fun gameViewModel_CorrectWordGuessed_ScoreUpdatedAndErrorFlagUnset()  {
          }
      }

   4. Import the following:

   .. code:: prettyprint

      import org.junit.Test

   **Note:** The code above uses the ``thingUnderTest_TriggerOfTest_ResultOfTest`` format
   to name the test function name:

   -  ``thingUnderTest`` = ``gameViewModel``
   -  ``TriggerOfTest`` = ``CorrectWordGuessed``
   -  ``ResultOfTest`` = ``ScoreUpdatedAndErrorFlagUnset``

   To pass a correct player word to the ``viewModel.updateUserGuess()`` method, you need to
   get the correct unscrambled word from the scrambled word in ``GameUiState``. To do so,
   first get the current game ui state.

   5. In the function body, create a ``currentGameUiState`` variable, and assign
      ``viewModel.uiState.value`` to it.

   .. code:: prettyprint

      @Test
      fun gameViewModel_CorrectWordGuessed_ScoreUpdatedAndErrorFlagUnset() {
          var currentGameUiState = viewModel.uiState.value
      }

   **Warning**: This way to retrieve the uiState works because you used
   ``MutableStateFlow``. In upcoming units, you will learn about advanced usages of
   ``StateFlow`` that create a stream of data, and you need to react to handle the stream.
   For those scenarios, you will write unit tests using different methods and approaches.

   6. To get the correct player guess, use the ``getUnscrambledWord()`` function, which
      takes in the ``currentGameUiState.currentScrambledWord`` as an argument and returns
      the unscrambled word. Store this returned value in a new read-only variable named
      ``correctPlayerWord`` and assign the value returned by the ``getUnscrambledWord()``
      function.

   .. code:: prettyprint

      @Test
      fun gameViewModel_CorrectWordGuessed_ScoreUpdatedAndErrorFlagUnset() {
          var currentGameUiState = viewModel.uiState.value
          val correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)

      }

   7. To verify if the guessed word is correct, add a call to the
      ``viewModel.updateUserGuess()`` method and pass the ``correctPlayerWord`` variable as
      an argument. Then add a call to ``viewModel.checkUserGuess()`` method to verify the
      guess.

   .. code:: prettyprint

      @Test
      fun gameViewModel_CorrectWordGuessed_ScoreUpdatedAndErrorFlagUnset() {
          var currentGameUiState = viewModel.uiState.value
          val correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)

          viewModel.updateUserGuess(correctPlayerWord)
          viewModel.checkUserGuess()
      }

   You are now ready to assert that the game state is what you expect.

   8. Get the instance of the ``GameUiState`` class from the value of the
      ``viewModel.uiState`` property and store it in the ``currentGameUiState`` variable.

   .. code:: prettyprint

      @Test
      fun gameViewModel_CorrectWordGuessed_ScoreUpdatedAndErrorFlagUnset() {
          var currentGameUiState = viewModel.uiState.value
          val correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)
          viewModel.updateUserGuess(correctPlayerWord)
          viewModel.checkUserGuess()

          currentGameUiState = viewModel.uiState.value
      }

   9. To check the guessed word is correct and score is updated, use the ``assertFalse()``
      function to verify that the ``currentGameUiState.isGuessedWordWrong`` property is
      ``false`` and the ``assertEquals()`` function to verify that the value of the
      ``currentGameUiState.score`` property is equal to ``20``.

   .. code:: prettyprint

      @Test
      fun gameViewModel_CorrectWordGuessed_ScoreUpdatedAndErrorFlagUnset() {
          var currentGameUiState = viewModel.uiState.value
          val correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)
          viewModel.updateUserGuess(correctPlayerWord)
          viewModel.checkUserGuess()

          currentGameUiState = viewModel.uiState.value
          // Assert that checkUserGuess() method updates isGuessedWordWrong is updated correctly.
          assertFalse(currentGameUiState.isGuessedWordWrong)
          // Assert that score is updated correctly.
          assertEquals(20, currentGameUiState.score)
      }

   10. Import the following:

   .. code:: prettyprint

      import org.junit.Assert.assertEquals
      import org.junit.Assert.assertFalse

   11. To make the value ``20`` readable and reusable, create a companion object and assign
       ``20`` to a ``private`` constant named ``SCORE_AFTER_FIRST_CORRECT_ANSWER``. Update
       the test with the newly created constant.

   .. code:: prettyprint

      class GameViewModelTest {
          ...
          @Test
          fun gameViewModel_CorrectWordGuessed_ScoreUpdatedAndErrorFlagUnset() {
              ...
              // Assert that score is updated correctly.
              assertEquals(SCORE_AFTER_FIRST_CORRECT_ANSWER, currentGameUiState.score)
          }

          companion object {
              private const val SCORE_AFTER_FIRST_CORRECT_ANSWER = SCORE_INCREASE
          }
      }

   12. Run the test.

   The test should pass, since all the assertions were valid, as shown in the following
   screenshot:

   |c412a2ac3fbefa57.png|


Error path

   To write a unit test for the error path, you need to assert that when an incorrect word
   is passed as an argument to the ``viewModel.updateUserGuess()`` method and the
   ``viewModel.checkUserGuess()`` method is called, then the following happens:

   -  The value of the ``currentGameUiState.score`` property remains unchanged.
   -  The value of the ``currentGameUiState.isGuessedWordWrong`` property is set to
      ``true`` because the guess is wrong.

   Complete the following steps to create the test:

   1. In the body of the ``GameViewModelTest`` class, create a
      ``gameViewModel_IncorrectGuess_ErrorFlagSet()`` function and annotate it with the
      ``@Test`` annotation.

   .. code:: prettyprint

      @Test
      fun gameViewModel_IncorrectGuess_ErrorFlagSet() {
          
      }

   2. Define an ``incorrectPlayerWord`` variable and assign the ``"and"`` value to it,
      which should not exist in the list of words.

   .. code:: prettyprint

      @Test
      fun gameViewModel_IncorrectGuess_ErrorFlagSet() {
          // Given an incorrect word as input
          val incorrectPlayerWord = "and"
      }

   3. Add a call to the ``viewModel.updateUserGuess()`` method and pass the
      ``incorrectPlayerWord`` variable as an argument.
   4. Add a call to the ``viewModel.checkUserGuess()`` method to verify the guess.

   .. code:: prettyprint

      @Test
      fun gameViewModel_IncorrectGuess_ErrorFlagSet() {
          // Given an incorrect word as input
          val incorrectPlayerWord = "and"

          viewModel.updateUserGuess(incorrectPlayerWord)
          viewModel.checkUserGuess()
      }

   5. Add a ``currentGameUiState`` variable and assign the value of the
      ``viewModel.uiState.value`` state to it.
   6. Use assertion functions to assert that the value of the ``currentGameUiState.score``
      property is ``0`` and the value of the ``currentGameUiState.isGuessedWordWrong``
      property is set to ``true``.

   .. code:: prettyprint

      @Test
      fun gameViewModel_IncorrectGuess_ErrorFlagSet() {
          // Given an incorrect word as input
          val incorrectPlayerWord = "and"

          viewModel.updateUserGuess(incorrectPlayerWord)
          viewModel.checkUserGuess()

          val currentGameUiState = viewModel.uiState.value
          // Assert that score is unchanged
          assertEquals(0, currentGameUiState.score)
          // Assert that checkUserGuess() method updates isGuessedWordWrong correctly
          assertTrue(currentGameUiState.isGuessedWordWrong)
      }

   7. Import the following:

   .. code:: prettyprint

      import org.junit.Assert.assertTrue

   8. Run the test to confirm that it passes.


**Boundary case**

   To test the initial state of the UI, you need to write a unit test for the
   ``GameViewModel`` class. The test must assert that when the ``GameViewModel`` is
   initialized, then the following is true:

   -  ``currentWordCount`` property is set to ``1``.
   -  ``score`` property is set to ``0``.
   -  ``isGuessedWordWrong`` property is set to ``false``.
   -  ``isGameOver`` property is set to ``false``.

   Complete the following steps to add the test:

   1. Create a ``gameViewModel_Initialization_FirstWordLoaded()`` method and annotate it
      with the ``@Test`` annotation.

   .. code:: prettyprint

      @Test
      fun gameViewModel_Initialization_FirstWordLoaded() {
          
      }

   2. Access ``viewModel.uiState.value`` property to get the initial instance of the
      ``GameUiState`` class. Assign it to a new ``gameUiState`` read-only variable.

   .. code:: prettyprint

      @Test
      fun gameViewModel_Initialization_FirstWordLoaded() {
          val gameUiState = viewModel.uiState.value
      }

   3. To get the correct player word, use the ``getUnscrambledWord()`` function, which
      takes in the ``gameUiState.currentScrambledWord`` word and returns the unscrambled
      word. Assign the returned value to a new read-only variable named
      ``unScrambledWord``.

   .. code:: prettyprint

      @Test
      fun gameViewModel_Initialization_FirstWordLoaded() {
          val gameUiState = viewModel.uiState.value
          val unScrambledWord = getUnscrambledWord(gameUiState.currentScrambledWord)

      }

   4. To verify the state is correct, add the ``assertTrue()`` functions to assert that the
      ``currentWordCount`` property is set to ``1``, and the ``score`` property is set to
      ``0``.
   5. Add ``assertFalse()`` functions to verify that the ``isGuessedWordWrong`` property is
      ``false`` and that the ``isGameOver`` property is set to ``false``.

   .. code:: prettyprint

      @Test
      fun gameViewModel_Initialization_FirstWordLoaded() {
          val gameUiState = viewModel.uiState.value
          val unScrambledWord = getUnscrambledWord(gameUiState.currentScrambledWord)

          // Assert that current word is scrambled.
          assertNotEquals(unScrambledWord, gameUiState.currentScrambledWord)
          // Assert that current word count is set to 1.
          assertTrue(gameUiState.currentWordCount == 1)
          // Assert that initially the score is 0.
          assertTrue(gameUiState.score == 0)
          // Assert that the wrong word guessed is false.
          assertFalse(gameUiState.isGuessedWordWrong)
          // Assert that game is not over.
          assertFalse(gameUiState.isGameOver)
      }

   6. Import the following:

   .. code:: prettyprint

      import org.junit.Assert.assertNotEquals

   7. Run the test to confirm that it passes.

   Another boundary case is to test the UI state after the user guesses all the words. You
   need to assert that when the user guesses all the words correctly, then the following is
   true:

   -  The score is up-to-date;
   -  The ``currentGameUiState.currentWordCount`` property is equal to the value of the
      ``MAX_NO_OF_WORDS`` constant;
   -  The ``currentGameUiState.isGameOver`` property is set to ``true``.

   Complete the following steps to add the test:

   1. Create a ``gameViewModel_AllWordsGuessed_UiStateUpdatedCorrectly()`` method and
      annotate it with the ``@Test`` annotation. In the method, create an ``expectedScore``
      variable and assign ``0`` to it.

   .. code:: prettyprint

      @Test
      fun gameViewModel_AllWordsGuessed_UiStateUpdatedCorrectly() {
          var expectedScore = 0
      }

   2. To get the initial state, add a ``currentGameUiState`` variable, and assign the value
      of the ``viewModel.uiState.value`` property to the variable.

   .. code:: prettyprint

      @Test
      fun gameViewModel_AllWordsGuessed_UiStateUpdatedCorrectly() {
          var expectedScore = 0
          var currentGameUiState = viewModel.uiState.value
      }

   3. To get the correct player word, use the ``getUnscrambledWord()`` function, which
      takes in the ``currentGameUiState.currentScrambledWord`` word and returns the
      unscrambled word. Store this returned value in a new read-only variable named
      ``correctPlayerWord`` and assign the value returned by the ``getUnscrambledWord()``
      function.

   .. code:: prettyprint

      @Test
      fun gameViewModel_AllWordsGuessed_UiStateUpdatedCorrectly() {
          var expectedScore = 0
          var currentGameUiState = viewModel.uiState.value
          var correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)
      }

   4. To test if the user guesses all the answers, use a ``repeat`` block to repeat the
      execution of the ``viewModel.updateUserGuess()`` method and the
      ``viewModel.checkUserGuess()`` method ``MAX_NO_OF_WORDS`` times.

   .. code:: prettyprint

      @Test
      fun gameViewModel_AllWordsGuessed_UiStateUpdatedCorrectly() {
          var expectedScore = 0
          var currentGameUiState = viewModel.uiState.value
          var correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)
          repeat(MAX_NO_OF_WORDS) {
              
          }
      }

   5. In the ``repeat`` block, add the value of the ``SCORE_INCREASE`` constant to the
      ``expectedScore`` variable to assert that the score increases after each correct
      answer.
   6. Add a call to the ``viewModel.updateUserGuess()`` method and pass the
      ``correctPlayerWord`` variable as an argument.
   7. Add a call to the ``viewModel.checkUserGuess()`` method to trigger the check for the
      user guess.

   .. code:: prettyprint

      @Test
      fun gameViewModel_AllWordsGuessed_UiStateUpdatedCorrectly() {
          var expectedScore = 0
          var currentGameUiState = viewModel.uiState.value
          var correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)
          repeat(MAX_NO_OF_WORDS) {
              expectedScore += SCORE_INCREASE
              viewModel.updateUserGuess(correctPlayerWord)
              viewModel.checkUserGuess()
          }
      }

   8. Update the current player word, use the ``getUnscrambledWord()`` function, which
      takes in the ``currentGameUiState.currentScrambledWord`` as an argument and returns
      the unscrambled word. Store this returned value in a new read-only variable named
      ``correctPlayerWord.`` To verify the state is correct, add the ``assertEquals()``
      function to check if the value of the ``currentGameUiState.score`` property is equal
      to the value of the ``expectedScore`` variable.

   .. code:: prettyprint

      @Test
      fun gameViewModel_AllWordsGuessed_UiStateUpdatedCorrectly() {
          var expectedScore = 0
          var currentGameUiState = viewModel.uiState.value
          var correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)
          repeat(MAX_NO_OF_WORDS) {
              expectedScore += SCORE_INCREASE
              viewModel.updateUserGuess(correctPlayerWord)
              viewModel.checkUserGuess()
              currentGameUiState = viewModel.uiState.value
              correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)
              // Assert that after each correct answer, score is updated correctly.
              assertEquals(expectedScore, currentGameUiState.score)
          }
      }

   9. Add an ``assertEquals()`` function to assert that the value of the
      ``currentGameUiState.currentWordCount`` property is equal to the value of the
      ``MAX_NO_OF_WORDS`` constant and that the value of the
      ``currentGameUiState.isGameOver`` property is set to ``true``.

   .. code:: prettyprint

      @Test
      fun gameViewModel_AllWordsGuessed_UiStateUpdatedCorrectly() {
          var expectedScore = 0
          var currentGameUiState = viewModel.uiState.value
          var correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)
          repeat(MAX_NO_OF_WORDS) {
              expectedScore += SCORE_INCREASE
              viewModel.updateUserGuess(correctPlayerWord)
              viewModel.checkUserGuess()
              currentGameUiState = viewModel.uiState.value
              correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)
              // Assert that after each correct answer, score is updated correctly.
              assertEquals(expectedScore, currentGameUiState.score)
          }
          // Assert that after all questions are answered, the current word count is up-to-date.
          assertEquals(MAX_NO_OF_WORDS, currentGameUiState.currentWordCount)
          // Assert that after 10 questions are answered, the game is over.
          assertTrue(currentGameUiState.isGameOver)
      }

   10. Import the following:

   .. code:: prettyprint

      import com.example.unscramble.data.MAX_NO_OF_WORDS

   11. Run the test to confirm that it passes.


**Test instance lifecycle overview**

   When you take a close look at the way ``viewModel`` initializes in the test, you might
   notice that the ``viewModel`` initializes only once even though all the tests use it.
   This code snippet shows the definition of the ``viewModel`` property.

   .. code:: prettyprint

      class GameViewModelTest {
          private val viewModel = GameViewModel()
          
          @Test
          fun gameViewModel_Initialization_FirstWordLoaded() {
              val gameUiState = viewModel.uiState.value
              ...
          }
          ...
      }

   You may wonder the following questions:

   -  Does it mean that the same instance of ``viewModel`` is reused for all the tests?
   -  Will it cause any issues? For example, what if the
      ``gameViewModel_Initialization_FirstWordLoaded`` test method executes after the
      ``gameViewModel_CorrectWordGuessed_ScoreUpdatedAndErrorFlagUnset`` test method? Will
      the initialization test fail?

   The answer to both questions is no. Test methods are executed in isolation to avoid
   unexpected side effects from mutable test instance state. By default, before each test
   method is executed, JUnit creates a new instance of the test class.

   Since you have four test methods so far in your ``GameViewModelTest`` class, the
   ``GameViewModelTest`` instantiates four times. Each instance has its own copy of the
   ``viewModel`` property. Hence, the sequence of test execution doesn't matter.

   **Note:** This "per-method" test instance lifecycle is the default behavior since
   JUnit4.


5. Introduction to code coverage
--------------------------------------------------------------------------------

   Code coverage plays a vital role to determine if you adequately test the classes,
   methods, and lines of code that make up your app.

   Android Studio provides a test coverage tool for local unit tests to track the
   percentage and areas of your app code that your unit tests covered.


**Run test with coverage using Android Studio**

   To run tests with coverage:

   1. Right-click the ``GameViewModelTest.kt`` file in the project pane and select
      |cf4c5adfe69a119f.png| **Run â€˜GameViewModelTest' with Coverage**.

   |73545d5ade3851df.png|

   2. After the test execution completes, in the coverage panel on the right, click the
      **Flatten Packages** option.

   |90e2989f8b58d254.png|

   3. Notice the **``com.example.android.unscramble.ui``** package as shown in the
      following image.

   |1c755d17d19c6f65.png|

   4. Double click on the package **``com.example.android.unscramble.ui``** name, displays
      the coverage for ``GameViewModel`` as shown in the following image:

   |14cf6ca3ffb557c4.png|


**Analyze test report**

   The report shown in the following diagram is broken down into two aspects:

   -  **The percentage of methods covered by the unit tests:** In the example diagram, the
      tests you wrote, so far, covered 7 out of 8 methods. That is 87% of the total
      methods.
   -  **The percentage of lines covered by the unit tests:** In the example diagram, the
      tests you wrote covered 39 out of 41 lines of code. That is 95% of the lines of code.

   **Note:** Code coverage tracks the number of lines executed during test execution.
   Hence, even though there are no verifications on ``GameUiState``, the coverage shows
   100%.

   The reports suggest that the unit tests you wrote so far missed certain parts of the
   code. To determine which parts were missed, complete the following step:

   -  Double-click **GameViewModel**.

   |c934ba14e096bddd.png|

   Android Studio displays the ``GameViewModel.kt`` file with additional color coding on
   the left side of the window. The bright green color indicates that those lines of code
   were covered.

   |edc4e5faf352119b.png|

   When you scroll down in the ``GameViewModel``, you might notice that a couple of lines
   are marked with a light pink color. This color indicates that these lines of code were
   not covered by the unit tests.

   |6df985f713337a0c.png|


**Improve coverage**

   To improve the coverage, you need to write a test that covers the missing path. You need
   to add a test to assert that when a user skips a word, then the following is true:

   -  ``currentGameUiState.score`` property remains unchanged.
   -  ``currentGameUiState.currentWordCount`` property is incremented by one, as shown in
      the following code snippet.

   To prepare to improve coverage, add the following test method to the
   ``GameViewModelTest`` class.

   .. code:: prettyprint

      @Test
      fun gameViewModel_WordSkipped_ScoreUnchangedAndWordCountIncreased() {
          var currentGameUiState = viewModel.uiState.value
          val correctPlayerWord = getUnscrambledWord(currentGameUiState.currentScrambledWord)
          viewModel.updateUserGuess(correctPlayerWord)
          viewModel.checkUserGuess()

          currentGameUiState = viewModel.uiState.value
          val lastWordCount = currentGameUiState.currentWordCount
          viewModel.skipWord()
          currentGameUiState = viewModel.uiState.value
          // Assert that score remains unchanged after word is skipped.
          assertEquals(SCORE_AFTER_FIRST_CORRECT_ANSWER, currentGameUiState.score)
          // Assert that word count is increased by 1 after word is skipped.
          assertEquals(lastWordCount + 1, currentGameUiState.currentWordCount)
      }

   Complete the following steps to re-run the coverage:

   1. Right-click the ``GameViewModelTest.kt`` file and from the menu and select **Run
      â€˜GameViewModelTest' with Coverage**.
   2. After the build is successful, navigate to the **GameViewModel** element again and
      confirm that the coverage percentage is 100%. The final coverage report is shown in
      the following image.

   |145781df2c68f71c.png|

   3. Navigate to the ``GameViewModel.kt`` file and scroll down to check whether the
      previously missed path is now covered.

   |357263bdb9219779.png|

   You learned how to run, analyze, and improve the code coverage of your application code.

   *Does a high code coverage percentage mean high quality of app code?* No. Code coverage
   indicates the percentage of code covered, or executed, by your unit test. It doesn't
   indicate that the code is verified. If you remove all the assertions from your unit test
   code and run the code coverage, it still shows 100% coverage.

   A high coverage doesn't indicate that the tests are designed correctly and that the
   tests verify the app's behavior. You need to ensure that the tests you wrote have the
   assertions that verify the behavior of the class being tested. You also don't have to
   strive to write unit tests to get a 100% test coverage for the entire app. You should
   test some parts of the app's code, such as Activities, using UI tests instead.

   However, a low coverage means that large parts of your code were completely untested.
   Use the code coverage as a tool to find the parts of code that were not executed by your
   tests, rather than a tool to measure your code's quality.


6. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble.git
      $ cd basic-android-kotlin-compose-training-unscramble
      $ git checkout main

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-unscramble/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the downloaded repository.

   If you want to see the solution code, 
   `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-unscramble>`__.


7. Conclusion
--------------------------------------------------------------------------------

   Congratulations! You learned how to define test strategy and implemented unit tests to
   test the ``ViewModel`` and ``StateFlow`` in the Unscramble app. As you continue to build
   Android apps, make sure that you write tests alongside your app features to confirm that
   your apps work properly throughout the development process.


**Summary**

   -  Use the ``testImplementation`` configuration to indicate that the dependencies apply
      to the local test source code and not the application code.
   -  Aim to categorize tests in three scenarios: Success path, error path, and boundary case.
   -  A good unit test has at least four characteristics: they are focused, understandable,
      deterministic, and self-contained.
   -  Test methods are executed in isolation to avoid unexpected side effects from mutable
      test instance state.
   -  By default, before each test method executes, JUnit creates a new instance of the test class.
   -  Code coverage plays a vital role to determine whether you adequately tested the
      classes, methods, and lines of code that make up your app.


**Learn more**

   -  `Fundamentals of testing Android apps <https://developer.android.google.cn/training/testing/fundamentals#benefits>`__
   -  `Using the Bill of Materials \| Jetpack Compose \| Android Developers <https://developer.android.google.cn/jetpack/compose/bom/bom>`__

.. |bb1e97c357603a27.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/bb1e97c357603a27.png
.. |1a2dceb0dd9c618d.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/1a2dceb0dd9c618d.png
.. |bc235c0754e4e0f2.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/bc235c0754e4e0f2.png
.. |1c20fc10750ca60c.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/1c20fc10750ca60c.png
.. |57d004ccc4d75833.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/57d004ccc4d75833.png
.. |f98067499852bdce.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/f98067499852bdce.png
.. |c412a2ac3fbefa57.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/c412a2ac3fbefa57.png
.. |cf4c5adfe69a119f.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/cf4c5adfe69a119f.png
.. |73545d5ade3851df.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/73545d5ade3851df.png
.. |90e2989f8b58d254.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/90e2989f8b58d254.png
.. |1c755d17d19c6f65.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/1c755d17d19c6f65.png
.. |14cf6ca3ffb557c4.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/14cf6ca3ffb557c4.png
.. |c934ba14e096bddd.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/c934ba14e096bddd.png
.. |edc4e5faf352119b.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/edc4e5faf352119b.png
.. |6df985f713337a0c.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/6df985f713337a0c.png
.. |145781df2c68f71c.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/145781df2c68f71c.png
.. |357263bdb9219779.png| image:: https://github.com/static/codelabs/basic-android-kotlin-compose-test-viewmodel/img/357263bdb9219779.png


ğŸš€ Practice: Add a ViewModel to Dessert Clicker
===============================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-viewmodel


1. Before you begin
--------------------------------------------------------------------------------


Introduction

   Dessert Clicker works with inline state and data. In this exercise, you will remove the inline
   state, data, and logic out of the MainActivity and move it to a ``ViewModel``.

   Abstracting app logic away from the view and into a ViewModel is a modern practice for Android
   development. This practice offers the following benefits:

   -  The code becomes more readable for other developers.
   -  The code becomes more testable.
   -  Multiple developers can work simultaneously on an app without interfering with other
      developers' work.

   The solution code is available at the end, but try to solve the exercises before you check the
   answers. Consider the solution as one way to implement the app.


Prerequisites

   -  The Android Basics in Compose coursework through the 
      `ViewModel and State in Compose codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-viewmodel-and-state>`__


What you'll need

   -  A computer with internet access and Android Studio installed
   -  The solution code for the Dessert Clicker app


What you'll build

   In these practice problems, you will improve the architecture of the Dessert Clicker app by
   adding a ``ViewModel`` to handle the data and app logic.

   The practice problems are split into sections where you will complete the following steps
   individually:

   -  Update and add the necessary dependencies.
   -  Create a ``ViewModel`` class.


2. Download the starter code
--------------------------------------------------------------------------------

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-clicker/tree/main

   **Branch name with starter code:** ``main``

   1. In Android Studio, open the ``basic-android-kotlin-compose-training-dessert-clicker`` folder.
   2. Open the Dessert Clicker app code in Android Studio.


3. Set up dependencies
--------------------------------------------------------------------------------

   1. Add the following variable to your project ``build.gradle`` file:

   .. code:: prettyprint

      buildscript {
         ext {
             ...
             lifecycle_version = '2.5.1'
         }
      }

   2. Add the following dependency to the ``app/build.gradle`` file:

   .. code:: prettyprint

      dependencies {
          ...implementation "androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycle_version"
      }


4. Create a UI state class
--------------------------------------------------------------------------------

   Currently, the ``DessertClickerApp()`` composable in the ``MainActivity`` contains the data and
   state that drive the UI.

   Create a data class that holds all the necessary data for the UI. The data within this class
   replaces the data that the ``DessertClickerApp()`` composable currently manages.


5. Create a ViewModel
--------------------------------------------------------------------------------

   Create a ``ViewModel`` class using the Jetpack ViewModel component. You use the ViewModel to
   manage the UI state.


6. Relocate the app logic and data to the ViewModel
--------------------------------------------------------------------------------

   Relocate the logic from the ``MainActivity`` to the ViewModel and make the UI state data
   accessible using the UI state class you created. Delete all the data and state management logic
   from ``MainActivity``.

   Try to approach this task on your own. If necessary, refer to the 
   `ViewModel and State in Compose codelab for guidance. <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-viewmodel-and-state>`__


7. Call the ViewModel
--------------------------------------------------------------------------------

   Use the data and methods that the ViewModel provides to drive the UI in the ``MainActivity``.


8. Solution code
--------------------------------------------------------------------------------

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-clicker/tree/viewmodel

   **Branch name with starter code:** ``viewmodel``


ğŸš€ Navigate between screens with Compose
========================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-navigation


1. Before you begin
--------------------------------------------------------------------------------

   Up until this point, the apps you've worked on consisted of a single screen. However, a
   lot of the apps you use probably have multiple screens that you can navigate through.
   For example, the Settings app has many pages of content spread across different screens.

   ====================== ====================== ======================
   |fa955a02eea01b57.png| |4cbe48d4d7de26ff.png| |bd6d050e9b0be97e.png|
   ====================== ====================== ======================

   In modern Android development, multiscreen apps are created using the Jetpack Navigation
   component. The Navigation Compose component allows you to easily build multi screen apps
   in Compose using a declarative approach, just like building user interfaces. This
   codelab introduces the essentials of the Navigation Compose component, how to make the
   AppBar responsive, and how to send data from your app to another app using intentsâ€”all
   while demonstrating best practices in an increasingly complex app.


Prerequisites

   -  Familiarity with the Kotlin language, including function types, lambdas, and scope
      functions
   -  Familiarity with basic ``Row`` and ``Column`` layouts in Compose


What you'll learn

   -  Create a ``NavHost`` composable to define routes and screens in your app.
   -  Navigate between screens using a ``NavHostController``.
   -  Manipulate the back stack to navigate to previous screens.
   -  Use intents to share data with another app.
   -  Customize the AppBar, including the title and back button.


What you'll build

   -  You'll implement navigation in a multiscreen app.


What you'll need

   -  The latest version of Android Studio
   -  An internet connection to download the starter code


2. Download starter code
--------------------------------------------------------------------------------

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-cupcake/archive/refs/heads/starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-cupcake.git
      $ cd basic-android-kotlin-compose-training-cupcake
      $ git checkout starter

   **Note:** The starter code is in the ``starter`` branch of the downloaded repository.

   If you want to see the starter code for this codelab, view it on
   `GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-cupcake/tree/starter>`__.


3. App walkthrough
--------------------------------------------------------------------------------

   The Cupcake app is a bit different than the apps you've worked with so far. Instead of
   all the content displaying on a single screen, the app has four separate screens, and
   the user can navigate through each screen while ordering cupcakes. If you run the app,
   you won't see anything and you won't be able to navigate between these screens since the
   navigation component is not added to the app code yet. However, you can still check the
   composable previews for each screen and match them with the final app screens below.


Start order screen

   The first screen presents the user with three buttons that correspond to the quantity of
   cupcakes to order.

   ====================== ======================
   |6979f0bec2de8dbd.png| |ffb8d156220c7e57.png|
   ====================== ======================

   In code, this is represented by the ``StartOrderScreen`` composable in
   ``StartOrderScreen.kt``.

   The screen consists of a single column, with an image and text, along with three custom
   buttons to order different quantities of cupcakes. The custom buttons are implemented by
   the ``SelectQuantityButton`` composable, which is also in ``StartOrderScreen.kt``.


Choose flavor screen

   After selecting the quantity, the app prompts the user to select a cupcake flavor. The
   app uses what's known as *radio buttons* to display different options. Users can select
   one flavor out of a choice of possible flavors.

   ====================== ======================
   |ac6e828a9105af26.png| |b55c8b57ac60fe51.png|
   ====================== ======================

   The list of possible flavors is stored as a list of string resource IDs in
   ``data.DataSource.kt``.


Choose pickup date screen

   After choosing a flavor, the app presents users with another series of radio buttons to
   select a pickup date. Pickup options come from a list returned by the
   ``pickupOptions()`` function in ``OrderViewModel``.

   ====================== ======================
   |ac6e828a9105af26.png| |aa6d382dd8c0af7.png|
   ====================== ======================

   Both the **Choose Flavor** screen and **Choose Pickup Date** screen are represented by
   the same composable, ``SelectOptionScreen`` in ``SelectOptionScreen.kt``. Why use the
   same composable? The layout of these screens is exactly the same! The only difference is
   the data, but you can use the same composable to display both the flavor and pickup date
   screens.


Order Summary screen

   After selecting the pickup date, the app displays the **Order Summary** screen where the
   user can review and complete the order.

   ====================== ======================
   |3bfc1693d3afc984.png| |7fc4d9ee733fcccb.png|
   ====================== ======================

   This screen is implemented by the ``OrderSummaryScreen`` composable in
   ``SummaryScreen.kt``.

   The layout consists of a ``Column`` containing all the information about their order, a
   ``Text`` composable for the subtotal, and buttons to either send the order to another
   app or cancel the order and return to the first screen.

   If users choose to send the order to another app, the Cupcake app displays an 
   `Android ShareSheet <https://developer.android.google.cn/training/sharing/send#why-to-use-system-sharesheet>`__
   that shows different sharing options.

   |13bde33712e135a4.png|

   The current state of the app is stored in ``data.OrderUiState.kt``. The ``OrderUiState``
   data class contains properties to store the user's selections from each screen.

   The screens of the app will be presented in the ``CupcakeApp`` composable. However, in
   the starter project, the app simply shows the first screen. It's not currently possible
   to navigate through all the screens of the app, but don't worry, that's what you're here
   for! You'll learn how to define navigation routes, set up a NavHost composable to
   navigate between screensâ€”also known as destinationsâ€”perform intents to integrate with
   system UI components like the share screen, and make the AppBar respond to navigation
   changes.


Reusable composables

   Where appropriate, the sample apps in this course are designed to implement best
   practices. The Cupcake app is no exception. In the **ui.components** package, you'll see
   a file named ``CommonUi.kt`` that contains a ``FormattedPriceLabel`` composable.
   Multiple screens in the app use this composable to format the order price consistently.
   Rather than duplicate the same ``Text`` composable with the same formatting and
   modifiers, you can define ``FormattedPriceLabel`` once and then reuse it as many times
   as needed for other screens.

   The flavor and pickup date screens use the ``SelectOptionScreen`` composable, which is
   also reusable. This composable takes a parameter named ``options`` of the type
   ``List<String>`` that represents the options to display. The options appear in a
   ``Row``, consisting of a ``RadioButton`` composable and a ``Text`` composable containing
   each string. A ``Column`` surrounds the entire layout and also contains a ``Text``
   composable to show the formatted price, a **Cancel** button, and a **Next** button.


4. Define routes and create a NavHostController
--------------------------------------------------------------------------------


Parts of the Navigation Component

   The Navigation component has three main parts:

   -  **NavController:** Responsible for navigating between destinationsâ€”that is, the
      screens in your app.
   -  **NavGraph:** Maps composable destinations to navigate to.
   -  **NavHost:** Composable acting as a container for displaying the current destination
      of the NavGraph.

   In this codelab, you'll focus on the NavController and the NavHost. Within the NavHost,
   you'll define the destinations for the Cupcake app's NavGraph.


Define routes for destinations in your app

   One of the fundamental concepts of navigation in a Compose app is the route. A route is
   a string that corresponds to a destination. This idea is similar to the concept of a
   URL. Just as a different URL maps to a different page on a website, a route is a string
   that maps to a destination and serves as its unique identifier. A destination is
   typically a single Composable or group of Composables corresponding to what the user
   sees. The Cupcake app needs destinations for the start order screen, the flavor screen,
   the pickup date screen, and the order summary screen.

   There are a finite number of screens in an app, so there are also a finite number of
   routes. You can define an app's routes using an enum class. Enum classes in Kotlin have
   a name property that returns a string with the property name.

   You'll start by defining the four routes of the Cupcake app.

   -  **``Start``:** Select the quantity of cupcakes from one of three buttons.
   -  **``Flavor``:** Select the flavor from a list of choices.
   -  **``Pickup``:** Select the pickup date from a list of choices.
   -  **``Summary``:** Review the selections and either send or cancel the order.

   Add an enum class to define the routes.

   1. In ``CupcakeScreen.kt``, above the ``CupcakeAppBar`` composable, add an enum class
      named ``CupcakeScreen``.

   .. code:: prettyprint

      enum class CupcakeScreen() {
          
      }

   2. Add four cases to the enum class: ``Start``, ``Flavor``, ``Pickup``, and ``Summary``.

   .. code:: prettyprint

      enum class CupcakeScreen() {
          Start,
          Flavor,
          Pickup,
          Summary
      }


Add a NavHost to your app

   A NavHost is a Composable that displays other composable destinations, based on a given
   route. For example, if the route is ``Flavor``, then the ``NavHost`` would show the
   screen to choose the cupcake flavor. If the route is ``Summary``, then the app displays
   the summary screen.

   The syntax for ``NavHost`` is just like any other Composable.

   |fae7688d6dd53de9.png|

   There are two notable parameters.

   -  **``navController``:** An instance of the ``NavHostController`` class. You can use
      this object to navigate between screens, for example, by calling the ``navigate()``
      method to navigate to another destination. You can obtain the ``NavHostController``
      by calling ``rememberNavController()`` from a composable function.
   -  **``startDestination``:** A string route defining the destination shown by default
      when the app first displays the ``NavHost``. In the case of the Cupcake app, this
      should be the ``Start`` route.

   Like other composables, ``NavHost`` also takes a ``modifier`` parameter.

   **Note:**
   `NavHostController <https://developer.android.google.cn/reference/androidx/navigation/NavHostController>`__
   is a subclass of the
   `NavController <https://developer.android.google.cn/reference/androidx/navigation/NavController>`__
   class that provides additional functionality for use with a ``NavHost`` composable.

   You'll add a ``NavHost`` to the ``CupcakeApp`` composable in ``CupcakeScreen.kt``.
   First, you need a reference to the navigation controller. You can use the navigation
   controller in both the ``NavHost`` you're adding now and the ``AppBar`` you'll add in a
   later step. Therefore, you should declare the variable in the ``CupcakeApp()``
   composable.

   1. Open ``CupcakeScreen.kt``.
   2. Within the ``Scaffold``, below the ``uiState`` variable, add a ``NavHost``
      composable.

   .. code:: prettyprint

      import androidx.navigation.compose.NavHost

      Scaffold(
          ...
      ) { innerPadding ->
          val uiState by viewModel.uiState.collectAsState()

          NavHost()
      }

   3. Pass in the ``navController`` variable for the ``navController`` parameter and
      ``CupcakeScreen.Start.name`` for the ``startDestination`` parameter. Pass the
      modifier that was passed into ``CupcakeApp()`` for the modifier parameter. Pass in an
      empty trailing lambda for the final parameter.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.padding

      NavHost(
          navController = navController,
          startDestination = CupcakeScreen.Start.name,
          modifier = Modifier.padding(innerPadding)
      ) {

      }


Handle routes in your ``NavHost``

   Like other composables, ``NavHost`` takes a function type for its content.

   |f67974b7fb3f0377.png|

   Within the content function of a ``NavHost``, you call the ``composable()`` function.
   The ``composable()`` function has two required parameters.

   -  **``route``:** A string corresponding to the name of a route. This can be any unique
      string. You'll use the name property of the ``CupcakeScreen`` enum's constants.
   -  **``content``:** Here you can call a composable that you want to display for the
      given route.

   You'll call the ``composable()`` function once for each of the four routes.

   **Note:** The ``composable()`` function is an extension function of
   `NavGraphBuilder <https://developer.android.google.cn/reference/kotlin/androidx/navigation/NavGraphBuilder>`__.

   1. Call the ``composable()`` function, passing in ``CupcakeScreen.Start.name`` for the
      ``route``.

   .. code:: prettyprint

      import androidx.navigation.compose.composable

      NavHost(
          navController = navController,
          startDestination = CupcakeScreen.Start.name,
          modifier = Modifier.padding(innerPadding)
      ) {
          composable(route = CupcakeScreen.Start.name) {
              
          }
      }

   2. Within the trailing lambda, call the ``StartOrderScreen`` composable, passing in
      ``quantityOptions`` for the ``quantityOptions`` property. For the ``modifier`` pass
      in ``Modifier.fillMaxSize().padding(dimensionResource(R.dimen.padding_medium))``

   .. code:: prettyprint

      import androidx.compose.foundation.layout.fillMaxSize
      import androidx.compose.ui.res.dimensionResource
      import com.example.cupcake.ui.StartOrderScreen
      import com.example.cupcake.data.DataSource

      NavHost(
          navController = navController,
          startDestination = CupcakeScreen.Start.name,
          modifier = Modifier.padding(innerPadding)
      ) {
          composable(route = CupcakeScreen.Start.name) {
              StartOrderScreen(
                  quantityOptions = DataSource.quantityOptions,
                  modifier = Modifier
                      .fillMaxSize()
                      .padding(dimensionResource(R.dimen.padding_medium))
              )
          }
      }

   **Note:** The ``quantityOptions`` property comes from the ``DataSource`` singleton
   object in **DataSource.kt**.

   3. Below the first call to ``composable()``, call ``composable()`` again, passing in
      ``CupcakeScreen.Flavor.name`` for the ``route``.

   .. code:: prettyprint

      composable(route = CupcakeScreen.Flavor.name) {
          
      }

   4. Within the trailing lambda, get a reference to ``LocalContext.current`` and store it
      in a variable named ``context``.
      `Context <https://developer.android.google.cn/reference/android/content/Context>`__
      is an abstract class whose implementation is provided by the Android system. It
      allows access to application-specific resources and classes, as well as up-calls for
      application-level operations such as launching activities, etc. You can use this
      variable to get the strings from the list of resource IDs in the view model to
      display the list of flavors.

   .. code:: prettyprint

      import androidx.compose.ui.platform.LocalContext

      composable(route = CupcakeScreen.Flavor.name) {
          val context = LocalContext.current
      }

   5. Call the ``SelectOptionScreen`` composable.

   .. code:: prettyprint

      composable(route = CupcakeScreen.Flavor.name) {
          val context = LocalContext.current
          SelectOptionScreen(

          )
      }

   6. The flavor screen needs to display and update the subtotal when the user selects a
      flavor. Pass in ``uiState.price`` for the ``subtotal`` parameter.

   .. code:: prettyprint

      composable(route = CupcakeScreen.Flavor.name) {
          val context = LocalContext.current
          SelectOptionScreen(
              subtotal = uiState.price
          )
      }

   7. The flavor screen gets the list of flavors from the app's string resources. Transform
      the list of resource IDs into a list of strings using the ``map()`` function and
      calling ``context.resources.getString(id)`` for each flavor.

   .. code:: prettyprint

      import com.example.cupcake.ui.SelectOptionScreen

      composable(route = CupcakeScreen.Flavor.name) {
          val context = LocalContext.current
          SelectOptionScreen(
              subtotal = uiState.price,
              options = DataSource.flavors.map { id -> context.resources.getString(id) }
          )
      }

   8. For the ``onSelectionChanged`` parameter, pass in a lambda expression that calls
      ``setFlavor()`` on the view model, passing in ``it`` (the argument passed into
      ``onSelectionChanged()``). For the ``modifier`` parameter, pass in
      ``Modifier.fillMaxHeight().``

   .. code:: prettyprint

      import androidx.compose.foundation.layout.fillMaxHeight
      import com.example.cupcake.data.DataSource.flavors

      composable(route = CupcakeScreen.Flavor.name) {
          val context = LocalContext.current
          SelectOptionScreen(
              subtotal = uiState.price,
              options = DataSource.flavors.map { id -> context.resources.getString(id) },
              onSelectionChanged = { viewModel.setFlavor(it) },
              modifier = Modifier.fillMaxHeight()
          )
      }

   The pickup date screen. is similar to the flavor screen. The only difference is the data
   passed into the ``SelectOptionScreen`` composable.

   9. Call the ``composable()`` function again, passing in ``CupcakeScreen.Pickup.name``
      for the ``route`` parameter.

   .. code:: prettyprint

      composable(route = CupcakeScreen.Pickup.name) {
          
      }

   10. In the trailing lambda, call the ``SelectOptionScreen`` composable and pass in
       ``uiState.price`` for the ``subtotal``, as before. Pass in ``uiState.pickupOptions``
       for the ``options`` parameter and a lambda expression that calls ``setDate()`` on
       the ``viewModel`` for the ``onSelectionChanged`` parameter. For the ``modifier``
       parameter, pass in ``Modifier.fillMaxHeight().``

   .. code:: prettyprint

      SelectOptionScreen(
          subtotal = uiState.price,
          options = uiState.pickupOptions,
          onSelectionChanged = { viewModel.setDate(it) },
          modifier = Modifier.fillMaxHeight()
      )

   11. Call ``composable()`` one more time, passing in ``CupcakeScreen.Summary.name`` for
       the ``route``.

   .. code:: prettyprint

      composable(route = CupcakeScreen.Summary.name) {
          
      }

   12. In the trailing lambda, call the ``OrderSummaryScreen()`` composable, passing in the
       ``uiState`` variable for the ``orderUiState`` parameter. For the ``modifier``
       parameter, pass in ``Modifier.fillMaxHeight().``

   .. code:: prettyprint

      import com.example.cupcake.ui.OrderSummaryScreen

      composable(route = CupcakeScreen.Summary.name) {
          OrderSummaryScreen(
              orderUiState = uiState,
              modifier = Modifier.fillMaxHeight()
          )
      }

   That's it for setting up the ``NavHost``. In the next section, you'll make your app
   change routes and navigate between screens when the user taps each of the buttons.


5. Navigate between routes
--------------------------------------------------------------------------------

   Now that you've defined your routes and mapped them to composables in a ``NavHost``,
   it's time to navigate between screens. The ``NavHostController``â€”the ``navController``
   property from calling ``rememberNavController()``â€”is responsible for navigating between
   routes. Notice, however, that this property is defined in the ``CupcakeApp`` composable.
   You need a way to access it from the different screens in your app.

   Easy, right? Just pass the ``navController`` as a parameter to each of the composables.

   While this approach works, it's not an ideal way to architect your app. A benefit of
   using a NavHost to handle your app's navigation is that navigation logic is *kept
   separate from individual UI*. This option avoids some of the major drawbacks of passing
   the ``navController`` as a parameter.

   -  Navigation logic is kept in one place, which can make your code easier to maintain
      and prevent bugs by not accidentally giving individual screens free reign of
      navigation in your app.
   -  In apps that need to work on different form factors (like portrait mode phone,
      foldable phone, or large screen tablet), a button may or may not trigger navigation,
      depending on the app's layout. Individual screens should be self-contained and don't
      need to be aware of other screens in the app.

   Instead, our approach is to pass a function type into each composable for what should
   happen when a user clicks the button. That way, the composable and any of its child
   composables decide when to call the function. However, navigation logic isn't exposed to
   the individual screens in your app. All the navigation behavior is handled in the
   NavHost.


Add button handlers to ``StartOrderScreen``

   You'll start by adding a function type parameter that is called when one of the quantity
   buttons is pressed on the first screen. This function is passed into the
   ``StartOrderScreen`` composable and is responsible for updating the viewmodel and
   navigating to the next screen.

   1. Open ``StartOrderScreen.kt``.
   2. Below the ``quantityOptions`` parameter, and before the modifier parameter, add a
      parameter named ``onNextButtonClicked`` of type ``() -> Unit``.

   .. code:: prettyprint

      @Composable
      fun StartOrderScreen(
          quantityOptions: List<Pair<Int, Int>>,
          onNextButtonClicked: () -> Unit,
          modifier: Modifier = Modifier
      ){
          ...
      }

   3. Now that the ``StartOrderScreen`` composable expects a value for
      ``onNextButtonClicked``, find the ``StartOrderPreview`` and pass an empty lambda body
      to the ``onNextButtonClicked`` parameter.

   .. code:: prettyprint

      @Preview
      @Composable
      fun StartOrderPreview() {
          CupcakeTheme {
              StartOrderScreen(
                  quantityOptions = DataSource.quantityOptions,
                  onNextButtonClicked = {},
                  modifier = Modifier
                      .fillMaxSize()
                      .padding(dimensionResource(R.dimen.padding_medium))
              )
          }
      }

   Each button corresponds to a different quantity of cupcakes. You'll need this
   information so that the function passed in for ``onNextButtonClicked`` can update the
   viewmodel accordingly.

   4. Modify the ``onNextButtonClicked`` parameter's type to take an ``Int`` parameter.

   .. code:: prettyprint

      onNextButtonClicked: (Int) -> Unit,

   To get the ``Int`` to pass in when calling ``onNextButtonClicked()``, take a look at the
   type of ``quantityOptions`` parameter.

   The type is ``List<Pair<Int, Int>>`` or a list of ``Pair<Int, Int>``. The
   `Pair <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/>`__ type may be
   unfamiliar to you, but it's just as the name suggests, a pair of values. ``Pair`` takes
   two generic type parameters. In this case, they're both of type ``Int``.

   |8326701a77706258.png|

   Each item in a pair is accessed by either the first property or second property. In the
   case of the ``StartOrderScreen`` composable's ``quantityOptions`` parameter, the first
   ``Int`` is a resource ID for the string to display on each button. The second ``Int`` is
   the actual quantity of cupcakes.

   We'll pass the second property of the selected pair when calling the
   ``onNextButtonClicked()`` function.

   1. Find the empty lambda expression for the ``onClick`` parameter of the
      ``SelectQuantityButton``.

   .. code:: prettyprint

      quantityOptions.forEach { item ->
          SelectQuantityButton(
              labelResourceId = item.first,
              onClick = {}
          )
      }

   2. Within the lambda expression, call ``onNextButtonClicked``, passing in
      ``item.second``â€”the number of cupcakes.

   .. code:: prettyprint

      quantityOptions.forEach { item ->
          SelectQuantityButton(
              labelResourceId = item.first,
              onClick = { onNextButtonClicked(item.second) }
          )
      }


Add button handlers to SelectOptionScreen

   1. Below the ``onSelectionChanged`` parameter of the ``SelectOptionScreen`` composable
      in ``SelectOptionScreen.kt``, add a parameter named ``onCancelButtonClicked`` of type
      ``() -> Unit`` with a default value of ``{}``.

   .. code:: prettyprint

      @Composable
      fun SelectOptionScreen(
          subtotal: String,
          options: List<String>,
          onSelectionChanged: (String) -> Unit = {},
          onCancelButtonClicked: () -> Unit = {},
          modifier: Modifier = Modifier
      )

   2. Below the ``onCancelButtonClicked`` parameter, add another parameter of type
      ``() -> Unit`` named ``onNextButtonClicked`` with a default value of ``{}``.

   .. code:: prettyprint

      @Composable
      fun SelectOptionScreen(
          subtotal: String,
          options: List<String>,
          onSelectionChanged: (String) -> Unit = {},
          onCancelButtonClicked: () -> Unit = {},
          onNextButtonClicked: () -> Unit = {},
          modifier: Modifier = Modifier
      )

   3. Pass in ``onCancelButtonClicked`` for the cancel button's ``onClick`` parameter.

   .. code:: prettyprint

      OutlinedButton(
          modifier = Modifier.weight(1f),
          onClick = onCancelButtonClicked
      ) {
          Text(stringResource(R.string.cancel))
      }

   4. Pass in ``onNextButtonClicked`` for the next button's ``onClick`` parameter.

   .. code:: prettyprint

      Button(
          modifier = Modifier.weight(1f),
          enabled = selectedValue.isNotEmpty(),
          onClick = onNextButtonClicked
      ) {
          Text(stringResource(R.string.next))
      }


Add button handlers to SummaryScreen

   Finally, add button handler functions for the **Cancel** and **Send** buttons on the
   summary screen.

   1. In the ``OrderSummaryScreen`` composable in **``SummaryScreen.kt``**, add a parameter
      named ``onCancelButtonClicked`` of type ``() -> Unit``.

   .. code:: prettyprint

      @Composable
      fun OrderSummaryScreen(
          orderUiState: OrderUiState,
          onCancelButtonClicked: () -> Unit,
          modifier: Modifier = Modifier
      ){
          ...
      }

   2. Add another parameter of type ``(String, String) -> Unit`` and name this one
      ``onSendButtonClicked``.

   .. code:: prettyprint

      @Composable
      fun OrderSummaryScreen(
          orderUiState: OrderUiState,
          onCancelButtonClicked: () -> Unit,
          onSendButtonClicked: (String, String) -> Unit,
          modifier: Modifier = Modifier
      ){
          ...
      }

   3. The ``OrderSummaryScreen`` composable now expects values for ``onSendButtonClicked``
      and ``onCancelButtonClicked``. Find the ``OrderSummaryPreview``, pass an empty lambda
      body with two ``String`` parameters to ``onSendButtonClicked`` and an empty lambda
      body to the ``onCancelButtonClicked`` parameters.

   .. code:: prettyprint

      @Preview
      @Composable
      fun OrderSummaryPreview() {
         CupcakeTheme {
             OrderSummaryScreen(
                 orderUiState = OrderUiState(0, "Test", "Test", "$300.00"),
                 onSendButtonClicked = { subject: String, summary: String -> },
                 onCancelButtonClicked = {},
                 modifier = Modifier.fillMaxHeight()
             )
         }
      }

   4. Pass ``onSendButtonClicked`` for the ``onClick`` parameter of the **Send** button.
      Pass in ``newOrder`` and ``orderSummary``, the two variables defined earlier in
      ``OrderSummaryScreen``. These strings consist of the actual data that the user can
      share with another app.

   .. code:: prettyprint

      Button(
          modifier = Modifier.fillMaxWidth(),
          onClick = { onSendButtonClicked(newOrder, orderSummary) }
      ) {
          Text(stringResource(R.string.send))
      }

   5. Pass ``onCancelButtonClicked`` for the ``onClick`` parameter of the **Cancel**
      button.

   .. code:: prettyprint

      OutlinedButton(
          modifier = Modifier.fillMaxWidth(),
          onClick = onCancelButtonClicked
      ) {
          Text(stringResource(R.string.cancel))
      }


Navigate to another route

   To navigate to another route, simply call the ``navigate()`` method on your instance of
   ``NavHostController``.

   |fc8aae3911a6a25d.png|

   The navigate method takes a single parameter: a ``String`` corresponding to a route
   defined in your ``NavHost``. If the route matches one of the calls to ``composable()``
   in the ``NavHost``, the app then navigates to that screen.

   You'll pass in functions that call ``navigate()`` when the user presses buttons on the
   ``Start``, ``Flavor``, and ``Pickup`` screens.

   1. In ``CupcakeScreen.kt``, find the call to ``composable()`` for the start screen. For
      the ``onNextButtonClicked`` parameter, pass in a lambda expression.

   .. code:: prettyprint

      StartOrderScreen(
          quantityOptions = DataSource.quantityOptions,
          onNextButtonClicked = {
          }
      )

   Remember the ``Int`` property passed into this function for the number of cupcakes?
   Before navigating to the next screen, you should update the view model so that the app
   displays the correct subtotal.

   2. Call ``setQuantity`` on the ``viewModel``, passing in ``it``.

   .. code:: prettyprint

      onNextButtonClicked = {
          viewModel.setQuantity(it)
      }

   3. Call ``navigate()`` on the ``navController``, passing in
      ``CupcakeScreen.Flavor.name`` for the ``route``.

   .. code:: prettyprint

      onNextButtonClicked = {
          viewModel.setQuantity(it)
          navController.navigate(CupcakeScreen.Flavor.name)
      }

   4. For the ``onNextButtonClicked`` parameter on the flavor screen, simply pass in a
      lambda that calls ``navigate()``, passing in ``CupcakeScreen.Pickup.name`` for the
      ``route``.

   .. code:: prettyprint

      composable(route = CupcakeScreen.Flavor.name) {
          val context = LocalContext.current
          SelectOptionScreen(
              subtotal = uiState.price,
              onNextButtonClicked = { navController.navigate(CupcakeScreen.Pickup.name) },
              options = DataSource.flavors.map { id -> context.resources.getString(id) },
              onSelectionChanged = { viewModel.setFlavor(it) },
              modifier = Modifier.fillMaxHeight()
          )
      }

   5. Pass in an empty lambda for ``onCancelButtonClicked``, which you implement next.

   .. code:: prettyprint

      SelectOptionScreen(
          subtotal = uiState.price,
          onNextButtonClicked = { navController.navigate(CupcakeScreen.Pickup.name) },
          onCancelButtonClicked = {},
          options = DataSource.flavors.map { id -> context.resources.getString(id) },
          onSelectionChanged = { viewModel.setFlavor(it) },
          modifier = Modifier.fillMaxHeight()
      )

   6. For the ``onNextButtonClicked`` parameter on the pickup screen, pass in a lambda that
      calls ``navigate()``, passing in ``CupcakeScreen.Summary.name`` for the ``route``.

   .. code:: prettyprint

      composable(route = CupcakeScreen.Pickup.name) {
          SelectOptionScreen(
              subtotal = uiState.price,
              onNextButtonClicked = { navController.navigate(CupcakeScreen.Summary.name) },
              options = uiState.pickupOptions,
              onSelectionChanged = { viewModel.setDate(it) },
              modifier = Modifier.fillMaxHeight()
          )
      }

   7. Again, pass in an empty lambda for ``onCancelButtonClicked()``.

   .. code:: prettyprint

      SelectOptionScreen(
          subtotal = uiState.price,
          onNextButtonClicked = { navController.navigate(CupcakeScreen.Summary.name) },
          onCancelButtonClicked = {},
          options = uiState.pickupOptions,
          onSelectionChanged = { viewModel.setDate(it) },
          modifier = Modifier.fillMaxHeight()
      )

   8. For the ``OrderSummaryScreen``, pass in empty lambdas for ``onCancelButtonClicked``
      and ``onSendButtonClicked``. Add parameters for the ``subject`` and ``summary`` that
      are passed into ``onSendButtonClicked``, which you will implement soon.

   .. code:: prettyprint

      composable(route = CupcakeScreen.Summary.name) {
          OrderSummaryScreen(
              orderUiState = uiState,
              onCancelButtonClicked = {},
              onSendButtonClicked = { subject: String, summary: String ->

              },
              modifier = Modifier.fillMaxHeight()
          )
      }

   You should now be able to navigate through each screen of your app. Notice that by
   calling ``navigate()``, not only does the screen change, but it's actually placed on top
   of the back stack. Also, when you press the system back button, you can navigate back to
   the previous screen.

   The app stacks each screen on top of the previous one, and the back button (
   |bade5f3ecb71e4a2.png|) can remove them. The history of screens from the
   ``startDestination`` at the bottom to the topmost screen that was just shown is known as
   the *back stack*.


Pop to the start screen

   Unlike the system back button, the **Cancel** button doesn't go back to the previous
   screen. Instead, it should popâ€”removeâ€”all screens from the back stack and return to the
   starting screen.

   You can do this by calling the ``popBackStack()`` method.

   |2f382e5eb319b4b8.png|

   The ``popBackStack()`` method has two required parameters.

   -  **``route``:** The string representing the route of the destination you want to
      navigate back to.
   -  **``inclusive``:** A Boolean value that, if true, also pops (removes) the specified
      route. If false, ``popBackStack()`` will remove all destinations on top ofâ€”but not
      includingâ€”the start destination, leaving it as the topmost screen visible to the
      user.

   When users press the **Cancel** button on any of the screens, the app resets the state
   in the view model and calls ``popBackStack()``. You'll first implement a method to do
   this and then pass it in for the appropriate parameter on all three screens with
   **Cancel** buttons.

   1. After the ``CupcakeApp()`` function, define a private function called
      ``cancelOrderAndNavigateToStart()``.

   .. code:: prettyprint

      private fun cancelOrderAndNavigateToStart() {
      }

   2. Add two parameters: ``viewModel`` of type ``OrderViewModel``, and ``navController``
      of type ``NavHostController``.

   .. code:: prettyprint

      private fun cancelOrderAndNavigateToStart(
          viewModel: OrderViewModel,
          navController: NavHostController
      ) {
      }

   3. In the function body, call ``resetOrder()`` on the ``viewModel``.

   .. code:: prettyprint

      private fun cancelOrderAndNavigateToStart(
          viewModel: OrderViewModel,
          navController: NavHostController
      ) {
          viewModel.resetOrder()
      }

   4. Call ``popBackStack()`` on the ``navController``, passing in
      ``CupcakeScreen.Start.name`` for the ``route``, and ``false`` for ``inclusive``.

   .. code:: prettyprint

      private fun cancelOrderAndNavigateToStart(
          viewModel: OrderViewModel,
          navController: NavHostController
      ) {
          viewModel.resetOrder()
          navController.popBackStack(CupcakeScreen.Start.name, inclusive = false)
      }

   5. In the ``CupcakeApp()`` composable, pass ``cancelOrderAndNavigateToStart`` in for the
      ``onCancelButtonClicked`` parameters of the two ``SelectOptionScreen`` composables
      and the ``OrderSummaryScreen`` composable.

   .. code:: prettyprint

      composable(route = CupcakeScreen.Start.name) {
          StartOrderScreen(
              quantityOptions = DataSource.quantityOptions,
              onNextButtonClicked = {
                  viewModel.setQuantity(it)
                  navController.navigate(CupcakeScreen.Flavor.name)
              },
              modifier = Modifier
                  .fillMaxSize()
                  .padding(dimensionResource(R.dimen.padding_medium))
          )
      }
      composable(route = CupcakeScreen.Flavor.name) {
          val context = LocalContext.current
          SelectOptionScreen(
              subtotal = uiState.price,
              onNextButtonClicked = { navController.navigate(CupcakeScreen.Pickup.name) },
              onCancelButtonClicked = {
                  cancelOrderAndNavigateToStart(viewModel, navController)
              },
              options = DataSource.flavors.map { id -> context.resources.getString(id) },
              onSelectionChanged = { viewModel.setFlavor(it) },
              modifier = Modifier.fillMaxHeight()
          )
      }
      composable(route = CupcakeScreen.Pickup.name) {
          SelectOptionScreen(
              subtotal = uiState.price,
              onNextButtonClicked = { navController.navigate(CupcakeScreen.Summary.name) },
              onCancelButtonClicked = {
                  cancelOrderAndNavigateToStart(viewModel, navController)
              },
              options = uiState.pickupOptions,
              onSelectionChanged = { viewModel.setDate(it) },
              modifier = Modifier.fillMaxHeight()
          )
      }
      composable(route = CupcakeScreen.Summary.name) {
          OrderSummaryScreen(
              orderUiState = uiState,
              onCancelButtonClicked = {
                  cancelOrderAndNavigateToStart(viewModel, navController)
              },
              onSendButtonClicked = { subject: String, summary: String ->

              },
              modifier = Modifier.fillMaxHeight()
         )
      }

   6. Run your app and test that pressing the **Cancel** button on any of the screens
      navigates the user back to the first screen.


6. Navigate to another app
--------------------------------------------------------------------------------

   So far, you've learned how to navigate to a different screen in your app and how to
   navigate back to the home screen. There's just one other step to implement navigation in
   the Cupcake app. On the order summary screen, the user can send their order to another
   app. This selection brings up a
   `ShareSheet <https://developer.android.google.cn/training/sharing/send>`__â€”a user
   interface component that covers the bottom part of the screenâ€”that shows sharing
   options.

   This piece of UI isn't part of the Cupcake app. In fact, it's provided by the Android
   operating system. System UI, such as the sharing screen, isn't called by your
   ``navController``. Instead, you use something called an *Intent*.

   An intent is a request for the system to perform some action, commonly presenting a new
   activity. There are many different intents, and you're encouraged to refer to the
   documentation for a comprehensive list. However, we are interested in the one called
   ``ACTION_SEND``. You can supply this intent with some data, such as a string, and
   present appropriate sharing actions for that data.

   The basic process for setting up an intent is as follows:

   1. Create an intent object and specify the intent, such as ``ACTION_SEND``.
   2. Specify the type of additional data being sent with the intent. For a simple piece of
      text, you can use ``"text/plain"``, though other types, such as ``"image/*"`` or
      ``"video/*"``, are available.
   3. Pass any additional data to the intent, such as the text or image to share, by
      calling the ``putExtra()`` method. This intent will take two extras:
      ``EXTRA_SUBJECT`` and ``EXTRA_TEXT``.
   4. Call the ``startActivity()`` method of context, passing in an activity created from
      the intent.

   We'll walk you through how to create the share action intent, but the process is the
   same for other types of intents. For future projects, you're encouraged to refer to the
   documentation as needed for the specific type of data and necessary extras.

   Complete the following steps to create an intent to send the cupcake order to another
   app:

   1. In **CupcakeScreen.kt**, below the ``CupcakeApp`` composable, create a private
      function named ``shareOrder()``.

   .. code:: prettyprint

      private fun shareOrder()

   2. Add a parameter named ``context`` of type ``Context``.

   .. code:: prettyprint

      import android.content.Context

      private fun shareOrder(context: Context) {
      }

   3. Add two ``String`` parameters: ``subject`` and ``summary``. These strings will be
      shown on the sharing action sheet.

   .. code:: prettyprint

      private fun shareOrder(context: Context, subject: String, summary: String) {
      }

   4. Within the function's body, create an Intent named ``intent``, and pass
      ``Intent.ACTION_SEND`` as an argument.

   .. code:: prettyprint

      import android.content.Intent

      val intent = Intent(Intent.ACTION_SEND)

   Since you only need to configure this ``Intent`` object once, you can make the next few
   lines of code more concise using the ``apply()`` function, which you learned about in an
   earlier codelab.

   5. Call ``apply()`` on the newly created Intent and pass in a lambda expression.

   .. code:: prettyprint

      val intent = Intent(Intent.ACTION_SEND).apply {
          
      }

   6. In the lambda body, set the type to ``"text/plain"``. Because you're doing this in a
      function passed into ``apply()``, you don't need to refer to the object's identifier,
      ``intent``.

   .. code:: prettyprint

      val intent = Intent(Intent.ACTION_SEND).apply {
          type = "text/plain"
      }

   7. Call ``putExtra()``, passing in subject for ``EXTRA_SUBJECT``.

   .. code:: prettyprint

      val intent = Intent(Intent.ACTION_SEND).apply {
          type = "text/plain"
          putExtra(Intent.EXTRA_SUBJECT, subject)
      }

   8. Call ``putExtra()``, passing in summary for ``EXTRA_TEXT``.

   .. code:: prettyprint

      val intent = Intent(Intent.ACTION_SEND).apply {
          type = "text/plain"
          putExtra(Intent.EXTRA_SUBJECT, subject)
          putExtra(Intent.EXTRA_TEXT, summary)
      }

   9. Call ``startActivity()`` method of context.

   .. code:: prettyprint

      context.startActivity(
          
      )

   10. Within the lambda passed into ``startActivity()``, create an activity from the
       Intent by calling the class method ``createChooser()``. Pass intent for the first
       argument and the ``new_cupcake_order`` string resource.

   .. code:: prettyprint

      context.startActivity(
          Intent.createChooser(
              intent,
              context.getString(R.string.new_cupcake_order)
          )
      )

   11. In the ``CupcakeApp`` composable, in the call to ``composable()`` for the
       ``CucpakeScreen.Summary.name``, get a reference to the context object so that you
       can pass it to the ``shareOrder()`` function.

   .. code:: prettyprint

      composable(route = CupcakeScreen.Summary.name) {
          val context = LocalContext.current

          ...
      }

   12. In the lambda body of ``onSendButtonClicked()``, call ``shareOrder()``, passing in
       the ``context``, ``subject``, and ``summary`` as arguments.

   .. code:: prettyprint

      onSendButtonClicked = { subject: String, summary: String ->
          shareOrder(context, subject = subject, summary = summary)
      }

   13. Run your app and navigate through the screens.

   When you click **Send Order to Another App**, you should see sharing actions such as
   **Messaging** and **Bluetooth** on the bottom sheet, along with the subject and summary
   you provided as extras.

   |13bde33712e135a4.png|


7. Make the app bar respond to navigation
--------------------------------------------------------------------------------

   Even though your app functions and can navigate to and from every screen, there's still
   something missing from the screenshots at the start of this codelab. The app bar does
   not automatically respond to navigation. The title doesn't update when the app navigates
   to a new route nor does it display the *Up button* before the title when appropriate.

   **Note:** The system back button is provided by the Android operating system and is
   located at the bottom of the screen.

   |Icon of the system Back button.|
   The Up button, on the other hand, is located in your app's ``AppBar``.

   |Icon of the Up button shown in the AppBar.|
   Within the context of your app, both the back button and the Up button do the same
   thingâ€”navigate back to the previous screen.

.. |Icon of the system Back button.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/7a4c3a5081adce31.png
.. |Icon of the Up button shown in the AppBar.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/cdd42ef932a23664.png

   The starter code includes a composable to manage the ``AppBar`` named ``CupcakeAppBar``.
   Now that you have implemented navigation in the app, you can use the information from
   the back stack to display the correct title and show the Up button if appropriate. The
   ``CupcakeAppBar`` composable should be aware of the current screen so that the title
   updates appropriately.

   1. In the ``CupcakeScreen`` enum in **CupcakeScreen.kt** add a parameter of type ``Int``
      named ``title`` using the ``@StringRes`` annotation.

   .. code:: prettyprint

      import androidx.annotation.StringRes

      enum class CupcakeScreen(@StringRes val title: Int) {
          Start,
          Flavor,
          Pickup,
          Summary
      }

   2. Add a resource value for each enum case, corresponding to the title text for each
      screen. Use ``app_name`` for the ``Start`` screen, ``choose_flavor`` for the
      ``Flavor`` screen, ``choose_pickup_date`` for the ``Pickup`` screen, and
      ``order_summary`` for the ``Summary`` screen.

   .. code:: prettyprint

      enum class CupcakeScreen(@StringRes val title: Int) {
          Start(title = R.string.app_name),
          Flavor(title = R.string.choose_flavor),
          Pickup(title = R.string.choose_pickup_date),
          Summary(title = R.string.order_summary)
      }

   3. Add a parameter named ``currentScreen`` of type ``CupcakeScreen`` to the
      ``CupcakeAppBar`` composable.

   .. code:: prettyprint

      fun CupcakeAppBar(
          currentScreen: CupcakeScreen,
          canNavigateBack: Boolean,
          navigateUp: () -> Unit = {},
          modifier: Modifier = Modifier
      )

   4. Inside ``CupcakeAppBar``, replace the hard coded app name with the current screen's
      title by passing in ``currentScreen.title`` to the call to ``stringResource()`` for
      the title parameter of ``TopAppBar``.

   .. code:: prettyprint

      TopAppBar(
          title = { Text(stringResource(currentScreen.title)) },
          modifier = modifier,
          navigationIcon = {
              if (canNavigateBack) {
                  IconButton(onClick = navigateUp) {
                      Icon(
                          imageVector = Icons.Filled.ArrowBack,
                          contentDescription = stringResource(R.string.back_button)
                      )
                  }
              }
          }
      )

   The Up button should only show if there's a composable on the back stack. If the app has
   no screens on the back stackâ€”``StartOrderScreen`` is shownâ€”then the Up button should not
   show. To check this, you need a reference to the back stack.

   1. In the ``CupcakeApp`` composable, below the ``navController`` variable, create a
      variable named ``backStackEntry`` and call the
      ``currentBackStackEntryAsState()`` method of ``navController`` using the ``by``
      delegate.

   .. code:: prettyprint

      import androidx.navigation.compose.currentBackStackEntryAsState

      @Composable
      fun CupcakeApp(
          viewModel: OrderViewModel = viewModel(),
          navController: NavHostController = rememberNavController()
      ){

          val backStackEntry by navController.currentBackStackEntryAsState()

          ...
      }

   2. Convert the current screen's title to a value of ``CupcakeScreen``. Below the
      ``backStackEntry`` variable, create a variable using ``val`` named ``currentScreen``
      equal to the result of calling the ``valueOf()`` class function of ``CupcakeScreen``,
      and pass in the route of the destination of ``backStackEntry``. Use the elvis
      operator to provide a default value of ``CupcakeScreen.Start.name``.

   .. code:: prettyprint

      val currentScreen = CupcakeScreen.valueOf(
          backStackEntry?.destination?.route ?: CupcakeScreen.Start.name
      )

   3. Pass the value of ``currentScreen`` variable into the parameter of the same name of
      the ``CupcakeAppBar`` composable.

   .. code:: prettyprint

      CupcakeAppBar(
          currentScreen = currentScreen,
          canNavigateBack = false,
          navigateUp = {}
      )

   As long as there's a screen behind the current screen on the back stack, the Up button
   should show. You can use a boolean expression to identify if the Up button should
   appear:

   1. For the ``canNavigateBack`` parameter, pass in a boolean expression checking if the
      ``previousBackStackEntry`` property of ``navController`` is not equal to null.

   .. code:: prettyprint

      canNavigateBack = navController.previousBackStackEntry != null,

   2. To actually navigate back to the previous screen, call the ``navigateUp()`` method of
      ``navController``.

   .. code:: prettyprint

      navigateUp = { navController.navigateUp() }

   3. Run your app.

   Notice that the ``AppBar`` title now updates to reflect the current screen. When you
   navigate to a screen other than ``StartOrderScreen``, the Up button should appear and
   take you back to the previous screen.

   |3fd023516061f522.gif|


8. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-cupcake.git
      $ cd basic-android-kotlin-compose-training-cupcake
      $ git checkout navigation

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-cupcake/archive/refs/heads/navigation.zip>`__

   **Note:** The solution code is in the ``navigation`` branch of the downloaded
   repository.

   If you want to see the solution code for this codelab, view it on
   `GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-cupcake/tree/navigation>`__.


9. Summary
--------------------------------------------------------------------------------

   Congratulations! You've just made the leap from simple single screen applications to a
   complex multi-screen app using the Jetpack Navigation component to move through multiple
   screens. You defined routes, handled them in a NavHost, and used function type
   parameters to separate the navigation logic from individual screens. You also learned
   how to send data to another app using intents as well as customize the app bar in
   response to navigation. In the upcoming units, you'll continue using these skills as you
   work on several other multi-screen apps of growing complexity.


Learn More

   -  `Navigating with Compose <https://developer.android.google.cn/jetpack/compose/navigation>`__
   -  `Navigation principles <https://developer.android.google.cn/guide/navigation/navigation-principles>`__
   -  `Jetpack Compose Navigation <https://developer.android.google.cn/codelabs/jetpack-compose-navigation#0>`__
   -  `Types of Navigation <https://material.io/design/navigation/understanding-navigation.html>`__

.. |fa955a02eea01b57.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/fa955a02eea01b57.png
.. |4cbe48d4d7de26ff.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/4cbe48d4d7de26ff.png
.. |bd6d050e9b0be97e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/bd6d050e9b0be97e.png
.. |6979f0bec2de8dbd.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/6979f0bec2de8dbd.png
.. |ffb8d156220c7e57.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/ffb8d156220c7e57.png
.. |ac6e828a9105af26.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/ac6e828a9105af26.png
.. |b55c8b57ac60fe51.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/b55c8b57ac60fe51.png
.. |aa6d382dd8c0af7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/aa6d382dd8c0af7.png
.. |3bfc1693d3afc984.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/3bfc1693d3afc984.png
.. |7fc4d9ee733fcccb.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/7fc4d9ee733fcccb.png
.. |13bde33712e135a4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/13bde33712e135a4.png
.. |fae7688d6dd53de9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/fae7688d6dd53de9.png
.. |f67974b7fb3f0377.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/f67974b7fb3f0377.png
.. |8326701a77706258.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/8326701a77706258.png
.. |fc8aae3911a6a25d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/fc8aae3911a6a25d.png
.. |bade5f3ecb71e4a2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/bade5f3ecb71e4a2.png
.. |2f382e5eb319b4b8.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/2f382e5eb319b4b8.png
.. |3fd023516061f522.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-navigation/img/3fd023516061f522.gif


ğŸš€ Test the Cupcake App
=======================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-cupcake

1. Introduction
--------------------------------------------------------------------------------

   In the `Navigate between screens with Compose <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-navigation>`__
   codelab, you learned how to add navigation to a Compose app using the Jetpack Navigation
   Compose component.

   The Cupcake app has multiple screens to navigate through and a variety of actions that
   can be taken by the user. This app provides a great opportunity for you to hone your
   automated testing skill! In this codelab, you will write a number of UI tests for the
   Cupcake app and learn how to approach maximizing test coverage.


Prerequisites

   -  Familiarity with the Kotlin language, including function types, lambdas, and scope functions
   -  Completion of the `Navigate between screens with Compose codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-navigation>`__


What you'll learn

   -  Test the Jetpack Navigation component with Compose.
   -  Create a consistent UI state for each UI test.
   -  Create helper functions for tests.


What you'll build

   -  UI tests for the Cupcake app


What you'll need

   -  The latest version of Android Studio
   -  An internet connection to download the starter code

2. Download the starter code
--------------------------------------------------------------------------------

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-cupcake

   **Branch name with starter code:** ``navigation``

   1. In Android Studio, open the **``basic-android-kotlin-compose-training-cupcake``**
      folder.
   2. Open the Cupcake app code in Android Studio.

3. Set up Cupcake for UI tests
--------------------------------------------------------------------------------


Add the ``androidTest`` dependencies

   The Gradle build tool enables you to add dependencies for specific modules. This
   functionality prevents dependencies from being compiled unnecessarily. You are already
   familiar with the ``implementation`` configuration when including dependencies in a
   project. You've used this keyword to import dependencies in the app module's
   ``build.gradle.kts`` file. Using the ``implementation`` keyword makes that dependency
   available to all source sets in that module; at this point in the course, you gained
   experience with the ``main``, ``test``, and ``androidTest`` source sets.

   UI tests are contained in their own source sets called ``androidTest``. Dependencies
   that are only needed for this module don't need to be compiled for other modules, such
   as the ``main`` module, where the app code is contained. When adding a dependency that
   is only used by UI tests, use the ``androidTestImplementation`` keyword to declare the
   dependency in the app module's ``build.gradle.kts`` file. Doing so ensures that the UI
   test dependencies are compiled only when you run UI tests.

   Complete the following steps to add the dependencies necessary to write UI tests:

   1. Open the ``build.gradle.kts(Module :app)`` file.
   2. Add the following dependencies to the ``dependencies`` section of the file:

   .. code:: prettyprint

      androidTestImplementation(platform("androidx.compose:compose-bom:2023.05.01"))
      androidTestImplementation("androidx.compose.ui:ui-test-junit4")
      androidTestImplementation("androidx.navigation:navigation-testing:2.6.0")
      androidTestImplementation("androidx.test.espresso:espresso-intents:3.5.1")
      androidTestImplementation("androidx.test.ext:junit:1.1.5")


Create the UI test directory

   1. Right-click the ``src`` directory in the project view and select **New** >
      **Directory**.

   |290b1ab99ce8f4e5.png|

   2. Select the **androidTest/java** option.

   **Note:** You may have to scroll down to find this option.

   |718bde5eb21b4f6f.png|


Create the test package

   1. Right-click the ``androidTest/java`` directory in the project window, and select
      **New** > **Package**.

   |7ad315f41e2b0881.png|

   2. Name the package **com.example.cupcake.test**. |b8306f9d11988a2.png|


Create the navigation test class

   In the ``test`` directory, create a new Kotlin class called
   ``CupcakeScreenNavigationTest``.

   |5515db35968f7d86.png|

   |4b527e7404fad927.png|

4. Set up the nav host
--------------------------------------------------------------------------------

   In a previous codelab, you learned that UI tests in Compose require a Compose test rule.
   The same is true of testing Jetpack Navigation. However, testing navigation requires
   some additional setup through the Compose test rule.

   When testing Compose Navigation, you won't have access to the same ``NavHostController``
   that you do in the app code. However, you can use a ``TestNavHostController`` and
   configure the test rule with this nav controller. In this section, you learn how to
   configure and reuse the test rule for navigation tests.

   1. In ``CupcakeScreenNavigationTest.kt``, create a test rule using
      ``createAndroidComposeRule`` and passing ``ComponentActivity`` as the type parameter.

   .. code:: prettyprint

      import androidx.activity.ComponentActivity
      import androidx.compose.ui.test.junit4.createAndroidComposeRule
      import org.junit.Rule

      @get:Rule
      val composeTestRule = createAndroidComposeRule<ComponentActivity>()

   To make sure that your app navigates to the correct place, you need to reference a
   ``TestNavHostController`` instance to check the navigation route of the nav host when
   the app takes actions to navigate.

   2. Instantiate a ``TestNavHostController`` instance as a ``lateinit`` variable. In
      Kotlin, the ``lateinit`` keyword is used to declare a property that can be
      initialized after the object has been declared.

   .. code:: prettyprint

      import androidx.navigation.testing.TestNavHostController

      private lateinit var navController: TestNavHostController

   Next, specify the composable you want to use for the UI tests.

   3. Create a method called ``setupCupcakeNavHost()``.
   4. In the ``setupCupcakeNavHost()`` method, call the ``setContent()`` method on the
      Compose test rule you created.
   5. Inside of the lambda passed to the ``setContent()`` method, call the ``CupcakeApp()``
      composable.

   .. code:: prettyprint

      import com.example.cupcake.CupcakeApp

      fun setupCupcakeNavHost() {
          composeTestRule.setContent {
              CupcakeApp()
          }
      }

   You now need to create the ``TestNavHostContoller`` object in the test class. You use
   this object later to determine the navigation state, as the app uses the controller to
   navigate the various screens in the Cupcake app.

   6. Set up the nav host by using the lambda you created previously. Initialize the
      ``navController`` variable you created, register a navigator, and pass that
      ``TestNavHostController`` to the ``CupcakeApp`` composable.

   .. code:: prettyprint

      import androidx.compose.ui.platform.LocalContext

      fun setupCupcakeNavHost() {
          composeTestRule.setContent {
              navController = TestNavHostController(LocalContext.current).apply {
                  navigatorProvider.addNavigator(ComposeNavigator())
              }
              CupcakeApp(navController = navController)
          }
      }

   Every test in the ``CupcakeScreenNavigationTest`` class involves testing an aspect of
   navigation. Therefore, each test depends on the ``TestNavHostController`` object you
   created. Instead of having to manually call the ``setupCupcakeNavHost()`` function for
   every test to set up the nav controller, you can make that happen automatically using
   the ``@Before`` annotation provided by the **junit** library. When a method is annotated
   with ``@Before``, it runs before every method annotated with ``@Test``.

   7. Add the ``@Before`` annotation to the ``setupCupcakeNavHost()`` method.

   .. code:: prettyprint

      import org.junit.Before

      @Before
      fun setupCupcakeNavHost() {
          composeTestRule.setContent {
              navController = TestNavHostController(LocalContext.current).apply {
                  navigatorProvider.addNavigator(ComposeNavigator())
              }
              CupcakeApp(navController = navController)
          }
      }

5. Write navigation tests
--------------------------------------------------------------------------------


Verify the start destination

   Recall that, when you built the Cupcake app, you created an ``enum`` class called
   ``CupcakeScreen`` that contained constants to dictate navigation of the app.

   **CupcakeScreen.kt**

   .. code:: prettyprint

      /**
      * enum values that represent the screens in the app
      */
      enum class CupcakeScreen(@StringRes val title: Int) {
         Start(title = R.string.app_name),
         Flavor(title = R.string.choose_flavor),
         Pickup(title = R.string.choose_pickup_date),
         Summary(title = R.string.order_summary)
      }

   All apps that have a UI have a home screen of some kind. For Cupcake, that screen is the
   **Start Order Screen**. The navigation controller in the ``CupcakeApp`` composable uses
   the ``Start`` item of the ``CupcakeScreen`` enum to determine when to navigate to this
   screen. When the app starts, if a destination route doesn't already exist, the nav host
   destination route is set to ``CupcakeScreen.Start.name``.

   You first need to write a test to verify that the **Start Order Screen** is the current
   destination route when the app starts.

   1. Create a function called ``cupcakeNavHost_verifyStartDestination()`` and annotate it
      with ``@Test``.

   .. code:: prettyprint

      import org.junit.Test

      @Test
      fun cupcakeNavHost_verifyStartDestination() {
      }

   You now must confirm that the nav controller's initial destination route is the **Start
   Order Screen**.

   2. Assert that the expected route name (in this case, ``CupcakeScreen.Start.name``) is
      equal to the destination route of the nav controller's current back stack entry.

   .. code:: prettyprint

      import org.junit.Assert.assertEquals
      ...

      @Test
      fun cupcakeNavHost_verifyStartDestination() {
          assertEquals(CupcakeScreen.Start.name, navController.currentBackStackEntry?.destination?.route)
      }

   **Note:** The ``AndroidComposeTestRule`` you created automatically launches the app,
   displaying the ``CupcakeApp`` composable before the execution of any ``@Test`` method.
   Therefore, you do not need to take any extra steps in the test methods to launch the
   app.


Create helper methods

   UI tests often require the repeating of steps to put the UI in a state in which a
   particular piece of the UI can be tested. A custom UI can also require complex
   assertions that require multiple lines of code. The assertion you wrote in the previous
   section requires a lot of code, and you are using this same assertion many times as you
   test navigation in the Cupcake app. In these situations, writing helper methods in your
   tests saves you from writing duplicate code.

   For each navigation test you write, you use the ``name`` property of the
   ``CupcakeScreen`` enum items to check that the current destination route of the
   navigation controller is correct. You write a helper function that you can call whenever
   you want to make such an assertion.

   Complete the following steps to create this helper function:

   1. Create an empty Kotlin file in the ``test`` directory called ``ScreenAssertions``.

   **Note:** Make sure to create a **File** and not a **Class**. This file will be used to
   create an extension function which will require an empty Kotlin file.

   |63af08bd78a827c4.png|

   2. Add an extension function to the ``NavController`` class called
      ``assertCurrentRouteName()`` and pass a string for the expected route name in the
      method signature.

   .. code:: prettyprint

      fun NavController.assertCurrentRouteName(expectedRouteName: String) {

      }

   3. In this function, assert that the ``expectedRouteName`` is equal to the destination
      route of the nav controller's current back stack entry.

   .. code:: prettyprint

      import org.junit.Assert.assertEquals
      ...

      fun NavController.assertCurrentRouteName(expectedRouteName: String) {
          assertEquals(expectedRouteName, currentBackStackEntry?.destination?.route)
      }

   4. Open the CupcakeScreenNavigationTest file and modify the
      ``cupcakeNavHost_verifyStartDestination()`` function to use your new extension
      function instead of the lengthy assertion.

   .. code:: prettyprint

      @Test
      fun cupcakeNavHost_verifyStartDestination() {
          navController.assertCurrentRouteName(CupcakeScreen.Start.name)
      }

   A number of tests also require interacting with UI components. In this codelab, those
   components are often found using a resource string. You can access a composable by its
   resource string with the ``Context.getString()`` method, which you can read about
   `here <https://developer.android.google.cn/reference/android/content/Context#getString(int)>`__.
   When writing a UI test in compose, implementing this method looks like this:

   .. code:: prettyprint

      composeTestRule.onNodeWithText(composeTestRule.activity.getString(R.string.my_string)

   This is a verbose instruction and it can be simplified with the addition of an extension
   function.

   1. Create a new file in the ``com.example.cupcake.test`` package called
      **ComposeRuleExtensions.kt**. Make sure this is a plain Kotlin file.

   |5710fc2d8219048b.png|

   2. Add the following code to that file.

   .. code:: prettyprint

      import androidx.activity.ComponentActivity
      import androidx.annotation.StringRes
      import androidx.compose.ui.test.SemanticsNodeInteraction
      import androidx.compose.ui.test.junit4.AndroidComposeTestRule
      import androidx.compose.ui.test.onNodeWithText
      import androidx.test.ext.junit.rules.ActivityScenarioRule

      fun <A : ComponentActivity> AndroidComposeTestRule<ActivityScenarioRule<A>, A>.onNodeWithStringId(
          @StringRes id: Int
      ): SemanticsNodeInteraction = onNodeWithText(activity.getString(id))

   This extension function allows you to reduce the amount of code you write when finding a
   UI component by its string resource. Instead of writing this:

   .. code:: prettyprint

      composeTestRule.onNodeWithText(composeTestRule.activity.getString(R.string.my_string)

   You can now use the following instruction:

   .. code:: prettyprint

      composeTestRule.onNodeWithStringId(R.string.my_string)


Verify that the Start screen doesn't have an Up button

   The original design of the Cupcake app doesn't have an Up button in the toolbar of the
   Start screen.

   |ffb8d156220c7e57.png|

   The Start screen lacks a button because there is nowhere to navigate Up from this
   screen, since it is the initial screen. Follow these steps to create a function that
   confirms the Start screen doesn't have an Up button:

   1. Create a method called
      ``cupcakeNavHost_verifyBackNavigationNotShownOnStartOrderScreen()`` and annotate it
      with ``@Test``.

   .. code:: prettyprint

      @Test
      fun cupcakeNavHost_verifyBackNavigationNotShownOnStartOrderScreen() {
      }

   In Cupcake, the Up button has a content description set to the string from the
   ``R.string.back_button`` resource.

   2. Create a variable in the test function with the value of the ``R.string.back_button``
      resource.

   .. code:: prettyprint

      @Test
      fun cupcakeNavHost_verifyBackNavigationNotShownOnStartOrderScreen() {
          val backText = composeTestRule.activity.getString(R.string.back_button)
      }

   3. Assert that a node with this content description does not exist on the screen.

   .. code:: prettyprint

      @Test
      fun cupcakeNavHost_verifyBackNavigationNotShownOnStartOrderScreen() {
          val backText = composeTestRule.activity.getString(R.string.back_button)
          composeTestRule.onNodeWithContentDescription(backText).assertDoesNotExist()
      }


Verify navigation to the Flavor screen

   Clicking on one of the buttons in the Start screen triggers a method that instructs the
   nav controller to navigate to the Flavor screen.

   |3bda045bfe202c90.png|

   In this test, you write a command to click a button to trigger this navigation and
   verify that the destination route is the Flavor screen.

   1. Create a function called
      ``cupcakeNavHost_clickOneCupcake_navigatesToSelectFlavorScreen()``\ and annotate it
      with ``@Test``.

   .. code:: prettyprint

      @Test
      fun cupcakeNavHost_clickOneCupcake_navigatesToSelectFlavorScreen(){
      }

   **Note:** Test method names are different from the function names you use in app code. A
   good naming convention for test methods is the following:
   ``thingUnderTest_TriggerOfTest_ResultOfTest``. Using the function you just created as an
   example, it is clear that you are testing the cupcake nav host by clicking the **One
   Cupcake** button, and the expected result is navigation to the Flavor screen.

   2. Find the **One Cupcake** button by its string resource id and perform a click action
      on it.

   .. code:: prettyprint

      import com.example.cupcake.R
      ...

      @Test
      fun cupcakeNavHost_clickOneCupcake_navigatesToSelectFlavorScreen() {
          composeTestRule.onNodeWithStringId(R.string.one_cupcake)
              .performClick()
      }

   3. Assert that the current route name is the Flavor screen name.

   .. code:: prettyprint

      @Test
      fun cupcakeNavHost_clickOneCupcake_navigatesToSelectFlavorScreen() {
          composeTestRule.onNodeWithStringId(R.string.one_cupcake)
              .performClick()
          navController.assertCurrentRouteName(CupcakeScreen.Flavor.name)
      }


Write more helper methods

   The Cupcake app has a mostly linear navigation flow. Short of clicking the **Cancel**
   button, you can only navigate through the app in one direction. Therefore, as you test
   screens that are deeper within the app, you can find yourself repeating code to navigate
   to the areas you want to test. This situation merits the use of more helper methods so
   that you only have to write that code once.

   Now that you tested navigation to the Flavor screen, create a method that navigates to
   the Flavor screen so that you don't have to repeat that code for future tests.

   **Note:** Keep in mind that these are not test methods. They don't test anything and
   they should only be executed when explicitly called. Therefore, they should not be
   annotated with ``@Test``.

   1. Create a method called ``navigateToFlavorScreen()``.

   .. code:: prettyprint

      private fun navigateToFlavorScreen() {
      }

   2. Write a command to find the **One Cupcake** button and perform a click action on it,
      as you did in the previous section.

   .. code:: prettyprint

      private fun navigateToFlavorScreen() {
          composeTestRule.onNodeWithStringId(R.string.one_cupcake)
              .performClick()
      }

   Recall that the **Next** button on the Flavor screen will not be clickable until a
   flavor is selected. This method is only meant to prepare the UI for navigation. After
   you call this method, the UI should be in a state in which the **Next** button is
   clickable.

   3. Find a node in the UI with the ``R.string.chocolate`` string and perform a click
      action on it to select it.

   .. code:: prettyprint

      private fun navigateToFlavorScreen() {
          composeTestRule.onNodeWithStringId(R.string.one_cupcake)
              .performClick()
          composeTestRule.onNodeWithStringId(R.string.chocolate)
              .performClick()
      }

   See if you can write helper methods that navigate to the Pickup screen and the Summary
   screen. Give this exercise a try on your own before looking at the solution.

   **Note:** Navigating to the Summary screen first requires the selection of a date from
   the Pickup screen. You have to generate a date to select in the UI.

   Use the following code to accomplish this:

   .. code:: prettyprint

      private fun getFormattedDate(): String {
          val calendar = Calendar.getInstance()
          calendar.add(java.util.Calendar.DATE, 1)
          val formatter = SimpleDateFormat("E MMM d", Locale.getDefault())
          return formatter.format(calendar.time)
      }

   .. code:: prettyprint

      private fun navigateToPickupScreen() {
          navigateToFlavorScreen()
          composeTestRule.onNodeWithStringId(R.string.next)
              .performClick()
      }

      private fun navigateToSummaryScreen() {
          navigateToPickupScreen()
          composeTestRule.onNodeWithText(getFormattedDate())
              .performClick()
          composeTestRule.onNodeWithStringId(R.string.next)
              .performClick()
      }

   As you test screens beyond the Start screen, you need to plan to test the Up button
   functionality to make sure it directs navigation to the previous screen. Consider making
   a helper function to find and click the Up button.

   .. code:: prettyprint

      private fun performNavigateUp() {
          val backText = composeTestRule.activity.getString(R.string.back_button)
          composeTestRule.onNodeWithContentDescription(backText).performClick()
      }


Maximize test coverage

   An app's test suite should test as much of the app functionality as possible. In a
   perfect world, a UI test suite would cover 100% of the UI functionality. In practice,
   this amount of test coverage is difficult to achieve because there are many factors
   external to your app that can affect the UI, such as devices with unique screen sizes,
   different versions of the Android operating system, and third party apps that can affect
   other apps on the phone.

   One way to help maximize test coverage is to write tests alongside features as you add
   them. In doing so, you avoid getting too far ahead on new features and having to go back
   to remember all possible scenarios. Cupcake is a fairly small app at this point, and you
   already tested a significant portion of the app's navigation! However, there are more
   navigation states to test.

   See if you can write the tests to verify the following navigation states. Try
   implementing them on your own before looking at the solution.

   -  Navigating to the Start screen by clicking the Up button from the Flavor screen
   -  Navigating to the Start screen by clicking the Cancel button from the Flavor screen
   -  Navigating to the Pickup screen
   -  Navigating to the Flavor screen by clicking the Up button from the Pickup screen
   -  Navigating to the Start screen by clicking the Cancel button from the Pickup screen
   -  Navigating to the Summary screen
   -  Navigating to the Start screen by clicking the Cancel button from the Summary screen

   .. code:: prettyprint

      @Test
      fun cupcakeNavHost_clickNextOnFlavorScreen_navigatesToPickupScreen() {
          navigateToFlavorScreen()
          composeTestRule.onNodeWithStringId(R.string.next)
              .performClick()
          navController.assertCurrentRouteName(CupcakeScreen.Pickup.name)
      }

      @Test
      fun cupcakeNavHost_clickBackOnFlavorScreen_navigatesToStartOrderScreen() {
          navigateToFlavorScreen()
          performNavigateUp()
          navController.assertCurrentRouteName(CupcakeScreen.Start.name)
      }

      @Test
      fun cupcakeNavHost_clickCancelOnFlavorScreen_navigatesToStartOrderScreen() {
          navigateToFlavorScreen()
          composeTestRule.onNodeWithStringId(R.string.cancel)
              .performClick()
          navController.assertCurrentRouteName(CupcakeScreen.Start.name)
      }

      @Test
      fun cupcakeNavHost_clickNextOnPickupScreen_navigatesToSummaryScreen() {
          navigateToPickupScreen()
          composeTestRule.onNodeWithText(getFormattedDate())
              .performClick()
          composeTestRule.onNodeWithStringId(R.string.next)
              .performClick()
          navController.assertCurrentRouteName(CupcakeScreen.Summary.name)
      }

      @Test
      fun cupcakeNavHost_clickBackOnPickupScreen_navigatesToFlavorScreen() {
          navigateToPickupScreen()
          performNavigateUp()
          navController.assertCurrentRouteName(CupcakeScreen.Flavor.name)
      }

      @Test
      fun cupcakeNavHost_clickCancelOnPickupScreen_navigatesToStartOrderScreen() {
          navigateToPickupScreen()
          composeTestRule.onNodeWithStringId(R.string.cancel)
              .performClick()
          navController.assertCurrentRouteName(CupcakeScreen.Start.name)
      }

      @Test
      fun cupcakeNavHost_clickCancelOnSummaryScreen_navigatesToStartOrderScreen() {
          navigateToSummaryScreen()
          composeTestRule.onNodeWithStringId(R.string.cancel)
              .performClick()
          navController.assertCurrentRouteName(CupcakeScreen.Start.name)
      }

6. Write tests for the Order screen
--------------------------------------------------------------------------------

   Navigation is only one aspect of the Cupcake app's functionality. The user also
   interacts with each of the app screens. You need to verify what appears on these screens
   and that actions taken on these screens yield the correct results. The
   **SelectOptionScreen** is an important part of the app.

   In this section, you write a test to verify that the content on this screen is correctly
   set.


Test the Choose Flavor screen content

   1. Create a new class inside the ``app/src/androidTest`` directory called
      ``CupcakeOrderScreenTest``, where your other test files are contained.

   |1aaa3be367a02dcd.png|

   2. In this class, create an ``AndroidComposeTestRule``.

   .. code:: prettyprint

      @get:Rule
      val composeTestRule = createAndroidComposeRule<ComponentActivity>()

   3. Create a function called ``selectOptionScreen_verifyContent()`` and annotate it with
      ``@Test``.

   .. code:: prettyprint

      @Test
      fun selectOptionScreen_verifyContent() {

      }

   In this function, you ultimately set the Compose rule content to the
   ``SelectOptionScreen``. Doing so ensures that the ``SelectOptionScreen`` composable
   launches directly so that navigation is not required. However, this screen requires two
   parameters: a list of flavor options and a subtotal.

   4. Create a list of flavor options and a subtotal to be passed to the screen.

   .. code:: prettyprint

      @Test
      fun selectOptionScreen_verifyContent() {
          // Given list of options
          val flavors = listOf("Vanilla", "Chocolate", "Hazelnut", "Cookie", "Mango")
          // And subtotal
          val subtotal = "$100"
      }

   5. Set the content to the ``SelectOptionScreen`` composable using the values you just
      created.

   Note that this approach is similar to launching a composable from the ``MainActivity``.
   The only difference is that the ``MainActivity`` calls the ``CupcakeApp`` composable,
   and here you are calling the ``SelectOptionScreen`` composable. Being able to change the
   composable you launch from ``setContent()`` lets you launch specific composables instead
   of having the test explicitly step through the app to get to the area you want to test.
   This approach helps prevent the test from failing in areas of the code that are
   unrelated to your current test.

   .. code:: prettyprint

      @Test
      fun selectOptionScreen_verifyContent() {
          // Given list of options
          val flavors = listOf("Vanilla", "Chocolate", "Hazelnut", "Cookie", "Mango")
          // And subtotal
          val subtotal = "$100"

          // When SelectOptionScreen is loaded
          composeTestRule.setContent {
              SelectOptionScreen(subtotal = subtotal, options = flavors)
          }
      }

   At this point in the test, the app launches the ``SelectOptionScreen`` composable and
   you are then able to interact with it through test instructions.

   6. Iterate through the ``flavors`` list and ensure that each string item in the list is
      displayed on the screen.
   7. Use the ``onNodeWithText()`` method to find the text on the screen and use the
      ``assertIsDisplayed()`` method to verify that the text is displayed in the app.

   .. code:: prettyprint

      @Test
      fun selectOptionScreen_verifyContent() {
          // Given list of options
          val flavors = listOf("Vanilla", "Chocolate", "Hazelnut", "Cookie", "Mango")
          // And subtotal
          val subtotal = "$100"

          // When SelectOptionScreen is loaded
          composeTestRule.setContent {
              SelectOptionScreen(subtotal = subtotal, options = flavors)
          }

          // Then all the options are displayed on the screen.
          flavors.forEach { flavor ->
              composeTestRule.onNodeWithText(flavor).assertIsDisplayed()
          }
      }

   8. Using the same technique to verify that the app displays the text, verify that the
      app displays the correct subtotal string on the screen. Search the screen for the
      ``R.string.subtotal_price`` resource id and the correct subtotal value, then assert
      that the app displays the value.

   .. code:: prettyprint

      import com.example.cupcake.R
      ...

      @Test
      fun selectOptionScreen_verifyContent() {
          // Given list of options
          val flavors = listOf("Vanilla", "Chocolate", "Hazelnut", "Cookie", "Mango")
          // And subtotal
          val subtotal = "$100"

          // When SelectOptionScreen is loaded
          composeTestRule.setContent {
              SelectOptionScreen(subtotal = subtotal, options = flavors)
          }

          // Then all the options are displayed on the screen.
          flavors.forEach { flavor ->
              composeTestRule.onNodeWithText(flavor).assertIsDisplayed()
          }

          // And then the subtotal is displayed correctly.
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(
                  R.string.subtotal_price,
                  subtotal
              )
          ).assertIsDisplayed()
      }

   Recall that the **Next** button is not enabled until an item is selected. This test only
   verifies the screen content, so the last thing to test is that the **Next** button is
   disabled.

   9. Find the **Next** button by using the same approach to find a node by string resource
      id. However, instead of verifying that the app displays the node, use the
      ``assertIsNotEnabled()`` method.

   .. code:: prettyprint

      @Test
      fun selectOptionScreen_verifyContent() {
          // Given list of options
          val flavors = listOf("Vanilla", "Chocolate", "Hazelnut", "Cookie", "Mango")
          // And subtotal
          val subtotal = "$100"

          // When SelectOptionScreen is loaded
          composeTestRule.setContent {
              SelectOptionScreen(subtotal = subtotal, options = flavors)
          }

          // Then all the options are displayed on the screen.
          flavors.forEach { flavor ->
              composeTestRule.onNodeWithText(flavor).assertIsDisplayed()
          }

          // And then the subtotal is displayed correctly.
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(
                  R.string.subtotal_price,
                  subtotal
              )
          ).assertIsDisplayed()

          // And then the next button is disabled
          composeTestRule.onNodeWithStringId(R.string.next).assertIsNotEnabled()
      }


Maximize test coverage

   The Choose Flavor screen content test only tests one aspect of a single screen. There
   are a number of additional tests you can write to increase your code coverage. Try
   writing the following tests on your own before downloading the solution code.

   -  Verify the Start screen content.
   -  Verify the Summary screen content.
   -  Verify that the **Next** button is enabled when an option is selected on the Choose
      Flavor screen.

   As you write your tests, keep in mind any helper functions that might reduce the amount
   of code you write along the way!

7. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use this git command:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-cupcake.git

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-cupcake/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the downloaded repository.

   If you want to see the solution code, 
   `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-cupcake/tree/main>`__.

8. Summary
--------------------------------------------------------------------------------

   Congratulations! You've learned how to test the Jetpack Navigation component. You also
   learned some fundamental skills for writing UI tests, such as writing reusable helper
   methods, how to leverage ``setContent()`` to write concise tests, how to set up your
   tests with the ``@Before`` annotation, and how to think about maximum test coverage. As
   you continue to build Android apps, remember to keep writing tests alongside your
   feature code!

.. |290b1ab99ce8f4e5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-cupcake/img/290b1ab99ce8f4e5.png
.. |718bde5eb21b4f6f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-cupcake/img/718bde5eb21b4f6f.png
.. |7ad315f41e2b0881.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-cupcake/img/7ad315f41e2b0881.png
.. |b8306f9d11988a2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-cupcake/img/b8306f9d11988a2.png
.. |5515db35968f7d86.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-cupcake/img/5515db35968f7d86.png
.. |4b527e7404fad927.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-cupcake/img/4b527e7404fad927.png
.. |63af08bd78a827c4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-cupcake/img/63af08bd78a827c4.png
.. |5710fc2d8219048b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-cupcake/img/5710fc2d8219048b.png
.. |ffb8d156220c7e57.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-cupcake/img/ffb8d156220c7e57.png
.. |3bda045bfe202c90.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-cupcake/img/3bda045bfe202c90.png
.. |1aaa3be367a02dcd.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-test-cupcake/img/1aaa3be367a02dcd.png


ğŸš€ Practice: Add navigation
===========================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-navigation


1. Before you begin
--------------------------------------------------------------------------------

   Congratulations! You built your first app in Jetpack Compose with navigation between
   multiple screens. Now you're ready to put what you learned into practice.

   This exercise focuses on the creation of the components necessary to add navigation to
   an app with multiple screen composables. The material expands upon what you learned in
   the `Navigate between screens with Compose <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-navigation>`__
   codelab, and lets you apply that knowledge to add navigation to an existing app.

   The solution code is available at the end, but try to solve the exercises before you
   check the answers. Consider the solution as one way to implement the app.


Prerequisites

   -  The Android Basics in Compose coursework through the 
      `Navigate between screens with Compose codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-navigation>`__


What you'll need

   -  A computer with internet access and Android Studio installed
   -  The starter code for the Lunch Tray app


What you'll build

   In these practice problems, you will complete the Lunch Tray app by adding navigation.
   The Lunch Tray app is an interactive lunch ordering app with three screens. Each screen
   represents one of the three types of menu items from which you can select: an entree, a
   side dish, and an accompaniment.

   The practice problems are split into sections, where you will do the following:

   -  Create a reference for each screen that the user navigates.
   -  Initialize a navigation controller.
   -  Create a top bar that displays the screen title and navigation buttons, if
      appropriate.
   -  Configure a navigation host that determines the routing from one screen to the next.

   The final app flow will look like this:

   |6e7d1c4638c64988.png|


2. Get set up
--------------------------------------------------------------------------------


**Download the starter code**

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-lunch-tray/tree/starter

   **Branch name with starter code:** ``starter``

   1. In Android Studio, open the **``basic-android-kotlin-compose-training-lunch-tray``**
      folder.
   2. Open the Lunch Tray app code in Android Studio.


3. Screen enum
--------------------------------------------------------------------------------

   In this section, you create an ``enum`` class to hold constants for each of the
   following Lunch Tray app screens:

   -  Start
   -  Entree menu
   -  Side dish menu
   -  Accompaniment menu
   -  Checkout

   Each screen should have an associated title in the form of a string. The strings are
   available in the starter code as resources.


4. Navigation controller and initialization
--------------------------------------------------------------------------------

   In this section, you create the navigation controller. You also initialize the backstack
   entry and name of the current screen.

   The name of the current screen should be either the name of the initial screen or the
   name of the destination screen if it currently exists.


5. AppBar
--------------------------------------------------------------------------------

   Create a composable for the AppBar of the ``Scaffold`` composable. The AppBar should
   display the title of the current screen. The appropriate backward-navigation button also
   should appear on a screen if backward navigation is possible. Backward navigation should
   not be available from the **Start** screen.


Final screenshot

   The following screenshots show two examples of the AppBar: one without the up button and
   the other with the button.

   |89162a2f5b189ffc.png| |4a908f1153e7773e.png|


UI specifications

   Use the **``Icons.Filled.ArrowBack``** icon for the backward-navigation button.


6. Navigation host
--------------------------------------------------------------------------------

   In this exercise, you build the navigational routing for the Lunch Tray app by using the
   navigation host.

   The following diagram shows the navigational flow for the Lunch Tray app:

   |61df3b2ee856325a.png|

   -  The **Start Order** button on the **Start** screen navigates to the **Entree menu**
      screen.
   -  The **Next** button on the **Entree menu** screen navigates to the **Side dish menu**
      screen.
   -  The **Next** button on the **Side dish menu** screen navigates to the **Accompaniment
      menu** screen.
   -  The **Next** button on the **Accompaniment menu** screen navigates to the
      **Checkout** screen.
   -  The **Submit** button on the **Checkout** screen navigates to the **Start** screen.
   -  The **Cancel** button on any screen navigates back to the **Start** screen.

   **Note:** Because the **Start** screen begins the navigational flow, you can navigate to
   it by popping the screen from the backstack.


Final result

   After you finish the implementation, your app navigation flow should look like this:

   |edb246dff8cf57f0.gif|


7. Get the solution code
--------------------------------------------------------------------------------

   **Solution code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-lunch-tray

   **Branch name with solution code:** ``main``

.. |6e7d1c4638c64988.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-navigation/img/6e7d1c4638c64988.png
.. |89162a2f5b189ffc.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-navigation/img/89162a2f5b189ffc.png
.. |4a908f1153e7773e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-navigation/img/4a908f1153e7773e.png
.. |61df3b2ee856325a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-navigation/img/61df3b2ee856325a.png
.. |edb246dff8cf57f0.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-navigation/img/edb246dff8cf57f0.gif
 

ğŸš€ Build an adaptive app with dynamic navigation
================================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens


1. Introduction
--------------------------------------------------------------------------------

   One of the great advantages of developing your app in the Android platform is the vast
   opportunity to reach users in different kinds of form factors, such as wearables, foldables,
   tablets, desktop, and even TV. When using an app, your users may want to use the same app on
   large screen devices to take advantage of the increased real estate. Increasingly, Android users
   use their apps on multiple devices of varying screen sizes, and expect a high-quality user
   experience across all devices.

   So far, you learned to make apps primarily for mobile devices. In this codelab, you'll learn how
   to transform your apps to make them adaptive to other screen sizes. You'll use adaptive
   navigation layout patterns that are beautiful and usable for both mobile and large screen
   devices, such as foldables, tablets, and desktop.


Prerequisites

   -  Familiarity with Kotlin programming, including classes, functions, and conditionals
   -  Familiarity using ``ViewModel`` classes
   -  Familiarity creating ``Composable`` functions
   -  Experience building layouts with Jetpack Compose
   -  Experience running apps on a device or emulator


What you'll learn

   -  How to create navigation between screens without Navigation Graph for simple apps
   -  How to create an adaptive navigation layout using Jetpack Compose
   -  How to create a custom back handler


What you'll build

   -  You will implement dynamic navigation in the existing Reply app to make its layout adapt to
      all screen sizes

   The finished product will look like the image below:

   |56cfa13ef31d0b59.png|


What you'll need

   -  A computer with internet access, a web browser, and Android Studio
   -  Access to GitHub


2. App overview
--------------------------------------------------------------------------------


Reply app introduction

   Reply app is a multiscreen app which resembles an `email client <https://en.wikipedia.org/wiki/Email_client>`__.

   |a1af0f9193718abf.png|

   It contains 4 different categories which are displayed by different tabs, namely: inbox, sent,
   draft, and spam.


Download the starter code

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-reply-app/tree/starter

   **Branch name with starter code:** ``starter``


3. Starter code walkthrough
--------------------------------------------------------------------------------


Important directories in Reply app

   The Reply App file directory displays two sub-directories that are expanded.

   The data and UI layer of the Reply app project is separated into different directories.
   ``ReplyViewModel``, ``ReplyUiState``, and other composables are located in the ``ui`` directory.
   The ``data`` and ``enum`` classes that define the data layer and the data provider classes are
   located in the ``data`` directory.


Data initialization in Reply app

   The Reply app is initialized with data through the ``initializeUIState()`` method in the
   ``ReplyViewModel``, which is executed in the ``init`` function.

   **ReplyViewModel.kt**

   .. code:: prettyprint

      ...
          init {
              initializeUIState()
          }
       

          private fun initializeUIState() {
              var mailboxes: Map<MailboxType, List<Email>> =
                  LocalEmailsDataProvider.allEmails.groupBy { it.mailbox }
              _uiState.value = ReplyUiState(
                  mailboxes = mailboxes,
                  currentSelectedEmail = mailboxes[MailboxType.Inbox]?.get(0)
                      ?: LocalEmailsDataProvider.defaultEmail
              )
          }
      ...


The screen level composable

   As with other apps, the Reply app uses the ``ReplyApp`` composable as the main composable where
   the ``viewModel`` and ``uiState`` are declared. Various ``viewModel()`` functions are also passed
   as lambda arguments for the ``ReplyHomeScreen`` composable.

   **ReplyApp.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun ReplyApp(modifier: Modifier = Modifier) {
          val viewModel: ReplyViewModel = viewModel()
          val replyUiState = viewModel.uiState.collectAsState().value

          ReplyHomeScreen(
              replyUiState = replyUiState,
              onTabPressed = { mailboxType: MailboxType ->
                  viewModel.updateCurrentMailbox(mailboxType = mailboxType)
                  viewModel.resetHomeScreenStates()
              },
              onEmailCardPressed = { email: Email ->
                  viewModel.updateDetailsScreenStates(
                      email = email
                  )
              },
              onDetailScreenBackPressed = {
                  viewModel.resetHomeScreenStates()
              },
              modifier = modifier
          )
      }


Other composables

   -  **``ReplyHomeScreen.kt``**: contains the screen composables for home screen, including
      navigation elements.
   -  **``ReplyHomeContent.kt``**: contains composables that define more detailed composables of the
      home screen.
   -  **``ReplyDetailsScreen.kt``**: contains screen composables and smaller composables for the
      details screen.

   Feel free to go through each file in detail to gain more understanding of the composables before
   proceeding with the next section of the codelab.


4. Change screens without a navigation graph
--------------------------------------------------------------------------------

   In the previous pathway, you learned to use a ``NavHostController`` class to navigate from one
   screen to another. With Compose, you can also change screens with simple conditional statements
   by making use of runtime mutable states. This is especially useful in small applications like the
   Reply app, where you only want to switch between two screens.


Change screens with state changes

   In Compose, screens are recomposed when a state change occurs. You can change screens using
   simple conditionals to respond to changes in states.

   You'll use conditionals to show the content of the home screen when the user is at the home
   screen, and the details screen when the user is not at the home screen.

   Modify the Reply app to allow screen changes on state change by completing the following steps:

   1. Open the starter code in Android Studio.
   2. In the ``ReplyHomeScreen`` composable in ``ReplyHomeScreen.kt``, wrap the ``ReplyAppContent``
      composable with an ``if`` statement for when the ``isShowingHomepage`` property of
      ``replyUiState`` object is ``true``.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      @Composable
      fun ReplyHomeScreen(
          replyUiState: ReplyUiState,
          onTabPressed: (MailboxType) -> Unit,
          onEmailCardPressed: (Int) -> Unit,
          onDetailScreenBackPressed: () -> Unit,
          modifier: Modifier = Modifier
      ) {

      ...
          if (replyUiState.isShowingHomepage) {
              ReplyAppContent(
                  replyUiState = replyUiState,
                  onTabPressed = onTabPressed,
                  onEmailCardPressed = onEmailCardPressed,
                  navigationItemContentList = navigationItemContentList,
                  modifier = modifier

              )
          }
      }

   You must now account for the scenario when the user is not at the home screen by showing the
   details screen.

   3. Add an ``else`` branch with the ``ReplyDetailsScreen`` composable in its body. Add
      ``replyUIState``, ``onDetailScreenBackPressed`` and ``modifier`` as arguments for the
      ``ReplyDetailsScreen`` composable.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      @Composable
      fun ReplyHomeScreen(
          replyUiState: ReplyUiState,
          onTabPressed: (MailboxType) -> Unit,
          onEmailCardPressed: (Int) -> Unit,
          onDetailScreenBackPressed: () -> Unit,
          modifier: Modifier = Modifier
      ) {

      ...

          if (replyUiState.isShowingHomepage) {
              ReplyAppContent(
                  replyUiState = replyUiState,
                  onTabPressed = onTabPressed,
                  onEmailCardPressed = onEmailCardPressed,
                  navigationItemContentList = navigationItemContentList,
                  modifier = modifier

              )
          } else {
              ReplyDetailsScreen(
                  replyUiState = replyUiState,
                  onBackPressed = onDetailScreenBackPressed,
                  modifier = modifier
              )
          }
      }

   The ``replyUiState`` object is a state object. As such, when there is a change in the
   ``isShowingHomepage`` property of the ``replyUiState`` object, the ``ReplyHomeScreen`` composable
   is recomposed and the ``if/else`` statement is reevaluated at runtime. This approach supports
   navigation between different screens without the use of a ``NavHostController`` class.

   |8443a3ef1a239f6e.gif|


Create custom back handler

   One advantage of using the ``NavHost`` composable to switch between screens is that the
   directions of previous screens are saved in the backstack. These saved screens allow the system
   back button to easily navigate to the previous screen when invoked. Since the Reply app doesn't
   use a ``NavHost``, you have to add the code to handle the back button manually. You will do this
   next.

   Complete the following steps to create a custom back handler in the Reply app:

   1. On the first line of the ``ReplyDetailsScreen`` composable, add a ``BackHandler`` composable.
   2. Call the ``onBackPressed()`` function in the body of the ``BackHandler`` composable.

   **ReplyDetailsScreen.kt**

   .. code:: prettyprint

      ...
      import androidx.activity.compose.BackHandler
      ...
      @Composable
      fun ReplyDetailsScreen(
          replyUiState: ReplyUiState,
          onBackPressed: () -> Unit,
          modifier: Modifier = Modifier
      ) {
          BackHandler {
              onBackPressed()
          }
      ... 


5. Run app on large screen devices
--------------------------------------------------------------------------------


Check your app with the resizable emulator

   To make usable apps, developers need to understand their users' experience in various form
   factors. Therefore, you must test apps on various form factors from the beginning of the
   development process.

   You can use many emulators of different screen sizes to achieve this goal. However, doing so can
   be cumbersome, especially when you are building for multiple screen sizes at once. You might also
   need to test how an app that is running responds to screen size changes , such as orientation
   changes, window size changes in a desktop, and fold state changes in foldable.

   Android Studio helps you to test these scenarios with the introduction of the **resizable
   emulator**.

   Complete the following steps to set up the resizable emulator:

   1. In Android Studio, select **Tools** > **Device Manager**.

      .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/d5ad25dcd845441a.png

         The Tools menu displays a list of options. Device Manager , which appears halfway down the list,
         is selected.

   2. In **Device Manager**, click **+** icon to create a virtual device.

      .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/10d3d6f4afe4035a.png

         The device manager toolbar displays two menu options including create virtual device.

   3. Select the **Phone** category and the **Resizable (Experimental)** device.
   4. Click **Next**.

      .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/94af56858ef86e1c.png

         The Device Manager window displays a prompt to choose a device definition. A list of options
         displays with a search field above it. The category

   5. Select **API Level 34** or higher.
   6. Click **Next**.

      .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/9658c810f0be9988.png

         The Virtual Device Configuration window displays a prompt to select a system image. 34 API level
         is selected.

   7. Name your new Android Virtual Device.
   8. Click **Finish**.

      .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/f6f40f18319df171.png

         The Virtual Configration screen in Android Virtural Device (AVD) displays. The configuration
         screen includes a text field to enter the AVD name. Below the name field are a list of device
         options, including the device definition (Resizable Experimental), the system image (Tiramisu),
         and the orientation, with Portrait orientation selected by default. Buttons reading


Run app on a large screen emulator

   1. Run the app on the resizable emulator.
   2. Select **Tablet** for the display mode.

   |bfacf9c20a30b06b.png|

   3. Inspect the app in the Tablet mode in landscape mode.

   |bb0fa5e954f6ca4b.png|

   Notice that the tablet screen display is horizontally elongated. While this orientation
   functionally works, it might not be the best use of the large screen real estate. Let's address
   that next.


Design for large screens

   Your first thought might be when looking at this app on a tablet is that it is poorly designed
   and unappealing. You are exactly right: this layout is *not* designed for large screen use.

   When designing for large screens, such as tablets and foldables, you have to consider user
   ergonomics and the proximity of the user's fingers to the screen. With mobile devices, user's
   fingers can easily reach most of the screen; the location of interactive elements, such as
   buttons and navigation elements, are not as critical. However, for large screens, having critical
   interactive elements in the middle of the screen can make them hard to reach.

   As you see in the Reply app, design for large screens is not just stretching or enlarging UI
   elements to fit the screen. It is an opportunity to use the increased real estate to create a
   different experience for your users. For example, you can add another layout on the same screen
   to prevent the need to navigate to another screen or make multitasking possible.

   |f50e77a4ffd923a.png|

   This design can increase user productivity and fosters greater engagement. But before you deploy
   this design, you must first learn how to create different layouts for different screen sizes.

   **Note**: Portrait mode is the primary orientation for phones, but landscape mode is the primary
   orientation for tablets. When designing for adaptivity, the relevant screen size is affected by
   the current window size and the device orientation, not just the device size.


6. Make your layout adapt to different screen sizes
--------------------------------------------------------------------------------


What are breakpoints?

   You may wonder how you can show different layouts for the same app. The short answer is by using
   conditionals on different states, the way you did in the beginning of this codelab.

   To create an adaptive app, you need the layout to change based on screen size. The measurement
   point where a layout changes is known as a breakpoint. Material Design created an 
   `opinionated breakpoint range <https://m3.material.io/foundations/adaptive-design/large-screens/overview>`__
   that covers most Android screens.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/74bb1db3132462ae.png

      A table shows the breakpoint range (in dp) for different device types and setups. 0 to 599 dp is
      for handsets in portait mode, phones in landscape, compact window size, 4 columns, and 8 minimum
      margins. 600 to 839 dp is for foldable small tablets in portait or landscape modes, medium window
      size class, 12 columns, and 12 minimum margins. 840 dp or greater is for a large tablet in
      portrait or landscape modes, the expanded window size class, 12 columns, and 32 minimum margins.
      Table notes state that margins and gutters are flexible and don't need to be equal in size and
      that phones in landscape are considered an exception to still fit within the 0 to 599 dp
      breakpoint range.

   This breakpoint range table shows, for example, that if your app is currently running on a device
   with a screen size less than 600 dp, you should show the mobile layout.

   **Note**: The breakpoints concept in adaptive layouts is different from the 
   `breakpoints term in debugging <https://developer.android.google.cn/studio/debug#breakPoints>`__.


Use Window Size Classes

   The ``WindowSizeClass`` API introduced for Compose makes the implementation of Material Design
   breakpoints simpler.

   Window Size Classes introduces three categories of sizes: Compact, Medium, and Expanded, for both
   width and height.


   |42db283a2ba29045.png| |2c932129fca12cea.png|

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/42db283a2ba29045.png

      The diagram represents the width-based window size classes.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/2c932129fca12cea.png

      The diagram represents the height-based window size classes.


   Complete the following steps to implement the ``WindowSizeClass`` API in the Reply app:

   1. Add the ``material3-window-size-class`` dependency to the module ``build.gradle.kts`` file.

      **build.gradle.kts**

      .. code:: prettyprint

         ...
         dependencies {
         ...
             implementation("androidx.compose.material3:material3-window-size-class")
         ...

   2. Click **Sync Now** to sync gradle after adding the dependency.

      |b4c912a45fa8b7f4.png|

      With the ``build.gradle.kts`` file up to date, you now can create a variable that stores the size
      of the app's window at any given time.

   3. In the ``onCreate()`` function in the ``MainActivity.kt`` file, assign the
      ``calculateWindowSizeClass()`` method with ``this`` context passed in the parameter to a
      variable named ``windowSize``.

   4. Import the appropriate ``calculateWindowSizeClass`` package.

      **MainActivity.kt**

      .. code:: prettyprint

         ...
         import androidx.compose.material3.windowsizeclass.calculateWindowSizeClass

         ...

         override fun onCreate(savedInstanceState: Bundle?) {
             super.onCreate(savedInstanceState)

             setContent {
                 ReplyTheme {
                     val layoutDirection = LocalLayoutDirection.current
                     Surface (
                        // ...
                     ) {
                         val windowSize = calculateWindowSizeClass(this)
                         ReplyApp()
         ...  

   5. Notice the red underlining of the ``calculateWindowSizeClass`` syntax, which shows the red
      light bulb. Click the red light bulb to the left of the ``windowSize`` variable and select
      **Opt in for â€˜ExperimentalMaterial3WindowSizeClassApi' on â€˜onCreate'** to create an annotation
      on top of the ``onCreate()`` method.

      **Note**: This error message appears because currently the ``material3-window-size-class`` API is
      still in an alpha version that requires this annotation.

      |f8029f61dfad0306.png|

      You can use the ``WindowWidthSizeClass`` variable in the ``MainActivity.kt`` to determine which
      layout to display in various composables. Let's prepare the ``ReplyApp`` composable to receive
      this value.

   6. In the ``ReplyApp.kt`` file, modify the ``ReplyApp`` composable to accept the
      ``WindowWidthSizeClass`` as the parameter and import the appropriate package.

      **ReplyApp.kt**

      .. code:: prettyprint

         ...
         import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
         ...

         @Composable
         fun ReplyApp(
             windowSize: WindowWidthSizeClass,
             modifier: Modifier = Modifier
         ) {
         ...  

   7. Pass the ``windowSize`` variable to the ``ReplyApp`` component in the ``MainActivity.kt``
      file's ``onCreate()`` method.

      **MainActivity.kt**

      .. code:: prettyprint

         ...
                 setContent {
                     ReplyTheme {
                         Surface {
                             val windowSize = calculateWindowSizeClass(this)
                             ReplyApp(
                                 windowSize = windowSize.widthSizeClass
                             )
         ...  

      You also need to update the app's preview, too, for the ``windowSize`` parameter.

   8. Pass the ``WindowWidthSizeClass.Compact`` as the ``windowSize`` parameter to the ``ReplyApp``
      composable for the preview component and import the appropriate package.

      **MainActivity.kt**

      .. code:: prettyprint

         ...
         import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
         ...

         @Preview(showBackground = true)
         @Composable
         fun ReplyAppCompactPreview() {
             ReplyTheme {
                 Surface {
                     ReplyApp(
                         windowSize = WindowWidthSizeClass.Compact,
                     )
                 }
             }
         }

   9. To change the app layouts based on the size of the screen, add a ``when`` statement in the
      ``ReplyApp`` composable based on the ``WindowWidthSizeClass`` value.

      **ReplyApp.kt**

      .. code:: prettyprint

         ...

         @Composable
         fun ReplyApp(
             windowSize: WindowWidthSizeClass,
             modifier: Modifier = Modifier
         ) {
             val viewModel: ReplyViewModel = viewModel()
             val replyUiState = viewModel.uiState.collectAsState().value
             
             when (windowSize) {
                 WindowWidthSizeClass.Compact -> {
                 }
                 WindowWidthSizeClass.Medium -> {
                 }
                 WindowWidthSizeClass.Expanded -> {
                 }
                 else -> {
                 }
             }
         ...  

      At this point, you established a foundation to use ``WindowSizeClass`` values to change the
      layouts in your app. The next step is to determine how you want your app to look on different
      screen sizes.


7. Implement adaptive navigation layout
--------------------------------------------------------------------------------


Implement adaptive UI navigation

   Currently, the `bottom navigation <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#NavigationBar(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,kotlin.Function1)>`__
   is used for all screen sizes.

   |f39984211e4dd665.png|

   As previously discussed, this navigation element is not ideal because users can find it difficult
   to reach these essential navigation elements on larger screens. Fortunately, there are
   recommended patterns for different navigation elements for various window size classes in
   `navigation for responsive UIs <https://developer.android.google.cn/guide/topics/large-screens/navigation-for-responsive-uis#responsive_ui_navigation>`__.
   For the Reply app, you can implement the following elements:

   ================= ===================== ========================================
   Window size class Few items             Many items
   ================= ===================== ========================================
   compact width     bottom navigation bar navigation drawer (leading edge or bottom)
   medium width      navigation rail       navigation drawer (leading edge)
   expanded width    navigation rail       persistent navigation drawer (leading edge)
   ================= ===================== ========================================

      A table lists the window size classes and the few items that display. Compact width displays a
      bottom navigation bar. Medium width displays a navigation rail. Expanded width displays a
      persistent navigation drawer with a leading edge.

   `Navigation rail <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#NavigationRail(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function1,androidx.compose.foundation.layout.WindowInsets,kotlin.Function1)>`__
   is another navigation component by `material design <https://m3.material.io/components/navigation-rail/overview>`__ 
   which allows compact navigation options for primary destinations to be accessible from the side of the app.

   |1c73d20ace67811c.png|

   Similarly, a `persistent/permanent navigation drawer <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#PermanentNavigationDrawer(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function0)>`__
   is created by `material design <https://m3.material.io/components/navigation-drawer/overview>`__
   as another option to provide ergonomic access for larger screens.

   |6795fb31e6d4a564.png|


Implement a navigation drawer

   To create a navigation drawer for expanded screens, you can use the ``navigationType`` parameter.
   Complete the following steps to do so:

   1. To represent different types of navigation elements, create a new file ``WindowStateUtils.kt``
      in a new package ``utils``, which is under the ``ui`` directory.
   2. Add an ``Enum`` class to represent different types of navigation elements.

   **WindowStateUtils.kt**

   .. code:: prettyprint

      package com.example.reply.ui.utils

      enum class ReplyNavigationType {
          BOTTOM_NAVIGATION, NAVIGATION_RAIL, PERMANENT_NAVIGATION_DRAWER
      }
       

   To successfully implement the navigation drawer, you need to determine the navigation type based
   on the app's window size.

   3. In the ``ReplyApp`` composable, create a ``navigationType`` variable and assign it the
      appropriate ``ReplyNavigationType`` value, according to the screen size in the ``when``
      statement.

   **ReplyApp.kt**

   .. code:: prettyprint

      ...
      import com.example.reply.ui.utils.ReplyNavigationType
      ...
          val navigationType: ReplyNavigationType
          when (windowSize) {
              WindowWidthSizeClass.Compact -> {
                  navigationType = ReplyNavigationType.BOTTOM_NAVIGATION
              }
              WindowWidthSizeClass.Medium -> {
                  navigationType = ReplyNavigationType.NAVIGATION_RAIL
              }
              WindowWidthSizeClass.Expanded -> {
                  navigationType = ReplyNavigationType.PERMANENT_NAVIGATION_DRAWER
              }
              else -> {
                  navigationType = ReplyNavigationType.BOTTOM_NAVIGATION
              }
          }
      ...
       

   You can use the ``navigationType`` value in the ``ReplyHomeScreen`` composable. You can prepare
   for that by making it a parameter for the composable.

   4. In the ``ReplyHomeScreen`` composable, add ``navigationType`` as a parameter.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun ReplyHomeScreen(
          navigationType: ReplyNavigationType,
          replyUiState: ReplyUiState,
          onTabPressed: (MailboxType) -> Unit,
          onEmailCardPressed: (Email) -> Unit,
          onDetailScreenBackPressed: () -> Unit,
          modifier: Modifier = Modifier
      ) 

      ...
       

   5. Pass the ``navigationType`` into the ``ReplyHomeScreen`` composable.

   **ReplyApp.kt**

   .. code:: prettyprint

      ...
          ReplyHomeScreen(
              navigationType = navigationType,
              replyUiState = replyUiState,
              onTabPressed = { mailboxType: MailboxType ->
                  viewModel.updateCurrentMailbox(mailboxType = mailboxType)
                  viewModel.resetHomeScreenStates()
              },
              onEmailCardPressed = { email: Email ->
                  viewModel.updateDetailsScreenStates(
                      email = email
                  )
              },
              onDetailScreenBackPressed = {
                  viewModel.resetHomeScreenStates()
              },
              modifier = modifier
          )
      ...
       

   Next, you can create a branch to show the app content with a navigation drawer when the user
   opens the app on an expanded screen and displays the homescreen.

   6. In the ``ReplyHomeScreen`` composable body, add an ``if`` statement for
      ``navigationType == ReplyNavigationType.PERMANENT_NAVIGATION_DRAWER && replyUiState.isShowingHomepage``
      condition.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      import androidx.compose.material3.PermanentNavigationDrawer
      ...
      @Composable
      fun ReplyHomeScreen(
          navigationType: ReplyNavigationType,
          replyUiState: ReplyUiState,
          onTabPressed: (MailboxType) -> Unit,
          onEmailCardPressed: (Email) -> Unit,
          onDetailScreenBackPressed: () -> Unit,
          modifier: Modifier = Modifier
      ) {
      ...
          if (navigationType == ReplyNavigationType.PERMANENT_NAVIGATION_DRAWER
              && replyUiState.isShowingHomepage
          ) {
          }

          if (replyUiState.isShowingHomepage) {
              ReplyAppContent(
                  replyUiState = replyUiState,
      ...

   7. To create the permanent drawer, create the ``PermanentNavigationDrawer`` composable in the if
      statement's body and add ``NavigationDrawerContent`` composable as the input for the
      ``drawerContent`` parameter.
   8. Add the ``ReplyAppContent`` composable as the final lambda argument of the
      ``PermanentNavigationDrawer``.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
          if (navigationType == ReplyNavigationType.PERMANENT_NAVIGATION_DRAWER
              && replyUiState.isShowingHomepage
          ) {
              PermanentNavigationDrawer(
                  drawerContent = {
                      PermanentDrawerSheet(Modifier.width(dimensionResource(R.dimen.drawer_width))) {
                          NavigationDrawerContent(
                              selectedDestination = replyUiState.currentMailbox,
                              onTabPressed = onTabPressed,
                              navigationItemContentList = navigationItemContentList,
                              modifier = Modifier
                                  .wrapContentWidth()
                                  .fillMaxHeight()
                                  .background(MaterialTheme.colorScheme.inverseOnSurface)
                                  .padding(dimensionResource(R.dimen.drawer_padding_content))
                          )
                      }
                  }
              ) {
                  ReplyAppContent(
                      replyUiState = replyUiState,
                      onTabPressed = onTabPressed,
                      onEmailCardPressed = onEmailCardPressed,
                      navigationItemContentList = navigationItemContentList,
                      modifier = modifier
                  )
              }
          }

      ...

   9. Add an ``else`` branch that uses the previous composable body to maintain the previous
      branching for non expanded screens.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
      if (navigationType == ReplyNavigationType.PERMANENT_NAVIGATION_DRAWER
              && replyUiState.isShowingHomepage
      ) {
              PermanentNavigationDrawer(
                  drawerContent = {
                      PermanentDrawerSheet(Modifier.width(dimensionResource(R.dimen.drawer_width))) {
                          NavigationDrawerContent(
                              selectedDestination = replyUiState.currentMailbox,
                              onTabPressed = onTabPressed,
                              navigationItemContentList = navigationItemContentList,
                              modifier = Modifier
                                  .wrapContentWidth()
                                  .fillMaxHeight()
                                  .background(MaterialTheme.colorScheme.inverseOnSurface)
                                  .padding(dimensionResource(R.dimen.drawer_padding_content))
                          )
                      }
                  }
              ) {
                  ReplyAppContent(
                      replyUiState = replyUiState,
                      onTabPressed = onTabPressed,
                      onEmailCardPressed = onEmailCardPressed,
                      navigationItemContentList = navigationItemContentList,
                      modifier = modifier
                  )
              }
          } else {
              if (replyUiState.isShowingHomepage) {
                  ReplyAppContent(
                      replyUiState = replyUiState,
                      onTabPressed = onTabPressed,
                      onEmailCardPressed = onEmailCardPressed,
                      navigationItemContentList = navigationItemContentList,
                      modifier = modifier
                  )
              } else {
                  ReplyDetailsScreen(
                      replyUiState = replyUiState,
                      onBackPressed = onDetailScreenBackPressed,
                      modifier = modifier
                  )
              }
          }
      }
      ...

   10. Run the app in **Tablet** mode. You should see the following screen:

   |2dbbc2f88d08f6a.png|


Implement a navigation rail

   Similar to the navigation drawer implementation, you need to use the ``navigationType`` parameter
   to switch between navigation elements.

   First, let's add a navigation rail for medium screens.

   1. Begin with preparation of the ``ReplyAppContent`` composable by adding ``navigationType`` as a
      parameter.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
      @Composable
      private fun ReplyAppContent(
          navigationType: ReplyNavigationType,
          replyUiState: ReplyUiState,
          onTabPressed: ((MailboxType) -> Unit),
          onEmailCardPressed: (Email) -> Unit,
          navigationItemContentList: List<NavigationItemContent>,
          modifier: Modifier = Modifier
      ) {       
      ... 

   2. Pass the ``navigationType`` value into both ``ReplyAppContent`` composables.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
                  ReplyAppContent(
                      navigationType = navigationType,
                      replyUiState = replyUiState,
                      onTabPressed = onTabPressed,
                      onEmailCardPressed = onEmailCardPressed,
                      navigationItemContentList = navigationItemContentList,
                      modifier = modifier
                  )
              }
          } else {
              if (replyUiState.isShowingHomepage) {
                  ReplyAppContent(
                      navigationType = navigationType,
                      replyUiState = replyUiState,
                      onTabPressed = onTabPressed,
                      onEmailCardPressed = onEmailCardPressed,
                      navigationItemContentList = navigationItemContentList,
                      modifier = modifier
                  )
      ... 

   Next, let's add branching, which allows the app to display navigation rails for some scenarios.

   3. In the ``ReplyAppContent`` composable body first line, wrap the ``ReplyNavigationRail``
      composable around the ``AnimatedVisibility`` composable and set the ``visible`` parameter to
      be ``true`` if the ``ReplyNavigationType`` value is ``NAVIGATION_RAIL``.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
      @Composable
      private fun ReplyAppContent(
          navigationType: ReplyNavigationType,
          replyUiState: ReplyUiState,
          onTabPressed: ((MailboxType) -> Unit),
          onEmailCardPressed: (Email) -> Unit,
          navigationItemContentList: List<NavigationItemContent>,
          modifier: Modifier = Modifier
      ) {
          Box(modifier = modifier) {
              AnimatedVisibility(visible = navigationType == ReplyNavigationType.NAVIGATION_RAIL) {
                  ReplyNavigationRail(
                      currentTab = replyUiState.currentMailbox,
                      onTabPressed = onTabPressed,
      navigationItemContentList = navigationItemContentList
                  )
              }
              Column(
                  modifier = Modifier
                      .fillMaxSize()
                      .background(
                          MaterialTheme.colorScheme.inverseOnSurface
                  )
              ) {
                  ReplyListOnlyContent(
                      replyUiState = replyUiState,
                      onEmailCardPressed = onEmailCardPressed,
                      modifier = Modifier.weight(1f)
                          .padding(
                              horizontal = dimensionResource(R.dimen.email_list_only_horizontal_padding)
                          )
                  )
                  ReplyBottomNavigationBar(
                      currentTab = replyUiState.currentMailbox,
                      onTabPressed = onTabPressed,
                      navigationItemContentList = navigationItemContentList,
                        modifier = Modifier
                            .fillMaxWidth()
                  )
              }
          }
      }     
      ... 

   4. To align the composables correctly, wrap both the ``AnimatedVisibility`` composable and the
      ``Column`` composable found in the ``ReplyAppContent`` body in a ``Row`` composable.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
      @Composable
      private fun ReplyAppContent(
          navigationType: ReplyNavigationType,
          replyUiState: ReplyUiState,
          onTabPressed: ((MailboxType) -> Unit),
          onEmailCardPressed: (Email) -> Unit,
          navigationItemContentList: List<NavigationItemContent>,
          modifier: Modifier = Modifier,
      ) {
          Row(modifier = modifier) {
              AnimatedVisibility(visible = navigationType == ReplyNavigationType.NAVIGATION_RAIL) {
                  val navigationRailContentDescription = stringResource(R.string.navigation_rail)
                  ReplyNavigationRail(
                      currentTab = replyUiState.currentMailbox,
                      onTabPressed = onTabPressed,
                      navigationItemContentList = navigationItemContentList
                  )
              }
              Column(
                  modifier = Modifier
                      .fillMaxSize()
                      .background(MaterialTheme.colorScheme.inverseOnSurface)
              ) {
                  ReplyListOnlyContent(
                      replyUiState = replyUiState,
                      onEmailCardPressed = onEmailCardPressed,
                      modifier = Modifier.weight(1f)
                          .padding(
                              horizontal = dimensionResource(R.dimen.email_list_only_horizontal_padding)
                      )
                  )
                  ReplyBottomNavigationBar(
                      currentTab = replyUiState.currentMailbox,
                      onTabPressed = onTabPressed,
                      navigationItemContentList = navigationItemContentList,
                      modifier = Modifier
                          .fillMaxWidth()
                  )
              }
          }
      }

      ... 

   Finally, let's make sure the bottom navigation displays in some scenarios.

   5. After the ``ReplyListOnlyContent`` composable, wrap the ``ReplyBottomNavigationBar``
      composable with an ``AnimatedVisibility`` composable.
   6. Set the ``visible`` parameter when the ``ReplyNavigationType`` value is ``BOTTOM_NAVIGATION``.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
      ReplyListOnlyContent(
          replyUiState = replyUiState,
          onEmailCardPressed = onEmailCardPressed,
          modifier = Modifier.weight(1f)
              .padding(
                  horizontal = dimensionResource(R.dimen.email_list_only_horizontal_padding)
              )

      )
      AnimatedVisibility(visible = navigationType == ReplyNavigationType.BOTTOM_NAVIGATION) {
          val bottomNavigationContentDescription = stringResource(R.string.navigation_bottom)
          ReplyBottomNavigationBar(
              currentTab = replyUiState.currentMailbox,
              onTabPressed = onTabPressed,
              navigationItemContentList = navigationItemContentList,
              modifier = Modifier
                  .fillMaxWidth()
          )
      }

      ... 

   7. Run the app in **Unfolded foldable** mode. You should to see the following screen:

   |bfacf9c20a30b06b.png|


8. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-reply-app.git 
      cd basic-android-kotlin-compose-training-reply-app
      git checkout nav-update

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-reply-app/archive/refs/heads/nav-update.zip>`__

   **Note:** The solution code is in the ``nav-update`` branch of the code repository.

   If you want to see the solution code, 
   `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-reply-app/tree/nav-update>`__.


9. Conclusion
--------------------------------------------------------------------------------

   Congratulations! You are one step closer to making the Reply app adaptive for all screen sizes by
   implementing an adaptive navigation layout. You enhanced the user experience using many Android
   form factors. In the next codelab, you'll further improve your skills working with adaptive apps
   by implementing adaptive content layout, testing, and previews.

   Don't forget to share your work on social media with #AndroidBasics!


**Learn more**

   -  `Build adaptive layouts <https://developer.android.google.cn/jetpack/compose/layouts/adaptive>`__
   -  `Support different screen sizes <https://developer.android.google.cn/guide/topics/large-screens/support-different-screen-sizes>`__
   -  `Design for large screens <https://m3.material.io/foundations/adaptive-design/large-screens/layout-anatomy>`__
   -  `Jetnews for every screen <https://medium.com/androiddevelopers/jetnews-for-every-screen-4d8e7927752>`__


.. |56cfa13ef31d0b59.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/56cfa13ef31d0b59.png
.. |a1af0f9193718abf.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/a1af0f9193718abf.png
.. |8443a3ef1a239f6e.gif| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/8443a3ef1a239f6e.gif
.. |bfacf9c20a30b06b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/bfacf9c20a30b06b.png
.. |bb0fa5e954f6ca4b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/bb0fa5e954f6ca4b.png
.. |f50e77a4ffd923a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/f50e77a4ffd923a.png
.. |b4c912a45fa8b7f4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/b4c912a45fa8b7f4.png
.. |f8029f61dfad0306.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/f8029f61dfad0306.png
.. |f39984211e4dd665.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/f39984211e4dd665.png
.. |1c73d20ace67811c.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/1c73d20ace67811c.png
.. |6795fb31e6d4a564.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/6795fb31e6d4a564.png
.. |2dbbc2f88d08f6a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens/img/2dbbc2f88d08f6a.png


ğŸš€ Build an app with an adaptive layout
=======================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens 


1. Introduction
--------------------------------------------------------------------------------

   In the previous codelab, you started transforming the Reply app to be adaptive by using
   window size classes and implementing dynamic navigation. These features are an important
   foundation and the first step to building apps for all screen sizes. If you missed
   `Build an adaptive app with dynamic navigation <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens>`__
   codelab, you are strongly encouraged to go back and start there.

   In this codelab, you'll build on a concept you learned to further implement adaptive
   layout in your app. The adaptive layout that you'll implement is part of canonical
   layouts - a set of commonly-used patterns for large screen displays. You'll also learn
   about more tooling and testing techniques to help you to quickly build robust apps.


Prerequisites

   -  Completion of the `Build an adaptive app with dynamic navigation codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens>`__
   -  Familiar with Kotlin programming, including classes, functions and conditionals
   -  Familiar with ``ViewModel`` classes
   -  Familiar with ``Composable`` functions
   -  Experience building layouts with Jetpack Compose
   -  Experience running apps on a device or emulator
   -  Experience using ``WindowSizeClass`` API


What you'll learn

   -  How to create a list-view pattern adaptive layout using Jetpack Compose
   -  How to create previews for different screen sizes
   -  How to test code for multiple screen sizes


What you'll build

   -  You will continue updating the Reply app to be adaptive for all screen sizes.

   The finished app will look like this:


What you'll need

   -  A computer with internet access, a web browser, and Android Studio
   -  Access to GitHub


Download the starter code

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-reply-app/archive/refs/heads/nav-update.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-reply-app.git
      $ cd basic-android-kotlin-compose-training-reply-app
      $ git checkout nav-update

   **Note:** The starter code is in the ``nav-update`` branch of the downloaded repository.

   You can browse the starter code in the `Reply GitHub repository.<https://github.com/google-developer-training/basic-android-kotlin-compose-training-reply-app/tree/nav-update>`__


2. Previews for different screen sizes
--------------------------------------------------------------------------------


Create previews for different screen sizes

   In the `Build an adaptive app with dynamic navigation <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens>`__
   codelab, you learned to use preview composables to help your development process. For an
   adaptive app, it is the best practice to create multiple previews to show the app on
   different screen sizes. With multiple previews, you can see your changes on all screen
   sizes at once. Moreover, the previews also serve as documentation for other developers
   who review your code to see that your app is compatible with different screen sizes.

   Previously, you only had a single preview that supported the compact screen. You'll add
   more previews next.

   To add previews for medium and expanded screens, complete the following steps:

   1. Add a preview for medium screens by setting a medium ``widthDp`` value in the
      ``Preview`` annotation parameter and specifying ``WindowWidthSizeClass.Medium`` value
      as the parameter for the ``ReplyApp`` composable.

   **MainActivity.kt**

   .. code:: prettyprint

      ...
      @Preview(showBackground = true, widthDp = 700)
      @Composable
      fun ReplyAppMediumPreview() {
          ReplyTheme {
              Surface {
                  ReplyApp(windowSize = WindowWidthSizeClass.Medium)
              }
          }
      }
      ...

   2. Add another preview for expanded screens by setting a large ``widthDp`` value in the
      ``Preview`` annotation parameter and specifying ``WindowWidthSizeClass.Expanded``
      value as the parameter for the ``ReplyApp`` composable.

   **MainActivity.kt**

   .. code:: prettyprint

      ...
      @Preview(showBackground = true, widthDp = 1000)
      @Composable
      fun ReplyAppExpandedPreview() {
          ReplyTheme {
              Surface {
                  ReplyApp(windowSize = WindowWidthSizeClass.Expanded)
              }
          }
      }
      ...

   3. Build the preview to view the following:

   |5577b1d0fe306e33.png|

   |f624e771b76bbc2.png|



3. Implement adaptive content layout
--------------------------------------------------------------------------------


Introduction to list-detail view

   You may notice that in the expanded screens, the content looks stretched out and doesn't
   make good use of the available screen real estate.

   |56cfa13ef31d0b59.png|

   You can improve this layout by applying one of the `canonical layouts <https://m3.material.io/foundations/adaptive-design/canonical-layouts>`__.
   Canonical layouts are large screen compositions that serve as starting points for design
   and implementation. You can use the three available layouts to guide how you organize
   common elements in an app, list-view, supporting panel, and feed. Each layout considers
   common use cases and components to address expectations and user needs for how apps
   adapt across screen sizes and breakpoints.

   For the Reply app, let's implement the `list-detail view`, as it is best for browsing
   content and quickly seeing details. With a list-detail view layout, you'll create
   another pane next to the email list screen to display the email details. This layout
   allows you to use the available screen to show more information to the user and make
   your app more productive.


Implement list-detail view

   To implement a list-detail view for expanded screens, complete the following steps:

   1. To represent different types of content layout, on ``WindowStateUtils.kt``, create a
      new ``Enum`` class for different content types. Use the ``LIST_AND_DETAIL`` value for
      when the expanded screen is in use and ``LIST_ONLY`` otherwise.

   **WindowStateUtils.kt**

   .. code:: prettyprint

      ...
      enum class ReplyContentType {
          LIST_ONLY, LIST_AND_DETAIL
      }
      ...

   2. Declare the ``contentType`` variable on ``ReplyApp.kt`` and assign the appropriate
      ``contentType`` for various window sizes to help determine the appropriate content
      type selection, depending on the screen size.

   **ReplyApp.kt**

   .. code:: prettyprint

      ...
      import com.example.reply.ui.utils.ReplyContentType
      ...

          val navigationType: ReplyNavigationType
          val contentType: ReplyContentType

          when (windowSize) {
              WindowWidthSizeClass.Compact -> {
                  ...
                  contentType = ReplyContentType.LIST_ONLY
              }
              WindowWidthSizeClass.Medium -> {
                  ...
                  contentType = ReplyContentType.LIST_ONLY
              }
              WindowWidthSizeClass.Expanded -> {
                  ...
                  contentType = ReplyContentType.LIST_AND_DETAIL
              }
              else -> {
                  ...
                  contentType = ReplyContentType.LIST_ONLY
              }
          }
      ...

   Next, you can use the ``contentType`` value to create different branching for layouts in
   the ``ReplyAppContent`` composable.

   3. In ``ReplyHomeScreen.kt``, add ``contentType`` as the parameter to the
      ``ReplyHomeScreen`` composable.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
      @OptIn(ExperimentalMaterial3Api::class)
      @Composable
      fun ReplyHomeScreen(
          navigationType: ReplyNavigationType,
          contentType: ReplyContentType,
          replyUiState: ReplyUiState,
          onTabPressed: (MailboxType) -> Unit,
          onEmailCardPressed: (Email) -> Unit,
          onDetailScreenBackPressed: () -> Unit,
          modifier: Modifier = Modifier
      ) {
      ...

   4. Pass the ``contentType`` value to the ``ReplyHomeScreen`` composable.

   **ReplyApp.kt**

   .. code:: prettyprint

      ...
          ReplyHomeScreen(
              navigationType = navigationType,
              contentType = contentType,
              replyUiState = replyUiState,
              onTabPressed = { mailboxType: MailboxType ->
                  viewModel.updateCurrentMailbox(mailboxType = mailboxType)
                  viewModel.resetHomeScreenStates()
              },
              onEmailCardPressed = { email: Email ->
                  viewModel.updateDetailsScreenStates(
                      email = email
                  )
              },
              onDetailScreenBackPressed = {
                  viewModel.resetHomeScreenStates()
              },
              modifier = modifier
          )

      ...

   5. Add the ``contentType`` as a parameter for the ``ReplyAppContent`` composable.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
      @Composable
      private fun ReplyAppContent(
          navigationType: ReplyNavigationType,
          contentType: ReplyContentType,
          replyUiState: ReplyUiState,
          onTabPressed: ((MailboxType) -> Unit),
          onEmailCardPressed: (Email) -> Unit,
          navigationItemContentList: List<NavigationItemContent>,
          modifier: Modifier = Modifier
      ) {
      ...

   6. Pass the ``contentType`` value to the two ``ReplyAppContent`` composables.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
                  ReplyAppContent(
                      navigationType = navigationType,
                      contentType = contentType,
                      replyUiState = replyUiState,
                      onTabPressed = onTabPressed,
                      onEmailCardPressed = onEmailCardPressed,
                      navigationItemContentList = navigationItemContentList,
                      modifier = modifier
                  )
              }
          } else {
              if (replyUiState.isShowingHomepage) {
                  ReplyAppContent(
                      navigationType = navigationType,
                      contentType = contentType,
                      replyUiState = replyUiState,
                      onTabPressed = onTabPressed,
                      onEmailCardPressed = onEmailCardPressed,
                      navigationItemContentList = navigationItemContentList,
                      modifier = modifier
                  )
              } else {
                  ReplyDetailsScreen(
                      replyUiState = replyUiState,
                      isFullScreen = true,
                      onBackButtonClicked = onDetailScreenBackPressed,
                      modifier = modifier
                  )
              }
          }
      ...

   Let's display either the full list and detail screen when the ``contentType`` is
   ``LIST_AND_DETAIL`` or the list only email content when the ``contentType`` is
   ``LIST_ONLY``.

   7. In ``ReplyHomeScreen.kt``, add an ``if/else`` statement on the ``ReplyAppContent``
      composable to display the ``ReplyListAndDetailContent`` composable when the
      ``contentType`` value is ``LIST_AND_DETAIL`` and display the ``ReplyListOnlyContent``
      composable on the ``else`` branch.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
              Column(
                  modifier = modifier
                      .fillMaxSize()
                      .background(MaterialTheme.colorScheme.inverseOnSurface)
              ) {
                  if (contentType == ReplyContentType.LIST_AND_DETAIL) {
                      ReplyListAndDetailContent(
                          replyUiState = replyUiState,
                          onEmailCardPressed = onEmailCardPressed,
                          modifier = Modifier.weight(1f)
                      )
                  } else {
                      ReplyListOnlyContent(
                          replyUiState = replyUiState,
                          onEmailCardPressed = onEmailCardPressed,
                          modifier = Modifier.weight(1f)
                              .padding(
                                  horizontal = dimensionResource(R.dimen.email_list_only_horizontal_padding)
                              )
                      )
                  }
                  AnimatedVisibility(visible = navigationType == ReplyNavigationType.BOTTOM_NAVIGATION) {
                      ReplyBottomNavigationBar(
                          currentTab = replyUiState.currentMailbox,
                          onTabPressed = onTabPressed,
                          navigationItemContentList = navigationItemContentList
                      )
                  }
              }
      ...

   8. Remove the ``replyUiState.isShowingHomepage`` condition to show a 
      `permanent navigation drawer <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#NavigationRail(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function1,kotlin.Function1)>`__,
      as the user doesn't need to navigate to the details view if they are using the
      expanded view.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
          if (navigationType == ReplyNavigationType.PERMANENT_NAVIGATION_DRAWER) {
              PermanentNavigationDrawer(
                  drawerContent = {
                      PermanentDrawerSheet(Modifier.width(dimensionResource(R.dimen.drawer_width))) {
                          NavigationDrawerContent(
                              selectedDestination = replyUiState.currentMailbox,
                              onTabPressed = onTabPressed,
                              navigationItemContentList = navigationItemContentList,
                              modifier = Modifier
                                  .wrapContentWidth()
                                  .fillMaxHeight()
                                  .background(MaterialTheme.colorScheme.inverseOnSurface)
                                  .padding(dimensionResource(R.dimen.drawer_padding_content))
                          )
                      }
                  }
              ) {

      ...

   9. Run your app on the tablet mode to see the screen below:

   |fe811a212feefea5.png|


Improve UI elements for list-detail view

   Currently, your app displays a details pane on the home screen for the expanded screens.

   |e7c540e41fe1c3d.png|

   However, the screen contains extraneous elements, such as the back button, the subject
   header, and additional paddings, as it was designed for a standalone details screen. You
   can improve this next with a simple adjustment.

   To improve the details screen for expanded view, complete the following steps:

   10. In ``ReplyDetailsScreen.kt``, add an ``isFullScreen`` variable as a ``Boolean``
       parameter to the ``ReplyDetailsScreen`` composable.

   This addition lets you differentiate the composable when you use it as a standalone and
   when you use it inside the home screen.

   **ReplyDetailsScreen.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun ReplyDetailsScreen(
          replyUiState: ReplyUiState,
          onBackPressed: () -> Unit,
          modifier: Modifier = Modifier,
          isFullScreen: Boolean = false
      ) {
      ...

   11. Inside the ``ReplyDetailsScreen`` composable, wrap the ``ReplyDetailsScreenTopBar``
       composable with an ``if`` statement so that it only displays when the app is full
       screen.

   **ReplyDetailsScreen.kt**

   .. code:: prettyprint

      ...
          LazyColumn(
              modifier = modifier
                  .fillMaxSize()
                  .background(color = MaterialTheme.colorScheme.inverseOnSurface)
                  .padding(top = dimensionResource(R.dimen.detail_card_list_padding_top))
          ) {
              item {
                  if (isFullScreen) {
                      ReplyDetailsScreenTopBar(
                          onBackPressed,
                          replyUiState,
                          Modifier
                              .fillMaxWidth()
                              .padding(bottom = dimensionResource(R.dimen.detail_topbar_padding_bottom))
                          )
                      )
                  }

      ...

   You can now add padding. Padding required for the ``ReplyEmailDetailsCard`` composable
   differs depending on whether or not you use it as a full screen. When you use
   ``ReplyEmailDetailsCard`` with other composables in the expanded screen, there's
   additional padding from other composables.

   12. Pass the ``isFullScreen`` value to the ``ReplyEmailDetailsCard`` composable. Pass a
       modifier with a horizontal padding of
       ``R.dimen.detail_card_outer_padding_horizontal`` if the screen is fullscreen and
       pass a modifier with an end padding of
       ``R.dimen.detail_card_outer_padding_horizontal`` otherwise.

   **ReplyDetailsScreen.kt**

   .. code:: prettyprint

      ...
              item {
                  if (isFullScreen) {
                      ReplyDetailsScreenTopBar(
                          onBackPressed,
                          replyUiState,
                          Modifier
                              .fillMaxWidth()
                              .padding(bottom = dimensionResource(R.dimen.detail_topbar_padding_bottom))
                          )
                      )
                  }
                  ReplyEmailDetailsCard(
                      email = replyUiState.currentSelectedEmail,
                      mailboxType = replyUiState.currentMailbox,
                      isFullScreen = isFullScreen,
                      modifier = if (isFullScreen) {
                          Modifier.padding(horizontal = dimensionResource(R.dimen.detail_card_outer_padding_horizontal))
                      } else {
                          Modifier.padding(end = dimensionResource(R.dimen.detail_card_outer_padding_horizontal))
                      }
                  )
              }
      ...

   13. Add an ``isFullScreen`` value as a parameter to the ``ReplyEmailDetailsCard``
       composable.

   **ReplyDetailsScreen.kt**

   .. code:: prettyprint

      ...
      @OptIn(ExperimentalMaterial3Api::class)
      @Composable
      private fun ReplyEmailDetailsCard(
          email: Email,
          mailboxType: MailboxType,
          modifier: Modifier = Modifier,
          isFullScreen: Boolean = false
      ) {
      ...

   14. Inside the ``ReplyEmailDetailsCard`` composable, only show the email subject text
       when the app is not in full screen, as the full screen layout already displays the
       email subject as the header. If it is full screen, add a spacer with height of
       ``R.dimen.detail_content_padding_top``.

   **ReplyDetailsScreen.kt**

   .. code:: prettyprint

      ...
      Column(
          modifier = Modifier
              .fillMaxWidth()
              .padding(dimensionResource(R.dimen.detail_card_inner_padding))
      ) {
          DetailsScreenHeader(
              email,
              Modifier.fillMaxWidth()
          )
          if (isFullScreen) {
              Spacer(modifier = Modifier.height(dimensionResource(R.dimen.detail_content_padding_top)))
          } else {
              Text(
                  text = stringResource(email.subject),
                  style = MaterialTheme.typography.bodyMedium,
                  color = MaterialTheme.colorScheme.outline,
                  modifier = Modifier.padding(
                      top = dimensionResource(R.dimen.detail_content_padding_top),
                      bottom = dimensionResource(R.dimen.detail_expanded_subject_body_spacing)
                  ),
              )
          }
          Text(
              text = stringResource(email.body),
              style = MaterialTheme.typography.bodyLarge,
              color = MaterialTheme.colorScheme.onSurfaceVariant,
          )
          DetailsScreenButtonBar(mailboxType, displayToast)
      }

      ...

   15. In ``ReplyHomeScreen.kt``, inside the ``ReplyHomeScreen`` composable, pass a
       ``true`` value for the ``isFullScreen`` parameter when creating the
       ``ReplyDetailsScreen`` composable as a standalone.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
              } else {
                  ReplyDetailsScreen(
                      replyUiState = replyUiState,
                      isFullScreen = true,
                      onBackPressed = onDetailScreenBackPressed,
                      modifier = modifier
                  )
              }
      ...

   16. Run the app on the tablet mode and see the following layout:

   |833b3986a71a0b67.png|


Adjust back handling for list-detail view

   With the expanded screens, you do not need to navigate to the ``ReplyDetailsScreen`` at
   all. Instead, you want the app to close when the user selects the back button. As such,
   we should adjust the back handler.

   Modify the back handler by passing the ``activity.finish()`` function as the
   ``onBackPressed`` parameter of the ``ReplyDetailsScreen`` composable inside the
   ``ReplyListAndDetailContent`` composable.

   **ReplyHomeContent.kt**

   .. code:: prettyprint

      ...
      import android.app.Activity
      import androidx.compose.ui.platform.LocalContext
      ...
              val activity = LocalContext.current as Activity
              ReplyDetailsScreen(
                  replyUiState = replyUiState,
                  modifier = Modifier.weight(1f),
                  onBackPressed = { activity.finish() }
              )
      ...



4. Verify for different screen sizes
--------------------------------------------------------------------------------


Large screen app quality guideline

   To build a great and consistent experience for Android users, it is important to build
   and test your app with quality in mind. You can refer to the `Core app quality guidelines <https://developer.android.google.cn/docs/quality-guidelines/core-app-quality>`__
   to determine how to improve your app quality.

   To build a great quality app for all form factors, review the `Large screen app quality guidelines <https://developer.android.google.cn/docs/quality-guidelines/large-screen-app-quality>`__.
   Your app must also meet the `Tier 3 - Large screen ready requirements <https://developer.android.google.cn/docs/quality-guidelines/large-screen-app-quality#large_screen_ready>`__.


Manually test your app for large screen readiness

   The app quality guidelines provide test device recommendations and procedures to check
   your app quality. Let's take a look at a test example relevant to the Reply app.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/c7a575b570c61ae9.png

      Large screen app quality description for configuration and continuity.

   The above app quality guideline requires the app to retain or restore its state after
   configuration changes. The guideline also provides instructions about how to test apps,
   as shown in the following figure:

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/2ff4fa3be80cdeb.png

      The large screen app quality test steps for configuration and continuity.

   To manually test the Reply app for configuration continuity, complete the following
   steps:

   1. Run the Reply app on a medium-sized device or, if you are using the resizable
      emulator, in unfolded foldable mode.
   2. Ensure that **Auto rotate** on the emulator is set to **on**.

   |5a1c3a4cb4fc0192.png|

   3. Scroll down the email list.

   |7ce0887b5b38a1f0.png|

   4. Click on an email card. For example, open the email from **Ali**.

   |16d7ca9c17206bf8.png|

   5. Rotate the device to check that the selected email is still consistent with the email
      selected in portrait orientation. In this example, an email from Ali is still shown.

   |d078601f2cc50341.png|

   6. Rotate back to portrait orientation to check that the app still displays the same
      email.

   |16d7ca9c17206bf8.png|



5. Add automated test for adaptive apps
--------------------------------------------------------------------------------


Configure test for the compact screen size

   In the `Test the Cupcake App <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-test-cupcake>`__
   codelab, you learned to create UI tests. Now let's learn how to create specific tests
   for different screen sizes.

   In the Reply app, you use different navigation elements for different screen sizes. For
   example, you expect to see a permanent navigation drawer when the user sees the expanded
   screen. It is useful to create tests to verify the existence of various navigation
   elements, such as the bottom navigation, navigation rail, and navigation drawer for
   different screen sizes.

   To create a test to verify the existence of a bottom navigation element in a compact
   screen, complete the following steps:

   1. In the test directory, create a new Kotlin class called ``ReplyAppTest.kt``.
   2. In ``ReplyAppTest`` class, create a test rule using ``createAndroidComposeRule`` and
      passing ``ComponentActivity`` as the type parameter. ``ComponentActivity`` is used to
      access an empty activity instead of the ``MainActivity``.

   **ReplyAppTest.kt**

   .. code:: prettyprint

      ...
      class ReplyAppTest {

          @get:Rule
          val composeTestRule = createAndroidComposeRule<ComponentActivity>()
      ...

   To differentiate between navigation elements in the screens, add a ``testTag`` in the
   ``ReplyBottomNavigationBar`` composable.

   3. Define a string resource for **Navigation Bottom.**

   **strings.xml**

   .. code:: prettyprint

      ...
      <resources>
      ...
          <string name="navigation_bottom">Navigation Bottom</string>
      ...
      </resources>

   4. Add the string name as the ``testTag`` argument for the ``Modifier``'s ``testTag``
      method in the ``ReplyBottomNavigationBar`` composable.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
      val bottomNavigationContentDescription = stringResource(R.string.navigation_bottom)
      ReplyBottomNavigationBar(
          ...
          modifier = Modifier
              .fillMaxWidth()
              .testTag(bottomNavigationContentDescription)
      )
      ...

   5. In the ``ReplyAppTest`` class, create a test function to test for a compact size
      screen. Set the content of the ``composeTestRule`` with the ``ReplyApp`` composable
      and pass the ``WindowWidthSizeClass.Compact`` as the ``windowSize`` argument.

   **Note:** Adding a composable that accepts ``WindowWidthSizeClass`` as an argument is a
   good practice to make testable code.

   **ReplyAppTest.kt**

   .. code:: prettyprint

      ...
          @Test
          fun compactDevice_verifyUsingBottomNavigation() {
              // Set up compact window
              composeTestRule.setContent {
                  ReplyApp(
                      windowSize = WindowWidthSizeClass.Compact
                  )
              }
          }

   6. Assert that the bottom navigation element exists with the test tag. Call the
      extension function ``onNodeWithTagForStringId`` on the ``composeTestRule`` and pass
      the navigation bottom string and call the ``assertExists()`` method.

   **ReplyAppTest.kt**

   .. code:: prettyprint

      ...
          @Test
          fun compactDevice_verifyUsingBottomNavigation() {
              // Set up compact window
              composeTestRule.setContent {
                  ReplyApp(
                      windowSize = WindowWidthSizeClass.Compact
                  )
              }
              // Bottom navigation is displayed
              composeTestRule.onNodeWithTagForStringId(
                  R.string.navigation_bottom
              ).assertExists()
          }

   7. Run the test and verify that it passes.


Configure test for the medium and expanded screen sizes

   Now that you successfully created a test for the compact screen, let's create
   corresponding tests for medium and expanded screens.

   To create tests to verify the existence of a navigation rail and permanent navigation
   drawer for medium and expanded screens, complete the following steps:

   1. Define a string resource for the **Navigation Rail** to be used as a test tag later.

   **strings.xml**

   .. code:: prettyprint

      ...
      <resources>
      ...
          <string name="navigation_rail">Navigation Rail</string>
      ...
      </resources>

   2. Pass the string as the test tag through the ``Modifier`` in the
      ``PermanentNavigationDrawer`` composable.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
          val navigationDrawerContentDescription = stringResource(R.string.navigation_drawer)
              PermanentNavigationDrawer(
      ...
      modifier = Modifier.testTag(navigationDrawerContentDescription)
      )
      ...

   3. Pass the string as the test tag through the ``Modifier`` in ``ReplyNavigationRail``
      composable.

   **ReplyHomeScreen.kt**

   .. code:: prettyprint

      ...
      val navigationRailContentDescription = stringResource(R.string.navigation_rail)
      ReplyNavigationRail(
          ...
          modifier = Modifier
              .testTag(navigationRailContentDescription)
      )
      ...

   4. Add a test to verify that a navigation rail element exists in the medium screens.

   **ReplyAppTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun mediumDevice_verifyUsingNavigationRail() {
          // Set up medium window
          composeTestRule.setContent {
              ReplyApp(
                  windowSize = WindowWidthSizeClass.Medium
              )
          }
          // Navigation rail is displayed
          composeTestRule.onNodeWithTagForStringId(
              R.string.navigation_rail
          ).assertExists()
      }

   5. Add a test to verify that a navigation drawer element exists in the expanded screens.

   **ReplyAppTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun expandedDevice_verifyUsingNavigationDrawer() {
          // Set up expanded window
          composeTestRule.setContent {
              ReplyApp(
                  windowSize = WindowWidthSizeClass.Expanded
              )
          }
          // Navigation drawer is displayed
          composeTestRule.onNodeWithTagForStringId(
              R.string.navigation_drawer
          ).assertExists()
      }

   6. Use a tablet emulator or a resizable emulator in Tablet mode to run the test.
   7. Run all the tests and verify that they pass.


Test for a configuration change in a compact screen

   A configuration change is a common occurrence that happens in your app lifecycle. For
   example, when you change orientation from portrait to landscape, a configuration change
   occurs. When a configuration change occurs, it is important to test that your app
   retains its state. Next, you'll create tests, which simulate a configuration change, to
   test that your app retains its state in a compact screen.

   To test for a configuration change in the compact screen:

   1. In the test directory, create a new Kotlin class called
      ``ReplyAppStateRestorationTest.kt``.
   2. In the ``ReplyAppStateRestorationTest`` class, create a test rule using
      ``createAndroidComposeRule`` and passing ``ComponentActivity`` as the type parameter.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      class ReplyAppStateRestorationTest {

          /**
           * Note: To access to an empty activity, the code uses ComponentActivity instead of
           * MainActivity.
           */
          @get:Rule
          val composeTestRule = createAndroidComposeRule<ComponentActivity>()
      }
      ...

   3. Create a test function to verify that an email is still selected in the compact
      screen after a configuration change.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun compactDevice_selectedEmailEmailRetained_afterConfigChange() {

      }
      ...

   To test for a configuration change, you need to use ``StateRestorationTester``.

   4. Setup ``stateRestorationTester`` by passing the ``composeTestRule`` as an argument to
      ``StateRestorationTester``.
   5. Use ``setContent()`` with the ``ReplyApp`` composable and pass the
      ``WindowWidthSizeClass.Compact`` as the ``windowSize`` argument.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun compactDevice_selectedEmailEmailRetained_afterConfigChange() {
          // Setup compact window
          val stateRestorationTester = StateRestorationTester(composeTestRule)
          stateRestorationTester.setContent { ReplyApp(windowSize = WindowWidthSizeClass.Compact) }

      }
      ...

   6. Verify that a third email is displayed in the app. Use the ``assertIsDisplayed()``
      method on the ``composeTestRule``, which looks for the text of the third email.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun compactDevice_selectedEmailEmailRetained_afterConfigChange() {
          // Setup compact window
          val stateRestorationTester = StateRestorationTester(composeTestRule)
          stateRestorationTester.setContent { ReplyApp(windowSize = WindowWidthSizeClass.Compact) }

          // Given third email is displayed
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)
          ).assertIsDisplayed()
      }
      ...

   7. Navigate to the email's details screen by clicking on the email subject. Use the
      ``performClick()`` method to navigate.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun compactDevice_selectedEmailEmailRetained_afterConfigChange() {
          // Setup compact window
          val stateRestorationTester = StateRestorationTester(composeTestRule)
          stateRestorationTester.setContent { ReplyApp(windowSize = WindowWidthSizeClass.Compact) }

          // Given third email is displayed
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)
          ).assertIsDisplayed()

          // Open detailed page
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].subject)
          ).performClick()
      }
      ...

   8. Verify that the third email is displayed in the details screen. Assert the existence
      of the back button to confirm that the app is in the details screen, and verify that
      the third email's text is displayed.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun compactDevice_selectedEmailEmailRetained_afterConfigChange() {
          ...
          // Open detailed page
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].subject)
          ).performClick()

          // Verify that it shows the detailed screen for the correct email
          composeTestRule.onNodeWithContentDescriptionForStringId(
              R.string.navigation_back
          ).assertExists()
          composeTestRule.onNodeWithText(
      }
      ...

   9. Simulate a config change using
      ``stateRestorationTester.emulateSavedInstanceStateRestore()``.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun compactDevice_selectedEmailEmailRetained_afterConfigChange() {
          ...
          // Verify that it shows the detailed screen for the correct email
          composeTestRule.onNodeWithContentDescriptionForStringId(
              R.string.navigation_back
          ).assertExists()
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)
          ).assertExists()

          // Simulate a config change
          stateRestorationTester.emulateSavedInstanceStateRestore()
      }
      ...

   10. Verify again that the third email is displayed in the details screen. Assert the
       existence of the back button to confirm that the app is in the details screen, and
       verify that the third email's text is displayed.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun compactDevice_selectedEmailEmailRetained_afterConfigChange() {
          // Setup compact window
          val stateRestorationTester = StateRestorationTester(composeTestRule)
          stateRestorationTester.setContent { ReplyApp(windowSize = WindowWidthSizeClass.Compact) }

          // Given third email is displayed
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)
          ).assertIsDisplayed()

          // Open detailed page
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].subject)
          ).performClick()

          // Verify that it shows the detailed screen for the correct email
          composeTestRule.onNodeWithContentDescriptionForStringId(
              R.string.navigation_back
          ).assertExists()
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)
          ).assertExists()

          // Simulate a config change
          stateRestorationTester.emulateSavedInstanceStateRestore()

          // Verify that it still shows the detailed screen for the same email
          composeTestRule.onNodeWithContentDescriptionForStringId(
              R.string.navigation_back
          ).assertExists()
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)
          ).assertExists()
      }

      ...

   11. Run the test with a phone emulator or resizable emulator in Phone mode.
   12. Verify that the test passes.


Test for a configuration change in the expanded screen

   To test for a configuration change in the expanded screen by simulating a configuration
   change and passing the appropriate WindowWidthSizeClass, complete the following steps:

   1. Create a test function to verify that an email is still selected in the details
      screen after a configuration change.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun expandedDevice_selectedEmailEmailRetained_afterConfigChange() {

      }
      ...

   To test for a configuration change, you need to use ``StateRestorationTester``.

   2. Setup ``stateRestorationTester`` by passing the ``composeTestRule`` as an argument to
      ``StateRestorationTester``.
   3. Use ``setContent()`` with the ``ReplyApp`` composable and pass
      ``WindowWidthSizeClass.Expanded`` as the ``windowSize`` argument.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun expandedDevice_selectedEmailEmailRetained_afterConfigChange() {
          // Setup expanded window
          val stateRestorationTester = StateRestorationTester(composeTestRule)
          stateRestorationTester.setContent { ReplyApp(windowSize = WindowWidthSizeClass.Expanded) }
      }
      ...

   4. Verify that a third email is displayed in the app. Use the ``assertIsDisplayed()``
      method on the ``composeTestRule``, which looks for the text of the third email.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun expandedDevice_selectedEmailEmailRetained_afterConfigChange() {
          // Setup expanded window
          val stateRestorationTester = StateRestorationTester(composeTestRule)
          stateRestorationTester.setContent { ReplyApp(windowSize = WindowWidthSizeClass.Expanded) }

          // Given third email is displayed
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)
          ).assertIsDisplayed()
      }
      ...

   5. Select the third email on the details screen. Use the ``performClick()`` method to
      select the email.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun expandedDevice_selectedEmailEmailRetained_afterConfigChange() {
          // Setup expanded window
          val stateRestorationTester = StateRestorationTester(composeTestRule)
          stateRestorationTester.setContent { ReplyApp(windowSize = WindowWidthSizeClass.Expanded) }

          // Given third email is displayed
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)
          ).assertIsDisplayed()

          // Select third email
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].subject)
          ).performClick()
          ...
      }

      ...

   6. Verify that the details screen displays the third email by using the ``testTag`` on
      the details screen and looking for text on its children. This approach makes sure
      that you can find the text in the details section and not in the email list.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...

      @Test
      fun expandedDevice_selectedEmailEmailRetained_afterConfigChange() {
          ...
          // Select third email
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].subject)
          ).performClick()

          // Verify that third email is displayed on the details screen
          composeTestRule.onNodeWithTagForStringId(R.string.details_screen).onChildren()
              .assertAny(hasAnyDescendant(hasText(
                  composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)))
              )
      ...
      }

      ...

   7. Simulate a configuration change using
      ``stateRestorationTester.emulateSavedInstanceStateRestore()``.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun expandedDevice_selectedEmailEmailRetained_afterConfigChange() {
          ...
          // Verify that third email is displayed on the details screen
          composeTestRule.onNodeWithTagForStringId(R.string.details_screen).onChildren()
              .assertAny(hasAnyDescendant(hasText(
                  composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)))
              )

          // Simulate a config change
          stateRestorationTester.emulateSavedInstanceStateRestore()
          ...
      }
      ...

   8. Verify again that the details screen displays the third email after a configuration
      change.

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
      @Test
      fun expandedDevice_selectedEmailEmailRetained_afterConfigChange() {
          // Setup expanded window
          val stateRestorationTester = StateRestorationTester(composeTestRule)
          stateRestorationTester.setContent { ReplyApp(windowSize = WindowWidthSizeClass.Expanded) }

          // Given third email is displayed
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)
          ).assertIsDisplayed()

          // Select third email
          composeTestRule.onNodeWithText(
              composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].subject)
          ).performClick()

          // Verify that third email is displayed on the details screen
          composeTestRule.onNodeWithTagForStringId(R.string.details_screen).onChildren()
              .assertAny(hasAnyDescendant(hasText(
                  composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)))
              )

          // Simulate a config change
          stateRestorationTester.emulateSavedInstanceStateRestore()

          // Verify that third email is still displayed on the details screen
          composeTestRule.onNodeWithTagForStringId(R.string.details_screen).onChildren()
              .assertAny(hasAnyDescendant(hasText(
                  composeTestRule.activity.getString(LocalEmailsDataProvider.allEmails[2].body)))
              )
      }
      ...

   9.  Run the test with a tablet emulator or resizable emulator in Tablet mode.
   10. Verify that the test passes.


Use annotations to group test for different screen sizes

   You might realize from the previous tests that some tests fail when they are run on
   devices with an incompatible screen size. While you can run the test one by one using an
   appropriate device, this approach might not scale when you have many test cases.

   To solve this problem, you can create annotations to denote the screen sizes that the
   test can run on, and configure the annotated test for the appropriate devices.

   To run a test based on screen sizes, complete the following steps:

   1. In the test directory, create ``TestAnnotations.kt``, which contains three annotation
      classes: ``TestCompactWidth``, ``TestMediumWidth``, ``TestExpandedWidth``.

   **TestAnnotations.kt**

   .. code:: prettyprint

      ...
      annotation class TestCompactWidth
      annotation class TestMediumWidth
      annotation class TestExpandedWidth
      ...

   2. Use the annotations on the test functions for compact tests by putting the
      ``TestCompactWidth`` annotation after the test annotation for a compact test in
      ``ReplyAppTest`` and ``ReplyAppStateRestorationTest``.

   **ReplyAppTest.kt**

   .. code:: prettyprint

      ...
          @Test
          @TestCompactWidth
          fun compactDevice_verifyUsingBottomNavigation() {
      ...

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
          @Test
          @TestCompactWidth
          fun compactDevice_selectedEmailEmailRetained_afterConfigChange() {

      ...

   3. Use the annotations on the test functions for medium tests by putting the
      ``TestMediumWidth`` annotation after the test annotation for a medium test in
      ``ReplyAppTest``.

   **ReplyAppTest.kt**

   .. code:: prettyprint

      ...
          @Test
          @TestMediumWidth
          fun mediumDevice_verifyUsingNavigationRail() {
      ...

   4. Use the annotations on the test functions for expanded tests by putting the
      ``TestExpandedWidth`` annotation after the test annotation for an expanded test in
      ``ReplyAppTest`` and ``ReplyAppStateRestorationTest``.

   **ReplyAppTest.kt**

   .. code:: prettyprint

      ...
          @Test
          @TestExpandedWidth
          fun expandedDevice_verifyUsingNavigationDrawer() {
      ...

   **ReplyAppStateRestorationTest.kt**

   .. code:: prettyprint

      ...
          @Test
          @TestExpandedWidth
          fun expandedDevice_selectedEmailEmailRetained_afterConfigChange() {
      ...

   To ensure success, configure the test to only run tests that are annotated with
   ``TestCompactWidth``.

   5. In the Android Studio, select **Run** > **Edit Configurations...**
      |7be537f5faa1a61a.png|
   6. Rename the test as **Compact tests**, and select to run the test **All in Package**.

   |f70b74bc2e6674f1.png|

   7. Click the three dots (**...**) to the right of the **Instrumentation arguments**
      field.
   8. Click the plus (``+``) button and add the extra parameters: **annotation** with the
      value **com.example.reply.test.TestCompactWidth**.

   |cf1ef9b80a1df8aa.png|

   9.  Run the tests with a compact emulator.
   10. Check that only compact tests were run.

   |204ed40031f8615a.png|

   11. Repeat the steps for medium and expanded screens.



6. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, use the following git command:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-reply-app.git

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-reply-app/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the downloaded repository.

   If you want to see the solution code, 
   `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-reply-app>`__.



7. Conclusion
--------------------------------------------------------------------------------

   Congratulations! You made the Reply app adaptive for all screen sizes by implementing an
   adaptive layout. You also learned to speed up your development using previews and
   maintaining your app quality using various testing methods.

   Don't forget to share your work on social media with #AndroidBasics!


**Learn more**

   -  `Build adaptive layouts <https://developer.android.google.cn/develop/ui/compose/layouts/adaptive/>`__
   -  `Support different screen sizes <https://developer.android.google.cn/develop/ui/compose/layouts/adaptive/support-different-screen-sizes>`__
   -  `Design for large screens <https://m3.material.io/foundations/adaptive-design/large-screens/layout-anatomy>`__
   -  `Jetnews for every screen <https://medium.com/androiddevelopers/jetnews-for-every-screen-4d8e7927752>`__
   -  `Multipreview annotations <https://developer.android.google.cn/jetpack/compose/tooling#preview-multipreview>`__

.. |5577b1d0fe306e33.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/5577b1d0fe306e33.png
.. |f624e771b76bbc2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/f624e771b76bbc2.png
.. |56cfa13ef31d0b59.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/56cfa13ef31d0b59.png
.. |fe811a212feefea5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/fe811a212feefea5.png
.. |e7c540e41fe1c3d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/e7c540e41fe1c3d.png
.. |833b3986a71a0b67.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/833b3986a71a0b67.png
.. |5a1c3a4cb4fc0192.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/5a1c3a4cb4fc0192.png
.. |7ce0887b5b38a1f0.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/7ce0887b5b38a1f0.png
.. |16d7ca9c17206bf8.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/16d7ca9c17206bf8.png
.. |d078601f2cc50341.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/d078601f2cc50341.png
.. |7be537f5faa1a61a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/7be537f5faa1a61a.png
.. |f70b74bc2e6674f1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/f70b74bc2e6674f1.png
.. |cf1ef9b80a1df8aa.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/cf1ef9b80a1df8aa.png
.. |204ed40031f8615a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens/img/204ed40031f8615a.png


ğŸš€ Practice: Build Sports app
=============================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-sports-app 


1. Before you begin
--------------------------------------------------------------------------------

   Congratulations! In this pathway, you learned how to make your app adaptive by using the
   ``WindowWidthSize`` class and the canonical layout. Now it is time to put what you learned into
   practice.

   In this practice set, you will build on the concepts you learned in this pathway by creating a
   Sports app. The starter app is fully functional for a mobile layout. Your task is to make it
   adaptive for large screens.

   The solution code is available at the end, but try to solve the exercises before you check it.
   Work through the problems at a pace that's comfortable for you. There are durations listed, but
   you do not have to adhere to them because they're only estimates. You're encouraged to take as
   much time as you need to solve each problem thoughtfully.


Prerequisites

   -  Complete Android Basics in Compose coursework through the `Build an adaptive app with dynamic navigation <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-navigation-for-large-screens#0>`__
      and `Build an adaptive app with adaptive layout <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens#0>`__
      codelabs.


What you'll need

   -  A computer with internet access and Android Studio installed
   -  Access to GitHub


What you'll build

   A Sports app that adapts to a large screen. The finished app looks like the following image:

   |1ce365f97570965e.png|


2. Get started
--------------------------------------------------------------------------------


Download the starter code

   In Android Studio, open the ``basic-android-kotlin-compose-training-sports`` folder.

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-sports/tree/starter

   **Branch name with starter code:** ``starter``


3. Plan to adapt Sports app for large screens
--------------------------------------------------------------------------------

   To adapt the Sports app for large screens, you first want to establish the type of layout that
   best displays the app on large screens.

   1. Start reviewing the current layouts available on the compact screen size. There are two
      screens â€” namely the list screen, which corresponds to the ``SportsList`` composable, and the
      detail screen, which corresponds to the ``SportsDetail`` composable.

   ====================== ======================
   |87ecbf0695393421.png| |6021d2078a2225ad.png|
   ====================== ======================

   2. Review `the canonical layout <https://m3.material.io/foundations/adaptive-design/canonical-layouts>`__ 
      to determine the layout that best fits the Sports app use case.
   3. Sketch out a possible expanded screen layout. Use either a simple visual design software or a
      piece of paper to visualize how the screens fit together in the expanded layout.

   |bb59e5ec7da56f7a.png|


4. Create the expanded screen in code
--------------------------------------------------------------------------------

   Now that you have a clear view of how the expanded layout looks, let's translate that into code.

   1. Create a composable for the expanded screen that shows both the list and the details screen.
      You can name it ``SportsListAndDetails`` and place it in the ``SportsScreens.kt`` file.
   2. Create a composable preview to simplify verification of the UI for the
      ``SportsListAndDetails`` composable.

   |678504d0ec535896.png|

   3. Ensure that the back button behavior is appropriate for the expanded screen. When the user
      presses the back button, you want them to exit the app when the main screen appears. You can
      change this behavior by passing the appropriate lambda to the ``SportsDetails`` composable.
      **Hint**: you can have access to the app's ``Activity`` from
      ``(LocalContext.current as Activity)``.


5. Make app change to different layout based on window size
--------------------------------------------------------------------------------

   To add the expanded screen composable to the app, complete the following tasks:

   1. Add ``androidx.compose.material3:material3-window-size-class`` to the app's
      ``build.gradle.kts``.
   2. Calculate ``windowSizeClass`` in the ``MainActivity`` and pass the ``widthSizeClass`` to the
      ``SportsApp`` composable.
   3. Create a new directory named ``utils`` and create a new file name ``WindowStateUtils.kt``.
   4. Add an ``enum`` class in ``WindowStateUtils`` to denote two different ``contentType``. You can
      name them ``ListOnly`` and ``ListAndDetail`` types.
   5. In the ``SportsApp`` composable, determine the ``contentType``, based on the
      ``widthSizeClass``.
   6. Display the ``SportsListAndDetails`` composable when ``contentType`` is ``ListAndDetail`` and
      keep the previous behavior when the contentType is ``ListOnly``.
   7. For the ``SportsAppBar`` composable, change the behavior so that the back button doesn't
      appear and the app bar shows **Sports** when the screen expands in the list page.
   8. Verify the UI and navigation capabilities for both compact and expanded screens using the
      resizable emulator.


6. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use this git command:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-sports.git

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-sports/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the downloaded repository.

   If you want to see the solution code, 
   `view it on GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-sports/tree/main>`__.


.. |1ce365f97570965e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-sports-app/img/1ce365f97570965e.png
.. |87ecbf0695393421.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-sports-app/img/87ecbf0695393421.png
.. |6021d2078a2225ad.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-sports-app/img/6021d2078a2225ad.png
.. |bb59e5ec7da56f7a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-sports-app/img/bb59e5ec7da56f7a.png
.. |678504d0ec535896.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-sports-app/img/678504d0ec535896.png


ğŸš€ Project: Create a My City app
================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-my-city 


1. Before you begin
--------------------------------------------------------------------------------

   In this unit, you learned:

   -  How to build an app with multiple screens
   -  How to build an adaptive layout so that your app works well across a range of screen sizes
   -  The importance of app architecture
   -  How to ensure your app adheres to the activity lifecycle without wasting unnecessary resources
   -  How to preserve user state across device configuration changes

   That was a lot to learn!

   Following the codelab steps helped you learn these new concepts to a certain degree, but you will
   gain a deeper level of understanding by applying your knowledge and skills to a new app.

   You will use your knowledge when you run into new situations, bugs, or times when you need to
   design a solution yourself. You can always refer back to previous apps and codelabs to quickly
   remind yourself what you learned and put that into action.

   You will learn more if you try to tackle these problems on your own, which will more closely
   resemble what the "real world" is like as a developer. It's a skill in itself to know how to
   break down a problem, troubleshoot it, and search for resources to find a solution. For that
   reason, you're encouraged to work on these projects at the end of each unit. With this motivation
   and context in mind, check out the following prompt for the Unit 4 project.


Prerequisites

   -  Ability to create and run a project in Android Studio
   -  Familiar with the basics of the Kotlin programming language
   -  Familiar with how to create UI layouts in Compose, and how to make them adaptive to different
      screen sizes
   -  Ability to add and implement the Jetpack Navigation component with Compose
   -  Ability to implement an app with the recommended app architecture using ViewModels, UiState,
      and Jetpack Navigation


What you'll build

   -  An Android app that displays recommendations for things to do and places to visit within the
      city you live in


What you'll need

   -  A computer with Android Studio installed


2. Overview
--------------------------------------------------------------------------------

   Congratulations on reaching the end of Unit 4!

   To help reinforce what you learned in this unit, you will build an app that contains lists of
   recommendations for different activities and places to visit within a city of your choice.

   This app should:

   -  Contain multiple screens; for example, each screen can display a different category of
      recommendations.
   -  Use the Jetpack Navigation component to enable users to navigate through your app.
   -  Maintain a clear distinction between the UI layer and the data layer.
   -  Use a ``ViewModel`` and make updates to the UI from the view model using the unidirectional data
      flow (UDF) pattern.
   -  Use adaptive layouts that account for all different screen sizes.
   -  Follow Material Design guidelines for `adaptive design <https://m3.material.io/foundations/adaptive-design/overview>`__ 
      and `navigation <https://material.io/design/navigation/understanding-navigation.html>`__.


3. Gather the content for the app
--------------------------------------------------------------------------------

   Gather the content for your app and write it down on a piece of paper or type it into a document.
   It's easier to organize the app content before you start coding your app.

   Decide which city or region you want to use for the app. We suggest you use your favorite city or
   the city you live in. You can also choose a wider region that includes multiple cities, if you
   prefer.

   Choose an app name based on the city you selected. Even though this project is called the **My
   City app**, you are encouraged to customize the app name to be specific to your city.

   Create lists for different categories of recommendations for your city. For example, you can
   create a list of recommended:

   -  Coffee shops
   -  Restaurants
   -  Kid-friendly places
   -  Parks
   -  Shopping centers

   Your app should contain several lists of recommendations from different categories. Try to create
   at least 3 to 5 recommendations for each category so the screen doesn't look too empty.

   If you want to add photos to your app, collect the photos at this stage.

   **Warning:** Don't use assets that you don't own or have appropriate rights to use for your app.


4. Sketch the app screens
--------------------------------------------------------------------------------

   On a piece of paper, sketch out what the different screens of the app will look like. You can
   draw arrows between the screens and add buttons to the layout to show how the user navigates from
   one screen to another.

   This sketch does not need to be very detailed or polished. The main purpose is to develop an idea
   for the destinations on the navigation graph and the overall layout of the app. These drawings
   can help you with the next step.

   If you need help sketching out the app and navigation flow, view the following example:

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-my-city/img/1bfad71252c639eb.jpeg

      First screen lists categories. When a category is selected, the next screen shows
      recommendations on that category. When a recommendation is selected, more details details are
      shown in the details screen.

   Can you use this example to sketch the app and navigation flow for larger screens? If you need
   more help, feel free to check the `codelab where you built the Reply app.<https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens>`__


5. Plan the steps
--------------------------------------------------------------------------------

   Write out the general steps for how to build the app that you sketched.

   For example:

   -  Create the data class for a recommended place.
   -  Create the screen layout for the recommended coffee shops.
   -  Create the navigation graph for all screens.

   These notes can help you determine the part of the app you want to tackle first.

   To become even more organized, you can also number the steps in the order you plan to complete
   them. If one step requires you to complete another step first, then you need to sequence the
   steps appropriately.


6. Implement the app
--------------------------------------------------------------------------------

   Now that you have a high-level plan for the app, you can start coding the app!

   Create the project and complete each task one-by-one. Be patient with yourself if a task takes a
   long time. It is normal to have a steep learning curve for building an app of this complexity.

   Tips:

   -  Review previous codelabs and the GitHub code repos for reference.
   -  Look at other `Compose sample apps <https://github.com/android/compose-samples>`__ or the 
      `Now in Android app <https://github.com/android/nowinandroid>`__. Note that these apps are larger
      and more complex than the apps you have built so far.
   -  If you encounter a bug in the app and can't figure out how to fix it, consider using the
      Android Studio `debugging tools <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-intro-debugger?continue=https%3A%2F%2Fdeveloper.android.com%2Fcourses%2Fpathways%2Fandroid-basics-compose-unit-2-pathway-2%23codelab-https%3A%2F%2Fdeveloper.android.com%2Fcodelabs%2Fbasic-android-kotlin-compose-intro-debugger#0>`__.


7. Get feedback from a user (Optional)
--------------------------------------------------------------------------------

   This section is recommended as a good learning experience. When you have a working version of
   your app, show it to a potential user and get feedback from them.

   If you own an Android device, install the app on the device. Alternatively, you can use an
   emulator, but keep in mind that the user may not be familiar with what an emulator is and how it
   relates to a real device.

   Try not to give the user any guidance or instructions. Instead, focus on observing the user and
   asking questions to understand how users might use the app for the first time. Pay attention to
   how they interact with the app and whether navigating through the app seems intuitive or
   confusing to them. Can they use the app as you expected, or are they having issues figuring out
   how to use the app?

   Make sure they navigate through every screen and interact with each part of the app. You can ask
   them other questions, including the following examples:

   -  What is your first impression of this app?
   -  What do you like about this app?
   -  Do you have any suggestions for how I can improve this app??

   Consider whether you want to incorporate the user's suggestions into your app to create a better
   experience for your users.


8. Test the app with Resizable Emulator
--------------------------------------------------------------------------------

   It is a good idea to test what you built on a `Resizable Emulator <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-adaptive-content-for-large-screens>`__
   to see if the app works as expected on different screen sizes. Make sure to change the emulator
   size and try out the different device options as shown in the following image.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-my-city/img/f2dd70c62ec89f91.png

      You can change the device options of a resizable emulator from the dropdown menu.


9. Good luck!
--------------------------------------------------------------------------------

   Good luck creating your app! When you complete the app, share it on social media using the
   hashtag #AndroidBasics. We're excited to see how your app turns out and to hear about your
   recommendations!


â­ Practice: Build Amphibians app
==================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-amphibians-app


1. Before you begin
-------------------


Introduction

   In this unit, you learned how to take your app to the next level by retrieving data from the
   internet. Your app can now show the latest data available from the server and is not restricted
   to what was statically available when you opened the app. This is very important functionality in
   most of the real world applications.

   In this practice set, you will take the concepts you learned and create an Amphibians app. This
   app will retrieve amphibian data from the internet and display it in a scrolling list.

   The solution code is available at the end. To make the most of this learning experience, try to
   implement and troubleshoot as much as you can before looking at the provided solution code. It is
   during this hands-on time that you will learn the most.


Prerequisites

   -  Android Basics with Compose coursework through the `Load and display images from the internet <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-load-images>`__
      codelab.


What you'll need

   -  A computer with internet access and Android Studio installed.


What you'll build

   In this practice set, you will build an app to display a list of amphibians, along with their
   details and image. The data is retrieved from the internet by making a network request and
   contains each amphibian's name, type, description, and image URL.

   The amphibian JSON data is hosted at
   https://android-kotlin-fun-mars-server.appspot.com/amphibians.

   The provided solution code displays the following UI design:

   |b0e225571b16ffb.png|

   The following sections provide the general steps to create the app. You are not required to
   follow them, but they are provided to help guide you along the way.


2. Plan the app
---------------


   Before you begin coding, take some time to sketch out the different elements for your app and how
   they connect together.

   Doing this preparation work helps identify what you need to do, might indicate where you can run
   into problems, and helps you think about ways to resolve issues.


3. Create a new project
-----------------------


   Start with a new project in Android Studio:

   1. Open Android Studio and select **New Project**.
   2. Under Templates, select **Phone and Tablet**.
   3. Select **Empty Activity** and click **Next**.
   4. Change the name to **Amphibians**.
   5. Click **Finish**.

   You are now ready to begin coding!


4. Set up dependencies
----------------------


   The app uses Retrofit for network requests, Coil for image loading, and the kotlinx.serialization
   library for parsing the JSON returned by the Amphibians API.

   Add their dependencies to ``app/build.gradle.kts``.


5. Create UI layer
------------------


   It is recommended that you follow `Android app architecture <https://developer.android.google.cn/topic/architecture>`__ 
   best practices and create a UI layer for this app.

   This layer contains the ``ViewModel`` and composable functions that display the ``UiState``
   coming from the ``ViewModel`` on the screen. The ``ViewModel`` is in charge of exposing the
   screen UI state, and handling the business logic in the UI layer and calling the business logic
   from other layers of the hierarchy.

   The `UI layer <https://developer.android.google.cn/topic/architecture/ui-layer>`__ also contains
   the visual elements that your users see and interact with. This layer is where you decide how the
   various elements go together to create the UI you envision. You are deciding on the colors,
   fonts, and how you display images.


6. Create data layer
--------------------


   The data layer is responsible for retrieving the amphibian data from the API.

   You probably want to include a data class for the amphibian data, a repository to manage the
   data, and a data source class to retrieve the data from the network.

   If you need some help making the network calls, you can refer to `Web services and Retrofit <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-getting-data-internet#4>`__
   from the `Get data from the internet <https://www.google.com/url?sa=D&q=https%3A%2F%2Fdeveloper.android.com%2Fcodelabs%2Fbasic-android-kotlin-compose-getting-data-internet>`__
   codelab.

   For help parsing the network response, refer to `Parse the JSON response with kotlinx.serialization <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-getting-data-internet#7>`__.

   For loading images with Coil, you can check out the `official documentation <https://coil-kt.github.io/coil/>`__ 
   or refer back to the `Display a downloaded image <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-load-images#2>`__
   section of the `Load and display images from the Internet <https://www.google.com/url?sa=D&q=https%3A%2F%2Fdeveloper.android.com%2Fcodelabs%2Fbasic-android-kotlin-compose-load-images>`__
   codelab.


7. Implement Dependency Injection
---------------------------------


   You should use `Dependency Injection <https://developer.android.google.cn/training/dependency-injection>`__ 
   (DI) to keep your app flexible, robust, and ready to scale.

   DI keeps app components loosely coupled and easier to test.

   When implementing DI, you need to create an `application container <https://developer.android.google.cn/training/dependency-injection/manual#dependencies-container>`__,
   which is used to get the dependencies that your app needs.

   The application container needs to be accessible to the whole application. You can achieve this
   by holding the dependencies container in a custom ``Application`` class. This class then inherits
   from the `Application class <https://developer.android.google.cn/reference/android/app/Application>`__.

   If you need help implementing this functionality:

   -  For the application container, refer to `Dependency injection <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-repository#3>`__
      and `Attach application container to the app <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-repository#4>`__
      from the codelab `Add repository and Manual DI <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-repository>`__.
   -  For the application class code, refer to `Attach application container to the app <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-repository#4>`__.


8. Solution code
----------------


   **Solution code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-amphibians

   **Branch name:** ``main``

.. |b0e225571b16ffb.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-amphibians-app/img/b0e225571b16ffb.png
â­ Project: Create a Bookshelf App
===================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-bookshelf


1. Before you begin
-------------------


Prerequisites

   -  Ability to create and run a project in Android Studio.
   -  Ability to create layouts in Jetpack Compose.
   -  Experience using coroutines in Kotlin.
   -  Experience working with Retrofit, Coil, and Gson.


What you'll build

   -  An Android app that makes multiple requests to a web service and displays asynchronous
      downloaded images.


What you'll need

   -  A computer with Android Studio installed.


2. Overview
-----------


   Congratulations on finishing unit 5!

   To practice the concepts you learned in this unit, including coroutines, Retrofit, and Gson,
   you're going to build an app on your own that displays a list of books with images from the
   Google Books API.

   The app is expected to do the following:

   -  Make a request to the Google Books API using Retrofit.
   -  Parse the response using Gson.
   -  Display asynchronously downloaded images of the books along with their titles in a vertical
      grid.
   -  Implement best practices, separating the UI and data layer, by using a repository.
   -  Write tests for code that requires the network service, using dependency injection.

   The goal of this project is twofold. First, you get to put all the concepts you've learned in
   this unit into practice. You also get to work with a brand new REST API, read documentation, and
   apply the skills you've learned into a new app, just like you'd do as a professional Android
   developer.

   The following screenshot shows an example of the finished Bookshelf app. The exact layout and
   books displayed by the app is up to you. You learn more about how to retrieve the book data in
   the following sections.

   |9335665e21b79da1.png|


3. Plan your app
----------------



Plan your UI

   You can design your app's UI however you want. You need to consider how your app's layout adapts
   to different device form factors.

   Because you're using a scrolling grid of images, you need to load multiple images simultaneously
   onscreen. After you've obtained the URL of the image, you can use the ``AsyncImage`` composable
   provided by the Coil library to download the data in the background. Where possible, be sure to
   indicate to users when your app is using the network.


Plan the network layer

   In `pathway 1 of this unit <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-5-pathway-1>`__,
   you learned how to get data from the network and parse JSON responses. For the Bookshelf app, the
   data layer needs to do the following three things:

   -  Create a Retrofit service to get data from the Google Books API.
   -  Add methods for the service to get a list of books and get information about a specific book.
   -  Use Gson to extract meaningful data from the JSON response returned by the API.

   Let's briefly go over the methods of the Google Books API that you need for this project.


Search for books

   The Google Books API provides a method that returns a list of books based on a particular search
   term, as described in `Using the API <https://developers.google.cn/books/docs/v1/using#PerformingSearch>`__.

   For example, this URL returns search results for the term "jazz history".

   **Example**

   .. code:: prettyprint

      https://www.googleapis.com/books/v1/volumes?q=jazz+history

   There are several query parameters to filter your search. For the Bookshelf app, the ``q``
   parameter (short for query) is sufficient.

   The documentation also shows the expected JSON response. For the Bookshelf app, you need to
   extract the book's ``id``.


Request info for a specific book

   You need to make a request to get info on a specific book. This endpoint takes the id you
   extracted from the previous response.

   .. code:: prettyprint

      https://www.googleapis.com/books/v1/volumes/<volume_id>

   You can find thumbnail links in the ``imageLinks`` object in the ``volumeInfo`` object. For this
   app, the images you want to download are under the ``thumbnail`` key.

   .. code:: prettyprint

      ...
          "imageLinks": {
            "smallThumbnail": "http://books.google.com/books/publisher/content?id=EPUTEAAAQBAJ&printsec=frontcover&img=1&zoom=5&edge=curl&imgtk=AFLRE734s3CngIs16gM_Ht6GeGF4ew664I7oOGghmfk4pgfFcDYb4GlYCYdjtqqXluL2KUyfq_Ni5MSyv4JxEJ8W679zQ2Ib3okUKau3I1ruqBGrWOt2_haUauWC8sXEgjN7JHm4uOjS&source=gbs_api",
            "thumbnail": "http://books.google.com/books/publisher/content?id=EPUTEAAAQBAJ&printsec=frontcover&img=1&zoom=1&edge=curl&imgtk=AFLRE71N0ldzv6rliUV_K5ZACa9yPNcT8Ino6YKXJUMje_z4GsC9cp6gFql5TxlmqMoYN3CDhM3XAIO2riFeMXUnFVr5pTLq91htTtG1DDyvOdiR4yI6xu3yEEAn0dRbvNFZ5m7dUC9E&source=gbs_api",
            "small": "http://books.google.com/books/publisher/content?id=EPUTEAAAQBAJ&printsec=frontcover&img=1&zoom=2&edge=curl&imgtk=AFLRE71HmTwpoe3KR0AISYk5sDgV2Fz-F-6CDKJtFdvlXSZv3jEzFtsSXGJnEGjtCuoDMxP_6sgP8au1yadB7OmI2MhIBquel7ivcDB8e9ieLyh4HNoXnX3zmxfF_CfIfnNXDv0WHuyA&source=gbs_api",
            "medium": "http://books.google.com/books/publisher/content?id=EPUTEAAAQBAJ&printsec=frontcover&img=1&zoom=3&edge=curl&imgtk=AFLRE72LMPH7Q2S49aPeQ3Gm8jLEf6zH4ijuE0nvbOyXBUAgyL816pXzaw0136Pk8jXpfYYFY0IsqL7G7MMDMgKcJhnaoHojWNZpljZmGHeWLL_M7hxkOpmdmO7xza8dfVfPbFmBH4kl&source=gbs_api",
            "large": "http://books.google.com/books/publisher/content?id=EPUTEAAAQBAJ&printsec=frontcover&img=1&zoom=4&edge=curl&imgtk=AFLRE71w0J9EOzUzu1O5GMbwhnpI8BLWzOEtzqc9IfyxEDqimZ--H4JlNAZh_1zx8pqPNRf1qDt7FPb57lH5ip-LBlK3zjMC-MCBYcciuoPjTJOFmLv7pp5B6_-UFBap1KRfC0eG7P4d&source=gbs_api",
            "extraLarge": "http://books.google.com/books/publisher/content?id=EPUTEAAAQBAJ&printsec=frontcover&img=1&zoom=6&edge=curl&imgtk=AFLRE73t0gcxT-jzEETp8Yo5Osr15nVL7ntKL2WSe2S8kRSio7w0CGgErAq4WbPWIsH4TmOdP_EO6ZoPNSP-YGSOwqfPMw8_IlYE6hy9IKeAs5V_xaHy7drZleF0eizAQiEVg5ci7qby&source=gbs_api"
          },
      ...

   **Tip:** Because you need to make two sets of requests to get the image URLs, getting the list of
   book images is more involved than what you did in the Mars photos app.

   The following approach might help you implement this app:

   1. Perform the first request to search for books.
   2. Perform the requests to get individual book data **one after another in the same coroutine**.
      This way, each request is performed one after the other until the coroutine finishes. After
      all the requests have finished, store each thumbnail in a ``MutableList``.
   3. Load each of the thumbnails in the ``AsyncImage`` composables.


Download book thumbnails

   After you have the thumbnail URL, it can be provided to the ``AsyncImage`` composable in each
   grid item.

   **Warning:** You need to replace ``http`` with ``https`` in the URLs for the images to show. You
   can do this using the `String.replace() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/replace.html>`__
   method.


Design for testability

   In addition to the networking concepts, you also learned how to refactor an app to use a
   repository class for the data layer. For this app, you should design with testability in mind,
   using a repository to easily swap data sources with dependency injection.

   -  Include a repository interface for the books service.
   -  Implement a repository class that accesses the Retrofit service.
   -  Implement a fake service that doesn't make an actual request to the Google Books API.
   -  Write a test for the repository using the fake service.

   Book data needs to be retrieved from the network using a repository, letting you easily swap data
   sources with dependency injection.


4. Build the Bookshelf app
--------------------------


   Now that you have an overview of the Google Books API, it's time to build the Bookshelf API. Even
   though you're using a different web service, you've already learned all the concepts needed to
   complete this project. You can always refer to previous codelabs and sample apps from this unit
   if you need a refresher. The codelabs in this unit might be useful to you as you work on your
   project.

   We highly recommend completing all the projects in the course. Even if you feel confident about
   everything you learned in this unit, chances are you'll need to refer back to the codelabs more
   often than you think. It happens to everyoneâ€”even the instructors of this course! So, have fun
   with this project, and practice what you learned before moving onto the next unit.


.. |9335665e21b79da1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-bookshelf/img/9335665e21b79da1.png


â­ Use SQL to read and write to a database
===========================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-sql


1. Before you begin
-------------------

   Many of the apps you use store data directly on the device. The Clock app stores your recurring
   alarms, the Google Maps app saves a list of your recent searches, and the Contacts app lets you
   add, edit, and remove your contacts' information.

   Data persistenceâ€”storing or persisting data on the deviceâ€”is a big part of Android development.
   Persistent data ensures user-generated content isn't lost when the app is closed, or data
   downloaded from the internet is saved so it doesn't need to be redownloaded later.

   SQLite is a common way provided by the Android SDK for Android apps to persist data. SQLite
   provides a relational database that allows you to represent data in a similar way to how you
   structure data with Kotlin classes. This codelab teaches the fundamentals of SQLâ€”Structured Query
   Languageâ€”which, while not an actual programming language, provides a simple and flexible way to
   read and modify a SQLite database with just a few lines of code.

   After you gain a fundamental knowledge of SQL, you'll be prepared to use the Room library to add
   persistence to your apps later in this unit.

   **Note:** Android apps have a number of ways to store data, including both internal and external
   storage. This unit discusses Room and Preferences Datastore. To learn more about the different
   methods for storing data on Android, refer to the `Data and file storage overview <https://developer.android.google.cn/training/data-storage>`__.


2. Key concepts of relational databases
---------------------------------------


What is a database?


   If you are familiar with a spreadsheet program like Google Sheets, you are already familiar with
   a basic analogy for a database.

   A spreadsheet consists of separate data tables, or individual spreadsheets in the same workbook.

   |1f2b00d3ca083c4a.png|

   Each table consists of columns that define what the data represents and rows that represent
   individual items with values for each column. For example, you might define columns for a
   student's ID, name, major, and grade.

   |a441da5cc7be346b.png|

   Each row contains data for a single student, with values for each of the columns.

   |6131d8a59996f521.png|

   A relational database works the same way.

   -  Tables define high-level groupings of data you want to represent, such as students and
      professors.
   -  Columns define the data that each row in the table contains.
   -  Rows contain the actual data that consist of values for each column in the table.

   The structure of a relational database also mirrors what you already know about classes and
   objects in Kotlin.

   .. code:: prettyprint

      data class Student(
          id: Int,
          name: String,
          major: String,
          gpa: Double
      )

   -  Classes, like tables, model the data you want to represent in your app.
   -  Properties, like columns, define the specific pieces of data that every instance of the class
      should contain.
   -  Objects, like rows, are the actual data. Objects contain values for each property defined in
      the class, just as rows contain values for each column defined in the data table.

   Just as a spreadsheet can contain multiple sheets and an app can contain multiple classes, a
   database can contain multiple tables. A database is called a relational database when it can
   model relationships between tables. For example, a graduate student might have a single professor
   as a doctoral advisor whereas that professor is the doctoral advisor for multiple students.

   |7f1b56e05520dc3.png|

   Every table in a relational database contains a unique identifier for rows, such as a column
   where the value in each row is an automatically incremented integer. This identifier is known as
   the primary key.

   When a table references the primary key of another table, it is known as a foreign key. The
   presence of a foreign key means there's a relationship between the tables.

   **Note:** Like with Kotlin classes, the convention is to use the singular form for the name of
   database tables. For the example above, that means you name the tables ``teacher``, ``student``,
   and ``course``, not the plural forms of ``teachers``, ``students``, and ``courses``.


What is SQLite?


   SQLite is a commonly used relational database. Specifically, SQLite refers to a lightweight C
   library for relational database management with Structured Query Language, known as SQL and
   sometimes pronounced as "sequel" for short.

   You won't have to learn C or any entirely new programming language to work with a relational
   database. SQL is simply a way to add and retrieve data from a relational database with a few
   lines of code.

   **Note:** Not all databases are organized into tables, columns, and rows. Other kinds of
   databases, known as NoSQL, are structured similarly to a JSON object with nested pairs of keys
   and values. Examples of NoSQL databases include Redis or `Cloud Firestore <https://firebase.google.cn/docs/firestore>`__.


Representing data with SQLite


   In Kotlin, you're familiar with data types like ``Int`` and ``Boolean``. SQLite databases use
   data types too! Data table columns must have a specific data type. The following table maps
   common Kotlin data types to their SQLite equivalents.

   ===================== ====================
   **Kotlin data type**  **SQLite data type**
   ``Int``               INTEGER
   ``String``            VARCHAR or TEXT
   ``Boolean``           BOOLEAN
   ``Float``, ``Double`` REAL
   ===================== ====================

   The tables in a database and the columns in each table are collectively known as the *schema*. In
   the next section, you download the starter data set and learn more about its schema.


3. Download the starter data set
--------------------------------

   The database for this codelab is for a hypothetical email app. This codelab uses familiar
   examples, such as sorting and filtering mail, or searching by subject text or sender, to
   demonstrate all the powerful things you can do with SQL. This example also ensures you have
   experience with the types of scenarios you might find in an app before you work with Room in the
   next pathway.

   Download the starter project from the ``compose`` branch of the SQL Basics GitHub repository
   `here <https://github.dev/google-developer-training/android-basics-kotlin-sql-basics-app/tree/compose>`__.


Use the Database Inspector


   To use Database Inspector, perform the following steps:

   1. Run the SQL Basics app in Android Studio. When the app launches, you see the following screen.

   |76e94dfe2234c2b1.png|

   2. In Android Studio, click **View** > **Tool Windows** > **App Inspection**.

   |cd5dd859d31cbab3.png|

   You now see a new tab at the bottom labeled **App Inspection** with the **Database Inspector**
   tab selected. There are two additional tabs, but you don't need to use those. It might take a few
   seconds to load, but you then see a list on the left with the data tables, which you can select
   to run queries against.

   |5ace24ac5cc15abc.png|

   3. Click the **Open New Query Tab** button to open a pane to run a query against the database.

   |277ecff401ca5f1a.png|

   The ``email`` table has 7 columns:

   -  ``id``: The primary key.
   -  ``subject``: The subject line of the email.
   -  ``sender``: The email address from which the email originated.
   -  ``folder``: The folder where the message can be found, such as Inbox or Spam.
   -  ``starred``: Whether or not the user starred the email.
   -  ``read``: Whether or not the user read the email.
   -  ``received``: The timestamp when the email was received.

   **Tip:** Click the **Keep Database Connections Open** |c344609191760f79.png| button to continue
   interacting with the database after shutting down the emulator.

   |582d2d5ec3a738e0.png|


4. Read data with a SELECT statement
------------------------------------


SQL ``SELECT`` statement


   A SQL statementâ€”sometimes called a queryâ€”is used to read or manipulate a database.

   You read data from a SQLite database with a ``SELECT`` statement. A simple ``SELECT`` statement
   consists of the ``SELECT`` keyword, followed by the column name, followed by the ``FROM``
   keyword, followed by the table name. Every SQL statement ends with a semicolon (``;``).

   |2d7ff99736b072b9.png|

   A ``SELECT`` statement can also return data from multiple columns. You must separate column names
   with a comma.

   |cf94edd5de825043.png|

   If you want to select every column from the table, you use the wildcard character (``*``) in
   place of the column names.

   |fb75d3033c59949a.png|

   In either case, a simple ``SELECT`` statement like this returns every row in the table. You just
   need to specify the column names you want it to return.

   **Note:** While it is the convention to end every SQL statement with a semicolon (``;``), certain
   editors like the database inspector in Android Studio might let you omit the semicolon. The
   diagrams in this codelab show a semicolon at the end of each complete SQL query.


Read email data using a ``SELECT`` statement


   One of the primary things an email app needs to do is display a list of messages. With a SQL
   database, you can get this information with a ``SELECT`` statement.

   1. Make sure the **email** table is selected in the **Database Inspector**.

   |ffc77f938ea09071.png|

   2. First, try to select every column from every row in the ``email`` table.

   .. code:: prettyprint

      SELECT * FROM email;

   3. Click the **Run** button in the bottom right corner of the text box. Observe that the entire
      ``email`` table is returned.

   |4c3ea237c6ed2b57.png|

   4. Now, try to select just the subject for every row.

   .. code:: prettyprint

      SELECT subject FROM email;

   5. Notice that, once again, the query returns every row but only for that single column.

   |69a20935721dcc2.png|

   6. You can also select multiple columns. Try selecting the subject and the sender.

   .. code:: prettyprint

      SELECT subject, sender FROM email;

   7. Observe that the query returns every row in the ``email`` table, but only the values of the
      subject and sender column.

   |4ae739dad54397ea.png|

   Congratulations! You just executed your first query. Not bad, but consider it just the beginning;
   the "hello world" of SQL, if you will.

   You can be much more specific with ``SELECT`` statements by adding clauses to specify a subset of
   the data and even change how the output is formatted. In the following sections, you learn about
   the commonly used clauses of ``SELECT`` statements and how to format data.


5. Use SELECT statements with aggregate functions and distinct values
--------------------------------------------------------


Reduce columns with aggregate functions


   SQL statements aren't limited to returning rows. SQL offers a variety of functions that can
   perform an operation or calculation on a specific column, such as finding the maximum value, or
   counting the number of unique possible values for a particular column. These functions are called
   **aggregate functions**. Instead of returning all the data of a specific column, you can return a
   single value from a specific column.

   Examples of SQL aggregate functions include the following:

   -  ``COUNT()``: Returns the total number of rows that match the query.
   -  ``SUM()``: Returns the sum of the values for all rows in the selected column.
   -  ``AVG()``: Returns the mean valueâ€”averageâ€”of all the values in the selected column.
   -  ``MIN()``: Returns the smallest value in the selected column.
   -  ``MAX()``: Returns the largest value in the selected column.

   Instead of a column name, you can call an aggregate function and pass in a column name as an
   argument between the parentheses.

   |6730a62d583a0d9.png|

   Instead of returning that column's value for every row in the table, a single value is returned
   from calling the aggregate function.

   Aggregate functions can be an efficient way to perform calculations on a value when you don't
   need to read all the data in a database. For example, you might want to find the average of the
   values in a column without loading your entire database into a List and doing it manually.

   Let's see some of the aggregate functions in action with the ``email`` table:

   1. An app might want to get the total number of emails received. You can do this by using the
      ``COUNT()`` function and the wildcard character (``*``).

   .. code:: prettyprint

      SELECT COUNT(*) FROM email;

   2. The query returns a single value. You can do this entirely with a SQL query, without any
      Kotlin code to count the rows manually.

   |5d49b987545184bb.png|

   3. To get the time of the most recent message, you can use the ``MAX()`` function on the received
      column because the most recent Unix timestamp is the highest number.

   .. code:: prettyprint

      SELECT MAX(received) FROM email;

   4. The query returns a single result, the highestâ€”most recentâ€”timestamp in the received column.

   |d0241dce845c3955.png|


Filter duplicate results with ``DISTINCT``


   When you select a column, you can precede it with the ``DISTINCT`` keyword. This approach can be
   useful if you want to remove duplicates from the query result.

   |4f02533256302f26.png|

   As an example, many email apps have an autocomplete feature for addresses. You might want to
   include all addresses you receive an email from and display them in a list.

   1. Run the following query to return the ``sender`` column for every row.

   .. code:: prettyprint

      SELECT sender FROM email;

   2. Observe that the result contains many duplicates. This definitely isn't an ideal experience!

   |4f0489d1668dbede.png|

   3. Add the ``DISTINCT`` keyword before the sender column and rerun the query.

   .. code:: prettyprint

      SELECT DISTINCT sender FROM email;

   4. Notice that the result is now much smaller and every value is unique.

   |43a47ad8d18fee6e.png|

   You can also precede the column name in an aggregate function with the ``DISTINCT`` keyword.

   |55c45cb9c258e882.png|

   Say you want to know the number of unique senders in the database. You can count the number of
   unique senders with the ``COUNT()`` aggregate function and with the ``DISTINCT`` keyword on the
   ``sender`` column.

   1. Perform a ``SELECT`` statement, passing in ``DISTINCT sender`` to the ``COUNT()`` function.

   .. code:: prettyprint

      SELECT COUNT(DISTINCT sender) FROM email;

   2. Observe that the query tells us that there are 14 unique senders.

   |19ae43b0bc9a927e.png|


6. Filter queries with a WHERE clause
-------------------------------------

   Many email apps offer the feature to filter the messages shown based on certain criteria, such as
   data, search term, folder, sender, etc. For these types of use cases, you can add a ``WHERE``
   clause to your ``SELECT`` query.

   After the table name, on a new line, you can add the ``WHERE`` keyword followed by an expression.
   When writing more complex SQL queries, it's common to put each clause on a new line for
   readability.

   |707b0641aa2de0f.png|

   This query performs a boolean check for each selected row; if the check returns true, it includes
   the row in the result of the query. Rows for which the query returns false are not included in
   the result.

   For example, an email app might have filters for spam, trash, drafts, or user-created filters.
   The following instructions do this with a ``WHERE`` clause:

   1. Run a ``SELECT`` statement to return all columns (``*``) from the ``email`` table, including a
      ``WHERE`` clause to check the condition ``folder = 'inbox'``. No, that's not a typo: you use a
      single equals sign to check equality in SQL, and single rather than double quotes to represent
      a string value.

   .. code:: prettyprint

      SELECT * FROM email
      WHERE folder = 'inbox';

   2. The result only returns rows for messages in the user's inbox.

   |6e9f2a17186d7faa.png|

   **Note:** Pay special attention to the SQL comparison operators!

   Unlike in Kotlin, the comparison operator in SQL is a single equal sign (``=``), rather than a
   double equal sign (``==``).

   The inequality operator (``!=``) is the same as in Kotlin. SQL also provides comparison operators
   ``<``, ``<=``, ``>``, and ``>=``.


Logical operators with ``WHERE`` clauses


   SQL ``WHERE`` clauses aren't limited to a single expression. You can use the ``AND`` keyword,
   equivalent to the Kotlin **and** operator (``&&``), to only include results that satisfy both
   conditions.

   |d8a698416e55d11b.png|

   Alternatively, you can use the ``OR`` keyword, equivalent to the Kotlin **or** operator (``||``),
   to include rows in the results that satisfy either condition.

   |f3cecac289e7650d.png|

   For readability, you can also negate an expression using the ``NOT`` keyword.

   |27300a0a38ef0343.png|

   Many email apps allow multiple filters, for example, only showing unread emails.

   Try out the following more complicated ``WHERE`` clauses on the ``email`` table:

   1. In addition to only returning messages in the user's inbox, try also limiting the results to
      unread messagesâ€”where the value of the read column is false.

   .. code:: prettyprint

      SELECT * FROM email
      WHERE folder = 'inbox' AND read = false;

   2. Observe that after running the query, the results only contain unread emails in the user's
      inbox.

   |d9ebd307a146d320.png|

   3. Return all emails that are in the **important** folder ``OR`` are **starred**
      (``starred = true``). This means the result includes emails in different folders as long as
      they're starred.

   .. code:: prettyprint

      SELECT * FROM email
      WHERE folder = 'important' OR starred = true;

   4. Observe the result.

   |fd2f0dc7b6444956.png|

   **Note:** You can also write the SQL condition ``NOT folder = 'spam'`` as ``folder != 'spam'``.


Search for text using ``LIKE``


   One super useful thing you can do with a ``WHERE`` clause is to search for text in a specific
   column. You achieve this result when you specify a column name, followed by the ``LIKE`` keyword,
   followed by a search string.

   |6692c0d491b6f9af.png|

   The search string starts with the percent symbol (``%``), followed by the text to search for
   (Search term), followed by the percent symbol (``%``) again.

   |c69c15f654645ee2.png|

   If you're searching for a prefixâ€”results that begin with the specified textâ€”omit the first
   percent symbol (``%``).

   |fbe6a94daaf173ae.png|

   Alternatively, if you're searching for a suffix, omit the last percent symbol (``%``).

   |141f567c9cbc4029.png|

   There are many use cases where an app can use text search, such as searching for emails that
   contain particular text in the subject line or updating autocomplete suggestions as the user is
   typing.

   The following instructions let you use text search when querying the ``email`` table.

   1. Shakespeare characters, like the ones in our database, loved to talk about fools. Run the
      following query to get the total number of emails with the text "fool" in the subject line.

   .. code:: prettyprint

      SELECT COUNT(*) FROM email
      WHERE subject LIKE '%fool%';

   2. Observe the result.

   |fd2ff96969824b0d.png|

   3. Run the following query to return all columns from all rows where the subject ends with the
      word fool.

   .. code:: prettyprint

      SELECT * FROM email
      WHERE subject LIKE '%fool';

   4. Observe that two rows are returned.

   |a23379e507e39c0b.png|

   5. Run the following query to return distinct values of the ``sender`` column that begin with the
      letter ``h``.

   .. code:: prettyprint

      SELECT DISTINCT sender FROM email
      WHERE sender LIKE 'h%';

   6. Observe that the query returns three values: ``helena@example.com`` ,
      ``hyppolytus@example.com``, and ``hermia@example.com``.

   |47ada07aee5cd8d9.png|


7. Group, order, and limit results
----------------------------------


Group results with ``GROUP BY``


   You just saw how to use aggregate functions and the ``WHERE`` clause to filter and reduce
   results. SQL offers several other clauses that can help you format the results of your query.
   Among these clauses are grouping, ordering, and limiting results.

   You can use a ``GROUP BY`` clause to group results so that all rows that have the same value for
   a given column are grouped next to each other in the results. This clause doesn't change the
   results, but only the order in which they're returned.

   To add a ``GROUP BY`` clause to a ``SELECT`` statement, add the ``GROUP BY`` keyword followed by
   the column name you want to group results by.

   |6be095e981498bbf.png|

   A common use case is to couple a ``GROUP BY`` clause with an aggregate function is to partition
   the result of an aggregate function across different buckets, such as values of a column. Here's
   an example. Pretend you want to get the number of emails in each folder: ``'inbox'``, ``'spam'``,
   etc. You can select both the ``folder`` column and the ``COUNT()`` aggregate function, and
   specify the ``folder`` column in the ``GROUP BY`` clause.

   1. Perform the following query to select the folder column, and the result of ``COUNT()``
      aggregate function. Use a ``GROUP BY`` clause to bucket the results by the value in the
      ``folder`` column.

   .. code:: prettyprint

      SELECT folder, COUNT(*) FROM email
      GROUP BY folder;

   2. Observe the results. The query returns the total number of emails for each folder.

   |13b9eb8f5c8230c4.png|

   **Note:** You can specify multiple columns, separated by a comma in the ``GROUP BY`` clause, if
   you want to further separate each group into additional subgroups based on a different column.


Sort results with ``ORDER BY``


   You can also change the order of query results when you sort them with the ``ORDER BY`` clause.
   Add the ``ORDER BY`` keyword, followed by a column name, followed by the sort direction.

   |9cf561c6346ed6e0.png|

   By default, the sort direction is ``a``\ scending order, which you can omit from the ``ORDER BY``
   clause. If you want the results sorted in descending order, add ``DESC`` after the column name.

   Chances are you expect an email app to show the most recent emails first. The following
   instructions let you do this with an ``ORDER BY`` clause.

   1. Add an ``ORDER BY`` clause to sort unread emails, based on the ``received`` column. Because
      ascending orderâ€”lowest or the oldest firstâ€”is the default, you need to use the ``DESC``
      keyword.

   .. code:: prettyprint

      SELECT * FROM email
      ORDER BY received DESC;

   2. Observe the result.

   |6e28aef784a16d1b.png|

   You can use an ``ORDER BY`` clause with a ``WHERE`` clause. Say a user wants to search for old
   emails containing the text *fool*. They can sort the results to show the oldest emails first, in
   ascending order.

   1. Select all emails where the subject contains the text "fool" and sort the results in ascending
      order. Because the order is ascending, which is the default order when none is specified,
      using the ``ASC`` keyword with the ``ORDER BY`` clause is optional.

   .. code:: prettyprint

      SELECT * FROM email
      WHERE subject LIKE '%fool%'
      ORDER BY received ASC;

   2. Observe that the filtered results are returned with the oldestâ€”lowest value in the received
      columnâ€”shown first.

   |77ada71b663afab6.png|

   **Note:** If both are used in the same query, the ``GROUP BY`` clause comes before the
   ``ORDER BY`` clause.


Restrict the number of results with ``LIMIT``


   So far, all the examples return every single result from the database that matches the query. In
   many cases, you only need to display a limited number of rows from your database. You can add a
   ``LIMIT`` clause to your query to only return a specific number of results. Add the ``LIMIT``
   keyword followed by the maximum number of rows you want to return. If applicable, the ``LIMIT``
   clause comes after the ``ORDER BY`` clause.

   |122152adf15a9fca.png|

   Optionally, you can include the ``OFFSET`` keyword followed by another number for the number of
   rows to "skip". For example, if you want the next ten results, after the first ten, but don't
   want to return all twenty results, you can use ``LIMIT 10 OFFSET 10``.

   |37ad836862573d55.png|

   In an app, you might want to load emails more quickly by only returning the first ten emails in
   the user's inbox. Users can then scroll to view subsequent pages of emails. The following
   instructions use a ``LIMIT`` clause to achieve this behavior.

   1. Perform the following ``SELECT`` statement to get all emails in the user's inbox in descending
      order and limited to the first ten results.

   .. code:: prettyprint

      SELECT * FROM email
      WHERE folder = 'inbox'
      ORDER BY received DESC
      LIMIT 10;

   2. Observe that only ten results are returned.

   |5b228d8053956489.png|

   3. Modify and re-run the query to include the ``OFFSET`` keyword with a value of ``10``.

   .. code:: prettyprint

      SELECT * FROM email
      WHERE folder = 'inbox'
      ORDER BY received DESC
      LIMIT 10 OFFSET 10;

   4. The query returns ten results in decreasing order. However, the query skips the first set of
      ten results.

   |83a6ddbf6ef92b89.png|


8. Insert, update, and delete data in a database
------------------------------------------------


Insert data into a database


   In addition to reading from a database, there are different SQL statements for writing to a
   database. The data needs a way to get in there in the first place, right?

   You can add a new row to a database with an ``INSERT`` statement. An ``INSERT`` statement starts
   with ``INSERT INTO`` followed by the table name in which you want to insert a new row. The
   ``VALUES`` keyword appears on a new line followed by a set of parentheses that contain a comma
   separated list of values. You need to list the values in the same order of the database columns.

   |97b93929d6de2d0e.png|

   Pretend the user receives a new email, and we need to store it in our app's database. We can use
   an ``INSERT`` statement to add a new row to the ``email`` table.

   1. Perform an ``INSERT`` statement with the following data for a new email. Because the email is
      new, it is unread and initially appears in the inbox ``folder``. A value of ``NULL`` is
      provided for the ``id`` column, which means the ``id`` will be automatically generated with
      the next available autoincremented integer..

   .. code:: prettyprint

      INSERT INTO email
      VALUES (
          NULL, 'Lorem ipsum dolor sit amet', 'sender@example.com', 'inbox', false, false, CURRENT_TIMESTAMP
      );

   **Note:** ``CURRENT_TIMESTAMP`` is a special variable that is replaced with the current time in
   `UTC <https://en.wikipedia.org/wiki/Coordinated_Universal_Time>`__ when the query runs, which is
   convenient for when you insert new rows!

   2. Observe that the result is inserted into the database with an ``id`` of ``44``.

   .. code:: prettyprint

      SELECT * FROM email
      WHERE sender = 'sender@example.com';

   |12a3e77309771dd8.png|


Update existing data in a database


   After you've inserted data into a table, you can still change it later. You can update the value
   of one or more columns using an ``UPDATE`` statement. An ``UPDATE`` statement starts with the
   ``UPDATE`` keyword, followed by the table name, followed by a ``SET`` clause.

   |8ee88a5985aec77e.png|

   A ``SET`` clause consists of the ``SET`` keyword, followed by the name of the column you want to
   update.

   |bc255ece789859f.png|

   An ``UPDATE`` statement often includes a ``WHERE`` clause to specify the single row or multiple
   rows that you want to update with the specified column-value pair.

   |e64b7b343feb6224.png|

   If the user wants to mark an email as read, for example, you use an ``UPDATE`` statement to
   update the database. The following instructions let you mark the email inserted in the previous
   step as read.

   1. Perform the following ``UPDATE`` statement to set the row with an ``id`` of ``44`` so that the
      value of the ``read`` column is ``true``.

   .. code:: prettyprint

      UPDATE email
      SET read = true
      WHERE id = 44;

   2. Run a ``SELECT`` statement for that specific row to validate the result.

   .. code:: prettyprint

      SELECT read FROM email
      WHERE id = 44;

   3. Observe that the value of the read column is now ``1`` for a "true" value as opposed to ``0``
      for "false"..

   |74e9af167fa49ba3.png|


Delete a row from a database


   Finally, you can use a SQL ``DELETE`` statement to delete one or more rows from a table. A
   ``DELETE`` statement starts with the ``DELETE`` keyword, followed by the ``FROM`` keyword,
   followed by the table name, followed by a ``WHERE`` clause to specify which row or rows you want
   to delete.

   |a7e56405c5e5aaab.png|

   The following instructions use a ``DELETE`` statement to delete the previously inserted and
   subsequently updated row from the database.

   1. Perform the following ``DELETE`` statement to delete the row with an ``id`` of ``44`` from the
      database.

   .. code:: prettyprint

      DELETE FROM email
      WHERE id = 44;

   2. Validate your changes using a ``SELECT`` statement.

   .. code:: prettyprint

      SELECT * FROM email
      WHERE id = 44;

   3. Observe that a row with an ``id`` of ``44`` no longer exists.

   |b026810cf2fd6e44.png|


9. Summary
----------

   Congratulations! You learned a lot! You can now read from a database using ``SELECT`` statements,
   including ``WHERE``, ``GROUP BY``, ``ORDER BY``, and ``LIMIT`` clauses to filter results. You
   also learned about frequently used aggregate functions, the ``DISTINCT`` keyword to specify
   unique results, and the ``LIKE`` keyword to perform a text search on the values in a column.
   Finally, you learned how to ``INSERT``, ``UPDATE``, and ``DELETE`` rows in a data table.

   These skills will translate directly to Room, and with your knowledge of SQL, you'll be more than
   prepared to take on data persistence in your future apps.

   ``SELECT`` statement syntax:

   |346bed4fda774ca7.png|


10. Learn more
--------------

   While we've focused on the basics of SQL and some common use cases for Android development,
   there's a lot more that SQL can do. Refer to the following resources as an additional reference
   for what you've learned or to learn even more about the topic.

   -  `Database Inspector <https://developer.android.google.cn/studio/inspect/database>`__
   -  `Save data using SQLite <https://developer.android.google.cn/training/data-storage/sqlite>`__
   -  `Aggregate functions <https://www.sqlite.org/lang_aggfunc.html>`__
   -  `SQL Quick reference <https://www.w3schools.com/sql/sql_quickref.asp>`__
   -  `Creating data tables <https://www.w3schools.com/sql/sql_create_db.asp>`__
   -  `SQL Joins <https://www.w3schools.com/sql/sql_join.asp>`__
   -  `SQLite
      Performance <https://developer.android.google.cn/topic/performance/sqlite-performance-best-practices>`__

.. |1f2b00d3ca083c4a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/1f2b00d3ca083c4a.png
.. |a441da5cc7be346b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/a441da5cc7be346b.png
.. |6131d8a59996f521.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/6131d8a59996f521.png
.. |7f1b56e05520dc3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/7f1b56e05520dc3.png
.. |76e94dfe2234c2b1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/76e94dfe2234c2b1.png
.. |cd5dd859d31cbab3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/cd5dd859d31cbab3.png
.. |5ace24ac5cc15abc.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/5ace24ac5cc15abc.png
.. |277ecff401ca5f1a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/277ecff401ca5f1a.png
.. |c344609191760f79.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/c344609191760f79.png
.. |582d2d5ec3a738e0.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/582d2d5ec3a738e0.png
.. |2d7ff99736b072b9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/2d7ff99736b072b9.png
.. |cf94edd5de825043.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/cf94edd5de825043.png
.. |fb75d3033c59949a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/fb75d3033c59949a.png
.. |ffc77f938ea09071.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/ffc77f938ea09071.png
.. |4c3ea237c6ed2b57.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/4c3ea237c6ed2b57.png
.. |69a20935721dcc2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/69a20935721dcc2.png
.. |4ae739dad54397ea.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/4ae739dad54397ea.png
.. |6730a62d583a0d9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/6730a62d583a0d9.png
.. |5d49b987545184bb.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/5d49b987545184bb.png
.. |d0241dce845c3955.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/d0241dce845c3955.png
.. |4f02533256302f26.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/4f02533256302f26.png
.. |4f0489d1668dbede.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/4f0489d1668dbede.png
.. |43a47ad8d18fee6e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/43a47ad8d18fee6e.png
.. |55c45cb9c258e882.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/55c45cb9c258e882.png
.. |19ae43b0bc9a927e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/19ae43b0bc9a927e.png
.. |707b0641aa2de0f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/707b0641aa2de0f.png
.. |6e9f2a17186d7faa.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/6e9f2a17186d7faa.png
.. |d8a698416e55d11b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/d8a698416e55d11b.png
.. |f3cecac289e7650d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/f3cecac289e7650d.png
.. |27300a0a38ef0343.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/27300a0a38ef0343.png
.. |d9ebd307a146d320.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/d9ebd307a146d320.png
.. |fd2f0dc7b6444956.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/fd2f0dc7b6444956.png
.. |6692c0d491b6f9af.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/6692c0d491b6f9af.png
.. |c69c15f654645ee2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/c69c15f654645ee2.png
.. |fbe6a94daaf173ae.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/fbe6a94daaf173ae.png
.. |141f567c9cbc4029.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/141f567c9cbc4029.png
.. |fd2ff96969824b0d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/fd2ff96969824b0d.png
.. |a23379e507e39c0b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/a23379e507e39c0b.png
.. |47ada07aee5cd8d9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/47ada07aee5cd8d9.png
.. |6be095e981498bbf.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/6be095e981498bbf.png
.. |13b9eb8f5c8230c4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/13b9eb8f5c8230c4.png
.. |9cf561c6346ed6e0.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/9cf561c6346ed6e0.png
.. |6e28aef784a16d1b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/6e28aef784a16d1b.png
.. |77ada71b663afab6.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/77ada71b663afab6.png
.. |122152adf15a9fca.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/122152adf15a9fca.png
.. |37ad836862573d55.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/37ad836862573d55.png
.. |5b228d8053956489.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/5b228d8053956489.png
.. |83a6ddbf6ef92b89.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/83a6ddbf6ef92b89.png
.. |97b93929d6de2d0e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/97b93929d6de2d0e.png
.. |12a3e77309771dd8.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/12a3e77309771dd8.png
.. |8ee88a5985aec77e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/8ee88a5985aec77e.png
.. |bc255ece789859f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/bc255ece789859f.png
.. |e64b7b343feb6224.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/e64b7b343feb6224.png
.. |74e9af167fa49ba3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/74e9af167fa49ba3.png
.. |a7e56405c5e5aaab.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/a7e56405c5e5aaab.png
.. |b026810cf2fd6e44.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/b026810cf2fd6e44.png
.. |346bed4fda774ca7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-sql/img/346bed4fda774ca7.png


â­ Persist data with Room
==========================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-persisting-data-room


1. Before you begin
-------------------

   Most production-quality apps have data that the app needs to persist. For example, the app might
   store a playlist of songs, items on a to-do list, records of expenses and income, a catalog of
   constellations, or a history of personal data. For such use cases, you use a database to store
   this persistent data.

   `Room <https://developer.android.google.cn/topic/libraries/architecture/room>`__ 
   is a persistence library that's part of Android `Jetpack <https://developer.android.google.cn/jetpack/androidx/explorer?case=data>`__. 
   Room is an abstraction layer on top of a `SQLite <https://developer.android.google.cn/training/data-storage/sqlite>`__ 
   database. SQLite uses a specialized language (SQL) to perform database operations. Instead of using SQLite
   directly, Room simplifies the chores of database setup, configuration, and interactions with the
   app. Room also provides compile-time checks of SQLite statements.

   An *abstraction layer* is a set of functions that hide the underlying implementation/complexity.
   It provides an interface to an existing set of functionality, like SQLite in this case.

   The image below shows how Room, as a data source, fits in with the overall architecture
   recommended in this course. Room is a Data Source.

   |data layer contains repositories and data sources|


Prerequisites

   -  Ability to build a basic user interface (UI) for an Android app using Jetpack Compose.
   -  Ability to use composables like ``Text``, ``Icon``, ``IconButton``, and ``LazyColumn``.
   -  Ability to use the ``NavHost`` composable to define routes and screens in your app.
   -  Ability to navigate between screens using a ``NavHostController``.
   -  Familiarity with the Android architecture component ``ViewModel``. Ability to use
      ``ViewModelProvider.Factory`` to instantiate the ViewModels.
   -  Familiarity with concurrency fundamentals.
   -  Ability to use coroutines for long-running tasks.
   -  Basic knowledge of SQLite databases and the SQL language.


What you'll learn


   -  How to create and interact with the SQLite database using the Room library.
   -  How to create an entity, a data access object (DAO), and database classes.
   -  How to use a DAO to map Kotlin functions to SQL queries.


What you'll build

   -  You'll build an **Inventory** app that saves inventory items into the SQLite database.


What you need

   -  Starter code for the **Inventory** app
   -  A computer with Android Studio
   -  Device or an emulator with API level 26 or higher


2. App overview
---------------

   In this codelab, you work with a starter code of the Inventory app and add the database layer to
   it using the Room library. The final version of the app displays a list of items from the
   inventory database. The user has options to add a new item, update an existing item, and delete
   an item from the inventory database. For this codelab, you save the item data to the Room
   database. You complete the rest of the app's functionality in the next codelab.

   +--------------------------------+--------------------------------+--------------------------------+
   | |Phone screen with inventory   | |Add item screen show in the   | |Add Item screen with item     |
   | items|                         | phone screen.|                 | details filled in.|            |
   +--------------------------------+--------------------------------+--------------------------------+

   **Note**: The above screenshots are from the final version of the app at the end of the pathway,
   not the end of this codelab. These screenshots give you an idea of the final version of the app.


3. Starter app overview
-----------------------


Download the starter code for this codelab

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-inventory-app/archive/refs/heads/starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-inventory-app.git
      $ cd basic-android-kotlin-compose-training-inventory-app
      $ git checkout starter

   **Note:** The starter code is in the ``starter`` branch of the downloaded repository.

   You can browse the code in the `Inventory app <https://github.com/google-developer-training/basic-android-kotlin-compose-training-inventory-app/tree/starter>`__
   GitHub repository.


Starter code overview

   1. Open the project with the starter code in Android Studio.
   2. Run the app on an Android device or an emulator. Make sure the emulator or connected device
      runs with an API level 26 or higher. `Database Inspector <https://developer.android.google.cn/studio/inspect/database>`__ 
      works on emulators/devices that run API level 26 and higher.

   **Note:** The Database Inspector lets you inspect, query, and modify your app's databases while
   your app runs. The Database Inspector works with plain SQLite or with libraries built on top of
   SQLite, such as Room.

   3. Notice that the app shows no inventory data.
   4. Tap the floating action button (FAB), which lets you add new items to the database.

   The app navigates to a new screen where you can enter details for the new item.

   ============================== ============================================
   |Phone screen empty inventory| |Add item screen show in the phone screen.|
   ============================== ============================================


Problems with the starter code

   1. In the **Add Item** screen, enter an item's details like name, price, and quantity of the
      Item.
   2. Tap **Save**. The **Add Item** screen is not closed, but you can navigate back using the back
      key. The save functionality is not implemented, so the item details are not saved.

   Notice that the app is incomplete and the **Save** button functionality is not implemented.

   |bae9fd572d154881.png|

   In this codelab, you add the code that uses Room to save the inventory details in the SQLite
   database. You use the Room persistence library to interact with the SQLite database.


Code walkthrough

   The starter code you downloaded has pre-designed screen layouts for you. In this pathway, you
   focus on implementing the database logic. The following section is a brief walkthrough of some of
   the files to get you started.


ui/home/HomeScreen.kt

   This file is the home screen, or the first screen in the app, which contains the composables to
   display the inventory list. It has a FAB |+| to add new items to the list. You display the items
   in the list later in the pathway.

   |47cc655ae260796b.png|


ui/item/ItemEntryScreen.kt

   This screen is similar to ``ItemEditScreen.kt``. They both have text fields for the item details.
   This screen is displayed when the FAB is tapped in the home screen. The ``ItemEntryViewModel.kt``
   is the corresponding ``ViewModel`` for this screen.

   |bae9fd572d154881.png|


ui/navigation/InventoryNavGraph.kt

   This file is the navigation graph for the entire application.


4. Main components of Room
--------------------------

   Kotlin provides an easy way to work with data through data classes. While it is easy to work with
   in-memory data using data classes, when it comes to persisting data, you need to convert this
   data into a format compatible with database storage. To do so, you need *tables* to store the
   data and *queries* to access and modify the data.

   The following three components of `Room <https://developer.android.google.cn/topic/libraries/architecture/room>`__ 
   make these workflows seamless.

   -  `Room entities <https://developer.android.google.cn/training/data-storage/room/defining-data>`__
      represent tables in your app's database. You use them to update the data stored in rows in
      tables and to create new rows for insertion.
   -  Room `DAOs <https://developer.android.google.cn/training/data-storage/room/accessing-data>`__
      provide methods that your app uses to retrieve, update, insert, and delete data in the
      database.
   -  Room `Database class <https://developer.android.google.cn/reference/kotlin/androidx/room/Database>`__ 
      is the database class that provides your app with instances of the DAOs associated with that
      database.

   You implement and learn more about these components later in the codelab. The following diagram
   demonstrates how the components of Room work together to interact with the database.

   |a3288e8f37250031.png|


Add Room dependencies

   In this task, you add the required Room component libraries to your Gradle files.

   1. Open the module-level gradle file ``build.gradle.kts (Module: InventoryApp.app)``.
   2. In the ``dependencies`` block, add the dependencies for the Room library shown in the
      following code.

   .. code:: prettyprint

      //Room
      implementation("androidx.room:room-runtime:${rootProject.extra["room_version"]}")
      ksp("androidx.room:room-compiler:${rootProject.extra["room_version"]}")
      implementation("androidx.room:room-ktx:${rootProject.extra["room_version"]}")

   KSP is a powerful and yet simple API for parsing Kotlin annotations.

   **Note**: For the library dependencies in your Gradle file, always use the most current stable
   release version numbers from the `AndroidX releases page. <https://developer.android.google.cn/jetpack/androidx/versions>`__ 


5. Create an item Entity
------------------------

   An `Entity <https://developer.android.google.cn/reference/androidx/room/Entity>`__ class defines
   a table, and each instance of this class represents a row in the database table. The entity class
   has mappings to tell Room how it intends to present and interact with the information in the
   database. In your app, the entity holds information about inventory items, such as item name,
   item price, and quantity of items available.

   |8c9f1659ee82ca43.png|

   The ``@Entity`` annotation marks a class as a database Entity class. For each Entity class, the
   app creates a database table to hold the items. Each field of the Entity is represented as a
   column in the database, unless denoted otherwise (see `Entity <https://developer.android.google.cn/reference/androidx/room/Entity>`__ 
   docs for details). Every entity instance stored in the database must have a primary key. 
   The `primary key <https://developer.android.google.cn/reference/androidx/room/PrimaryKey>`__ 
   is used to uniquely identify every record/entry in your database tables. After the app assigns a primary
   key, it cannot be modified; it represents the entity object as long as it exists in the database.

   In this task, you create an Entity class and define fields to store the following inventory
   information for each item: an ``Int`` to store the primary key, a ``String`` to store the item
   name, a ``double`` to store the item price, and an ``Int`` to store the quantity in stock.

   1. Open the starter code in the Android Studio.
   2. Open the ``data`` package under the ``com.example.inventory`` base package.
   3. Inside the ``data`` package, open the ``Item`` Kotlin class, which represents a database
      entity in your app.

   .. code:: prettyprint

      // No need to copy over, this is part of the starter code
      class Item(
          val id: Int,
          val name: String,
          val price: Double,
          val quantity: Int
      )

   **Note**: As a reminder, the primary constructor is part of the class header in a Kotlin class.
   It goes after the class name (and optional type parameters).


Data classes

   Data classes are primarily used to hold data in Kotlin. They are defined with the keyword
   ``data``. Kotlin data class objects have some extra benefits. For example, the compiler
   automatically generates utilities to compare, print, and copy such as ``toString()``,
   `copy() <https://kotlinlang.org/docs/data-classes.html#copying>`__, and ``equals()``.

   **Example:**

   .. code:: prettyprint

      // Example data class with 2 properties.
      data class User(val firstName: String, val lastName: String){
      }

   To ensure consistency and meaningful behavior of the generated code, data classes must fulfill
   the following requirements:

   -  The primary constructor must have at least one parameter.
   -  All primary constructor parameters must be ``val`` or ``var``.
   -  Data classes cannot be ``abstract``, ``open``, or ``sealed``.

   **Warning**: The compiler only uses the properties defined inside the primary constructor for the
   automatically generated functions. The compiler excludes properties declared inside the class
   body from the generated implementations.

   To learn more about Data classes, check out the `Data classes documentation. <https://kotlinlang.org/docs/data-classes.html>`__ 

   1. Prefix the definition of the ``Item`` class with the ``data`` keyword to convert it to a data
      class.

   .. code:: prettyprint

      data class Item(
          val id: Int,
          val name: String,
          val price: Double,
          val quantity: Int
      )

   2. Above the ``Item`` class declaration, annotate the data class with ``@Entity``. Use the
      ``tableName`` argument to set the ``items`` as the SQLite table name.

   .. code:: prettyprint

      import androidx.room.Entity

      @Entity(tableName = "items")
      data class Item(
         ...
      )

   **Note**: The ``@Entity`` annotation has several possible arguments. By default (no arguments to
   ``@Entity``), the table name is the same as the class name. Use the ``tableName`` argument to
   customize the table name. For simplicity, you use an ``item``. There are several other arguments
   for ``@Entity`` you can investigate in the `Entity documentation <https://developer.android.google.cn/reference/androidx/room/Entity>`__.

   3. Annotate the ``id`` property with ``@PrimaryKey`` to make the ``id`` the primary key. A
      primary key is an ID to uniquely identify every record/entry in your ``Item`` table

   .. code:: prettyprint

      import androidx.room.PrimaryKey

      @Entity(tableName = "items")
      data class Item(
          @PrimaryKey
          val id: Int,
          ...
      )

   4. Assign the ``id`` a default value of ``0``, which is necessary for the ``id`` to auto generate
      ``id`` values.
   5. Add the ``autoGenerate`` parameter to the ``@PrimaryKey`` annotation to specify whether the
      primary key column should be auto-generated. If ``autoGenerate`` is set to ``true``, Room will
      automatically generate a unique value for the primary key column when a new entity instance is
      inserted into the database. This ensures that each entity instance has a unique identifier,
      without having to manually assign values to the primary key column

   .. code:: prettyprint

      data class Item(
          @PrimaryKey(autoGenerate = true)
          val id: Int = 0,
          // ...
      )

   Great! Now that you have created an Entity class, you can create a Data Access Object (DAO) to
   access the database.


6. Create the item DAO
----------------------

   The `Data Access Object <https://developer.android.google.cn/reference/androidx/room/Dao>`__
   (DAO) is a pattern you can use to separate the persistence layer from the rest of the application
   by providing an abstract interface. This isolation follows the `single-responsibility principle <https://en.wikipedia.org/wiki/Single-responsibility_principle>`__, 
   which you have seen in previous codelabs.

   The functionality of the DAO is to hide all the complexities involved in performing database
   operations in the underlying persistence layer, separate from the rest of the application. This
   lets you change the data layer independently of the code that uses the data.

   |8b91b8bbd7256a63.png|

   In this task, you define a DAO for Room. DAOs are the main components of Room that are
   responsible for defining the interface that accesses the database.

   The DAO you create is a custom interface that provides convenience methods for
   querying/retrieving, inserting, deleting, and updating the database. Room generates an
   implementation of this class at compile time.

   The ``Room`` library provides convenience annotations, such as ``@Insert``, ``@Delete``, and
   ``@Update``, for defining methods that perform simple inserts, deletes, and updates without
   requiring you to write a SQL statement.

   If you need to define more complex operations for insert, delete, update, or if you need to query
   the data in the database, use a ``@Query`` annotation instead.

   As an added bonus, as you write your queries in Android Studio, the compiler checks your SQL
   queries for syntax errors.

   For the Inventory app, you need the ability to do the following:

   -  **Insert** or add a new item.
   -  **Update** an existing item to update the name, price, and quantity.
   -  **Get** a specific item based on its primary key, ``id``.
   -  **Get all items** so you can display them.
   -  **Delete** an entry in the database.

   |59aaa051e6a22e79.png|

   Complete the following steps to implement the item DAO in your app:

   1. In the ``data`` package, create the Kotlin interface ``ItemDao.kt``.

   |name field is filled in as item dao|

   2. Annotate the ``ItemDao`` interface with ``@Dao``.

   .. code:: prettyprint

      import androidx.room.Dao

      @Dao
      interface ItemDao {
      }

   3. Inside the body of the interface, add an ``@Insert`` annotation.
   4. Below the ``@Insert``, add an ``insert()`` function that takes an instance of the ``Entity``
      class ``item`` as its argument.
   5. Mark the function with the ``suspend`` keyword to let it run on a separate thread.

   The database operations can take a long time to execute, so they need to run on a separate
   thread. Room doesn't allow database access on the main thread.

   .. code:: prettyprint

      import androidx.room.Insert

      @Insert
      suspend fun insert(item: Item)

   When inserting items into the database, conflicts can happen. For example, multiple places in the
   code tries to update the entity with different, conflicting, values such as the same primary key.
   An entity is a row in DB. In the Inventory app, we only insert the entity from one place that is
   the **Add Item** screen so we are not expecting any conflicts and can set the conflict strategy
   to *Ignore*.

   6. Add an argument ``onConflict`` and assign it a value of ``OnConflictStrategy.``\ *``IGNORE``*.

   The argument ``onConflict`` tells the Room what to do in case of a conflict. The
   ``OnConflictStrategy.``\ *``IGNORE``* strategy ignores a new item.

   To know more about the available conflict strategies, check out the `OnConflictStrategy <https://developer.android.google.cn/reference/androidx/room/OnConflictStrategy.html>`__
   documentation.

   .. code:: prettyprint

      import androidx.room.OnConflictStrategy

      @Insert(onConflict = OnConflictStrategy.IGNORE)
      suspend fun insert(item: Item)

   Now ``Room`` generates all the necessary code to insert the ``item`` into the database. When you
   call any of the DAO functions that are marked with Room annotations, Room executes the
   corresponding SQL query on the database. For example, when you call the above method,
   ``insert()`` from your Kotlin code, ``Room`` executes a SQL query to insert the entity into the
   database.

   7. Add a new function with ``@Update`` annotation that takes an ``Item`` as parameter.

   The entity that's updated has the same primary key as the entity that's passed in. You can update
   some or all of the entity's other properties.

   8. Similar to the ``insert()`` method, mark this function with the ``suspend`` keyword.

   .. code:: prettyprint

      import androidx.room.Update

      @Update
      suspend fun update(item: Item)

   Add another function with the ``@Delete`` annotation to delete item(s), and make it a suspending
   function.

   **Note**: The ``@Delete`` annotation deletes an item or a list of items. You need to pass the
   entities you want to delete. If you don't have the entity, you might have to fetch it before
   calling the ``delete()`` function.

   .. code:: prettyprint

      import androidx.room.Delete

      @Delete
      suspend fun delete(item: Item)

   There is no convenience annotation for the remaining functionality, so you have to use the
   ``@Query`` annotation and supply SQLite queries.

   9. Write a SQLite query to retrieve a particular item from the item table based on the given
      ``id``. The following code provides a sample query that selects all columns from the
      ``items``, where the ``id`` matches a specific value and ``id`` is a unique identifier.

   **Example:**

   .. code:: prettyprint

      // Example, no need to copy over
      SELECT * from items WHERE id = 1

   10. Add a ``@Query`` annotation.
   11. Use the SQLite query from the previous step as a string parameter to the ``@Query``
       annotation.
   12. Add a ``String`` parameter to the ``@Query`` that is a SQLite query to retrieve an item from
       the item table.

   The query now says to select all columns from the ``items``, where the ``id`` matches the :``id``
   argument. Notice the ``:id`` uses the colon notation in the query to reference arguments in the
   function.

   .. code:: prettyprint

      @Query("SELECT * from items WHERE id = :id")

   13. After the ``@Query`` annotation, add a ``getItem()`` function that takes an ``Int`` argument
       and returns a ``Flow<Item>``.

   .. code:: prettyprint

      import androidx.room.Query
      import kotlinx.coroutines.flow.Flow

      @Query("SELECT * from items WHERE id = :id")
      fun getItem(id: Int): Flow<Item>

   It is recommended to use ``Flow`` in the persistence layer. With ``Flow`` as the return type, you
   receive notification whenever the data in the database changes. The ``Room`` keeps this ``Flow``
   updated for you, which means you only need to explicitly get the data once. This setup is helpful
   to update the inventory list, which you implement in the next codelab. Because of the ``Flow``
   return type, Room also runs the query on the background thread. You don't need to explicitly make
   it a ``suspend`` function and call it inside a coroutine scope.

   **Note**: ``Flow`` in Room database can keep the data *up-to-date* by emitting a notification
   whenever the data in the database changes. This allows you to observe the data and update your UI
   accordingly.

   14. Add a ``@Query`` with a ``getAllItems()`` function.
   15. Have the SQLite query return all columns from the ``item`` table, ordered in ascending order.
   16. Have ``getAllItems()`` return a list of ``Item`` entities as ``Flow``. ``Room`` keeps this
       ``Flow`` updated for you, which means you only need to explicitly get the data once.

   .. code:: prettyprint

      @Query("SELECT * from items ORDER BY name ASC")
      fun getAllItems(): Flow<List<Item>>

   Completed ``ItemDao``:

   .. code:: prettyprint

      import androidx.room.Dao
      import androidx.room.Delete
      import androidx.room.Insert
      import androidx.room.OnConflictStrategy
      import androidx.room.Query
      import androidx.room.Update
      import kotlinx.coroutines.flow.Flow

      @Dao
      interface ItemDao {
          @Insert(onConflict = OnConflictStrategy.IGNORE)
          suspend fun insert(item: Item)

          @Update
          suspend fun update(item: Item)

          @Delete
          suspend fun delete(item: Item)

          @Query("SELECT * from items WHERE id = :id")
          fun getItem(id: Int): Flow<Item>

          @Query("SELECT * from items ORDER BY name ASC")
          fun getAllItems(): Flow<List<Item>>
      }

   17. Though you won't see any visible changes, build your app to make sure it has no errors.


7. Create a Database instance
-----------------------------

   In this task, you create a `RoomDatabase <https://developer.android.google.cn/reference/androidx/room/RoomDatabase>`__
   that uses your ``Entity`` and DAO from the previous tasks. The database class defines the list of
   entities and DAOs.

   The `Database <https://developer.android.google.cn/reference/androidx/room/Database>`__ class
   provides your app with instances of the DAOs you define. In turn, the app can use the DAOs to
   retrieve data from the database as instances of the associated data entity objects. The app can
   also use the defined data entities to update rows from the corresponding tables or to create new
   rows for insertion.

   You need to create an abstract ``RoomDatabase`` class and annotate it with ``@Database``. This
   class has one method that returns the existing instance of the ``RoomDatabase`` if the database
   doesn't exist.

   Here's the general process for getting the ``RoomDatabase`` instance:

   -  Create a ``public abstract`` class that extends ``RoomDatabase``. The new abstract class you
      define acts as a database holder. The class you define is abstract because ``Room`` creates
      the implementation for you.
   -  Annotate the class with ``@Database``. In the arguments, list the entities for the database
      and set the version number.
   -  Define an abstract method or property that returns an ``ItemDao`` instance, and the ``Room``
      generates the implementation for you.
   -  You only need one instance of the ``RoomDatabase`` for the whole app, so make the
      ``RoomDatabase`` a singleton.
   -  Use ``Room``'s `Room.databaseBuilder <https://developer.android.google.cn/reference/androidx/room/Room#databaseBuilder%28android.content.Context,java.lang.Class,kotlin.String%29>`__
      to create your (``item_database``) database only if it doesn't exist. Otherwise, return the
      existing database.


Create the Database

   1. In the ``data`` package, create a Kotlin class ``InventoryDatabase.kt``.
   2. In the ``InventoryDatabase.kt`` file, make ``InventoryDatabase`` class an ``abstract`` class
      that extends ``RoomDatabase``.
   3. Annotate the class with ``@Database``. Disregard the missing parameters error, which you fix
      in the next step.

   .. code:: prettyprint

      import androidx.room.Database
      import androidx.room.RoomDatabase

      @Database
      abstract class InventoryDatabase : RoomDatabase() {}

   The ``@Database`` annotation requires several arguments so that ``Room`` can build the database.

   4. Specify the ``Item`` as the only class with the list of ``entities``.
   5. Set the ``version`` as ``1`` **.** Whenever you change the schema of the database table, you
      have to increase the version number.
   6. Set ``exportSchema`` to ``false`` so as not to keep schema version history backups.

   .. code:: prettyprint

      @Database(entities = [Item::class], version = 1, exportSchema = false)

   7. Inside the body of the class, declare an abstract function that returns the ``ItemDao`` so
      that the database knows about the DAO.

   .. code:: prettyprint

      abstract fun itemDao(): ItemDao

   8. Below the abstract function, define a ``companion object``, which allows access to the methods
      to create or get the database and uses the class name as the qualifier.

   .. code:: prettyprint

       companion object {}

   9. Inside the ``companion`` object, declare a private nullable variable ``Instance`` for the
      database and initialize it to ``null``.

   The ``Instance`` variable keeps a reference to the database, when one has been created. This
   helps maintain a single instance of the database opened at a given time, which is an expensive
   resource to create and maintain.

   10. Annotate ``Instance`` with ``@Volatile``.

   The value of a volatile variable is never cached, and all reads and writes are to and from the
   main memory. These features help ensure the value of ``Instance`` is always up to date and is the
   same for all execution threads. It means that changes made by one thread to ``Instance`` are
   immediately visible to all other threads.

   .. code:: prettyprint

      @Volatile
      private var Instance: InventoryDatabase? = null

   11. Below ``Instance``, while still inside the ``companion`` object, define a
       ``getDatabase()``\ method with a ``Context`` parameter that the database builder needs.
   12. Return a type ``InventoryDatabase``. An error message appears because ``getDatabase()`` isn't
       returning anything yet.

   .. code:: prettyprint

      import android.content.Context

      fun getDatabase(context: Context): InventoryDatabase {}

   Multiple threads can potentially ask for a database instance at the same time, which results in
   two databases instead of one. This issue is known as a `race condition <https://en.wikipedia.org/wiki/Race_condition>`__. 
   Wrapping the code to get the database inside a ``synchronized`` block means that only 
   one thread of execution at a time can enter this block of code, which makes sure the 
   database only gets initialized once. Use ``synchronized{}`` block to avoid the race condition.

   13. Inside ``getDatabase()``, return the ``Instance`` variableâ€”or, if ``Instance`` is null,
       initialize it inside a ``synchronized{}`` block. Use the elvis operator(``?:``) to do this.
   14. Pass in ``this``, the companion object. You fix the error in later steps.

   .. code:: prettyprint

      return Instance ?: synchronized(this) { }

   15. Inside the synchronized block, use the database builder to get the database. Continue to
       ignore the errors, which you fix in the next steps.

   .. code:: prettyprint

      import androidx.room.Room

      Room.databaseBuilder()

   16. Inside the ``synchronized`` block, use the database builder to get a database. Pass in the
       application context, the database class, and a name for the database- ``item_database`` to
       the ``Room.databaseBuilder()``.

   .. code:: prettyprint

      Room.databaseBuilder(context, InventoryDatabase::class.java, "item_database")

   Android Studio generates a Type Mismatch error. To remove this error, you have to add a
   ``build()`` in the following steps.

   17. Add the required migration strategy to the builder. Use ``.``
       `fallbackToDestructiveMigration() <https://developer.android.google.cn/reference/androidx/room/RoomDatabase.Builder#fallbackToDestructiveMigration()>`__.

   .. code:: prettyprint

      .fallbackToDestructiveMigration()

   **Note**: Normally, you would provide a migration object with a migration strategy for when the
   schema changes. A *migration object* is an object that defines how you take all rows with the old
   schema and convert them to rows in the new schema, so that no data is lost.
   `Migration <https://medium.com/androiddevelopers/understanding-migrations-with-room-f01e04b07929>`__
   is beyond the scope of this codelab, but the term refers to when the schema is changed and you
   need to move your date without losing the data. Since this is a sample app, a simple alternative
   is to destroy and rebuild the database, which means that the inventory data is lost. For example,
   if you change something in the entity class, like adding a new parameter, you can allow the app
   to delete and re-initialize the database.

   18. To create the database instance, call ``.build()``. This call removes the Android Studio
       errors.

   .. code:: prettyprint

      .build()

   19. After ``build()``, add an ``also`` block and assign ``Instance = it`` to keep a reference to
       the recently created db instance.

   .. code:: prettyprint

      .also { Instance = it }

   20. At the end of the ``synchronized`` block, return ``instance``. Your final code looks like the
       following code:

   .. code:: prettyprint

      import android.content.Context
      import androidx.room.Database
      import androidx.room.Room
      import androidx.room.RoomDatabase

      /**
      * Database class with a singleton Instance object.
      */
      @Database(entities = [Item::class], version = 1, exportSchema = false)
      abstract class InventoryDatabase : RoomDatabase() {

          abstract fun itemDao(): ItemDao

          companion object {
              @Volatile
              private var Instance: InventoryDatabase? = null

              fun getDatabase(context: Context): InventoryDatabase {
                  // if the Instance is not null, return it, otherwise create a new database instance.
                  return Instance ?: synchronized(this) {
                      Room.databaseBuilder(context, InventoryDatabase::class.java, "item_database")
                          .build()
                          .also { Instance = it }
                  }
              }
          }
      }

   **Tip:** You can use this code as a template for your future projects. The way you create the
   ``RoomDatabase`` instance is similar to the process in the previous steps. You might have to
   replace the entities and DAOs specific to your app.

   21. Build your code to make sure there are no errors.


8. Implement the Repository
---------------------------

   In this task, you implement the ``ItemsRepository`` interface and ``OfflineItemsRepository``
   class to provide ``get``, ``insert``, ``delete``, and ``update`` entities from the database.

   1. Open the ``ItemsRepository.kt`` file under the ``data`` package.
   2. Add the following functions to the interface, which map to the DAO implementation.

   .. code:: prettyprint

      import kotlinx.coroutines.flow.Flow

      /**
      * Repository that provides insert, update, delete, and retrieve of [Item] from a given data source.
      */
      interface ItemsRepository {
          /**
           * Retrieve all the items from the the given data source.
           */
          fun getAllItemsStream(): Flow<List<Item>>

          /**
           * Retrieve an item from the given data source that matches with the [id].
           */
          fun getItemStream(id: Int): Flow<Item?>

          /**
           * Insert item in the data source
           */
          suspend fun insertItem(item: Item)

          /**
           * Delete item from the data source
           */
          suspend fun deleteItem(item: Item)

          /**
           * Update item in the data source
           */
          suspend fun updateItem(item: Item)
      }

   3. Open the ``OfflineItemsRepository.kt`` file under the ``data`` package.
   4. Pass in a constructor parameter of the type ``ItemDao``.

   .. code:: prettyprint

      class OfflineItemsRepository(private val itemDao: ItemDao) : ItemsRepository

   5. In the ``OfflineItemsRepository`` class, override the functions defined in the
      ``ItemsRepository`` interface and call the corresponding functions from the ``ItemDao``.

   .. code:: prettyprint

      import kotlinx.coroutines.flow.Flow

      class OfflineItemsRepository(private val itemDao: ItemDao) : ItemsRepository {
          override fun getAllItemsStream(): Flow<List<Item>> = itemDao.getAllItems()

          override fun getItemStream(id: Int): Flow<Item?> = itemDao.getItem(id)

          override suspend fun insertItem(item: Item) = itemDao.insert(item)

          override suspend fun deleteItem(item: Item) = itemDao.delete(item)

          override suspend fun updateItem(item: Item) = itemDao.update(item)
      }


Implement AppContainer class

   In this task, you instantiate the database and pass in the DAO instance to the
   ``OfflineItemsRepository`` class.

   1. Open the ``AppContainer.kt`` file under the ``data`` package.
   2. Pass in the ``ItemDao()`` instance to the ``OfflineItemsRepository`` constructor.
   3. Instantiate the database instance by calling ``getDatabase()`` on the ``InventoryDatabase``
      class passing in the context and call ``.itemDao()`` to create the instance of ``Dao``.

   .. code:: prettyprint

      override val itemsRepository: ItemsRepository by lazy {
          OfflineItemsRepository(InventoryDatabase.getDatabase(context).itemDao())
      }

   You now have all the building blocks to work with your Room. This code compiles and runs, but you
   have no way to tell if it actually works. So, this moment is a good time to test your database.
   To complete the test, you need the ``ViewModel`` to talk to the database.


9. Add the save functionality
-----------------------------

   You have thus far created a database, and the UI classes were part of the starter code. To save
   the app's transient data and to also access the database, you need to update the
   ``ViewModel``s. Your ``ViewModel``s interact with the database via the DAO and provide data
   to the UI. All database operations need to be run away from the main UI thread; you do so with
   coroutines and `viewModelScope <https://developer.android.google.cn/topic/libraries/architecture/coroutines#viewmodelscope>`__.


UI state class walkthrough

   Open the ``ui/item/ItemEntryViewModel.kt`` file. The ``ItemUiState`` data class represents the UI
   state of an Item. The ``ItemDetails`` data class represents a single item.

   The starter code provides you with three extension functions:

   -  The ``ItemDetails.toItem()`` extension function converts the ``ItemUiState`` UI state object
      to the ``Item`` entity type.
   -  The ``Item.toItemUiState()`` extension function converts the ``Item`` Room entity object to
      the ``ItemUiState`` UI state type.
   -  The ``Item.toItemDetails()`` extension function converts the ``Item`` Room entity object to
      the ``ItemDetails``.

   .. code:: prettyprint

      // No need to copy, this is part of starter code
      /**
      * Represents Ui State for an Item.
      */
      data class ItemUiState(
          val itemDetails: ItemDetails = ItemDetails(),
          val isEntryValid: Boolean = false
      )

      data class ItemDetails(
          val id: Int = 0,
          val name: String = "",
          val price: String = "",
          val quantity: String = "",
      )

      /**
      * Extension function to convert [ItemDetails] to [Item]. If the value of [ItemDetails.price] is
      * not a valid [Double], then the price will be set to 0.0. Similarly if the value of
      * [ItemDetails.quantity] is not a valid [Int], then the quantity will be set to 0
      */
      fun ItemDetails.toItem(): Item = Item(
          id = id,
          name = name,
          price = price.toDoubleOrNull() ?: 0.0,
          quantity = quantity.toIntOrNull() ?: 0
      )

      fun Item.formatedPrice(): String {
          return NumberFormat.getCurrencyInstance().format(price)
      }

      /**
      * Extension function to convert [Item] to [ItemUiState]
      */
      fun Item.toItemUiState(isEntryValid: Boolean = false): ItemUiState = ItemUiState(
          itemDetails = this.toItemDetails(),
          isEntryValid = isEntryValid
      )

      /**
      * Extension function to convert [Item] to [ItemDetails]
      */
      fun Item.toItemDetails(): ItemDetails = ItemDetails(
          id = id,
          name = name,
          price = price.toString(),
          quantity = quantity.toString()
      )

   You use the above class in the view models to read and update the UI.


Update ItemEntry ViewModel

   In this task, you pass in the repository to the ``ItemEntryViewModel.kt`` file. You also save the
   item details entered in the **Add Item** screen into the database.

   1. Notice the ``validateInput()`` private function in the ``ItemEntryViewModel`` class.

   .. code:: prettyprint

      // No need to copy over, this is part of starter code
      private fun validateInput(uiState: ItemDetails = itemUiState.itemDetails): Boolean {
          return with(uiState) {
              name.isNotBlank() && price.isNotBlank() && quantity.isNotBlank()
          }
      }

   The above function checks if the ``name``, ``price``, and ``quantity`` are empty. You use this
   function to verify user input before adding or updating the entity in the database.

   2. Open the ``ItemEntryViewModel`` class and add a ``private`` default constructor parameter of
      the type ``ItemsRepository``.

   .. code:: prettyprint

      import com.example.inventory.data.ItemsRepository

      class ItemEntryViewModel(private val itemsRepository: ItemsRepository) : ViewModel() {
      }

   3. Update the ``initializer`` for the item entry view model in the ``ui/AppViewModelProvider.kt``
      and pass in the repository instance as a parameter.

   .. code:: prettyprint

      object AppViewModelProvider {
          val Factory = viewModelFactory {
              // Other Initializers 
              // Initializer for ItemEntryViewModel
              initializer {
                  ItemEntryViewModel(inventoryApplication().container.itemsRepository)
              }
              //...
          }
      }

   4. Go to the ``ItemEntryViewModel.kt`` file and at the end of the ``ItemEntryViewModel`` class
      and add a suspend function called ``saveItem()`` to insert an item into the Room database.
      This function adds the data to the database in a non-blocking way.

   .. code:: prettyprint

      suspend fun saveItem() {
      }

   5. Inside the function, check if ``itemUiState`` is valid and convert it to ``Item`` type so Room
      can understand the data.
   6. Call ``insertItem()`` on ``itemsRepository`` and pass in the data. The UI calls this function
      to add Item details to the database.

   .. code:: prettyprint

      suspend fun saveItem() {
          if (validateInput()) {
              itemsRepository.insertItem(itemUiState.itemDetails.toItem())
          }
      }

   You have now added all the required functions to add entities to the database. In the next task,
   you update the UI to use the above functions.


ItemEntryBody() composable walkthrough

   1. In the ``ui/item/ItemEntryScreen.kt`` file, the ``ItemEntryBody()`` composable is partially
      implemented for you as part of the stater code. Look at the ``ItemEntryBody()`` composable in
      the ``ItemEntryScreen()`` function call.

   .. code:: prettyprint

      // No need to copy over, part of the starter code
      ItemEntryBody(
          itemUiState = viewModel.itemUiState,
          onItemValueChange = viewModel::updateUiState,
          onSaveClick = { },
          modifier = Modifier
              .padding(innerPadding)
              .verticalScroll(rememberScrollState())
              .fillMaxWidth()
      )

   2. Note that the UI state and the ``updateUiState`` lambda are being passed as function
      parameters. Look at the function definition to see how the UI state is being updated.

   .. code:: prettyprint

      // No need to copy over, part of the starter code
      @Composable
      fun ItemEntryBody(
          itemUiState: ItemUiState,
          onItemValueChange: (ItemUiState) -> Unit,
          onSaveClick: () -> Unit,
          modifier: Modifier = Modifier
      ) {
          Column(
              // ...
          ) {
              ItemInputForm(
                   itemDetails = itemUiState.itemDetails,
                   onValueChange = onItemValueChange,
                   modifier = Modifier.fillMaxWidth()
               )
              Button(
                   onClick = onSaveClick,
                   enabled = itemUiState.isEntryValid,
                   shape = MaterialTheme.shapes.small,
                   modifier = Modifier.fillMaxWidth()
               ) {
                   Text(text = stringResource(R.string.save_action))
               }
          }
      }

   You are displaying ``ItemInputForm`` and a **Save** button in this composable. In the
   ``ItemInputForm()`` composable, you are displaying three text fields. The **Save** is only
   enabled if text is entered in the text fields. The *``isEntryValid``* value is true if the text
   in all the text fields is valid (not empty).

   +------------------------------------------------+------------------------------------------------+
   | |Phone screen with item details partially      | |Phone screen with item details filled and     |
   | filled and save button disabled|               | save button enabled|                           |
   +------------------------------------------------+------------------------------------------------+

   3. Take a look at the ``ItemInputForm()`` composable function implementation and notice the
      ``onValueChange`` function parameter. You are updating the *``itemDetails``* value with the
      value entered by the user in the text fields. By the time the **Save** button is enabled,
      ``itemUiState.itemDetails`` has the values that need to be saved.

   .. code:: prettyprint

      // No need to copy over, part of the starter code
      @Composable
      fun ItemEntryBody(
          //...
      ) {
          Column(
              // ...
          ) {
              ItemInputForm(
                   itemDetails = itemUiState.itemDetails,
                   //...
               )
              //...
          }
      }

   .. code:: prettyprint

      // No need to copy over, part of the starter code
      @Composable
      fun ItemInputForm(
          itemDetails: ItemDetails,
          modifier: Modifier = Modifier,
          onValueChange: (ItemUiState) -> Unit = {},
          enabled: Boolean = true
      ) {
          Column(modifier = modifier.fillMaxWidth(), verticalArrangement = Arrangement.spacedBy(16.dp)) {
              OutlinedTextField(
                  value = itemUiState.name,
                  onValueChange = { onValueChange(itemDetails.copy(name = it)) },
                  //...
              )
              OutlinedTextField(
                  value = itemUiState.price,
                  onValueChange = { onValueChange(itemDetails.copy(price = it)) },
                  //...
              )
              OutlinedTextField(
                  value = itemUiState.quantity,
                  onValueChange = { onValueChange(itemDetails.copy(quantity = it)) },
                  //...
              )
          }
      }


Add click listener to the Save button

   To tie everything together, add a click handler to the **Save** button. Inside the click handler,
   you launch a coroutine and call ``saveItem()`` to save the data in the Room database.

   1. In the ``ItemEntryScreen.kt``, inside the ``ItemEntryScreen`` composable function, create a
      ``val`` named ``coroutineScope`` with the ``rememberCoroutineScope()`` composable function.

   **Note:** The ``rememberCoroutineScope()`` is a composable function that returns a
   ``CoroutineScope`` bound to the composition where it's called. You can use the
   ``rememberCoroutineScope()`` composable function when you want to launch a coroutine outside of a
   composable and ensure the coroutine is canceled after the scope leaves the composition. You can
   use this function when you need to control the lifecycle of coroutines manually, for example, to
   cancel an animation whenever a user event happens.

   .. code:: prettyprint

      import androidx.compose.runtime.rememberCoroutineScope

      val coroutineScope = rememberCoroutineScope()

   2. Update the *``ItemEntryBody``*\ ``()`` function call and launch a coroutine inside
      ``onSaveClick`` lambda.

   .. code:: prettyprint

      ItemEntryBody(
         // ...
          onSaveClick = {
              coroutineScope.launch {
              }
          },
          modifier = modifier.padding(innerPadding)
      )

   3. Look at the ``saveItem()`` function implementation in the ``ItemEntryViewModel.kt`` file to
      check if ``itemUiState`` is valid, converting ``itemUiState`` to ``Item`` type, and inserting
      it in the database using ``itemsRepository.insertItem()``.

   .. code:: prettyprint

      // No need to copy over, you have already implemented this as part of the Room implementation 

      suspend fun saveItem() {
          if (validateInput()) {
              itemsRepository.insertItem(itemUiState.itemDetails.toItem())
          }
      }

   4. In the ``ItemEntryScreen.kt``, inside the ``ItemEntryScreen`` composable function, inside the
      coroutine, call ``viewModel.saveItem()`` to save the item in the database.

   .. code:: prettyprint

      ItemEntryBody(
          // ...
          onSaveClick = {
              coroutineScope.launch {
                  viewModel.saveItem()
              }
          },
          //...
      )

   Notice that you did not use ``viewModelScope.launch()`` for ``saveItem()`` in the
   ``ItemEntryViewModel.kt`` file, but it is necessary for *``ItemEntryBody``*\ ``()`` when you call
   a repository method. You can only call suspend functions from a coroutine or another suspend
   function. The function ``viewModel.saveItem()`` is a suspend function.

   5. Build and run your app.
   6. Tap the **+** FAB.
   7. In the **Add Item** screen, add the item details and tap **Save**. Notice that tapping the
      **Save** button does not close the **Add Item** screen.

   |86086f5d34c90fcf.png|

   8. In the ``onSaveClick`` lambda, add a call to ``navigateBack()``\ after the call to
      ``viewModel.saveItem()`` to navigate back to the previous screen. Your ``ItemEntryBody()``
      function looks like the following code:

   .. code:: prettyprint

      ItemEntryBody(
          itemUiState = viewModel.itemUiState,
          onItemValueChange = viewModel::updateUiState,
          onSaveClick = {
              coroutineScope.launch {
                  viewModel.saveItem()
                  navigateBack()
              }
          },
          modifier = modifier.padding(innerPadding)
      )

   9. Run the app again and perform the same steps to enter and save the data. Notice that this
      time, the app navigates back to the **Inventory** screen.

   This action saves the data, but you cannot see the inventory data in the app. In the next task,
   you use the `Database Inspector <https://developer.android.google.cn/studio/inspect/database>`__
   to view the data you saved.

   |App screen with empty inventory list|


10. View the database content using Database Inspector
------------------------------------------------------

   The `Database Inspector <https://developer.android.google.cn/studio/inspect/database>`__ lets you
   inspect, query, and modify your app's databases while your app runs. This feature is especially
   useful for database debugging. The Database Inspector works with plain SQLite and with libraries
   built on top of SQLite, such as Room. Database Inspector works best on emulators/devices running
   API level 26.

   **Note**: The Database Inspector only works with the SQLite library included in the Android
   operating system on API level 26 and higher. It doesn't work with other SQLite libraries that you
   bundle with your app.

   1. Run your app on an emulator or connected device running API level 26 or higher, if you have
      not done so already.
   2. In Android Studio, select **View** > **Tool Windows** > **App Inspection** from the menu bar.
   3. Select the **Database Inspector** tab.
   4. In the **Database Inspector** pane, select the ``com.example.inventory`` from the dropdown
      menu if it is not already selected. The **item_database** in the Inventory app appears in the
      **Databases** pane.

   |76408bd5e93c3432.png|

   5. Expand the node for the **item_database** in the **Databases** pane and select **Item** to
      inspect. If your **Databases** pane is empty, use your emulator to add some items to the
      database using the **Add Item** screen.
   6. Check the **Live updates** checkbox in the Database Inspector to automatically update the data
      it presents as you interact with your running app in the emulator or device.

   |9e21d9f7eb426008.png|

   Congratulations! You created an app that can persist data using
   `Room <https://developer.android.google.cn/reference/androidx/room/package-summary>`__. In the
   next codelab, you will add a ``lazyColumn`` to your app to display the items on the database, and
   add new features to the app, like the ability to delete and update the entities. See you there!


11. Get the solution code
-------------------------

   The solution code for this codelab is in the GitHub repo. To download the code for the finished
   codelab, use the following git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-inventory-app.git
      $ cd basic-android-kotlin-compose-training-inventory-app
      $ git checkout room

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-inventory-app/archive/refs/heads/room.zip>`__

   **Note:** The solution code is in the ``room`` branch of the downloaded repository.

   If you want to see the solution code for this codelab, view it on
   `GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-inventory-app/tree/room>`__.


12. Summary
-----------

   -  Define your tables as data classes annotated with ``@Entity``. Define properties annotated
      with ``@ColumnInfo`` as columns in the tables.
   -  Define a data access object (DAO) as an interface annotated with ``@Dao``. The DAO maps Kotlin
      functions to database queries.
   -  Use annotations to define ``@Insert``, ``@Delete``, and ``@Update`` functions.
   -  Use the ``@Query`` annotation with an SQLite query string as a parameter for any other
      queries.
   -  Use `Database Inspector <https://developer.android.google.cn/studio/inspect/database>`__ to
      view the data saved in the Android SQLite database.


13. Learn more
--------------

   Android Developer Documentation

   -  `Save data in a local database using Room <https://developer.android.google.cn/training/data-storage/room>`__
   -  `androidx.room <https://developer.android.google.cn/reference/androidx/room/package-summary>`__
   -  `Debug your database with the Database Inspector <https://developer.android.google.cn/studio/inspect/database>`__

   Blog posts

   -  `7 Pro-tips for Room <https://medium.com/androiddevelopers/7-pro-tips-for-room-fbadea4bfbd1>`__
   -  `The one and only object. Kotlin Vocabulary <https://medium.com/androiddevelopers/the-one-and-only-object-5dfd2cf7ab9b>`__

   Videos

   -  `Kotlin: Using Room Kotlin APIs <https://www.youtube.com/watch?v=vsDkhRTMdA0>`__
   -  `Database Inspector <https://www.youtube.com/watch?v=UMc7Tu0nKYQ>`__

   Other documentation and articles

   -  `Singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`__
   -  `Companion objects <https://kotlinlang.org/docs/object-declarations.html#companion-objects>`__
   -  `SQLite Tutorial - An Easy Way to Master SQLite Fast <https://www.sqlitetutorial.net/>`__


.. |data layer contains repositories and data sources| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/dcfae1d1e200f931.png
.. |Phone screen with inventory items| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/dff66d262bbd788e.png
.. |Add item screen show in the phone screen.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/7008448fe6aba0a2.png
.. |Add Item screen with item details filled in.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/bae9fd572d154881.png
.. |Phone screen empty inventory| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/fb1fb265e2aa93f9.png
.. |bae9fd572d154881.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/bae9fd572d154881.png
.. |+| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/92174b5798be403e.png
.. |47cc655ae260796b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/47cc655ae260796b.png
.. |bae9fd572d154881.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/bae9fd572d154881.png
.. |a3288e8f37250031.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/a3288e8f37250031.png
.. |8c9f1659ee82ca43.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/8c9f1659ee82ca43.png
.. |8b91b8bbd7256a63.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/8b91b8bbd7256a63.png
.. |59aaa051e6a22e79.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/59aaa051e6a22e79.png
.. |name field is filled in as item dao| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/8ba78e80cf23b017.png
.. |Phone screen with item details partially filled and save button disabled| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/2d1bb6ae6fa41c70.png
.. |Phone screen with item details filled and save button enabled| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/86086f5d34c90fcf.png
.. |86086f5d34c90fcf.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/86086f5d34c90fcf.png
.. |App screen with empty inventory list| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/63d24e14cf062873.png
.. |76408bd5e93c3432.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/76408bd5e93c3432.png
.. |9e21d9f7eb426008.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/9e21d9f7eb426008.png


â­ Read and update data with Room
==================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-update-data-room


1. Before you begin
-------------------


   You learned in the previous codelabs how to use a Room persistence library, an abstraction layer
   on top of a `SQLite <https://developer.android.google.cn/training/data-storage/sqlite>`__
   database, to store the app data. In this codelab, you'll add more features to the Inventory app
   and learn how to read, display, update, and delete data from the SQLite database using Room. You
   will use a ``LazyColumn`` to display the data from the database and automatically update the data
   when the underlying data in the database changes.


Prerequisites

   -  Ability to create and interact with the SQLite database using the Room library.
   -  Ability to create an entity, DAO, and database classes.
   -  Ability to use a data access object (DAO) to map Kotlin functions to SQL queries.
   -  Ability to display list items in a `LazyColumn <https://developer.android.google.cn/jetpack/compose/lists>`__.
   -  Completion of the previous codelab in this unit, `Persist data with Room <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-persisting-data-room>`__.


What you'll learn

   -  How to read and display entities from a SQLite database.
   -  How to update and delete entities from a SQLite database using the Room library.


What you'll build

   -  An Inventory app that displays a list of inventory items and can update, edit, and delete
      items from the app database using Room.


What you'll need

   -  A computer with Android Studio


2. Starter app overview
-----------------------


   This codelab uses the Inventory app solution code from the previous codelab, 
   `Persist data with Room <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-persisting-data-room>`__
   as the starter code. The starter app already saves data with the `Room <https://developer.android.google.cn/reference/androidx/room/package-summary>`__
   persistence library. The user can use the **Add Item** screen to add data to the app database.

   **Note:** The current version of the starter app doesn't display the data stored in the database.

   ============================================== ==============================
   |Add Item screen with item details filled in.| |Phone screen empty inventory|
   ============================================== ==============================

   In this codelab, you extend the app to read and display the data, and update and delete entities
   on the database using a Room library.


Download the starter code for this codelab

   To get started, download the starter code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-inventory-app.git
      $ cd basic-android-kotlin-compose-training-inventory-app
      $ git checkout room

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-inventory-app/archive/refs/heads/room.zip>`__

   **Note:** The starter code is in the ``room`` branch of the downloaded repository.

   If you want to see the starter code for this codelab, view it on
   `GitHub <https://github.com/google-developer-training/basic-android-kotlin-compose-training-inventory-app/tree/room>`__.


3. Update UI state
------------------


   In this task, you add a ``LazyColumn`` to the app to display the data stored in the database.

   |Phone screen with inventory items|


HomeScreen composable function walkthrough

   -  Open the ``ui/home/HomeScreen.kt`` file and look at the ``HomeScreen()`` composable.

   .. code:: prettyprint

      @Composable
      fun HomeScreen(
          navigateToItemEntry: () -> Unit,
          navigateToItemUpdate: (Int) -> Unit,
          modifier: Modifier = Modifier,
      ) {
          val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior()

          Scaffold(
              topBar = {
                  // Top app with app title
              },
              floatingActionButton = {
                  FloatingActionButton(
                      // onClick details
                  ) {
                      Icon(
                          // Icon details
                      )
                  }
              },
          ) { innerPadding ->
           
             // Display List header and List of Items
              HomeBody(
                  itemList = listOf(),  // Empty list is being passed in for itemList
                  onItemClick = navigateToItemUpdate,
                  modifier = modifier.padding(innerPadding)
                                    .fillMaxSize()
              )
          }

   This composable function displays the following items:

   -  The top app bar with the app title
   -  The floating action button (FAB) for the addition of new items to inventory
      |7b1535d90ee957fa.png|
   -  The ``HomeBody()`` composable function

   The ``HomeBody()`` composable function displays inventory items based on the passed in list. As
   part of the starter code implementation, an empty list (``listOf()``) is passed to the
   ``HomeBody()`` composable function. To pass the inventory list to this composable, you must
   retrieve the inventory data from the repository and pass it into the ``HomeViewModel``.


Emit UI state in the ``HomeViewModel``

   When you added methods to ``ItemDao`` to get items- ``getItem()`` and ``getAllItems()``- you
   specified a ``Flow`` as the return type. Recall that a ``Flow`` represents a generic stream of
   data. By returning a ``Flow``, you only need to explicitly call the methods from the DAO once for
   a given lifecycle. Room handles updates to the underlying data in an asynchronous manner.

   Getting data from a flow is called *collecting from a flow*. When collecting from a flow in your
   UI layer, there are a few things to consider.

   -  Lifecycle events like configuration changes, for example rotating the device, causes the
      activity to be recreated. This causes recomposition and collecting from your ``Flow`` all over
      again.
   -  You want the values to be cached as state so that existing data isn't lost between lifecycle
      events.
   -  Flows should be canceled if there's no observers left, such as after a composable's lifecycle
      ends.

   The recommended way to expose a ``Flow`` from a ``ViewModel`` is with a ``StateFlow``. Using a
   ``StateFlow`` allows the data to be saved and observed, regardless of the UI lifecycle. To
   convert a ``Flow`` to a ``StateFlow``, you use the ``stateIn`` operator.

   The ``stateIn`` operator has three parameters which are explained below:

   -  ``scope`` - The ``viewModelScope`` defines the lifecycle of the ``StateFlow``. When the
      ``viewModelScope`` is canceled, the ``StateFlow`` is also canceled.
   -  ``started`` - The pipeline should only be active when the UI is visible. The
      ``SharingStarted.WhileSubscribed()`` is used to accomplish this. To configure a delay (in
      milliseconds) between the disappearance of the last subscriber and the stopping of the sharing
      coroutine, pass in the ``TIMEOUT_MILLIS`` to the ``SharingStarted.WhileSubscribed()`` method.
   -  ``initialValue`` - Set the initial value of the state flow to ``HomeUiState()``.

   Once you've converted your ``Flow`` into a ``StateFlow``, you can collect it using the
   ``collectAsState()`` method, converting its data into ``State`` of the same type.

   In this step, you'll retrieve all items in the Room database as a ``StateFlow`` observable API
   for UI state. When the Room Inventory data changes, the UI updates automatically.

   1. Open the ``ui/home/HomeViewModel.kt`` file, which contains a ``TIMEOUT_MILLIS`` constant and a
      ``HomeUiState`` data class with a list of items as a constructor parameter.

   .. code:: prettyprint

      // No need to copy over, this code is part of starter code

      class HomeViewModel : ViewModel() {

          companion object {
              private const val TIMEOUT_MILLIS = 5_000L
          }
      }

      data class HomeUiState(val itemList: List<Item> = listOf())

   2. Inside the ``HomeViewModel`` class, declare a ``val`` called ``homeUiState`` of the type
      ``StateFlow<HomeUiState>``. You will resolve the initialization error shortly.

   .. code:: prettyprint

      val homeUiState: StateFlow<HomeUiState>

   3. Call ``getAllItemsStream()`` on ``itemsRepository`` and assign it to ``homeUiState`` you just
      declared.

   .. code:: prettyprint

      val homeUiState: StateFlow<HomeUiState> =
          itemsRepository.getAllItemsStream()

   You now get an error - Unresolved reference: itemsRepository. To resolve the Unresolved reference
   error, you need to pass in the ``ItemsRepository`` object to the ``HomeViewModel``.

   4. Add a constructor parameter of the type ``ItemsRepository`` to the ``HomeViewModel`` class.

   .. code:: prettyprint

      import com.example.inventory.data.ItemsRepository

      class HomeViewModel(itemsRepository: ItemsRepository): ViewModel() {

   5. In the ``ui/AppViewModelProvider.kt`` file, in the ``HomeViewModel`` initializer, pass the
      ``ItemsRepository`` object as shown.

   .. code:: prettyprint

      initializer {
          HomeViewModel(inventoryApplication().container.itemsRepository)
      }

   6. Go back to the ``HomeViewModel.kt`` file. Notice the type mismatch error. To resolve this, add
      a transformation map as shown below.

   .. code:: prettyprint

      val homeUiState: StateFlow<HomeUiState> =
          itemsRepository.getAllItemsStream().map { HomeUiState(it) }

   Android Studio still shows you a type mismatch error. This error is because ``homeUiState`` is of
   the type ``StateFlow`` and ``getAllItemsStream()`` returns a ``Flow``.

   7. Use the ``stateIn`` operator to convert the ``Flow`` into a ``StateFlow``. The ``StateFlow``
      is the observable API for UI state, which enables the UI to update itself.

   .. code:: prettyprint

      import androidx.lifecycle.viewModelScope
      import kotlinx.coroutines.flow.SharingStarted
      import kotlinx.coroutines.flow.map
      import kotlinx.coroutines.flow.stateIn

      val homeUiState: StateFlow<HomeUiState> =
          itemsRepository.getAllItemsStream().map { HomeUiState(it) }
              .stateIn(
                  scope = viewModelScope,
                  started = SharingStarted.WhileSubscribed(TIMEOUT_MILLIS),
                  initialValue = HomeUiState()
              )

   8. Build the app to make sure there are no errors in the code. There will not be any visual
      changes.


4. Display the Inventory data
-----------------------------


   In this task, you collect and update the UI state in the ``HomeScreen``.

   1. In the ``HomeScreen.kt`` file, in the ``HomeScreen`` composable function, add a new function
      parameter of the type ``HomeViewModel`` and initialize it.

   .. code:: prettyprint

      import androidx.lifecycle.viewmodel.compose.viewModel
      import com.example.inventory.ui.AppViewModelProvider


      @Composable
      fun HomeScreen(
          navigateToItemEntry: () -> Unit,
          navigateToItemUpdate: (Int) -> Unit,
          modifier: Modifier = Modifier,
          viewModel: HomeViewModel = viewModel(factory = AppViewModelProvider.Factory)
      )

   2. In the ``HomeScreen`` composable function, add a ``val`` called ``homeUiState`` to collect the
      UI state from the ``HomeViewModel``. You use *``collectAsState``*\ ``()``, which collects
      values from this `StateFlow <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/index.html>`__
      and represents its latest value via `State <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/State>`__.

   .. code:: prettyprint

      import androidx.compose.runtime.collectAsState
      import androidx.compose.runtime.getValue

      val homeUiState by viewModel.homeUiState.collectAsState()

   3. Update the ``HomeBody()`` function call and pass in ``homeUiState.itemList`` to the
      ``itemList`` parameter.

   .. code:: prettyprint

      HomeBody(
          itemList = homeUiState.itemList,
          onItemClick = navigateToItemUpdate,
          modifier = modifier.padding(innerPadding)
      )

   4. Run the app. Notice that the inventory list displays if you saved items in your app database.
      If the list is empty, add some inventory items to the app database.

   |Phone screen with inventory items|


5. Test your database
---------------------


   Previous codelabs discuss the importance of testing your code. In this task, you add some unit
   tests to test your DAO queries, and then you add more tests as you progress through the codelab.

   The recommended approach for testing your database implementation is writing a JUnit test that
   runs on an Android device. Because these tests don't require creating an activity, they are
   faster to execute than your UI tests.

   1. In the ``build.gradle.kts (Module :app)`` file, notice the following dependencies for Espresso
      and JUnit.

   .. code:: prettyprint

      // Testing
      androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
      androidTestImplementation("androidx.test.ext:junit:1.1.5")

   2. Switch to **Project** view and right-click on **src** > **New** > **Directory** to create a
      test source set for your tests.

   |9121189f4a0d2613.png|

   3. Select **androidTest/kotlin** from the **New Directory** popup.

   |fba4ed57c7589f7f.png|

   4. Create a Kotlin class called ``ItemDaoTest.kt``.
   5. Annotate the ``ItemDaoTest`` class with ``@RunWith(AndroidJUnit4::class)``. Your class now
      looks something like the following example code:

   .. code:: prettyprint

      package com.example.inventory

      import androidx.test.ext.junit.runners.AndroidJUnit4
      import org.junit.runner.RunWith

      @RunWith(AndroidJUnit4::class)
      class ItemDaoTest {
      }

   6. Inside the class, add private ``var`` variables of the type ``ItemDao`` and
      ``InventoryDatabase``.

   .. code:: prettyprint

      import com.example.inventory.data.InventoryDatabase
      import com.example.inventory.data.ItemDao

      private lateinit var itemDao: ItemDao
      private lateinit var inventoryDatabase: InventoryDatabase

   7. Add a function to create the database and annotate it with ``@Before`` so that it can run
      before every test.
   8. Inside the method, initialize ``itemDao``.

   .. code:: prettyprint

      import android.content.Context
      import androidx.room.Room
      import androidx.test.core.app.ApplicationProvider
      import org.junit.Before

      @Before
      fun createDb() {
          val context: Context = ApplicationProvider.getApplicationContext()
          // Using an in-memory database because the information stored here disappears when the
          // process is killed.
          inventoryDatabase = Room.inMemoryDatabaseBuilder(context, InventoryDatabase::class.java)
              // Allowing main thread queries, just for testing.
              .allowMainThreadQueries()
              .build()
          itemDao = inventoryDatabase.itemDao()
      }

   In this function, you use an in-memory database and do not persist it on the disk. To do so, you
   use the inMemoryDatabaseBuilder() function. You do this because the information need not be
   persisted, but rather, needs to be deleted when the process is killed.You are running the DAO
   queries in the main thread with ``.allowMainThreadQueries()``, just for testing.

   9. Add another function to close the database. Annotate it with ``@After`` to close the database
      and run after every test.

   .. code:: prettyprint

      import org.junit.After
      import java.io.IOException

      @After
      @Throws(IOException::class)
      fun closeDb() {
          inventoryDatabase.close()
      }

   10. Declare items in the class ``ItemDaoTest`` for the database to use, as shown in the following
       code example:

   .. code:: prettyprint

      import com.example.inventory.data.Item

      private var item1 = Item(1, "Apples", 10.0, 20)
      private var item2 = Item(2, "Bananas", 15.0, 97)

   11. Add utility functions to add one item, and then two items, to the database. Later, you use
       these functions in your test. Mark them as ``suspend`` so they can run in a coroutine.

   .. code:: prettyprint

      private suspend fun addOneItemToDb() {
          itemDao.insert(item1)
      }

      private suspend fun addTwoItemsToDb() {
          itemDao.insert(item1)
          itemDao.insert(item2)
      }

   12. Write a test for inserting a single item into the database, ``insert()``. Name the test
       ``daoInsert_insertsItemIntoDB`` and annotate it with ``@Test``.

   .. code:: prettyprint

      import kotlinx.coroutines.flow.first
      import kotlinx.coroutines.runBlocking
      import org.junit.Assert.assertEquals
      import org.junit.Test


      @Test
      @Throws(Exception::class)
      fun daoInsert_insertsItemIntoDB() = runBlocking {
          addOneItemToDb()
          val allItems = itemDao.getAllItems().first()
          assertEquals(allItems[0], item1)
      }

   In this test, you use the utility function ``addOneItemToDb()`` to add one item to the database.
   Then, you read the first item in the database. With ``assertEquals()``, you compare the expected
   value with the actual value. You run the test in a new coroutine with ``runBlocking{}``. This
   setup is the reason you mark the utility functions as ``suspend``.

   13. Run the test and make sure it passes.

   |2f0ddde91781d6bd.png|

   |8f66e03d03aac31a.png|

   14. Write another test for ``getAllItems()`` from the database. Name the test
       ``daoGetAllItems_returnsAllItemsFromDB``.

   .. code:: prettyprint

      @Test
      @Throws(Exception::class)
      fun daoGetAllItems_returnsAllItemsFromDB() = runBlocking {
          addTwoItemsToDb()
          val allItems = itemDao.getAllItems().first()
          assertEquals(allItems[0], item1)
          assertEquals(allItems[1], item2)
      }

   In the above test, you add two items to the database inside a coroutine. Then you read the two
   items and compare them with the expected values.


6. Display item details
-----------------------


   In this task, you read and display the entity details on the **Item Details** screen. You use the
   item UI state, such as name, price, and quantity from the inventory app database and display them
   on the **Item Details** screen with the ``ItemDetailsScreen`` composable. The
   ``ItemDetailsScreen`` composable function is prewritten for you and contains three Text
   composables that display the item details.


ui/item/ItemDetailsScreen.kt

   This screen is part of the starter code and displays the details of the items, which you see in a
   later codelab. You do not work on this screen in this codelab. The ``ItemDetailsViewModel.kt`` is
   the corresponding ``ViewModel`` for this screen.

   |de7761a894d1b2ab.png|

   1. In the ``HomeScreen`` composable function, notice the ``HomeBody()`` function call.
      ``navigateToItemUpdate`` is being passed to the ``onItemClick`` parameter, which gets called
      when you click on any item in your list.

   .. code:: prettyprint

      // No need to copy over 
      HomeBody(
          itemList = homeUiState.itemList,
          onItemClick = navigateToItemUpdate,
          modifier = modifier
              .padding(innerPadding)
              .fillMaxSize()
      )

   2. Open ``ui/navigation/InventoryNavGraph.kt`` and notice the ``navigateToItemUpdate`` parameter
      in the ``HomeScreen`` composable. This parameter specifies the destination for navigation as
      the item details screen.

   .. code:: prettyprint

      // No need to copy over 
      HomeScreen(
          navigateToItemEntry = { navController.navigate(ItemEntryDestination.route) },
          navigateToItemUpdate = {
              navController.navigate("${ItemDetailsDestination.route}/${it}")
         }

   This part of the ``onItemClick`` functionality is already implemented for you. When you click the
   list item, the app navigates to the item details screen.

   3. Click any item in the inventory list to see the item details screen with empty fields.

   |Item details screen with empty data|

   To fill the text fields with item details, you need to collect the UI state in
   ``ItemDetailsScreen()``.

   4. In ``UI/Item/ItemDetailsScreen.kt``, add a new parameter to the ``ItemDetailsScreen``
      composable of the type ``ItemDetailsViewModel`` and use the factory method to initialize it.

   .. code:: prettyprint

      import androidx.lifecycle.viewmodel.compose.viewModel
      import com.example.inventory.ui.AppViewModelProvider

      @Composable
      fun ItemDetailsScreen(
          navigateToEditItem: (Int) -> Unit,
          navigateBack: () -> Unit,
          modifier: Modifier = Modifier,
          viewModel: ItemDetailsViewModel = viewModel(factory = AppViewModelProvider.Factory)
      )

   5. Inside the ``ItemDetailsScreen()`` composable, create a ``val`` called ``uiState`` to collect
      the UI state. Use ``collectAsState()`` to collect ``uiState`` ``StateFlow`` and represent its
      latest value via ``State``. Android Studio displays an unresolved reference error.

   .. code:: prettyprint

      import androidx.compose.runtime.collectAsState

      val uiState = viewModel.uiState.collectAsState()

   6. To resolve the error, create a ``val`` called ``uiState`` of the type
      ``StateFlow<ItemDetailsUiState>`` in the ``ItemDetailsViewModel`` class.
   7. Retrieve the data from the item repository and map it to ``ItemDetailsUiState`` using the
      extension function ``toItemDetails()``. The extension function ``Item.toItemDetails()`` is
      already written for you as part of the starter code.

   .. code:: prettyprint

      import androidx.lifecycle.viewModelScope
      import kotlinx.coroutines.flow.SharingStarted
      import kotlinx.coroutines.flow.StateFlow
      import kotlinx.coroutines.flow.filterNotNull
      import kotlinx.coroutines.flow.map
      import kotlinx.coroutines.flow.stateIn

      val uiState: StateFlow<ItemDetailsUiState> =
               itemsRepository.getItemStream(itemId)
                   .filterNotNull()
                   .map {
                       ItemDetailsUiState(itemDetails = it.toItemDetails())
                   }.stateIn(
                       scope = viewModelScope,
                       started = SharingStarted.WhileSubscribed(TIMEOUT_MILLIS),
                       initialValue = ItemDetailsUiState()
                   )

   8. Pass ``ItemsRepository`` into the ``ItemDetailsViewModel`` to resolve the
      ``Unresolved reference: itemsRepository`` error.

   .. code:: prettyprint

      class ItemDetailsViewModel(
          savedStateHandle: SavedStateHandle,
          private val itemsRepository: ItemsRepository
          ) : ViewModel() {

   9. In ``ui/AppViewModelProvider.kt``, update the initializer for ``ItemDetailsViewModel`` as
      shown in the following code snippet:

   .. code:: prettyprint

      initializer {
          ItemDetailsViewModel(
              this.createSavedStateHandle(),
              inventoryApplication().container.itemsRepository
          )
      }

   10. Go back to the ``ItemDetailsScreen.kt`` and notice the error in the ``ItemDetailsScreen()``
       composable is resolved.
   11. In the ``ItemDetailsScreen()`` composable, update the ``ItemDetailsBody()`` function call and
       pass in ``uiState.value`` to ``itemUiState`` argument.

   .. code:: prettyprint

      ItemDetailsBody(
          itemUiState = uiState.value,
          onSellItem = {  },
          onDelete = { },
          modifier = modifier.padding(innerPadding)
      )

   12. Observe the implementations of ``ItemDetailsBody()`` and ``ItemInputForm()``. You are passing
       the current selected ``item`` from ``ItemDetailsBody()`` to ``ItemDetails()``.

   .. code:: prettyprint

      // No need to copy over

      @Composable
      private fun ItemDetailsBody(
          itemUiState: ItemUiState,
          onSellItem: () -> Unit,
          onDelete: () -> Unit,
          modifier: Modifier = Modifier
      ) {
          Column(
             //...
          ) {
              var deleteConfirmationRequired by rememberSaveable { mutableStateOf(false) }
              ItemDetails(
                   item = itemDetailsUiState.itemDetails.toItem(), modifier = Modifier.fillMaxWidth()
               )

            //...
          }

   13. Run the app. When you click any list element on the **Inventory** screen, the **Item
       Details** screen displays.
   14. Notice that the screen is not blank anymore. It displays the entity details retrieved from
       the inventory database.

   |Item details screen with valid item details|

   15. Tap the **Sell** button. Nothing happens!

   In the next section, you implement the functionality of the **Sell** button.


7. Implement Item details screen
--------------------------------



**ui/item/ItemEditScreen.kt**

   The Item edit screen is already provided to you as part of the starter code.

   This layout contains text field composables to edit the details of any new inventory item.

   |Edit item layout with item name item price and quantity in stock felids|

   The code for this app still isn't fully functional. For example, in the **Item Details** screen,
   when you tap the **Sell** button, the **Quantity in Stock** does not decrease. When you tap the
   **Delete** button, the app does prompt you with a confirmation dialog. However, when you select
   the **Yes** button, the app does not actually delete the item.

   |item delete confirmation pop up|

   Lastly, the FAB button |aad0ce469e4a3a12.png| opens an empty **Edit Item** screen.

   |Edit item screen with empty felids|

   In this section, you implement the functionalities of **Sell**, **Delete** and the FAB buttons.


8. Implement sell item
----------------------


   In this section, you extend the features of the app to implement the sell functionality. This
   update involves the following tasks:

   -  Add a test for the DAO function to update an entity.
   -  Add a function in the ``ItemDetailsViewModel`` to reduce the quantity and update the entity in
      the app database.
   -  Disable the **Sell** button if the quantity is zero.

   1. In ``ItemDaoTest.kt``, add a function called ``daoUpdateItems_updatesItemsInDB()`` with no
      parameters. Annotate with ``@Test`` and ``@Throws(Exception::class)``.

   .. code:: prettyprint

      @Test
      @Throws(Exception::class)
      fun daoUpdateItems_updatesItemsInDB()

   2. Define the function and create a *``runBlocking``* block. Call ``addTwoItemsToDb()`` inside
      it.

   .. code:: prettyprint

      fun daoUpdateItems_updatesItemsInDB() = runBlocking {
          addTwoItemsToDb()
      }

   3. Update the two entities with different values, calling ``itemDao.update``.

   .. code:: prettyprint

      itemDao.update(Item(1, "Apples", 15.0, 25))
      itemDao.update(Item(2, "Bananas", 5.0, 50))

   4. Retrieve the entities with ``itemDao.getAllItems()``. Compare them to the updated entity and
      assert.

   .. code:: prettyprint

      val allItems = itemDao.getAllItems().first()
      assertEquals(allItems[0], Item(1, "Apples", 15.0, 25))
      assertEquals(allItems[1], Item(2, "Bananas", 5.0, 50))

   5. Make sure the completed function looks like the following:

   .. code:: prettyprint

      @Test
      @Throws(Exception::class)
      fun daoUpdateItems_updatesItemsInDB() = runBlocking {
          addTwoItemsToDb()
          itemDao.update(Item(1, "Apples", 15.0, 25))
          itemDao.update(Item(2, "Bananas", 5.0, 50))

          val allItems = itemDao.getAllItems().first()
          assertEquals(allItems[0], Item(1, "Apples", 15.0, 25))
          assertEquals(allItems[1], Item(2, "Bananas", 5.0, 50))
      }

   6. Run the test and make sure it passes.


Add a function in the ``ViewModel``

   1. In ``ItemDetailsViewModel.kt``, inside the ``ItemDetailsViewModel`` class, add a function
      called ``reduceQuantityByOne()`` with no parameters.

   .. code:: prettyprint

      fun reduceQuantityByOne() {
      }

   2. Inside the function, start a coroutine with ``viewModelScope.launch{}``.

   **Note:** You must run database operations inside a coroutine.

   .. code:: prettyprint

      import kotlinx.coroutines.launch
      import androidx.lifecycle.viewModelScope


      viewModelScope.launch {
      }

   3. Inside the ``launch`` block, create a ``val`` called ``currentItem`` and set it to
      *``uiState.value.toItem()``.*

   .. code:: prettyprint

      val currentItem = uiState.value.toItem()

   The ``uiState.value`` is of the type **``ItemUiState``**. You convert it to the ``Item`` entity
   type with the extension function *``toItem``*\ ``()``.

   4. Add an ``if`` statement to check if the ``quality`` is greater than ``0``.
   5. Call ``updateItem()`` on ``itemsRepository`` and pass in the updated ``currentItem``. Use
      ``copy()`` to update the ``quantity`` value so that the function looks like the following:

   .. code:: prettyprint

      fun reduceQuantityByOne() {
          viewModelScope.launch {
              val currentItem = uiState.value.itemDetails.toItem()
              if (currentItem.quantity > 0) {
          itemsRepository.updateItem(currentItem.copy(quantity = currentItem.quantity - 1))
             }
          }
      }

   6. Go back to ``ItemDetailsScreen.kt``.
   7. In the ``ItemDetailsScreen`` composable, go to the ``ItemDetailsBody()`` function call.
   8. In the ``onSellItem`` lambda, call ``viewModel.reduceQuantityByOne()``.

   .. code:: prettyprint

      ItemDetailsBody(
          itemUiState = uiState.value,
          onSellItem = { viewModel.reduceQuantityByOne() },
          onDelete = { },
          modifier = modifier.padding(innerPadding)
      )

   9.  Run the app.
   10. On the **Inventory** screen, click a list element. When the **Item Details** screen displays,
       tap the **Sell** and notice that the quantity value decreases by one.

   |Item details screen decreases the quantity by one when sell button is tapped|

   11. In the **Item Details** screen, continuously tap the **Sell** button until the quantity is
       zero.

   **Tip:** To save time, you might want to use an item for this task with a low quantity. If none
   of your items have a low quantity, you can create a new one with a low quantity.

   After the quantity reaches zero, tap **Sell** again. There is no visual change because the
   function ``reduceQuantityByOne()`` checks if the quantity is greater than zero before updating
   the quantity.

   |Item details screen with quantity in stock as 0|

   To give users better feedback, you might want to disable the **Sell** button when there is no
   item to sell.

   12. In the ``ItemDetailsViewModel`` class, set ``outOfStock`` value based on the
       ``it.quantity`` in the ``map`` transformation.

   .. code:: prettyprint

      val uiState: StateFlow<ItemDetailsUiState> =
          itemsRepository.getItemStream(itemId)
              .filterNotNull()
              .map {
                  ItemDetailsUiState(outOfStock = it.quantity <= 0, itemDetails = it.toItemDetails())
              }.stateIn(
                  //...
              )

   13. Run your app. Notice that the app disables the **Sell** button when the quantity in stock is
       zero.

   |Item details screen with sell button disabled|

   Congratulations on implementing the **Sell** item feature in your app!


Delete item entity

   As with the previous task, you must extend the features of your app further by implementing
   delete functionality This feature is much easier to implement than the sell feature. The process
   involves the following tasks:

   -  Add a test for the delete DAO query.
   -  Add a function in the ``ItemDetailsViewModel`` class to delete an entity from the database.
   -  Update the *``ItemDetailsBody``* composable.


Add DAO test

   1. In ``ItemDaoTest.kt``, add a test called ``daoDeleteItems_deletesAllItemsFromDB()``.

   .. code:: prettyprint

      @Test
      @Throws(Exception::class)
      fun daoDeleteItems_deletesAllItemsFromDB()

   2. Launch a coroutine with ``runBlocking {}``.

   .. code:: prettyprint

      fun daoDeleteItems_deletesAllItemsFromDB() = runBlocking {
      }

   3. Add two items to the database and call ``itemDao.delete()`` on those two items to delete them
      from the database.

   .. code:: prettyprint

      addTwoItemsToDb()
      itemDao.delete(item1)
      itemDao.delete(item2)

   4. Retrieve the entities from the database and check that the list is empty. The completed test
      should look like the following:

   .. code:: prettyprint

      import org.junit.Assert.assertTrue

      @Test
      @Throws(Exception::class)
      fun daoDeleteItems_deletesAllItemsFromDB() = runBlocking {
          addTwoItemsToDb()
          itemDao.delete(item1)
          itemDao.delete(item2)
          val allItems = itemDao.getAllItems().first()
          assertTrue(allItems.isEmpty())
      }


Add delete function in the ``ItemDetailsViewModel``

   1. In ``ItemDetailsViewModel``, add a new function called ``deleteItem()`` that takes no
      parameters and returns nothing.
   2. Inside the ``deleteItem()`` function, add an ``itemsRepository.deleteItem()`` function call
      and pass in ``uiState.value.toItem()``.

   .. code:: prettyprint

      suspend fun deleteItem() {
          itemsRepository.deleteItem(uiState.value.itemDetails.toItem())
      }

   In this function, you convert the ``uiState`` from ``itemDetails`` type to ``Item`` entity type
   using the ``toItem`()`` extension function.

   3. In the ``ui/item/ItemDetailsScreen`` composable, add a ``val`` called ``coroutineScope`` and
      set it to ``rememberCoroutineScope()``. This approach returns a coroutine scope bound to the
      composition where it's called (``ItemDetailsScreen`` composable).

   .. code:: prettyprint

      import androidx.compose.runtime.rememberCoroutineScope


      val coroutineScope = rememberCoroutineScope()

   4. Scroll to the ``ItemDetailsBody()`` function.
   5. Launch a coroutine with ``coroutineScope`` inside the ``onDelete`` lambda.
   6. Inside the ``launch`` block, call the ``deleteItem()`` method on ``viewModel``.

   .. code:: prettyprint

      import kotlinx.coroutines.launch

      ItemDetailsBody(
          itemUiState = uiState.value,
          onSellItem = { viewModel.reduceQuantityByOne() },
          onDelete = {
              coroutineScope.launch {
                 viewModel.deleteItem()
          }
          modifier = modifier.padding(innerPadding)
      )

   7. After deleting the item, navigate back to the inventory screen.
   8. Call ``navigateBack()`` after the ``deleteItem()`` function call.

   .. code:: prettyprint

      onDelete = {
          coroutineScope.launch {
              viewModel.deleteItem()
              navigateBack()
          }

   9. Still within the ``ItemDetailsScreen.kt`` file, scroll to the ``ItemDetailsBody()`` function.

   This function is part of the starter code. This composable displays an alert dialog to get the
   user's confirmation before deleting the item and calls the ``deleteItem()`` function when you tap
   **Yes**.

   .. code:: prettyprint

      // No need to copy over

      @Composable
      private fun ItemDetailsBody(
          itemUiState: ItemUiState,
          onSellItem: () -> Unit,
          onDelete: () -> Unit,
          modifier: Modifier = Modifier
      ) {
          Column(
              /*...*/
          ) {
              //...
             
              if (deleteConfirmationRequired) {
                  DeleteConfirmationDialog(
                      onDeleteConfirm = {
                          deleteConfirmationRequired = false
                          onDelete()
                      },
                      //...
                  )
              }
          }
      }

   When you tap **No**, the app closes the alert dialog. The ``showConfirmationDialog()`` function
   displays the following alert:

   |item delete confirmation pop up|

   10. Run the app.
   11. Select a list element on the **Inventory** screen.
   12. In the **Item Details** screen, tap **Delete**.
   13. Tap **Yes** in the alert dialog, and the app navigates back to the **Inventory** screen.
   14. Confirm that the entity you deleted is no longer in the app database.

   Congratulations on implementing the delete feature!

   +----------------------------------------+-----------------------------------------+
   | |Item details screen with Alert dialog | |Phone screen displaying inventory list |
   | window.|                               | without the deleted item|               |
   +----------------------------------------+-----------------------------------------+


Edit item entity

   Similar to the previous sections, in this section, you add another feature enhancement to the app
   that edits an item entity.

   Here is a quick run through of the steps to edit an entity in the app database:

   -  Add a test to the test get item DAO query.
   -  Populate the text fields and the **Edit Item** screen with the entity details.
   -  Update the entity in the database using Room.


Add DAO test

   1. In ``ItemDaoTest.kt``, add a test called ``daoGetItem_returnsItemFromDB()``.

   .. code:: prettyprint

      @Test
      @Throws(Exception::class)
      fun daoGetItem_returnsItemFromDB()

   2. Define the function. Inside the coroutine, add one item to the database.

   .. code:: prettyprint

      @Test
      @Throws(Exception::class)
      fun daoGetItem_returnsItemFromDB() = runBlocking {
          addOneItemToDb()
      }

   3. Retrieve the entity from the database using the ``itemDao.getItem()`` function and set it to a
      ``val`` named ``item``.

   .. code:: prettyprint

      val item = itemDao.getItem(1)

   4. Compare the actual value with the retrieved value and assert using ``assertEquals()``. Your
      completed test looks like the following:

   .. code:: prettyprint

      @Test
      @Throws(Exception::class)
      fun daoGetItem_returnsItemFromDB() = runBlocking {
          addOneItemToDb()
          val item = itemDao.getItem(1)
          assertEquals(item.first(), item1)
      }

   5. Run the test and ensure it passes.


Populate text fields

   If you run the app, go to the **Item Details** screen, and then click the FAB, you can see that
   the title of the screen now is **Edit Item**. However, all the text fields are empty. In this
   step, you populate the text fields in the **Edit Item** screen with the entity details.

   ====================== ======================
   |3aac7e2c9e7a04b6.png| |cdccb3a8931b4a3.png|
   ====================== ======================

   1. In ``ItemDetailsScreen.kt``, scroll to the ``ItemDetailsScreen`` composable.
   2. In ``FloatingActionButton()``, change the ``onClick`` argument to include
      ``uiState.value.itemDetails.id``, which is the ``id`` of the selected entity. You use this
      ``id`` to retrieve the entity details.

   .. code:: prettyprint

      FloatingActionButton(
          onClick = { navigateToEditItem(uiState.value.itemDetails.id) },
          modifier = /*...*/
      )

   3. In the ``ItemEditViewModel`` class, add an ``init`` block.

   .. code:: prettyprint

      init {

      }

   4. Inside the ``init`` block, launch a coroutine with *``viewModelScope``*\ ``.``\ *``launch``*.

   .. code:: prettyprint

      import kotlinx.coroutines.launch

      viewModelScope.launch { }

   5. Inside the ``launch`` block, retrieve the entity details with
      ``itemsRepository.getItemStream(itemId)``.

   .. code:: prettyprint

      import androidx.lifecycle.viewModelScope
      import kotlinx.coroutines.flow.filterNotNull
      import kotlinx.coroutines.flow.first


      init {
          viewModelScope.launch {
              itemUiState = itemsRepository.getItemStream(itemId)
                  .filterNotNull()
                  .first()
                  .toItemUiState(true)
          }
      }

   In this launch block, you add a filter to return a flow that only contains values that are not
   null. With ``toItemUiState()``, you convert the ``item`` entity to ``ItemUiState``. You pass the
   ``actionEnabled`` value as ``true`` to enable the **Save** button.

   To resolve the ``Unresolved reference: itemsRepository`` error, you need to pass in the
   *``ItemsRepository``* as a dependency to the view model.

   6. Add a constructor parameter to the ``ItemEditViewModel`` class.

   .. code:: prettyprint

      class ItemEditViewModel(
          savedStateHandle: SavedStateHandle,
          private val itemsRepository: ItemsRepository
      )

   7. In the ``AppViewModelProvider.kt`` file, in the ``ItemEditViewModel`` initializer, add the
      ``ItemsRepository`` object as an argument.

   .. code:: prettyprint

      initializer {
          ItemEditViewModel(
              this.createSavedStateHandle(),
              inventoryApplication().container.itemsRepository
          )
      }

   8.  Run the app.
   9.  Go to **Item Details** and tap |73b88f16638608f0.png| FAB.
   10. Notice that the fields populate with the item details.
   11. Edit the stock quantity, or any other field, and tap **Save**.

   Nothing happens! This is because you are not updating the entity in the app database. You fix
   this in the next section.

   ====================== ======================
   |3aac7e2c9e7a04b6.png| |cdccb3a8931b4a3.png|
   ====================== ======================


Update the entity using Room

   In this final task, you add the final pieces of the code to implement the update functionality.
   You define the necessary functions in the ViewModel and use them in the ``ItemEditScreen``.

   It's coding time again!

   1. In ``ItemEditViewModel`` class, add a function called ``updateUiState()`` that takes an
      ``ItemUiState`` object and returns nothing. This function updates the ``itemUiState`` with new
      values that the user enters.

   .. code:: prettyprint

      fun updateUiState(itemDetails: ItemDetails) {
          itemUiState =
              ItemUiState(itemDetails = itemDetails, isEntryValid = validateInput(itemDetails))
      }

   In this function, you assign the passed in ``itemDetails`` to the ``itemUiState`` and update the
   ``isEntryValid`` value. The app enables the **Save** button if ``itemDetails`` is ``true``. You
   set this value to ``true`` *only* if the input that the user enters is valid.

   2. Go to the ``ItemEditScreen.kt`` file.
   3. In the ``ItemEditScreen`` composable, scroll down to the ``ItemEntryBody()`` function call.
   4. Set the ``onItemValueChange`` argument value to the new function ``updateUiState``.

   .. code:: prettyprint

      ItemEntryBody(
          itemUiState = viewModel.itemUiState,
          onItemValueChange = viewModel::updateUiState,
          onSaveClick = { },
          modifier = modifier.padding(innerPadding)
      )

   5. Run the app.
   6. Go to the **Edit Item** screen.
   7. Make one of the entity values empty so that it is invalid. Notice how the **Save** button
      disables automatically.

   +--------------------------------+--------------------------------+--------------------------------+
   | |Item details screen with sell | |Edit Item screen with all     | |Edit Item screen with Save    |
   | button enabled|                | text fields in and save button | button disabled|               |
   |                                | enabled|                       |                                |
   +--------------------------------+--------------------------------+--------------------------------+

   8. Go back to the ``ItemEditViewModel`` class and add a ``suspend`` function called
      ``updateItem()`` that takes nothing. You use this function to save the updated entity to the
      Room database.

   .. code:: prettyprint

      suspend fun updateItem() {
      }

   9.  Inside the ``getUpdatedItemEntry()`` function, add an ``if`` condition to validate the user
       input by using the function ``validateInput()``.
   10. Make a call to the ``updateItem()`` function on the ``itemsRepository``, passing in the
       ``itemUiState.itemDetails.``\ *``toItem``*\ ``()``. Entities that can be added to the Room
       database need to be of the type ``Item``. The completed function looks like the following:

   .. code:: prettyprint

      suspend fun updateItem() {
          if (validateInput(itemUiState.itemDetails)) {
              itemsRepository.updateItem(itemUiState.itemDetails.toItem())
          }
      }

   11. Go back to the ``ItemEditScreen`` composable.You need a coroutine scope to call the
       ``updateItem()`` function. Create a val called ``coroutineScope`` and set it to
       ``rememberCoroutineScope()``.

   .. code:: prettyprint

      import androidx.compose.runtime.rememberCoroutineScope

      val coroutineScope = rememberCoroutineScope()

   12. In the ``ItemEntryBody()`` function call, update the ``onSaveClick`` function argument to
       start a coroutine in the ``coroutineScope``.
   13. Inside the ``launch`` block, call ``updateItem()`` on the ``viewModel`` and navigate back.

   .. code:: prettyprint

      import kotlinx.coroutines.launch

      onSaveClick = {
          coroutineScope.launch {
              viewModel.updateItem()
              navigateBack()
          }
      },

   The completed ``ItemEntryBody()`` function call looks like the following:

   .. code:: prettyprint

      ItemEntryBody(
          itemUiState = viewModel.itemUiState,
          onItemValueChange = viewModel::updateUiState,
          onSaveClick = {
              coroutineScope.launch {
                  viewModel.updateItem()
                  navigateBack()
              }
          },
          modifier = modifier.padding(innerPadding)
      )

   14. Run the app and try editing inventory items. You are now able to edit any item in the
       Inventory app database.

   ====================================== ================================================
   |Edit item screen item details edited| |Item details screen with updated item details|
   ====================================== ================================================

   Congratulations on creating your first app that uses Room to manage the database!


9. Solution code
----------------


   The solution code for this codelab is in the GitHub repo and the branch shown below:

   **Solution Code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-inventory-app/tree/main


10. Learn more
--------------


   Android Developer Documentation

   -  `Debug your database with the Database Inspector <https://developer.android.google.cn/studio/inspect/database>`__
   -  `Save data in a local database using Room <https://developer.android.google.cn/training/data-storage/room>`__
   -  `Test and debug your database \| Android Developers <https://developer.android.google.cn/training/data-storage/room/testing-db>`__

   Kotlin references

   -  `Extensions <https://kotlinlang.org/docs/extensions.html>`__


.. |Add Item screen with item details filled in.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/bae9fd572d154881.png
.. |Phone screen empty inventory| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/fb1fb265e2aa93f9.png
.. |Phone screen with inventory items| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/47cc655ae260796b.png
.. |7b1535d90ee957fa.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/7b1535d90ee957fa.png
.. |9121189f4a0d2613.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/9121189f4a0d2613.png
.. |fba4ed57c7589f7f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/fba4ed57c7589f7f.png
.. |2f0ddde91781d6bd.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/2f0ddde91781d6bd.png
.. |8f66e03d03aac31a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/8f66e03d03aac31a.png
.. |de7761a894d1b2ab.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/de7761a894d1b2ab.png
.. |Item details screen with empty data| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/fc38a289ccb8a947.png
.. |Item details screen with valid item details| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/b0c839d911d5c379.png
.. |Edit item layout with item name item price and quantity in stock felids| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/53bf6bada41dad50.png
.. |item delete confirmation pop up| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/d8e76897bd8f253a.png
.. |aad0ce469e4a3a12.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/aad0ce469e4a3a12.png
.. |Edit item screen with empty felids| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/cdccb3a8931b4a3.png
.. |Item details screen decreases the quantity by one when sell button is tapped| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/3aac7e2c9e7a04b6.png
.. |Item details screen with quantity in stock as 0| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/dbd889a1ac1f3be4.png
.. |Item details screen with sell button disabled| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/48f2748adfe30d47.png
.. |Item details screen with Alert dialog window.| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/5a03d33f03b4d17c.png
.. |Phone screen displaying inventory list without the deleted item| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/c0b2c57bc97325bd.png
.. |3aac7e2c9e7a04b6.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/3aac7e2c9e7a04b6.png
.. |cdccb3a8931b4a3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/cdccb3a8931b4a3.png
.. |73b88f16638608f0.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/73b88f16638608f0.png
.. |3aac7e2c9e7a04b6.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/3aac7e2c9e7a04b6.png
.. |cdccb3a8931b4a3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/cdccb3a8931b4a3.png
.. |Item details screen with sell button enabled| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/d368151eb7b198cd.png
.. |Edit Item screen with all text fields in and save button enabled| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/427ff7e2bf45f6ca.png
.. |Edit Item screen with Save button disabled| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/9aa8fa86a928e1a6.png
.. |Edit item screen item details edited| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/6ed9dac5d3cafeda.png
.. |Item details screen with updated item details| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-update-data-room/img/476f37623617d192.png


â­ Practice: Build Bus Schedule app
====================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-bus-schedule-app


1. Before you begin
-------------------

Introduction

   In the `Persist Data with Room <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-persisting-data-room>`__
   codelab, you learned how to implement a Room database in an Android app. This exercise provides
   the opportunity to gain more familiarity with the implementation of Room databases through an
   independently driven set of steps.

   In this practice set, you take the concepts you learned from the `Persist Data with Room <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-persisting-data-room>`__
   codelab to complete the Bus Schedule app. This app presents the user with a list of bus stops and
   scheduled departures using data provided from a Room database.

   The solution code is available at the end. To make the most of this learning experience, try to
   implement and troubleshoot as much as you can before you look at the provided solution code. It
   is during this hands-on time that you learn the most.


Prerequisites

   -  Android Basics with Compose coursework through the `Persist Data with Room <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-persisting-data-room>`__
      codelab


What you'll need

   -  A computer with internet access and Android Studio
   -  The Bus Schedule starter code


What you'll build

   In this practice set, you complete the Bus Schedule app by implementing a database and then
   delivering data to the UI using the database. A database file in the asset directory found in the
   starter code provides data for the app. You load this data into a database and make it available
   for read usage by the app.

   After you complete the app, it shows a list of bus stops and corresponding arrival times. You can
   click an item in the list to trigger navigation to a detail screen that provides data for that
   stop.

   The completed app shows this data, loaded from a Room database:

   |cdb6f9e79137f323.png|

   |6c59e6f57f59bd27.png|


2. Download the starter code
----------------------------


   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-bus-schedule-app/tree/starter

   **Branch name with starter code:** ``starter``

   1. In Android Studio, open the ``basic-android-kotlin-compose-training-bus-schedule`` folder.
   2. Open the Bus Schedule app code in Android Studio.
   3. Click the **Run** button |65e9e2045e2dc48b.png| to build and run the app.

   The app is expected to display a schedule showing one stop when built from the ``starter`` branch
   code.

   |3603c91854cada9a.png|


3. Add dependencies
-------------------


   Add the following dependencies to the app:


**app/build.gradle.kts**

   .. code:: prettyprint

      implementation("androidx.room:room-ktx:${rootProject.extra["room_version"]}")
      implementation("androidx.room:room-runtime:${rootProject.extra["room_version"]}")
      ksp("androidx.room:room-compiler:${rootProject.extra["room_version"]}")

   You should get the most current stable version of ``room`` from the 
   `Room documentation <https://developer.android.google.cn/jetpack/androidx/releases/room>`__ 
   and add the correct version number. At this moment the latest version is:


**build.gradle.kts**

   .. code:: prettyprint

      set("room_version", "2.5.1")


4. Create a Room entity
-----------------------


   Convert the current Bus Schedule data class into a ``Room Entity``.

   The following image shows a sample of what the final data table looks like, including the schema
   and ``Entity`` property.

   |9587f9a5f035e552.png|


5. Create a data access object
------------------------------


   Create a data access object (DAO) to access the database. The DAO provides a method to retrieve
   all the items in the database and a method to retrieve a single item with the name of the bus
   stop. Make sure to order the schedule by arrival time.


6. Create a database instance
-----------------------------


   Create a Room database that uses the ``Entity`` and your DAO. The database initializes itself
   with data from the ``assets/database/bus_schedule.db`` file in the starter code.


7. Update the ViewModel
-----------------------


   Update the ViewModel to retrieve data from the DAO and provide it to the UI instead of supplying
   sample data. Make sure to leverage both of your DAO methods to supply data for the list and for
   individual stops.


8. Solution code
----------------


   **Solution code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-bus-schedule-app/tree/main

   **Branch name with solution code:** ``main``

.. |cdb6f9e79137f323.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-bus-schedule-app/img/cdb6f9e79137f323.png
.. |6c59e6f57f59bd27.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-bus-schedule-app/img/6c59e6f57f59bd27.png
.. |65e9e2045e2dc48b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-bus-schedule-app/img/65e9e2045e2dc48b.png
.. |3603c91854cada9a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-bus-schedule-app/img/3603c91854cada9a.png
.. |9587f9a5f035e552.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-bus-schedule-app/img/9587f9a5f035e552.png


â­ Save preferences locally with DataStore
===========================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-datastore 


1. Before you begin
-------------------


Introduction

   In this unit, you have learned how to use SQL and Room to save data locally on a device. SQL and
   Room are powerful tools. However, in cases where you don't need to store relational data,
   DataStore can provide a simple solution. The DataStore Jetpack Component is a great way to store
   small and simple data sets with low overhead. DataStore has two different implementations,
   ``Preferences DataStore`` and ``Proto DataStore``.

   -  ``Preferences DataStore`` stores key-value pairs. The values can be Kotlin's basic data types,
      such as ``String``, ``Boolean``, and ``Integer``. It does not store complex datasets. It does
      not require a predefined schema. The primary use case of the ``Preferences Datastore`` is to
      store user preferences on their device.
   -  ``Proto DataStore`` stores custom data types. It requires a predefined schema that maps proto
      definitions with object structures.

   Only ``Preferences DataStore`` is covered in this codelab, but you can read more about
   ``Proto DataStore`` in the `DataStore <https://developer.android.google.cn/topic/libraries/architecture/datastore>`__
   documentation.

   ``Preferences DataStore`` is a great way to store user-controlled settings, and in this codelab,
   you learn how to implement ``DataStore`` to do exactly that!


Prerequisites:

   -  Complete the Android Basics with Compose coursework through the 
      `Read and Update Data with Room <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-update-data-room>`__
      codelab.


What you'll need

   -  A computer with internet access and Android Studio
   -  A device or emulator
   -  The starter code for the Dessert Release app


What you'll build

   The Dessert Release app shows a list of Android releases. The icon in the app bar toggles the
   layout between a grid view and a list view.

   |b6e4bd0e50915b81.png| |24a261db4cf2c6b8.png|

   In its current state, the app does not persist the layout selection. When you close the app, your
   layout selection does not save and the setting returns to the default selection. In this codelab,
   you add ``DataStore`` to the Dessert Release app and use it to store a layout selection
   preference.


2. Download the starter code
----------------------------


   Click the following link to download all the code for this codelab:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-release/archive/refs/heads/starter.zip>`__

   Or if you prefer, you can clone the Dessert Release code from GitHub:

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-release/tree/starter

   **Branch name with starter code:** ``starter``

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-release.git
      $ cd basic-android-kotlin-compose-training-dessert-release
      $ git checkout starter

   1. In Android Studio, open the ``basic-android-kotlin-compose-training-dessert-release`` folder.
   2. Open the Dessert Release app code in Android Studio.


3. Set up dependencies
----------------------


   Add the following to ``dependencies`` in the ``app/build.gradle.kts`` file:

   .. code:: prettyprint

      implementation("androidx.datastore:datastore-preferences:1.0.0")


4. Implement the user preferences repository
--------------------------------------------


   1. In the ``data`` package, create a new class called ``UserPreferencesRepository``.

   |c4c2e90902898001.png|

   2. In the ``UserPreferencesRepository`` constructor, define a private value property to represent
      a ``DataStore`` object instance with a ``Preferences`` type.

   .. code:: prettyprint

      class UserPreferencesRepository(
          private val dataStore: DataStore<Preferences>
      ){
      }

   **Note:** Make sure to use the ``androidx.datastore.preferences.core.Preferences`` import for the
   Preferences class.

   ``DataStore`` stores key-value pairs. To access a value you must define a key.

   3. Create a ``companion object`` inside the ``UserPreferencesRepository`` class.
   4. Use the ``booleanPreferencesKey()`` function to define a key and pass it the name
      ``is_linear_layout``. Similar to SQL table names, the key needs to use an underscore format.
      This key is used to access a boolean value indicating whether the linear layout should be
      shown.

   .. code:: prettyprint

      class UserPreferencesRepository(
          private val dataStore: DataStore<Preferences>
      ){
          private companion object {
              val IS_LINEAR_LAYOUT = booleanPreferencesKey("is_linear_layout")
          }
          ...
      }


Write to the DataStore

   You create and modify the values within a ``DataStore`` by passing a lambda to the ``edit()``
   method. The lambda is passed an instance of ``MutablePreferences``, which you can use to update
   values in the ``DataStore``. All the updates inside this lambda are executed as a single
   transaction. Put another way, the update is *atomic* â€” it happens all at one time. This type of
   update prevents a situation in which some values update but others do not.

   1. Create a suspend function and call it ``saveLayoutPreference()``.
   2. In the ``saveLayoutPreference()`` function, call the ``edit()`` method on the ``dataStore``
      object.

   .. code:: prettyprint

      suspend fun saveLayoutPreference(isLinearLayout: Boolean) {
          dataStore.edit {

          }
      }

   3. To make your code more readable, define a name for the ``MutablePreferences`` provided in the
      lambda body. Use that property to set a value with the key you defined and the boolean passed
      to the ``saveLayoutPreference()`` function.

   .. code:: prettyprint

      suspend fun saveLayoutPreference(isLinearLayout: Boolean) {
          dataStore.edit { preferences ->
              preferences[IS_LINEAR_LAYOUT] = isLinearLayout
          }
      }

   **Note:** The value does not exist in DataStore until this function is called and the value is
   set. By setting up the key-value pair in the ``edit()`` method, the value is defined and
   initialized until the app's cache or data is cleared.


Read from the DataStore

   Now that you have created a way to write ``isLinearLayout`` into ``dataStore``, take the
   following steps to read it:

   1. Create a property in ``UserPreferencesRepository`` of type ``Flow<Boolean>`` called
      ``isLinearLayout``.

   .. code:: prettyprint

      val isLinearLayout: Flow<Boolean> =

   2. You can use the ``DataStore.data`` property to expose ``DataStore`` values. Set
      ``isLinearLayout`` to the ``data`` property of the ``DataStore`` object.

   .. code:: prettyprint

      val isLinearLayout: Flow<Boolean> = dataStore.data

   **Note:** This code does not compile and the ``dataStore.data`` instruction is underlined in red.
   This outcome is expected, as the implementation is not yet complete.

   The ``data`` property is a ``Flow`` of ``Preferences`` objects. The ``Preferences`` object
   contains all the key-value pairs in the DataStore. Each time the data in the DataStore is
   updated, a new ``Preferences`` object is emitted into the ``Flow``.

   3. Use the map function to convert the ``Flow<Preferences>`` into a ``Flow<Boolean>``.

   This function accepts a lambda with the current ``Preferences`` object as a parameter. You can
   specify the key you previously defined to obtain the layout preference. Bear in mind that the
   value might not exist if ``saveLayoutPreference`` hasn't been called yet, so you must also supply
   a default value.

   4. Specify ``true`` to default to the linear layout view.

   **Note:** Remember that until the preference is defined and initialized, it does not exist in the
   ``DataStore``. That is why you must programmatically confirm that the preference exists and
   provide a default value if it does not.

   .. code:: prettyprint

      val isLinearLayout: Flow<Boolean> = dataStore.data.map { preferences ->
          preferences[IS_LINEAR_LAYOUT] ?: true
      }


Exception handling

   Any time you interact with the file system on a device, it's possible that something can fail.
   For example, a file might not exist, or the disk could be full or unmounted. As ``DataStore``
   reads and writes data from files, ``IOExceptions`` can occur when accessing the ``DataStore``.
   You use the ``catch{}`` operator to catch exceptions and handle these failures.

   1. In the companion object, implement an immutable ``TAG`` string property to use for logging.

   .. code:: prettyprint

      private companion object {
          val IS_LINEAR_LAYOUT = booleanPreferencesKey("is_linear_layout")
          const val TAG = "UserPreferencesRepo"
      }

   2. ``Preferences DataStore`` throws an ``IOException`` when an error is encountered while reading
      data. In the ``isLinearLayout`` initialization block, before ``map()``, use the
      ``catch{}`` operator to catch the ``IOException``.

   .. code:: prettyprint

      val isLinearLayout: Flow<Boolean> = dataStore.data
          .catch {}
          .map { preferences ->
              preferences[IS_LINEAR_LAYOUT] ?: true
          }

   3. In the catch block, if there is an ``IOexception``, log the error and emit
      ``emptyPreferences()``. If a different type of exception is thrown, prefer re-throwing that
      exception. By emitting ``emptyPreferences()`` if there is an error, the map function can still
      map to the default value.

   .. code:: prettyprint

      val isLinearLayout: Flow<Boolean> = dataStore.data
          .catch {
              if(it is IOException) {
                  Log.e(TAG, "Error reading preferences.", it)
                  emit(emptyPreferences())
              } else {
                  throw it
              }
          }
          .map { preferences ->
              preferences[IS_LINEAR_LAYOUT] ?: true
          }


5. Initialize the DataStore
---------------------------


   In this codelab, you must handle the dependency injection manually. Therefore, you must manually
   provide the ``UserPreferencesRepository`` class with a ``Preferences DataStore``. Follow these
   steps to inject ``DataStore`` into the ``UserPreferencesRepository``.

   1. Find the ``dessertrelease`` package.
   2. Within this directory, create a new class called ``DessertReleaseApplication`` and implement
      the ``Application`` class. This is the container for your DataStore.

   .. code:: prettyprint

      class DessertReleaseApplication: Application() {
      }

   3. Inside of the ``DessertReleaseApplication.kt`` file, but outside the
      ``DessertReleaseApplication`` class, declare a ``private const val`` called
      ``LAYOUT_PREFERENCE_NAME``.
   4. Assign the ``LAYOUT_PREFERENCE_NAME`` variable the string value ``layout_preferences``, which
      you can then use as the name of the ``Preferences Datastore`` that you instantiate in the next
      step.

   .. code:: prettyprint

      private const val LAYOUT_PREFERENCE_NAME = "layout_preferences"

   5. Still outside the ``DessertReleaseApplication`` class body but in the
      ``DessertReleaseApplication.kt`` file, create a private value property of type
      ``DataStore<Preferences>`` called ``Context.dataStore`` using the ``preferencesDataStore``
      delegate. Pass ``LAYOUT_PREFERENCE_NAME`` for the ``name`` parameter of the
      ``preferencesDataStore`` delegate.

   .. code:: prettyprint

      private const val LAYOUT_PREFERENCE_NAME = "layout_preferences"
      private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(
          name = LAYOUT_PREFERENCE_NAME
      )

   6. Inside the ``DessertReleaseApplication`` class body, create a ``lateinit var`` instance of the
      ``UserPreferencesRepository``.

   .. code:: prettyprint

      private const val LAYOUT_PREFERENCE_NAME = "layout_preferences"
      private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(
          name = LAYOUT_PREFERENCE_NAME
      )

      class DessertReleaseApplication: Application() {
          lateinit var userPreferencesRepository: UserPreferencesRepository
      }

   7. Override the ``onCreate()`` method.

   .. code:: prettyprint

      private const val LAYOUT_PREFERENCE_NAME = "layout_preferences"
      private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(
          name = LAYOUT_PREFERENCE_NAME
      )

      class DessertReleaseApplication: Application() {
          lateinit var userPreferencesRepository: UserPreferencesRepository

          override fun onCreate() {
              super.onCreate()
          }
      }

   8. Inside the ``onCreate()`` method, initialize ``userPreferencesRepository`` by constructing a
      ``UserPreferencesRepository`` with ``dataStore`` as its parameter.

   .. code:: prettyprint

      private const val LAYOUT_PREFERENCE_NAME = "layout_preferences"
      private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(
          name = LAYOUT_PREFERENCE_NAME
      )

      class DessertReleaseApplication: Application() {
          lateinit var userPreferencesRepository: UserPreferencesRepository

          override fun onCreate() {
              super.onCreate()
              userPreferencesRepository = UserPreferencesRepository(dataStore)
          }
      }

   9. Add the following line inside the ``<application>`` tag in the ``AndroidManifest.xml`` file.

   .. code:: prettyprint

      <application
          android:name=".DessertReleaseApplication"
          ...
      </application>

   This approach defines ``DessertReleaseApplication`` class as the entry point of the app. The
   purpose of this code is to initialize the dependencies defined in the
   ``DessertReleaseApplication`` class before launching the ``MainActivity``.


6. Use the UserPreferencesRepository
------------------------------------


Provide the repository to the ViewModel

   Now that the ``UserPreferencesRepository`` is available through dependency injection, you can use
   it in ``DessertReleaseViewModel``.

   1. In the ``DessertReleaseViewModel``, create a ``UserPreferencesRepository`` property as a
      constructor parameter.

   .. code:: prettyprint

      class DessertReleaseViewModel(
          private val userPreferencesRepository: UserPreferencesRepository
      ) : ViewModel() {
          ...
      }

   2. Within the ``ViewModel``'s companion object, in the ``viewModelFactory initializer`` block,
      obtain an instance of the ``DessertReleaseApplication`` using the following code.

   .. code:: prettyprint

          ...
          companion object {
              val Factory: ViewModelProvider.Factory = viewModelFactory {
                  initializer {
                      val application = (this[APPLICATION_KEY] as DessertReleaseApplication)
                      ...
                  }
              }
          }
      }

   3. Create an instance of the ``DessertReleaseViewModel`` and pass the
      ``userPreferencesRepository``.

   .. code:: prettyprint

          ...
          companion object {
              val Factory: ViewModelProvider.Factory = viewModelFactory {
                  initializer {
                      val application = (this[APPLICATION_KEY] as DessertReleaseApplication)
                      DessertReleaseViewModel(application.userPreferencesRepository)
                  }
              }
          }
      }

   The ``UserPreferencesRepository`` is now accessible by the ViewModel. The next steps are to use
   the read and write capabilities of the ``UserPreferencesRepository`` that you implemented
   previously.


Store the layout preference

   1. Edit the ``selectLayout()`` function in the ``DessertReleaseViewModel`` to access the
      preferences repository and update the layout preference.
   2. Recall that writing to the ``DataStore`` is done asynchronously with a ``suspend`` function.
      Start a new Coroutine to call the preference repository's ``saveLayoutPreference()`` function.

   .. code:: prettyprint

      fun selectLayout(isLinearLayout: Boolean) {
          viewModelScope.launch {
              userPreferencesRepository.saveLayoutPreference(isLinearLayout)
          }
      }


Read the layout preference

   In this section, you refactor the existing ``uiState: StateFlow`` in the ``ViewModel`` to reflect
   the ``isLinearLayout: Flow`` from the repository.

   1. Delete the code that initializes the ``uiState`` property to
      ``MutableStateFlow(DessertReleaseUiState)``.

   .. code:: prettyprint

      val uiState: StateFlow<DessertReleaseUiState> =

   The linear layout preference from the repository has two possible values, true or false, in the
   form of a ``Flow<Boolean>``. This value must map to a UI state.

   2. Set the ``StateFlow`` to the result of the ``map()`` collection transformation called on the
      ``isLinearLayout Flow``.

   .. code:: prettyprint

      val uiState: StateFlow<DessertReleaseUiState> =
          userPreferencesRepository.isLinearLayout.map { isLinearLayout ->
      }

   3. Return an instance of the ``DessertReleaseUiState`` data class, passing the
      ``isLinearLayout Boolean``. The screen uses this UI state to determine the correct strings and
      icons to display.

   .. code:: prettyprint

      val uiState: StateFlow<DessertReleaseUiState> =
          userPreferencesRepository.isLinearLayout.map { isLinearLayout ->
              DessertReleaseUiState(isLinearLayout)
          }

   ``UserPreferencesRepository.isLinearLayout`` is a ``Flow`` which is
   `cold <https://developer.android.google.cn/kotlin/flow/stateflow-and-sharedflow#sharein>`__.
   However, for providing state to the UI, it's better to use a *hot flow,* like ``StateFlow``, so
   that the state is always available immediately to the UI.

   4. Use the ``stateIn()`` function to convert a ``Flow`` to a ``StateFlow``.
   5. The ``stateIn()`` function accepts three parameters: ``scope``, ``started``, and
      ``initialValue``. Pass in ``viewModelScope``, ``SharingStarted.WhileSubscribed(5_000)``, and
      ``DessertReleaseUiState()`` for these parameters, respectively.

   .. code:: prettyprint

      val uiState: StateFlow<DessertReleaseUiState> =
          userPreferencesRepository.isLinearLayout.map { isLinearLayout ->
              DessertReleaseUiState(isLinearLayout)
          }
      .stateIn(
              scope = viewModelScope,
              started = SharingStarted.WhileSubscribed(5_000),
              initialValue = DessertReleaseUiState()
          )

   **Note:** Please read `Migrating from LiveData to Kotlin's Flow <https://medium.com/androiddevelopers/migrating-from-livedata-to-kotlins-flow-379292f419fb>`__
   to learn more about the ``started`` parameter and why ``SharingStarted.WhileSubscribed(5_000)``
   is passed to it.

   6. Launch the app. Notice that you can click on the toggle icon to toggle between a grid layout
      and a linear layout.

   **Note:** Try toggling the layout and closing the app. Reopen the app and notice that your layout
   preference was saved.

   |b6e4bd0e50915b81.png| |24a261db4cf2c6b8.png|

   Congratulations! You successfully added ``Preferences DataStore`` to your app to save the user's
   layout preference.


7. Get the solution code
------------------------


   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-release.git
      $ cd basic-android-kotlin-compose-training-dessert-release
      $ git checkout main

   Alternatively, you can download the repository as a zip file, unzip it, and open it in Android
   Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-release/archive/refs/heads/main.zip>`__

   **Note:** The solution code is in the ``main`` branch of the downloaded repository.

   If you want to see the solution code, `view it on GitHub <https://github.com/google-developer-training/basic-android-kotlin-compose-training-dessert-release/tree/main>`__.


.. |b6e4bd0e50915b81.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-datastore/img/b6e4bd0e50915b81.png
.. |24a261db4cf2c6b8.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-datastore/img/24a261db4cf2c6b8.png
.. |c4c2e90902898001.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-datastore/img/c4c2e90902898001.png


â­ Project: Create a Flight Search app
=======================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-flight-search


1. Before you begin
-------------------


Prerequisites


   -  Basic knowledge of SQL for reading and manipulating a relational database.
   -  Ability to use Room in an Android app to read from and write to a database.
   -  Ability to use DataStore to store simple data.
   -  Ability to build moderately complex user interfaces with Compose.


What you'll build


   -  An Android app that asks the user for a departure airport, searches a pre-populated database
      to present a list of flights that depart from that airport, lets the user save favorite
      flights, and updates the database with Room.


What you'll need


   -  A computer with Android Studio


2. Overview
-----------


   Congratulations on your completion of Unit 6! You started with a general overview of relational
   databases and Structured Query Language (SQL), integrated a relational database into an app with
   Room, and learned about Preferences DataStore for persisting settings and UI state. It's time to
   put everything you've learned into practice.

   In this project, you'll build the Flight Search app in which users enter an airport and can view
   a list of destinations using that airport as a departure. This project gives you the opportunity
   to practice your skills with SQL, Room, and DataStore by offering you a set of app requirements
   that you must fulfill. In particular, you need the Flight Search app to meet the following
   requirements:

   -  Provide a text field for the user to enter an airport name or International Air Transport
      Association (IATA) airport identifier.
   -  Query the database to provide autocomplete suggestions as the user types.
   -  When the user chooses a suggestion, generate a list of available flights from that airport,
      including the IATA identifier and airport name to other airports in the database.
   -  Let the user save favorite individual routes.
   -  When no search query is entered, display all the user-selected favorite routes in a list.
   -  Save the search text with Preferences DataStore. When the user reopens the app, the search
      text, if any, needs to prepopulate the text field with appropriate results from the database.

   We've provided a prepopulated database for this project. However, the expectation is for you to
   build the app from scratch per the requirementsâ€”practice for the actual work you do as an Android
   developer. This project is also a good chance to revisit or further refine your UI building
   skills with Compose, as you haven't needed to do much UI work since Unit 4.


3. Get the flights database
---------------------------


   The data for this app comes from the flights database. The flights database contains two tables,
   **airport** and **favorite**.

   The **airport** table contains the following schema.

   ========== ============= ===============================
   **Column** **Data type** **Description**
   id         INTEGER       Unique identifier (primary key)
   iata_code  VARCHAR       3 letter IATA code
   name       VARCHAR       Full airport name
   passengers INTEGER       Number of passengers per year
   ========== ============= ===============================

   The **favorite** table contains the following schema.

   ================ ============= ===============================
   **Column**       **Data type** **Description**
   id               INTEGER       Unique identifier (primary key)
   departure_code   VARCHAR       IATA code for departure
   destination_code VARCHAR       IATA code for destination
   ================ ============= ===============================

   You can use the airport table to search for airports and build a list of potential flights. You
   use the favorite table, which is initially empty, to save pairs of departure and arrival
   destinations selected by the user.

   Download the ``flight_search.db`` file from the ``project`` branch of the SQL Basics GitHub
   repository `here <https://github.com/google-developer-training/android-basics-kotlin-sql-basics-app/tree/project>`__.


4. Plan your app
----------------


Plan your UI


   You're welcome to design your app however you like. As a guide, the following descriptions and
   images is an example of what a user might expect to see in the app.

   When the user first opens the app, they see an empty screen with a text field, prompting for an
   airport.

   When the user starts typing, the app displays a list of autocomplete suggestions that match
   either the airport name or identifier.

   |38e2daa4d7d3ce47.png|

   When the user selects a suggestion, the app displays a list of all possible flights from that
   airport. Each item includes the identifier and names for both airports, and a button to save the
   destination as a favorite. Feel free to experiment with the layout so long as it conveys all
   necessary information.

   |555d1fda9bd01095.png|

   When the user clears the search box or does not enter a search query, the app displays a list of
   saved favorite destinations, if any exist.

   |844c9efbca15b5b1.png|

   **Tip:** Use a ``LazyColumn`` to display autocomplete suggestions and search results. You might
   want to wrap your layout in a Box and use animation APIs to display the autocomplete suggestions
   in front of the search results list. Your UI then has two lazy columns: the search results, which
   the app always displays, and the autocomplete suggestions, which the app displays conditionally
   while the user types.


Use Room to integrate the flights database


   In order to implement the features above, you need to leverage your knowledge of SQL and Room.
   The database already consists of two tables, **airport** and **favorite**, and you need entities
   for each one. Select the appropriate Kotlin data types so that you can access the values in each
   table.

   Additionally, you need to consider the following requirements when querying the flights database
   and persisting data:

   -  Search for autocomplete suggestions in the airport table. Keep in mind that the user might
      already know the airport code, so you need to check their input against the ``iata_code``
      column, in addition to the ``name`` column, when searching for text. Remember that you can use
      the ``LIKE`` keyword to perform text searches.
   -  Show more frequently visited airports in descending order by sorting on the passengers column.
   -  Assume that every airport has flights to every other airport in the database (except for
      itself).
   -  When no text is in the search box, display a list of favorite flights, showing the departure
      and destination. As the favorite table only includes columns for the airport codes, you're not
      expected to show the airport names in this list.
   -  Perform all database querying with SQL and Room APIs. The whole point is to NOT load your
      entire database into memory at once, only to retrieve the required data as needed.


Persist user state with Preferences DataStore


   In addition to SQL and Room, you also know how to persist individual values like user settings.
   For the Flight Search app, you need to store the user's search string in Preferences DataStore so
   that it populates when the user relaunches the app. If the text field is empty when the user
   exits the app, then the list of favorite flights needs to display instead.


5. Build the Flight Search app
------------------------------


   Now that you've read through all the requirements, it's time to build your app. Although this
   unit focuses exclusively on data persistence, it's important to continue to get cumulative
   practice. While you've seen example screenshots of the Flight Search app in action, this project
   is your opportunity to make the app your own and stand out.

   Although these exact tasks are unfamiliar, you already know all the core concepts necessary to
   build this project. If you get stuck or need a refresher, you can refer to the previous codelabs.

   The following might be useful to you as you work on your project:

   -  `Use SQL to read and write to a database <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-sql>`__
   -  `Persist data with Room <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-persisting-data-room>`__
   -  `Read and update data with Room <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-update-data-room>`__
   -  `Save preferences locally with DataStore <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-datastore>`__

   Most importantly, enjoy the process! Learning is a journey. Even if you find this project
   challenging, you'll probably learn something new and then find the same problems easy to solve
   the next time. Have fun, and see you in the next unit!

.. |38e2daa4d7d3ce47.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-flight-search/img/38e2daa4d7d3ce47.png
.. |555d1fda9bd01095.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-flight-search/img/555d1fda9bd01095.png
.. |844c9efbca15b5b1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-flight-search/img/844c9efbca15b5b1.png


ğŸš€ Background work with WorkManager
===================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-workmanager


1. Before you begin
--------------------------------------------------------------------------------

   This codelab covers `WorkManager <https://developer.android.google.cn/arch/work>`__, a
   backwards compatible, flexible, and simple library for deferrable background work.
   ``WorkManager`` is the recommended task scheduler on Android for deferrable work, with a
   guarantee to execute.


Prerequisites

   -  Knowledge of `StateFlow <https://developer.android.google.cn/kotlin/flow/stateflow-and-sharedflow>`__
      and `ViewModel <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__.
      If you're new to these classes, check out the `ViewModel and State in Compose Codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-viewmodel-and-state>`__
      (specifically for ``ViewModel`` and ``State``) or `Read and update data with Room Codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-update-data-room>`__
      (specifically for ``Flow`` and ``StateFlow``).
   -  Knowledge of repositories and dependency injection. For a refresher, check out 
      `Add repository and Manual DI <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-add-repository>`__.
   -  Able to implement coroutines in your app.


What you'll learn

   -  How to `add WorkManager <https://developer.android.google.cn/guide/background/persistent/getting-started>`__
      to your project.
   -  How to `schedule a simple task <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#schedule_one-time_work>`__.
   -  How to configure `input and output parameters for workers <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#input_output>`__.
   -  How to `chain workers <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work>`__.


What you'll do

   -  Modify a starter app to use WorkManager.
   -  Implement a work request to blur an image.
   -  Implement a serial group of work by chaining work.
   -  Pass data into and out of the work being scheduled.


What you'll need

   -  The latest stable version of Android Studio
   -  An internet connection


2. App overview
--------------------------------------------------------------------------------

   These days, smartphones are almost *too* good at taking pictures. Gone are the days when
   a photographer might take a reliably blurry picture of something mysterious.

   In this codelab, you'll work on Blur-O-Matic, an app that blurs photos and saves the
   results to a file. Was that the `Loch Ness monster or a toy submarine? <https://en.wikipedia.org/wiki/Loch_Ness_Monster#%22Surgeon's_photograph%22_(1934)>`__
   With Blur-O-Matic, no one will ever know!

   ===================== ======================
   |2bdb6fdc2567e96.png| |10c653bb5b84c4b2.png|
   ===================== ======================

   The screen has radio buttons where you can select how blurry you'd like your image to
   be. Clicking the **Start** button blurs and saves the image.

   Right now, the app does not apply any blurring nor save the final image.

   This codelab focuses on adding WorkManager to the app, creating workers to clean up
   temporary files that are created in blurring an image, blurring an image, and saving a
   final copy of the image which you can view when you click the **See File** button. You
   also learn how to monitor the status of the background work and update the app's UI
   accordingly.


3. Explore the Blur-O-Matic starter app
--------------------------------------------------------------------------------


Get the starter code

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-workmanager/archive/refs/heads/starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-workmanager.git
      $ cd basic-android-kotlin-compose-training-workmanager
      $ git checkout starter

   **Note:** The starter code is in the ``starter`` branch of the cloned repository.

   You can browse the code for the Blur-o-matic app in this
   `GitHub <https://github.com/google-developer-training/basic-android-kotlin-compose-training-workmanager/tree/starter>`__
   repository.


Run starter code

   To familiarize yourself with the starter code, complete the following steps:

   1. Open the project with the starter code in Android Studio.
   2. Run the app on an Android device or an emulator.

   |2bdb6fdc2567e96.png|

   The screen has radio buttons that let you select the amount of blur for your image. When
   you click the **Start** button, the app blurs and saves the image.

   Right now, the app does not apply any amount of blur when you click the **Start**
   button.


Starter code walkthrough

   In this task, you familiarize yourself with the structure of the project. The following
   lists provide a walkthrough of the important files and folders in the project.

   -  ``WorkerUtils``: Convenience methods which you later use to display ``Notifications``
      and code to save a bitmap to file.
   -  ``BlurViewModel``: This view model stores the state of the app and interacts with the
      repository.
   -  ``WorkManagerBluromaticRepository``: The class where you start the background work
      with WorkManager.
   -  ``Constants``: A static class with some constants you use during the codelab.
   -  ``BluromaticScreen``: Contains composable functions for the UI and interacts with the
      ``BlurViewModel``. The composable functions show the image and include radio
      buttons to select the desired blur level.


4. What is WorkManager?
--------------------------------------------------------------------------------

   WorkManager is part of `Android Jetpack <http://d.android.com/jetpack>`__ and an
   `Architecture Component <http://d.android.com/arch>`__ for background work that needs a
   combination of opportunistic and guaranteed execution. Opportunistic execution means
   that WorkManager does your background work as soon as it can. Guaranteed execution means
   that WorkManager takes care of the logic to start your work under a variety of
   situations, even if you navigate away from your app.

   WorkManager is an incredibly flexible library that has many additional benefits. Some of
   these benefits include:

   -  Support for both asynchronous one-off and periodic tasks.
   -  Support for constraints, such as network conditions, storage space, and charging
      status.
   -  Chaining of complex work requests, such as running work in parallel.
   -  Output from one work request used as input for the next.
   -  Handling API-level compatibility back to API level 14 (see note).
   -  Working with or without Google Play services.
   -  Following system health best practices.
   -  Support to easily display state of work requests in the app's UI.

   **Note:** WorkManager sits on top of a few APIs, such as
   `JobScheduler <https://developer.android.google.cn/reference/android/app/job/JobScheduler.html>`__
   and `AlarmManager <https://developer.android.google.cn/reference/android/app/AlarmManager>`__.
   WorkManager picks the right APIs to use based on conditions like the user's device API
   level. To learn more, check out `Schedule tasks with WorkManager <https://developer.android.google.cn/topic/libraries/architecture/workmanager/>`__
   and the `WorkManager documentation <https://developer.android.google.cn/reference/androidx/work/WorkManager>`__.


5. When to use WorkManager
--------------------------------------------------------------------------------

   The WorkManager library is a good choice for tasks that you need to complete. The
   running of these tasks is not dependent on the app continuing to run after the work is
   enqueued. The tasks run even if the app is closed or the user returns to the home
   screen.

   Some examples of tasks that are a good use of WorkManager:

   -  Periodically querying for latest news stories.
   -  Applying filters to an image and then saving the image.
   -  Periodically syncing local data with the network.

   WorkManager is one option for running a task off of the main thread but it is not a
   catch-all for running every type of task off of the main thread.
   `Coroutines <https://developer.android.google.cn/kotlin/coroutines>`__ are another
   option that previous codelabs discuss.

   For more details about when to use WorkManager, check out the 
   `Guide to background work <https://d.android.com/guide/background/>`__.


6. Add WorkManager to your app
--------------------------------------------------------------------------------

   ``WorkManager`` requires the following gradle dependency. **This is already included**
   in the build file:

   **app/build.gradle.kts**

   .. code:: prettyprint

      dependencies {
          // WorkManager dependency
          implementation("androidx.work:work-runtime-ktx:2.8.1")
      }

   You must use the most current `stable release <https://developer.android.google.cn/jetpack/androidx/releases/work>`__ 
   version of ``work-runtime-ktx`` in your app.

   If you change the version, make sure to click **Sync Now** to sync your project with the
   updated gradle files.


7. WorkManager Basics
--------------------------------------------------------------------------------

   There are a few WorkManager classes you need to know about:

   -  `Worker <https://developer.android.google.cn/reference/androidx/work/Worker>`__ 
      and `CoroutineWorker <https://developer.android.google.cn/reference/androidx/work/CoroutineWorker>`__:
      Worker is a class that performs work synchronously on a background thread. As we are
      interested in asynchronous work, we can use CoroutineWorker, which has
      interoperability with Kotlin Coroutines. In this app, you extend from the
      ``CoroutineWorker`` class and override the `doWork() <https://developer.android.google.cn/reference/androidx/work/CoroutineWorker#doWork()>`__
      method. This method is where you put the code for the actual work you want to perform
      in the background.

   -  `WorkRequest <https://developer.android.google.cn/reference/androidx/work/WorkRequest.html>`__:
      This class represents a request to do some work. A ``WorkRequest`` is where you
      define if the worker needs to be run once or periodically.
      `Constraints <https://developer.android.google.cn/reference/androidx/work/Constraints.html>`__
      can also be placed on the ``WorkRequest`` that require certain conditions are met
      before the work runs. One example is that the device is charging before starting the
      requested work. You pass in your ``CoroutineWorker`` as part of creating your
      ``WorkRequest``.

   -  `WorkManager <https://developer.android.google.cn/reference/androidx/work/WorkManager.html>`__:
      This class actually schedules your ``WorkRequest`` and makes it run. It schedules a
      ``WorkRequest`` in a way that spreads out the load on system resources, while
      honoring the constraints you specify.

   In your case, you define a new ``BlurWorker`` class, which contains the code to blur an
   image. When you click the **Start** button, WorkManager creates and then enqueues a
   ``WorkRequest`` object.


8. Create the BlurWorker
--------------------------------------------------------------------------------

   In this step, you take an image in the ``res/drawable`` folder called
   ``android_cupcake.png`` and run a few functions on it in the background. These functions
   blur the image.

   1. Right-click on the package ``com.example.bluromatic.workers`` in your Android project
      pane and select **New -> Kotlin Class/File**.

   2. Name the new Kotlin class ``BlurWorker``. Extend it from ``CoroutineWorker`` with the
      required constructor parameters.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      import androidx.work.CoroutineWorker
      import androidx.work.WorkerParameters
      import android.content.Context

      class BlurWorker(ctx: Context, params: WorkerParameters) : CoroutineWorker(ctx, params) {
      }

   The ``BlurWorker`` class extends the `CoroutineWorker <https://developer.android.google.cn/reference/androidx/work/CoroutineWorker>`__
   class instead of the more general `Worker <https://developer.android.google.cn/reference/androidx/work/Worker>`__
   class. The ``CoroutineWorker`` class implementation of the ``doWork()`` is a suspending
   function, which lets it run asynchronous code that a ``Worker`` cannot do. As detailed
   in the guide `Threading in WorkManager <https://developer.android.google.cn/guide/background/persistent/threading>`__,
   "CoroutineWorker is the recommended implementation for Kotlin users."

   At this point, Android Studio draws a red wiggly line under ``class BlurWorker`` that
   indicates an error.

   |9e96aa94f82c6990.png|

   If you place your cursor over the text ``class BlurWorker``, the IDE displays a popup
   with additional information regarding the error.

   |cdc4bbefa7a9912b.png|

   The error message indicates that you did not override the ``doWork()`` method as
   required.

   In the ``doWork()`` method, write code to blur the cupcake image shown.

   Follow these steps to fix the error and implement the ``doWork()`` method:

   1. Place your cursor inside the class code by clicking on the text "BlurWorker".
   2. From the Android Studio menu, select **Code > Override Methods...**
   3. From the **Override Members** popup, select ``doWork()``.
   4. Click **OK**.

   |8f495f0861ed19ff.png|

   5. Immediately before the class declaration, create a variable named ``TAG`` and assign
      it the value ``BlurWorker``. Note that this variable is not specifically related to
      the ``doWork()`` method, but you use it later in calls to ``Log()``.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      private const val TAG = "BlurWorker"

      class BlurWorker(ctx: Context, params: WorkerParameters) : CoroutineWorker(ctx, params) {
      ... 

   6. To better see when work executes, you need to utilize ``WorkerUtil``'s
      ``makeStatusNotification()`` function. This function lets you easily display a
      notification banner at the top of the screen.

   Inside the ``doWork()`` method, use the ``makeStatusNotification()`` function to
   display a status notification and notify the user that the blur worker has started and
   is blurring the image.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      import com.example.bluromatic.R
      ...
      override suspend fun doWork(): Result {

          makeStatusNotification(
              applicationContext.resources.getString(R.string.blurring_image),
              applicationContext
          )
      ...

   7. Add a ``return try...catch`` code block, which is where the actual blur image work is
      performed.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      ...
              makeStatusNotification(
                  applicationContext.resources.getString(R.string.blurring_image),
                  applicationContext
              )

              return try {
              } catch (throwable: Throwable) {
              }
      ...

   8. In the ``try`` block, add a call to ``Result.success()``.
   9. In the ``catch`` block, add a call to ``Result.failure()``.

   **Note:** WorkManager uses ``Result.success()`` and ``Result.failure()`` to indicate the
   final status of the work request being performed.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      ...
              makeStatusNotification(
                  applicationContext.resources.getString(R.string.blurring_image),
                  applicationContext
              )

              return try {
                  Result.success()
              } catch (throwable: Throwable) {
                  Result.failure()
              }
      ...

   10. In the ``try`` block, create a new variable named ``picture`` and populate it with
       the bitmap returned from calling the `BitmapFactory.decodeResource() <https://developer.android.google.cn/reference/android/graphics/BitmapFactory#decodeResource(android.content.res.Resources,%20int)>`__
       method and passing in the application's resource package and the resource id of the
       cupcake image.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      ...
              return try {
                  val picture = BitmapFactory.decodeResource(
                      applicationContext.resources,
                      R.drawable.android_cupcake
                  )

                  Result.success()
      ...

   11. Blur the bitmap by calling the ``blurBitmap()`` function and pass in the ``picture``
       variable and a value of ``1`` (one) for the ``blurLevel`` parameter.
   12. Save the result in a new variable named ``output``.

   **Note:** In later instructions, you will be passing a variable for the ``blurLevel``
   parameter.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      ...
                  val picture = BitmapFactory.decodeResource(
                      applicationContext.resources,
                      R.drawable.android_cupcake
                  )

                  val output = blurBitmap(picture, 1)

                  Result.success()
      ...

   13. Create a new variable ``outputUri`` and populate it with a call to the
       ``writeBitmapToFile()`` function.
   14. In the call to ``writeBitmapToFile()``, pass the application context and the
       ``output`` variable as arguments.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      ...
                  val output = blurBitmap(picture, 1)

                  // Write bitmap to a temp file
                  val outputUri = writeBitmapToFile(applicationContext, output)

                  Result.success()
      ...

   15. Add code to display a notification message to the user that contains the
       ``outputUri`` variable.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      ...
                  val outputUri = writeBitmapToFile(applicationContext, output)

                  makeStatusNotification(
                      "Output is $outputUri",
                      applicationContext
                  )

                  Result.success()
      ...

   16. In the ``catch`` block, log an error message to indicate an error occurred while
       attempting to blur the image. The call to ``Log.e()`` passes the previously defined
       ``TAG`` variable, an appropriate message, and the exception being thrown.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      ...
              } catch (throwable: Throwable) {
                  Log.e(
                      TAG,
                      applicationContext.resources.getString(R.string.error_applying_blur),
                      throwable
                  )
                  Result.failure()
              }
      ...

   A ``CoroutineWorker,`` by default, runs as ``Dispatchers.Default`` but can be changed by
   calling ``withContext()`` and passing in the desired dispatcher.

   17. Create a ``withContext()`` block.
   18. Inside the call to ``withContext()`` pass ``Dispatchers.IO`` so the lambda function
       runs in a special thread pool for potentially blocking IO operations.
   19. Move the previously written ``return try...catch`` code into this block.

   .. code:: prettyprint

      ...
              return withContext(Dispatchers.IO) {

                  return try {
                      // ...
                  } catch (throwable: Throwable) {
                      // ...
                  }
              }
      ...

   Android Studio displays the following error because you cannot call ``return`` from
   within a lambda function.

   |2d81a484b1edfd1d.png|

   This error can be fixed by adding a label as shown in the popup.

   .. code:: prettyprint

      ...
                  //return try {
                  return@withContext try {
      ...

   Because this Worker runs very quickly, it is recommended to add a delay in the code to
   emulate slower running work.

   20. Inside the ``withContext()`` lambda, add a call to the ``delay()`` utility function
       and pass in the ``DELAY_TIME_MILLIS`` constant. This call is strictly for the
       codelab to provide a delay between notification messages.

   .. code:: prettyprint

      import com.example.bluromatic.DELAY_TIME_MILLIS
      import kotlinx.coroutines.delay

      ...
              return withContext(Dispatchers.IO) {

                  // This is an utility function added to emulate slower work.
                  delay(DELAY_TIME_MILLIS)


                      val picture = BitmapFactory.decodeResource(
      ...


9. Update WorkManagerBluromaticRepository
--------------------------------------------------------------------------------

   The repository handles all interactions with the WorkManager. This structure adheres to
   the `design principle of separation of concerns <https://en.wikipedia.org/wiki/Separation_of_concerns>`__ 
   and is a recommended Android architecture pattern.

   -  In the ``data/WorkManagerBluromaticRepository.kt`` file, inside the
      ``WorkManagerBluromaticRepository`` class, create a private variable named
      ``workManager`` and store a ``WorkManager`` instance in it by calling
      ``WorkManager.getInstance(context)``.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      import androidx.work.WorkManager
      ...
      class WorkManagerBluromaticRepository(context: Context) : BluromaticRepository {

          // New code
          private val workManager = WorkManager.getInstance(context)
      ...


Create and enqueue the WorkRequest in WorkManager

   Alright, time to make a ``WorkRequest`` and tell WorkManager to run it! There are two
   types of ``WorkRequest``s:

   -  ``OneTimeWorkRequest``: A ``WorkRequest`` that only executes once.
   -  ``PeriodicWorkRequest``: A ``WorkRequest`` that executes repeatedly on a cycle.

   You only want the image to blur one time when the **Start** button is clicked.

   This work occurs in the ``applyBlur()`` method, which you call when you click the
   **Start** button.

   The following steps are completed inside the ``applyBlur()`` method.

   1. Populate a new variable named ``blurBuilder`` by creating a ``OneTimeWorkRequest``
      for the blur worker and calling the ``OneTimeWorkRequestBuilder`` extension function
      from `WorkManager KTX <https://developer.android.google.cn/kotlin/ktx#workmanager>`__.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      import com.example.bluromatic.workers.BlurWorker
      import androidx.work.OneTimeWorkRequestBuilder
      ...
      override fun applyBlur(blurLevel: Int) {
          // Create WorkRequest to blur the image
          val blurBuilder = OneTimeWorkRequestBuilder<BlurWorker>()
      }

   2. Start the work by calling the ``enqueue()`` method on your ``workManager`` object.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      import com.example.bluromatic.workers.BlurWorker
      import androidx.work.OneTimeWorkRequestBuilder
      ...
      override fun applyBlur(blurLevel: Int) {
          // Create WorkRequest to blur the image
          val blurBuilder = OneTimeWorkRequestBuilder<BlurWorker>()

          // Start the work
          workManager.enqueue(blurBuilder.build())
      }

   3. Run the app and see the notification when you click the **Start** button.

   At this time, the image is blurred the same amount, regardless of which option you
   select. In later steps, the blur amount changes based on the option selected.

   **Note:** The app requires notifications to be enabled. If a notification is not shown,
   navigate to **Settings > Apps > Blur-O-Matic > Notifications** and enable **All
   Blur-O-Matic notifications**.

   |f2b3591b86d1999d.png|

   To confirm that the image successfully blurs, you can open the 
   `Device Explorer <https://developer.android.google.cn/studio/debug/device-file-explorer>`__ 
   in Android Studio:

   |6bc555807e67f5ad.png|

   Then navigate to **data > data > com.example.bluromatic > files > blur_filter_outputs >
   <URI>** and confirm that the cupcake image is in fact blurred:

   |fce43c920a61a2e3.png|


10. Input data and output data
--------------------------------------------------------------------------------

   Blurring the image asset in the resources directory is all well and good, but for
   Blur-O-Matic to really be the revolutionary image editing app it's destined to be, you
   need to let the user blur the image they see on screen and then show them the blurred
   result.

   To do this, we provide the URI of the cupcake image displayed as the input to our
   ``WorkRequest`` and then use the output of our ``WorkRequest`` to display the final
   blurred image.

   |ce8ec44543479fe5.png|

   Input and output are passed in and out of a worker via
   `Data <http://d.android.com/reference/androidx/work/Data>`__ objects. ``Data``
   objects are lightweight containers for key/value pairs. They are meant to store a small
   amount of data that might pass into and out of a worker from the ``WorkRequest``.

   In the next step, you're going to pass the URI to the ``BlurWorker`` by creating an
   input data object.


Create input data object

   1. In the ``data/WorkManagerBluromaticRepository.kt`` file, inside the
      ``WorkManagerBluromaticRepository`` class, create a new private variable named
      ``imageUri``.
   2. Populate the variable with the image URI by calling the context method
      ``getImageUri()``.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      import com.example.bluromatic.getImageUri
      ...
      class WorkManagerBluromaticRepository(context: Context) : BluromaticRepository {

          private var imageUri: Uri = context.getImageUri() // <- Add this
          private val workManager = WorkManager.getInstance(context)
      ...

   The app code contains the ``createInputDataForWorkRequest()`` helper function for
   creating input data objects.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      // For reference - already exists in the app
      private fun createInputDataForWorkRequest(blurLevel: Int, imageUri: Uri): Data {
          val builder = Data.Builder()
          builder.putString(KEY_IMAGE_URI, imageUri.toString()).putInt(BLUR_LEVEL, blurLevel)
          return builder.build()
      }

   First the helper function creates a
   `Data.Builder <https://developer.android.google.cn/reference/kotlin/androidx/work/Data.Builder>`__
   object. It then puts the ``imageUri`` and the ``blurLevel`` into it as key/value pairs.
   A Data object is then created and returned when it calls ``return builder.build()``.

   3. To set the input data object for the WorkRequest, you call the
      ``blurBuilder.setInputData()`` method. You can create and pass the data object in one
      step by calling the ``createInputDataForWorkRequest()`` helper function as the
      argument. For the call to ``createInputDataForWorkRequest()`` function, pass in the
      ``blurLevel`` variable and the ``imageUri`` variable.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      override fun applyBlur(blurLevel: Int) {
           // Create WorkRequest to blur the image
          val blurBuilder = OneTimeWorkRequestBuilder<BlurWorker>()

          // New code for input data object
          blurBuilder.setInputData(createInputDataForWorkRequest(blurLevel, imageUri))

          workManager.enqueue(blurBuilder.build())
      }


Access the input data object

   Now let's update the ``doWork()`` method in the ``BlurWorker`` class to get the URI and
   the blur level that were passed in by the input data object. If a value for the
   ``blurLevel`` was not provided, it will be defaulted to ``1``.

   Inside the ``doWork()`` method:

   1. Create a new variable named ``resourceUri`` and populate the variable by calling
      ``inputData.getString()`` and passing in the constant ``KEY_IMAGE_URI`` that was used
      as the key when creating the input data object.

   ``val resourceUri = inputData.getString(KEY_IMAGE_URI)``

   2. Create a new variable named ``blurLevel``. Populate the variable by calling
      ``inputData.getInt()`` and passing in the constant ``BLUR_LEVEL`` that was used as
      the key when creating the input data object. In case this key/value pair has not been
      created, provide a default value of ``1`` (one).

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      import com.example.bluromatic.KEY_BLUR_LEVEL
      import com.example.bluromatic.KEY_IMAGE_URI
      ...
      override fun doWork(): Result {

          // ADD THESE LINES
          val resourceUri = inputData.getString(KEY_IMAGE_URI)
          val blurLevel = inputData.getInt(KEY_BLUR_LEVEL, 1)

          // ... rest of doWork()
      }

   With the URI, now let's blur the image of the cupcake on screen.

   1. Check that the ``resourceUri`` variable is populated. If it is not populated, your
      code should throw an exception. The code that follows is using the
      `require() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html#require>`__
      statement which throws an ``IllegalArgumentException`` if the first argument
      evaluates to false.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      return@withContext try {
          // NEW code
          require(!resourceUri.isNullOrBlank()) {
              val errorMessage =
                  applicationContext.resources.getString(R.string.invalid_input_uri)
                  Log.e(TAG, errorMessage)
                  errorMessage
          }

   Since the image source is passed in as a URI, we need a
   `ContentResolver <https://developer.android.google.cn/reference/kotlin/android/content/ContentResolver>`__
   object to read the contents pointed to by the URI.

   2. Add a ``contentResolver`` object to the ``applicationContext`` value.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      ...
          require(!resourceUri.isNullOrBlank()) {
              // ...
          }
          val resolver = applicationContext.contentResolver
      ...

   3. Because the image source is now the passed in URI, use
      ``BitmapFactory.decodeStream()`` instead of ``BitmapFactory.decodeResource()`` to
      create the Bitmap object.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      import android.net.Uri
      ...
      //     val picture = BitmapFactory.decodeResource(
      //         applicationContext.resources,
      //         R.drawable.android_cupcake
      //     )

          val resolver = applicationContext.contentResolver

          val picture = BitmapFactory.decodeStream(
              resolver.openInputStream(Uri.parse(resourceUri))
          )

   4. Pass the ``blurLevel`` variable in the call to the ``blurBitmap()`` function.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      //val output = blurBitmap(picture, 1)
      val output = blurBitmap(picture, blurLevel)


Create the output data object

   You're now done with this Worker and can return the output URI as an output data object
   in ``Result.success()``. Providing the output URI as an output data object makes it
   easily accessible to other workers for further operations. This approach is useful in
   the next section when you create a chain of workers.

   To do this, complete the following steps:

   1. Preceding the ``Result.success()`` code, create a new variable named ``outputData``.
   2. Populate this variable by calling the ``workDataOf()`` function and use constant
      ``KEY_IMAGE_URI`` for the key and variable ``outputUri`` as the value. The
      ``workDataOf()``
      function <https://developer.android.google.cn/reference/kotlin/androidx/work/package-summary#workDataOf(kotlin.Array)>`__
      creates a Data object from the passed in key and value pair.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      import androidx.work.workDataOf
      // ...
      val outputData = workDataOf(KEY_IMAGE_URI to outputUri.toString())

   3. Update the ``Result.success()`` code to take this new Data object as an argument.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      //Result.success()
      Result.success(outputData)

   4. Remove the code that displays the notification as it is no longer needed because the
      output Data object now uses the URI.

   **workers/BlurWorker.kt**

   .. code:: prettyprint

      // REMOVE the following notification code
      //makeStatusNotification(
      //    "Output is $outputUri",
      //    applicationContext
      //)


Run your app

   At this point, when you run your app, you can expect it to compile. You can see the
   blurred image through the **Device Explorer** but not on the screen yet.

   Note that you might need to **Synchronize** to see your images:

   |a658ad6e65f0ce5d.png|

   Great work! You've blurred an input image using ``WorkManager``!


11. Chain your Work
--------------------------------------------------------------------------------

   Right now, you're doing a single work taskâ€”blurring the image. This task is a great
   first step, but the app is still missing some core functionality:

   -  The app doesn't clean up temporary files.
   -  The app doesn't actually save the image to a permanent file.
   -  The app always blurs the picture the same amount.

   You can use a WorkManager chain of work to add this functionality. WorkManager lets you
   create separate ``WorkerRequest``s that run in order or in parallel.

   In this section, you create a chain of work that looks like the following:

   |c883bea5a5beac45.png|

   The boxes represent the ``WorkRequest``s.

   Another feature of chaining is its ability to accept input and produce output. The
   output of one ``WorkRequest`` becomes the input of the next ``WorkRequest`` in the
   chain.

   You already have a ``CoroutineWorker`` to blur an image, but you also need a
   ``CoroutineWorker`` to clean up temp files and a ``CoroutineWorker`` to save the image
   permanently.


Create CleanupWorker

   The ``CleanupWorker`` deletes the temporary files, if they exist.

   1. Right-click on the package ``com.example.bluromatic.workers`` in your Android project
      pane and select **New -> Kotlin Class/File**.
   2. Name the new Kotlin class ``CleanupWorker``.
   3. Copy the code for CleanupWorker.kt, as shown in the following code example.

   Since file manipulation is out of scope for this codelab, you can copy the following
   code for the ``CleanupWorker``.

   **workers/CleanupWorker.kt**

   .. code:: prettyprint

      package com.example.bluromatic.workers

      import android.content.Context
      import android.util.Log
      import androidx.work.CoroutineWorker
      import androidx.work.WorkerParameters
      import com.example.bluromatic.DELAY_TIME_MILLIS
      import com.example.bluromatic.OUTPUT_PATH
      import com.example.bluromatic.R
      import kotlinx.coroutines.Dispatchers
      import kotlinx.coroutines.delay
      import kotlinx.coroutines.withContext
      import java.io.File

      /**
       * Cleans up temporary files generated during blurring process
       */
      private const val TAG = "CleanupWorker"

      class CleanupWorker(ctx: Context, params: WorkerParameters) : CoroutineWorker(ctx, params) {

          override suspend fun doWork(): Result {
              /** Makes a notification when the work starts and slows down the work so that it's easier
               * to see each WorkRequest start, even on emulated devices
               */
              makeStatusNotification(
                  applicationContext.resources.getString(R.string.cleaning_up_files),
                  applicationContext
              )

              return withContext(Dispatchers.IO) {
                  delay(DELAY_TIME_MILLIS)

                  return@withContext try {
                      val outputDirectory = File(applicationContext.filesDir, OUTPUT_PATH)
                      if (outputDirectory.exists()) {
                          val entries = outputDirectory.listFiles()
                          if (entries != null) {
                              for (entry in entries) {
                                  val name = entry.name
                                  if (name.isNotEmpty() && name.endsWith(".png")) {
                                      val deleted = entry.delete()
                                      Log.i(TAG, "Deleted $name - $deleted")
                                  }
                              }
                          }
                      }
                      Result.success()
                  } catch (exception: Exception) {
                      Log.e(
                          TAG,
                          applicationContext.resources.getString(R.string.error_cleaning_file),
                          exception
                      )
                      Result.failure()
                  }
              }
          }
      }


Create SaveImageToFileWorker

   The ``SaveImageToFileWorker`` class saves the temporary file to a permanent file.

   The ``SaveImageToFileWorker`` takes input and output. The input is a ``String`` of the
   temporarily blurred image URI, stored with the key ``KEY_IMAGE_URI``. The output is a
   ``String`` of the saved blurred image URI, stored with the key ``KEY_IMAGE_URI``.

   |de0ee97cca135cf8.png|

   1. Right-click on the package ``com.example.bluromatic.workers`` in your Android project
      pane and select **New -> Kotlin Class/File**.
   2. Name the new Kotlin class ``SaveImageToFileWorker``.
   3. Copy the SaveImageToFileWorker.kt code as shown in the following example code.

   Since file manipulation is out of scope for this codelab, you can copy the following
   code for the ``SaveImageToFileWorker``. In the provided code, notice how the
   ``resourceUri`` and ``output`` values are retrieved and stored with the key
   ``KEY_IMAGE_URI``. This process is very similar to the code you previously wrote for the
   input and output data objects.

   **workers/SaveImageToFileWorker.kt**

   .. code:: prettyprint

      package com.example.bluromatic.workers

      import android.content.Context
      import android.graphics.BitmapFactory
      import android.net.Uri
      import android.provider.MediaStore
      import android.util.Log
      import androidx.work.CoroutineWorker
      import androidx.work.WorkerParameters
      import androidx.work.workDataOf
      import com.example.bluromatic.DELAY_TIME_MILLIS
      import com.example.bluromatic.KEY_IMAGE_URI
      import com.example.bluromatic.R
      import kotlinx.coroutines.Dispatchers
      import kotlinx.coroutines.delay
      import kotlinx.coroutines.withContext
      import java.text.SimpleDateFormat
      import java.util.Locale
      import java.util.Date

      /**
       * Saves the image to a permanent file
       */
      private const val TAG = "SaveImageToFileWorker"

      class SaveImageToFileWorker(ctx: Context, params: WorkerParameters) : CoroutineWorker(ctx, params) {

          private val title = "Blurred Image"
          private val dateFormatter = SimpleDateFormat(
              "yyyy.MM.dd 'at' HH:mm:ss z",
              Locale.getDefault()
          )

          override suspend fun doWork(): Result {
              // Makes a notification when the work starts and slows down the work so that
              // it's easier to see each WorkRequest start, even on emulated devices
              makeStatusNotification(
                  applicationContext.resources.getString(R.string.saving_image),
                  applicationContext
              )

              return withContext(Dispatchers.IO) {
                  delay(DELAY_TIME_MILLIS)

                  val resolver = applicationContext.contentResolver
                  return@withContext try {
                      val resourceUri = inputData.getString(KEY_IMAGE_URI)
                      val bitmap = BitmapFactory.decodeStream(
                          resolver.openInputStream(Uri.parse(resourceUri))
                      )
                      val imageUrl = MediaStore.Images.Media.insertImage(
                          resolver, bitmap, title, dateFormatter.format(Date())
                      )
                      if (!imageUrl.isNullOrEmpty()) {
                          val output = workDataOf(KEY_IMAGE_URI to imageUrl)

                          Result.success(output)
                      } else {
                          Log.e(
                              TAG,
                              applicationContext.resources.getString(R.string.writing_to_mediaStore_failed)
                          )
                          Result.failure()
                      }
                  } catch (exception: Exception) {
                      Log.e(
                          TAG,
                          applicationContext.resources.getString(R.string.error_saving_image),
                          exception
                      )
                      Result.failure()
                  }
              }
          }
      }

   **Note:** The provided code for the ``CleanupWorker`` worker and the
   ``SaveImageToFileWorker`` worker each include the statement
   ``delay(DELAY_TIME_MILLIS)``. This code slows the worker down while it is running. This
   code was included for instructional purposes so you can more easily see the workers
   running in the **Background Task Inspector** and to also provide a brief pause between
   notification messages. You do not normally use this code in production code.


Create a chain of work

   Currently, the code only creates and runs a single ``WorkRequest``.

   In this step, you modify the code to create and execute a chain of WorkRequests instead
   of just one blur image request.

   In the chain of WorkRequests, your first work request is to clean up the temporary
   files.

   1. Instead of calling ``OneTimeWorkRequestBuilder``, call ``workManager.beginWith()``.

   Calling the ``beginWith()`` method returns a
   `WorkContinuation <https://developer.android.google.cn/reference/androidx/work/WorkContinuation>`__
   object and creates the starting point for a chain of ``WorkRequest``s with the first
   work request in the chain.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      import androidx.work.OneTimeWorkRequest
      import com.example.bluromatic.workers.CleanupWorker
      // ...
          override fun applyBlur(blurLevel: Int) {
              // Add WorkRequest to Cleanup temporary images
              var continuation = workManager.beginWith(OneTimeWorkRequest.from(CleanupWorker::class.java))

              // Add WorkRequest to blur the image
              val blurBuilder = OneTimeWorkRequestBuilder<BlurWorker>()
      ...

   **Note:** In this code, we show an alternate way to create the ``OneTimeWorkRequest``
   object. Calling ``OneTimeWorkRequest.from(CleanupWorker::class.java)`` is the equivalent
   to calling ``OneTimeWorkRequestBuilder<CleanupWorker>().build()``. Class
   ``OneTimeWorkRequest`` comes from the `AndroidX <https://developer.android.google.cn/jetpack/androidx>`__
   Work library while ``OneTimeWorkRequestBuilder`` is a helper function provided by the 
   `WorkManager KTX <https://developer.android.google.cn/kotlin/ktx#workmanager>`__ extension.

   You can add to this chain of work requests by calling the ``then()`` method and passing
   in a ``WorkRequest`` object.

   2. Remove the call to ``workManager.enqueue(blurBuilder.build())``, which was only
      enqueueing one work request.
   3. Add the next work request to the chain by calling the ``.then()`` method.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      ...
      //workManager.enqueue(blurBuilder.build())

      // Add the blur work request to the chain
      continuation = continuation.then(blurBuilder.build())
      ...

   4. Create a work request to save the image and add it to the chain.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      import com.example.bluromatic.workers.SaveImageToFileWorker

      ...
      continuation = continuation.then(blurBuilder.build())

      // Add WorkRequest to save the image to the filesystem
      val save = OneTimeWorkRequestBuilder<SaveImageToFileWorker>()
          .build()
      continuation = continuation.then(save)
      ...

   5. To start the work, call the ``enqueue()`` method on the continuation object.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      ...
      continuation = continuation.then(save)

      // Start the work
      continuation.enqueue()
      ...

   This code produces and runs the following chain of WorkRequests: a ``CleanupWorker``
   ``WorkRequest`` followed by a ``BlurWorker`` ``WorkRequest`` followed by a
   ``SaveImageToFileWorker`` ``WorkRequest``.

   6. Run the app.

   You are now able to click **Start** and see notifications when the different workers
   execute. You can still see the blurred image in the **Device Explorer**, and in an
   upcoming section, you add an extra button so that users can see the blurred image on the
   device.

   In the following screenshots, notice that the notification message displays which worker
   is currently running.

   |bbe0fdd79e3bca27.png|

   |5d43bbfff1bfebe5.png|

   |da2d31fa3609a7b1.png|

   Notice that the output folder contains multiple blurred imagesâ€”images that are in
   intermediate blurred stages and the final image that displays the image with the blur
   amount you selected.

   Superb work! Now, you can clean up the temporary files, blur an image, and save it!


12. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-workmanager.git
      $ cd basic-android-kotlin-compose-training-workmanager
      $ git checkout intermediate

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-workmanager/archive/refs/heads/intermediate.zip>`__

   If you want to see the solution code for this codelab, view it on
   `GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-workmanager/tree/intermediate>`__.


13. Conclusion
--------------------------------------------------------------------------------

   Congratulations! You've finished the Blur-O-Matic app and in the process learned about:

   -  Adding WorkManager to your Project
   -  Scheduling a ``OneTimeWorkRequest``
   -  Input and Output parameters
   -  Chaining work together ``WorkRequest``s

   WorkManager supports a lot more than we could cover in this codelab, including
   repetitive work, a testing support library, parallel work requests, and input mergers.

   To learn more, go to the `Schedule tasks with WorkManager <http://d.android.com/topic/libraries/architecture/workmanager/>`__
   documentation.

.. |10c653bb5b84c4b2.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/10c653bb5b84c4b2.png
.. |2bdb6fdc2567e96.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/2bdb6fdc2567e96.png
.. |9e96aa94f82c6990.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/9e96aa94f82c6990.png
.. |cdc4bbefa7a9912b.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/cdc4bbefa7a9912b.png
.. |8f495f0861ed19ff.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/8f495f0861ed19ff.png
.. |2d81a484b1edfd1d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/2d81a484b1edfd1d.png
.. |f2b3591b86d1999d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/f2b3591b86d1999d.png
.. |6bc555807e67f5ad.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/6bc555807e67f5ad.png
.. |fce43c920a61a2e3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/fce43c920a61a2e3.png
.. |ce8ec44543479fe5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/ce8ec44543479fe5.png
.. |a658ad6e65f0ce5d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/a658ad6e65f0ce5d.png
.. |c883bea5a5beac45.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/c883bea5a5beac45.png
.. |de0ee97cca135cf8.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/de0ee97cca135cf8.png
.. |bbe0fdd79e3bca27.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/bbe0fdd79e3bca27.png
.. |5d43bbfff1bfebe5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/5d43bbfff1bfebe5.png
.. |da2d31fa3609a7b1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-workmanager/img/da2d31fa3609a7b1.png


ğŸš€ Advanced WorkManager and Testing
===================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-verify-background-work


1. Introduction
--------------------------------------------------------------------------------

   In the `Background Work with WorkManager <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-workmanager>`__
   codelab, you learned how to execute work in the background (not on the main thread)
   using WorkManager. In this codelab, you will continue learning about WorkManager
   functionality for ensuring unique work, tagging work, canceling work, and work
   constraints. The codelab will finish with you learning how to write automated tests to
   verify that your workers function properly and return the expected results. You will
   also learn how to use the **Background Task Inspector**, provided by Android Studio, to
   inspect queued workers.


What you'll build

   In this codelab, you will ensure unique work, tagging work, canceling work, and
   implementing work constraints. You will then learn how to write automated UI tests for
   the **Blur-O-Matic** app that verify the functionality of the three workers created in
   the `Background Work with WorkManager <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-workmanager>`__
   codelab:

   -  ``BlurWorker``
   -  ``CleanupWorker``
   -  ``SaveImageToFileWorker``


What you'll learn

   -  Ensuring `unique work <https://developer.android.google.cn/guide/background/persistent/how-to/manage-work#unique-work>`__.
   -  How to cancel work.
   -  How to define `work constraints <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#work-constraints>`__.
   -  How to write automated tests to verify Worker functionality.
   -  The basics of inspecting queued workers with the **Background Task Inspector**.


What you'll need

   -  The latest stable version of Android Studio
   -  Completion of the `Background Work with WorkManager codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-workmanager>`__
   -  An Android device or emulator


2. Getting set up
--------------------------------------------------------------------------------


Download the Code

   Click the following link to download all the code for this codelab:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-workmanager/archive/refs/heads/intermediate.zip>`__

   Or if you prefer, you can clone the code from GitHub:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-workmanager.git
      $ cd basic-android-kotlin-compose-training-workmanager
      $ git checkout intermediate

   **Note:** The starter code is in the ``intermediate`` branch of the downloaded
   repository.

   Open the project in Android Studio.


3. Ensure unique work
--------------------------------------------------------------------------------

   Now that you know how to chain workers, it's time to tackle another powerful feature of
   WorkManager: `unique work sequences <https://developer.android.google.cn/guide/background/persistent/how-to/manage-work#unique-work>`__.

   Sometimes, you only want one chain of work to run at a time. For example, perhaps you
   have a work chain that syncs your local data with the server. You probably want the
   first data sync to complete before starting a new one. To do this, you use
   `beginUniqueWork() <https://developer.android.google.cn/reference/kotlin/androidx/work/WorkManager#beginUniqueWork(java.lang.String,androidx.work.ExistingWorkPolicy,androidx.work.OneTimeWorkRequest)>`__
   instead of `beginWith() <https://developer.android.google.cn/reference/kotlin/androidx/work/WorkManager#beginWith(androidx.work.OneTimeWorkRequest)>`__,
   and you provide a unique ``String`` name. This input names the **entire** chain of work
   requests so that you can refer to and query them together.

   You also need to pass in an `ExistingWorkPolicy <https://developer.android.google.cn/reference/kotlin/androidx/work/ExistingWorkPolicy>`__
   object. This object tells the Android OS what happens if the work already exists.
   Possible `ExistingWorkPolicy <http://d.android.com/reference/androidx/work/ExistingWorkPolicy>`__
   values are `REPLACE <https://developer.android.google.cn/reference/kotlin/androidx/work/ExistingWorkPolicy#REPLACE>`__,
   `KEEP <https://developer.android.google.cn/reference/kotlin/androidx/work/ExistingWorkPolicy#KEEP>`__,
   `APPEND <https://developer.android.google.cn/reference/kotlin/androidx/work/ExistingWorkPolicy#APPEND>`__,
   or `APPEND_OR_REPLACE <https://developer.android.google.cn/reference/kotlin/androidx/work/ExistingWorkPolicy#APPEND_OR_REPLACE>`__.

   In this app, you want to use ``REPLACE`` because if a user decides to blur another image
   before the current one finishes, you want to stop the current one and start blurring the
   new image.

   You also want to ensure that if a user clicks **Start** when a work request is already
   enqueued, then the app replaces the previous work request with the new request. It does
   not make sense to continue working on the previous request because the app replaces it
   with the new request anyway.

   In the ``data/WorkManagerBluromaticRepository.kt`` file, inside the ``applyBlur()``
   method, complete the following steps:

   1. Remove the call to ``beginWith()`` function and add a call to the
      `beginUniqueWork() <https://developer.android.google.cn/reference/kotlin/androidx/work/WorkManager#beginUniqueWork(java.lang.String,androidx.work.ExistingWorkPolicy,androidx.work.OneTimeWorkRequest)>`__
      function.
   2. For the first parameter to the ``beginUniqueWork()`` function, pass in the constant
      ``IMAGE_MANIPULATION_WORK_NAME``.
   3. For the second parameter, the ``existingWorkPolicy`` parameter, pass in
      ``ExistingWorkPolicy.REPLACE``.
   4. For the third parameter, create a new ``OneTimeWorkRequest`` for the
      ``CleanupWorker``.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      import androidx.work.ExistingWorkPolicy
      import com.example.bluromatic.IMAGE_MANIPULATION_WORK_NAME
      ...
      // REPLACE THIS CODE:
      // var continuation = workManager.beginWith(OneTimeWorkRequest.from(CleanupWorker::class.java))
      // WITH
      var continuation = workManager
          .beginUniqueWork(
              IMAGE_MANIPULATION_WORK_NAME,
              ExistingWorkPolicy.REPLACE,
              OneTimeWorkRequest.from(CleanupWorker::class.java)
          )
      ...

   Blur-O-Matic now only blurs one image at a time.


4. Tag and update the UI based on Work status
--------------------------------------------------------------------------------

   The next change you make is to what the app shows when the Work executes. Information
   returned about the enqueued works determines how the UI needs to change.

   This table shows three different methods that you can call to get work information:

   * Get work using **id**

      `getWorkInfoByIdLiveData() <https://developer.android.google.cn/reference/androidx/work/WorkManager#getWorkInfoByIdLiveData(java.util.UUID)>`__
      This function returns a single **LiveData<WorkInfo>** for a specific WorkRequest by its ID.

   * Get work using **unique chain name**

      `getWorkInfosForUniqueWorkLiveData() <https://developer.android.google.cn/reference/androidx/work/WorkManager#getWorkInfosForUniqueWorkLiveData(java.lang.String)>`__
      This function returns **LiveData<List<WorkInfo>>** for all work in a unique chain of WorkRequests.

   * Get work using a **tag**

      `getWorkInfosByTagLiveData() <https://developer.android.google.cn/reference/androidx/work/WorkManager#getWorkInfosByTagLiveData(java.lang.String)>`__
      This function returns the **LiveData<List<WorkInfo>>** for a tag.


   **Note:** WorkManager exposes some APIs as LiveData. We use the LiveData APIs but
   convert and use them as a flow. If the APIs change in the future, we can update the
   codelab accordingly.

   A ``WorkInfo`` object contains details about the current state of a ``WorkRequest``,
   including:

   -  Whether the work is
      `BLOCKED <https://developer.android.google.cn/reference/androidx/work/WorkInfo.State#BLOCKED>`__,
      `CANCELLED <https://developer.android.google.cn/reference/androidx/work/WorkInfo.State#CANCELLED>`__,
      `ENQUEUED <https://developer.android.google.cn/reference/androidx/work/WorkInfo.State#ENQUEUED>`__,
      `FAILED <https://developer.android.google.cn/reference/androidx/work/WorkInfo.State#FAILED>`__,
      `RUNNING <https://developer.android.google.cn/reference/androidx/work/WorkInfo.State#RUNNING>`__,
      or `SUCCEEDED <https://developer.android.google.cn/reference/androidx/work/WorkInfo.State#SUCCEEDED>`__.
   -  If the ``WorkRequest`` is finished and any output data from the work.

   These methods return `LiveData <https://developer.android.google.cn/topic/libraries/architecture/livedata>`__.
   LiveData is a lifecycle aware observable data holder. We convert it into a Flow of
   `WorkInfo <http://d.android.com/reference/androidx/work/WorkInfo>`__ 
   objects by calling `.asFlow() <https://developer.android.google.cn/reference/kotlin/androidx/lifecycle/LiveData#(androidx.lifecycle.LiveData).asFlow()>`__.

   Because you are interested in when the final image saves, you add a tag to the
   ``SaveImageToFileWorker`` WorkRequest so that you can get its WorkInfo from the
   ``getWorkInfosByTagLiveData()`` method.

   Another option is to use the ``getWorkInfosForUniqueWorkLiveData()`` method, which
   returns information about all three WorkRequests (``CleanupWorker``, ``BlurWorker``, and
   ``SaveImageToFileWorker``). The downside to this method is that you need additional code
   to specifically find the necessary ``SaveImageToFileWorker`` information.


Tag the work request

   Tagging the work is done in the ``data/WorkManagerBluromaticRepository.kt`` file inside
   the ``applyBlur()`` function.

   1. When you create the ``SaveImageToFileWorker`` work request, tag the work by calling
      the ``addTag()`` method and passing in the ``String`` constant ``TAG_OUTPUT``.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      import com.example.bluromatic.TAG_OUTPUT
      ...
      val save = OneTimeWorkRequestBuilder<SaveImageToFileWorker>()
          .addTag(TAG_OUTPUT) // <- Add this
          .build()

   Instead of a WorkManager ID, you use a tag to label your work because if your user blurs
   multiple images, all of the save image ``WorkRequest``s have the same tag but *not*
   the same ID.


Get the WorkInfo

   You use the ``WorkInfo`` information from the ``SaveImageToFileWorker`` work request in
   the logic to decide which composables to display in the UI based on the ``BlurUiState``.

   The ViewModel consumes this information from the repository's ``outputWorkInfo``
   variable.

   Now that you have tagged the ``SaveImageToFileWorker`` work request, you can complete
   the following steps to retrieve its information:

   1. In the ``data/WorkManagerBluromaticRepository.kt`` file, call the
      ``workManager.getWorkInfosByTagLiveData()`` method to populate the ``outputWorkInfo``
      variable.
   2. Pass in the ``TAG_OUTPUT`` constant for the method's parameter.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      ...
      override val outputWorkInfo: Flow<WorkInfo?> =
          workManager.getWorkInfosByTagLiveData(TAG_OUTPUT)
      ...

   The call of the ``getWorkInfosByTagLiveData()`` method returns `LiveData <https://developer.android.google.cn/topic/libraries/architecture/livedata>`__.
   LiveData is a lifecycle aware observable data holder. The `.asFlow() <https://developer.android.google.cn/reference/kotlin/androidx/lifecycle/LiveData#(androidx.lifecycle.LiveData).asFlow()>`__
   function converts it to a Flow.

   3. Chain a call to the ``.asFlow()`` function to convert the method to a Flow. You
      convert the method so the app can work with a Kotlin Flow instead of LiveData.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      import androidx.lifecycle.asFlow
      ...
      override val outputWorkInfo: Flow<WorkInfo?> =
          workManager.getWorkInfosByTagLiveData(TAG_OUTPUT).asFlow()
      ...

   4. Chain a call to the `.mapNotNull() <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map-not-null.html>`__
      transform function to ensure the Flow contains values.
   5. For the transform rule, if the element is not empty, select the first item in the
      collection. Otherwise, return a null value. The transform function will then remove
      them if they are a null value.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      import kotlinx.coroutines.flow.mapNotNull
      ...
          override val outputWorkInfo: Flow<WorkInfo?> =
              workManager.getWorkInfosByTagLiveData(TAG_OUTPUT).asFlow().mapNotNull {
                  if (it.isNotEmpty()) it.first() else null
              }
      ...

   6. Because the ``.mapNotNull()`` transform function guarantees that a value exists, you
      can safely remove the ``?`` from the Flow type as it no longer needs to be a nullable
      type.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      ...
          override val outputWorkInfo: Flow<WorkInfo> =
      ...

   7. You also need to remove the ``?`` from the ``BluromaticRepository`` interface.

   **data/BluromaticRepository.kt**

   .. code:: prettyprint

      ...
      interface BluromaticRepository {
      //    val outputWorkInfo: Flow<WorkInfo?>
          val outputWorkInfo: Flow<WorkInfo>
      ...

   The ``WorkInfo`` information is emitted as a ``Flow`` from the repository. The
   ``ViewModel`` then consumes it.


Update the ``BlurUiState``

   The ``ViewModel`` uses the ``WorkInfo`` emitted by the repository from the
   ``outputWorkInfo`` Flow to set the value of the ``blurUiState`` variable.

   The UI code uses the ``blurUiState`` variable value to determine which composables to
   display.

   Complete the following steps to perform the ``blurUiState`` update:

   1. Populate the ``blurUiState`` variable with the ``outputWorkInfo`` Flow from the
      repository.

   **ui/BlurViewModel.kt**

   .. code:: prettyprint

      // ...
      // REMOVE
      // val blurUiState: StateFlow<BlurUiState> = MutableStateFlow(BlurUiState.Default)

      // ADD
      val blurUiState: StateFlow<BlurUiState> = bluromaticRepository.outputWorkInfo
      // ...

   2. You then need to map the values in the Flow to the ``BlurUiState`` states, depending
      on the status of the work.

   When the work is finished, set the ``blurUiState`` variable to
   ``BlurUiState.Complete(outputUri = "")``.

   When the work is cancelled, set the ``blurUiState`` variable to ``BlurUiState.Default``.

   Otherwise, set the ``blurUiState`` variable to ``BlurUiState.Loading``.

   **ui/BlurViewModel.kt**

   .. code:: prettyprint

      import androidx.work.WorkInfo
      import kotlinx.coroutines.flow.map
      // ...

          val blurUiState: StateFlow<BlurUiState> = bluromaticRepository.outputWorkInfo
              .map { info ->
                  when {
                      info.state.isFinished -> {
                          BlurUiState.Complete(outputUri = "")
                      }
                      info.state == WorkInfo.State.CANCELLED -> {
                          BlurUiState.Default
                      }
                      else -> BlurUiState.Loading
                  }
              }

      // ...

   3. Because you are interested in a
      `StateFlow <https://developer.android.google.cn/kotlin/flow/stateflow-and-sharedflow#stateflow>`__,
      convert the Flow by chaining a call to the ``.stateIn()`` function.

   The call to the ``.stateIn()`` function requires three arguments:

   1. For the first parameter, pass ``viewModelScope``, which is the coroutine scope tied
      to the ViewModel.
   2. For the second parameter, pass ``SharingStarted.WhileSubscribed(5_000)``. This
      parameter controls when sharing starts and stops.
   3. For the third parameter, pass ``BlurUiState.Default``, which is the initial value of
      the state flow.

   **ui/BlurViewModel.kt**

   .. code:: prettyprint

      import kotlinx.coroutines.flow.stateIn
      import androidx.lifecycle.viewModelScope
      import kotlinx.coroutines.flow.SharingStarted
      // ...

          val blurUiState: StateFlow<BlurUiState> = bluromaticRepository.outputWorkInfo
              .map { info ->
                  when {
                      info.state.isFinished -> {
                          BlurUiState.Complete(outputUri = "")
                      }
                      info.state == WorkInfo.State.CANCELLED -> {
                          BlurUiState.Default
                      }
                      else -> BlurUiState.Loading
                  }
              }.stateIn(
                  scope = viewModelScope,
                  started = SharingStarted.WhileSubscribed(5_000),
                  initialValue = BlurUiState.Default
              )

      // ...

   The ``ViewModel`` exposes the UI state information as a ``StateFlow`` through the
   ``blurUiState`` variable. The flow converts from a cold ``Flow`` to a hot ``StateFlow``
   by calling the `stateIn() function. <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html>`__


Update the UI

   In the ``ui/BluromaticScreen.kt`` file, you get the UI state from the ``ViewModel``'s
   ``blurUiState`` variable and update the UI.

   A ``when`` block controls the app's UI. This ``when`` block has a branch for each of the
   three ``BlurUiState`` states.

   The UI updates in the ``BlurActions`` composable inside its ``Row`` composable. Complete
   the following steps:

   1. Remove the ``Button(onStartClick)`` code inside the ``Row`` Composable and replace it
      with a ``when`` block with ``blurUiState`` as its argument.

   **ui/BluromaticScreen.kt**

   .. code:: prettyprint

      ...
          Row(
              modifier = modifier,
              horizontalArrangement = Arrangement.Center
          ) {
              // REMOVE
              // Button(
              //     onClick = onStartClick,
              //     modifier = Modifier.fillMaxWidth()
              // ) {
              //     Text(stringResource(R.string.start))
              // }
              // ADD
              when (blurUiState) {
              }
          }
      ...

   When the app opens, it is at its default state. This state in code is represented as
   ``BlurUiState.Default``.

   2. Inside the ``when`` block, create a branch for this state as shown in the following
      code example:

   **ui/BluromaticScreen.kt**

   .. code:: prettyprint

      ...
          Row(
              modifier = modifier,
              horizontalArrangement = Arrangement.Center
          ) {
              when (blurUiState) {
                  is BlurUiState.Default -> {}
              }
          }
      ...

   For the default state, the app shows the **Start** button.

   3. For the ``onClick`` parameter in the ``BlurUiState.Default`` state, pass the
      ``onStartClick`` variable, which is being passed to the composable.
   4. For the ``stringResourceId`` parameter, pass the string resource id of
      ``R.string.start``.

   **ui/BluromaticScreen.kt**

   .. code:: prettyprint

      ...
          Row(
              modifier = modifier,
              horizontalArrangement = Arrangement.Center
          ) {
              when (blurUiState) {
                  is BlurUiState.Default -> {
                      Button(
                          onClick = onStartClick,
                          modifier = Modifier.fillMaxWidth()
                      ) {
                          Text(stringResource(R.string.start))
                      }
              }
          }
      ...

   When the app is actively blurring an image, that is the ``BlurUiState.Loading`` state.
   For this state, the app shows the **Cancel Work** button and a circular progress
   indicator.

   5. For the button's ``onClick`` parameter in the ``BlurUiState.Loading`` state, pass
      ``onCancelClick`` variable, which is being passed to the composable.
   6. For the button's ``stringResourceId`` parameter, pass the string resource id of
      ``R.string.cancel_work``.

   **ui/BluromaticScreen.kt**

   .. code:: prettyprint

      import androidx.compose.material3.CircularProgressIndicator
      import androidx.compose.material3.FilledTonalButton
      ...
          Row(
              modifier = modifier,
              horizontalArrangement = Arrangement.Center
          ) {
              when (blurUiState) {
                  is BlurUiState.Default -> {
                      Button(onStartClick) { Text(stringResource(R.string.start)) }
                  }
                  is BlurUiState.Loading -> {
                     FilledTonalButton(onCancelClick) { Text(stringResource(R.string.cancel_work)) }
                     CircularProgressIndicator(modifier = Modifier.padding(dimensionResource(R.dimen.padding_small)))
                  }
              }
          }
      ...

   **Note:** You don't use the **Cancel Work** button right now but still create it. You
   configure it in an upcoming step.

   The last state to configure is the ``BlurUiState.Complete`` state, which occurs after an
   image blurs and saves. At this time, the app only displays the **Start** button.

   7. For its ``onClick`` parameter in the ``BlurUiState.Complete`` state, pass the
      ``onStartClick`` variable.
   8. For its ``stringResourceId`` parameter, pass the string resource id of
      ``R.string.start``.

   **ui/BluromaticScreen.kt**

   .. code:: prettyprint

      ...
          Row(
              modifier = modifier,
              horizontalArrangement = Arrangement.Center
          ) {
              when (blurUiState) {
                  is BlurUiState.Default -> {
                      Button(onStartClick) { Text(stringResource(R.string.start)) }
                  }
                  is BlurUiState.Loading -> {
                      FilledTonalButton(onCancelClick) { Text(stringResource(R.string.cancel_work)) }
                      CircularProgressIndicator(modifier = Modifier.padding(dimensionResource(R.dimen.padding_small)))
                  }
                  is BlurUiState.Complete -> {
                      Button(onStartClick) { Text(stringResource(R.string.start)) }
                  }
              }
          }
      ...


Run your app

   1. Run your app and click **Start**.
   2. Refer to the **Background Task Inspector** window to see how the various states
      correspond to the UI being displayed.

   **Note:** The **Background Task Inspector** window can be found through the menus:
   **View > Tool Windows > App Inspection** then select the **Background Task Inspector**
   tab.

   The ``SystemJobService`` is the component responsible for managing Worker executions.

   While the workers are running, the UI shows the **Cancel Work** button and a circular
   progress indicator.

   |3395cc370b580b32.png|

   |c5622f923670cf67.png|

   After the workers finish, the UI updates to show the **Start** button as expected.

   |97252f864ea042aa.png|

   |81ba9962a8649e70.png|


5. Show final output
--------------------------------------------------------------------------------

   In this section, you configure the app to display a button labeled **See File** whenever
   there is a blurred image ready to show.


Create the **See File** button

   The **See File** button only shows when the ``BlurUiState`` is ``Complete``.

   1. Open the ``ui/BluromaticScreen.kt`` file and navigate to ``BlurActions`` composable.
   2. To add space between the **Start** button and the **See File** button, add a
      ``Spacer`` composable within the ``BlurUiState.Complete`` block.
   3. Add a new ``FilledTonalButton`` composable.
   4. For the ``onClick`` parameter, pass ``onSeeFileClick(blurUiState.outputUri)``.
   5. Add a ``Text`` composable for the ``Button``'s content parameter.
   6. For the ``Text``'s ``text`` parameter, use the string resource id
      ``R.string.see_file``.

   **ui/BluromaticScreen.kt**

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Spacer
      import androidx.compose.foundation.layout.width

      // ...
      is BlurUiState.Complete -> {
          Button(onStartClick) { Text(stringResource(R.string.start)) }
          // Add a spacer and the new button with a "See File" label
          Spacer(modifier = Modifier.width(dimensionResource(R.dimen.padding_small)))
          FilledTonalButton({ onSeeFileClick(blurUiState.outputUri) })
          { Text(stringResource(R.string.see_file)) }
      }
      // ...


Update the blurUiState

   The ``BlurUiState`` state is set in the ViewModel and is dependent on the state of the
   work request and possibly the ``bluromaticRepository.outputWorkInfo`` variable.

   1. In the ``ui/BlurViewModel.kt`` file, inside the ``map()`` transform, create a new
      variable ``outputImageUri``.
   2. Populate this new variable saved image's URI from the ``outputData`` data object.

   You can retrieve this string with the ``KEY_IMAGE_URI`` key.

   **ui/BlurViewModel.kt**

   .. code:: prettyprint

      import com.example.bluromatic.KEY_IMAGE_URI

      // ...
      .map { info ->
          val outputImageUri = info.outputData.getString(KEY_IMAGE_URI)
          when {
      // ...

   3. If the worker finishes and the variable is populated, it indicates that a blurred
      image exists to display.

   You can check if this variable is populated by calling
   ``outputImageUri.isNullOrEmpty()``.

   4. Update the ``isFinished`` branch to also check that the variable is populated and
      then pass the ``outputImageUri`` variable into the ``BlurUiState.Complete`` data
      object.

   **ui/BlurViewModel.kt**

   .. code:: prettyprint

      // ...
      .map { info ->
          val outputImageUri = info.outputData.getString(KEY_IMAGE_URI)
          when {
              info.state.isFinished && !outputImageUri.isNullOrEmpty() -> {
                  BlurUiState.Complete(outputUri = outputImageUri)
              }
              info.state == WorkInfo.State.CANCELLED -> {
      // ...


Create See File click event code

   When a user clicks the **See File** button, its ``onClick`` handler calls its assigned
   function. This function passes as an argument in the call to the ``BlurActions()``
   composable.

   The purpose of this function is to display the saved image from its URI. It calls the
   ``showBlurredImage()`` helper function and passes in the URI. The helper function
   creates an intent and uses it to start a new activity to show the saved image.

   1. Open the ``ui/BluromaticScreen.kt`` file.
   2. In the ``BluromaticScreenContent()`` function, in the call to the ``BlurActions()``
      composable function, start creating a lambda function for the ``onSeeFileClick``
      parameter that takes a single parameter named ``currentUri``. This approach stores
      the saved image's URI.

   **ui/BluromaticScreen.kt**

   .. code:: prettyprint

      // ...
      BlurActions(
          blurUiState = blurUiState,
          onStartClick = { applyBlur(selectedValue) },
          onSeeFileClick = { currentUri ->
          },
          onCancelClick = { cancelWork() },
          modifier = Modifier.fillMaxWidth()
      )
      // ...

   3. Inside the body of the lambda function, call the ``showBlurredImage()`` helper
      function.
   4. For the first parameter, pass the ``context`` variable.
   5. For the second parameter, pass the ``currentUri`` variable.

   **ui/BluromaticScreen.kt**

   .. code:: prettyprint

      // ...
      BlurActions(
          blurUiState = blurUiState,
          onStartClick = { applyBlur(selectedValue) },
          // New lambda code runs when See File button is clicked
          onSeeFileClick = { currentUri ->
              showBlurredImage(context, currentUri)
          },
          onCancelClick = { cancelWork() },
          modifier = Modifier.fillMaxWidth()
      )
      // ...


Run your app

   Run your app. You now see your new, clickable **See File** button, which takes you to
   the saved file:

   |9d76d5d7f231c6b6.png|

   |926e532cc24a0d4f.png|


6. Cancel work
--------------------------------------------------------------------------------

   |5cec830cc8ef647e.png|

   Previously, you added the **Cancel Work** button, so now you can add the code to make it
   do something. With WorkManager, you can cancel work using the id, tag, and **unique
   chain** name.

   In this case, you want to cancel work with its unique chain name because you want to
   cancel all work in the chain, not just a particular step.


Cancel the work by name

   1. Open the ``data/WorkManagerBluromaticRepository.kt`` file.
   2. In the ``cancelWork()`` function, call the ``workManager.cancelUniqueWork()``
      function.
   3. Pass in the unique chain name ``IMAGE_MANIPULATION_WORK_NAME`` so the call only
      cancels scheduled work with that name.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      override fun cancelWork() {
          workManager.cancelUniqueWork(IMAGE_MANIPULATION_WORK_NAME)
      }

   Following the design principle of `separation of concerns <https://en.wikipedia.org/wiki/Separation_of_concerns>`__, 
   the composable functions must not directly interact with the repository. The composable 
   functions interact with the ViewModel, and the ViewModel interacts with the repository.

   This approach is a good design principle to follow because changes to your repository do
   not require you to change your composable functions as they do not directly interact.

   1. Open the ``ui/BlurViewModel.kt`` file.
   2. Create a new function called ``cancelWork()`` to cancel the work.
   3. Inside the function, on the ``bluromaticRepository`` object, call the
      ``cancelWork()`` method.

   **ui/BlurViewModel.kt**

   .. code:: prettyprint

      /**
       * Call method from repository to cancel any ongoing WorkRequest
       * */
      fun cancelWork() {
          bluromaticRepository.cancelWork()
      }


Setup Cancel Work click event

   1. Open the ``ui/BluromaticScreen.kt`` file.
   2. Navigate to the ``BluromaticScreen()`` composable function.

   **ui/BluromaticScreen.kt**

   .. code:: prettyprint

      fun BluromaticScreen(blurViewModel: BlurViewModel = viewModel(factory = BlurViewModel.Factory)) {
          val uiState by blurViewModel.blurUiState.collectAsStateWithLifecycle()
          val layoutDirection = LocalLayoutDirection.current
          Surface(
              modifier = Modifier
                  .fillMaxSize()
                  .statusBarsPadding()
                  .padding(
                      start = WindowInsets.safeDrawing
                          .asPaddingValues()
                          .calculateStartPadding(layoutDirection),
                      end = WindowInsets.safeDrawing
                          .asPaddingValues()
                          .calculateEndPadding(layoutDirection)
                  )
          ) {
              BluromaticScreenContent(
                  blurUiState = uiState,
                  blurAmountOptions = blurViewModel.blurAmount,
                  applyBlur = blurViewModel::applyBlur,
                  cancelWork = {},
                  modifier = Modifier
                      .verticalScroll(rememberScrollState())
                      .padding(dimensionResource(R.dimen.padding_medium))
              )
          }
      }

   Inside the call to the ``BluromaticScreenContent`` composable, you want the ViewModel's
   ``cancelWork()`` method to run when a user clicks the button.

   3. Assign the ``cancelWork`` parameter the value ``blurViewModel::cancelWork``.

   **ui/BluromaticScreen.kt**

   .. code:: prettyprint

      // ...
              BluromaticScreenContent(
                  blurUiState = uiState,
                  blurAmountOptions = blurViewModel.blurAmount,
                  applyBlur = blurViewModel::applyBlur,
                  cancelWork = blurViewModel::cancelWork,
                  modifier = Modifier
                      .verticalScroll(rememberScrollState())
                      .padding(dimensionResource(R.dimen.padding_medium))
              )
      // ...


Run your app and cancel work

   Run your app. It compiles just fine. Start blurring a picture and then click **Cancel
   Work**. The whole chain is cancelled!

   |81ba9962a8649e70.png|

   After you cancel work, only the **Start** button shows because ``WorkInfo.State`` is
   ``CANCELLED``. This change causes the ``blurUiState`` variable to be set to
   ``BlurUiState.Default``, which resets the UI back to its initial state and shows just
   the **Start** button.

   The **Background Task Inspector** shows the status of **Cancelled** which is expected.

   |7656dd320866172e.png|


7. Work constraints
--------------------------------------------------------------------------------

   Last but not least, ``WorkManager`` supports `Constraints <https://developer.android.google.cn/reference/androidx/work/Constraints.html>`__.
   A constraint is a requirement that you must meet before a WorkRequest runs.

   Some example constraints are `requiresDeviceIdle() <https://developer.android.google.cn/reference/androidx/work/Constraints#requiresDeviceIdle()>`__
   and `requiresStorageNotLow() <https://developer.android.google.cn/reference/androidx/work/Constraints#requiresStorageNotLow()>`__.

   -  For the ``requiresDeviceIdle()`` constraint, if it is passed a value of ``true``, the
      work runs only if the device is idle.
   -  For the ``requiresStorageNotLow()`` constraint, if it is passed a value of ``true``,
      the work runs only if the storage is not low.

   For **Blur-O-Matic**, you add the constraint that the device's battery charge level must
   not be low before it runs the ``blurWorker`` work request. This constraint means that
   your work request is deferred and only runs once the device's battery is not low.


Create the battery not low constraint

   In the ``data/WorkManagerBluromaticRepository.kt`` file, complete the following steps:

   1. Navigate to the ``applyBlur()`` method.
   2. After the code declaring the ``continuation`` variable, create a new variable named
      ``constraints``, which holds a ``Constraints`` object for the constraint being
      created.
   3. Create a builder for a Constraints object by calling the `Constraints.Builder() <http://d.android.com/reference/androidx/work/Constraints.Builder.html>`__
      function and assign it to the new variable.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      import androidx.work.Constraints

      // ...
          override fun applyBlur(blurLevel: Int) {
              // ...

              val constraints = Constraints.Builder()
      // ...

   4. Chain the `setRequiresBatteryNotLow() <https://developer.android.google.cn/reference/androidx/work/Constraints.Builder#setRequiresBatteryNotLow(kotlin.Boolean)>`__
      method to the call and pass it a value of ``true`` so that the ``WorkRequest`` only
      runs when the device's battery is not low.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      // ...
          override fun applyBlur(blurLevel: Int) {
              // ...

              val constraints = Constraints.Builder()
                  .setRequiresBatteryNotLow(true)
      // ...

   5. Build the object by chaining a call to the ``.build()`` method.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      // ...
          override fun applyBlur(blurLevel: Int) {
              // ...

              val constraints = Constraints.Builder()
                  .setRequiresBatteryNotLow(true)
                  .build()
      // ...

   6. To add the constraint object to the ``blurBuilder`` work request, chain a call to the
      ``.setConstraints()`` method and pass in the constraint object.

   **data/WorkManagerBluromaticRepository.kt**

   .. code:: prettyprint

      // ...
      blurBuilder.setInputData(createInputDataForWorkRequest(blurLevel, imageUri))

      blurBuilder.setConstraints(constraints) // Add this code
      //...


Test with emulator

   1. On an emulator, change the **Charge level** in the **Extended Controls** window to be
      15% or lower to simulate a low battery scenario, **Charger connection** to **AC
      charger,** and **Battery status** to **Not charging.**

   |9b0084cb6e1a8672.png|

   2. Run the app and click **Start** to start blurring the image.

   The emulator's battery charge level is set to low, so ``WorkManager`` does not run the
   ``blurWorker`` work request because of the constraint. It is enqueued but deferred until
   the constraint is met. You can see this deferral in the **Background Task Inspector**
   tab.

   |7518cf0353d04f12.png|

   3. After you confirm it did not run, slowly increase the battery charge level.

   The constraint is met after the battery charge level reaches approximately 25%, and the
   deferred work runs. This outcome appears in the **Background Task Inspector** tab.

   |ab189db49e7b8997.png|

   **Note:** Another good constraint to add to Blur-O-Matic is a `setRequiresStorageNotLow() <https://developer.android.google.cn/reference/androidx/work/Constraints.Builder.html#setRequiresStorageNotLow(kotlin.Boolean)>`__
   constraint when saving. To see a full list of constraint options, check out the
   `Constraints.Builder <http://d.android.com/reference/androidx/work/Constraints.Builder.html>`__
   reference.


8. Write tests for Worker implementations
--------------------------------------------------------------------------------


How to test WorkManager

   Writing tests for Workers and testing using the WorkManager API can be counterintuitive.
   The work done in a Worker does not have direct access to the UIâ€”it is strictly business
   logic. Typically, you test business logic with local unit tests. However, you might
   remember from the Background Work with WorkManager codelab that WorkManger requires an
   Android `Context <https://developer.android.google.cn/reference/android/content/Context>`__ 
   to run. Context is not available in local unit tests by default. Therefore, you must test
   Worker tests with UI tests, even though there are no direct UI elements to test.


Set up dependencies

   You need to add three gradle dependencies to your project. The first two enable JUnit
   and espresso for UI tests. The third dependency provides the work testing API.


**app/build.gradle.kts**

   .. code:: prettyprint

      dependencies {
          // Espresso
          androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
          // Junit
          androidTestImplementation("androidx.test.ext:junit:1.1.5")
          // Work testing
          androidTestImplementation("androidx.work:work-testing:2.8.1")
      }

   You need to use the most current `stable release version <https://developer.android.google.cn/jetpack/androidx/releases/work>`__ 
   of ``work-runtime-ktx`` in your app. If you change the version, make sure to click
   **Sync Now** to sync your project with the updated gradle files.


Create a test class

   1. Create a directory for your UI tests in the **app > src** directory.

      |a7768e9b6ea994d3.png|

      |20cc54de1756c884.png|

   2. Create a new Kotlin class in the ``androidTest/java`` directory called
      ``WorkerInstrumentationTest``.


Write a ``CleanupWorker`` test

   Follow the steps to write a test to verify the implementation of the ``CleanupWorker``.
   Try to implement this verification on your own based on the instructions. The solution
   is provided at the end of the steps.

   1. In ``WorkerInstrumentationTest.kt``, create a ``lateinit`` variable to hold an
      instance of ``Context``.
   2. Create a ``setUp()`` method annotated with ``@Before``.
   3. In the ``setUp()`` method, initialize the ``lateinit`` context variable with an
      application context from ``ApplicationProvider``.
   4. Create a test function called ``cleanupWorker_doWork_resultSuccess()``.
   5. In the ``cleanupWorker_doWork_resultSuccess()`` test, create an instance of the
      ``CleanupWorker``.


**WorkerInstrumentationTest.kt**

   .. code:: prettyprint

      class WorkerInstrumentationTest {
         private lateinit var context: Context

         @Before
         fun setUp() {
             context = ApplicationProvider.getApplicationContext()
         }

         @Test
         fun cleanupWorker_doWork_resultSuccess() {
         }
      }

   When writing the **Blur-O-Matic** app, you use the ``OneTimeWorkRequestBuilder`` to
   create workers. Testing Workers requires different work builders. The WorkManager API
   provides two different builders:

   -  `TestWorkerBuilder <https://developer.android.google.cn/reference/androidx/work/testing/TestWorkerBuilder>`__
   -  `TestListenableWorkerBuilder <https://developer.android.google.cn/reference/androidx/work/testing/TestListenableWorkerBuilder>`__

   Both of these builders let you test the business logic of your worker. For
   ``CoroutineWorkers``, such as ``CleanupWorker``, ``BlurWorker``, and
   ``SaveImageToFileWorker``, use ``TestListenableWorkerBuilder`` for testing because it
   handles the threading complexities of the coroutine.

   6. ``CoroutineWorker``\ s run asynchronously, given the use of coroutines. To execute
      the worker in parallel, use ``runBlocking``. Provide it an empty lambda body to
      start, but you use ``runBlocking`` to instruct the worker to ``doWork()`` directly
      instead of queuing the worker.


**WorkerInstrumentationTest.kt**

   .. code:: prettyprint

      class WorkerInstrumentationTest {
         private lateinit var context: Context

         @Before
         fun setUp() {
             context = ApplicationProvider.getApplicationContext()
         }

         @Test
         fun cleanupWorker_doWork_resultSuccess() {
             val worker = TestListenableWorkerBuilder<CleanupWorker>(context).build()
             runBlocking {
             }
         }
      }

   7. In the lambda body of ``runBlocking``, call ``doWork()`` on the instance of
      ``CleanupWorker`` that you created in step 5 and save it as a value.

   You might recall that the ``CleanupWorker`` deletes any PNG files saved in the
   Blur-O-Matic app's file structure. This process involves file input/output, which means
   that exceptions can be thrown while trying to delete files. For this reason, the attempt
   to delete files is wrapped in a ``try`` block.


**CleanupWorker.kt**

   .. code:: prettyprint

      ...
                  return@withContext try {
                      val outputDirectory = File(applicationContext.filesDir, OUTPUT_PATH)
                      if (outputDirectory.exists()) {
                          val entries = outputDirectory.listFiles()
                          if (entries != null) {
                              for (entry in entries) {
                                  val name = entry.name
                                  if (name.isNotEmpty() && name.endsWith(".png")) {
                                      val deleted = entry.delete()
                                      Log.i(TAG, "Deleted $name - $deleted")
                                  }
                              }
                          }
                      }
                      Result.success()
                  } catch (exception: Exception) {
                      Log.e(
                          TAG,
                          applicationContext.resources.getString(R.string.error_cleaning_file),
                          exception
                      )
                      Result.failure()
                  }

   Note that at the end of the ``try`` block, ``Result.success()`` is returned. If the code
   makes it to ``Result.success()``, there is no error accessing the file directory.

   Now it's time to make an assertion that indicates the worker was successful.

   8. Assert that the result of the worker is ``ListenableWorker.Result.success()``.

   Take a look at the following solution code:


**WorkerInstrumentationTest.kt**

   .. code:: prettyprint

      class WorkerInstrumentationTest {
         private lateinit var context: Context

         @Before
         fun setUp() {
             context = ApplicationProvider.getApplicationContext()
         }

         @Test
         fun cleanupWorker_doWork_resultSuccess() {
             val worker = TestListenableWorkerBuilder<CleanupWorker>(context).build()
             runBlocking {
                 val result = worker.doWork()
                 assertTrue(result is ListenableWorker.Result.Success)
             }
         }
      }


Write a ``BlurWorker`` test

   Follow these steps to write a test to verify the implementation of the ``BlurWorker``.
   Try to implement this verification on your own based on the instructions. The solution
   is provided at the end of the steps.

   1. In ``WorkerInstrumentationTest.kt``, create a new test function called
      ``blurWorker_doWork_resultSuccessReturnsUri()``.

   The ``BlurWorker`` needs an image to process. Therefore, building an instance of the
   ``BlurWorker`` requires some input data that includes such an image.

   2. Outside of the test function, create a mock URI input. The mock URI is a pair that
      contains a key and a URI value. Use the following example code for the key value
      pair:

   .. code:: prettyprint

      KEY_IMAGE_URI to "android.resource://com.example.bluromatic/drawable/android_cupcake"

   3. Build a ``BlurWorker`` inside of the ``blurWorker_doWork_resultSuccessReturnsUri()``
      function and make sure to pass the mock URI input you create as work data through the
      ``setInputData()`` method.

   Similar to the ``CleanupWorker`` test, you must call the implementation of the worker
   inside of ``runBlocking``.

   4. Create a ``runBlocking`` block.
   5. Call ``doWork()`` inside of the ``runBlocking`` block.

   Unlike the ``CleanupWorker``, the ``BlurWorker`` has some output data that is ripe for
   testing!

   6. To access the output data, extract the URI from the result of ``doWork()``.


**WorkerInstrumentationTest.kt**

   .. code:: prettyprint

      @Test
      fun blurWorker_doWork_resultSuccessReturnsUri() {
          val worker = TestListenableWorkerBuilder<BlurWorker>(context)
              .setInputData(workDataOf(mockUriInput))
              .build()
          runBlocking {
              val result = worker.doWork()
              val resultUri = result.outputData.getString(KEY_IMAGE_URI)
          }
      }

   7. Make an assertion that the worker is successful. For an example, take a look at the
      following code from the ``BlurWorker``:


**BlurWorker.kt**

   .. code:: prettyprint

      val resourceUri = inputData.getString(KEY_IMAGE_URI)
      val blurLevel = inputData.getInt(BLUR_LEVEL, 1)

      ...
      val picture = BitmapFactory.decodeStream(
          resolver.openInputStream(Uri.parse(resourceUri))
      )

      val output = blurBitmap(picture, blurLevel)

      // Write bitmap to a temp file
      val outputUri = writeBitmapToFile(applicationContext, output)

      val outputData = workDataOf(KEY_IMAGE_URI to outputUri.toString())

      Result.success(outputData)
      ...

   The ``BlurWorker`` takes the URI and blur level from the input data and creates a
   temporary file. If the operation is successful, it returns a key-value pair containing
   the URI. To check that the contents of the output are correct, make an assertion that
   the output data contains the key ``KEY_IMAGE_URI``.

   8. Make an assertion that the output data contains a URI that starts with the string
      ``"file:///data/user/0/com.example.bluromatic/files/blur_filter_outputs/blur-filter-output-"``

   **Note:** The URI from the result of ``doWork()`` might be null. If the URI is null,
   return false inside of the assertion.

   9. Check your test against the following solution code:


**WorkerInstrumentationTest.kt**

   .. code:: prettyprint

          @Test
          fun blurWorker_doWork_resultSuccessReturnsUri() {
              val worker = TestListenableWorkerBuilder<BlurWorker>(context)
                  .setInputData(workDataOf(mockUriInput))
                  .build()
              runBlocking {
                  val result = worker.doWork()
                  val resultUri = result.outputData.getString(KEY_IMAGE_URI)
                  assertTrue(result is ListenableWorker.Result.Success)
                  assertTrue(result.outputData.keyValueMap.containsKey(KEY_IMAGE_URI))
                  assertTrue(
                      resultUri?.startsWith("file:///data/user/0/com.example.bluromatic/files/blur_filter_outputs/blur-filter-output-")
                          ?: false
                  )
              }
          }


Write a ``SaveImageToFileWorker`` test

   True to its name, the ``SaveImageToFileWorker`` writes a file to disk. Recall that in
   the ``WorkManagerBluromaticRepository``, you add the ``SaveImageToFileWorker`` to the
   WorkManager as a continuation after the ``BlurWorker``. Therefore, it has the same input
   data. It takes the URI from the input data, creates a bitmap, and then writes that
   bitmap to disk as a file. If the operation is successful, the resulting output is an
   image URL. The test for the ``SaveImageToFileWorker`` is very similar to that of the
   ``BlurWorker`` test, the only difference is the output data.

   See if you can write a test for the ``SaveImageToFileWorker`` on your own! When you are
   done, you can check the solution below. Recall the approach you took for the
   ``BlurWorker`` test:

   1. Build the worker, passing the input data.
   2. Make a ``runBlocking`` block.
   3. Call ``doWork()`` on the worker.
   4. Check that the result was successful.
   5. Check the output for the correct key and value.

   **Note:** The URL of the image file that the ``SaveImageToFileWorker`` saves to the disk
   needs to start with the following string: ``"content://media/external/images/media/"``.

   Here is the solution:

   .. code:: prettyprint

      @Test
      fun saveImageToFileWorker_doWork_resultSuccessReturnsUrl() {
          val worker = TestListenableWorkerBuilder<SaveImageToFileWorker>(context)
              .setInputData(workDataOf(mockUriInput))
              .build()
          runBlocking {
              val result = worker.doWork()
              val resultUri = result.outputData.getString(KEY_IMAGE_URI)
              assertTrue(result is ListenableWorker.Result.Success)
              assertTrue(result.outputData.keyValueMap.containsKey(KEY_IMAGE_URI))
              assertTrue(
                  resultUri?.startsWith("content://media/external/images/media/")
                      ?: false
              )
          }
      }


9. Debug WorkManager with Background Task Inspector
--------------------------------------------------------------------------------


Inspect Workers

   Automated tests are a great way to verify the functionality of your Workers. However,
   they don't provide quite as much utility when you are trying to debug a Worker.
   Fortunately, Android Studio has a tool that lets you visualize, monitor, and debug your
   Workers in real time. `Background Task Inspector <https://developer.android.google.cn/studio/inspect/task>`__ 
   works for emulators and devices running API level 26 or higher.

   In this section, you learn some of the features that **Background Task Inspector**
   provides to inspect the workers in **Blur-O-Matic**.

   1. Launch the **Blur-O-Matic** app on a device or emulator.
   2. Navigate to **View > Tool Windows > App Inspection**.

      |798f10dfd8d74bb1.png|

   3. Select the **Background Task Inspector** tab.

      |d601998f3754e793.png|

   4. If necessary, select the device and running process from the drop-down menu.

      In the example images, the process is ``com.example.bluromatic``. It might automatically
      select the process for you. If it selects the wrong process, you can change it.

      |6428a2ab43fc42d1.png|

   5. Click the **Workers** drop-down menu. Currently, there are no workers running, which
      makes sense because there hasn't been an attempt to blur an image.

      |cf8c466b3fd7fed1.png|

   6. In the app, select **More blurred** and click **Start**. You immediately see some
      content in the **Workers** drop-down.

   **Note:** Keep in mind that the **Background Task Inspector** isn't like the debugger in
   the sense that it doesn't stop the workers during their execution; the debugger provides
   that functionality separately. The **Background Task Inspector** only monitors the
   Workers during execution.

   You now see something like this in the **Workers** drop-down.

   |569a8e0c1c6993ce.png|

   The Worker table shows the name of the Worker, the Service (``SystemJobService`` in this
   case), the status of each, and a timestamp. In the screenshot from the previous step,
   notice that the ``BlurWorker`` and the ``CleanupWorker`` have successfully completed
   their work.

   You can also cancel work using the inspector.

   7. Select an enqueued worker and click **Cancel Selected Worker** |7108c2a82f64b348.png|
      from the toolbar.


Inspect task details

   1. Click on a worker in the **Workers** table. |97eac5ad23c41127.png|

   Doing so brings up the **Task Details** window.

   |9d4e17f7d4afa6bd.png|

   2. Review the information shown in the **Task Details**. |59fa1bf4ad8f4d8d.png|

   The details show the following categories:

   -  **Description**: This section lists the Worker class name with the fully-qualified
      package as well as the assigned tag and the UUID of this worker.
   -  **Execution**: This section shows the worker's constraints (if any), running
      frequency, its state, and which class created and queued this worker. Recall the
      BlurWorker has a constraint that prevents it from executing when the battery is low.
      When you inspect a Worker that has constraints, they appear in this section.
   -  **WorkContinuation**: This section displays where this worker is in the work chain.
      To check the details of another worker in the work chain, click on its UUID.
   -  **Results**: This section displays the start time, retry count, and the output data
      of the selected worker.


Graph view

   Recall that the workers in **Blur-O-Matic** are chained. The Background Task Inspector
   offers a graph view that represents worker dependencies visually.

   At the corner of the **Background Task Inspector** window, there are two buttons to
   toggle between â€” **Show Graph View** and **Show List View**.

   |4cd96a8b2773f466.png|

   1. Click **Show Graph View** |6f871bb00ad8b11a.png|:

   |ece206da18cfd1c9.png|

   The graph view accurately indicates the Worker dependency implemented in the
   **Blur-O-Matic** app.

   2. Click **Show List View** |669084937ea340f5.png| to exit the graph view.


Additional features

   The **Blur-O-Matic** app only implements Workers to complete background tasks. However,
   you can read more about the tools available to inspect other types of background work in
   the documentation for the `Background Task Inspector <https://developer.android.google.cn/studio/inspect/task#inspect-jobs-alarms-wakelocks>`__.


10. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-workmanager.git
      $ cd basic-android-kotlin-compose-training-workmanager
      $ git checkout main

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-workmanager/archive/refs/heads/main.zip>`__

   If you want to see the solution code for this codelab, view it on
   `GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-workmanager>`__.


11. Congratulations
--------------------------------------------------------------------------------

   Congratulations! You learned about additional WorkManger functionality, wrote automated
   tests for the **Blur-O-Matic** workers, and used the **Background Task Inspector** to
   examine them. In this codelab, you learned:

   -  Naming unique ``WorkRequest`` chains.
   -  Tagging ``WorkRequest``s.
   -  Updating the UI based on the ``WorkInfo``.
   -  Canceling a ``WorkRequest``.
   -  Adding constraints to a ``WorkRequest``.
   -  The WorkManager testing API.
   -  How to approach testing worker implementations.
   -  How to test ``CoroutineWorker``s.
   -  How to manually inspect workers and verify their functionality.

.. |3395cc370b580b32.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/3395cc370b580b32.png
.. |c5622f923670cf67.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/c5622f923670cf67.png
.. |97252f864ea042aa.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/97252f864ea042aa.png
.. |81ba9962a8649e70.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/81ba9962a8649e70.png
.. |9d76d5d7f231c6b6.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/9d76d5d7f231c6b6.png
.. |926e532cc24a0d4f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/926e532cc24a0d4f.png
.. |5cec830cc8ef647e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/5cec830cc8ef647e.png
.. |7656dd320866172e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/7656dd320866172e.png
.. |9b0084cb6e1a8672.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/9b0084cb6e1a8672.png
.. |7518cf0353d04f12.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/7518cf0353d04f12.png
.. |ab189db49e7b8997.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/ab189db49e7b8997.png
.. |a7768e9b6ea994d3.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/a7768e9b6ea994d3.png
.. |20cc54de1756c884.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/20cc54de1756c884.png
.. |798f10dfd8d74bb1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/798f10dfd8d74bb1.png
.. |d601998f3754e793.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/d601998f3754e793.png
.. |6428a2ab43fc42d1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/6428a2ab43fc42d1.png
.. |cf8c466b3fd7fed1.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/cf8c466b3fd7fed1.png
.. |569a8e0c1c6993ce.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/569a8e0c1c6993ce.png
.. |7108c2a82f64b348.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/7108c2a82f64b348.png
.. |97eac5ad23c41127.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/97eac5ad23c41127.png
.. |9d4e17f7d4afa6bd.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/9d4e17f7d4afa6bd.png
.. |59fa1bf4ad8f4d8d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/59fa1bf4ad8f4d8d.png
.. |4cd96a8b2773f466.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/4cd96a8b2773f466.png
.. |6f871bb00ad8b11a.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/6f871bb00ad8b11a.png
.. |ece206da18cfd1c9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/ece206da18cfd1c9.png
.. |669084937ea340f5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-verify-background-work/img/669084937ea340f5.png


ğŸš€ Practice: Build Water Me app
===============================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-practice-water-me-app


1. Before you begin
--------------------------------------------------------------------------------


Introduction

   In this unit, you learned about ``WorkManager``, which is a Jetpack library for deferrable
   background work. **This background work is guaranteed to run even if you close its source app.**

   While learning about ``WorkManager``, you learned how to define work in a ``Worker`` class, how
   to create a WorkRequest for the ``Worker``, and how to enqueue and schedule work.

   In this practice set, you take the concepts you learned and enhance the **Water Me!**
   app.

   The solution code is available at the end. To make the most of this learning experience,
   try to implement and troubleshoot as much as you can before looking at the provided
   solution code. It is during this hands-on time that you learn the most.


Prerequisites

   -  Android Basics with Compose coursework through the 
      `Advanced WorkManager and Testing codelab <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-verify-background-work>`__


What you'll need

   -  A computer with internet access and Android Studio


What you'll build

   In this practice set, you take the concepts you learned and enhance the **Water Me!**
   app.

   The app currently displays a list of plants in a scrolling list. When you tap on a
   plant, the app lets you set a reminder to water the plant.

   |fb69d6519999f217.png| |d6b68d1e9f1026c5.png|

   While you can select a reminder timeframe, the reminder notification doesn't display.

   Your job is to implement the background work for the reminder notification to display.

   After you complete your code, the app can then display a reminder notification after a
   selected time duration elapses.

   |a8f9bceed83af5a9.png|


2. Get the starter code
--------------------------------------------------------------------------------

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-waterme/archive/refs/heads/starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-waterme.git
      $ cd basic-android-kotlin-compose-training-waterme
      $ git checkout starter

   **Note:** The starter code is in the ``starter`` branch of the cloned repository.

   You can browse the code for the **Water Me!** app in this
   `GitHub repository.<https://github.dev/google-developer-training/basic-android-kotlin-compose-training-waterme/tree/starter>`__


Run starter code

   To familiarize yourself with the starter code, complete the following steps:

   1. Open the project with the starter code in Android Studio.
   2. Run the app on an Android device or emulator.

   You are now ready to begin coding!


3. Schedule notification using WorkManager
--------------------------------------------------------------------------------

   The functionality for the **Water Me!** app is mostly implemented except for the ability
   to schedule the reminder notification.

   The code to make a notification is in the ``WaterReminderWorker.kt`` file, which is in
   the **worker** package. The ``WaterReminderWorker`` class extends the
   ``CoroutineWorker`` class, and the code to make the notification is inside its
   ``doWork()`` method.

   Because notifications might be a new topic for you, this code is already complete.

   .. code:: prettyprint

      override suspend fun doWork(): Result {

          val plantName = inputData.getString(nameKey)

          makePlantReminderNotification(
              applicationContext.resources.getString(R.string.time_to_water, plantName),
              applicationContext
          )

          return Result.success()
      }

   Your task is to create a `OneTimeWorkRequest <https://developer.android.google.cn/reference/androidx/work/OneTimeWorkRequest>`__
   that calls this method with the correct parameters from the
   ``WorkManagerWaterRepository``.

   For additional help, refer to `Background Work with WorkManager <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-workmanager>`__.


Create work requests

   To schedule the notification, you need to implement the ``scheduleReminder()`` method in
   the ``WorkManagerWaterRepository.kt`` file.

   1. Create a variable called ``data`` with ``Data.Builder``. The data needs to consist of
      a single string value where ``WaterReminderWorker.nameKey`` is the key and the
      ``plantName`` passed into ``scheduleReminder()`` is the value.

   2. Create a one-time work request with the ``WaterReminderWorker`` class. Use the
      ``duration`` and ``unit`` passed into the ``scheduleReminder()`` function and set the
      input data to the data variable you create.

   3. Call the ``workManager``'s ``enqueueUniqueWork()`` method. Pass in the plant name
      concatenated with the duration, use ``REPLACE`` as the ``ExistingWorkPolicy``, and
      the work request object.

   **Note:** Passing in the plant name, concatenated with the duration, lets you set
   multiple reminders per plant. You can schedule one reminder in 5 seconds for a Peony and
   another reminder in 1 day for a Peony. If you only pass in the plant name, when you
   schedule the second reminder for a Peony, it replaces the previously scheduled reminder
   for the Peony.

   Your app should now work as expected.


4. Additional challenge (optional)
--------------------------------------------------------------------------------

   For additional coding practice, change the time duration options to the following:

   -  5 seconds
   -  1 minute
   -  2 minutes
   -  3 minutes

   After you finish, test each duration to confirm it works as expected.

   **Note:** The provided solution code does not contain the implementation of this
   additional challenge.


5. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-waterme.git
      $ cd basic-android-kotlin-compose-training-waterme
      $ git checkout main

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-waterme/archive/refs/heads/main.zip>`__

   If you want to see the solution code for this codelab, view it on
   `GitHub <https://github.dev/google-developer-training/basic-android-kotlin-compose-training-waterme/tree/main>`__.

.. |fb69d6519999f217.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-water-me-app/img/fb69d6519999f217.png
.. |d6b68d1e9f1026c5.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-water-me-app/img/d6b68d1e9f1026c5.png
.. |a8f9bceed83af5a9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-practice-water-me-app/img/a8f9bceed83af5a9.png


ğŸš€ Build an Android App with Views
==================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-app-with-views


1. Before you begin
--------------------------------------------------------------------------------


Introduction

   So far, you learned all about building Android apps with Compose. That's a good thing!
   Compose is a very powerful tool that can simplify the development process. However,
   Android apps were not always built with declarative UIs. Compose is a very recent tool
   in the history of Android Apps. Android UIs were originally built with Views. As such,
   it's highly likely that you will encounter Views as you continue your journey as an
   Android developer. In this codelab, you learn the basics of how Android apps were built
   before Compose â€” with XML, Views, View Bindings, and Fragments.


Prerequisites:

   -  Complete the Android Basics with Compose coursework through 
      `Unit 7 <https://developer.android.google.cn/courses/android-basics-compose/unit-7>`__.


What you'll need

   -  A computer with internet access and Android Studio
   -  A device or emulator
   -  The starter code for the Juice Tracker app


What you'll build

   In this codelab, you complete the Juice Tracker app. This app lets you keep track of
   notable juices by building a list consisting of detailed items. You add and modify
   Fragments and XML to complete the UI and the starter code. Specifically, you build the
   entry form for creating a new juice, including the UI and any associated logic or
   navigation. The result is an app with an empty list to which you can add your own
   juices.

   |d6dc43171ae62047.png| |87b2ca7b49e814cb.png| |2d630489477e216e.png|


2. Get the starter code
--------------------------------------------------------------------------------

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/tree/views-starter

   **Branch name with starter code:** ``views-starter``

   1. In Android Studio, open the ``basic-android-kotlin-compose-training-juice-tracker``
      folder.
   2. Open the Juice Tracker app code in Android Studio.


3. Create a Layout
--------------------------------------------------------------------------------

   When building an app with `Views <https://developer.android.google.cn/reference/android/view/View>`__, 
   you construct the UI inside of a `Layout <https://developer.android.google.cn/develop/ui/views/layout/declaring-layout>`__.
   Layouts are typically declared using XML. These XML layout files are located in the
   resources directory under **res > layout**. Layouts contain the components that make up
   the UI; these components are known as ``View``s. XML syntax consists of tags,
   elements, and attributes. For more details on XML syntax, reference the 
   `Create XML layouts for Android <https://developer.android.google.cn/codelabs/basic-android-kotlin-training-xml-layouts>`__
   codelab.

   In this section, you build an XML layout for the "**Type of juice**" entry dialog
   pictured.

   |87b2ca7b49e814cb.png|

   1. Create a new **Layout Resource File** in the **main > res > layout** directory called
      ``fragment_entry_dialog``.

   .. figure:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/331927b84e9d1a27.png

      Android studio project pane context pane opened with an option to create a layout
      resource file.

   |6adb279d6e74ab13.png|

   The ``fragment_entry_dialog.xml`` layout contains the UI components that the app
   displays to the user.

   Notice that the **Root element** is a ``ConstraintLayout``. This type of layout is a
   ``ViewGroup`` that lets you position and size Views in a flexible way using the
   constraints. A ``ViewGroup`` is a type of ``View`` that contains other ``View``s,
   called children or child ``View``s. The following steps cover this topic in more
   detail, but you can learn more about ``ConstraintLayout`` in 
   `Build a Responsive UI with ConstraintLayout <https://developer.android.google.cn/develop/ui/views/layout/constraint-layout>`__.

   2. After you create the file, define the app name space in the ``ConstraintLayout``.

   **``fragment_entry_dialog.xml``**

   .. code:: prettyprint

      <androidx.constraintlayout.widget.ConstraintLayout
         xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:app="http://schemas.android.com/apk/res-auto"
         android:layout_width="match_parent"
         android:layout_height="match_parent">
      </androidx.constraintlayout.widget.ConstraintLayout>

   3. Add the following guidelines to the ``ConstraintLayout``.

   **``fragment_entry_dialog.xml``**

   .. code:: prettyprint

      <androidx.constraintlayout.widget.Guideline
         android:id="@+id/guideline_left"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:orientation="vertical"
         app:layout_constraintGuide_begin="16dp" />
      <androidx.constraintlayout.widget.Guideline
         android:id="@+id/guideline_middle"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:orientation="vertical"
         app:layout_constraintGuide_percent="0.5" />
      <androidx.constraintlayout.widget.Guideline
         android:id="@+id/guideline_top"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:orientation="horizontal"
         app:layout_constraintGuide_begin="16dp" />

   These ``Guideline``s serve as padding for other views. The guidelines constrain the
   "**Type of juice**" header text.

   4. Create a ``TextView`` element. This ``TextView`` represents the title of the detail
      fragment.

   |110cad4ae809e600.png|

   5. Set the ``TextView`` an ``id`` of ``header_title``.
   6. Set ``layout_width`` to ``0dp``. Layout constraints ultimately define this
      ``TextView``'s width. Therefore, defining a width only adds unnecessary calculations
      during the drawing of the UI; defining a width of ``0dp`` avoids the extra
      calculations.
   7. Set the ``TextView text`` attribute to ``@string/juice_type``.
   8. Set the ``textAppearance`` to ``@style/TextAppearance.MaterialComponents.Headline5``.

   **``fragment_entry_dialog.xml``**

   .. code:: prettyprint

      <TextView
         android:id="@+id/header_title"
         android:layout_width="0dp"
         android:layout_height="wrap_content"
         android:text="@string/juice_type"
         android:textAppearance="@style/TextAppearance.MaterialComponents.Headline5" />

   Lastly, you need to define the constraints. Unlike the ``Guideline``s, which use
   dimensions as constraints, the guidelines themselves constrain this ``TextView``. To
   achieve this outcome, you can reference the id of the ``Guideline`` by which you want to
   constrain the view.

   9. Constrain the top of the header to the bottom of ``guideline_top``.

   **``fragment_entry_dialog.xml``**

   .. code:: prettyprint

      <TextView
         android:id="@+id/header_title"
         android:layout_width="0dp"
         android:layout_height="wrap_content"
         android:text="@string/juice_type"
         android:textAppearance="@style/TextAppearance.MaterialComponents.Headline5"
         app:layout_constraintTop_toBottomOf="@+id/guideline_top" />

   10. Constrain the end to the start of ``guideline_middle`` and the start to the start of
       ``guideline_left`` to finish the ``TextView`` placement. Keep in mind that how you
       constrain a given view depends entirely on how you want your UI to look.

   **``fragment_entry_dialog.xml``**

   .. code:: prettyprint

      <TextView
         android:id="@+id/header_title"
         android:layout_width="0dp"
         android:layout_height="wrap_content"
         android:text="@string/juice_type"
         android:textAppearance="@style/TextAppearance.MaterialComponents.Headline5"
         app:layout_constraintTop_toBottomOf="@+id/guideline_top"
         app:layout_constraintEnd_toStartOf="@+id/guideline_middle"
         app:layout_constraintStart_toStartOf="@+id/guideline_left" />

   Try to build the rest of the UI based on the screenshots. You can find the completed
   `fragment_entry_dialog.xml <https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/blob/views/app/src/main/res/layout/fragment_entry_dialog.xml>`__
   file in the `solution <https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/tree/views>`__.


4. Create a Fragment with Views
--------------------------------------------------------------------------------

   In Compose, you build layouts declaratively using Kotlin or Java. You can access
   different "screens" by navigating to different Composables, typically within the same
   activity. When building an app with Views, a Fragment that hosts the XML layout replaces
   the concept of a Composable "screen."

   In this section, you create a ``Fragment`` to host the ``fragment_entry_dialog`` layout
   and provide data to the UI.

   1. In the ``juicetracker`` package, create a new class called ``EntryDialogFragment``.
   2. Make the ``EntryDialogFragment`` extend the ``BottomSheetDialogFragment``.

   **``EntryDialogFragment.kt``**

   .. code:: prettyprint

      import com.google.android.material.bottomsheet.BottomSheetDialogFragment


      class EntryDialogFragment : BottomSheetDialogFragment() {
      }

   The ``DialogFragment`` is a ``Fragment`` that displays a floating dialog.
   ``BottomSheetDialogFragment`` inherits from the ``DialogFragment`` class, but displays a
   sheet the width of the screen pinned to the bottom of the screen. This approach matches
   the design pictured previously.

   3. Rebuild the project, which causes View Binding files based on the
      ``fragment_entry_dialog`` layout to autogenerate. The View Bindings let you access
      and interact with XML declared ``View``s, you can read more about them in the 
      `View Binding <https://developer.android.google.cn/topic/libraries/view-binding>`__
      documentation.
   4. In the ``EntryDialogFragment`` class, implement the ``onCreateView()``function. As
      the name suggests, this function creates the ``View`` for this ``Fragment``.

   **Note:** Like an ``Activity``, a ``Fragment`` also has different 
   `lifecycle states <https://developer.android.google.cn/guide/fragments/lifecycle>`__, 
   and corresponding lifecycle methods.

   **``EntryDialogFragment.kt``**

   .. code:: prettyprint

      import android.os.Bundle
      import android.view.LayoutInflater
      import android.view.View
      import android.view.ViewGroup

      override fun onCreateView(
         inflater: LayoutInflater,
         container: ViewGroup?,
         savedInstanceState: Bundle?
      ): View? {
         return super.onCreateView(inflater, container, savedInstanceState)
      }

   The ``onCreateView()`` function returns a ``View``, but right now, it does not return a
   useful ``View``.

   5. Return the ``View`` generated by inflating the ``FragmentEntryDialogViewBinding``
      instead of returning ``super.onCreateView()``.

   **``EntryDialogFragment.kt``**

   .. code:: prettyprint

      import com.example.juicetracker.databinding.FragmentEntryDialogBinding


      override fun onCreateView(
         inflater: LayoutInflater,
         container: ViewGroup?,
         savedInstanceState: Bundle?
      ): View? {
         return FragmentEntryDialogBinding.inflate(inflater, container, false).root
      }

   6. Outside of the ``onCreateView()`` function, but inside the ``EntryDialogFragment``
      class, create an instance of the ``EntryViewModel``.
   7. Implement the ``onViewCreated()`` function.

   After you inflate the View binding, you can access and modify the ``View``s in the
   layout. The ``onViewCreated()`` method is called after ``onCreateView()`` in the
   lifecycle. The ``onViewCreated()`` method is the recommended place to access and modify
   the ``View``s within the layout.

   8. Create an instance of the view binding by calling the ``bind()`` method on
      ``FragmentEntryDialogBinding``.

   At this point, your code should look like the following example:

   **``EntryDialogFragment.kt``**

   .. code:: prettyprint

      import androidx.fragment.app.viewModels
      import com.example.juicetracker.ui.AppViewModelProvider
      import com.example.juicetracker.ui.EntryViewModel

      class EntryDialogFragment : BottomSheetDialogFragment() {

         private val entryViewModel by viewModels<EntryViewModel> { AppViewModelProvider.Factory }

         override fun onCreateView(
             inflater: LayoutInflater,
             container: ViewGroup?,
             savedInstanceState: Bundle?
         ): View {
             return FragmentEntryDialogBinding.inflate(inflater, container, false).root
         }

         override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
              val binding = FragmentEntryDialogBinding.bind(view)
          }
      }

   You can access and set Views through the binding. For example, you can set a
   ``TextView`` through the ``setText()`` method.

   .. code:: prettyprint

      binding.name.setText("Apple juice")

   **Note:** The use of the hard-coded string **"Apple juice"** in the above example was
   done for simplicity. In production, string resources should be used.

   The entry dialog UI serves as a place for a user to create a new item, but you can also
   use it to modify an existing item. Therefore, the Fragment needs to retrieve a clicked
   item. The Navigation Component facilitates navigating to the ``EntryDialogFragment`` and
   retrieving a clicked item.

   The ``EntryDialogFragment`` is not yet complete, but don't worry! For now, move on to
   the next section to learn more about using the Navigation Component in an app with
   ``View``s.


5. Modify the Navigation Component
--------------------------------------------------------------------------------

   In this section, you use the navigation component to launch the entry dialog and to
   retrieve an item, if applicable.

   Compose affords the opportunity to render different composables simply by calling them.
   However, Fragments work differently. The 
   `Navigation Component <https://developer.android.google.cn/guide/navigation/navigation-getting-started>`__
   coordinates Fragment "destinations," providing an easy way to move between different
   Fragments and the Views they contain.

   Use the Navigation Component to coordinate navigation to your ``EntryDialogFragment``.

   1. Open the ``nav_graph.xml`` file and make sure the **Design** tab is selected.

      |783cb5d7ff0ba127.png|

   2. Click the |93401bf098936c15.png| icon to add a new destination.

      |d5410c90e408b973.png|

   3. Select ``EntryDialogFragment`` destination. This action declares the
      ``entryDialogFragment`` in the nav graph, making it accessible for navigation
      actions.

      |418feed425072ea4.png|

   **Note:** The ``entryDialogFragment`` screen might appear in a random place in the
   ``nav_graph.xml`` display. You can drag the destinations to make the display more
   organized.

   You need to launch the ``EntryDialogFragment`` from the ``TrackerFragment``. Therefore,
   a navigation action needs to accomplish this task.

   4. Drag your cursor over the ``trackerFragment``. Selecting the gray dot and drag the
      line to the ``entryDialogFragment``. |85decb6fcddec713.png|
   5. The nav_graph design view lets you declare arguments for a destination by selecting
      the destination and clicking the |a0d73140a20e4348.png| icon next to the
      **Arguments** dropdown. Use this feature to add an ``itemId`` argument of type
      ``Long`` to the ``entryDialogFragment``; the default value should be ``0L``.

   |555cf791f64f62b8.png|

   |840105bd52f300f7.png|

   Note that the ``TrackerFragment`` holds a list of ``Juice`` items â€” if you click one of
   these items, the ``EntryDialogFragment`` launches.

   6. Rebuild the project. The ``itemId`` argument is now accessible in the
      ``EntryDialogFragment``.


6. Complete the Fragment
--------------------------------------------------------------------------------

   With the data from the navigation arguments, complete the entry dialog.

   1. Retrieve the ``navArgs()`` in the ``onViewCreated()`` method of the
      ``EntryDialogFragment``.
   2. Retrieve the ``itemId`` from the ``navArgs()``.
   3. Implement the ``saveButton`` to save the new/modified juice using the ``ViewModel``.

   Recall from the entry dialog UI that the default color value is red. For now, pass this
   as a place holder.

   Pass the item id from the args when calling ``saveJuice()``.

   **``EntryDialogFragment.kt``**

   .. code:: prettyprint

      import androidx.navigation.fragment.navArgs
      import com.example.juicetracker.data.JuiceColor


      class EntryDialogFragment : BottomSheetDialogFragment() {

         //...
         var selectedColor: JuiceColor = JuiceColor.Red

         override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
              val binding = FragmentEntryDialogBinding.bind(view)
              val args: EntryDialogFragmentArgs by navArgs()
              val juiceId = args.itemId

              binding.saveButton.setOnClickListener {
                 entryViewModel.saveJuice(
                     juiceId,
                     binding.name.text.toString(),
                     binding.description.text.toString(),
                     selectedColor.name,
                     binding.ratingBar.rating.toInt()
                 )
              }
          }
      }

   4. After the data is saved, dismiss the dialog with the ``dismiss()`` method.

   **``EntryDialogFragment.kt``**

   .. code:: prettyprint

      class EntryDialogFragment : BottomSheetDialogFragment() {

          //...
          var selectedColor: JuiceColor = JuiceColor.Red
          //...

          override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
              val binding = FragmentEntryDialogBinding.bind(view)
              val args: EntryDialogFragmentArgs by navArgs()
              binding.saveButton.setOnClickListener {
                 entryViewModel.saveJuice(
                     juiceId,
                     binding.name.text.toString(),
                     binding.description.text.toString(),
                     selectedColor.name,
                     binding.ratingBar.rating.toInt()
                 )
                 dismiss()
              }
          }
      }

   Keep in mind that the above code does not complete the ``EntryDialogFragment``. You
   still need to implement a number of things, such as the population of the fields with
   existing ``Juice`` data (if applicable), the selection of a color from the
   ``colorSpinner``, the implementation of the ``cancelButton``, and more. However, this
   code is not unique to ``Fragment``s, and you are able to implement this code on your
   own. Try to implement the rest of the functionality. As a last resort, you can refer to
   the solution code for this codelab.


7. Launch the entry dialog
--------------------------------------------------------------------------------

   The last task is to launch the entry dialog using the Navigation Component. The entry
   dialog needs to launch when the user clicks the floating action button (**FAB**). It
   needs to also launch and pass the corresponding id when the user clicks an item.

   1. In the ``onClickListener()`` for the FAB, call ``navigate()`` on the nav controller.

   **``TrackerFragment.kt``**

   .. code:: prettyprint

      import androidx.navigation.findNavController


      //...

      binding.fab.setOnClickListener { fabView ->
         fabView.findNavController().navigate(
         )
      }

      //...

   2. In the navigate function, pass the action to navigate from the tracker to the entry
      dialog.

   **``TrackerFragment.kt``**

   .. code:: prettyprint

      //...

      binding.fab.setOnClickListener { fabView ->
         fabView.findNavController().navigate(
      TrackerFragmentDirections.actionTrackerFragmentToEntryDialogFragment()
         )
      }

      //...

   3. Repeat this action in the lambda body for the ``onEdit()`` method in the
      ``JuiceListAdapter``, but this time, pass the ``id`` of the ``Juice``.

   **``TrackerFragment.kt``**

   .. code:: prettyprint

      //...

      onEdit = { drink ->
         findNavController().navigate(
             TrackerFragmentDirections.actionTrackerFragmentToEntryDialogFragment(drink.id)
         )
      },

      //...


8. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker.git
      $ cd basic-android-kotlin-compose-training-juice-tracker
      $ git checkout views

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/archive/refs/heads/views.zip>`__

   **Note:** The solution code is in the ``views`` branch of the downloaded repository.

   If you want to see the solution code, 
   `view it on GitHub <https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/tree/views>`__.

.. |d6dc43171ae62047.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/d6dc43171ae62047.png
.. |87b2ca7b49e814cb.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/87b2ca7b49e814cb.png
.. |2d630489477e216e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/2d630489477e216e.png
.. |6adb279d6e74ab13.png|image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/6adb279d6e74ab13.png
.. |110cad4ae809e600.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/110cad4ae809e600.png
.. |783cb5d7ff0ba127.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/783cb5d7ff0ba127.png
.. |93401bf098936c15.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/93401bf098936c15.png
.. |d5410c90e408b973.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/d5410c90e408b973.png
.. |418feed425072ea4.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/418feed425072ea4.png
.. |85decb6fcddec713.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/85decb6fcddec713.png
.. |a0d73140a20e4348.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/a0d73140a20e4348.png
.. |555cf791f64f62b8.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/555cf791f64f62b8.png
.. |840105bd52f300f7.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-app-with-views/img/840105bd52f300f7.png


ğŸš€ Add Compose to a legacy app
==============================

   https://developer.android.google.cn/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app


1. Before you begin
--------------------------------------------------------------------------------

   From the start, Jetpack Compose was designed with View interoperability, which means
   that Compose and the View system can share resources and work together side by side to
   display the UI. This functionality lets you add Compose to your existing View-based app.
   That means Compose and Views can co-exist in your codebase until your entire app is
   fully in Compose.

   In this codelab, you change the view-based list item in the **Juice Tracker** app to
   Compose. You can convert the rest of Juice Tracker's views on your own, if you wish.

   If you have an app with a View-based UI, you might not want to rewrite its entire UI all
   at once. This codelab helps you convert a single view in a view-based UI to a Compose
   element.


Prerequisites

   -  Familiarity with a View-based UI.
   -  Knowledge of how to build an app using a View-based UI.
   -  Experience with the Kotlin syntax, including lambdas.
   -  Knowledge of how to build an app in Jetpack Compose.


What you'll learn

   -  How to add Compose to an existing screen that was built with Android views.
   -  How to preview a Composable added to your View-based app.


What you'll build

   -  You convert a View-based list item to Compose in the **Juice Tracker** app.


2. Starter app overview
--------------------------------------------------------------------------------

   This codelab uses the **Juice Tracker** app solution code from the 
   `Build an Android App with Views <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-app-with-views>`__
   as the starter code. The starter app already saves data using the
   `Room <https://developer.android.google.cn/reference/androidx/room/package-summary>`__
   persistence library. The user can add juice info to the app database, like juice name,
   description, color, and rating.

   |36bd5542e97fee2e.png|

   In this codelab, you convert the view-based list item to Compose.

   |List item with juice details|

   Download the starter code for this codelab

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/archive/refs/heads/views.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker.git
      $ cd basic-android-kotlin-compose-training-juice-tracker
      $ git checkout views

   **Note:** The starter code is in the ``views`` branch of the downloaded repository.

   You can browse the code in the
   `JuiceTracker <https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/tree/views>`__
   GitHub repository.


3. Add Jetpack Compose library
--------------------------------------------------------------------------------

   Recollect, Compose and Views can exist together on a given screen; you can have some UI
   elements in Compose and others in the View system. For example, you can have only the
   list in Compose, while the rest of the screen is in the View system.

   Complete the following steps to add the Compose library to the **Juice Tracker** app.

   1. Open the Juice Tracker in Android Studio.
   2. Open the app-level ``build.gradle.kts``.
   3. Inside the ``buildFeatures`` block, add a ``compose = true`` flag.

   .. code:: prettyprint

      buildFeatures {
          //...
          // Enable Jetpack Compose for this module
          compose = true
      }

   This flag enables Android Studio to work with Compose. You have not done this step in
   the previous codelabs because Android Studio automatically generates this code when you
   create a new Android Studio Compose template project.

   4. Below the ``buildFeatures``, add the ``composeOptions`` block.
   5. Inside the block, set ``kotlinCompilerExtensionVersion`` to ``"1.5.1"`` to set the
      Kotlin compiler version.

   .. code:: prettyprint

      composeOptions {
          kotlinCompilerExtensionVersion = "1.5.1"
      }

   6. In the ``dependencies`` section, add Compose dependencies. You need the following
      dependencies to add Compose to a View based app. These dependencies help integrate
      Compose with the Activity, add the Compose design components library, support Compose
      Jetpack theming, and provide tools for better IDE support.

   .. code:: prettyprint

      dependencies {
          implementation(platform("androidx.compose:compose-bom:2023.06.01"))
          // other dependencies 
          // Compose
          implementation("androidx.activity:activity-compose:1.7.2")
          implementation("androidx.compose.material3:material3")
          implementation("com.google.accompanist:accompanist-themeadapter-material3:0.28.0")


          debugImplementation("androidx.compose.ui:ui-tooling")
      }


Add ComposeView

   A `ComposeView <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/platform/ComposeView>`__
   is an Android View that can host Jetpack Compose UI content. Use
   `setContent <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/platform/ComposeView#setContent(kotlin.Function0)>`__
   to supply the content composable function for the view.

   1. Open the ``layout/list_item.xml`` and view the preview in the **Split** tab.

   By the end of this codelab, you will replace this view with a composable.

   |97412dabc6dc49b6.png|

   2. In `JuiceListAdapter.kt <http://juicelistadapter.kt>`__, remove
      ``ListItemBinding`` from everywhere. In the ``JuiceListViewHolder`` class, replace
      ``binding.root`` with ``composeView``.

   .. code:: prettyprint

      import androidx.compose.ui.platform.ComposeView

      class JuiceListViewHolder(
          private val onEdit: (Juice) -> Unit,
          private val onDelete: (Juice) -> Unit
      ): RecyclerView.ViewHolder(composeView) 

   3. In the ``onCreateViewHolder()`` folder, update the ``return()`` function to match the
      following code:

   .. code:: prettyprint

      override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): JuiceListViewHolder {
         return JuiceListViewHolder(
             ComposeView(parent.context),
             onEdit,
             onDelete
         )
      }

   4. In the ``JuiceListViewHolder`` class, delete all the ``private`` variables and remove
      all the code from the ``bind()`` function. Your ``JuiceListViewHolder`` class now
      looks like the following code:

   .. code:: prettyprint

      class JuiceListViewHolder(
          private val onEdit: (Juice) -> Unit,
          private val onDelete: (Juice) -> Unit
      ) : RecyclerView.ViewHolder(composeView) {

         fun bind(juice: Juice) {

         }
      }

   5. At this point, you can delete
      ``com.example.juicetracker.databinding.ListItemBinding`` and
      ``android.view.LayoutInflater`` imports.

   .. code:: prettyprint

      // Delete
      import com.example.juicetracker.databinding.ListItemBinding
      import android.view.LayoutInflater

   6. Delete the ``layout/list_item.xml`` file.
   7. Select **OK** in the **Delete** dialog.

   |be6304b98a377f30.png|


4. Add composable function
--------------------------------------------------------------------------------

   Next, you create a composable that emits the list item. The Composable takes ``Juice``
   and two callback functions to edit and to delete the list item.

   1. In ``JuiceListAdapter.kt``, after the ``JuiceListAdapter`` class definition, create a
      composable function called ``ListItem()``.
   2. Make the ``ListItem()`` function accept the ``Juice`` object and a lambda callback
      for delete.

   .. code:: prettyprint

      import androidx.compose.runtime.Composable
      import androidx.compose.ui.Modifier


      @Composable
      fun ListItem(
          input: Juice,
          onDelete: (Juice) -> Unit,
          modifier: Modifier = Modifier
      ) {
      }

   Take a look at the preview of the list item you want to create. Notice that it has a
   juice icon, juice details, and a delete button icon. You will be implementing these
   components shortly.

   |4ec7f82371c6bc15.png|


Create Juice icon composable

   1. In ``JuiceListAdapter.kt``, after the ``ListItem()`` composable, create another
      composable function called ``JuiceIcon()`` that takes a ``color`` and a ``Modifier``.

   .. code:: prettyprint

      @Composable
      fun JuiceIcon(color: String, modifier: Modifier = Modifier) {

      }

   2. Inside the ``JuiceIcon()`` function, add variables for the ``color`` and the content
      description as shown in the following code:

   .. code:: prettyprint

      @Composable
      fun JuiceIcon(color: String, modifier: Modifier = Modifier) {
         val colorLabelMap = JuiceColor.values().associateBy { stringResource(it.label) }
         val selectedColor = colorLabelMap[color]?.let { Color(it.color) }
         val juiceIconContentDescription = stringResource(R.string.juice_color, color)

      }

   Using ``colorLabelMap`` and ``selectedColor`` variables you will retrieve the color
   resource associated with the user selection.

   3. Add a ``Box`` layout to display two icons *``ic_juice_color``* and
      *``ic_juice_clear``* on top of each other. The *``ic_juice_color``* icon has a tint
      and is aligned to the center.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Box


      Box(
         modifier.semantics {
             contentDescription = juiceIconContentDescription
         }
      ) {
         Icon(
             painter = painterResource(R.drawable.ic_juice_color),
             contentDescription = null,
             tint = selectedColor ?: Color.Red,
             modifier = Modifier.align(Alignment.Center)
         )
         Icon(painter = painterResource(R.drawable.ic_juice_clear), contentDescription = null)
      }

   Since you are familiar with the composable implementation, details about how it is
   implemented are not provided.

   4. Add a function to preview ``JuiceIcon()``. Pass the color as ``Yellow``.

   .. code:: prettyprint

      import androidx.compose.ui.tooling.preview.Preview


      @Preview
      @Composable
      fun PreviewJuiceIcon() {
          JuiceIcon("Yellow")
      }

   |c016198f82a5d199.png|


Create juice details composables

   In the ``JuiceListAdapter.kt``, you need to add another composable function to display
   the juice details. You also need a column layout to display two ``Text`` composables for
   the name and description, and a rating indicator. To do so, complete the following
   steps:

   1. Add a composable function called ``JuiceDetails()`` that takes a ``Juice`` object and
      a ``Modifier``, and a text composable for juice name and a composable for juice
      description as shown in the following code:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Arrangement
      import androidx.compose.foundation.layout.Column
      import androidx.compose.foundation.layout.padding
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Text
      import androidx.compose.ui.text.font.FontWeight


      @Composable
      fun JuiceDetails(juice: Juice, modifier: Modifier = Modifier) {
         Column(modifier, verticalArrangement = Arrangement.Top) {
             Text(
                 text = juice.name,
                 style = MaterialTheme.typography.h5.copy(fontWeight = FontWeight.Bold),
             )
             Text(juice.description)
             RatingDisplay(rating = juice.rating, modifier = Modifier.padding(top = 8.dp))
         }
      }

   2. To resolve the unresolved reference error, create a composable function called
      ``RatingDisplay()``.

   |f8961fe60eb4fdc9.png|

   In the View system, you have a
   `RatingBar <https://developer.android.google.cn/reference/android/widget/RatingBar>`__
   to display the following rating bar. Compose doesn't have a rating bar composable so you
   need to implement this element from scratch.

   3. Define the ``RatingDisplay()`` function to display the stars as per the rating. This
      composable function displays the number of stars based on the rating.

   |Rating bar with four stars|

   .. code:: prettyprint

      import androidx.compose.ui.res.painterResource
      import androidx.compose.ui.res.pluralStringResource


      @Composable
      fun RatingDisplay(rating: Int, modifier: Modifier = Modifier) {
         val displayDescription = pluralStringResource(R.plurals.number_of_stars, count = rating)
         Row(
             // Content description is added here to support accessibility
             modifier.semantics {
                 contentDescription = displayDescription
             }
         ) {
             repeat(rating) {
                 // Star [contentDescription] is null as the image is for illustrative purpose
                 Image(
                     modifier = Modifier.size(32.dp),
                     painter = painterResource(R.drawable.star),
                     contentDescription = null
                 )
             }
         }
      }

   To create the star drawable in Compose, you need to create the star vector asset.

   4. In the **Project** pane, right click on **drawable > New > Vector Asset**.

   |7241b28c6d029385.png|

   5. In the **Asset Studio** dialog, search for a star icon. Select the filled-in star
      icon.

   |a6b2c1664d33a55e.png|

   |103a8136eaa0406d.png|

   6. Change the color value of the star to **625B71**.

   |Asset studio dialog with configure vector asset and color|

   7. Click **Next > Finish**.
   8. Notice that a drawable appears in the ``res/drawable`` folder.

   |Project pane in android studio pointed to res drawable folder|

   9. Add a preview composable to preview the *``JuiceDetails``* composable.

   .. code:: prettyprint

      @Preview
      @Composable
      fun PreviewJuiceDetails() {
          JuiceDetails(Juice(1, "Sweet Beet", "Apple, carrot, beet, and lemon", "Red", 4))
      }

   |with juice name juice description and star rating bar|


Create delete button composable

   1. In the ``JuiceListAdapter.kt``, add another composable function called
      ``DeleteButton()`` that takes a lambda callback function and a Modifier.
   2. Set the lambda to the ``onClick`` argument and pass in the ``Icon()`` as shown in the
      following code:

   .. code:: prettyprint

      import androidx.compose.ui.res.painterResource
      import androidx.compose.material3.Icon
      import androidx.compose.material3.IconButton


      @Composable
      fun DeleteButton(onDelete: () -> Unit, modifier: Modifier = Modifier) {
          IconButton(
              onClick = { onDelete() },
              modifier = modifier
          ) {
              Icon(
                  painter = painterResource(R.drawable.ic_delete),
                  contentDescription = stringResource(R.string.delete)
              )
          }
      }

   3. Add a preview function to preview the delete button.

   .. code:: prettyprint

      @Preview
      @Composable
      fun PreviewDeleteIcon() {
          DeleteButton({})
      }

   |Android studio preview of the delete icon|


5. Implement ListItem function
--------------------------------------------------------------------------------

   Now that you have all the required composables to display the list item, you can arrange
   them in a layout. Notice the ``ListItem()`` function you defined in the previous step.

   .. code:: prettyprint

      @Composable
      fun ListItem(
         input: Juice,
         onEdit: (Juice) -> Unit,
         onDelete: (Juice) -> Unit,
         modifier: Modifier = Modifier
      ) {
      }

   In the ``JuiceListAdapter.kt``, complete the following steps to implement the
   ``ListItem()`` function.

   1. Add a ``Row`` layout inside ``Mdc3Theme {}`` lambda.

   .. code:: prettyprint

      import androidx.compose.foundation.clickable
      import androidx.compose.foundation.layout.Arrangement
      import com.google.accompanist.themeadapter.material3.Mdc3Theme

      Mdc3Theme {
         Row(
             modifier = modifier,
             horizontalArrangement = Arrangement.SpaceBetween
         ) {

         }
      }

   2. Inside the ``Row`` lambda, call the three composables ``JuiceIcon``,
      ``JuiceDetails``, ``DeleteButton`` you created as child elements.

   .. code:: prettyprint

      JuiceIcon(input.color)
      JuiceDetails(input, Modifier.weight(1f))
      DeleteButton({})

   Passing the ``Modifier.``\ *``weight``*\ ``(1f)`` to the ``JuiceDetails()`` composable
   ensures the juice details take up the horizontal space remaining after measuring
   unweighted child elements.

   3. Pass in the ``onDelete(input)`` lambda and modifier with top alignment as parameters
      to the ``DeleteButton`` composable.

   .. code:: prettyprint

      DeleteButton(
         onDelete = {
             onDelete(input)
         },
         modifier = Modifier.align(Alignment.Top)
      )

   4. Write a preview function to preview the ``ListItem`` composable.

   .. code:: prettyprint

      @Preview
      @Composable
      fun PreviewListItem() {
         ListItem(Juice(1, "Sweet Beet", "Apple, carrot, beet, and lemon", "Red", 4), {})
      }

   |Android Studio list item preview with sweet beet juice details|

   5. Bind the ``ListItem`` composable to the view holder. Call ``onEdit(input)`` inside
      the *``clickable()``* lambda function to open the edit dialog when the list item is
      clicked.

   In the ``JuiceListViewHolder`` class, inside the ``bind()`` function, you need to host
   the composable. You use
   `ComposeView <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/platform/ComposeView>`__,
   which is an Android View that can host Compose UI content using its ``setContent``
   method.

   .. code:: prettyprint

      fun bind(input: Juice) {
          composeView.setContent {
              ListItem(
                  input,
                  onDelete,
                  modifier = Modifier
                      .fillMaxWidth()
                      .clickable {
                          onEdit(input)
                      }
                      .padding(vertical = 8.dp, horizontal = 16.dp),
             )
         }
      }

   6. Run the app. Add your favorite juice. Notice the shiny compose list item.

   |aadccf32ab952d0f.png|. |8aa751f4cf63bf98.png|

   Congratulations! You just created your first Compose interoperability app that uses
   Compose elements in a view-based app.


6. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker.git
      $ cd basic-android-kotlin-compose-training-juice-tracker
      $ git checkout views-with-compose

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/archive/refs/heads/views-with-compose.zip>`__

   **Note:** The solution code is in the ``views-with-compose`` branch of the repository.

   If you want to see the solution code, `view it on GitHub <https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/tree/views-with-compose>`__.


7. Learn more
--------------------------------------------------------------------------------

   Android Developer Documentation

   -  `Tools for Compose \| Jetpack Compose \| Android Developers <https://developer.android.google.cn/jetpack/compose/tooling>`__
   -  `Interoperability APIs \| Jetpack Compose \| Android Developers <https://developer.android.google.cn/jetpack/compose/interop/interop-apis>`__
   -  `Migration strategy \| Jetpack Compose \| Android Developers <https://developer.android.google.cn/jetpack/compose/interop/migration-strategy>`__

   Codelab [Intermediate]

   -  `Migrating to Jetpack Compose <https://developer.android.google.cn/codelabs/jetpack-compose-migration#0>`__


.. |36bd5542e97fee2e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/36bd5542e97fee2e.png
.. |List item with juice details| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/9aa691f45f5a880d.png
.. |97412dabc6dc49b6.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/97412dabc6dc49b6.png
.. |be6304b98a377f30.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/be6304b98a377f30.png
.. |4ec7f82371c6bc15.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/4ec7f82371c6bc15.png
.. |c016198f82a5d199.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/c016198f82a5d199.png
.. |f8961fe60eb4fdc9.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/f8961fe60eb4fdc9.png
.. |Rating bar with four stars| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/842de5707f1a9396.png
.. |7241b28c6d029385.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/7241b28c6d029385.png
.. |a6b2c1664d33a55e.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/a6b2c1664d33a55e.png
.. |103a8136eaa0406d.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/103a8136eaa0406d.png
.. |Asset studio dialog with configure vector asset and color| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/15e67a7024a18d28.png
.. |Project pane in android studio pointed to res drawable folder| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/3bfec1300d5c43a0.png
.. |with juice name juice description and star rating bar| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/19fe7df886c6d2b6.png
.. |Android studio preview of the delete icon| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/30e00883e38f39b0.png
.. |Android Studio list item preview with sweet beet juice details| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/fdb313f1157ff4e5.png
.. |aadccf32ab952d0f.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/aadccf32ab952d0f.png
.. |8aa751f4cf63bf98.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app/img/8aa751f4cf63bf98.png



ğŸš€ View Interoperability in Compose
===================================

https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-view-interop#6


1. Before you begin
--------------------------------------------------------------------------------


Introduction

   At this point in the course you are well versed in building apps with Compose and have
   some knowledge of building apps with XML, Views, View Bindings, and Fragments. After
   building apps with Views, you might have come to appreciate the conveniences of building
   apps with a declarative UI like Compose. However, there might be some cases where it
   makes sense to use Views instead of Compose. In this codelab, you learn how to use View
   Interops to add View components into a modern Compose app.

   At the time of writing this codelab, the UI components you are set to create are not yet
   available in Compose. This is the perfect opportunity to utilize View Interop!


Prerequisites:

   -  Complete the `Android Basics with Compose <https://developer.android.google.cn/courses/android-basics-compose/course>`__
      coursework through the `Build an Android App with Views <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-app-with-views>`__
      codelab.


What you'll need

   -  A computer with internet access and Android Studio
   -  A device or emulator
   -  The starter code for the Juice Tracker app


What you'll build

   In this codelab, you will need to integrate three Views into the Compose UI to complete
   the Juice Tracker app UI; a Spinner, a RatingBar, and an AdView. To build these
   components, you will use View Interoperability, or View Interop for short. With View
   Interop, you can actually add Views to your app by wrapping them in a Composable.

   |a02177f6b6277edc.png| |afc4551fde8c3113.png| |5dab7f58a3649c04.png|


Code walkthrough

   In this codelab, you work with the same JuiceTracker app from the 
   `Build an Android App with Views <https://developer.android.google.cn/codelabs/basic-android-kotlin-compose-app-with-views>`__
   and `Add Compose to a View-based app <https://developer.android.google.cn/codelabs/basic-android-kotlin-training-compose-add-compose-to-a-view-based-app>`__
   codelabs. The difference with this version is that the provided starter code is entirely
   in Compose. The app is currently missing the color and rating inputs in the entry dialog
   sheet and the ad banner at the top of the list screen.

   The ``bottomsheet`` directory contains all of the UI components related to the entry
   dialog. This package should contain the UI components for the color and rating inputs,
   when they're created.

   The ``homescreen`` contains the UI components hosted by the home screen, this includes
   the JuiceTracker list. This package should eventually contain the ad banner, when it's
   created.

   The main UI components, such as the bottom sheet and the juice list, are hosted in the
   ``JuiceTrackerApp.kt`` file.


2. Get the starter code
--------------------------------------------------------------------------------

   To get started, download the starter code:

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/archive/refs/heads/compose-starter.zip>`__

   Alternatively, you can clone the GitHub repository for the code:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker.git
      $ cd basic-android-kotlin-compose-training-juice-tracker
      $ git checkout compose-starter

   **Starter code URL:**

   https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/tree/compose-starter

   **Branch name with starter code:** ``compose-starter``

   1. In Android Studio, open the ``basic-android-kotlin-compose-training-juice-tracker``
      folder.
   2. Open the Juice Tracker app code in Android Studio.


3. Gradle configuration
--------------------------------------------------------------------------------

   Add the play services ads dependency to the app ``build.gradle.kts`` file.

   **app/build.gradle.kts**

   .. code:: prettyprint

      android {
         ...
         dependencies {
            ...
            implementation("com.google.android.gms:play-services-ads:22.2.0")
         }
      }


4. Setup
--------------------------------------------------------------------------------

   Add the following value to the Android manifest, above the ``activity`` tag, to enable
   the ad banner for testing:

   **AndroidManifest.xml**

   .. code:: prettyprint

      ...
      <meta-data
         android:name="com.google.android.gms.ads.APPLICATION_ID"
         android:value="ca-app-pub-3940256099942544~3347511713" />

      ...

   **Note:** The id value used above is only for testing. If you want to serve real ads in
   your app, see `Set up your app in your AdMob account <https://developers.google.cn/admob/android/quick-start#set_up_your_app_in_your_admob_account>`__.


5. Complete the entry dialog
--------------------------------------------------------------------------------

   In this section, you complete the entry dialog by creating the color spinner and the
   rating bar. The color spinner is the component that lets you choose a color, and the
   rating bar lets you select a rating for the juice. See the design below:

   |Color spinner with the multiple colors listed|

   |Rating bar with 4 out of 5 stars selected|


Create the color spinner

   To implement a spinner in Compose, the ``Spinner`` class must be used. ``Spinner`` is a
   View component, as opposed to a Composable, so it must be implemented using an interop.

   1. In the ``bottomsheet`` directory, create a new file called ``ColorSpinnerRow.kt``.
   2. Create a new class inside the file called ``SpinnerAdapter``.
   3. In the constructor for the ``SpinnerAdapter``, define a callback parameter called
      ``onColorChange`` that takes an ``Int`` parameter. The ``SpinnerAdapter`` handles the
      callback functions for the ``Spinner``.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      class SpinnerAdapter(val onColorChange: (Int) -> Unit){
      }

   4. Implement the ``AdapterView.OnItemSelectedListener`` interface.

   Implementing this interface lets you define the clicking behavior for the spinner. You
   set up this adapter in a Composable later on.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      class SpinnerAdapter(val onColorChange: (Int) -> Unit): AdapterView.OnItemSelectedListener {
      }

   5. Implement the ``AdapterView.OnItemSelectedListener`` member functions:
      ``onItemSelected()`` and ``onNothingSelected()``.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      class SpinnerAdapter(val onColorChange: (Int) -> Unit): AdapterView.OnItemSelectedListener {
         override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
              TODO("Not yet implemented")
          }

          override fun onNothingSelected(parent: AdapterView<*>?) {
              TODO("Not yet implemented")
          }
      }

   6. Modify the ``onItemSelected()`` function to call the ``onColorChange()`` callback
      function so that when you select a color, the app updates the selected value in the
      UI.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      class SpinnerAdapter(val onColorChange: (Int) -> Unit): AdapterView.OnItemSelectedListener {
         override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
              onColorChange(position)
          }

          override fun onNothingSelected(parent: AdapterView<*>?) {
              TODO("Not yet implemented")
          }
      }

   7. Modify the ``onNothingSelected()`` function to set the color to ``0`` so that when
      you select nothing, the default color is the first color, red.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      class SpinnerAdapter(val onColorChange: (Int) -> Unit): AdapterView.OnItemSelectedListener {
         override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
              onColorChange(position)
          }

          override fun onNothingSelected(parent: AdapterView<*>?) {
              onColorChange(0)
          }
      }

   The ``SpinnerAdapter``, which defines the spinner's behavior through callback functions,
   is already built. Now you need to build the content of the spinner and populate it with
   data.

   8. Inside of the ``ColorSpinnerRow.kt`` file, but outside of the ``SpinnerAdapter``
      class, create a new Composable called ``ColorSpinnerRow``.

   9. In the method signature of ``ColorSpinnerRow()``, add an ``Int`` parameter for the
      spinner position, a callback function that takes an ``Int`` parameter and a modifier.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun ColorSpinnerRow(
          colorSpinnerPosition: Int,
          onColorChange: (Int) -> Unit,
          modifier: Modifier = Modifier
      ) {
      }

   10. Inside the function, create an array of juice color string resources using the
       ``JuiceColor`` enum. This array serves as the content that will populate the
       spinner.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun ColorSpinnerRow(
          colorSpinnerPosition: Int,
          onColorChange: (Int) -> Unit,
          modifier: Modifier = Modifier
      ) {
         val juiceColorArray =
              JuiceColor.values().map { juiceColor -> stringResource(juiceColor.label) }

      }

   11. Add an ``InputRow()`` Composable and pass the color string resource for the input
       label and a modifier, which defines the input row where the ``Spinner`` appears.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun ColorSpinnerRow(
          colorSpinnerPosition: Int,
          onColorChange: (Int) -> Unit,
          modifier: Modifier = Modifier
      ) {
         val juiceColorArray =
              JuiceColor.values().map { juiceColor -> stringResource(juiceColor.label) }
         InputRow(inputLabel = stringResource(R.string.color), modifier = modifier) {
         }
      }

   Next you will create the ``Spinner``! Since ``Spinner`` is a View class, Compose's View
   interoperability API must be utilized to wrap it into a Composable. This is achieved
   with the ``AndroidView`` Composable.

   1. To use a ``Spinner`` in Compose, create an ``AndroidView()`` Composable in the
      ``InputRow`` lambda body. The ``AndroidView()`` Composable creates a View element or
      hierarchy in a Composable.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun ColorSpinnerRow(
          colorSpinnerPosition: Int,
          onColorChange: (Int) -> Unit,
          modifier: Modifier = Modifier
      ) {
         val juiceColorArray =
              JuiceColor.values().map { juiceColor -> stringResource(juiceColor.label) }
         InputRow(inputLabel = stringResource(R.string.color), modifier = modifier) {
            AndroidView()
         }
      }

   The ``AndroidView`` **Composable** takes three parameters:

   -  The **``factory``** **lambda**, which is a function that creates the View.
   -  The **``update``** **callback**, which is called when the View created in the
      ``factory`` is inflated.
   -  A **Composable** ``modifier``.

   |3bb9f605719b173.png|

   2. To implement the ``AndroidView``, start by passing a modifier and filling the max
      width of the screen.
   3. Pass a lambda for the ``factory`` parameter.
   4. The ``factory`` lambda takes a ``Context`` as a parameter. Create a ``Spinner`` class
      and pass the context.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun ColorSpinnerRow(
          colorSpinnerPosition: Int,
          onColorChange: (Int) -> Unit,
          modifier: Modifier = Modifier
      ) {
         ...
         InputRow(...) {
            AndroidView(
               modifier = Modifier.fillMaxWidth(),
               factory = { context ->
                  Spinner(context)
               }
            )
         }
      }

   Just like a ``RecyclerView.Adapter`` provides data to a ``RecyclerView``, an
   ``ArrayAdapter`` provides data to a ``Spinner``. The ``Spinner`` requires an adapter to
   hold the array of colors.

   1. Set the adapter using an ``ArrayAdapter``. The ``ArrayAdapter`` requires a context,
      an XML layout, and an array. Pass ``simple_spinner_dropdown_item`` for the layout;
      this layout is provided as a default with Android.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun ColorSpinnerRow(
          colorSpinnerPosition: Int,
          onColorChange: (Int) -> Unit,
          modifier: Modifier = Modifier
      ) {
         ...
         InputRow(...) {
            AndroidView(
               â€‹â€‹modifier = Modifier.fillMaxWidth(),
               factory = { context ->
                   Spinner(context).apply {
                       adapter =
                           ArrayAdapter(
                               context,
                               android.R.layout.simple_spinner_dropdown_item,
                               juiceColorArray
                           )
                   }
               }
            )
         }
      }

   The ``factory`` callback returns an instance of the View created within it. ``update``
   is a callback that takes a parameter of the same type returned by the ``factory``
   callback. This parameter is an instance of the View that is inflated by the ``factory``.
   In this case, since a ``Spinner`` was created in the factory, the instance of that
   ``Spinner`` is accessible in the ``update`` lambda body.

   2. Add an ``update`` callback that passes a ``spinner``. Use the callback provided in
      ``update`` to call the ``setSelection()`` method.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun ColorSpinnerRow(
          colorSpinnerPosition: Int,
          onColorChange: (Int) -> Unit,
          modifier: Modifier = Modifier
      ) {
         ...
         InputRow(...) {
            //...
               },
               update = { spinner ->
                   spinner.setSelection(colorSpinnerPosition)
                   spinner.onItemSelectedListener = SpinnerAdapter(onColorChange)
               }
            )
         }
      }

   3. Use the ``SpinnerAdapter`` you created earlier to set an
      ``onItemSelectedListener()`` callback in the ``update``.

   **bottomsheet/ColorSpinnerRow.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun ColorSpinnerRow(
          colorSpinnerPosition: Int,
          onColorChange: (Int) -> Unit,
          modifier: Modifier = Modifier
      ) {
         ...
         InputRow(...) {
            AndroidView(
               // ...
               },
               update = { spinner ->
                   spinner.setSelection(colorSpinnerPosition)
                   spinner.onItemSelectedListener = SpinnerAdapter(onColorChange)
               }
            )
         }
      }

   The code for the color spinner component is now complete.

   4. Add the following utility function to get the enum index of ``JuiceColor``. You will
      use this in the next step.

   .. code:: prettyprint

      private fun findColorIndex(color: String): Int {
         val juiceColor = JuiceColor.valueOf(color)
         return JuiceColor.values().indexOf(juiceColor)
      }

   5. Implement the ``ColorSpinnerRow`` in the ``SheetForm`` Composable in the
      ``EntryBottomSheet.kt`` file. Place the color spinner after the "Description" text,
      and above the buttons.

   **bottomsheet/EntryBottomSheet.kt**

   .. code:: prettyprint

      ...
      @Composable
      fun SheetForm(
         juice: Juice,
         onUpdateJuice: (Juice) -> Unit,
         onCancel: () -> Unit,
         onSubmit: () -> Unit,
         modifier: Modifier = Modifier,
      ) {
         ...
         TextInputRow(
                  inputLabel = stringResource(R.string.juice_description),
                  fieldValue = juice.description,
                  onValueChange = { description -> onUpdateJuice(juice.copy(description = description)) },
                  modifier = Modifier.fillMaxWidth()
              )
              ColorSpinnerRow(
                  colorSpinnerPosition = findColorIndex(juice.color),
                  onColorChange = { color ->
                      onUpdateJuice(juice.copy(color = JuiceColor.values()[color].name))
                  }
              )
         ButtonRow(
                  modifier = Modifier
                      .align(Alignment.End)
                      .padding(bottom = dimensionResource(R.dimen.padding_medium)),
                  onCancel = onCancel,
                  onSubmit = onSubmit,
                  submitButtonEnabled = juice.name.isNotEmpty()
              )
          }
      }


Create the rating input

   1. Create a new file in the ``bottomsheet`` directory called ``RatingInputRow.kt``.
   2. In the ``RatingInputRow.kt`` file, create a new Composable called
      ``RatingInputRow()``.
   3. In the method signature, pass an ``Int`` for the rating, a callback with an ``Int``
      parameter to handle a selection change, and a modifier.

   **bottomsheet/RatingInputRow.kt**

   .. code:: prettyprint

      @Composable
      fun RatingInputRow(rating:Int, onRatingChange: (Int) -> Unit, modifier: Modifier = Modifier){
      }

   4. Like the ``ColorSpinnerRow``, add an ``InputRow`` to the Composable that contains an
      ``AndroidView``, as shown in the following example code.

   **bottomsheet/RatingInputRow.kt**

   .. code:: prettyprint

      @Composable
      fun RatingInputRow(rating:Int, onRatingChange: (Int) -> Unit, modifier: Modifier = Modifier){
          InputRow(inputLabel = stringResource(R.string.rating), modifier = modifier) {
              AndroidView(
                  factory = {},
                  update = {}
              )
          }
      }

   5. In the ``factory`` lambda body, create an instance of the ``RatingBar`` class, which
      provides the type of rating bar needed for this design. Set the ``stepSize`` to
      ``1f`` to enforce the rating to only be a whole number.

   **bottomsheet/RatingInputRow.kt**

   .. code:: prettyprint

      @Composable
      fun RatingInputRow(rating:Int, onRatingChange: (Int) -> Unit, modifier: Modifier = Modifier){
          InputRow(inputLabel = stringResource(R.string.rating), modifier = modifier) {
              AndroidView(
                  factory = { context ->
                      RatingBar(context).apply {
                          stepSize = 1f
                      }
                  },
                  update = {}
              )
          }
      }

   When the View is inflated, the rating is set. Recall that the ``factory`` returns the
   instance of the ``RatingBar`` to the update callback.

   6. Use the rating passed to the Composable to set the rating for the ``RatingBar``
      instance in the ``update`` lambda body.

   7. When a new rating is set, use the ``RatingBar`` callback to call the
      ``onRatingChange()`` callback function to update the rating in the UI.

   **bottomsheet/RatingInputRow.kt**

   .. code:: prettyprint

      @Composable
      fun RatingInputRow(rating:Int, onRatingChange: (Int) -> Unit, modifier: Modifier = Modifier){
          InputRow(inputLabel = stringResource(R.string.rating), modifier = modifier) {
              AndroidView(
                  factory = { context ->
                      RatingBar(context).apply {
                          stepSize = 1f
                      }
                  },
                  update = { ratingBar ->
                      ratingBar.rating = rating.toFloat()
                      ratingBar.setOnRatingBarChangeListener { _, _, _ ->
                          onRatingChange(ratingBar.rating.toInt())
                      }
                  }
              )
          }
      }

   The rating input composable is now complete.

   8. Use the ``RatingInputRow()`` composable in the ``EntryBottomSheet``. Place it after
      the color spinner and above the buttons.

   **bottomsheet/EntryBottomSheet.kt**

   .. code:: prettyprint

      @Composable
      fun SheetForm(
          juice: Juice,
          onUpdateJuice: (Juice) -> Unit,
          onCancel: () -> Unit,
          onSubmit: () -> Unit,
          modifier: Modifier = Modifier,
      ) {
          Column(
              modifier = modifier,
              verticalArrangement = Arrangement.spacedBy(4.dp)
          ) {
              ...
              ColorSpinnerRow(
                  colorSpinnerPosition = findColorIndex(juice.color),
                  onColorChange = { color ->
                      onUpdateJuice(juice.copy(color = JuiceColor.values()[color].name))
                  }
              )
              RatingInputRow(
                  rating = juice.rating,
                  onRatingChange = { rating -> onUpdateJuice(juice.copy(rating = rating)) }
              )
              ButtonRow(
                  modifier = Modifier.align(Alignment.CenterHorizontally),
                  onCancel = onCancel,
                  onSubmit = onSubmit,
                  submitButtonEnabled = juice.name.isNotEmpty()
              )
          }
      }


Create the ad banner

   1. In the ``homescreen`` package, create a new file called ``AdBanner.kt``.
   2. In the ``AdBanner.kt`` file, create a new Composable called ``AdBanner()``.

   Unlike the previous Composables you made, the ``AdBanner`` does not require an input.
   Therefore, you do not need to wrap it in an ``InputRow`` Composable. However, it does
   require an ``AndroidView``.

   3. Attempt to build the banner on your own using the ``AdView`` class. Make sure to set
      the ad size to ``AdSize.BANNER`` and the ad unit id to
      ``"ca-app-pub-3940256099942544/6300978111"``.
   4. When the ``AdView`` is inflated, load an ad using the ``AdRequest Builder``.

   **homescreen/AdBanner.kt**

   .. code:: prettyprint

      @Composable
      fun AdBanner(modifier: Modifier = Modifier) {
          AndroidView(
              modifier = modifier,
              factory = { context ->
                  AdView(context).apply {
                      setAdSize(AdSize.BANNER)
                      // Use test ad unit ID
                      adUnitId = "ca-app-pub-3940256099942544/6300978111"
                  }
              },
              update = { adView ->
                  adView.loadAd(AdRequest.Builder().build())
              }
          )
      }

   5. Place the ``AdBanner`` before the ``JuiceTrackerList`` in the ``JuiceTrackerApp``.
      The ``JuiceTrackerList`` is declared on line 83.

   **ui/JuiceTrackerApp.kt**

   .. code:: prettyprint

      ...
      AdBanner(
         Modifier
             .fillMaxWidth()
             .padding(
                 top = dimensionResource(R.dimen.padding_medium),
                 bottom = dimensionResource(R.dimen.padding_small)
             )
      )

      JuiceTrackerList(
          juices = trackerState,
          onDelete = { juice -> juiceTrackerViewModel.deleteJuice(juice) },
          onUpdate = { juice ->
              juiceTrackerViewModel.updateCurrentJuice(juice)
              scope.launch {
                  bottomSheetScaffoldState.bottomSheetState.expand()
              }
           },
      )


6. Get the solution code
--------------------------------------------------------------------------------

   To download the code for the finished codelab, you can use these git commands:

   ::

      $ git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker.git
      $ cd basic-android-kotlin-compose-training-juice-tracker
      $ git checkout compose-with-views

   Alternatively, you can download the repository as a zip file, unzip it, and open it in
   Android Studio.

   `Download zip <https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/archive/refs/heads/compose-with-views.zip>`__

   **Note:** The solution code is in the ``compose-with-views`` branch of the downloaded
   repository.

   If you want to see the solution code, 
   `view it on GitHub <https://github.com/google-developer-training/basic-android-kotlin-compose-training-juice-tracker/tree/compose-with-views>`__.


7. Learn more
--------------------------------------------------------------------------------

   -  `Interoperability APIs <https://developer.android.google.cn/jetpack/compose/interop/interop-apis>`__
   -  `Layouts <https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-1-pathway-3>`__


8. It's a wrap!
--------------------------------------------------------------------------------

   This course may end here, but this is just the beginning of your journey into Android
   app development!

   In this course, you have learned to build apps using Jetpack Compose, the modern UI
   toolkit for building native Android apps. Throughout this course, you built apps with
   lists, single or multiple screens, and navigated between them. You learned to create
   interactive apps, made your app respond to user input and updated the UI. You applied
   Material Design and used colors, shapes, and typography to theme your app. You also used
   Jetpack and other third-party libraries to schedule tasks, retrieve data from remote
   servers, persist data locally and more.

   By completing this course, you not only have a good understanding of how to create
   beautiful and responsive apps using Jetpack Compose, but are also equipped with the
   knowledge and skills you need to create efficient, maintainable, and visually appealing
   Android apps. This foundation will help you to continue learning and building your
   skills in Modern Android development and Compose.

   We would like to thank you all for participating and completing this course! We
   encourage you all to continue learning and expanding your skills through additional
   resources such as the `Android Developer docs <https://developer.android.google.cn/>`__,
   `Jetpack Compose for Android Developers course <https://developer.android.google.cn/courses/jetpack-compose/course>`__,
   `Modern Android App Architecture <https://developer.android.google.cn/courses/pathways/android-architecture>`__,
   `Android Developers blog <https://medium.com/androiddevelopers>`__, other
   `codelabs <https://developer.android.google.cn/codelabs/>`__, and 
   `sample projects <https://github.com/android/compose-samples>`__.

   Finally, don't forget to share what you built on social media and use the hashtag
   #AndroidBasics so that we and the rest of the Android developer community can follow
   your learning journey too!

   Happy composing!!

.. |a02177f6b6277edc.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-view-interop/img/a02177f6b6277edc.png
.. |afc4551fde8c3113.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-view-interop/img/afc4551fde8c3113.png
.. |5dab7f58a3649c04.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-view-interop/img/5dab7f58a3649c04.png
.. |Color spinner with the multiple colors listed| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-view-interop/img/a30be98a789642d3.png
.. |Rating bar with 4 out of 5 stars selected| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-view-interop/img/356ab2ae171f53bb.png
.. |3bb9f605719b173.png| image:: https://developer.android.google.cn/static/codelabs/basic-android-kotlin-compose-view-interop/img/3bb9f605719b173.png


ğŸŸ© TOC - Kotlin bootcamp for programmers
=========================================

   pandoc --column=100 -trst -rhtml https://developer.android.google.cn/courses/kotlin-bootcamp/overview

   In the Kotlin Bootcamp for Programmers course, youâ€™ll learn the basics of 
   Kotlin as you create programs in IntelliJ IDEA. This course is designed 
   for programmers who know an object-oriented language such as Java or C++.

   â­ Training level: Intermediate

   é¢å‘ç¼–ç¨‹äººå‘˜çš„ Kotlin è®­ç»ƒè¥

   åœ¨â€œé¢å‘ç¼–ç¨‹äººå‘˜çš„ Kotlin è®­ç»ƒè¥â€è¯¾ç¨‹ä¸­ï¼Œæ‚¨å°†å­¦ä¹  Kotlin çš„åŸºç¡€çŸ¥è¯†ï¼Œå¹¶ä½¿ç”¨ IntelliJ IDEA åˆ›å»ºå„ç§å°ç¨‹åºã€‚

   è¿™äº›è¯¾ç¨‹èµ„æ–™åŒ…æ‹¬è¯¾ç¨‹ Codelab ä»¥åŠå»ºè®®çš„å®¶åº­ä½œä¸šã€‚

   å¦‚æœæ‚¨æŒ‰é¡ºåºå­¦ä¹ æœ¬è¯¾ç¨‹ï¼Œæ‚¨å°†ä¼šå……åˆ†å‘æ˜è¯¾ç¨‹çš„ä»·å€¼ï¼Œä½†å¹¶ä¸å¼ºåˆ¶è¦æ±‚è¿™æ ·åšã€‚æ ¹æ®æ‚¨çš„çŸ¥è¯†æ°´å¹³ï¼Œå¯¹äºæŸäº›ç‰ˆå—æ‚¨ä¹Ÿè®¸åªéœ€è¦ç•¥è¯»å³å¯ã€‚

   æœ¬è¯¾ç¨‹ä¸“ä¸ºäº†è§£é¢å‘å¯¹è±¡çš„è¯­è¨€ï¼ˆä¾‹å¦‚ Java æˆ– C++ï¼‰çš„ç¼–ç¨‹äººå‘˜è®¾è®¡ã€‚å¦‚æœæ‚¨ç†Ÿæ‚‰ C#ï¼Œå°±ä¼šç†Ÿæ‚‰ Kotlin çš„ä¸€äº›åŠŸèƒ½ã€‚

   * `1   å…¥é—¨ (get started)  <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-introduction/>`__

      åœ¨ç¬¬ 1 è¯¾ä¸­ï¼Œæ‚¨å°†äº†è§£å¦‚ä½•ä½¿ç”¨ Kotlin REPLï¼ˆè¯»å–-æ±‚å€¼-è¾“å‡ºå¾ªç¯ï¼‰äº¤äº’å¼ shellï¼Œå¹¶ç»ƒä¹ ä½¿ç”¨ Kotlin
      ä»£ç çš„åŸºæœ¬è¯­æ³•ã€‚


   * `2   åŸºç¡€çŸ¥è¯† (kotlin basics)  <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-basics/>`__

      åœ¨ç¬¬ 2 è¯¾ä¸­ï¼Œæ‚¨å°†äº†è§£å¦‚ä½•ä½¿ç”¨ Kotlin æ•°æ®ç±»å‹ã€è¿ç®—ç¬¦å’Œå˜é‡ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨å¸ƒå°”å€¼å’Œæ¡ä»¶ã€‚æ‚¨å°†æ¢ç´¢å¯ä¸º null
      å˜é‡å’Œä¸å¯ä¸º null å˜é‡ä¹‹é—´çš„åŒºåˆ«ï¼Œå¹¶ç»ƒä¹ åœ¨ Kotlin ä¸­ä½¿ç”¨æ•°ç»„ã€åˆ—è¡¨å’Œå¾ªç¯ã€‚


   * `3   å‡½æ•° (functions)  <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-functions/>`__

      åœ¨ç¬¬ 3 è¯¾ä¸­ï¼Œæ‚¨å°†äº†è§£å¦‚ä½•åœ¨ IntelliJ IDEA ä¸­ä½¿ç”¨ ``main()``
      å‡½æ•°å’Œå‚æ•°åˆ›å»ºç¨‹åºã€‚æ‚¨å¯ä»¥é€šè¿‡åˆ›å»ºå°å‹ç¨‹åºæ¥äº†è§£é»˜è®¤å€¼ã€compact å‡½æ•°ã€åˆ—è¡¨è¿‡æ»¤æ¡ä»¶ã€åŸºæœ¬ lambda å’Œé«˜é˜¶å‡½æ•°ã€‚


   * `4   ç±»å’Œå¯¹è±¡ (classes and objects)  <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-classes/>`__

      åœ¨ç¬¬ 4 è¯¾ä¸­ï¼Œæ‚¨å°†äº†è§£ Kotlin ä¸­çš„ç±»ã€å¯¹è±¡å’Œç»§æ‰¿ã€‚æ‚¨å¯ä»¥é€šè¿‡åˆ›å»ºå°å‹ç¨‹åºæ¥äº†è§£æŠ½è±¡ç±»ã€æ¥å£å’Œæ¥å£å§”æ‰˜ã€‚


   * `5.1 æ‰©å±• (extensions)  <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-extensions/>`__

      åœ¨ç¬¬ 5.1 è¯¾ä¸­ï¼Œæ‚¨å°†äº†è§£ Kotlin
      ä¸­çš„é›†åˆã€å¸¸é‡å’Œæ‰©å±•å‡½æ•°ã€‚æ‚¨å¯ä»¥é€šè¿‡åˆ›å»ºå°å‹ç¨‹åºæ¥äº†è§£ç”¨äºå­˜å‚¨æ•°æ®çš„å¯¹ã€ä¸‰å…ƒç»„ã€åˆ—è¡¨å’Œå“ˆå¸Œæ˜ å°„ï¼Œå¹¶å®ç°æ‰©å±•å‡½æ•°æ¥å‘ç°æœ‰ç±»æ·»åŠ åŠŸèƒ½ã€‚


   * `5.2 æ³›å‹ (generics)  <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-generics/>`__

      åœ¨ç¬¬ 5.2 è¯¾ä¸­ï¼Œæ‚¨å°†äº†è§£ Kotlin
      ä¸­çš„æ³›å‹ç±»ã€æ–¹æ³•å’Œå‡½æ•°ã€‚æ‚¨å°†åˆ›å»ºç±»å‹å±‚æ¬¡ç»“æ„ï¼Œé€šè¿‡å°†ç±»å˜ä¸ºæ³›å‹ä½¿å…¶æ›´åŠ çµæ´»ï¼Œå¹¶ä½¿ç”¨æ³›å‹æ–¹æ³•å’Œå‡½æ•°æ‰©å±•å…¶åŠŸèƒ½ã€‚


   * `6   åŠŸèƒ½æ“çºµ (functional manipulation)  <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-sams/`__ 

      åœ¨ç¬¬ 6 è¯¾ä¸­ï¼Œæ‚¨å°†äº†è§£æ³¨è§£ã€å¸¦æ ‡ç­¾çš„ break å’Œå•ä¸€æŠ½è±¡æ–¹æ³• (SAM)ã€‚æ‚¨è¿˜å¯ä»¥æŸ¥çœ‹ lambda
      å’Œé«˜é˜¶å‡½æ•°ã€‚ç„¶ååˆ›å»ºå¹¶ä½¿ç”¨ lambda å’Œé«˜é˜¶å‡½æ•°ï¼Œå¹¶äº†è§£ Kotlin æ ‡å‡†åº“ä¸­çš„é«˜é˜¶å‡½æ•°ã€‚

   æœ¬é¡µé¢ä¸Šçš„å†…å®¹å’Œä»£ç ç¤ºä¾‹å— `å†…å®¹è®¸å¯ <https://developer.android.google.cn/license>`__
   éƒ¨åˆ†æ‰€è¿°è®¸å¯çš„é™åˆ¶ã€‚Java å’Œ OpenJDK æ˜¯ Oracle å’Œ/æˆ–å…¶å…³è”å…¬å¸çš„æ³¨å†Œå•†æ ‡ã€‚

   æœ€åæ›´æ–°æ—¶é—´ (UTC)ï¼š2021-05-04ã€‚




â­ Kotlin Bootcamp 1: Get started
==================================

   pandoc --column=100 -trst -rhtml https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-introduction/


1. Welcome
--------------------------------------------------------------------------------

   This codelab is part of the 
   `Kotlin Bootcamp for Programmers course <https://developer.android.google.cn/courses/kotlin-bootcamp/overview>`__. 
   You'll get the most value out of this course if you work through the codelabs in sequence.
   Depending on your knowledge, you may be able to skim some sections. This course is
   geared towards programmers who know an object-oriented language, and want to learn
   `Kotlin <https://kotlinlang.org/>`__.


Introduction

   The Kotlin Bootcamp for Programmers course teaches you the Kotlin programming language.
   In this codelab, you learn about advantages of programming in the
   `Kotlin <https://kotlinlang.org/>`__ programming language, and you install the IDE to
   get ready for the first lesson.

   This course is geared towards programmers who know an object-oriented language and want
   to learn more about Kotlin. If you are familiar with C#, some of the features of Kotlin
   will be familiar. If you are familiar primarily with the Java programming language, you
   may be amazed at how much more concise and readable your code can be.

   Since 2017, Google has officially supported Kotlin for developing Android apps. Read the
   announcement on the `Android Developers Blog <https://android-developers.googleblog.com/2017/05/android-announces-support-for-kotlin.html>`__.
   This course content is a prerequisite of `Android Kotlin Fundamentals <https://codelabs.developers.google.cn/android-kotlin-fundamentals/>`__.


What you should already know

   You should be familiar with:

   -  The basics of a modern, object-oriented, statically typed programming language such
      as Java or C#
   -  How to program with classes, methods, and exception handling in at least one language
   -  Using an IDE such as IntelliJ IDEA, Android Studio, Eclipse, or Visual Studio


What you'll learn

   -  How to work with the Kotlin REPL (Read-Eval-Print Loop) interactive shell
   -  The basic syntax of Kotlin code


What you'll do

   -  Install the Java Development Kit (JDK) and the IntelliJ IDEA, and become familiar
      with some Kotlin features.


2. Benefits of Kotlin
--------------------------------------------------------------------------------

   Kotlin is a new, modern programming language created by programmers, for programmers.
   It's focused on clarity, conciseness, and code safety.


Robust code

   The creators of Kotlin made various design decisions about the language to help
   programmers create robust code. For example, null-pointer exceptions in software have
   caused financial losses and spectacular computer crashes, and have resulted in countless
   hours of debugging. So Kotlin distinguishes between nullable and non-nullable data
   types, which helps catch more errors at compile time. Kotlin is strongly typed, and it
   does a lot to infer the types from your code. It has lambdas, coroutines, and
   properties, which allow you to write less code with fewer bugs.


Mature platform

   Kotlin has been around since 2011, and was released as open source in 2012. It reached
   version 1.0 in 2016, and since 2017 Kotlin has been an officially supported language for
   building Android apps. It's included with the IntelliJ IDEA as well as Android Studio
   3.0 and later.


Concise, readable code

   Code written in Kotlin can be very concise, and the language is designed to eliminate
   boilerplate code such as getters and setters. For example, consider the following Java
   code:

   .. code:: prettyprint

      public class Aquarium {

         private int mTemperature;

         public Aquarium() { }

         public int getTemperature() {
             return mTemperature;
         }

         public void setTemperature(int mTemperature) {
             this.mTemperature = mTemperature;
         }

         @Override
         public String toString() {
             return "Aquarium{" +
                     "mTemperature=" + mTemperature +
                     '}';
         }
      }

   It can be written concisely like this in Kotlin:

   .. code:: prettyprint

      data class Aquarium (var temperature: Int = 0)

   Sometimes the goals of conciseness and readability are at odds with each other. Kotlin
   is designed to use "just enough boilerplate code" to ensure readability while keeping
   things concise.


Interoperable with Java

   Kotlin code compiles so that you can use Java and Kotlin code side-by-side, and continue
   to use your favorite Java libraries. You can add Kotlin code to an existing Java
   program, or if you want to migrate your program completely, IntelliJ IDEA and Android
   Studio both include tools to migrate existing Java code to Kotlin code.


3. Task: Install the Java Development Kit (JDK)
--------------------------------------------------------------------------------

   If you don't have the latest JDK already installed on your computer, follow the steps
   below. You need to have the JDK installed to run Kotlin programs.

   To see which version of the JDK you have installed, if any, type ``javac -version`` in a
   terminal window.

   ::

      javac -version

   You can see what the latest version of the JDK is on the 
   `Java SE Downloads <https://www.oracle.com/technetwork/java/javase/downloads>`__ 
   page. If you have the latest version, skip ahead to Install IntelliJ IDEA.

   **Note:** We recommend that you install only the latest JDK and JRE.

   **JRE or JDK?**

   The JRE (Java Runtime Environment) is needed for running Java and Kotlin programs. The
   JDK (Java Development Kit), on the other hand, includes the JRE, plus the development
   tools that you need for writing and running Java programs. You need the JDK for writing
   Kotlin programs.


Step 1: Uninstall any older versions of the JDK/JRE

   Before you install the latest and greatest, remove all older versions of the JDK:

   -  For Windows, select **Control Panel** > **Add/Remove Programs**.
   -  For Mac instructions, see 
      `Uninstalling the JDK <https://docs.oracle.com/javase/8/docs/technotes/guides/install/mac_jdk.html#A1096903>`__.

   For additional information on uninstalling older versions of the JRE, see 
   `How do I uninstall Java on my Mac? <https://www.java.com/en/download/help/mac_uninstall_java.xml>`__ or 
   `How do I uninstall Java on my Windows computer? <https://www.java.com/en/download/help/uninstall_java.xml>`__


Step 2: Download the JDK

   You can download the JDK for free here:
   http://www.oracle.com/technetwork/java/javase/downloads/index.html

   1. Click on **JDK Download**.
   2. Under **Downloads**, choose the link for the JDK for your operating system.
   3. Accept the license agreement.
   4. Click on the **Download** button.


Step 3: Install the JDK (for Mac)

   From either the **Downloads** window of the browser, or from the file browser,
   double-click the ``.dmg`` file to launch the install file.

   1. A **Finder** window appears with an icon of an open box and the name of the ``.pkg`` file.
   2. Double-click the package icon to launch the installation app, and follow the prompts as they appear.
   3. You might need to enter the administrator password to continue.
   4. After the installation is complete, feel free to delete the ``.dmg`` file to save space.


Step 3: Install the JDK and JRE (for Windows)

   1. Run the downloaded installer (for example, ``jdk-14.0.1_windows-x64_bin.exe``), which
      installs both the JDK and the JRE. By default, the JDK is installed in the
      ``C:\Program Files\Java\jdk-14.0.1`` directory, but it depends on the latest version.
   2. Accept the defaults, and follow the on-screen instructions to install the JDK.


Step 4: Add the JDK installation directory to PATH (Windows only)

   Windows searches the current directory and the directories listed in the ``PATH``
   environment variable (system variable) for executable programs.

   1. In **Settings** for Windows, search for ``edit environment`` in **Find a setting**.
   2. Select **Edit environment variables for your account** in the list of matches.
   3. In the **Environment Variables** dialog in the **User variables** section, select
      **Path** and click the **Edit...** button.
   4. Add the path to the JDK's bin directory, for example,
      ``C:\Program Files\Java\jdk-14.0.1\bin``, after any existing items.

   **Note:** This was tested for JDK 14 installed on Windows 10. Other versions of the JDK
   may use different directories, and the steps may be different for other versions of
   Windows.


Step 5: Verify the JDK installation

   To verify that the JDK was installed correctly, type the following commands in a
   terminal window:

   ::

      java -version
      javac -version

   **Windows users:** If you receive an error from either command, confirm you've added the
   correct path for the JRE.


4. Task: Install IntelliJ IDEA
--------------------------------------------------------------------------------


Step 1: Download and install IntelliJ IDEA

   `Download IntelliJ IDEA <https://www.jetbrains.com/idea/download/index.html>`__ for your
   operating system.

   **Windows:**

   1. Run the ``ideaIC.exe`` file that you downloaded.
   2. Follow the instructions in the installation wizard.

   **Mac:**

   1. To mount the macOS disk image, double-click the ``ideaIC.dmg`` file that you
      downloaded.
   2. Copy **IntelliJ IDEA** to the **Applications** folder.

   **Linux:**

   1. See ``Install-Linux-tar.txt`` in the downloaded ``.tar.gz`` file.

   For more information on how to install and set up IntelliJ IDEA, check out 
   `Install IntelliJ IDEA <https://www.jetbrains.com/help/idea/install-and-set-up-product.html>`__.


Step 2: Verify your IntelliJ IDEA installation

   1. Start IntelliJ IDEA.
   2. Install any updates and additional content you are prompted for.
   3. Select **Configure > Check for Updates** until there are no more updates available.


5. Task: Create Hello Kotlin
--------------------------------------------------------------------------------

   Create a Kotlin project so IntelliJ IDEA knows you're working in Kotlin.

      1. In the **Welcome to IntelliJ IDEA** window, click **Create New Project.**
      2. In the **New Project** pane, select **Kotlin** in the left-hand navigation.
      3. Select **Kotlin/JVM** (**JVM | IDEA** in newer versions) in the right panel and
         click **Next**.

         .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-introduction/img/dff2db7eb362cd3c.png

      4. Name your project ``Hello Kotlin``.
      5. Click **Finish.**

   Now you can access the
   `REPL <https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop>`__
   (Read-Eval-Print Loop), Kotlin's interactive shell. Commands that you type into the REPL
   are interpreted as soon as you press ``Control+Enter`` (``Command+Enter`` on a Mac).

      1. Select **Tools** > **Kotlin** > **Kotlin REPL** to open the REPL.

         The first time you run IntelliJ IDEA after installing, it may take a few moments before
         the **Kotlin** menu appears under **Tools**.

      2. Type or paste the code below into the REPL.

         .. code:: prettyprint

            fun printHello() {
               println("Hello World")
            }

            printHello()

      3. Press ``Control+Enter`` (``Command+Enter`` on a Mac). You should see ``Hello World``,
         as shown below. 

         .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-introduction/img/6ee2cf6716c7e437.png

      4. Take a quick look at this Kotlin code. The ``fun`` keyword designates a function,
         followed by the name. As with other programming languages, the parentheses are for
         function arguments, if any, and the curly braces frame the code for the function.
         There is no return type because the function doesn't return anything. Also note that
         there are no semicolons at the ends of lines.

   **Note:** If you're used to putting semicolons at the end of lines, that's OKâ€”Kotlin
   doesn't mind.

   Congratulations! You've written your first Kotlin program.


6. Summary
--------------------------------------------------------------------------------

   -  Kotlin is similar to other object-oriented programming languages.
   -  Install the latest JDK for your operating system to use Kotlin.
   -  Install the IntelliJ IDEA to work with Kotlin.
   -  In IntelliJ IDEA, start the Kotlin REPL (**Tools > Kotlin > Kotlin REPL**) to
      practice in an interactive shell.
   -  Enter code followed by ``Control+Enter`` (``Command+Enter`` on a Mac) to run it.
   -  Here is "Hello World" in Kotlin:

      .. code:: prettyprint

         fun printHello() {
            println ("Hello World")
         }

         printHello()


7. Learn more
--------------------------------------------------------------------------------


Kotlin documentation

   If you want more information on any topic in this course, or if you get stuck,
   `https://kotlinlang.org <https://kotlinlang.org/>`__ is your best starting point.

   -  `Kotlin coding conventions <https://kotlinlang.org/docs/reference/coding-conventions.html>`__
   -  `Kotlin idioms <https://kotlinlang.org/docs/reference/idioms.html>`__


Kotlin tutorials

   The https://play.kotlinlang.org website includes rich tutorials called Kotlin Koans, a
   `web-based interpreter <https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt>`__,
   and a complete set of reference documentation with examples.


Udacity course

   To view the Udacity course on this topic, see 
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__.


IntelliJ IDEA

   `Documentation for the IntelliJ IDEA <https://www.jetbrains.com/help/idea/>`__ can be
   found on the JetBrains website.


8. Homework
--------------------------------------------------------------------------------

   This section lists possible homework assignments for students who are working through
   this codelab as part of a course led by an instructor. It's up to the instructor to do
   the following:

   -  Assign homework if required.
   -  Communicate to students how to submit homework assignments.
   -  Grade the homework assignments.

   Instructors can use these suggestions as little or as much as they want, and should feel
   free to assign any other homework they feel is appropriate.

   If you're working through this codelab on your own, feel free to use these homework
   assignments to test your knowledge.


**Answer these questions**


**Question 1**

   Which of the following is NOT a benefit of using the Kotlin language?

   *  â–¢ Kotlin distinguishes between nullable and non-nullable data types.
   *  â–¢ Kotlin is a supported language for building Android apps.
   *  â–¢ Kotlin is designed so you can write less code with fewer bugs.
   *  â–¢ Your code compiles faster in Kotlin.


**Question 2**

   How do you start the Kotlin REPL?

   *  â–¢ Type ``repl`` on the command line.
   *  â–¢ Create a Kotlin project in IntelliJ IDEA, then select **Run > Kotlin REPL**.
   *  â–¢ Open IntelliJ IDEA, then select **File > Kotlin REPL**.
   *  â–¢ Create a Kotlin project in IntelliJ IDEA, then select **Tools > Kotlin > Kotlin REPL**.


**Question 3**

   Which of the following is NOT true about Kotlin and Java code?

   *  â–¢ Kotlin code and Java code can run side-by-side.
   *  â–¢ You can add Kotlin code to an existing Java program.
   *  â–¢ You can migrate existing Java code to Kotlin.
   *  â–¢ Kotlin code will run faster than Java code.


9. Next codelab
--------------------------------------------------------------------------------

   Proceed to the next lesson: 
   `2. Kotlin Basics <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-basics/>`__

   For an overview of the course, including links to other codelabs, see 
   `"Kotlin Bootcamp for Programmers: Welcome to the course." <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-welcome/>`__


â­ Kotlin Bootcamp 2: Kotlin basics
====================================

   pandoc --column=100 -trst -rhtml https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-basics/


1. Welcome
--------------------------------------------------------------------------------

   This codelab is part of the 
   `Kotlin Bootcamp for Programmers course <https://developer.android.google.cn/courses/kotlin-bootcamp/overview>`__. 
   You'll get the most value out of this course if you work through the codelabs in sequence.
   Depending on your knowledge, you may be able to skim some sections. This course is
   geared towards programmers who know an object-oriented language, and want to learn
   `Kotlin <https://kotlinlang.org/>`__.


Introduction

   In this codelab, you learn the basics of the `Kotlin <https://kotlinlang.org/>`__
   programming language: data types, operators, variables, control structures, and nullable
   versus non-nullable variables. This course is geared toward programmers who know an
   object-oriented language, and want to learn Kotlin.

   Rather than build a single sample app, the lessons in this course are designed to build
   your knowledge, but be semi-independent of each other so you can skim sections you're
   familiar with. To tie them together, many of the examples use an aquarium theme. And if
   you want to see the full aquarium story, check out the 
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__ Udacity course.


What you should already know

   -  How to create a project in IntelliJ IDEA
   -  How to open and execute code in Kotlin's REPL (Read-Eval-Print Loop) in IntelliJ IDEA
      (**Tools > Kotlin > Kotlin REPL**)


What you'll learn

   -  How to use Kotlin data types, operators, and variables
   -  How to work with booleans and conditions
   -  The difference between nullable and non-nullable variables
   -  How arrays, lists, and loops work in Kotlin


What you'll do

   -  Work with the Kotlin REPL to learn the basics of Kotlin

2. Task: Learn about operators and types
--------------------------------------------------------------------------------

   In this task, you learn about operators and types in the Kotlin programming language.


Step 1: Explore numeric operators

   1. Open IntelliJ IDEA, if it's not already open.
   2. To open the Kotlin REPL, select **Tools** > **Kotlin** > **Kotlin REPL**.

      .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-basics/img/2b1c3edac8da7c7.png

      As with other languages, Kotlin uses ``+``, ``-``, ``*`` and ``/`` for plus, minus,
      times and division. Kotlin also supports different number types, such as ``Int``,
      ``Long``, ``Double``, and ``Float``.

   3. Enter the following expressions in the REPL. To see the result, press
      ``Control+Enter`` (``Command+Enter`` on a Mac) after each one.

      **Note:** In this codelab, **â‡’** indicates output from your code. In the latest version
      of the REPL, the output includes the result number and the type of the result.

      ::

         1+1
         â‡’ res8: kotlin.Int = 2

         53-3
         â‡’ res9: kotlin.Int = 50

         50/10
         â‡’ res10: kotlin.Int = 5

         1.0/2.0
         â‡’ res11: kotlin.Double = 0.5

         2.0*3.5
         â‡’ res12: kotlin.Double = 7.0

      Note that results of operations keep the types of the operands, so 1/2 = 0, but 1.0/2.0
      = 0.5.

   4. Try some expressions with different combinations of integer and decimal numbers.

      ::

         6*50
         â‡’ res13: kotlin.Int = 300

         6.0*50.0
         â‡’ res14: kotlin.Double = 300.0

         6.0*50
         â‡’ res15: kotlin.Double = 300.0

   5. Call some methods on numbers. Kotlin keeps numbers as primitives, but it lets you
      call methods on numbers as if they were objects.

      ::

         2.times(3)
         â‡’ res5: kotlin.Int = 6

         3.5.plus(4)
         â‡’ res8: kotlin.Double = 7.5

         2.4.div(2)
         â‡’ res9: kotlin.Double = 1.2

      .. Note::

         It is possible to create actual object wrappers around numbers, which is known
         as *boxing*. Boxing happens automatically, such as for collections, where numbers are
         boxed and unboxed as needed.

      .. Warning::

         Using object wrappers takes more memory than storing just a number
         primitive. Do not use boxing unless it is needed, such as in a collection, which is
         covered later.


Step 2: Practice using types

   Kotlin does not implicitly convert between number types, so you can't assign a short
   value directly to a long variable, or a ``Byte`` to an ``Int``. This is because implicit
   number conversion is a common source of errors in programs. You can always assign values
   of different types by casting.

   1. To see some of the casts that are possible, define a variable of type ``Int`` in the
      REPL.

      .. code:: prettyprint

         val i: Int = 6

   2. Create a new variable, then enter the variable name shown above, followed by ``.to``.

      .. code:: prettyprint

         val b1 = i.to

      IntelliJ IDEA displays a list of possible completions. This auto-completion works for
      variables and objects of any type.

      .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-basics/img/6495b0b44b910418.png

   3. Select ``toByte()`` from the list, then print the variable.

      .. code:: prettyprint

         val b1 = i.toByte()
         println(b1)

      ::

         â‡’ 6

   4. Assign a ``Byte`` value to variables of different types.

      .. code:: prettyprint

         val b2: Byte = 1 // OK, literals are checked statically
         println(b2)
         â‡’ 1

         val i1: Int = b2
         â‡’ error: type mismatch: inferred type is Byte but Int was expected

         val i2: String = b2
         â‡’ error: type mismatch: inferred type is Byte but String was expected

         val i3: Double = b2
         â‡’ error: type mismatch: inferred type is Byte but Double was expected

   5. For the assignments that returned errors, try casting them instead.

      .. code:: prettyprint

         val i4: Int = b2.toInt() // OK!
         println(i4)
         â‡’ 1

         val i5: String = b2.toString()
         println(i5)
         â‡’ 1

         val i6: Double = b2.toDouble()
         println(i6)
         â‡’ 1.0

   6. To make long numeric constants more readable, Kotlin allows you to place underscores
      in the numbers, where it makes sense to you. Try entering different numeric
      constants.

      ::

         val oneMillion = 1_000_000
         val socialSecurityNumber = 999_99_9999L
         val hexBytes = 0xFF_EC_DE_5E
         val bytes = 0b11010010_01101001_10010100_10010010

      **Note:** Because Kotlin is strongly typed, the compiler can usually infer the type for
      variables, so you don't need to explicitly declare it.


Step 3: Learn the value of variable types

   Kotlin supports two types of variables: changeable and unchangeable. With ``val``, you
   can assign a value once. If you try to assign something again, you get an error. With
   ``var``, you can assign a value, then change the value later in the program.

   1. Define variables using ``val`` and ``var`` and then assign new values to them.

      .. code:: prettyprint

         var fish = 1
         fish = 2
         val aquarium = 1
         aquarium = 2

      ::

         â‡’ error: val cannot be reassigned

      You can assign ``fish`` a value, then assign it a new value, because it is defined with
      ``var``. Trying to assign a new value to ``aquarium`` gives an error because it is
      defined with ``val``.

      The type you store in a variable is inferred when the compiler can figure it out from
      context. If you want, you can always specify the type of a variable explicitly, using
      the colon notation.

   2. Define some variables and specify the type explicitly.

      .. code:: prettyprint

         var fish: Int = 12
         var lakes: Double = 2.5

      Once a type has been assigned by you or the compiler, you can't change the type, or you
      get an error.


Step 4: Learn about strings

   Strings in Kotlin work pretty much like strings in any other programming language using
   ``"`` for strings and ``'`` for single characters, and you can concatenate strings with
   the ``+`` operator. You can create string templates by combining them with values; the
   ``$`` ``variable`` name is replaced with the text representing the value. This is
   called `variable interpolation`.

   1. Create a string template.

      .. code:: prettyprint

         val numberOfFish = 5
         val numberOfPlants = 12
         "I have $numberOfFish fish" + " and $numberOfPlants plants"

      ::

         â‡’ res20: kotlin.String = I have 5 fish and 12 plants

   2. Create a string template with an expression in it. As in other languages, the value
      can be the result of an expression. Use curly braces ``{}`` to define the expression.

      .. code:: prettyprint

         "I have ${numberOfFish + numberOfPlants} fish and plants"

      ::

         â‡’ res21: kotlin.String = I have 17 fish and plants

3. Task: Compare conditions and booleans
--------------------------------------------------------------------------------

   In this task, you learn about booleans and checking conditions in the Kotlin programming
   language. Like other languages, Kotlin has booleans and boolean operators such as less
   than, equal to, greater than, and so on (``<``, ``==``, ``>``, ``!=``, ``<=``, ``>=``).

   1. Write an ``if``/``else`` statement.

      .. code:: prettyprint

         val numberOfFish = 50
         val numberOfPlants = 23
         if (numberOfFish > numberOfPlants) {
            println("Good ratio!") 
         } else {
            println("Unhealthy ratio")
         }

      ::

         â‡’ Good ratio!

   2. Try a range in an ``if`` statement. In Kotlin, the condition you test can use ranges,
      too.

      .. code:: prettyprint

         val fish = 50
         if (fish in 1..100) {
            println(fish)
         }

      ::

         â‡’ 50

   3. Write an ``if`` with multiple cases. For more complicated conditions, use logical and
      ``&&`` and logical or ``||``. As in other languages, you can have multiple cases by
      using ``else if``.

      .. code:: prettyprint

         if (numberOfFish == 0) {
            println("Empty tank")
         } else if (numberOfFish < 40) {
            println("Got fish!")
         } else {
            println("That's a lot of fish!")
         }

      ::

         â‡’ That's a lot of fish!

   4. Try out a ``when`` statement. There's a nicer way to write that series of
      ``if``/ ``else if``/ ``else`` statements in Kotlin, using the ``when`` statement, which
      is like the ``switch`` statement in other languages. Conditions in a ``when``
      statement can use ranges, too.

      .. code:: prettyprint

         when (numberOfFish) {
            0  -> println("Empty tank")
            in 1..39 -> println("Got fish!")
            else -> println("That's a lot of fish!")
         }

      ::

         â‡’ That's a lot of fish!

4. Task: Learn about nullability
--------------------------------------------------------------------------------

   In this task, you learn about nullable versus non-nullable variables. Programming errors
   involving nulls have been the source of countless bugs. Kotlin seeks to reduce bugs by
   introducing non-nullable variables.


Step 1: Learn about nullability

   By default, variables cannot be ``null``.

   1. Declare an ``Int`` and assign ``null`` to it.

      .. code:: prettyprint

         var rocks: Int = null

      ::

         â‡’ error: null can not be a value of a non-null type Int

   2. Use the question mark operator, ``?``, after the type to indicate that a variable can
      be null. Declare an ``Int?`` and assign ``null`` to it.

      .. code:: prettyprint

         var marbles: Int? = null

      When you have complex data types, such as a list:

      -  You can allow the elements of the list to be null.
      -  You can allow for the list to be null, but if it's not null its elements cannot be null.
      -  You can allow both the list or the elements to be null.

      Lists and some other complex data types are covered in a later task.


Step 2: Learn about the ? and ?: operators

   You can test for ``null`` with the ``?`` operator, saving you the pain of writing many
   ``if``/ ``else`` statements.

   1. Write some code the longer way to check whether the ``fishFoodTreats`` variable is
      not ``null``. Then decrement that variable.

      .. code:: prettyprint

         var fishFoodTreats = 6
         if (fishFoodTreats != null) {
            fishFoodTreats = fishFoodTreats.dec()
         }

   2. Now look at the Kotlin way of writing it, using the ``?`` operator.

      .. code:: prettyprint

         var fishFoodTreats = 6
         fishFoodTreats = fishFoodTreats?.dec()

   3. You can also chain null tests with the ``?:`` operator. Look at this example:

      .. code:: prettyprint

         fishFoodTreats = fishFoodTreats?.dec() ?: 0

      It's shorthand for "if ``fishFoodTreats`` is not ``null``, decrement and use it;
      otherwise use the value after the ``?:``, which is 0." If ``fishFoodTreats`` is
      ``null``, evaluation is stopped, and the ``dec()`` method is not called.

      **Note:** The ``?:`` operator is sometimes called the "Elvis operator," because it's
      like a smiley on its side with a pompadour hairstyle, the way Elvis Presley styled his
      hair. Read more about 
      `the Elvis operator <https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator>`__ in
      the Kotlin documentation.


A point about null pointers

   If you really love ``NullPointerExceptions``, Kotlin lets you keep them. The not-null
   assertion operator, ``!!`` (double-bang), converts any value to a non-null type and
   throws an exception if the value is ``null``.

   .. code:: prettyprint

      val len = s!!.length   // throws NullPointerException if s is null

   **Note:** In programming slang, the exclamation mark is often called a "
   `bang <https://en.wikipedia.org/wiki/Exclamation_mark#Computers>`__," so the not-null
   assertion operator is sometimes called the "double-bang" or "bang bang" operator.

   **Note:** It's generally a bad idea to use the double-bang operator. That's why the
   language creators made you enter two exclamation marks instead of one. However,
   sometimes you need the double-bang when dealing with legacy Java code.

5. Task: Explore arrays, lists, and loops
--------------------------------------------------------------------------------

   In this task, you learn about arrays and lists, and you learn different ways to create
   loops in the Kotlin programming language.


Step 1: Make lists

   Lists are a fundamental type in Kotlin, and are similar to lists in other languages.

   1. Declare a list using ``listOf`` and print it out. This list cannot be changed.

      .. code:: prettyprint

         val school = listOf("mackerel", "trout", "halibut")
         println(school)

      ::

         â‡’ [mackerel, trout, halibut]

   2. Declare a list that can be changed using ``mutableListOf``. Remove an item.

      .. code:: prettyprint

         val myList = mutableListOf("tuna", "salmon", "shark")
         myList.remove("shark")

      ::

         â‡’ res36: kotlin.Boolean = true

      The ``remove()`` method returns ``true`` when it successfully removes the item passed.

      **Note:** With a list defined with ``val``, you can't change which list the variable
      refers to, but you can still change the contents of the list.


Step 2: Create arrays

   Like other languages, Kotlin has
   `arrays <https://kotlinlang.org/docs/reference/basic-types.html#arrays>`__. Unlike lists
   in Kotlin, which have mutable and immutable versions, there is no mutable version of an
   ``Array``. Once you create an array, the size is fixed. You can't add or remove
   elements, except by copying to a new array.

   The rules about using ``val`` and ``var`` are the same with arrays as with lists.

   **Note:** With an array defined with ``val``, you can't change which array the variable
   refers to, but you can still change the contents of the array.

   1. Declare an array of strings using ``arrayOf``. Use the
      ``java.util.Arrays.toString()`` array utility to print it out.

      .. code:: prettyprint

         val school = arrayOf("shark", "salmon", "minnow")
         println(java.util.Arrays.toString(school))

      ::

         â‡’ [shark, salmon, minnow]

   2. An array declared with ``arrayOf`` doesn't have a type associated with the elements,
      so you can mix types, which is helpful. Declare an array with different types.

      .. code:: prettyprint

         val mix = arrayOf("fish", 2)

   3. You can also declare arrays with one type for all the elements. Declare an array of
      integers using ``intArrayOf()``. There are corresponding builders, or instantiation
      functions, for arrays of other types.

      .. code:: prettyprint

         val numbers = intArrayOf(1,2,3)

      **Note:** Using an array of a primitive type such as ``Int`` or ``Byte`` avoids the
      overhead of boxing.

   4. Combine two arrays with the ``+`` operator.

      .. code:: prettyprint

         val numbers = intArrayOf(1,2,3)
         val numbers3 = intArrayOf(4,5,6)
         val foo2 = numbers3 + numbers
         println(foo2[5])

      ::

         => 3

   5. Try out different combinations of nested arrays and lists. As in other languages, you
      can nest arrays and lists. That is, when you put an array within an array, you have
      an array of arraysâ€”not a flattened array of the contents of the two. The elements of
      an array can also be lists, and the elements of lists can be arrays.

      .. code:: prettyprint

         val numbers = intArrayOf(1, 2, 3)
         val oceans = listOf("Atlantic", "Pacific")
         val oddList = listOf(numbers, oceans, "salmon")
         println(oddList)

      ::

         â‡’ [[I@89178b4, [Atlantic, Pacific], salmon]

      The first element, ``numbers``, is an ``Array``. When you don't use the array utility to
      print it, Kotlin prints the address instead of the contents of the array.

   6. One nice feature of Kotlin is that you can initialize arrays with code instead of
      initializing them to 0. Try this example:

      .. code:: prettyprint

         val array = Array (5) { it * 2 }
         println(java.util.Arrays.toString(array))

      ::

         â‡’ [0, 2, 4, 6, 8]

      The initialization code is between the curly braces, ``{}``. In the code, ``it`` refers
      to the array index, starting with 0.


Step 3: Make loops

   Now that you have lists and arrays, looping through the elements works as you might
   expect.

   1. Create an array. Use a ``for`` loop to iterate through the array and print the
      elements.

      .. code:: prettyprint

         val school = arrayOf("shark", "salmon", "minnow")
         for (element in school) {
            print(element + " ")
         }

      ::

         â‡’ shark salmon minnow

   2. In Kotlin, you can loop through the elements and the indexes at the same time. Try
      this example:

      .. code:: prettyprint

         for ((index, element) in school.withIndex()) {
            println("Item at $index is $element\n")
         }

      ::

         â‡’ Item at 0 is shark
         Item at 1 is salmon
         Item at 2 is minnow

   3. Try different step sizes and ranges. You can specify ranges of numbers or of
      characters, alphabetically. And as in other languages, you don't have to step forward
      by 1. You can step backward using ``downTo``.

      .. code:: prettyprint

         for (i in 1..5) print(i)
         â‡’ 12345

         for (i in 5 downTo 1) print(i)
         â‡’ 54321

         for (i in 3..6 step 2) print(i)
         â‡’ 35

         for (i in 'd'..'g') print (i)
         â‡’ defg

   4. Try out some loops. Like other languages, Kotlin has ``while`` loops, ``do...while``
      loops, and ``++`` and ``--`` operators. Kotlin also has ``repeat`` loops.

      .. code:: prettyprint

         var bubbles = 0
         while (bubbles < 50) {
            bubbles++
         }
         println("$bubbles bubbles in the water\n")

         do {
            bubbles--
         } while (bubbles > 50)
         println("$bubbles bubbles in the water\n")

         repeat(2) {
            println("A fish is swimming")
         }

      ::

         â‡’ 50 bubbles in the water
         49 bubbles in the water
         A fish is swimming
         A fish is swimming


6. Summary
--------------------------------------------------------------------------------

   Kotlin is very similar to other languages when it comes to the basics like operators,
   lists, and loops, but there are some important differences.

   The following features may be different in Kotlin than what you're used to in other
   languages:

   -  Kotlin types can't be implicitly convertedâ€”use casting.
   -  Variables declared with ``val`` can only be assigned once.
   -  Kotlin variables are not nullable by default. Use ``?`` to make variables nullable.
   -  With Kotlin, you can loop through the index and elements of an array at the same time
      in a ``for`` loop.

   The following Kotlin programming constructs are similar to those in other languages:

   -  Arrays and lists can have a single type or mixed types.
   -  Arrays and lists can be nested.
   -  You can create loops with ``for``, ``while``, ``do``/``while``, and ``repeat``.
   -  The ``when`` statement is Kotlin's version of the ``switch`` statement, but ``when``
      is more flexible.


7. Learn more
--------------------------------------------------------------------------------


Kotlin documentation

   If you want more information on any topic in this course, or if you get stuck,
   `https://kotlinlang.org <https://kotlinlang.org/>`__ is your best starting point.

   -  `Kotlin coding conventions <https://kotlinlang.org/docs/reference/coding-conventions.html>`__
   -  `Kotlin idioms <https://kotlinlang.org/docs/reference/idioms.html>`__
   -  `Explicit type conversion <https://kotlinlang.org/docs/reference/basic-types.html#explicit-conversions>`__
   -  `Defining variables <https://kotlinlang.org/docs/reference/basic-syntax.html#defining-variables>`__
   -  `String templates <https://kotlinlang.org/docs/reference/basic-types.html#string-templates>`__
   -  `Nullable values <https://kotlinlang.org/docs/reference/basic-syntax.html#using-nullable-values-and-checking-for-null>`__
   -  `Lists <https://kotlinlang.org/docs/reference/collections-overview.html#list>`__
   -  `Arrays <https://kotlinlang.org/docs/reference/basic-types.html#arrays>`__
   -  `if, when, for, while <https://kotlinlang.org/docs/reference/control-flow.html#control-flow-if-when-for-while>`__
   -  `?: (Elvis) operator <https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator>`__
   -  `!! operator <https://kotlinlang.org/docs/reference/null-safety.html#the--operator>`__


Kotlin tutorials

   The https://play.kotlinlang.org website includes rich tutorials called Kotlin Koans, a
   `web-based interpreter <https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt>`__,
   and a complete set of reference documentation with examples.


Udacity course

   To view the Udacity course on this topic, see 
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__.


IntelliJ IDEA

   `Documentation for the IntelliJ IDEA <https://www.jetbrains.com/help/idea/>`__ 
   can be found on the JetBrains website.


8. Homework
--------------------------------------------------------------------------------

   This section lists possible homework assignments for students who are working through
   this codelab as part of a course led by an instructor. It's up to the instructor to do

   the following:
   -  Assign homework if required.
   -  Communicate to students how to submit homework assignments.
   -  Grade the homework assignments.

   Instructors can use these suggestions as little or as much as they want, and should feel
   free to assign any other homework they feel is appropriate.

   If you're working through this codelab on your own, feel free to use these homework
   assignments to test your knowledge.


**Answer these questions**

**Question 1**

   Which of the following declares an unchangeable list of strings?

   *  â–¢ ``val school = arrayOf("shark", "salmon", "minnow")``
   *  â–¢ ``var school = arrayOf("shark", "salmon", "minnow")``
   *  â–¢ ``val school = listOf("shark", "salmon", "minnow")``
   *  â–¢ ``val school = mutableListOf("shark", "salmon", "minnow")``


**Question 2**

   What will be the output of the following code? ``for (i in 3..8 step 2) print(i)``

   *  â–¢ 345678
   *  â–¢ 468
   *  â–¢ 38
   *  â–¢ 357


**Question 3**

   What is the purpose of the question mark in this code? ``var rocks: Int? = 3``

   *  â–¢ The type of the variable ``rocks`` isn't fixed.
   *  â–¢ The variable ``rocks`` can be set to null.
   *  â–¢ The variable ``rocks`` cannot be set to null.
   *  â–¢ The variable ``rocks`` shouldn't be initialized right away.

9. Next codelab
--------------------------------------------------------------------------------

   Proceed to the next lesson: 
   `3. Functions <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-functions/>`__

   For an overview of the course, including links to other codelabs, see 
   `"Kotlin Bootcamp for Programmers: Welcome to the course." <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-welcome/>`__


â­ Kotlin Bootcamp 3: Functions
==================================

   pandoc --column=100 -trst -rhtml https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-functions/


1. Welcome
--------------------------------------------------------------------------------

   This codelab is part of the 
   `Kotlin Bootcamp for Programmers course <https://developer.android.google.cn/courses/kotlin-bootcamp/overview>`__. You'll
   get the most value out of this course if you work through the codelabs in sequence.
   Depending on your knowledge, you may be able to skim some sections. This course is
   geared towards programmers who know an object-oriented language, and want to learn
   `Kotlin <https://kotlinlang.org/>`__.



Introduction

   In this codelab, you create a Kotlin program and learn about functions in Kotlin,
   including default values for parameters, filters, lambdas, and compact functions.

   Rather than build a single sample app, the lessons in this course are designed to build
   your knowledge, but be semi-independent of each other so you can skim sections you're
   familiar with. To tie them together, many of the examples use an aquarium theme. And if
   you want to see the full aquarium story, check out the 
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__ Udacity course.


What you should already know

   -  The basics of a modern, object-oriented, statically typed programming language
   -  How to program with classes, methods, and exception handling in at least one language
   -  How to work with Kotlin's REPL (Read-Eval-Print Loop) in IntelliJ IDEA
   -  The basics of Kotlin, including types, operators, and loops

   This codelab is geared towards programmers who know an object-oriented language and want
   to learn more about Kotlin.


What you'll learn


   -  How to create a program with a ``main()`` function and arguments in IntelliJ IDEA
   -  How to use default values and compact functions
   -  How to apply filters for lists
   -  How to create basic lambdas and higher-order functions


What you'll do

   -  Work with the REPL to try out some code.
   -  Work with IntelliJ IDEA to create basic Kotlin programs.


2. Task: Explore the main() function
--------------------------------------------------------------------------------

   In this task, you create a Kotlin program and learn about the ``main()`` function, as
   well as how to pass arguments to a program from the command line.

   You may remember the ``printHello()`` function that you entered into the REPL in a
   previous codelab:

   .. code:: prettyprint

      fun printHello() {
          println ("Hello World")
      }

      printHello()

   ::

      â‡’ Hello World

   You define functions using the ``fun`` keyword, followed by the name of the function. As
   with other programming languages, the parentheses ``()`` are for function arguments, if
   any. Curly braces ``{}`` frame the code for the function. There is no return type for
   this function, because it doesn't return anything.


Step 1: Create a Kotlin file

   1. Open IntelliJ IDEA.
   2. The **Project** pane on the left in IntelliJ IDEA shows a list of your project files
      and folders. Find and right-click the **src** folder under **Hello Kotlin.** (You
      should already have the **Hello Kotlin** project from the previous codelab.)
   3. Select **New > Kotlin File / Class**.
   4. Keep **Kind** as **File**, and name the file **Hello**.
   5. Click **OK**.

   There is now a file in the **src** folder called **Hello.kt**.

      .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-functions/img/ebfb3ba0929f45bb.png


Step 2: Add code and run your program

   1. As with other languages, the Kotlin ``main()`` function specifies the entry point for
      execution. Any command line arguments are passed as an array of strings.

      Type or paste the following code into the **Hello.kt** file:

      .. code:: prettyprint

         fun main(args: Array<String>) {
            println("Hello, world!")
         }

      **Tip:** As of Kotlin 1.3, if your ``main()`` function doesn't use any parameters, you
      don't need to define ``args``.

   2. Like your earlier ``printHello()`` function, this function has no ``return`` statement.
      Every function in Kotlin returns something, even when nothing is explicitly specified.
      So a function like this ``main()`` function returns a type ``kotlin.Unit``, which is
      Kotlin's way of saying no value.

      **Note:** When a function returns ``kotlin.Unit``, you don't have to specify it
      explicitly. This is different from some other languages, where you have to explicitly
      say that you are returning nothing.

   3. To run your program, click the green triangle to the left of the ``main()`` function.
      Select **Run â€˜HelloKt'** from the menu.

   4. IntelliJ IDEA compiles the program and runs it. The results appear in a log pane at
      the bottom, as shown below.

      .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-functions/img/7b8750c0e4817c3d.png


   **Java programmers:** If you're using a previously installed version of IntelliJ IDEA
   instead of installing a fresh copy, at this point you may have problems accessing the
   Kotlin compiler. Be sure your project is referring to the correct version of the JDK.
   See `this discussion on Stack Overflow <https://stackoverflow.com/a/44907745>`__ and the
   `Change project SDK documentation <https://www.jetbrains.com/help/idea/sdk.html#change-project-sdk>`__ 
   for IntelliJ IDEA.


Step 3: Pass arguments to main()

   Because you are running your program from IntelliJ IDEA and not from the command line,
   you need to specify any arguments to the program a little differently.

   1. Select **Run > Edit Configurations**. The **Run/Debug Configurations** window opens.
   2. Type ``Kotlin!`` in the **Program arguments** field.
   3. Click **OK**.

      .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-functions/img/7224905bcfca70c2.png


Step 4: Change the code to use a string template

   A `string template <https://kotlinlang.org/docs/reference/basic-types.html#string-templates>`__
   inserts a variable or expression into a string, and ``$`` specifies that part of the
   string will be a variable or expression. Curly braces ``{}`` frame the expression, if
   any.

   1. In **Hello.kt**, change the greeting message to use the first argument passed into
      the program, ``args[0]``, instead of ``"world"``.

      .. code:: prettyprint

         fun main(args: Array<String>) {
            println("Hello, ${args[0]}")
         }

   2. Run the program, and the output includes the argument you specified.

      ::

         â‡’ Hello, Kotlin!


3. Task: Learn why (almost) everything has a value
--------------------------------------------------------------------------------

   In this task, you learn why almost everything in Kotlin has a value, and why that's
   useful.

   Some other languages have *statements*, which are lines of code that don't have a value.
   In Kotlin, almost everything is an *expression* and has a valueâ€”even if that value is
   ``kotlin.Unit``.

   1. In **Hello.kt**, write code in ``main()`` to assign a ``println()`` to a variable
      called ``isUnit`` and print it. (``println()`` does not return a value, so it returns
      ``kotlin.Unit``.)

      .. code:: prettyprint

         // Will assign kotlin.Unit
         val isUnit = println("This is an expression")
         println(isUnit)

   2. Run your program. The first ``println()`` prints the string
      ``"This is an expression"``. The second ``println()`` prints the value of the first
      ``println()`` statement, that is, ``kotlin.Unit``.

      ::

         â‡’ This is an expression
         kotlin.Unit

   3. Declare a ``val`` called ``temperature`` and initialize it to 10.

   4. Declare another ``val`` called ``isHot`` and assign the return value of an
      ``if``/``else`` statement to ``isHot``, as shown in the following code. Because it is
      an expression, you can use the value of the ``if`` expression right away.

      .. code:: prettyprint

         val temperature = 10
         val isHot = if (temperature > 50) true else false
         println(isHot)

      ::

         â‡’ false

   5. Use the value of an expression in a string template. Add some code to check the
      temperature to determine whether a fish is safe or too warm, then run your program.

      .. code:: prettyprint

         val temperature = 10
         val message = "The water temperature is ${ if (temperature > 50) "too warm" else "OK" }."
         println(message)

      ::

         â‡’ The water temperature is OK.

   **Note:** Loops are exceptions to "everything has a value." There's no sensible value
   for ``for`` loops or ``while`` loops, so they do not have values. If you try to assign a
   loop's value to something, the compiler gives an error.


4. Task: Learn more about functions
--------------------------------------------------------------------------------

   In this task, you learn more about functions in Kotlin, and more about the very useful
   ``when`` conditional expression.


Step 1: Create some functions

   In this step, you put together some of what you've learned and create functions with
   different types. You can replace the contents of **Hello.kt** with this new code.

   1. Write a function called ``feedTheFish()`` that calls ``randomDay()`` to get a random
      day of the week. Use a string template to print a ``food`` for the fish to eat that
      day. For now, the fish eat the same food every day.

      .. code:: prettyprint

         fun feedTheFish() {
            val day = randomDay()
            val food = "pellets"
            println ("Today is $day and the fish eat $food")
         }

         fun main(args: Array<String>) {
            feedTheFish()
         }

   2. Write the ``randomDay()`` function to pick a random day from an array and return it.

      The ``nextInt()`` function takes an integer limit, which limits the number from
      ``Random()`` to 0 through 6 to match the ``week`` array.

      .. code:: prettyprint

         fun randomDay() : String {
            val week = arrayOf ("Monday", "Tuesday", "Wednesday", "Thursday",
                     "Friday", "Saturday", "Sunday")
            return week[Random().nextInt(week.size)]
         }

   3. The ``Random()`` and ``nextInt()`` functions are defined in ``java.util.*``. At the
      top of the file, add the needed import:

      .. code:: prettyprint

         import java.util.*    // required import

      **Tip:** Before you add the import, ``Random()`` gives an unresolved reference error in
      IntelliJ IDEA. To add the import automatically, click on ``Random()``, then press
      ``Alt+Enter`` (``Option+Enter`` on a Mac). Select **Import > java.util.Random**.

   4. Run your program, and check the output.

      ::

         â‡’ Today is Tuesday and the fish eat pellets


Step 2: Use a when expression

   Extending this further, change the code to pick different food for different days using
   a ``when`` expression. The ``when`` statement is similar to ``switch`` in other
   programming languages, but ``when`` automatically breaks at the end of each branch. It
   also makes sure your code covers all the branches if you are checking an enum.

   1. In **Hello.kt**, add a function called ``fishFood()`` that takes a day as a
      ``String`` and returns the fish's food for the day as a ``String``. Use ``when()``,
      so that each day the fish gets a specific food. Run your program a few times to see
      different outputs.

      .. code:: prettyprint

         fun fishFood (day : String) : String {
            var food = ""
            when (day) {
               "Monday" -> food = "flakes"
               "Tuesday" -> food = "pellets"
               "Wednesday" -> food = "redworms"
               "Thursday" -> food = "granules"
               "Friday" -> food = "mosquitoes"
               "Saturday" -> food = "lettuce"
               "Sunday" -> food = "plankton"
            }
            return food
         }

         fun feedTheFish() {
            val day = randomDay()
            val food = fishFood(day)

            println ("Today is $day and the fish eat $food")
         }

      ::

         â‡’ Today is Thursday and the fish eat granules

   2. Add a default branch to the ``when`` expression using ``else``. For testing, to make
      sure the default is taken sometimes in your program, remove the ``Tuesday`` and
      ``Saturday`` branches.

      Having a default branch ensures that ``food`` gets a value before being returned, so it
      doesn't need to be initialized anymore. Because the code now assigns a string to
      ``food`` only once, you can declare ``food`` with ``val`` instead of ``var``.

      .. code:: prettyprint

         fun fishFood (day : String) : String {
            val food : String
            when (day) {
               "Monday" -> food = "flakes"
               "Wednesday" -> food = "redworms"
               "Thursday" -> food = "granules"
               "Friday" -> food = "mosquitoes"
               "Sunday" -> food = "plankton"
               else -> food = "nothing"
            }
            return food
         }

   3. Because every expression has a value, you can make this code a little more concise.
      Return the value of the ``when`` expression directly, and eliminate the ``food``
      variable. The value of the ``when`` expression is the value of the last expression of
      the branch that satisfied the condition.

      .. code:: prettyprint

         fun fishFood (day : String) : String {
            return when (day) {
               "Monday" -> "flakes"
               "Wednesday" -> "redworms"
               "Thursday" -> "granules"
               "Friday" -> "mosquitoes"
               "Sunday" -> "plankton"
               else -> "nothing"
            }
         }

      The final version of your program looks something like the code below.

      .. code:: prettyprint

         import java.util.*    // required import

         fun randomDay() : String {
            val week = arrayOf ("Monday", "Tuesday", "Wednesday", "Thursday",
               "Friday", "Saturday", "Sunday")
            return week[Random().nextInt(week.size)]
         }

         fun fishFood (day : String) : String {
            return when (day) {
               "Monday" -> "flakes"
               "Wednesday" -> "redworms"
               "Thursday" -> "granules"
               "Friday" -> "mosquitoes"
               "Sunday" -> "plankton"
               else -> "nothing"
            }
         }

         fun feedTheFish() {
            val day = randomDay()
            val food = fishFood(day)
            println ("Today is $day and the fish eat $food")
         }

         fun main(args: Array<String>) {
            feedTheFish()
         }


5. Task: Explore default values and compact functions
--------------------------------------------------------------------------------

   In this task, you learn about default values for functions and methods. You also learn
   about `compact functions`, which can make your code more concise and readable, and can
   reduce the number of code paths for testing. Compact functions are also called
   `single-expression functions`.


Step 1: Create a default value for a parameter

   In Kotlin, you can pass arguments by parameter name. You can also specify default values
   for parameters: if an argument isn't supplied by the caller, the default value is used.
   Later, when you write methods (member functions), it means you can avoid writing lots of
   overload versions of the same method.

   1. In **Hello.kt**, write a ``swim()`` function with a ``String`` parameter named
      ``speed`` that prints the fish's speed. The ``speed`` parameter has a default value
      of ``"fast"``.

      .. code:: prettyprint

         fun swim(speed: String = "fast") {
            println("swimming $speed")
         }

   2. From the ``main()`` function, call the ``swim()`` function three ways. First call the
      function using the default. Then call the function and pass the ``speed`` parameter
      without a name, then call the function by naming the ``speed`` parameter.

      .. code:: prettyprint

         swim()   // uses default speed
         swim("slow")   // positional argument
         swim(speed="turtle-like")   // named parameter

      ::

         â‡’ swimming fast
         swimming slow
         swimming turtle-like

   **Note:** Arguments don't have to use the parameter names; you can just pass the
   arguments in the defined order. But with default values, this can get a little
   confusing, so it is best practice to put parameters without defaults first, and the ones
   with defaults after.


Step 2: Add required parameters

   If no default is specified for a parameter, the corresponding argument must always be
   passed.

   1. In **Hello.kt**, write a ``shouldChangeWater()`` function that takes three
      parameters: ``day``, ``temperature``, and a ``dirty`` level. The function returns
      ``true`` if the water should be changed, which happens if it's Sunday, if the
      temperature is too high, or if the water is too dirty. The day of the week is
      required, but the default temperature is 22, and the default dirty level is 20.

      Use a ``when`` expression without an argument, which in Kotlin acts as a series of
      ``if/else if`` checks.

      .. code:: prettyprint

         fun shouldChangeWater (day: String, temperature: Int = 22, dirty: Int = 20): Boolean {
            return when {
               temperature > 30 -> true
               dirty > 30 -> true
               day == "Sunday" ->  true
               else -> false
            }
         }

   2. Call ``shouldChangeWater()`` from ``feedTheFish()`` and supply the day. The ``day``
      parameter doesn't have a default, so you must specify an argument. The other two
      parameters of ``shouldChangeWater()`` have default values, so you don't have to pass
      arguments for them.

      .. code:: prettyprint

         fun feedTheFish() {
            val day = randomDay()
            val food = fishFood(day)
            println ("Today is $day and the fish eat $food")
            println("Change water: ${shouldChangeWater(day)}")
         }

      ::

         => Today is Thursday and the fish eat granules
         Change water: false


Step 3: Make compact functions

   The ``when`` expression that you wrote in the previous step packs a lot of logic into a
   small amount of code. If you wanted to unpack it a little, or if the conditions to check
   were more complicated, you could use some well-named local variables. But the Kotlin way
   to do it is with compact functions.

   Compact functions, or 
   `single-expression functions <https://kotlinlang.org/docs/reference/idioms.html#single-expression-functions>`__,
   are a common pattern in Kotlin. When a function returns the results of a single
   expression, you can specify the body of the function after an ``=`` symbol, omit the
   curly braces ``{}``, and omit the ``return``.

   1. in **Hello.kt**, add compact functions to test the conditions.

      .. code:: prettyprint

         fun isTooHot(temperature: Int) = temperature > 30

         fun isDirty(dirty: Int) = dirty > 30

         fun isSunday(day: String) = day == "Sunday"

   2. Change ``shouldChangeWater()`` to call the new functions.

      .. code:: prettyprint

         fun shouldChangeWater (day: String, temperature: Int = 22, dirty: Int = 20): Boolean {
            return when {
               isTooHot(temperature) -> true
               isDirty(dirty) -> true
               isSunday(day) -> true
               else  -> false
            }
         }

   3. Run your program. The output from the ``println()`` with ``shouldChangeWater()``
      should be the same as it was before you switched to using compact functions.


Default values

   The default value for a parameter doesn't have to be a value. It can be another
   function, as shown in the following partial sample:

   .. code:: prettyprint

      fun shouldChangeWater (day: String, temperature: Int = 22, dirty: Int = getDirtySensorReading()): Boolean {
          ...

   **Note:** A function used as a default value is evaluated at runtime, so do not put an
   expensive operation like a file read or a large memory allocation in the function. The
   operation is executed every time your function is called, which may slow down your
   program.


6. Task: Get started with filters
--------------------------------------------------------------------------------

   In this task, you learn a bit about filters in Kotlin. Filters are a handy way to get
   part of a list based on some condition.


Step 1: Create a filter

   1. In **Hello.kt**, define a list of aquarium decorations at the top level with
      ``listOf()``. You can replace the contents of **Hello.kt**.

      .. code:: prettyprint

         val decorations = listOf ("rock", "pagoda", "plastic plant", "alligator", "flowerpot")

   2. Create a new ``main()`` function with a line to print only the decorations that start
      with the letter â€˜p'. The code for the filter condition is in curly braces ``{}``, and
      ``it`` refers to each item as the filter loops through. If the expression returns
      ``true``, the item is included.

      .. code:: prettyprint

         fun main() {
            println( decorations.filter {it[0] == 'p'})
         }

   3. Run your program, and you see the following output in the **Run** window:

      ::

         â‡’ [pagoda, plastic plant]


Step 2: Compare eager and lazy filters

   If you're familiar with filters in other languages, you may wonder whether filters in
   Kotlin are *eager* or *lazy*. Is the result list created immediately, or when the list
   is accessed? In Kotlin, it happens whichever way you need it to. By default, ``filter``
   is eager, and each time you use the filter, a list is created.

   To make the filter lazy, you can use a
   `Sequence <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html>`__,
   which is a collection that can only look at one item at a time, starting at the
   beginning, and going to the end. Conveniently, this is exactly the API that a lazy
   filter needs.

   1. In **Hello.kt**, change your code to assign the filtered list to a variable called
      ``eager``, then print it.

      .. code:: prettyprint

         fun main() {
            val decorations = listOf ("rock", "pagoda", "plastic plant", "alligator", "flowerpot")

            // eager, creates a new list
            val eager = decorations.filter { it [0] == 'p' }
            println("eager: $eager")

   2. Below that code, evaluate the filter using a ``Sequence`` with ``asSequence()``.
      Assign the sequence to a variable called ``filtered``, and print it.

      .. code:: prettyprint

            // lazy, will wait until asked to evaluate
            val filtered = decorations.asSequence().filter { it[0] == 'p' }
            println("filtered: $filtered")

      When you return the filter results as a ``Sequence``, the ``filtered`` variable won't
      hold a new listâ€”it'll hold a ``Sequence`` of the list elements and knowledge of the
      filter to apply to those elements. Whenever you access elements of the ``Sequence``, the
      filter is applied, and the result is returned to you.

   3. Force evaluation of the sequence by converting it to a ``List`` with ``toList()``.
      Print the result.

      .. code:: prettyprint

            // force evaluation of the lazy list
            val newList = filtered.toList()
            println("new list: $newList")

   4. Run your program and observe the output.

      ::

         â‡’ eager: [pagoda, plastic plant]
         filtered: kotlin.sequences.FilteringSequence@386cc1c4
         new list: [pagoda, plastic plant]

      To visualize what's going on with the ``Sequence`` and lazy evaluation, use the
      ``map()`` function. The ``map()`` function performs a simple transformation on each
      element in the sequence.

   5. With the same ``decorations`` list as above, make a transformation with ``map()``
      that does nothing, and simply returns the element that was passed. Add a
      ``println()`` to show each time an element is accessed, and assign the sequence to a
      variable called ``lazyMap``.

      .. code:: prettyprint

            val lazyMap = decorations.asSequence().map {
               println("access: $it")
               it
            }

   6. Print ``lazyMap``, print the first element of ``lazyMap`` using ``first()``, and
      print ``lazyMap`` converted to a ``List``.

      .. code:: prettyprint

            println("lazy: $lazyMap")
            println("-----")
            println("first: ${lazyMap.first()}")
            println("-----")
            println("all: ${lazyMap.toList()}")

   7. Run your program, and observe the output. Printing ``lazyMap`` just prints a
      reference to the ``Sequence``â€”the inner ``println()`` isn't called. Printing the
      first element accesses only the first element. Converting the ``Sequence`` to a
      ``List`` accesses all the elements.

      ::

         â‡’ lazy: kotlin.sequences.TransformingSequence@5ba23b66
         -----
         access: rock
         first: rock
         -----
         access: rock
         access: pagoda
         access: plastic plant
         access: alligator
         access: flowerpot
         all: [rock, pagoda, plastic plant, alligator, flowerpot]

   8. Create a new ``Sequence`` using the original filter before applying ``map``. Print
      that result.

      .. code:: prettyprint

            val lazyMap2 = decorations.asSequence().filter {it[0] == 'p'}.map {
               println("access: $it")
               it
            }
            println("-----")
            println("filtered: ${lazyMap2.toList()}")

   9. Run your program and observe the additional output. As with getting the first
      element, the inner ``println()`` is only called for the elements that are accessed.

      ::

         â‡’
         -----
         access: pagoda
         access: plastic plant
         filtered: [pagoda, plastic plant]


7. Task: Get started with lambdas and higher-order functions
--------------------------------------------------------------------------------

   In this task, you get an introduction to `lambdas and higher-order functions <https://kotlinlang.org/docs/reference/lambdas.html>`__ 
   in Kotlin.


Lambdas

   In addition to traditional named functions, Kotlin supports lambdas. A `lambda` is an
   expression that makes a function. But instead of declaring a named function, you declare
   a function that has no name. Part of what makes this useful is that the lambda
   expression can now be passed as data. In other languages, lambdas are called 
   `anonymous functions`, `function literals`, or similar names.


Higher-order functions

   You can create a higher-order function by passing a lambda to another function. In the
   previous task, you created a higher-order function called ``filter``. You passed the
   following lambda expression to ``filter`` as the condition to check: ``{it[0] == 'p'}``

   Similarly, ``map`` is a higher-order function, and the lambda you passed to it was the
   transformation to apply.


Step 1: Learn about lambdas

   1. Like named functions, lambdas can have parameters. For lambdas, the parameters (and
      their types, if needed) go on the left of what is called a function arrow ``->``. The
      code to execute goes to the right of the function arrow. Once the lambda is assigned
      to a variable, you can call it just like a function.

      Using the REPL (**Tools > Kotlin > Kotlin REPL**), try out this code:

      .. code:: prettyprint

         var dirtyLevel = 20
         val waterFilter = { dirty : Int -> dirty / 2}
         println(waterFilter(dirtyLevel))

      ::

         â‡’ 10

      In this example, the lambda takes an ``Int`` named ``dirty``, and returns ``dirty / 2``.
      (Because filtering removes dirt.)

   2. Kotlin's syntax for function types is closely related to its syntax for lambdas. Use
      this syntax to cleanly declare a variable that holds a function:

      .. code:: prettyprint

         val waterFilter: (Int) -> Int = { dirty -> dirty / 2 }

      Here's what the code says:

      -  Make a variable called ``waterFilter``.
      -  ``waterFilter`` can be any function that takes an ``Int`` and returns an ``Int``.
      -  Assign a lambda to ``waterFilter``.
      -  The lambda returns the value of the argument ``dirty`` divided by 2.

      Note that you don't have to specify the type of the lambda argument anymore. The type is
      calculated by type inference.


Step 2: Create a higher-order function

   So far, the examples for lambdas look mostly like functions. The real power of lambdas
   is using them to create higher-order functions, where the argument to one function is
   another function.

   1. Write a higher-order function. Here's a basic example, a function that takes two
      arguments. The first argument is an integer. The second argument is a function that
      takes an integer and returns an integer. Try it out in the REPL.

      .. code:: prettyprint

         fun updateDirty(dirty: Int, operation: (Int) -> Int): Int {
            return operation(dirty)
         }

      The body of the code calls the function that was passed as the second argument, and
      passes the first argument along to it.

   2. To call this function, pass it an integer and a function.

      .. code:: prettyprint

         val waterFilter: (Int) -> Int = { dirty -> dirty / 2 }
         println(updateDirty(30, waterFilter))

      ::

         â‡’ 15

      The function you pass doesn't have to be a lambda; it can be a regular named function
      instead. To specify the argument as a regular function, use the ``::`` operator. This
      way Kotlin knows that you are passing the `function reference` as an argument, not trying
      to call the function.

   3. Try passing a regular named function to ``updateDirty()``.

      .. code:: prettyprint

         fun increaseDirty( start: Int ) = start + 1

         println(updateDirty(15, ::increaseDirty))

      ::

         â‡’ 16

      **Note:** Kotlin prefers that any parameter that takes a function is the last parameter.
      When working with higher-order functions, Kotlin has a special syntax, called the 
      `last parameter call syntax <https://kotlinlang.org/docs/reference/lambdas.html#passing-a-lambda-to-the-last-parameter>`__,
      which lets you make the code even more concise. In this case, you can pass a lambda for
      the function parameter, but you don't need to put the lambda inside the parentheses.

      .. code:: prettyprint

         var dirtyLevel = 19;
         dirtyLevel = updateDirty(dirtyLevel) { dirtyLevel -> dirtyLevel + 23}
         println(dirtyLevel)

      ::

         â‡’ 42


8. Summary
--------------------------------------------------------------------------------

   -  To create a Kotlin source file in IntelliJ IDEA, start with a Kotlin project.

   -  To compile and run a program in IntelliJ IDEA, click the green triangle next to the
      ``main()`` function. Output appears in a log window below.

   -  In IntelliJ IDEA, specify command line arguments to pass to the ``main()`` function
      in **Run > Edit Configurations**.

   -  Almost everything in Kotlin has a value. You can use this fact to make your code more
      concise by using the value of an ``if`` or ``when`` as an expression or return value.

   -  Default arguments remove the need for multiple versions of a function or method. For
      example: ``fun swim(speed: String = "fast") { ... }``

   -  Compact functions, or single-expression functions, can make your code more readable.
      For example: ``fun isTooHot(temperature: Int) = temperature > 30``

   -  You've learned some basics about filters, which use lambda expressions. For example:
      ``val beginsWithP = decorations.filter { it [0] == 'p' }``

   -  A `lambda expression` is an expression that makes an unnamed function. Lambda
      expressions are defined between curly braces ``{}``.

   -  In a `higher-order function`, you pass a function such as a lambda expression to
      another function as data. For example:
      ``dirtyLevel = updateDirty(dirtyLevel) { dirtyLevel -> dirtyLevel + 23}``

   There's a lot in this lesson, especially if you're new to lambdas. A later lesson
   revisits lambdas and higher-order functions.

   **Note:** You may have noticed that in Kotlin, as in some other languages, there is more
   than one correct way to do things. Making code more compact sometimes helps readability
   and even performance, and sometimes it doesn't. As you learn more about Kotlin, you may
   find easier, more concise ways to do things.


9. Learn more
--------------------------------------------------------------------------------


Kotlin documentation

   If you want more information on any topic in this course, or if you get stuck,
   `https://kotlinlang.org <https://kotlinlang.org/>`__ is your best starting point.

   -  `Kotlin coding conventions <https://kotlinlang.org/docs/reference/coding-conventions.html>`__
   -  `Kotlin idioms <https://kotlinlang.org/docs/reference/idioms.html>`__
   -  `String templates <https://kotlinlang.org/docs/reference/basic-types.html#string-templates>`__
   -  `when expression <https://kotlinlang.org/docs/reference/control-flow.html#when-expression>`__
   -  `Single-expression functions <https://kotlinlang.org/docs/reference/idioms.html#single-expression-functions>`__
   -  `Higher-order functions and lambdas <https://kotlinlang.org/docs/reference/lambdas.html>`__
   -  `Filters <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/filter.html>`__
   -  `Sequences <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html>`__
   -  `Last parameter call syntax <https://kotlinlang.org/docs/reference/lambdas.html#passing-a-lambda-to-the-last-parameter>`__


Kotlin tutorials

   The https://play.kotlinlang.org website includes rich tutorials called Kotlin Koans, a
   `web-based interpreter <https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt>`__,
   and a complete set of reference documentation with examples.


Udacity course

   To view the Udacity course on this topic, see 
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__.


IntelliJ IDEA

   `Documentation for the IntelliJ IDEA <https://www.jetbrains.com/help/idea/>`__ can be
   found on the JetBrains website.


10. Homework
--------------------------------------------------------------------------------

   This section lists possible homework assignments for students who are working through
   this codelab as part of a course led by an instructor. It's up to the instructor to do
   the following:

   -  Assign homework if required.
   -  Communicate to students how to submit homework assignments.
   -  Grade the homework assignments.

   Instructors can use these suggestions as little or as much as they want, and should feel
   free to assign any other homework they feel is appropriate.

   If you're working through this codelab on your own, feel free to use these homework
   assignments to test your knowledge.


**Answer these questions**


**Question 1**

   The ``contains(element: String)`` function returns ``true`` if the string ``element`` is
   contained in the string it's called on. What will be the output of the following code?

   .. code:: kotlin

      val decorations = listOf ("rock", "pagoda", "plastic plant", "alligator", "flowerpot")

      println(decorations.filter {it.contains('p')})

   *  â–¢ ``[pagoda, plastic, plant]``
   *  â–¢ ``[pagoda, plastic plant]``
   *  â–¢ ``[pagoda, plastic plant, flowerpot]``
   *  â–¢ ``[rock, alligator]``


**Question 2**

   In the following function definition, which one of the parameters is required?
   ``fun shouldChangeWater (day: String, temperature: Int = 22, dirty: Int = 20, numDecorations: Int = 0): Boolean {...}``

   *  â–¢ ``numDecorations``
   *  â–¢ ``dirty``
   *  â–¢ ``day``
   *  â–¢ ``temperature``


**Question 3**

   You can pass a regular named function (not the result of calling it) to another
   function. How would you pass ``increaseDirty( start: Int ) = start + 1`` to
   ``updateDirty(dirty: Int, operation: (Int) -> Int)``?

   *  â–¢ ``updateDirty(15, &increaseDirty())``
   *  â–¢ ``updateDirty(15, increaseDirty())``
   *  â–¢ ``updateDirty(15, ("increaseDirty()"))``
   *  â–¢ ``updateDirty(15, ::increaseDirty)``


11. Next codelab
--------------------------------------------------------------------------------

   Proceed to the next lesson: 
   `4. Classes and objects <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-classes/>`__

   For an overview of the course, including links to other codelabs, see 
   `"Kotlin Bootcamp for Programmers: Welcome to the course." <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-welcome/>`__


â­ Kotlin Bootcamp 4: Object-oriented programming
==================================================

   pandoc --column=100 -trst -rhtml https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-classes/


1. Welcome
--------------------------------------------------------------------------------

   This codelab is part of the 
   `Kotlin Bootcamp for Programmers course <https://developer.android.google.cn/courses/kotlin-bootcamp/overview>`__. 
   You'll get the most value out of this course if you work through the codelabs in sequence.
   Depending on your knowledge, you may be able to skim some sections. This course is
   geared towards programmers who know an object-oriented language, and want to learn
   `Kotlin <https://kotlinlang.org/>`__.


Introduction

   In this codelab, you create a Kotlin program and learn about classes and objects in
   Kotlin. Much of this content will be familiar to you if you know another object-oriented
   language, but Kotlin has some important differences to reduce the amount of code you
   need to write. You also learn about abstract classes and interface delegation.

   Rather than build a single sample app, the lessons in this course are designed to build
   your knowledge, but be semi-independent of each other so you can skim sections you're
   familiar with. To tie them together, many of the examples use an aquarium theme. And if
   you want to see the full aquarium story, check out the 
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__ Udacity course.


What you should already know

   -  The basics of Kotlin, including types, operators, and looping
   -  Kotlin's function syntax
   -  The basics of object-oriented programming
   -  The basics of an IDE such as IntelliJ IDEA or Android Studio


What you'll learn

   -  How to create classes and access properties in Kotlin
   -  How to create and use class constructors in Kotlin
   -  How to create a subclass, and how inheritance works
   -  About abstract classes, interfaces, and interface delegation
   -  How to create and use data classes
   -  How to use singletons, enums, and sealed classes


What you'll do

   -  Create a class with properties
   -  Create a constructor for a class
   -  Create a subclass
   -  Examine examples of abstract classes and interfaces
   -  Create a simple data class
   -  Learn about singletons, enums, and sealed classes


2. Terminology
--------------------------------------------------------------------------------

   The following programming terms should already be familiar to you:

   -  `Classes` are blueprints for objects. For example, an ``Aquarium`` class is the
      blueprint for making an aquarium object.

   -  `Objects` are instances of classes; an aquarium object is one actual ``Aquarium``.

   -  `Properties` are characteristics of classes, such as the length, width, and height of
      an ``Aquarium``.

   -  `Methods`, also called `member functions`, are the functionality of the class.
      Methods are what you can "do" with the object. For example, you can
      ``fillWithWater()`` an ``Aquarium`` object.

   -  An `interface` is a specification that a class can implement. For example, cleaning
      is common to objects other than aquariums, and cleaning generally happens in similar
      ways for different objects. So you could have an interface called ``Clean`` that
      defines a ``clean()`` method. The ``Aquarium`` class could implement the ``Clean``
      interface to clean the aquarium with a soft sponge.

   -  `Packages` are a way to group related code to keep it organized, or to make a library
      of code. Once a package is created, you can import the package's contents into
      another file and reuse the code and classes in it.


3. Task: Create a class
--------------------------------------------------------------------------------

   In this task, you create a new package and a class with some properties and a method.


Step 1: Create a package

   Packages can help you keep your code organized.

   1. In the **Project** pane, under the **Hello Kotlin** project, right-click on the
      **src** folder.

   2. Select **New > Package** and call it ``example.myapp``.


Step 2: Create a class with properties

   Classes are defined with the keyword ``class``, and class names by convention start with
   a capital letter.

   1. Right-click on the **example.myapp** package.

   2. Select **New > Kotlin File / Class**.

   3. Under **Kind**, select **Class**, and name the class **``Aquarium``**. IntelliJ IDEA
      includes the package name in the file and creates an empty ``Aquarium`` class for you.

   4. Inside the ``Aquarium`` class, define and initialize ``var`` properties for the
      width, height, and length (in centimeters). Initialize the properties with default
      values.

   .. code:: prettyprint

      package example.myapp

      class Aquarium {
          var width: Int = 20
          var height: Int = 40
          var length: Int = 100
      }

   Under the hood, Kotlin automatically creates getters and setters for the properties you
   defined in the ``Aquarium`` class, so you can access the properties directly, for
   example, ``myAquarium.length``.

   **Note:** If you declared these properties with ``val`` instead of ``var``, the
   properties would be ``immutable``. You could only set them once, and all the instances of
   ``Aquarium`` would have the same dimensions.

   Also note that IntelliJ IDEA underlines the name of each ``var`` in your code, but not
   each ``val``. Kotlin coding style 
   `prefers immutable data <https://kotlinlang.org/docs/reference/coding-conventions.html#immutability>`__
   when possible, so IntelliJ IDEA draws your attention to mutable data so you can minimize
   its use.


Step 3: Create a main() function

   Create a new file called ``main.kt`` to hold the ``main()`` function.

   1. In the **Project** pane on the left, right-click on the **example.myapp** package.

   2. Select **New > Kotlin File / Class**.

   3. Under the **Kind** dropdown, keep the selection as **File**, and name the file
      ``main.kt``. IntelliJ IDEA includes the package name, but doesn't include a class
      definition for a file.

   4. Define a ``buildAquarium()`` function and inside create an instance of ``Aquarium``.
      To create an instance, reference the class as if it were a function, ``Aquarium()``.
      This calls the constructor of the class and creates an instance of the ``Aquarium``
      class, similar to using ``new`` in other languages.

   5. Define a ``main()`` function and call ``buildAquarium()``.

   .. code:: prettyprint

      package example.myapp

      fun buildAquarium() {
          val myAquarium = Aquarium()
      }

      fun main() {
          buildAquarium()
      }


Step 4: Add a method

   1. In the ``Aquarium`` class, add a method to print the aquarium's dimension properties.

      .. code:: prettyprint

          fun printSize() {
              println("Width: $width cm " +
                      "Length: $length cm " +
                      "Height: $height cm ")
          }

   2. In ``main.kt``, in ``buildAquarium()``, call the ``printSize()`` method on
      ``myAquarium``.

      .. code:: prettyprint

         fun buildAquarium() {
            val myAquarium = Aquarium()
            myAquarium.printSize()
         }

   3. Run your program by clicking the green triangle next to the ``main()`` function.
      Observe the result.

      ::

         â‡’ Width: 20 cm Length: 100 cm Height: 40 cm 

   4. In ``buildAquarium()``, add code to set the height to 60 and print the changed
      dimension properties.

      .. code:: prettyprint

         fun buildAquarium() {
            val myAquarium = Aquarium()
            myAquarium.printSize()
            myAquarium.height = 60
            myAquarium.printSize()
         }

   5. Run your program and observe the output.

      ::

         â‡’ Width: 20 cm Length: 100 cm Height: 40 cm 
         Width: 20 cm Length: 100 cm Height: 60 cm 


4. Task: Add class constructors
--------------------------------------------------------------------------------

   In this task, you create the ``primary constructor`` for the class, and continue 
   working with properties.


Step 1: Create a constructor

   In this step, you add a constructor to the ``Aquarium`` class you created in the first
   task. In the earlier example, every instance of ``Aquarium`` is created with the same
   dimensions. You can change the dimensions once it is created by setting the properties,
   but it would be simpler to create it the correct size to begin with.

   In some programming languages, the constructor is defined by creating a method within
   the class that has the same name as the class. In Kotlin, you define the constructor
   directly in the class declaration itself, specifying the parameters inside parentheses
   as if the class was a method. As with functions in Kotlin, those parameters can include
   default values.

   1. In the ``Aquarium`` class you created earlier, change the class definition to include
      three constructor parameters with default values for ``length``, ``width`` and
      ``height``, and assign them to the corresponding properties.

      .. code:: prettyprint

         class Aquarium(length: Int = 100, width: Int = 20, height: Int = 40) {
            // Dimensions in cm
            var length: Int = length
            var width: Int = width
            var height: Int = height
            ...
         }

   2. The more compact Kotlin way is to define the properties directly with the
      constructor, using ``var`` or ``val``, and Kotlin also creates the getters and
      setters automatically. Then you can remove the property definitions in the body of
      the class.

      .. code:: prettyprint

         class Aquarium(var length: Int = 100, var width: Int = 20, var height: Int = 40) {
         ...
         }

   3. When you create an ``Aquarium`` object with that constructor, you can specify no
      arguments and get the default values, or specify just some of them, or specify all of
      them and create a completely custom-sized ``Aquarium``. In the ``buildAquarium()``
      function, try out different ways of creating an ``Aquarium`` object using named
      parameters.

      .. code:: prettyprint

         fun buildAquarium() {
            val aquarium1 = Aquarium()
            aquarium1.printSize()
            // default height and length
            val aquarium2 = Aquarium(width = 25)
            aquarium2.printSize()
            // default width
            val aquarium3 = Aquarium(height = 35, length = 110)
            aquarium3.printSize()
            // everything custom
            val aquarium4 = Aquarium(width = 25, height = 35, length = 110)
            aquarium4.printSize()
         }

   4. Run the program and observe the output.

      ::

         â‡’ Width: 20 cm Length: 100 cm Height: 40 cm 
         Width: 25 cm Length: 100 cm Height: 40 cm 
         Width: 20 cm Length: 110 cm Height: 35 cm 
         Width: 25 cm Length: 110 cm Height: 35 cm 

   Notice that you didn't have to overload the constructor and write a different version
   for each of these cases (plus a few more for the other combinations). Kotlin creates
   what is needed from the default values and named parameters.


Step 2: Add init blocks

   The example constructors above just declare properties and assign the value of an
   expression to them. If your constructor needs more initialization code, it can be placed
   in one or more ``init`` blocks. In this step, you add some ``init`` blocks to
   ``Aquarium`` class.

   1. In the ``Aquarium`` class, add an ``init`` block to print that the object is
      initializing, and a second block to print the volume in liters.

      .. code:: prettyprint

         class Aquarium (var length: Int = 100, var width: Int = 20, var height: Int = 40) {
            init {
               println("aquarium initializing")
            }
            init {
               // 1 liter = 1000 cm^3
               println("Volume: ${width * length * height / 1000} l")
            }
         }

   2. Run the program and observe the output.

      .. code:: prettyprint

         aquarium initializing
         Volume: 80 l
         Width: 20 cm Length: 100 cm Height: 40 cm 
         aquarium initializing
         Volume: 100 l
         Width: 25 cm Length: 100 cm Height: 40 cm 
         aquarium initializing
         Volume: 77 l
         Width: 20 cm Length: 110 cm Height: 35 cm 
         aquarium initializing
         Volume: 96 l
         Width: 25 cm Length: 110 cm Height: 35 cm 

   Notice that the ``init`` blocks are executed in the order in which they appear in the
   class definition, and all of them are executed when the constructor is called.

   **Note:** Parameters of the ``primary constructor`` can be used in the initializer blocks.
   Any properties used in initializer blocks must be declared previously.


Step 3: Learn about secondary constructors

   In this step, you learn about ``secondary constructors`` and add one to your class. In
   addition to a ``primary constructor``, which can have one or more ``init`` blocks, a Kotlin
   class can also have one or more secondary constructors to allow constructor overloading,
   that is, constructors with different arguments.

   **Note:** Kotlin coding style says each class should have only one constructor, using
   default values and named parameters. This is because using multiple constructors leads
   to more code paths, and the likelihood that one or more paths will go untested. Before
   writing a secondary constructor, consider whether a 
   `factory function <https://kotlinlang.org/docs/reference/coding-conventions.html#factory-functions>`__
   would work instead, to keep the class definition clean.

   **Note:** Every secondary constructor must call the primary constructor first, either
   directly using ``this()``, or indirectly by calling another secondary constructor. This
   means that any ``init`` blocks in the primary will be called for all constructors, and
   all the code in the primary constructor will be executed first.

   1. In the ``Aquarium`` class, add a secondary constructor that takes a number of fish as
      its argument, using the ``constructor`` keyword. Create a ``val`` tank property for
      the calculated volume of the aquarium in liters based on the number of fish. Assume 2
      liters (2,000 cm^3) of water per fish, plus a little extra room so the water doesn't
      spill.

      .. code:: prettyprint

         constructor(numberOfFish: Int) : this() {
            // 2,000 cm^3 per fish + extra room so water doesn't spill
            val tank = numberOfFish * 2000 * 1.1
         }

   2. Inside the secondary constructor, keep the length and width (which were set in the
      primary constructor) the same, and calculate the height needed to make the tank the
      given volume.

      .. code:: prettyprint

            // calculate the height needed
            height = (tank / (length * width)).toInt()

   3. In the ``buildAquarium()`` function, add a call to create an ``Aquarium`` using your
      new secondary constructor. Print the size and volume.

      .. code:: prettyprint

         fun buildAquarium() {
            val aquarium6 = Aquarium(numberOfFish = 29)
            aquarium6.printSize()
            println("Volume: ${aquarium6.width * aquarium6.length * aquarium6.height / 1000} l")
         }

   4. Run your program and observe the output.

      ::

         â‡’ aquarium initializing
         Volume: 80 l
         Width: 20 cm Length: 100 cm Height: 31 cm 
         Volume: 62 l

   Notice that the volume is printed twice, once by the ``init`` block in the primary
   constructor before the secondary constructor is executed, and once by the code in
   ``buildAquarium()``.

   You could have included the ``constructor`` keyword in the primary constructor, too, but
   it's not necessary in most cases.


Step 4: Add a new property getter

   In this step, you add an explicit property getter. Kotlin automatically defines getters
   and setters when you define properties, but sometimes the value for a property needs to
   be adjusted or calculated. For example, above, you printed the volume of the
   ``Aquarium``. You can make the volume available as a property by defining a variable and
   a getter for it. Because ``volume`` needs to be calculated, the getter needs to return
   the calculated value, which you can do with a one-line function.

   1. In the ``Aquarium`` class, define an ``Int`` property called ``volume``, and define a
      ``get()`` method that calculates the volume in the next line.

      .. code:: prettyprint

         val volume: Int
            get() = width * height * length / 1000  // 1000 cm^3 = 1 l

   2. Remove the ``init`` block that prints the volume.

   3. Remove the code in ``buildAquarium()`` that prints the volume.

   4. In the ``printSize()`` method, add a line to print the volume.

      .. code:: prettyprint

         fun printSize() {
            println("Width: $width cm " +
                     "Length: $length cm " +
                     "Height: $height cm "
            )
            // 1 l = 1000 cm^3
            println("Volume: $volume l")
         }

   5. Run your program and observe the output.

      ::

         â‡’ aquarium initializing
         Width: 20 cm Length: 100 cm Height: 31 cm 
         Volume: 62 l

   The dimensions and volume are the same as before, but the volume is only printed once
   after the object is fully initialized by both the primary constructor and the secondary
   constructor.


Step 5: Add a property setter

   In this step, you create a new property setter for the volume.

   1. In the ``Aquarium`` class, change ``volume`` to a ``var`` so it can be set more than
      once.

   2. Add a setter for the ``volume`` property by adding a ``set()`` method below the
      getter, which recalculates the height based on the supplied amount of water. By
      convention, the name of the setter parameter is ``value``, but you can change it if
      you prefer.

      .. code:: prettyprint

         var volume: Int
            get() = width * height * length / 1000
            set(value) {
               height = (value * 1000) / (width * length)
            }

   3. In ``buildAquarium()``, add code to set the volume of the Aquarium to 70 liters.
      Print the new size.

      .. code:: prettyprint

         fun buildAquarium() {
            val aquarium6 = Aquarium(numberOfFish = 29)
            aquarium6.printSize()
            aquarium6.volume = 70
            aquarium6.printSize()
         }

   4. Run your program again and observe the changed height and volume.

      .. code:: prettyprint

         â‡’ aquarium initialized
         Width: 20 cm Length: 100 cm Height: 31 cm 
         Volume: 62 l
         Width: 20 cm Length: 100 cm Height: 35 cm 
         Volume: 70 l


5. Concept: Learn about visibility modifiers
--------------------------------------------------------------------------------

   There have been no visibility modifiers, such as ``public`` or ``private``, in the code
   so far. That's because by default, everything in Kotlin is public, which means that
   everything can be accessed everywhere, including classes, methods, properties, and
   member variables.

   In Kotlin, classes, objects, interfaces, constructors, functions, properties, and their
   setters can have *visibility modifiers*:

   -  ``public`` means visible outside the class. Everything is public by default,
      including variables and methods of the class.

   -  ``internal`` means it will only be visible within that module. A
      `module <https://kotlinlang.org/docs/reference/visibility-modifiers.html#modules>`__
      is a set of Kotlin files compiled together, for example, a library or application.

   -  ``private`` means it will only be visible in that class (or source file if you are
      working with functions).

   -  ``protected`` is the same as ``private``, but it will also be visible to any
      subclasses.

   See `Visibility
   Modifiers <https://kotlinlang.org/docs/reference/visibility-modifiers.html>`__ in the
   Kotlin documentation for more information.


Member variables

   Properties within a class, or member variables, are ``public`` by default. If you define
   them with ``var``, they are mutable, that is, readable and writable. If you define them
   with ``val``, they are read-only after initialization.

   If you want a property that your code can read or write, but outside code can only read,
   you can leave the property and its getter as public and declare the setter private, as
   shown below.

   .. code:: prettyprint

      var volume: Int
          get() = width * height * length / 1000
          private set(value) {
              height = (value * 1000) / (width * length)
          }


6. Task: Learn about subclasses and inheritance
--------------------------------------------------------------------------------

   In this task, you learn how subclasses and inheritance work in Kotlin. They are similar
   to what you've seen in other languages, but there are some differences.

   In Kotlin, by default, classes cannot be subclassed. Similarly, properties and member
   variables cannot be overridden by subclasses (though they can be accessed).

   You must mark a class as ``open`` to allow it to be subclassed. Similarly, you must mark
   properties and member variables as ``open``, in order to override them in the subclass.
   The ``open`` keyword is required, to prevent accidentally leaking implementation details
   as part of the class's interface.


Step 1: Make the Aquarium class open

   In this step, you make the ``Aquarium`` class ``open``, so that you can override it in
   the next step.

   1. Mark the ``Aquarium`` class and all its properties with the ``open`` keyword.

      .. code:: prettyprint

         open class Aquarium (open var length: Int = 100, open var width: Int = 20, open var height: Int = 40) {
            open var volume: Int
               get() = width * height * length / 1000
               set(value) {
                     height = (value * 1000) / (width * length)
               }

   2. Add an open ``shape`` property with the value ``"rectangle"``.

      .. code:: prettyprint

            open val shape = "rectangle"

   3. Add an open ``water`` property with a getter that returns 90% of the volume of the
      ``Aquarium``.

      .. code:: prettyprint

            open var water: Double = 0.0
               get() = volume * 0.9

   4. Add code to the ``printSize()`` method to print the shape, and the amount of water as
      a percentage of the volume.

      .. code:: prettyprint

         fun printSize() {
            println(shape)
            println("Width: $width cm " +
                     "Length: $length cm " +
                     "Height: $height cm ")
            // 1 l = 1000 cm^3
            println("Volume: $volume l Water: $water l (${water/volume*100.0}% full)")
         }

   5. In ``buildAquarium()``, change the code to create an ``Aquarium`` with
      ``width = 25``, ``length = 25``, and ``height = 40``.

      .. code:: prettyprint

         fun buildAquarium() {
            val aquarium6 = Aquarium(length = 25, width = 25, height = 40)
            aquarium6.printSize()
         }

   6. Run your program and observe the new output.

      ::

         â‡’ aquarium initializing
         rectangle
         Width: 25 cm Length: 25 cm Height: 40 cm 
         Volume: 25 l Water: 22.5 l (90.0% full)


Step 2: Create a subclass

   1. Create a subclass of ``Aquarium`` called ``TowerTank``, which implements a rounded
      cylinder tank instead of a rectangular tank. You can add ``TowerTank`` below
      ``Aquarium``, because you can add another class in the same file as the ``Aquarium``
      class.

   2. In ``TowerTank``, override the ``height`` property, which is defined in the
      constructor. To override a property, use the ``override`` keyword in the subclass.

      **Note:** Subclasses must declare their constructor parameters explicitly.

   3. Make the constructor for ``TowerTank`` take a ``diameter``. Use the ``diameter`` for
      both ``length`` and ``width`` when calling the constructor in the ``Aquarium``
      superclass.

      .. code:: prettyprint

         class TowerTank (override var height: Int, var diameter: Int): 
               Aquarium(height = height, width = diameter, length = diameter) {

   4. Override the volume property to calculate a cylinder. The formula for a cylinder is
      pi times the radius squared times the height. You need to import the constant ``PI``
      from ``java.lang.Math``.

      .. code:: prettyprint

            override var volume: Int
            // ellipse area = Ï€ * r1 * r2
            get() = (width/2 * length/2 * height / 1000 * PI).toInt()
            set(value) {
               height = ((value * 1000 / PI) / (width/2 * length/2)).toInt()
            }

   5. In ``TowerTank``, override the ``water`` property to be 80% of the volume.

      .. code:: prettyprint

         override var water = volume * 0.8

   6. Override the ``shape`` to be ``"cylinder"``.

      .. code:: prettyprint

         override val shape = "cylinder"

   7. Your final ``TowerTank`` class should look something like the code below.

      ``Aquarium.kt``:

      .. code:: prettyprint

         package example.myapp

         import java.lang.Math.PI

         ... // existing Aquarium class

         class TowerTank (override var height: Int, var diameter: Int): 
               Aquarium(height = height, width = diameter, length = diameter) {
            override var volume: Int
            // ellipse area = Ï€ * r1 * r2
            get() = (width/2 * length/2 * height / 1000 * PI).toInt()
            set(value) {
               height = ((value * 1000 / PI) / (width/2 * length/2)).toInt()
            }

            override var water = volume * 0.8
            override val shape = "cylinder"
         }

   8. In ``buildAquarium()``, create a ``TowerTank`` with a diameter of 25 cm and a height
      of 45 cm. Print the size.

      ``main.kt:``

      .. code:: prettyprint

         package example.myapp

         fun buildAquarium() {
            val myAquarium = Aquarium(width = 25, length = 25, height = 40)
            myAquarium.printSize()
            val myTower = TowerTank(diameter = 25, height = 40)
            myTower.printSize()
         }

   9. Run your program and observe the output.

      ::

         â‡’ aquarium initializing
         rectangle
         Width: 25 cm Length: 25 cm Height: 40 cm 
         Volume: 25 l Water: 22.5 l (90.0% full)
         aquarium initializing
         cylinder
         Width: 25 cm Length: 25 cm Height: 40 cm 
         Volume: 18 l Water: 14.4 l (80.0% full)


7. Task: Compare abstract classes and interfaces
--------------------------------------------------------------------------------

   Sometimes you want to define common behavior or properties to be shared among some
   related classes. Kotlin offers two ways to do that, interfaces and abstract classes. In
   this task, you create an abstract ``AquariumFish`` class for properties that are common
   to all fish. You create an interface called ``FishAction`` to define behavior common to
   all fish.

   -  Neither an abstract class nor an interface can be instantiated on its own, which
      means you cannot create objects of those types directly.
   -  Abstract classes have constructors.
   -  Interfaces can't have any constructor logic or store any state.

   **Note:** Abstract classes are always open; you don't need to mark them with ``open``.
   Properties and methods of an abstract class are non-abstract unless you explicitly mark
   them with the ``abstract`` keyword. That means subclasses can use them as given. If
   properties or methods are abstract, the subclasses must implement them.


Step 1. Create an abstract class

   1. Under **example.myapp**, create a new file, ``AquariumFish.kt``.

   2. Create a class, also called ``AquariumFish``, and mark it with ``abstract``.

   3. Add one ``String`` property, ``color``, and mark it with ``abstract``.

      .. code:: prettyprint

         package example.myapp

         abstract class AquariumFish {
            abstract val color: String
         }

      .. Tip::

         A class may be declared abstract, along with some or all of its members. 
         An abstract member does not have an implementation in its class. You 
         don't need to annotate abstract classes or functions with open.

   4. Create two subclasses of ``AquariumFish``, ``Shark`` and ``Plecostomus``.

   5. Because ``color`` is abstract, the subclasses must implement it. Make ``Shark`` gray
      and ``Plecostomus`` gold.

      .. code:: prettyprint

         class Shark: AquariumFish() {
            override val color = "gray"
         }

         class Plecostomus: AquariumFish() {
            override val color = "gold"
         }

   6. In **main.kt**, create a ``makeFish()`` function to test your classes. Instantiate a
      ``Shark`` and a ``Plecostomus``, then print the color of each.

   7. Delete your earlier test code in ``main()`` and add a call to ``makeFish()``. Your
      code should look something like the code below.

      ``main.kt``:

      .. code:: prettyprint

         package example.myapp

         fun makeFish() {
            val shark = Shark()
            val pleco = Plecostomus()

            println("Shark: ${shark.color}")
            println("Plecostomus: ${pleco.color}")
         }

         fun main () {
            makeFish()
         }

   8. Run your program and observe the output.

      ::

         â‡’ Shark: gray 
         Plecostomus: gold

      The following diagram represents the ``Shark`` class and ``Plecostomus`` class, which
      subclass the abstract class, ``AquariumFish``.

      .. figure:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-classes/img/209b37c55b04ddb7.png

         A diagram showing the abstract class, AquariumFish, and two subclasses, Shark and Plecostumus.


Step 2. Create an interface

   1. In **AquariumFish.kt**, create an interface called ``FishAction`` with a method
      ``eat()``.

      .. code:: prettyprint

         interface FishAction  {
            fun eat()
         }

   2. Add ``FishAction`` to each of the subclasses, and implement ``eat()`` by having it
      print what the fish does.

      .. code:: prettyprint

         class Shark: AquariumFish(), FishAction {
            override val color = "gray"
            override fun eat() {
               println("hunt and eat fish")
            }
         }

         class Plecostomus: AquariumFish(), FishAction {
            override val color = "gold"
            override fun eat() {
               println("eat algae")
            }
         }

   3. In the ``makeFish()`` function, have each fish you created eat something by calling
      ``eat()``.

      .. code:: prettyprint

         fun makeFish() {
            val shark = Shark()
            val pleco = Plecostomus()
            println("Shark: ${shark.color}")
            shark.eat()
            println("Plecostomus: ${pleco.color}")
            pleco.eat()
         }

   4. Run your program and observe the output.

      ::

         â‡’ Shark: gray
         hunt and eat fish
         Plecostomus: gold
         eat algae

      The following diagram represents the ``Shark`` class and the ``Plecostomus`` class, both
      of which are composed of and implement the ``FishAction`` interface.

      .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-classes/img/e4b747e0303bcdaa.png


When to use abstract classes versus interfaces

   The examples above are simple, but when you have a lot of interrelated classes, abstract
   classes and interfaces can help you keep your design cleaner, more organized, and easier
   to maintain.

   As noted above, abstract classes can have constructors, and interfaces cannot, but
   otherwise they are very similar. So, when should you use each?

   When you use interfaces to compose a class, the class's functionality is extended by way
   of the class instances that it contains. Composition tends to make code easier to reuse
   and reason about than inheritance from an abstract class. Also, you can use multiple
   interfaces in a class, but you can only subclass from one abstract class.

   **Note:** When designing programs in Kotlin, consider how you can effectively use
   composition to build up an application from small composable building blocks.

   Composition often leads to better
   `encapsulation <https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)>`__,
   lower `coupling <https://en.wikipedia.org/wiki/Coupling_(computer_programming)>`__
   (interdependence), cleaner interfaces, and more usable code. For these reasons, using
   composition with interfaces is the preferred design. On the other hand, inheritance from
   an abstract class tends to be a natural fit for some problems. So you should prefer
   composition, but when inheritance makes sense Kotlin lets you do that too!

   -  Use an interface if you have a lot of methods and one or two default implementations,
      for example as in ``AquariumAction`` below.

   .. code:: prettyprint

      interface AquariumAction {
          fun eat()
          fun jump()
          fun clean()
          fun catchFish()
          fun swim()  {
              println("swim")
          }
      }

   -  Use an abstract class any time you can't complete a class. For example, going back to
      the ``AquariumFish`` class, you can make all ``AquariumFish`` implement
      ``FishAction``, and provide a default implementation for ``eat`` while leaving
      ``color`` abstract, because there isn't really a default color for fish.

   .. code:: prettyprint

      interface FishAction  {
          fun eat()
      }

      abstract class AquariumFish: FishAction {
         abstract val color: String
         override fun eat() = println("yum")
      }


8. Task: Use interface delegation
--------------------------------------------------------------------------------

   The previous task introduced abstract classes, interfaces, and the idea of composition.
   `Interface delegation` is an advanced technique where the methods of an interface are
   implemented by a helper (or delegate) object, which is then used by a class. This
   technique can be useful when you use an interface in a series of unrelated classes: you
   add the needed interface functionality to a separate helper class, and each of the
   classes uses an instance of the helper class to implement the functionality.

   In this task, you use interface delegation to add functionality to a class.


Step 1: Make a new interface

   1. In **AquariumFish.kt**, remove the ``AquariumFish`` class. Instead of inheriting from
      the ``AquariumFish`` class, ``Plecostomus`` and ``Shark`` are going to implement
      interfaces for both the fish action and their color.

   2. Create a new interface, ``FishColor``, that defines the color as a string.

   .. code:: prettyprint

      interface FishColor {
          val color: String
      }

   3. Change ``Plecostomus`` to implement two interfaces, ``FishAction``, and a
      ``FishColor``. You need to override the ``color`` from ``FishColor`` and ``eat()``
      from ``FishAction``.

      .. code:: prettyprint

         class Plecostomus: FishAction, FishColor {
            override val color = "gold"
            override fun eat() {
               println("eat algae")
            }
         }

   4. Change your ``Shark`` class to also implement the two interfaces, ``FishAction`` and
      ``FishColor``, instead of inheriting from ``AquariumFish``.

      .. code:: prettyprint

         class Shark: FishAction, FishColor {
            override val color = "gray"
            override fun eat() {
               println("hunt and eat fish")
            }
         }

   5. Your finished code should look something like this:

      .. code:: prettyprint

         package example.myapp

         interface FishAction {
            fun eat()
         }

         interface FishColor {
            val color: String
         }

         class Plecostomus: FishAction, FishColor {
            override val color = "gold"
            override fun eat() {
               println("eat algae")
            }
         }

         class Shark: FishAction, FishColor {
            override val color = "gray"
            override fun eat() {
               println("hunt and eat fish")
            }
         }


Step 2: Make a singleton class

   Next, you implement the setup for the delegation part by creating a helper class that
   implements ``FishColor``. You create a basic class called ``GoldColor`` that implements
   ``FishColor``â€”all it does is say that its color is gold.

   It doesn't make sense to make multiple instances of ``GoldColor``, because they'd all do
   exactly the same thing. So Kotlin lets you declare a class where you can only create one
   instance of it by using the keyword ``object`` instead of ``class``. Kotlin will create
   that one instance, and that instance is referenced by the class name. Then all other
   objects can just use this one instanceâ€”there is no way to make other instances of this
   class. If you're familiar with the 
   `singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`__, 
   this is how you implement singletons in Kotlin.

   1. In **AquariumFish.kt**, create an object for ``GoldColor``. Override the color.

      .. code:: prettyprint

         object GoldColor : FishColor {
            override val color = "gold"
         }


Step 3: Add interface delegation for FishColor

   Now you're ready to use interface delegation.

   1. In **AquariumFish.kt**, remove the override of ``color`` from ``Plecostomus``.

   2. Change the ``Plecostomus`` class to get its color from ``GoldColor``. You do this by
      adding ``by GoldColor`` to the class declaration, creating the delegation. What this
      says is that instead of implementing ``FishColor``, use the implementation provided
      by ``GoldColor``. So every time ``color`` is accessed, it is delegated to
      ``GoldColor``.

      .. code:: prettyprint

         class Plecostomus:  FishAction, FishColor by GoldColor {
            override fun eat() {
               println("eat algae")
            }
         }

      With the class as is, all Plecos will be golden, but these fish actually come in many
      colors. You can address this by adding a constructor parameter for the color with
      ``GoldColor`` as the default color for ``Plecostomus``.

   3. Change the ``Plecostomus`` class to take a passed in ``fishColor`` with its
      constructor, and set its default to ``GoldColor``. Change the delegation from
      ``by GoldColor`` to ``by fishColor``.

      .. code:: prettyprint

         class Plecostomus(fishColor: FishColor = GoldColor):  FishAction,
               FishColor by fishColor {
            override fun eat() {
               println("eat algae")
            }
         }


Step 4: Add interface delegation for FishAction

   In the same way, you can use interface delegation for the ``FishAction``.

   1. In **AquariumFish.kt** make a ``PrintingFishAction`` class that implements
      ``FishAction``, which takes a ``String``, ``food``, then prints what the fish eats.

      .. code:: prettyprint

         class PrintingFishAction(val food: String) : FishAction {
            override fun eat() {
               println(food)
            }
         }

   2. In ``Plecostomus`` class, remove the override function ``eat()``, because you will
      replace it with a delegation.

   3. In the declaration of ``Plecostomus``, delegate ``FishAction`` to
      ``PrintingFishAction``, passing ``"eat algae"``.

   4. With all that delegation, there's no code in the body of the ``Plecostomus`` class,
      so remove the ``{}``, because all the overrides are handled by interface delegation

      .. code:: prettyprint

         class Plecostomus (fishColor: FishColor = GoldColor):
               FishAction by PrintingFishAction("eat algae"),
               FishColor by fishColor

   The following diagram represents the ``Shark`` and the ``Plecostomus`` classes, both
   composed of the ``PrintingFishAction`` and ``FishColor`` interfaces, but delegating the
   implementation to them.

   .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-classes/img/a7556eed5ec884a3.png

   Interface delegation is powerful, and you should generally consider how to use it
   whenever you might use an abstract class in another language. It lets you use
   composition to plug in behaviors, instead of requiring lots of subclasses, each
   specialized in a different way.


9. Task: Create a data class
--------------------------------------------------------------------------------

   A `data class` is similar to a ``struct`` in some other languagesâ€”it exists mainly to hold
   some dataâ€”but a data class object is still an object. Kotlin data class objects have
   some extra benefits, such as utilities for printing and copying. In this task, you
   create a simple data class and learn about the support Kotlin provides for data classes.


Step 1: Create a data class

   1. Add a new package ``decor`` under the **example.myapp** package to hold the new code.
      Right-click on **example.myapp** in the **Project** pane and select **File > New >
      Package**.

   2. In the package, create a new class called ``Decoration``.

      .. code:: prettyprint

         package example.myapp.decor

         class Decoration {
         }

   3. To make ``Decoration`` a data class, prefix the class declaration with the keyword
      ``data``.

   4. Add a ``String`` property called ``rocks`` to give the class some data.

      .. code:: prettyprint

         data class Decoration(val rocks: String) {
         }

   5. In the file, outside the class, add a ``makeDecorations()`` function to create and
      print an instance of a ``Decoration`` with ``"granite"``.

      .. code:: prettyprint

         fun makeDecorations() {
            val decoration1 = Decoration("granite")
            println(decoration1)
         }

   5. Add a ``main()`` function to call ``makeDecorations()``, and run your program. Notice
      the sensible output that is created because this is a data class.

      ::

         â‡’ Decoration(rocks=granite)

   6. In ``makeDecorations()``, instantiate two more ``Decoration`` objects that are both
      "slate" and print them.

      .. code:: prettyprint

         fun makeDecorations() {
            val decoration1 = Decoration("granite")
            println(decoration1)

            val decoration2 = Decoration("slate")
            println(decoration2)

            val decoration3 = Decoration("slate")
            println(decoration3)
         }

   7. In ``makeDecorations()``, add a print statement that prints the result of comparing
      ``decoration1`` with ``decoration2``, and a second one comparing ``decoration3`` with
      ``decoration2``. Use the equals() method that is provided by data classes.

      .. code:: prettyprint

            println (decoration1.equals(decoration2))
            println (decoration3.equals(decoration2))

   8. Run your code.

      ::

         â‡’ Decoration(rocks=granite)
         Decoration(rocks=slate)
         Decoration(rocks=slate)
         false
         true

   **Note:** You could have used ``==`` to check whether ``d1 == d2`` and ``d3 == d2``. In
   Kotlin, using ``==`` on data class objects is the same as using ``equals()`` (structural
   equality). If you need to check whether two variables refer to the same object
   (referential equality), use the ``===`` operator. Read more about 
   `equality in Kotlin <https://kotlinlang.org/docs/reference/equality.html>`__ 
   in the language documentation.

   **Note:** Although they are similar to structs in some languages, remember that data
   class objects are objects. Assigning a data class object to another variable copies the
   reference to that object, not the contents. To copy the contents to a new object, use
   the ``copy()`` method.

   **Warning:** The ``copy()``, ``equals()``, and other data class utilities only reference
   properties defined in the primary constructor.


Step 2. Use destructuring

   To get at the properties of a data object and assign them to variables, you could assign
   them one at a time, like this.

   .. code:: prettyprint

      val rock = decoration.rock
      val wood = decoration.wood
      val diver = decoration.diver

   Instead, you can make variables, one for each property, and assign the data object to
   the group of variables. Kotlin puts the property value in each variable.

   .. code:: prettyprint

      val (rock, wood, diver) = decoration

   This is called
   `destructuring <https://kotlinlang.org/docs/reference/multi-declarations.html#destructuring-declarations>`__
   and is a useful shorthand. The number of variables should match the number of
   properties, and the variables are assigned in the order in which they are declared in
   the class. Here is a complete example you can try in **Decoration.kt**.

   .. code:: prettyprint

      // Here is a data class with 3 properties.
      data class Decoration2(val rocks: String, val wood: String, val diver: String){
      }

      fun makeDecorations() {
          val d5 = Decoration2("crystal", "wood", "diver")
          println(d5)

      // Assign all properties to variables.
          val (rock, wood, diver) = d5
          println(rock)
          println(wood)
          println(diver)
      }

   ::

      â‡’ Decoration2(rocks=crystal, wood=wood, diver=diver)
      crystal
      wood
      diver

   If you don't need one or more of the properties, you can skip them by using ``_``
   instead of a variable name, as shown in the code below.

   .. code:: prettyprint

          val (rock, _, diver) = d5


10. Task: Learn about singletons, enums, and sealed classes
--------------------------------------------------------------------------------

   In this task, you learn about some of the special-purpose classes in Kotlin, including
   the following:

   -  Singleton classes
   -  Enums
   -  Sealed classes


Step 1: Recall singleton classes

   Recall the earlier example with the ``GoldColor`` class.

   .. code:: prettyprint

      object GoldColor : FishColor {
         override val color = "gold"
      }

   Because every instance of ``GoldColor`` does the same thing, it is declared as an
   ``object`` instead of as a ``class`` to make it a singleton. There can be only one
   instance of it.


Step 2: Create an enum

   Kotlin also supports enums, which allow you to enumerate something and refer to it by
   name, much like in other languages. Declare an enum by prefixing the declaration with
   the keyword ``enum``. A basic enum declaration only needs a list of names, but you can
   also define one or more fields associated with each name.

   1. In **Decoration.kt**, try out an example of an enum.

      .. code:: prettyprint

         enum class Color(val rgb: Int) {
            RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF);
         }

      Enums are a bit like singletonsâ€”there can be only one, and only one of each value in the
      enumeration. For example, there can only be one ``Color.RED``, one ``Color.GREEN``, and
      one ``Color.BLUE``. In this example, the RGB values are assigned to the ``rgb`` property
      to represent the color components. You can also get the ordinal value of an enum using
      the ``ordinal`` property, and its name using the ``name`` property.

   2. Try out another example of an enum.

      .. code:: prettyprint

         enum class Direction(val degrees: Int) {
            NORTH(0), SOUTH(180), EAST(90), WEST(270)
         }

         fun main() {
            println(Direction.EAST.name)
            println(Direction.EAST.ordinal)
            println(Direction.EAST.degrees)
         }

      ::

         â‡’ EAST
         2
         90


Step 3: Create a sealed class

   A `sealed class` is a class that can be subclassed, but only inside the file in which
   it's declared. If you try to subclass the class in a different file, you get an error.

   Because the classes and subclasses are in the same file, Kotlin will know all the
   subclasses statically. That is, at compile time, the compiler sees all the classes and
   subclasses and knows that this is all of them, so the compiler can do extra checks for
   you.

   In **AquariumFish.kt**, try out an example of a sealed class, keeping with the
   aquatic theme.

   .. code:: prettyprint

      sealed class Seal
      class SeaLion : Seal()
      class Walrus : Seal()

      fun matchSeal(seal: Seal): String {
         return when(seal) {
             is Walrus -> "walrus"
             is SeaLion -> "sea lion"
         }
      }

   The ``Seal`` class can't be subclassed in another file. If you want to add more ``Seal``
   types, you have to add them in the same file. This makes sealed classes a safe way to
   represent a fixed number of types. For example, sealed classes are great for 
   `returning success or error from a network API <https://articles.caster.io/android/handling-optional-errors-using-kotlin-sealed-classes/>`__.


11. Summary
--------------------------------------------------------------------------------

   This lesson covered a lot of ground. While much of it should be familiar from other
   object-oriented programming languages, Kotlin adds some features to keep code concise
   and readable.


Classes and constructors

   -  Define a class in Kotlin using ``class``.
   -  Kotlin automatically creates setters and getters for properties.
   -  Define the primary constructor directly in the class definition. For example:
      ``class Aquarium(var length: Int = 100, var width: Int = 20, var height: Int = 40)``
   -  If a primary constructor needs additional code, write it in one or more ``init``
      blocks.
   -  A class can define one or more secondary constructors using ``constructor``, but
      Kotlin style is to use a factory function instead.


Visibility modifiers and subclasses

   -  All classes and functions in Kotlin are ``public`` by default, but you can use
      modifiers to change the visibility to ``internal``, ``private``, or ``protected``.
   -  To make a subclass, the parent class must be marked ``open``.
   -  To override methods and properties in a subclass, the methods and properties must be
      marked ``open`` in the parent class.
   -  A sealed class can be subclassed only in the same file where it is defined. Make a
      sealed class by prefixing the declaration with ``sealed``.


Data classes, singletons, and enums

   -  Make a data class by prefixing the declaration with ``data``.
   -  *Destructuring* is a shorthand for assigning the properties of a ``data`` object to
      separate variables.
   -  Make a singleton class by using ``object`` instead of ``class``.
   -  Define an enum using ``enum class``.


Abstract classes, interfaces, and delegation

   -  Abstract classes and interfaces are two ways to share common behavior between
      classes.
   -  An *abstract class* defines properties and behavior, but leaves the implementation to
      subclasses.
   -  An *interface* defines behavior, and may provide default implementations for some or
      all of the behavior.
   -  When you use interfaces to compose a class, the class's functionality is extended by
      way of the class instances that it contains.
   -  Interface delegation uses composition, but also delegates the implementation to the
      interface classes.
   -  Composition is a powerful way to add functionality to a class using interface
      delegation. In general composition is preferred, but inheritance from an abstract
      class is a better fit for some problems.


12. Learn more
--------------------------------------------------------------------------------


Kotlin documentation

   If you want more information on any topic in this course, or if you get stuck,
   `https://kotlinlang.org <https://kotlinlang.org/>`__ is your best starting point.

   -  `Kotlin coding conventions <https://kotlinlang.org/docs/reference/coding-conventions.html>`__
   -  `Kotlin idioms <https://kotlinlang.org/docs/reference/idioms.html>`__
   -  `Classes and inheritance <https://kotlinlang.org/docs/reference/classes.html>`__
   -  `Constructors <https://kotlinlang.org/docs/reference/classes.html#constructors>`__
   -  `Factory functions <https://kotlinlang.org/docs/reference/coding-conventions.html#factory-functions>`__
   -  `Properties and fields <https://kotlinlang.org/docs/reference/properties.html>`__
   -  `Visibility modifiers <https://kotlinlang.org/docs/reference/visibility-modifiers.html>`__
   -  `Abstract classes <https://kotlinlang.org/docs/reference/classes.html#abstract-classes>`__
   -  `Interfaces <https://kotlinlang.org/docs/reference/interfaces.html>`__
   -  `Delegation <https://kotlinlang.org/docs/reference/delegation.html>`__
   -  `Data classes <https://kotlinlang.org/docs/reference/data-classes.html>`__
   -  `Equality <https://kotlinlang.org/docs/reference/equality.html>`__
   -  `Destructuring <https://kotlinlang.org/docs/reference/multi-declarations.html#destructuring-declarations>`__
   -  `Object declarations <https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations>`__
   -  `Enum classes <https://kotlinlang.org/docs/reference/enum-classes.html>`__
   -  `Sealed classes <https://kotlinlang.org/docs/reference/sealed-classes.html>`__
   -  `Handling Optional Errors Using Kotlin Sealed Classes <https://articles.caster.io/android/handling-optional-errors-using-kotlin-sealed-classes/>`__


Kotlin tutorials

   The https://play.kotlinlang.org website includes rich tutorials called Kotlin Koans, a
   `web-based interpreter <https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt>`__,
   and a complete set of reference documentation with examples.


Udacity course

   To view the Udacity course on this topic, see 
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__.


IntelliJ IDEA

   `Documentation for the IntelliJ IDEA <https://www.jetbrains.com/help/idea/>`__ 
   can be found on the JetBrains website.


13. Homework
--------------------------------------------------------------------------------

   This section lists possible homework assignments for students who are working through
   this codelab as part of a course led by an instructor. It's up to the instructor to do
   the following:

   -  Assign homework if required.
   -  Communicate to students how to submit homework assignments.
   -  Grade the homework assignments.

   Instructors can use these suggestions as little or as much as they want, and should feel
   free to assign any other homework they feel is appropriate.

   If you're working through this codelab on your own, feel free to use these homework
   assignments to test your knowledge.


**Answer these questions**

**Question 1**

   Classes have a special method that serves as a blueprint for creating objects of that
   class. What is the method called?

   *  â–¢ A builder
   *  â–¢ An instantiator
   *  â–¢ A constructor
   *  â–¢ A blueprint


**Question 2**

   Which of the following statements about interfaces and abstract classes is NOT correct?

   *  â–¢ Abstract classes can have constructors.
   *  â–¢ Interfaces can't have constructors.
   *  â–¢ Interfaces and abstract classes can be instantiated directly.
   *  â–¢ Abstract properties must be implemented by subclasses of the abstract class.


**Question 3**

   Which of the following is NOT a Kotlin visibility modifier for properties, methods,
   etc.?

   *  â–¢ ``internal``
   *  â–¢ ``nosubclass``
   *  â–¢ ``protected``
   *  â–¢ ``private``


**Question 4**

   Consider this data class:
   ``data class Fish(val name: String, val species: String, val colors: String)`` Which of
   the following is NOT valid code to create and destructure a ``Fish`` object?

   *  â–¢ ``val (name1, species1, colors1) = Fish("Pat", "Plecostomus", "gold")``
   *  â–¢ ``val (name2, _, colors2) = Fish("Bitey", "shark", "gray")``
   *  â–¢ ``val (name3, species3, _) = Fish("Amy", "angelfish", "blue and black stripes")``
   *  â–¢ ``val (name4, species4, colors4) = Fish("Harry", "halibut")``


**Question 5**

   Let's say you own a zoo with lots of animals that all need to be taken care of. Which of
   the following would NOT be part of implementing caretaking?

   *  â–¢ An ``interface`` for different types of foods animals eat.
   *  â–¢ An ``abstract Caretaker`` class from which you can create different types of caretakers.
   *  â–¢ An ``interface`` for giving clean water to an animal.
   *  â–¢ A ``data`` class for an entry in a feeding schedule.


14. Next codelab
--------------------------------------------------------------------------------

   Proceed to the next lesson: 
   `5.1 Extensions <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-extensions>`__

   For an overview of the course, including links to other codelabs, see 
   `"Kotlin Bootcamp for Programmers: Welcome to the course." <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-welcome/>`__


â­ Kotlin Bootcamp 5.1: Extensions
==================================

   pandoc --column=100 -trst -rhtml https://developer.android.google.cn/codelabs/kotlin-bootcamp-extensions

1. Welcome
--------------------------------------------------------------------------------

   This codelab is part of the 
   `Kotlin Bootcamp for Programmers course <https://developer.android.google.cn/courses/kotlin-bootcamp/overview>`__. 
   You'll get the most value out of this course if you work through the codelabs in sequence.
   Depending on your knowledge, you may be able to skim some sections. This course is
   geared towards programmers who know an object-oriented language, and want to learn
   `Kotlin <https://kotlinlang.org/>`__.


Introduction

   In this codelab you are introduced to a number of different useful features in Kotlin,
   including pairs, collections, and extension functions.

   Rather than build a single sample app, the lessons in this course are designed to build
   your knowledge, but be semi-independent of each other so you can skim sections you're
   familiar with. To tie them together, many of the examples use an aquarium theme. And if
   you want to see the full aquarium story, check out the 
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__ Udacity course.


What you should already know

   -  The syntax of Kotlin functions, classes, and methods
   -  How to work with Kotlin's REPL (Read-Eval-Print Loop) in IntelliJ IDEA
   -  How to create a new class in the IntelliJ IDEA and run a program


What you'll learn

   -  How to work with pairs and triples
   -  More about collections
   -  Defining and using constants
   -  Writing extension functions


What you'll do

   -  Learn about pairs, triples, and hash maps in the REPL
   -  Learn different ways of organizing constants
   -  Write an extension function and an extension property


2. Task: Learn about pairs and triples
--------------------------------------------------------------------------------

   In this task, you learn about pairs and triples and destructuring them. Pairs and
   triples are premade data classes for 2 or 3 generic items. This can, for example, be
   useful for having a function return more than one value.

   Suppose you had a ``List`` of fish, and a function ``isFreshWater()`` to check if the
   fish was a freshwater or saltwater fish. ``List.partition()`` returns two lists, one
   with the items where the condition is ``true``, and the other for items where the
   condition is ``false``.

   .. code:: prettyprint

      val twoLists = fish.partition { isFreshWater(it) }
      println("freshwater: ${twoLists.first}")
      println("saltwater: ${twoLists.second}")


Step 1: Make some pairs and triples

   1. Open the REPL (**Tools** > **Kotlin** > **Kotlin REPL**).

   2. Create a pair, associating a piece of equipment with what it is used for, then print
      the values. You can create a pair by creating an expression connecting two values,
      such as two strings, with the keyword ``to``, then using ``.first`` or ``.second`` to
      refer to each value.

      .. code:: prettyprint

         val equipment = "fish net" to "catching fish"
         println("${equipment.first} used for ${equipment.second}")

      ::

         â‡’ fish net used for catching fish

   3. Create a triple and print it with ``toString()``, then convert it to a list with
      ``toList()``. You create a triple using ``Triple()`` with 3 values. Use ``.first``,
      ``.second`` and ``.third`` to refer to each value.

      .. code:: prettyprint

         val numbers = Triple(6, 9, 42)
         println(numbers.toString())
         println(numbers.toList())

      ::

         â‡’ (6, 9, 42)
         [6, 9, 42]

      The above examples use the same type for all the parts of the pair or triple, but that
      is not required. The parts could be a string, a number, or a list, for example -- even
      another pair or triple.

   4. Create a pair where the first part of the pair is itself a pair.

      .. code:: prettyprint

         val equipment2 = ("fish net" to "catching fish") to "equipment"
         println("${equipment2.first} is ${equipment2.second}\n")
         println("${equipment2.first.second}")

      ::

         â‡’ (fish net, catching fish) is equipment
         â‡’ catching fish


Step 2: Destructure some pairs and triples

   Separating pairs and triples into their parts is called `destructuring`. Assign the pair
   or triple to the appropriate number of variables, and Kotlin will assign the value of
   each part in order.

   1. Destructure a pair and print the values.

      .. code:: prettyprint

         val equipment = "fish net" to "catching fish"
         val (tool, use) = equipment
         println("$tool is used for $use")

      ::

         â‡’ fish net is used for catching fish

   2. Destructure a triple and print the values.

      .. code:: prettyprint

         val numbers = Triple(6, 9, 42)
         val (n1, n2, n3) = numbers
         println("$n1 $n2 $n3")

      ::

         â‡’ 6 9 42

      Note that destructuring pairs and triples works the same as with data classes, which was
      covered in a previous codelab.

3. Task: Comprehend collections
--------------------------------------------------------------------------------

   In this task you learn more about collections, including lists, and a new collection
   type, hash maps.


Step 1: Learn more about lists

   1. Lists and mutable lists were introduced in an earlier lesson. They're a very useful
      data structure, so Kotlin provides a number of built-in functions for lists. Review
      this partial list of functions for lists. You can find complete listings in the
      Kotlin documentation for
      `List <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html>`__
      and
      `MutableList <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html>`__.

      =============================== ================================
      **Function**                    **Purpose**
      =============================== ================================
      ``add(element: E)``             | Add an item to the mutable list.
      ``remove(element: E)``          | Remove an item from a mutable list.
      ``reversed()``                  | Return a copy of the list with the elements in reverse order.
      ``contains(element: E)``        | Return ``true`` if the list contains the item.
      ``subList(from: Int, to: Int)`` | Return part of the list, from the first index up tobut not including the second index.
      =============================== ================================

   2. Still working in the REPL, create a list of numbers and call ``sum()`` on it. This
      sums up all the elements.

      .. code:: prettyprint

         val list = listOf(1, 5, 3, 4)
         println(list.sum())

      ::

         â‡’ 13

   3. Create a list of strings and sum the list.

      .. code:: prettyprint

         val list2 = listOf("a", "bbb", "cc")
         println(list2.sum())

      ::

         â‡’ error: none of the following functions can be called with the arguments supplied:

   4. If the element isn't something ``List`` knows how to sum directly, such as a string,
      you can specify how to sum it using ``.sumBy()`` with a lambda function, for example,
      to sum by the length of each string. The default name for a lambda argument is ``it``
      and here ``it`` refers to each element of the list as the list is traversed.

      .. code:: prettyprint

         val list2 = listOf("a", "bbb", "cc")
         println(list2.sumBy { it.length })

      ::

         â‡’ 6

   5. There's a lot more you can do with lists. One way to see the functionality available
      is to create a list in IntelliJ IDEA, add the dot, and then look at the
      auto-completion list in the tooltip. This works for any object. Try it out with a
      list.

      .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-extensions/img/7accafeefe61a724.png

      .. Note::

         To see the functionality for a class, create an object in IntelliJ IDEA, add a
         dot after the name, and then look at the auto-completion list in the tooltip. This works
         for any object.

   6. Choose ``listIterator()`` from the list, then go through the list with a ``for``
      statement and print all the elements separated by spaces.

      .. code:: prettyprint

         val list2 = listOf("a", "bbb", "cc")
         for (s in list2.listIterator()) {
               println("$s ")
         }

      ::

         â‡’ a bbb cc


Step 2: Try out hash maps

   In Kotlin, you can map pretty much anything to anything else using ``hashMapOf()``. Hash
   maps are sort of like a list of pairs, where the first value acts as a key.

   1. Create a hash map that matches symptoms, the keys, and diseases of fish, the values.

      .. code:: prettyprint

         val cures = hashMapOf("white spots" to "Ich", "red sores" to "hole disease")

   2. You can then retrieve the disease value based on the symptom key, using ``get()``, or
      even shorter, square brackets ``[]``.

      .. code:: prettyprint

         println(cures.get("white spots"))

      ::

         â‡’ Ich

      .. code:: prettyprint

         println(cures["red sores"])

      ::

         â‡’ hole disease

   3. Try specifying a symptom that isn't in the map.

      .. code:: prettyprint

         println(cures["scale loss"])

      ::

         â‡’ null

      If a key isn't in the map, trying to return the matching disease returns ``null``.
      Depending on the map data, it may be common to have no match for a possible key. For
      cases like that, Kotlin provides the ``getOrDefault()`` function.

   4. Try looking up a key that has no match, using ``getOrDefault()``.

      .. code:: prettyprint

         println(cures.getOrDefault("bloating", "sorry, I don't know"))

      ::

         â‡’ sorry, I don't know

      If you need to do more than just return a value, Kotlin provides the ``getOrElse()``
      function.

   5. Change your code to use ``getOrElse()`` instead of ``getOrDefault()``.

      .. code:: prettyprint

         println(cures.getOrElse("bloating") {"No cure for this"})

      ::

         â‡’ No cure for this

      Instead of returning a simple default value, whatever code is between the curly braces
      ``{}`` is executed. In the example, ``else`` simply returns a string, but it could be as
      fancy as finding a webpage with a cure and returning it.

      Just like ``mutableListOf``, you can also make a ``mutableMapOf``. A mutable map lets
      you put and remove items. Mutable just means able to change, immutable means unable to
      change.

   6. Make an inventory map that can be modified, mapping an equipment string to the number
      of items. Create it with a fish net in it, then add 3 tank scrubbers into the
      inventory with ``put()``, and remove the fish net with ``remove()``.

      .. code:: prettyprint

         val inventory = mutableMapOf("fish net" to 1)
         inventory.put("tank scrubber", 3)
         println(inventory.toString())
         inventory.remove("fish net")
         println(inventory.toString())

      ::

         â‡’ {fish net=1, tank scrubber=3}
         {tank scrubber=3}

      .. Note::

         Immutable collections are particularly useful in a threaded environment where
         there might be problems if multiple threads touch the same collection.

4. Task: Study constants
--------------------------------------------------------------------------------

   In this task, you learn about constants in Kotlin and different ways of organizing them.


Step 1: Learn about const vs. val

   1. In the REPL, try creating a numeric constant. In Kotlin, you can make top-level
      constants and assign them a value at compile time using ``const val``.

      .. code:: prettyprint

         const val rocks = 3

      The value is assigned, and can't be changed, which sounds a lot like declaring a regular
      ``val``. So what's the difference between ``const val`` and ``val``? The value for
      ``const val`` is determined at compile time, where as the value for ``val`` is
      determined during program execution, which means, ``val`` can be assigned by a function
      at run time.

      That means ``val`` can be assigned a value from a function, but ``const val`` cannot.

      .. code:: prettyprint

         val value1 = complexFunctionCall() // OK
         const val CONSTANT1 = complexFunctionCall() // NOT ok

      In addition, ``const val`` only works at the top level, and in singleton classes
      declared with ``object``, not with regular classes. You can use this to create a file or
      singleton object that contains only constants, and import them as needed.

      .. code:: prettyprint

         object Constants {
               const val CONSTANT2 = "object constant"
         }
         val foo = Constants.CONSTANT2


Step 2: Create a companion object

   Kotlin does not have a concept of class level constants.

   To define constants inside a class, you have to wrap them into companion objects
   declared with the ``companion`` keyword. The companion object is basically a singleton
   object within the class.

   1. Create a class with a companion object containing a string constant.

      .. code:: prettyprint

         class MyClass {
               companion object {
                  const val CONSTANT3 = "constant in companion"
               }
         }

      The basic difference between companion objects and regular objects is:

      -  Companion objects are initialized from the static constructor of the containing
         class, that is, they are created when the object is created.

      -  Regular objects are initialized lazily on the first access to that object; that is,
         when they are first used.

      There is more, but all that you need to know for now is to wrap constants in classes in
      a companion object.


5. Task: Write extensions
--------------------------------------------------------------------------------

   In this task, you learn about extending the behavior of classes. It's very common to
   write utility functions to extend the behavior of a class. Kotlin provides a convenient
   syntax for declaring these utility functions: extension functions.

   Extension functions allow you to add functions to an existing class without having to
   access its source code. For example, you could declare them in an **Extensions.kt** file
   that is part of your package. This doesn't actually modify the class, but it allows you
   to use the dot-notation when calling the function on objects of that class.


Step 1: Write an extension function

   1. Still working in the REPL, write a simple extension function, ``hasSpaces()`` to
      check if a string contains spaces. The function name is prefixed with the class it
      operates on. Inside the function, ``this`` refers to the object it is called on, and
      ``it`` refers to the iterator in the ``find()`` call.

      .. code:: prettyprint

         fun String.hasSpaces(): Boolean {
               val found = this.find { it == ' ' }
               return found != null
         }
         println("Does it have spaces?".hasSpaces())

      ::

         â‡’ true

   2. You can simplify the ``hasSpaces()`` function. The ``this`` isn't explicitly needed,
      and the function can be reduced to a single expression and returned, so the curly
      braces ``{}`` around it aren't needed, either.

      .. code:: prettyprint

         fun String.hasSpaces() = find { it == ' ' } != null


Step 2: Learn the limitations of extensions

   Extension functions only have access to the public API of the class they're extending.
   Variables that are ``private`` can't be accessed.

   1. Try adding extension functions to a property marked ``private``.

      .. code:: prettyprint

         class AquariumPlant(val color: String, private val size: Int)

         fun AquariumPlant.isRed() = color == "red"    // OK
         fun AquariumPlant.isBig() = size > 50         // gives error

      ::

         â‡’ error: cannot access 'size': it is private in 'AquariumPlant'

      .. Note::

         Extension functions are resolved statically, at compile time, based on the
         type of the variable.

   2. Examine the code below and figure out what it will print.

      .. code:: prettyprint

         open class AquariumPlant(val color: String, private val size: Int)

         class GreenLeafyPlant(size: Int) : AquariumPlant("green", size)

         fun AquariumPlant.print() = println("AquariumPlant")
         fun GreenLeafyPlant.print() = println("GreenLeafyPlant")

         val plant = GreenLeafyPlant(size = 10)
         plant.print()
         println("\n")
         val aquariumPlant: AquariumPlant = plant
         aquariumPlant.print()  // what will it print?

      ::

         â‡’ GreenLeafyPlant
         AquariumPlant

      ``plant.print()`` prints ``GreenLeafyPlant``. You might expect ``aquariumPlant.print()``
      to print ``GreenLeafyPlant``, too, because it was assigned the value of ``plant``. But
      the type is resolved at compile time, so ``AquariumPlant`` gets printed.


Step 3: Add an extension property

   In addition to extension functions, Kotlin also lets you add extension properties. Like
   extension functions, you specify the class you're extending, followed by a dot, followed
   by the property name.

   1. Still working in the REPL, add an extension property ``isGreen`` to
      ``AquariumPlant``, which is ``true`` if the color is green.

      .. code:: prettyprint

         val AquariumPlant.isGreen: Boolean
            get() = color == "green"

      The ``isGreen`` property can be accessed just like a regular property; when accessed,
      the `getter` for ``isGreen`` is called to get the value.

   2. Print the ``isGreen`` property for the ``aquariumPlant`` variable and observe the
      result.

      .. code:: prettyprint

         aquariumPlant.isGreen

      ::

         â‡’ res4: kotlin.Boolean = true


Step 4: Know about nullable receivers

   The class you extend is called the `receiver`, and it is possible to make that class
   nullable. If you do that, the ``this`` variable used in the body can be ``null``, so
   make sure you test for that. You would want to take a nullable receiver if you expect
   that callers will want to call your extension method on nullable variables, or if you
   want to provide a default behavior when your function is applied to ``null``.

   1. Still working in the REPL, define a ``pull()`` method that takes a nullable receiver.
      This is indicated with a question mark ``?`` after the type, before the dot. Inside
      the body, you can test if ``this`` is not ``null`` by using questionmark-dot-apply
      ``?.apply.``

      .. code:: prettyprint

         fun AquariumPlant?.pull() {
            this?.apply {
                  println("removing $this")
            }
         }

         val plant: AquariumPlant? = null
         plant.pull()

   2. In this case, there is no output when you run the program. Because ``plant`` is
      ``null``, the inner ``println()`` is not called.

      Extension functions are very powerful, and most of the Kotlin standard library is
      implemented as extension functions.


6. Summary
--------------------------------------------------------------------------------

   In this lesson, you learned more about collections, learned about constants, and got a
   taste of the power of extension functions and properties.

   -  Pairs and triples can be used to return more than one value from a function. For
      example: ``val twoLists = fish.partition { isFreshWater(it) }``

   -  Kotlin has many useful functions for ``List``, such as ``reversed()``,
      ``contains()``, and ``subList()``.

   -  A ``HashMap`` can be used to map keys to values. For example:
      ``val cures = hashMapOf("white spots" to "Ich", "red sores" to "hole disease")``

   -  Declare compile-time constants using the ``const`` keyword. You can put them at the
      top level, organize them in a singleton object, or put them in a companion object.

   -  A companion object is a singleton object within a class definition, defined with the
      ``companion`` keyword.

   -  Extension functions and properties can add functionality to a class. For example:
      ``fun String.hasSpaces() = find { it == ' ' } != null``

   -  A nullable receiver allows you to create extensions on a class which can be ``null``.
      The ``?.`` operator can be paired with ``apply`` to check for ``null`` before
      executing code. For example: ``this?.apply { println("removing $this") }``


7. Learn more
--------------------------------------------------------------------------------


Kotlin documentation

   If you want more information on any topic in this course, or if you get stuck,
   `https://kotlinlang.org <https://kotlinlang.org/>`__ is your best starting point.

   -  `Kotlin coding conventions <https://kotlinlang.org/docs/reference/coding-conventions.html>`__
   -  `Kotlin idioms <https://kotlinlang.org/docs/reference/idioms.html>`__
   -  `Pair <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-pair/index.html>`__
   -  `Triple <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-triple/index.html>`__
   -  `List <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html>`__
   -  `MutableList <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/index.html>`__
   -  `HashMap <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-hash-map/index.html>`__
   -  `Companion objects <https://kotlinlang.org/docs/reference/object-declarations.html#companion-objects>`__
   -  `Extensions <https://kotlinlang.org/docs/reference/extensions.html#extensions>`__
   -  `Nullable receiver <https://kotlinlang.org/docs/reference/extensions.html#nullable-receiver>`__


Kotlin tutorials

   The https://play.kotlinlang.org website includes rich tutorials called Kotlin Koans, a
   `web-based interpreter <https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt>`__,
   and a complete set of reference documentation with examples.


Udacity course

   To view the Udacity course on this topic, see 
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__.


IntelliJ IDEA

   `Documentation for the IntelliJ IDEA <https://www.jetbrains.com/help/idea/>`__ 
   can be found on the JetBrains website.


8. Homework
--------------------------------------------------------------------------------

   This section lists possible homework assignments for students who are working through
   this codelab as part of a course led by an instructor. It's up to the instructor to do
   the following:

   -  Assign homework if required.
   -  Communicate to students how to submit homework assignments.
   -  Grade the homework assignments.

   Instructors can use these suggestions as little or as much as they want, and should feel
   free to assign any other homework they feel is appropriate.

   If you're working through this codelab on your own, feel free to use these homework
   assignments to test your knowledge.


**Answer these questions**


**Question 1**

   Which one of the following returns a copy of a list?

   * â—» ``add()``
   * â—» ``remove()``
   * â—» ``reversed()``
   * â—» ``contains()``


**Question 2**

   Which one of these extension functions on
   ``class AquariumPlant(val color: String, val size: Int, private val cost: Double, val leafy: Boolean)``
   will give a compiler error?

   * â—» ``fun AquariumPlant.isRed() = color == "red"``
   * â—» ``fun AquariumPlant.isBig() = size > 45``
   * â—» ``fun AquariumPlant.isExpensive() = cost > 10.00``
   * â—» ``fun AquariumPlant.isNotLeafy() = leafy == false``


**Question 3**

   Which one of the following is not a place where you can define constants with
   ``const val``?

   * â—» at the top level of a file
   * â—» in regular classes
   * â—» in singleton objects
   * â—» in companion objects


9. Next codelab
--------------------------------------------------------------------------------

   Proceed to the next lesson: 
   `5.2 Generics <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-generics/>`__

   For an overview of the course, including links to other codelabs, see 
   `"Kotlin Bootcamp for Programmers: Welcome to the course." <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-welcome/>`__


â­ Kotlin Bootcamp 5.2: Generics 
=================================

   pandoc --column=100 -trst -rhtml https://developer.android.google.cn/codelabs/kotlin-bootcamp-generics

1. Welcome
----------

   This codelab is part of the 
   `Kotlin Bootcamp for Programmers course <https://developer.android.google.cn/courses/kotlin-bootcamp/overview>`__. 
   You'll get the most value out of this course if you work through the codelabs in sequence.
   Depending on your knowledge, you may be able to skim some sections. This course is
   geared towards programmers who know an object-oriented language, and want to learn
   `Kotlin <https://kotlinlang.org/>`__.


Introduction

   In this codelab you are introduced to `generic classes`, `functions`, and `methods`, and how
   they work in Kotlin.

   Rather than build a single sample app, the lessons in this course are designed to build
   your knowledge, but be semi-independent of each other so you can skim sections you're
   familiar with. To tie them together, many of the examples use an aquarium theme. And if
   you want to see the full aquarium story, check out the Udacity course:
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__ .


What you should already know

   -  The syntax of Kotlin functions, classes, and methods
   -  How to create a new class in the IntelliJ IDEA and run a program


What you'll learn

   -  How to work with generic classes, methods, and functions


What you'll do

   -  Create a generic class and add constraints
   -  Create ``in`` and ``out`` types
   -  Create generic functions, methods, and extension functions

2. Task: Explore generic classes
--------------------------------


Introduction to generics

   Kotlin, like many programming languages, has generic types. A generic type allows you to
   make a class generic, and thereby make a class much more flexible.

   Imagine you were implementing a ``MyList`` class that holds a list of items. Without
   generics, you would need to implement a new version of ``MyList`` for each type: one for
   ``Double``, one for ``String``, one for ``Fish``. With generics, you can make the list
   generic, so it can hold any type of object. It's like making the type a wildcard that
   will fit many types.

   To define a generic type, put T in angle brackets ``<T>`` after the class name. (You
   could use another letter or a longer name, but the convention for a generic type is T.)

   .. code:: prettyprint

      class MyList<T> {
          fun get(pos: Int): T {
              TODO("implement")
          }
          fun addItem(item: T) {}
      }

   You can reference ``T`` as if it were a normal type. The return type for ``get()`` is
   ``T``, and the parameter to ``addItem()`` is of type ``T``. Of course, generic lists are
   very useful, so the ``List`` class is built into Kotlin.


Step 1: Make a type hierarchy

   In this step you create some classes to use in the next step. Subclassing was covered in
   an earlier codelab, but here is a brief review.

   1. To keep the example uncluttered, create a new package under **src** and call it
      ``generics``.

   2. In the **generics** package, create a new ``Aquarium.kt`` file. This allows you to
      redefine things using the same names without conflicts, so the rest of your code for
      this codelab goes into this file.

   3. Make a type hierarchy of water supply types. Start by making ``WaterSupply`` an
      ``open`` class, so it can be subclassed.

   4. Add a boolean ``var`` parameter, ``needsProcessing``. This automatically creates a
      mutable property, along with a getter and setter.

   5. Make a subclass ``TapWater`` that extends ``WaterSupply``, and pass ``true`` for
      ``needsProcessing``, because the tap water contains additives which are bad for fish.

   6. In ``TapWater``, define a function called ``addChemicalCleaners()`` that sets
      ``needsProcessing`` to ``false`` after cleaning the water. The ``needsProcessing``
      property can be set from ``TapWater``, because it is ``public`` by default and
      accessible to subclasses. Here is the completed code.

      .. code:: prettyprint

         package generics

         open class WaterSupply(var needsProcessing: Boolean)

         class TapWater : WaterSupply(true) {
            fun addChemicalCleaners() {
               needsProcessing = false
            }
         }

   7. Create two more subclasses of ``WaterSupply``, called ``FishStoreWater`` and
      ``LakeWater``. ``FishStoreWater`` doesn't need processing, but ``LakeWater`` must be
      filtered with the ``filter()`` method. After filtering, it does not need to be
      processed again, so in ``filter()``, set ``needsProcessing = false``.

      .. code:: prettyprint

         class FishStoreWater : WaterSupply(false)

         class LakeWater : WaterSupply(true) {
            fun filter() {
               needsProcessing = false
            }
         }

   If you need additional information, review the earlier lesson on inheritance in Kotlin.

   **Tip:** Files don't have to have the same name as their class, and you can have
   multiple classes in a file.


Step 2: Make a generic class

   In this step you modify the ``Aquarium`` class to support different types of water
   supplies.

   1. In **Aquarium.kt**, define an ``Aquarium`` class, with ``<T>`` in brackets after the
      class name.

   2. Add an immutable property ``waterSupply`` of type ``T`` to ``Aquarium``.

      .. code:: prettyprint

         class Aquarium<T>(val waterSupply: T)

   3. Write a function called ``genericsExample()``. This isn't part of a class, so it can
      go at the top level of the file, like the ``main()`` function or the class
      definitions. In the function, make an ``Aquarium`` and pass it a ``WaterSupply``.
      Since the ``waterSupply`` parameter is generic, you must specify the type in angle
      brackets ``<>``.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium = Aquarium<TapWater>(TapWater())
         }

   4. In ``genericsExample()`` your code can access the aquarium's ``waterSupply``. Because
      it is of type ``TapWater``, you can call ``addChemicalCleaners()`` without any type
      casts.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium = Aquarium<TapWater>(TapWater())
            aquarium.waterSupply.addChemicalCleaners()
         }

   5. When creating the ``Aquarium`` object, you can remove the angle brackets and what's
      between them because Kotlin has type inference. So there's no reason to say
      ``TapWater`` twice when you create the instance. The type can be inferred by the
      argument to ``Aquarium``; it will still make an ``Aquarium`` of type ``TapWater``.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium = Aquarium(TapWater())
            aquarium.waterSupply.addChemicalCleaners()
         }

   6. To see what is happening, print ``needsProcessing`` before and after calling
      ``addChemicalCleaners()``. Below is the completed function.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium = Aquarium<TapWater>(TapWater())
            println("water needs processing: ${aquarium.waterSupply.needsProcessing}")
            aquarium.waterSupply.addChemicalCleaners()
            println("water needs processing: ${aquarium.waterSupply.needsProcessing}")
         }

   7. Add a ``main()`` function to call ``genericsExample()``, then run your program and
      observe the result.

      .. code:: prettyprint

         fun main() {
            genericsExample()
         }

      .. code:: 

         â‡’ water needs processing: true
         water needs processing: false


Step 3: Make it more specific

   Generic means you can pass almost anything, and sometimes that's a problem. In this step
   you make the ``Aquarium`` class more specific about what you can put in it.

   1. In ``genericsExample()``, create an ``Aquarium``, passing a string for the
      ``waterSupply``, then print the aquarium's ``waterSupply`` property.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium2 = Aquarium("string")
            println(aquarium2.waterSupply)
         }

   2. Run your program observe the result.

      .. code::

         â‡’ string

      The result is the string you passed, because ``Aquarium`` doesn't put any limitations on
      ``T.``\ Any type, including ``String``, can be passed in.

   3. In ``genericsExample()``, create another ``Aquarium``, passing ``null`` for the
      ``waterSupply``. If the ``waterSupply`` is null, print ``"waterSupply is null"``.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium3 = Aquarium(null)
            if (aquarium3.waterSupply == null) {
               println("waterSupply is null")
            }
         }

   4. Run your program and observe the result.

      .. code::

         â‡’ waterSupply is null

      Why can you pass ``null`` when creating an ``Aquarium``? This is possible because by
      default, ``T`` stands for the nullable ``Any?`` type, the type at the top of the type
      hierarchy. The following is equivalent to what you typed earlier.

      .. code:: prettyprint

         class Aquarium<T: Any?>(val waterSupply: T)

   5. To not allow passing ``null``, make ``T`` of type ``Any`` explicitly, by removing the
      ``?`` after ``Any``.

      .. code:: prettyprint

         class Aquarium<T: Any>(val waterSupply: T)

      In this context, ``Any`` is called a 
      `generic constraint <https://kotlinlang.org/docs/reference/generics.html#generic-constraints>`__.
      It means any type can be passed for ``T`` as long as it isn't ``null``.

   6. What you really want is to make sure that only a ``WaterSupply`` (or one of its
      subclasses) can be passed for ``T``. Replace ``Any`` with ``WaterSupply`` to define a
      more specific generic constraint.

      .. code:: prettyprint

         class Aquarium<T: WaterSupply>(val waterSupply: T)


Step 4: Add more checking

   In this step you learn about the
   `check() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check.html>`__
   function to help ensure your code is behaving as expected. The ``check()`` function is
   a standard library function in Kotlin. It acts as an assertion and will throw an
   ``IllegalStateException`` if its argument evaluates to ``false``.

   1. Add an ``addWater()`` method to ``Aquarium`` class to add water, with a ``check()``
      that makes sure you don't need to process the water first.

      .. code:: prettyprint

         class Aquarium<T: WaterSupply>(val waterSupply: T) {
            fun addWater() {
               check(!waterSupply.needsProcessing) { "water supply needs processing first" }
               println("adding water from $waterSupply")
            }    
         }

      In this case, if ``needsProcessing`` is true, ``check()`` will throw an exception.

   2. In ``genericsExample()``, add code to make an ``Aquarium`` with ``LakeWater``, and
      then add some water to it.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium4 = Aquarium(LakeWater())
            aquarium4.addWater()
         }

   3. Run your program, and you will get an exception, because the water needs to be
      filtered first.

      ::

         â‡’ Exception in thread "main" java.lang.IllegalStateException: water supply needs processing first
               at Aquarium.generics.Aquarium.addWater(Aquarium.kt:21)

   4. Add a call to filter the water before adding it to the ``Aquarium``. Now when you run
      your program, there is no exception thrown.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium4 = Aquarium(LakeWater())
            aquarium4.waterSupply.filter()
            aquarium4.addWater()
         }

      ::

         â‡’ adding water from generics.LakeWater@880ec60

   **Tip:** Use the ``check()`` function to help ensure that your code is working as
   expected.

   The above covers the basics of generics. The following tasks cover more, but the
   important concept is how to declare and use a generic class with a generic constraint.

3. Task: Learn about in and out types
-------------------------------------

   In this task, you learn about 
   `in and out types <https://kotlinlang.org/docs/reference/generics.html#declaration-site-variance>`__
   with generics. An ``in`` type is a type that can only be passed into a class, not
   returned. An ``out`` type is a type that can only be returned from a class.

   Look at the ``Aquarium`` class and you'll see that the generic type is only ever
   returned when getting the property ``waterSupply``. There aren't any methods that take a
   value of type ``T`` as a parameter (except for defining it in the constructor). Kotlin
   lets you define ``out`` types for exactly this case, and it can infer extra information
   about where the types are safe to use. Similarly, you can define ``in`` types for
   generic types that are only ever passed into methods, not returned. This allows Kotlin
   to do extra checks for code safety.

   The ``in`` and ``out`` types are directives for Kotlin's type system. Explaining the
   whole type system is outside the scope of this bootcamp (it's pretty involved); however,
   the compiler will flag types that are not marked ``in`` and ``out`` appropriately, so
   you need to know about them.

   .. Note::

      ``val`` and ``var`` are about the `VALUES` of variables. ``val`` protects the variable
      value from being changed.

      ``in`` and ``out`` are about the `TYPES` of variables. ``in`` and ``out`` make sure that
      when working with generic types, only safe types are passed in and out of functions.


Step 1: Define an out type

   1. In the ``Aquarium`` class, change ``T: WaterSupply`` to be an ``out`` type.

      .. code:: prettyprint

         class Aquarium<out T: WaterSupply>(val waterSupply: T) {
            ...
         }

   2. In the same file, outside the class, declare a function ``addItemTo()`` that expects
      an ``Aquarium`` of ``WaterSupply``.

      .. code:: prettyprint

         fun addItemTo(aquarium: Aquarium<WaterSupply>) = println("item added")

   3. Call ``addItemTo()`` from ``genericsExample()`` and run your program.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium = Aquarium(TapWater())
            addItemTo(aquarium)
         }

      ::

         â‡’ item added

      Kotlin can ensure that ``addItemTo()`` won't do anything type unsafe with the generic
      ``WaterSupply``, because it's declared as an ``out`` type.

   4. If you remove the ``out`` keyword, the compiler will give an error when calling
      ``addItemTo()``, because Kotlin can't ensure that you are not doing anything unsafe
      with the type. 

      .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-generics/img/bea96c26eaed641c.png


Step 2: Define an in type

   The ``in`` type is similar to the ``out`` type, but for generic types that are only ever
   passed into functions, not returned. If you try to return an ``in`` type, you'll get a
   compiler error. In this example you'll define an ``in`` type as part of an interface.

   1. In **Aquarium.kt**, define an interface ``Cleaner`` that takes a generic ``T`` that's
      constrained to ``WaterSupply``. Since it is only used as an argument to ``clean()``,
      you can make it an ``in`` parameter.

      .. code:: prettyprint

         interface Cleaner<in T: WaterSupply> {
            fun clean(waterSupply: T)
         }

   2. To use the ``Cleaner`` interface, create a class ``TapWaterCleaner`` that implements
      ``Cleaner`` for cleaning ``TapWater`` by adding chemicals.

      .. code:: prettyprint

         class TapWaterCleaner : Cleaner<TapWater> {
            override fun clean(waterSupply: TapWater) =   waterSupply.addChemicalCleaners()
         }

   3. In the ``Aquarium`` class, update ``addWater()`` to take a ``Cleaner`` of type ``T``,
      and clean the water before adding it.

      .. code:: prettyprint

         class Aquarium<out T: WaterSupply>(val waterSupply: T) {
            fun addWater(cleaner: Cleaner<T>) {
               if (waterSupply.needsProcessing) {
                     cleaner.clean(waterSupply)
               }
               println("water added")
            }
         }

   4. Update the ``genericsExample()`` example code to make a ``TapWaterCleaner``, an
      ``Aquarium`` with ``TapWater``, and then add some water using the cleaner. It will
      use the cleaner as needed.

      .. code:: prettyprint

         fun genericsExample() {
            val cleaner = TapWaterCleaner()
            val aquarium = Aquarium(TapWater())
            aquarium.addWater(cleaner)
         }

      Kotlin will use the ``in`` and ``out`` type information to make sure your code uses the
      generics safely. ``Out`` and ``in`` are easy to remember: ``out`` types can be passed
      outward as return values, ``in`` types can be passed inward as arguments.

   .. Tip:: 

      The IntelliJ IDEA will suggest you add ``out`` or ``in`` to your generic types
      when it's correct to do so. If you click on the generic type name, IntelliJ IDEA will
      put an "intention bulb" at the start of the line. If you click on the bulb, a list of
      suggestions will appear.

      .. image:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-generics/img/29c11b278d60a7f0.png

      If you want to dig in more to the sort of problems in types and out types
      solve, the `documentation <https://kotlinlang.org/docs/reference/generics.html>`__ covers
      them in depth.


4. Task: Find out about generic functions
-----------------------------------------

   In this task you will learn about generic functions and when to use them. Typically,
   making a generic function is a good idea whenever the function takes an argument of a
   class that has a generic type.


Step 1: Make a generic function

   1. In **generics/Aquarium.kt**, make a function ``isWaterClean()`` which takes an
      ``Aquarium``. You need to specify the generic type of the parameter; one option is to
      use ``WaterSupply``.

      .. code:: prettyprint

         fun isWaterClean(aquarium: Aquarium<WaterSupply>) {
            println("aquarium water is clean: ${!aquarium.waterSupply.needsProcessing}")
         }

      But this means ``Aquarium`` must have an ``out`` type parameter for this to be called.
      Sometimes ``out`` or ``in`` is too restrictive because you need to use a type for both
      input and output. You can remove the ``out`` requirement by making the function generic.

   2. To make the function generic, put angle brackets after the keyword ``fun`` with a
      generic type ``T`` and any constraints, in this case, ``WaterSupply``. Change
      ``Aquarium`` to be constrained by ``T`` instead of by ``WaterSupply``.

      .. code:: prettyprint

         fun <T: WaterSupply> isWaterClean(aquarium: Aquarium<T>) {
            println("aquarium water is clean: ${!aquarium.waterSupply.needsProcessing}")
         }

      ``T`` is a type parameter to ``isWaterClean()`` that is being used to specify the
      generic type of the aquarium. This pattern is really common, and it's a good idea to
      take a moment to work through this.

   3. Call the ``isWaterClean()`` function by specifying the type in angle brackets right
      after the function name and before the parentheses.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium = Aquarium(TapWater())
            isWaterClean<TapWater>(aquarium)
         }

   4. Because of type inference from the argument ``aquarium``, the type isn't needed, so
      remove it. Run your program and observe the output.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium = Aquarium(TapWater())
            isWaterClean(aquarium)
         }

      ::

         â‡’ aquarium water is clean: false


Step 2: Make a generic method with a reified type

   You can use generic functions for methods too, even in classes that have their own
   generic type. In this step, you add a generic method to ``Aquarium`` that checks if it
   has a type of ``WaterSupply``.

   1. In ``Aquarium`` class, declare a method, ``hasWaterSupplyOfType()`` that takes a
      generic parameter ``R`` (``T`` is already used) constrained to ``WaterSupply``, and
      returns ``true`` if ``waterSupply`` is of type ``R``. This is like the function you
      declared earlier, but inside the ``Aquarium`` class.

      .. code:: prettyprint

         fun <R: WaterSupply> hasWaterSupplyOfType() = waterSupply is R

   2. Notice that the final ``R`` is underlined in red. Hold the pointer over it to see
      what the error is.

      .. figure:: https://developer.android.google.cn/static/codelabs/kotlin-bootcamp-generics/img/e270f4047d18603e.png

         Cannot check for instance of erased type: R

   3. To do an ``is`` check, you need to tell Kotlin that the type is
      `reified <https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters>`__,
      or real, and can be used in the function. To do that, put ``inline`` in front of the
      ``fun`` keyword, and ``reified`` in in front of the generic type ``R``.

      .. code:: prettyprint

         inline fun <reified R: WaterSupply> hasWaterSupplyOfType() = waterSupply is R

      .. Note::
         
         Generic types are normally only available at compile time, and get replaced
         with the actual types. To keep a generic type available until run time, declare the
         function ``inline`` and make the type ``reified``.

      Once a type is reified, you can use it like a normal type - beecause it is a real type
      after inlining. That means you can do ``is`` checks using the type.

      If you don't use ``reified`` here, the type won't be "real" enough for Kotlin to allow
      ``is`` checks. That's because non-reified types are only available at compile time, and
      can't be used at runtime by your program. This is discussed more in the next section.

   4. Pass ``TapWater`` as the type. Like calling generic functions, call generic methods
      by using angle brackets with the type after the function name. Run your program and
      observe the result.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium = Aquarium(TapWater())
            println(aquarium.hasWaterSupplyOfType<TapWater>())   // true
         }

      ::

         â‡’ true


Step 3: Make extension functions

   You can use reified types for regular functions and extension functions, too.

   1. Outside the ``Aquarium`` class, define an extension function on ``WaterSupply``
      called ``isOfType()`` that checks if the passed ``WaterSupply`` is of a specific
      type, for example, ``TapWater``.

      .. code:: prettyprint

         inline fun <reified T: WaterSupply> WaterSupply.isOfType() = this is T

   2. Call the extension function just like a method.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium = Aquarium(TapWater())
            println(aquarium.waterSupply.isOfType<TapWater>())  
         }

      ::

         â‡’ true

      With these extension functions, it doesn't matter what type of ``Aquarium`` it is
      (``Aquarium`` or ``TowerTank`` or some other subclass), as long as it is an
      ``Aquarium``. Using the
      `star-projection <https://kotlinlang.org/docs/reference/generics.html#star-projections>`__
      syntax is a convenient way to specify a variety of matches. And when you use a
      star-projection, Kotlin will make sure you don't do anything unsafe, too.

      .. Note::

         Star-projections are much like raw types in the Java programming language, 
         but safe.

   3. To use a star-projection, put ``<*>`` after ``Aquarium``. Move
      ``hasWaterSupplyOfType()`` to be an extension function, because it isn't really part
      of the core API of ``Aquarium``.

      .. code:: prettyprint

         inline fun <reified R: WaterSupply> Aquarium<*>.hasWaterSupplyOfType() = waterSupply is R

   4. Change the call to ``hasWaterSupplyOfType()`` and run your program.

      .. code:: prettyprint

         fun genericsExample() {
            val aquarium = Aquarium(TapWater())
            println(aquarium.hasWaterSupplyOfType<TapWater>())
         }

      ::

         â‡’ true

5. Concept: Reified types and type erasure
------------------------------------------

   In the earlier example, you had to mark the generic type as ``reified`` and make the
   function ``inline``, because Kotlin needs to know about them at runtime, not just
   compile time.

   All generic types are only used at compile time by Kotlin. This lets the compiler make
   sure that you're doing everything safely. By runtime all the generic types are erased,
   hence the earlier error message about checking an erased type.

   It turns out the compiler can create correct code without keeping the generic types
   until runtime. But it does mean that sometimes you do something, like ``is`` checks on
   generic types, that the compiler can't support. That's why Kotlin added reified, or
   real, types.

   You can read more about reified types and type erasure in the 
   `Kotlin documentation <https://kotlinlang.org/docs/reference/typecasts.html#type-erasure-and-generic-type-checks>`__.

6. Summary
----------

   This lesson focused on generics, which are important for making code more flexible and
   easier to reuse.


   -  Create generic classes to make code more flexible.

   -  Add generic constraints to limit the types used with generics.

   -  Use ``in`` and ``out`` types with generics to provide better type checking to
      restrict types being passed into or returned from classes.

   -  Create generic functions and methods to work with generic types. For example:
      ``fun <T: WaterSupply> isWaterClean(aquarium: Aquarium<T>) { ... }``

   -  Use generic extension functions to add non-core functionality to a class.

   -  Reified types are sometimes necessary because of type erasure. Reified types, unlike
      generic types, persist to runtime.

   -  Use the ``check()`` function to verify your code is running as expected. For example:
      ``check(!waterSupply.needsProcessing) { "water supply needs processing first" }``

7. Learn more
-------------

Kotlin documentation


   If you want more information on any topic in this course, or if you get stuck,
   https://kotlinlang.org is your best starting point.

   -  `Kotlin coding conventions <https://kotlinlang.org/docs/reference/coding-conventions.html>`__
   -  `Kotlin idioms <https://kotlinlang.org/docs/reference/idioms.html>`__
   -  `Generics <https://kotlinlang.org/docs/reference/generics.html>`__
   -  `Generic constraints <https://kotlinlang.org/docs/reference/generics.html#generic-constraints>`__
   -  `Star-projections <https://kotlinlang.org/docs/reference/generics.html#star-projections>`__
   -  `In and out types <https://kotlinlang.org/docs/reference/generics.html#declaration-site-variance>`__
   -  `Reified parameters <https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters>`__
   -  `Type erasure <https://kotlinlang.org/docs/reference/typecasts.html#type-erasure-and-generic-type-checks>`__
   -  `check() function <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check.html>`__


Kotlin tutorials

   The https://play.kotlinlang.org website includes rich tutorials called Kotlin Koans, a
   `web-based interpreter <https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt>`__,
   and a complete set of reference documentation with examples.


Udacity course

   To view the Udacity course on this topic, see 
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__.


IntelliJ IDEA

   `Documentation for the IntelliJ IDEA <https://www.jetbrains.com/help/idea/>`__ 
   can be found on the JetBrains website.

8. Homework
-----------

   This section lists possible homework assignments for students who are working through
   this codelab as part of a course led by an instructor. It's up to the instructor to do
   the following:

   -  Assign homework if required.
   -  Communicate to students how to submit homework assignments.
   -  Grade the homework assignments.

   Instructors can use these suggestions as little or as much as they want, and should feel
   free to assign any other homework they feel is appropriate.

   If you're working through this codelab on your own, feel free to use these homework
   assignments to test your knowledge.

**Answer these questions**


**Question 1**

   Which of the following is the convention for naming a generic type?

   *  ğŸ”³ ``<Gen>``
   *  ğŸ”³ ``<Generic>``
   *  ğŸ”³ ``<T>``
   *  ğŸ”³ ``<X>``


**Question 2**

   A restriction on the types allowed for a generic type is called:

   *  ğŸ”³ a generic restriction
   *  ğŸ”³ a generic constraint
   *  ğŸ”³ disambiguation
   *  ğŸ”³ a generic type limit


**Question 3**

   Reified means:

   *  ğŸ”³ The real execution impact of an object has been calculated.
   *  ğŸ”³ A restricted entry index has been set on the class.
   *  ğŸ”³ The generic type parameter has been made into a real type.
   *  ğŸ”³ A remote error indicator has been triggered.

9. Next codelab
---------------

   Proceed to the next lesson: 
   `6. Functional manipulation <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-sams/>`__

   For an overview of the course, including links to other codelabs, see 
   `"Kotlin Bootcamp for Programmers: Welcome to the course." <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-welcome/>`__


â­ Kotlin Bootcamp 6: Functional manipulation
=============================================

   pandoc --column=100 -trst -rhtml https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-sams


1. Welcome
--------------------------------------------------------------------------------

   This codelab is part of the 
   `Kotlin Bootcamp for Programmers course <https://developer.android.google.cn/courses/kotlin-bootcamp/overview>`__.
   You'll get the most value out of this course if you work through the codelabs in
   sequence. Depending on your knowledge, you may be able to skim some sections.
   This course is geared towards programmers who know an object-oriented language,
   and want to learn `Kotlin <https://kotlinlang.org/>`__.


Introduction

   This is the final codelab in the Kotlin Bootcamp. In this codelab you learn
   about annotations and labeled breaks. You review lambdas and higher- order
   functions, which are key parts of Kotlin. You also learn more about inlining
   functions, and Single Abstract Method (SAM) interfaces. Finally, you learn more
   about the `Kotlin Standard Library <https://kotlinlang.org/api/latest/jvm/stdlib/>`__.

   Rather than build a single sample app, the lessons in this course are designed
   to build your knowledge, but be semi-independent of each other so you can skim
   sections you're familiar with. To tie them together, many of the examples use an
   aquarium theme. And if you want to see the full aquarium story, check out the
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__ Udacity course.


What you should already know

   -  The syntax of Kotlin functions, classes, and methods
   -  How to create a new class in the IntelliJ IDEA and run a program
   -  The basics of lambdas and higher-order functions


What you'll learn

   -  The basics of annotations
   -  How to use labeled breaks
   -  More about higher-order functions
   -  About Single Abstract Method (SAM) interfaces
   -  About the Kotlin Standard Library


What you'll do

   -  Create a simple annotation.
   -  Use a labeled break.
   -  Review lambda functions in Kotlin.
   -  Use and create higher-order functions.
   -  Call some Single Abstract Method interfaces.
   -  Use some functions from the Kotlin Standard Library.


2. Task: Learn about annotations
--------------------------------------------------------------------------------

   Annotations are a way of attaching metadata to code, and are not something
   specific to Kotlin. The annotations are read by the compiler and used to
   generate code or logic. Many frameworks, such as `Ktor <https://ktor.io/>`__ and
   `Kotlinx <https://ktor.io/kotlinx/index.html>`__, as well as
   `Room <https://codelabs.developers.google.cn/codelabs/android-room-with-a-view-kotlin/#0>`__,
   use annotations to configure how they run and interact with your code. You are
   unlikely to encounter any annotations until you start using frameworks, but it's
   useful to be able to know how to read an annotation.

   There are also annotations that are available through the Kotlin standard
   library that control the way code is compiled. They're really useful if you're
   exporting Kotlin to Java code, but otherwise you don't need them that often.

   Annotations go right before the thing that is annotated, and most things can be
   annotated â€” classes, functions, methods, and even control structures. Some
   annotations can take arguments.

   Here is an example of some annotations.

   .. code:: prettyprint

      @file:JvmName("InteropFish")
      class InteropFish {
         companion object {
             @JvmStatic fun interop()
         }
      }

   This says the exported name of this file is ``InteropFish`` with the ``JvmName``
   annotation; the ``JvmName`` annotation is taking an argument of
   ``"InteropFish"``. In the companion object, ``@JvmStatic`` tells Kotlin to make
   ``interop()`` a static function in ``InteropFish``.

   You can also create your own annotations, but this is mostly useful if you are
   writing a library that needs particular information about classes at runtime,
   that is `reflection <https://kotlinlang.org/docs/reference/reflection.html#reflection>`__.


Step 1: Create a new package and file

   1. Under **src**, create a new package, ``example``.
   2. In **example**, create a new Kotlin file, ``Annotations.kt``.


Step 2: Create your own annotation

   1. In ``Annotations.kt``, create a ``Plant`` class with two methods, ``trim()``
      and ``fertilize()``.

      .. code:: prettyprint

         class Plant {
               fun trim(){}
               fun fertilize(){}
         }

   2. Create a function that prints all the methods in a class. Use ``::class`` to
      get information about a class at runtime. Use ``declaredMemberFunctions`` to
      get a list of the methods of a class. (To access this, you need to import
      ``kotlin.reflect.full.*``)

      .. code:: prettyprint

         import kotlin.reflect.full.*    // required import

         class Plant {
            fun trim(){}
            fun fertilize(){}
         }

         fun testAnnotations() {
            val classObj = Plant::class
            for (m in classObj.declaredMemberFunctions) {
               println(m.name)
            }
         }

   3. Create a ``main()`` function to call your test routine. Run your program and
      observe the output.

      .. code:: prettyprint

         fun main() {
            testAnnotations()
         }

      ::

         â‡’ trim
         fertilize

   4. Create a simple annotation, ``ImAPlant``.

      .. code:: prettyprint

         annotation class ImAPlant

      This doesn't do anything other than say it is annotated.

   4. Add the annotation in front of your ``Plant`` class.

      .. code:: prettyprint

         @ImAPlant class Plant{
            ...
         }

   5. Change ``testAnnotations()`` to print all the annotations of a class. Use
      ``annotations`` to get all the annotations of a class. Run your program and
      observe the result.

      .. code:: prettyprint

         fun testAnnotations() {
            val plantObject = Plant::class
            for (a in plantObject.annotations) {
               println(a.annotationClass.simpleName)
            }
         }

      ::

         â‡’ ImAPlant

   6. Change ``testAnnotations()`` to find the ``ImAPlant`` annotation. Use
      ``findAnnotation()`` to find a specific annotation. Run your program and
      observe the result.

      .. code:: prettyprint

         fun testAnnotations() {
            val plantObject = Plant::class
            val myAnnotationObject = plantObject.findAnnotation<ImAPlant>()
            println(myAnnotationObject)
         }

      ::

         â‡’ @example.ImAPlant()


Step 3: Create a targeted annotation

   Annotations can target getters or setters. When they do, you can apply them with
   the ``@get:`` or ``@set:`` prefix. This comes up a lot when using frameworks
   with annotations.

   Declare two annotations, ``OnGet`` which can only be applied to property
   getters, and ``OnSet`` which can only be applied to property setters. Use
   ``@Target(AnnotationTarget.PROPERTY_GETTER)`` or ``PROPERTY_SETTER`` on each.

   .. code:: prettyprint

      annotation class ImAPlant

      @Target(AnnotationTarget.PROPERTY_GETTER)
      annotation class OnGet
      @Target(AnnotationTarget.PROPERTY_SETTER)
      annotation class OnSet

      @ImAPlant class Plant {
          @get:OnGet
          val isGrowing: Boolean = true

          @set:OnSet
          var needsFood: Boolean = false
      }

   Annotations are really powerful for creating libraries that inspect things both
   at runtime and sometimes at compile time. However, typical application code just
   uses annotations provided by frameworks.


3. Task: Learn about labeled breaks
--------------------------------------------------------------------------------

   Kotlin has several ways of controlling flow. You are already familiar with
   ``return``, which returns from a function to its enclosing function. Using a
   ``break`` is like ``return``, but for loops.

   Kotlin gives you additional control over loops with what's called a 
   `labeled break <https://kotlinlang.org/docs/reference/returns.html#break-and-continue-labels>`__.
   A ``break`` qualified with a label jumps to the execution point right after the
   loop marked with that label. This is particularly useful when dealing with
   nested loops.

   Any expression in Kotlin may be marked with a label. Labels have the form of an
   identifier followed by the ``@`` sign.

   1. In ``Annotations.kt``, try out a labeled break by breaking out from an inner
      loop.

      .. code:: prettyprint

         fun labels() {
            outerLoop@ for (i in 1..100) {
                  print("$i ")
                  for (j in 1..100) {
                     if (i > 10) break@outerLoop  // breaks to outer loop
               }
            }
         }

         fun main() {
            labels()
         }

   2. Run your program and observe the output.

      ::

         â‡’ 1 2 3 4 5 6 7 8 9 10 11 

      Similarly, you can use a labeled ``continue``. Instead of breaking out of the
      labeled loop, the labeled continue proceeds to the next iteration of the loop.

      .. Note::

         A labeled break in Kotlin can only be used to break out of loops,
         unlike ``goto`` in C++ or C#.


4. Task: Create simple lambdas
--------------------------------------------------------------------------------

   Lambdas are anonymous functions, which are functions with no name. You can
   assign them to variables and pass them as arguments to functions and methods.
   They are extremely useful.


Step 1: Create a simple lambda

   1. Start the REPL in IntelliJ IDEA, **Tools > Kotlin > Kotlin REPL**.

   2. Create a lambda with an argument, ``dirty: Int`` that does a calculation,
      dividing ``dirty`` by 2. Assign the lambda to a variable, ``waterFilter``.

      .. code:: prettyprint

         val waterFilter = { dirty: Int -> dirty / 2 }

   3. Call ``waterFilter``, passing a value of 30.

      .. code:: prettyprint

         waterFilter(30)

      ::

         â‡’ res0: kotlin.Int = 15


Step 2: Create a filter lambda

   1. Still in the REPL, create a data class, ``Fish``, with one property,
      ``name``.

      .. code:: prettyprint

         data class Fish(val name: String)

   2. Create a list of 3 ``Fish``, with names Flipper, Moby Dick, and Dory.

      .. code:: prettyprint

         val myFish = listOf(Fish("Flipper"), Fish("Moby Dick"), Fish("Dory"))

   3. Add a filter to check for names that contain the letter 'i'.

      .. code:: prettyprint

         myFish.filter { it.name.contains("i")}

      ::

         â‡’ res3: kotlin.collections.List<Line_1.Fish> = [Fish(name=Flipper), Fish(name=Moby Dick)]

      In the lambda expression, ``it`` refers to the current list element, and the
      filter is applied to each list element in turn.

   4. Apply ``joinString()`` to the result, using ``", "`` as the separator.

      .. code:: prettyprint

         myFish.filter { it.name.contains("i")}.joinToString(", ") { it.name }

      ::

         â‡’ res4: kotlin.String = Flipper, Moby Dick

      The ``joinToString()`` function creates a string by joining the filtered names,
      separated by the string specified. It is one of the many useful functions built
      into the Kotlin standard library.


5. Task: Write a higher-order function
--------------------------------------------------------------------------------

   Passing a lambda or other function as an argument to a function creates a
   higher-order function. The filter above is a simple example of this.
   ``filter()`` is a function, and you pass it a lambda that specifies how to
   process each element of the list.

   Writing higher-order functions with extension lambdas is one of the most
   advanced parts of the Kotlin language. It takes a while to learn how to write
   them, but they are really convenient to use.


Step 1: Create a new class

   1. Within the **example** package, create a new Kotlin file, ``Fish.kt``.

   2. In ``Fish.kt``, create a data class ``Fish``, with one property, ``name``.

      .. code:: prettyprint

         data class Fish (var name: String)

   3. Create a function ``fishExamples()``. In ``fishExamples()``, create a fish
      named ``"splashy"``, all lowercase.

      .. code:: prettyprint

         fun fishExamples() {
            val fish = Fish("splashy")  // all lowercase
         }

   4. Create a ``main()`` function which calls ``fishExamples()``.

      .. code:: prettyprint

         fun main () {
            fishExamples()
         }

   5. Compile and run your program by clicking the green triangle to the left of
      ``main()``. There is no output yet.


Step 2: Use a higher-order function

   The ``with()`` function lets you make one or more references to an object or
   property in a more compact way. Using ``this``. ``with()`` is actually a
   higher-order function, and in the lamba you specify what to do with the supplied
   object.

   1. Use ``with()`` to capitalize the fish name in ``fishExamples()``. Within the
      curly braces, ``this`` refers to the object passed to ``with()``.

      .. code:: prettyprint

         fun fishExamples() {
            val fish = Fish("splashy")  // all lowercase
            with (fish.name) {
               this.capitalize()
            }
         }

   2. There is no output, so add a ``println()`` around it. And the ``this`` is
      implicit and not needed, so you can remove it.

      .. code:: prettyprint

         fun fishExamples() {
            val fish = Fish("splashy")  // all lowercase
            with (fish.name) {
               println(capitalize())
            }
         }

      ::

         â‡’ Splashy


Step 3: Create a higher-order function

   Under the hood, ``with()`` is a higher-order function. To see how this works,
   you can make your own greatly simplified version of ``with()`` that just works
   for strings.

   1. In ``Fish.kt``, define a function, ``myWith()`` that takes two arguments. The
      arguments are the object to operate on, and a function that defines the
      operation. The convention for the argument name with the function is
      ``block``. In this case, that function returns nothing, which is specified
      with ``Unit``.

   .. code:: prettyprint

      fun myWith(name: String, block: String.() -> Unit) {}

   Inside ``myWith()``, ``block()`` is now an extension function of ``String``. The
   class being extended is often called the **receiver object**. So ``name`` is the
   receiver object in this case.

   2. In the body of ``myWith()``, apply the passed in function, ``block()``, to
      the receiver object, ``name``.

   .. code:: prettyprint

      fun myWith(name: String, block: String.() -> Unit) {
          name.block()
      }

   3. In ``fishExamples()``, replace ``with()`` with ``myWith()``.

   .. code:: prettyprint

      fun fishExamples() {
          val fish = Fish("splashy")  // all lowercase
          myWith (fish.name) {
              println(capitalize())
          }
      }

   ``fish.name`` is the name argument, and ``println(capitalize())`` is the block
   function.

   4. Run the program, and it operates as before.

   ::

      â‡’ Splashy


Step 4: Explore more built in extensions

   The ``with()`` extension lambda is very useful, and is part of the `Kotlin
   Standard Library <https://kotlinlang.org/api/latest/jvm/stdlib/>`__. Here are a
   few of the others you might find handy: ``run()``, ``apply()``, and ``let()``.

   The ``run()`` function is an extension that works with all types. It takes one
   lambda as its argument and returns the result of executing the lambda.

   1. In ``fishExamples()``, call ``run()`` on ``fish`` to get the name.

      .. code:: prettyprint

         fish.run {
            name
         }

      This just returns the ``name`` property. You could assign that to a variable or
      print it. This isn't actually a useful example, as you could just access the
      property, but ``run()`` can be useful for more complicated expressions.

      The ``apply()`` function is similar to ``run()``, but it returns the changed
      object it was applied to instead of the result of the lambda. This can be useful
      for calling methods on a newly created object.

   2. Make a copy of ``fish`` and call ``apply()`` to set the name of the new copy.

      .. code:: prettyprint

         val fish2 = Fish(name = "splashy").apply {
            name = "sharky"
         }
         println(fish2.name)

      ::

         â‡’ sharky

      .. Note::

         ``run()`` and ``apply()`` are similar, but ``run()`` returns the
         result of applying the function, and ``apply()`` returns the object after
         applying the function.

      The ``let()`` function is similar to ``apply()``, but it returns a *copy* of the
      object with the changes. This can be useful for chaining manipulations together.

   3. Use ``let()`` to get the name of ``fish``, capitalize it, concatenate another
      string to it, get the length of that result, add 31 to the length, then print
      the result.

      .. code:: prettyprint

         println(fish.let { it.name.capitalize()}
         .let{it + "fish"}
         .let{it.length}
         .let{it + 31})

      ::

         â‡’ 42

      In this example, the object type referred to by ``it`` is ``Fish``, then
      ``String``, then ``String`` again and finally ``Int``.

   4. Print ``fish`` after calling ``let()``, and you will see that it hasn't
      changed.

      .. code:: prettyprint

         println(fish.let { it.name.capitalize()}
            .let{it + "fish"}
            .let{it.length}
            .let{it + 31})
         println(fish)

      ::

         â‡’ 42
         Fish(name=splashy)


6. Concept: Inline functions
--------------------------------------------------------------------------------

   Lambdas and higher-order functions are really useful, but there is something you
   should know: lambdas are objects. A lambda expression is an instance of a
   ``Function`` interface, which is itself a subtype of ``Object``. Consider the
   earlier example of ``myWith()``.

   .. code:: prettyprint

      myWith(fish.name) {
          capitalize()
      }

   The ``Function`` interface has a method, ``invoke()``, which is overridden to
   call the lambda expression. Written out longhand, it would look something like
   the code below.

   .. code:: prettyprint

      // actually creates an object that looks like this
      myWith(fish.name, object : Function1<String, Unit> {
          override fun invoke(name: String) {
              name.capitalize()
          }
      })

   Normally this isn't a problem, because creating objects and calling functions
   doesn't incur much overhead, that is, memory and CPU time. But if you're
   defining something like ``myWith()`` that you use everywhere, the overhead could
   add up.

   Kotlin provides ``inline`` as a way to handle this case to reduce overhead
   during runtime by adding a bit more work for the compiler. (You learned a little
   about ``inline`` in the earlier lesson talking about reified types.) Marking a
   function as ``inline`` means that every time the function is called, the
   compiler will actually transform the source code to "inline" the function. That
   is, the compiler will change the code to replace the lambda with the
   instructions inside the lambda.

   If ``myWith()`` in the above example is marked with ``inline``:

   .. code:: prettyprint

      inline myWith(fish.name) {
          capitalize()
      }

   it is transformed into a direct call:

   .. code:: prettyprint

      // with myWith() inline, this becomes
      fish.name.capitalize()

   It is worth noting that inlining large functions does increase your code size,
   so it's best used for simple functions that are used many times like
   ``myWith()``. The extension functions from the libraries you learned about
   earlier are marked ``inline``, so you don't have to worry about extra objects
   being created.


7. Task: Learn about Single Abstract Methods
--------------------------------------------------------------------------------

   Single Abstract Method just means an interface with one method on it. They are
   very common when using APIs written in the Java programming language, so there
   is an acronym for it, SAM. Some examples are ``Runnable``, which has a single
   abstract method, ``run()``, and ``Callable``, which has a single abstract
   method, ``call()``.

   In Kotlin, you have to call functions that take SAMs as parameters all the time.
   Try the example below.

   1. Inside **example**, create a Java class, ``JavaRun``, and paste the following
      into the file.

      .. code:: prettyprint

         package example;

         public class JavaRun {
            public static void runNow(Runnable runnable) {
               runnable.run();
            }
         }

      Kotlin lets you instantiate an object that implements an interface by preceding
      the type with ``object:``. It's useful for passing parameters to SAMs.

   2. Back in ``Fish.kt``, create a function ``runExample()``, which creates a
      ``Runnable`` using ``object:`` The object should implement ``run()`` by
      printing ``"I'm a Runnable"``.

      .. code:: prettyprint

         fun runExample() {
            val runnable = object: Runnable {
               override fun run() {
                     println("I'm a Runnable")
               }
            }
         }

   3. Call ``JavaRun.runNow()`` with the object you created.

      .. code:: prettyprint

         fun runExample() {
            val runnable = object: Runnable {
               override fun run() {
                     println("I'm a Runnable")
               }
            }
            JavaRun.runNow(runnable)
         }

      Call ``runExample()`` from ``main()`` and run the program.

      ::

         â‡’ I'm a Runnable

      A lot of work to print something, but a good example of how a SAM works. Of
      course, Kotlin provides a simpler way to do this â€” use a lambda in place of the
      object to make this code a lot more compact.

   4. Remove the existing code in ``runExample``, change it to call ``runNow()``
      with a lambda, and run the program.

      .. code:: prettyprint

         fun runExample() {
            JavaRun.runNow({
               println("Passing a lambda as a Runnable")
            })
         }

      ::

         â‡’ Passing a lambda as a Runnable

   5. You can make this even more concise using the last parameter call syntax, and
      get rid of the parentheses.

      .. code:: prettyprint

         fun runExample() {
            JavaRun.runNow {
               println("Last parameter is a lambda as a Runnable")
            }
         }

      ::

         â‡’ Last parameter is a lambda as a Runnable

      That's the basics of a SAM, a Single Abstract Method. You can instantiate,
      override and make a call to a SAM with one line of code, using the pattern:
      ``Class.singleAbstractMethod { lambda_of_override }``


8. Summary
--------------------------------------------------------------------------------

   This lesson reviewed lambdas and went into more depth with higher-order
   functions â€” key parts of Kotlin. You also learned about annotations and labeled
   breaks.

   -  Use annotations to specify things to the compiler. For example:
      ``@file:JvmName("Foo")``

   -  Use labeled breaks to let your code exit from inside nested loops. For
      example: ``if (i > 10) break@outerLoop // breaks to outerLoop label``

   -  Lambdas can be very powerful when coupled with higher-order functions.

   -  Lambdas are objects. To avoid creating the object, you can mark the function
      with ``inline``, and the compiler will put the contents of the lambda in the
      code directly.

   -  Use ``inline`` carefully, but it can help reduce resource usage by your
      program.

   -  SAM, Single Abstract Method, is a common pattern, and made simpler with
      lambdas. The basic pattern is:
      ``Class.singleAbstractMethod { lamba_of_override }``

   -  The `Kotlin Standard Library <https://kotlinlang.org/api/latest/jvm/stdlib/>`__ 
      provides numerous
      useful functions, including several SAMs, so get to know what's in it.

   There's lots more to Kotlin than was covered in the course, but you now have the
   basics to begin developing your own Kotlin programs. Hopefully you're excited
   about this expressive language, and looking forward to creating more
   functionality while writing less code (especially if you're coming from the Java
   programming language.) Practice and learning as you go is the best way to become
   an expert in Kotlin, so continue to explore and learn about Kotlin on your own.


9. Learn more
--------------------------------------------------------------------------------


Kotlin documentation

   If you want more information on any topic in this course, or if you get stuck,
   `https://kotlinlang.org <https://kotlinlang.org/>`__ is your best starting
   point.

   -  `Kotlin coding conventions <https://kotlinlang.org/docs/reference/coding-conventions.html>`__
   -  `Kotlin idioms <https://kotlinlang.org/docs/reference/idioms.html>`__
   -  `Annotations <https://kotlinlang.org/docs/reference/annotations.html>`__
   -  `Reflection <https://kotlinlang.org/docs/reference/reflection.html#reflection>`__
   -  `Labeled breaks <https://kotlinlang.org/docs/reference/returns.html#break-and-continue-labels>`__
   -  `Higher-order functions and lambdas <https://kotlinlang.org/docs/reference/lambdas.html>`__
   -  `Inline functions <https://kotlinlang.org/docs/reference/inline-functions.html>`__


Kotlin tutorials

   The https://play.kotlinlang.org website includes rich tutorials called Kotlin
   Koans, a `web-based interpreter <https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt>`__,
   and a complete set of reference documentation with examples.


Udacity course

   To view the Udacity course on this topic, see 
   `Kotlin Bootcamp for Programmers <https://classroom.udacity.com/courses/ud9011>`__.


IntelliJ IDEA

   `Documentation for the IntelliJ IDEA <https://www.jetbrains.com/help/idea/>`__
   can be found on the JetBrains website.


Kotlin Standard Library

   The `Kotlin Standard Library <https://kotlinlang.org/api/latest/jvm/stdlib/>`__
   provides numerous useful functions. Before you write your own function or
   interface, always check the Standard Library to see if someone has saved you
   some work. Check back occasionally, because new functionality is added
   frequently.


Kotlin tutorials

   The https://play.kotlinlang.org website includes rich tutorials called Kotlin
   Koans, a `web-based interpreter <https://try.kotlinlang.org/#/Examples/Hello,%20world!/Simplest%20version/Simplest%20version.kt>`__,
   and a complete set of reference documentation with examples.


Udacity course

   To view the Udacity course on this topic, see `Kotlin Bootcamp for
   Programmers <https://classroom.udacity.com/courses/ud9011>`__.


IntelliJ IDEA

   `Documentation for the IntelliJ IDEA <https://www.jetbrains.com/help/idea/>`__
   can be found on the JetBrains website.


10. Homework
--------------------------------------------------------------------------------

   This section lists possible homework assignments for students who are working
   through this codelab as part of a course led by an instructor. It's up to the
   instructor to do the following:

   -  Assign homework if required.
   -  Communicate to students how to submit homework assignments.
   -  Grade the homework assignments.

   Instructors can use these suggestions as little or as much as they want, and
   should feel free to assign any other homework they feel is appropriate.

   If you're working through this codelab on your own, feel free to use these
   homework assignments to test your knowledge.


**Answer these questions**

**Question 1**

   In Kotlin, SAM stands for:

   *  â—» Safe Argument Matching
   *  â—» Simple Access Method
   *  â—» Single Abstract Method
   *  â—» Strategic Access Methodology


**Question 2**

   Which one of the following is not a Kotlin Standard Library extension function?

   *  â—» ``elvis()``
   *  â—» ``apply()``
   *  â—» ``run()``
   *  â—» ``with()``


**Question 3**

   Which one of the following is not true of lambdas in Kotlin?

   *  â—» Lambdas are anonymous functions.
   *  â—» Lambdas are objects unless inlined.
   *  â—» Lambdas are resource intensive and shouldn't be used.
   *  â—» Lambdas can be passed to other functions.


**Question 4**

   Labels in Kotlin are indicated with an identifier followed by:

   *  â—» ``:``
   *  â—» ``::``
   *  â—» ``@:``
   *  â—» ``@``


11. Next steps
--------------------------------------------------------------------------------

   Congratulations! You've completed the Kotlin Bootcamp for Programmers codelab.

   For an overview of the course, including links to other codelabs, see 
   `"Kotlin Bootcamp for Programmers: Welcome to the course." <https://codelabs.developers.google.cn/codelabs/kotlin-bootcamp-welcome/>`__

   If you're a Java programmer, you may be interested in the 
   `Refactoring to Kotlin <https://codelabs.developers.google.cn/codelabs/java-to-kotlin/>`__
   codelab. The automated Java to Kotlin conversion tools cover the basics, but you
   can create more concise, robust code with a little extra work.

   If you're interested in developing apps for Android, take a look at 
   `Android Kotlin Fundamentals <https://developer.android.google.cn/courses/kotlin-android-fundamentals/overview>`__.


â­ Converting to Kotlin
========================

https://developer.android.google.cn/codelabs/java-to-kotlin


1. Welcome!
-----------

   [This codelab is also available in `Chinese <https://developer.android.google.cn/codelabs/java-to-kotlin-zh/#0>`__ 
   and `Brazilian Portuguese <https://developer.android.google.cn/codelabs/java-to-kotlin-pt-br/#0>`__]

   In this codelab, you'll learn how to convert your code from Java to Kotlin. You'll also
   learn what the Kotlin language conventions are and how to ensure that the code you're
   writing follows them.

   This codelab is suited to any developer that uses Java who is considering migrating
   their project to Kotlin. We'll start with a couple of Java classes that you'll convert
   to Kotlin using the IDE. Then we'll take a look at the converted code and see how we
   can improve it by making it more `idiomatic <https://en.wikipedia.org/wiki/Programming_idiom>`__ 
   and avoid common pitfalls.


What you'll learn


   You will learn how to convert Java to Kotlin. In doing so you will learn the following
   Kotlin language features and concepts:

   -  Handling nullability
   -  Implementing singletons
   -  Data classes
   -  Handling strings
   -  Elvis operator
   -  Destructuring
   -  Properties and backing properties
   -  Default arguments and named parameters
   -  Working with collections
   -  Extension functions
   -  Top-level functions and parameters
   -  ``let``, ``apply``, ``with``, and ``run`` keywords


**Assumptions**


   You should already be familiar with Java.


What you'll need


   -  `Android Studio Bumblebee <https://developer.android.google.cn/studio/>`__ or
      `IntelliJ IDEA <https://www.jetbrains.com/idea/>`__

   Note that the auto-converter in future versions of Android Studio might create slightly
   different results.


2. Getting set up
-----------------


**Create a new project**


   If you're using IntelliJ IDEA, create a new Java project with Kotlin/JVM.

   If you're using Android Studio, create a new project with the *No Activity* template.
   Choose *Kotlin* as the project language. Minimum SDK can be of any value, it will not
   affect the outcome.


**The code**


   We'll create a ``User`` model object and a ``Repository`` singleton class that works
   with ``User`` objects and exposes lists of users and formatted user names.

   Create a new file called ``User.java`` under app/java/<*yourpackagename*> and paste in
   the following code:

   .. code:: prettyprint

      public class User {

          @Nullable
          private String firstName;
          @Nullable
          private String lastName;

          public User(String firstName, String lastName) {
              this.firstName = firstName;
              this.lastName = lastName;
          }

          public String getFirstName() {
              return firstName;
          }

          public void setFirstName(String firstName) {
              this.firstName = firstName;
          }

          public String getLastName() {
              return lastName;
          }

          public void setLastName(String lastName) {
              this.lastName = lastName;
          }

      }

   You'll notice your IDE is telling you ``@Nullable`` is not defined. So import
   ``androidx.annotation.Nullable`` if you use Android Studio, or
   ``org.jetbrains.annotations.Nullable`` if you're using IntelliJ.

   Create a new file called ``Repository.java`` and paste in the following code:

   .. code:: prettyprint

      import java.util.ArrayList;
      import java.util.List;

      public class Repository {

          private static Repository INSTANCE = null;

          private List<User> users = null;

          public static Repository getInstance() {
              if (INSTANCE == null) {
                  synchronized (Repository.class) {
                      if (INSTANCE == null) {
                          INSTANCE = new Repository();
                      }
                  }
              }
              return INSTANCE;
          }

          // keeping the constructor private to enforce the usage of getInstance
          private Repository() {

              User user1 = new User("Jane", "");
              User user2 = new User("John", null);
              User user3 = new User("Anne", "Doe");

              users = new ArrayList();
              users.add(user1);
              users.add(user2);
              users.add(user3);
          }

          public List<User> getUsers() {
              return users;
          }

          public List<String> getFormattedUserNames() {
              List<String> userNames = new ArrayList<>(users.size());
              for (User user : users) {
                  String name;

                  if (user.getLastName() != null) {
                      if (user.getFirstName() != null) {
                          name = user.getFirstName() + " " + user.getLastName();
                      } else {
                          name = user.getLastName();
                      }
                  } else if (user.getFirstName() != null) {
                      name = user.getFirstName();
                  } else {
                      name = "Unknown";
                  }
                  userNames.add(name);
              }
              return userNames;
          }
      }


3. Declaring nullability, val, var and data classes
---------------------------------------------------

   Our IDE can do a pretty good job of automatically converting Java code into Kotlin code
   but sometimes it needs a little help. Let's let our IDE do an initial pass at the
   conversion. Then we'll go through the resulting code to understand how and why it has
   been converted this way.

   The auto-converter in future versions of Android Studio might create different results.
   The results shown below were done using Android Studio 4.0.

   Go to the ``User.java`` file and convert it to Kotlin: **Menu bar -> Code -> Convert
   Java File to Kotlin File**.

   If your IDE prompts for correction after conversion, press **Yes**.

   |e6f96eace5dabe5f.png|

   You should see the following Kotlin code:

   .. code:: prettyprint

      class User(var firstName: String?, var lastName: String?)

   Note that ``User.java`` was renamed to ``User.kt``. Kotlin files have the extension .kt.

   Pro tip: If you paste Java code into a Kotlin file, the IDE will automatically convert
   the pasted code to Kotlin.

   In our Java ``User`` class we had two properties: ``firstName`` and ``lastName``. Each
   had a getter and setter method, making its value mutable. Kotlin's keyword for mutable
   variables is ``var``, so the converter uses ``var`` for each of these properties. If
   our Java properties had only getters, they would be read-only and would have been
   declared as ``val`` variables. ``val`` is similar to the ``final`` keyword in Java.

   One of the key differences between Kotlin and Java is that Kotlin explicitly specifies
   whether a variable can accept a null value. It does this by appending a ``?`` to the
   type declaration.

   Because we marked ``firstName`` and ``lastName`` as nullable, the auto-converter
   automatically marked the properties as nullable with ``String?``. If you annotate your
   Java members as non-null (using ``org.jetbrains.annotations.NotNull`` or
   ``androidx.annotation.NonNull``), the converter will recognize this and make the fields
   non-null in Kotlin as well.

   Pro tip: In Kotlin, we recommend using read-only and immutable objects wherever
   possible (i.e. using ``val`` instead of ``var``) and avoiding nullable types. You
   should strive to make nullability meaningful and something you want to handle
   specifically.

   The basic conversion is already done. But we can write this in a more idiomatic way.
   Let's see how.


**Data class**


   Our ``User`` class only holds data. Kotlin has a keyword for classes with this role:
   ``data``. By marking this class as a ``data`` class, the compiler will automatically
   create getters and setters for us. It will also derive the ``equals()``,
   ``hashCode()``, and ``toString()`` functions.

   Let's add the ``data`` keyword to our ``User`` class:

   .. code:: prettyprint

      data class User(var firstName: String?, var lastName: String?)

   Kotlin, like Java, can have a primary constructor and one or more secondary
   constructors. The one in the example above is the primary constructor of the ``User``
   class. If you're converting a Java class that has multiple constructors, the converter
   will automatically create multiple constructors in Kotlin as well. They are defined
   using the ``constructor`` keyword.

   Read more about constructors in the `official documentation <https://kotlinlang.org/docs/reference/classes.html#constructors>`__.

   If we want to create an instance of this class, we can do it like this:

   .. code:: prettyprint

      val user1 = User("Jane", "Doe")


**Equality**


   Kotlin has two types of equality:

   -  Structural equality uses the ``==`` operator and calls ``equals()`` to determine if
      two instances are equal.
   -  Referential equality uses the ``===`` operator and checks if two references point to
      the same object.

   The properties defined in the primary constructor of the data class will be used for
   structural equality checks.

   .. code:: prettyprint

      val user1 = User("Jane", "Doe")
      val user2 = User("Jane", "Doe")
      val structurallyEqual = user1 == user2 // true
      val referentiallyEqual = user1 === user2 // false

   Read more about data classes in the `official documentation <https://kotlinlang.org/docs/reference/data-classes.html#data-classes>`__.


4. Default arguments, named arguments
-------------------------------------

   In Kotlin, we can assign default values to arguments in function calls. The default
   value is used when the argument is omitted. In Kotlin, constructors are also functions,
   so we can use default arguments to specify that the default value of ``lastName`` is
   ``null``. To do this, we just assign ``null`` to ``lastName``.

   .. code:: prettyprint

      data class User(var firstName: String?, var lastName: String? = null)

      // usage
      val jane = User("Jane") // same as User("Jane", null)
      val joe = User("Joe", "Doe")

   Kotlin allows you to label your arguments when your functions are called:

   .. code:: prettyprint

      val john = User(firstName = "John", lastName = "Doe") 

   As a different use case, let's say that the ``firstName`` has ``null`` as its default
   value and ``lastName`` does not. In this case, because the default parameter would
   precede a parameter with no default value, you must call the function with named
   arguments:

   .. code:: prettyprint

      data class User(var firstName: String? = null, var lastName: String?)

      // usage
      val jane = User(lastName = "Doe") // same as User(null, "Doe")
      val john = User("John", "Doe")

   Default values are an important and often used concept in Kotlin code. In our codelab
   we want to always specify the first and last name in a ``User`` object declaration, so
   we don't need default values.

   If your function has multiple parameters, consider using `named arguments <https://kotlinlang.org/docs/reference/functions.html?_ga=2.40893098.969837971.1560273584-565456768.1516189658#named-arguments>`__
   as they make the code more readable.


5. Object initialization, companion object and singletons
---------------------------------------------------------

   Before continuing the codelab, make sure that your ``User`` class is a **``data``**
   class. Now, let's convert the ``Repository`` class to Kotlin. The automatic conversion
   result should look like this:

   .. code:: prettyprint

      import java.util.*

      class Repository private constructor() {
          private var users: MutableList<User?>? = null
          fun getUsers(): List<User?>? {
              return users
          }

          val formattedUserNames: List<String?>
              get() {
                  val userNames: MutableList<String?> =
                      ArrayList(users!!.size)
                  for (user in users) {
                      var name: String
                      name = if (user!!.lastName != null) {
                          if (user!!.firstName != null) {
                              user!!.firstName + " " + user!!.lastName
                          } else {
                              user!!.lastName
                          }
                      } else if (user!!.firstName != null) {
                          user!!.firstName
                      } else {
                          "Unknown"
                      }
                      userNames.add(name)
                  }
                  return userNames
              }

          companion object {
              private var INSTANCE: Repository? = null
              val instance: Repository?
                  get() {
                      if (INSTANCE == null) {
                          synchronized(Repository::class.java) {
                              if (INSTANCE == null) {
                                  INSTANCE =
                                      Repository()
                              }
                          }
                      }
                      return INSTANCE
                  }
          }

          // keeping the constructor private to enforce the usage of getInstance
          init {
              val user1 = User("Jane", "")
              val user2 = User("John", null)
              val user3 = User("Anne", "Doe")
              users = ArrayList<Any?>()
              users.add(user1)
              users.add(user2)
              users.add(user3)
          }
      }

   Let's see what the automatic converter did:

   -  The list of ``users`` is nullable since the object wasn't instantiated at
      declaration time
   -  Functions in Kotlin like ``getUsers()`` are declared with the ``fun`` modifier
   -  The ``getFormattedUserNames()`` method is now a property called
      ``formattedUserNames``
   -  The iteration over the list of users (that was initially part of
      ``getFormattedUserNames(``) ) has a different syntax than the Java one
   -  The ``static`` field is now part of a ``companion object`` block
   -  An ``init`` block was added

   **Note**: The generated code doesn't compile. Don't worry about it, we'll change it in
   the next steps.

   Before we go further, let's clean up the code a bit. If we look in the constructor, we
   notice the converter made our ``users`` list a mutable list that holds nullable
   objects. While the list can indeed be null, let's assume it can't hold null users. So
   let's do the following:

   -  Remove the ``?`` in ``User?`` within the ``users`` type declaration
   -  Remove the ``?`` in ``User?`` for the return type of ``getUsers()`` so it returns
      ``List<User>?``


**Init block**


   In Kotlin, the primary constructor cannot contain any code, so initialization code is
   placed in ``init`` blocks. The functionality is the same.

   .. code:: prettyprint

      class Repository private constructor() {
          ...
          init {
              val user1 = User("Jane", "")
              val user2 = User("John", null)
              val user3 = User("Anne", "Doe")
              users = ArrayList<Any?>()
              users.add(user1)
              users.add(user2)
              users.add(user3)
          }
      }

   Much of the ``init`` code handles initializing properties. This can also be done in the
   declaration of the property. For example, in the Kotlin version of our ``Repository``
   class, we see that the users property was initialized in the declaration.

   .. code:: prettyprint

      private var users: MutableList<User>? = null

   Find out more about initializer blocks from the `official documentation <https://kotlinlang.org/docs/reference/classes.html#constructors>`__.


Kotlin's ``static`` **properties and methods**


   In Java, we use the ``static`` keyword for fields or functions to say that they belong
   to a class but not to an instance of the class. This is why we created the ``INSTANCE``
   static field in our ``Repository`` class. The Kotlin equivalent for this is the
   ``companion object`` block. Here you would also declare the static fields and static
   functions. The converter created the companion object block and moved the ``INSTANCE``
   field here.


**Handling singletons**


   Because we need only one instance of the ``Repository`` class, we used the 
   `singleton pattern <https://en.wikipedia.org/wiki/Singleton_pattern>`__ 
   in Java. With Kotlin, you can enforce this pattern at the compiler level by 
   replacing the ``class`` keyword with ``object``.

   Remove the private constructor and replace the class definition with
   ``object Repository``. Remove the companion object as well.

   .. code:: prettyprint

      object Repository {

          private var users: MutableList<User>? = null
          fun getUsers(): List<User>? {
             return users
          }

          val formattedUserNames: List<String>
              get() {
                  val userNames: MutableList<String> =
                      ArrayList(users!!.size)
              for (user in users) {
                  var name: String
                  name = if (user!!.lastName != null) {
                      if (user!!.firstName != null) {
                          user!!.firstName + " " + user!!.lastName
                      } else {
                          user!!.lastName
                      }
                  } else if (user!!.firstName != null) {
                      user!!.firstName
                  } else {
                      "Unknown"
                  }
                  userNames.add(name)
             }
             return userNames
         }

          // keeping the constructor private to enforce the usage of getInstance
          init {
              val user1 = User("Jane", "")
              val user2 = User("John", null)
              val user3 = User("Anne", "Doe")
              users = ArrayList<Any?>()
              users.add(user1)
              users.add(user2)
              users.add(user3)
          }
      }

   When using the ``object`` class, we just call functions and properties directly on the
   object, like this:

   .. code:: prettyprint

      val formattedUserNames = Repository.formattedUserNames

   Note that if a property does not have a visibility modifier on it, it is public by
   default, as in the case of ``formattedUserNames`` property in the ``Repository``
   object.

   Find out more about objects and companion objects from the `official documentation <https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html>`__.


6. Handling nullability
-----------------------

   When converting the ``Repository`` class to Kotlin, the automatic converter made the
   list of users nullable, because it wasn't initialized to an object when it was
   declared. As a result, for all the usages of the ``users`` object, the not-null
   assertion operator ``!!`` needs to be used. (You'll see ``users!!`` and ``user!!``
   throughout the converted code.) The ``!!`` operator converts any variable to a non-null
   type, so you can access properties or call functions on it. However, an exception will
   be thrown if the variable value is indeed null. By using ``!!``, you're risking
   exceptions being thrown at runtime.

   Instead, prefer handling nullability by using one of these methods:

   -  Doing a null check ( ``if (users != null) {...}`` )
   -  Using the `elvis operator <https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator>`__
      ``?:`` (covered later in the codelab)
   -  Using some of the Kotlin standard functions (covered later in the codelab)

   Find out more about null safety from the `official documentation <https://kotlinlang.org/docs/reference/null-safety.html#null-safety>`__.

   In our case, we know that the list of users doesn't need to be nullable, since it's
   initialized right after the object is constructed (in the ``init`` block). Thus we can
   directly instantiate the ``users`` object when we declare it.

   When creating instances of collection types, Kotlin provides several helper functions
   to make your code more readable and flexible. Here we're using a ``MutableList`` for
   ``users``:

   .. code:: prettyprint

      private var users: MutableList<User>? = null

   For simplicity, we can use the `mutableListOf() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/mutable-list-of.html>`__
   function and provide the list element type. ``mutableListOf<User>()`` creates an empty
   list that can hold ``User`` objects. Since the data type of the variable can now be
   inferred by the compiler, remove the explicit type declaration of the ``users``
   property.

   .. code:: prettyprint

      private val users = mutableListOf<User>()

   We also changed ``var`` into ``val`` because users will contain a read-only reference
   to the list of users. Note that the reference is read-only, so it can never point to a
   new list, but the list itself is still mutable (you can add or remove elements).

   Since the ``users`` variable is already initialized, remove this initialization from
   the ``init`` block:

   .. code:: prettyprint

      users = ArrayList<Any?>()

   Then the ``init`` block should look like this:

   .. code:: prettyprint

      init {
          val user1 = User("Jane", "")
          val user2 = User("John", null)
          val user3 = User("Anne", "Doe")

          users.add(user1)
          users.add(user2)
          users.add(user3)
      }

   With these changes, our ``users`` property is now non-null, and we can remove all the
   unnecessary ``!!`` operator occurrences. Note that you will still see compile errors in
   Android Studio, but continue with the next few steps of the codelabs to resolve them.

   .. code:: prettyprint

      val userNames: MutableList<String?> = ArrayList(users.size)

   .. code:: prettyprint

      for (user in users) {
          var name: String
          name = if (user.lastName != null) {
              if (user.firstName != null) {
                  user.firstName + " " + user.lastName
              } else {
                  user.lastName
              }
          } else if (user.firstName != null) {
              user.firstName
          } else {
              "Unknown"
          }
          userNames.add(name)
      }

   Also, for the ``userNames`` value, if you specify the type of ``ArrayList`` as holding
   ``Strings``, then you can remove the explicit type in the declaration because it will
   be inferred.

   .. code:: prettyprint

      val userNames = ArrayList<String>(users.size)


**Destructuring**


   Kotlin allows destructuring an object into a number of variables, using a syntax called
   *destructuring declaration*. We create multiple variables and can use them
   independently.

   For example, ``data`` classes support destructuring so we can destructure the ``User``
   object in the ``for`` loop into ``(firstName, lastName)``. This allows us to work
   directly with the ``firstName`` and ``lastName`` values. Update the ``for`` loop as
   shown below. Replace all instances of ``user.firstName`` with ``firstName`` and replace
   ``user.lastName`` with ``lastName``.

   .. code:: prettyprint

      for ((firstName, lastName) in users) {
          var name: String
          name = if (lastName != null) {
              if (firstName != null) {
                  firstName + " " + lastName
              } else {
                  lastName
              }
          } else if (firstName != null) {
              firstName
          } else {
              "Unknown"
          }
          userNames.add(name)
      }

   Read more about destructuring declarations in the `official documentation <https://kotlinlang.org/docs/reference/multi-declarations.html>`__.


**if expression**


   The names in the list of userNames are not quite in the format that we want yet. Since
   both ``lastName`` and ``firstName`` can be ``null``, we need to handle nullability when
   we build the list of formatted user names. We want to display ``"Unknown"`` if either
   name is missing. Since the ``name`` variable will not be changed after it's set once,
   we can use ``val`` instead of ``var``. Make this change first.

   .. code:: prettyprint

      val name: String

   Take a look at the code that sets the name variable. It may look new to you to see a
   variable being set to equal an ``if`` / ``else`` block of code. This is allowed because
   in Kotlin ``if`` and ``when`` are expressionsâ€”they return a value. The last line of the
   ``if`` statement will be assigned to ``name``. This block's only purpose is to
   initialize the ``name`` value.

   Essentially, this logic presented here is if the ``lastName`` is null, ``name`` is
   either set to the ``firstName`` or ``"Unknown"``.

   .. code:: prettyprint

      name = if (lastName != null) {
          if (firstName != null) {
              firstName + " " + lastName
          } else {
              lastName
          }
      } else if (firstName != null) {
          firstName
      } else {
          "Unknown"
      }

   Read more about ``if`` and ``when`` in the `official documentation <https://kotlinlang.org/docs/control-flow.html#if-expression>`__.


**Elvis operator**


   This code can be written more idiomatically by using the `elvis operator <https://en.wikipedia.org/wiki/Elvis_operator>`__ 
   ``?:``. The elvis operator will return the expression on its left hand side if it's 
   not null, or the expression on its right hand side, if the left hand side is null.

   So in the following code, ``firstName`` is returned if it is not null. If ``firstName``
   is null, the expression returns the value on the right hand , ``"Unknown"``:

   .. code:: prettyprint

      name = if (lastName != null) {
          ...
      } else {
          firstName ?: "Unknown"
      }

   Read more about the elvis operator in the `official documentation <https://kotlinlang.org/docs/null-safety.html#elvis-operator>`__.


7. String templates
-------------------

   Kotlin makes working with ``String``s easy with `String templates <https://kotlinlang.org/docs/reference/basic-syntax.html#using-string-templates>`__.
   String templates allow you to reference variables inside string declarations by using
   the $ symbol before the variable. You could also put an expression within a string
   declaration, by placing the expression within { } and using the $ symbol before it.
   Example: ``${user.firstName}``.

   Your code currently uses string concatenation to combine the ``firstName`` and
   ``lastName`` into the user name.

   .. code:: prettyprint

      if (firstName != null) {
          firstName + " " + lastName
      }

   Instead, replace the String concatenation with:

   .. code:: prettyprint

      if (firstName != null) {
          "$firstName $lastName"
      }

   Using string templates can simplify your code.

   Your IDE will show you warnings if there is a more idiomatic way to write your code.
   You'll notice a squiggly underline in the code, and when you hover over it, you'll see
   a suggestion for how to refactor your code.

   Currently, you should see a warning that the ``name`` declaration can be joined with
   the assignment. Let's apply this. Because the type of the ``name`` variable can be
   deduced, we can remove the explicit ``String`` type declaration. Now our
   ``formattedUserNames`` looks like this:

   .. code:: prettyprint

      val formattedUserNames: List<String?>
          get() {
              val userNames = ArrayList<String>(users.size)
              for ((firstName, lastName) in users) {
                  val name = if (lastName != null) {
                      if (firstName != null) {
                          "$firstName $lastName"
                      } else {
                          lastName
                      }
                  } else {
                      firstName ?: "Unknown"
                  }
                  userNames.add(name)
              }
              return userNames
          }

   We can make one additional tweak. Our UI logic displays ``"Unknown"`` in case the first
   and last names are missing, so we're not supporting null objects. Thus, for the data
   type of ``formattedUserNames`` replace ``List<String?>`` with ``List<String>``.

   .. code:: prettyprint

      val formattedUserNames: List<String>


8. Operations on collections
----------------------------

   Let's take a closer look at the ``formattedUserNames`` getter and see how we can make
   it more idiomatic. Right now the code does the following:

   -  Creates a new list of strings
   -  Iterates through the list of users
   -  Constructs the formatted name for each user, based on the user's first and last name
   -  Returns the newly created list

   .. code:: prettyprint

          val formattedUserNames: List<String>
              get() {
                  val userNames = ArrayList<String>(users.size)
                  for ((firstName, lastName) in users) {
                      val name = if (lastName != null) {
                          if (firstName != null) {
                              "$firstName $lastName"
                          } else {
                              lastName
                          }
                      } else {
                          firstName ?: "Unknown"
                      }
                      userNames.add(name)
                  }
                  return userNames
              }

   Kotlin provides an extensive list of `collection transformations <https://kotlinlang.org/docs/reference/collection-transformations.html>`__
   that make development faster and safer by expanding the capabilities of the Java
   Collections API. One of them is the `map <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map.html>`__
   function. This function returns a new list containing the results of applying the given
   transform function to each element in the original list. So, instead of creating a new
   list and iterating through the list of users manually, we can use the ``map`` function
   and move the logic we had in the ``for`` loop inside the ``map`` body. By default, the
   name of the current list item used in ``map`` is `it <https://kotlinlang.org/docs/reference/lambdas.html?_ga=2.51454505.1883141324.1588651372-527214030.1582762539#it-implicit-name-of-a-single-parameter>`__,
   but for readability you can replace ``it`` with your own variable name. In our case,
   let's name it ``user``:

   .. code:: prettyprint

      val formattedUserNames: List<String>
              get() {
                  return users.map { user ->
                      val name = if (user.lastName != null) {
                          if (user.firstName != null) {
                              "${user.firstName} ${user.lastName}"
                          } else {
                              user.lastName ?: "Unknown"
                          }
                      }  else {
                          user.firstName ?: "Unknown"
                      }
                      name
                  }
              }

   Notice that we use the Elvis operator to return ``"Unknown"`` if ``user.lastName`` is
   null, since ``user.lastName`` is of type ``String?`` and a ``String`` is required for
   the ``name``.

   .. code:: prettyprint

      ...
      else {
          user.lastName ?: "Unknown"
      }
      ...

   To simplify this even more, we can remove the ``name`` variable completely:

   .. code:: prettyprint

      val formattedUserNames: List<String>
              get() {
                  return users.map { user ->
                      if (user.lastName != null) {
                          if (user.firstName != null) {
                              "${user.firstName} ${user.lastName}"
                          } else {
                              user.lastName ?: "Unknown"
                          }
                      }  else {
                          user.firstName ?: "Unknown"
                      }
                  }
              }

   As well as collection transformations, the Kotlin Standard Library provides a wide
   array of tools to manage your `collections <https://kotlinlang.org/docs/reference/collections-overview.html>`__. 
   From different collection types to a variety of `operations <https://kotlinlang.org/docs/reference/collection-operations.html>`__
   specific to either the general ``Collection`` type or to different subtypes like
   `List <https://kotlinlang.org/docs/reference/list-operations.html>`__ or
   `Set <https://kotlinlang.org/docs/reference/set-operations.html>`__.

   In general, when working with collections, make sure you check whether the
   functionality you're planning on writing in Kotlin is already implemented by the
   Standard Library and prefer using that one to your own implementation.


9. Properties and backing properties
------------------------------------

   We saw that the automatic converter replaced the ``getFormattedUserNames()`` function
   with a property called ``formattedUserNames`` that has a custom getter. Under the hood,
   Kotlin still generates a ``getFormattedUserNames()`` method that returns a ``List``.

   In Java, we would expose our class properties via getter and setter functions. Kotlin
   allows us to have a better differentiation between properties of a class, expressed
   with fields, and functionalities, actions that a class can do, expressed with
   functions. In our case, the ``Repository`` class is very simple and doesn't do any
   actions so it only has fields.

   The logic that was triggered in the Java ``getFormattedUserNames()`` function is now
   triggered when calling the getter of the ``formattedUserNames`` Kotlin property.

   While we don't explicitly have a field corresponding to the ``formattedUserNames``
   property, Kotlin does provide us an automatic backing field named ``field`` which we
   can access if needed from custom getters and setters.

   Sometimes, however, we want some extra functionality that the automatic backing field
   doesn't provide.

   Let's go through an example.

   Inside our ``Repository`` class, we have a mutable list of users which is being exposed
   in the function ``getUsers()`` which was generated from our Java code:

   .. code:: prettyprint

      fun getUsers(): List<User>? {
          return users
      }

   Because we didn't want the callers of the ``Repository`` class to modify the users
   list, we created the ``getUsers()`` function that returns a read-only ``List<User>``.
   With Kotlin, we prefer using properties rather than functions for such cases. More
   precisely, we would expose a read-only ``List<User>`` that is backed by a
   ``mutableListOf<User>``.

   First, let's rename ``users`` to ``_users``. Highlight the variable name, right click
   to **Refactor > Rename** the variable. Then add a public read-only property that
   returns a list of users. Let's call it ``users``:

   .. code:: prettyprint

      private val _users = mutableListOf<User>()
      val users: List<User>
          get() = _users

   At this point, you can delete the ``getUsers()`` method.

   With the above change, the private ``_users`` property becomes the *backing property*
   for the public ``users`` property. Outside of the ``Repository`` class, the ``_users``
   list is not modifiable, as consumers of the class can access the list only through
   ``users``.

   When ``users`` is called from Kotlin code, the ``List`` implementation from the Kotlin
   Standard Library is used, where the list is not modifiable. If ``users`` is called from
   Java, the ``java.util.List`` implementation is used, where the list is modifiable and
   operations like add() and remove() are available.

   The convention for backing properties is to use a leading underscore.

   Find out more about properties from the `official documentation <https://kotlinlang.org/docs/reference/properties.html#properties-and-fields>`__.

   Full code:

   .. code:: prettyprint

      object Repository {

          private val _users = mutableListOf<User>()
          val users: List<User>
              get() = _users

          val formattedUserNames: List<String>
              get() {
                  return _users.map { user ->
                      if (user.lastName != null) {
                          if (user.firstName != null) {
                              "${user.firstName} ${user.lastName}"
                          } else {
                              user.lastName ?: "Unknown"
                          }
                      }  else {
                          user.firstName ?: "Unknown"
                      }
                  }
              }

          init {
              val user1 = User("Jane", "")
              val user2 = User("John", null)
              val user3 = User("Anne", "Doe")

              _users.add(user1)
              _users.add(user2)
              _users.add(user3)
          }
      }


10. Top-level and extension functions and properties
----------------------------------------------------

   Right now the ``Repository`` class knows how to compute the formatted user name for a
   ``User`` object. But if we want to reuse the same formatting logic in other classes, we
   need to either copy and paste it or move it to the ``User`` class.

   Kotlin provides the ability to declare functions and properties outside of any class,
   object, or interface. For example, the ``mutableListOf()`` function we used to create a
   new instance of a ``List`` is already defined in `Collections.kt <https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/collections/Collections.kt#L90>`__
   from the Kotlin Standard Library.

   In Java, whenever you need some utility functionality, you would most likely create a
   ``Util`` class and declare that functionality as a static function. In Kotlin you can
   declare top-level functions, without having a class. However, Kotlin also provides the
   ability to create **extension functions**. These are functions that extend a certain
   type but are declared outside of the type.

   To extend the functionality of a class, either because we don't own the class or
   because it's not open to inheritance, Kotlin created special declarations called
   **extensions**. Kotlin supports extension functions and extension properties.

   The visibility of extension functions and properties can be restricted by using
   visibility modifiers. These restrict the usage only to classes that need the
   extensions, and don't pollute the namespace.

   For the ``User`` class, we can either add an extension function that computes the
   formatted name, or we can hold the formatted name in an extension property. It can be
   added outside the ``Repository`` class, in the same file:

   .. code:: prettyprint

      // extension function
      fun User.getFormattedName(): String {
          return if (lastName != null) {
              if (firstName != null) {
                  "$firstName $lastName"
              } else {
                  lastName ?: "Unknown"
              }
          } else {
              firstName ?: "Unknown"
          }
      }

      // extension property
      val User.userFormattedName: String
          get() {
              return if (lastName != null) {
                  if (firstName != null) {
                      "$firstName $lastName"
                  } else {
                      lastName ?: "Unknown"
                  }
              } else {
                  firstName ?: "Unknown"
              }
          }

      // usage:
      val user = User(...)
      val name = user.getFormattedName()
      val formattedName = user.userFormattedName

   We can then use the extension functions and properties as if they're part of the
   ``User`` class.

   Because the formatted name is a property of the ``User`` class and not a functionality
   of the ``Repository`` class, let's use the extension property. Our ``Repository`` file
   now looks like this:

   .. code:: prettyprint

      val User.formattedName: String
          get() {
              return if (lastName != null) {
                  if (firstName != null) {
                      "$firstName $lastName"
                  } else {
                      lastName ?: "Unknown"
                  }
              } else {
                  firstName ?: "Unknown"
              }
          }

      object Repository {

          private val _users = mutableListOf<User>()
          val users: List<User>
            get() = _users

          val formattedUserNames: List<String>
              get() {
                  return _users.map { user -> user.formattedName }
              }

          init {
              val user1 = User("Jane", "")
              val user2 = User("John", null)
              val user3 = User("Anne", "Doe")

              _users.add(user1)
              _users.add(user2)
              _users.add(user3)
          }
      }

   The `Kotlin Standard Library <https://kotlinlang.org/api/latest/jvm/stdlib/index.html>`__ 
   uses extension functions to extend the functionality of several Java APIs; a lot of the
   functionalities on ``Iterable`` and ``Collection`` are implemented as extension
   functions. For example, the ``map`` function we used in a previous step is an extension
   function on ``Iterable``.


11. Scope functions: let, apply, with, run, also
------------------------------------------------

   In our ``Repository`` class code, we are adding several ``User`` objects to the
   ``_users`` list. These calls can be made more idiomatic with the help of Kotlin scope
   functions.

   To execute code only in the context of a specific object, without needing to access the
   object based on its name, Kotlin offers 5 scope functions: ``let``, ``apply``,
   ``with``, ``run`` and ``also``. These functions make your code easier to read and more
   concise. All scope functions have a receiver (``this``), may have an argument (``it``)
   and may return a value.

   Here's a handy cheat sheet to help you remember when to use each function:

   |6b9283d411fb6e7b.png|

   Download the scope functions cheat sheet from `here <https://medium.com/androiddevelopers/kotlin-standard-functions-cheat-sheet-27f032dd4326>`__.

   Since we're configuring our ``_users`` object in our ``Repository``, we can make the
   code more idiomatic by using the ``apply`` function:

   .. code:: prettyprint

      init {
          val user1 = User("Jane", "")
          val user2 = User("John", null)
          val user3 = User("Anne", "Doe")
         
          _users.apply {
             // this == _users
             add(user1)
             add(user2)
             add(user3)
          }
       }

   Find out more about scope functions from the `official documentation <https://kotlinlang.org/docs/reference/scope-functions.html>`__.


12. Wrap up
-----------

   In this codelab, we covered the basics you need to start converting your code from Java
   to Kotlin. This conversion is independent of your development platform and helps to
   ensure that the code you write is idiomatic Kotlin.

   Idiomatic Kotlin makes writing code short and sweet. With all the features Kotlin
   provides, there are so many ways to make your code safer, more concise, and more
   readable. For example, we can even optimize our ``Repository`` class by instantiating
   the ``_users`` list with users directly in the declaration, getting rid of the ``init``
   block:

   .. code:: prettyprint

      private val users = mutableListOf(User("Jane", ""), User("John", null), User("Anne", "Doe"))

   We covered a large array of topics, from handling nullability, singletons, Strings, and
   collections to topics like extension functions, top-level functions, properties, and
   scope functions. We went from two Java classes to two Kotlin ones that now look like
   this:


**User.kt**


   .. code:: prettyprint

      data class User(var firstName: String?, var lastName: String?)


**Repository.kt**


   .. code:: prettyprint

      val User.formattedName: String
          get() {
             return if (lastName != null) {
                  if (firstName != null) {
                      "$firstName $lastName"
                  } else {
                      lastName ?: "Unknown"
                  }
              } else {
                  firstName ?: "Unknown"
              }
          }

      object Repository {

          private val _users = mutableListOf(User("Jane", ""), User("John", null), User("Anne", "Doe"))
          val users: List<User>
              get() = _users

          val formattedUserNames: List<String>
              get() = _users.map { user -> user.formattedName }
      }

   Here's a TL;DR of the Java functionalities and their mapping to Kotlin:

   ================================= =======================================================
   **Java**                          **Kotlin**
   ================================= =======================================================
   ``final`` object                  ``val`` object
   ``equals()``                      ``==``
   ``==``                            ``===``
   Class that just holds data        ``data`` class
   Initialization in the constructor Initialization in the ``init`` block
   ``static`` fields and functions   fields and functions declared in a ``companion object``
   Singleton class                   ``object``
   ================================= =======================================================

   Note that one of the benefits of Kotlin is that it's 100% interoperable with the Java
   programming language. Call Java-based code from Kotlin, or call Kotlin from Java-based
   code. You can have as little or as much of Kotlin in your project as you want.

   To find out more about Kotlin and how to use it on your platform, check out these
   resources:

   -  `Kotlin Koans <https://play.kotlinlang.org/koans/overview>`__
   -  `Kotlin Tutorials <https://kotlinlang.org/docs/tutorials/>`__
   -  `Android Kotlin Fundamentals <https://developer.android.google.cn/courses/kotlin-android-fundamentals/overview>`__
   -  `Kotlin Bootcamp for Programmers <https://developer.android.google.cn/courses/kotlin-bootcamp/overview>`__
   -  `Kotlin for Java developers <https://www.coursera.org/learn/kotlin-for-java-developers>`__ - free
      course in Audit mode

.. |e6f96eace5dabe5f.png| image:: https://developer.android.google.cn/static/codelabs/java-to-kotlin/img/e6f96eace5dabe5f.png
.. |6b9283d411fb6e7b.png| image:: https://developer.android.google.cn/static/codelabs/java-to-kotlin/img/6b9283d411fb6e7b.png


â­ Java è°ƒç”¨ Kotlin ä»£ç 
========================

https://developer.android.google.cn/codelabs/java-friendly-kotlin


æ¬¢è¿ï¼
----------------------------

   åœ¨æ­¤ Codelab ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•ç¼–å†™æˆ–ä¿®æ”¹ Kotlin ä»£ç ï¼Œä»è€Œæ›´åŠ é¡ºç•…åœ°åœ¨ Java ä»£ç ä¸­è°ƒç”¨
   Kotlin ä»£ç ã€‚


**å­¦ä¹ å†…å®¹**

   -  å¦‚ä½•ä½¿ç”¨ ``@JvmField``ã€``@JvmStatic`` å’Œå…¶ä»–æ³¨è§£ã€‚
   -  åœ¨é€šè¿‡ Java ä»£ç è®¿é—®æŸäº› Kotlin è¯­è¨€åŠŸèƒ½æ–¹é¢å­˜åœ¨çš„é™åˆ¶ã€‚


å‡†å¤‡å·¥ä½œ
----------------------------

**å­¦å‰é¡»çŸ¥**

   æ­¤ Codelab æ˜¯ä¸“ä¸ºç¨‹åºå‘˜ç¼–å†™çš„ï¼Œå› æ­¤æˆ‘ä»¬å‡å®šæ‚¨å…·å¤‡ Java å’Œ Kotlin æ–¹é¢çš„åŸºç¡€çŸ¥è¯†ã€‚

   æ­¤ Codelab ä¼šæ¨¡æ‹Ÿå¯¹ä¸€ä¸ªä½¿ç”¨ Java ç¼–ç¨‹è¯­è¨€ç¼–å†™çš„å¤§å‹é¡¹ç›®çš„éƒ¨åˆ†å†…å®¹è¿›è¡Œè¿ç§»ï¼Œä»¥ä¾¿ä¸æ–°çš„
   Kotlin ä»£ç æ•´åˆçš„è¿‡ç¨‹ã€‚

   ä¸ºç®€å•èµ·è§ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªåä¸º ``UseCase.java`` çš„ ``.java``
   æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶å°†ä»£è¡¨ç°æœ‰ä»£ç åº“ã€‚

   æˆ‘ä»¬å°†å‡å®šï¼Œæˆ‘ä»¬åˆšåˆšå°†æœ€åˆä½¿ç”¨ Java ç¼–å†™çš„éƒ¨åˆ†åŠŸèƒ½æ›¿æ¢ä¸ºä½¿ç”¨ Kotlin
   ç¼–å†™çš„æ–°ç‰ˆæœ¬ï¼Œå¹¶ä¸”æˆ‘ä»¬éœ€è¦å®Œæˆç›¸å…³çš„é›†æˆã€‚

   ç”±äºæˆ‘ä»¬è¦æ¨¡æ‹Ÿé‡æ„ä»£ç çš„è¿‡ç¨‹ï¼Œå› æ­¤é¡¹ç›®åœ¨å¯¼å…¥åä¼šå­˜åœ¨ä¸€äº›é”™è¯¯ã€‚è¿™æ˜¯æ­£å¸¸ç°è±¡ã€‚æˆ‘ä»¬ä¼šåœ¨åç»­æ­¥éª¤ä¸­å°†è¿™äº›é—®é¢˜å…¨éƒ¨è§£å†³ã€‚


å¯¼å…¥é¡¹ç›®

   æ‚¨å¯ä»¥è®¿é—® GitHub é¡¹ç›®ä»£ç ï¼š `GitHub <https://github.com/googlecodelabs/java-friendly-kotlin>`__

   æˆ–è€…ï¼Œæ‚¨ä¹Ÿå¯ä»¥è®¿é—®ä»¥ä¸‹ç½‘å€ä»¥ä¸‹è½½ ZIP å½’æ¡£æ–‡ä»¶å¹¶ä»ä¸­è§£å‹é¡¹ç›®ï¼š

   `ä¸‹è½½ Zip æ–‡ä»¶ <https://github.com/googlecodelabs/java-friendly-kotlin/archive/master.zip>`__

   å¦‚æœæ‚¨ä½¿ç”¨çš„æ˜¯ IntelliJ IDEAï¼Œè¯·é€‰æ‹©â€œImport Projectâ€ã€‚

   å¦‚æœæ‚¨ä½¿ç”¨çš„æ˜¯ Android Studioï¼Œè¯·é€‰æ‹©â€œImport project (Gradle, Eclipse ADT, etc.)â€ã€‚


ä»£ç åº“å’Œ @JvmStatic
----------------------------

   è¯·æ‰“å¼€ ``UseCase.java``ï¼Œç„¶åå¼€å§‹å¤„ç†æˆ‘ä»¬çœ‹åˆ°çš„é”™è¯¯ã€‚

   ç¬¬ä¸€ä¸ªæœ‰é—®é¢˜çš„å‡½æ•°æ˜¯ ``registerGuest``ï¼š

   ::

      public static User registerGuest(String name) {
         User guest = new User(Repository.getNextGuestId(), StringUtils.nameToLogin(name), name);
         Repository.addUser(guest);
         return guest;
      }

   ``Repository.getNextGuestId()`` å’Œ ``Repository.addUser(...)``
   çš„é”™è¯¯æ˜¯ç›¸åŒçš„ï¼šâ€œNon-static cannot be accessed from a static contextâ€ã€‚

   ç°åœ¨ï¼Œæˆ‘ä»¬è¦çœ‹ä¸€çœ‹å…¶ä¸­ä¸€ä¸ª Kotlin æ–‡ä»¶ã€‚æ‰“å¼€æ–‡ä»¶ ``Repository.kt``ã€‚

   å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬çš„ä»£ç åº“æ˜¯é€šè¿‡ä½¿ç”¨å¯¹è±¡å…³é”®å­—è¿›è¡Œå£°æ˜çš„å•ä¾‹ã€‚é—®é¢˜åœ¨äºï¼ŒKotlin
   ä¼šåœ¨ç±»å†…éƒ¨ç”Ÿæˆé™æ€å®ä¾‹ï¼Œè€Œä¸æ˜¯å°†å…¶ä½œä¸ºé™æ€å±æ€§å’Œæ–¹æ³•å…¬å¼€ã€‚

   ä¾‹å¦‚ï¼Œè‹¥è¦å¼•ç”¨ ``Repository.getNextGuestId()``ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨
   ``Repository.INSTANCE.getNextGuestId()`` æ¥å®ç°ï¼Œä½†ä¹Ÿå¯ä»¥é‡‡ç”¨æ›´å¥½çš„æ–¹å¼ã€‚

   æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ ``@JvmStatic`` ä¸ºä»£ç åº“çš„å…¬å…±å±æ€§å’Œæ–¹æ³•æ·»åŠ æ³¨è§£ï¼Œä»è€Œè®© Kotlin
   ç”Ÿæˆé™æ€æ–¹æ³•å’Œå±æ€§ï¼š

   ::

      object Repository {
         val BACKUP_PATH = "/backup/user.repo"

         private val _users = mutableListOf<User>()
         private var _nextGuestId = 1000

         @JvmStatic
         val users: List<User>
             get() = _users

         @JvmStatic
         val nextGuestId
             get() = _nextGuestId++

         init {
             _users.add(User(100, "josh", "Joshua Calvert", listOf("admin", "staff", "sys")))
             _users.add(User(101, "dahybi", "Dahybi Yadev", listOf("staff", "nodes")))
             _users.add(User(102, "sarha", "Sarha Mitcham", listOf("admin", "staff", "sys")))
             _users.add(User(103, "warlow", groups = listOf("staff", "inactive")))
         }

         @JvmStatic
         fun saveAs(path: String?):Boolean {
             val backupPath = path ?: return false

             val outputFile = File(backupPath)
             if (!outputFile.canWrite()) {
                 throw FileNotFoundException("Could not write to file: $backupPath")
             }
             // Write data...
             return true
         }

         @JvmStatic
         fun addUser(user: User) {
             // Ensure the user isn't already in the collection.
             val existingUser = users.find { user.id == it.id }
             existingUser?.let { _users.remove(it) }
             // Add the user.
             _users.add(user)
         }
      }

   ä½¿ç”¨ IDE å°† @JvmStatic æ³¨è§£æ·»åŠ åˆ°ä»£ç ä¸­ã€‚

   ``@JvmStatic`` æ³¨è§£ç”¨äºæŒ‡ç¤º Kotlin ç¼–è¯‘å™¨ç”Ÿæˆå¸¦æ³¨è§£çš„æˆå‘˜æˆ–æ–¹æ³•çš„é™æ€ç‰ˆæœ¬ã€‚

   å¦‚æœæˆ‘ä»¬åˆ‡æ¢å› ``UseCase.java``ï¼Œ``Repository`` ä¸Šçš„å±æ€§å’Œæ–¹æ³•ä¸ä¼šå†å¯¼è‡´é”™è¯¯ï¼Œä½†
   ``Repository.BACKUP_PATH`` é™¤å¤–ã€‚æˆ‘ä»¬ç¨åå†ä»‹ç»è¿™ä¸€ä¾‹å¤–æƒ…å†µã€‚

   ç°åœ¨ï¼Œæˆ‘ä»¬è¦ä¿®æ­£ ``registerGuest()`` æ–¹æ³•ä¸­çš„ä¸‹ä¸€ä¸ªé”™è¯¯ã€‚


StringExtensions å’Œ @JvmName
----------------------------

   è®©æˆ‘ä»¬è€ƒè™‘ä»¥ä¸‹åœºæ™¯ï¼šæˆ‘ä»¬æœ‰ä¸€ä¸ª ``StringUtils`` ç±»ï¼Œå…¶ä¸­åŒ…å«ä¸€äº›ç”¨äºå­—ç¬¦ä¸²æ“ä½œçš„é™æ€å‡½æ•°ã€‚
   å°†å…¶è½¬æ¢ä¸º Kotlin æ—¶ï¼Œæˆ‘ä»¬å°†è¿™äº›æ–¹æ³•è½¬æ¢ä¸ºäº† `æ‰©å±•å‡½æ•° <https://kotlinlang.org/docs/reference/extensions.html>`__ã€‚
   Java æ²¡æœ‰æ‰©å±•å‡½æ•°ï¼Œå› æ­¤ Kotlin ä¼šå°†è¿™äº›æ–¹æ³•ç¼–è¯‘ä¸ºé™æ€å‡½æ•°ã€‚

   ç»éªŒä¸°å¯Œçš„ Java å¼€å‘è€…å¯èƒ½ä¼šå°† ``StringUtils`` è¯†åˆ«ä¸º Apache Commons
   åº“é›†ä¸­çš„æ ‡è¯†ç¬¦ã€‚ç”±äº Apache Commons å¾ˆå°‘ç”¨äº Android åº”ç”¨ï¼Œå› æ­¤æˆ‘ä»¬åœ¨æ­¤ Codelab
   ä¸­ä½¿ç”¨çš„ ``StringUtils`` æ˜¯å®Œå…¨ä¸ç›¸å…³çš„ã€‚

   é—æ†¾çš„æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬æŸ¥çœ‹ ``UseCase.java`` å†…çš„ ``registerGuest()``
   æ–¹æ³•ï¼Œå°±ä¼šå‘ç°æƒ…å†µä¸å¤ªå¯¹åŠ²ï¼š

   ::

      User guest = new User(Repository.getNextGuestId(), StringUtils.nameToLogin(name), name);

   åŸå› æ˜¯ Kotlin å°†è¿™äº›â€œé¡¶çº§â€æˆ–è½¯ä»¶åŒ…çº§å‡½æ•°æ”¾åˆ°ä¸€ä¸ªç±»ä¸­ï¼Œè€Œè¿™ä¸ªç±»çš„åç§°æ˜¯åŸºäºæ–‡ä»¶åçš„ã€‚åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œ
   ç”±äºè¯¥æ–‡ä»¶åä¸º StringUtils.ktï¼Œå› æ­¤ç›¸åº”çš„ç±»åä¸º ``StringUtilsKt``ã€‚

   æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰å¯¹ ``StringUtils`` çš„å¼•ç”¨æ›´æ”¹ä¸º ``StringUtilsKt``
   å¹¶ä¿®æ”¹è¿™ä¸ªé”™è¯¯ï¼Œä½†è¿™å¹¶ä¸æ˜¯æœ€ç†æƒ³çš„æ–¹å¼ï¼ŒåŸå› åœ¨äºï¼š

   -  æˆ‘ä»¬çš„ä»£ç ä¸­å¯èƒ½æœ‰å¾ˆå¤šåœ°æ–¹éƒ½éœ€è¦æ›´æ–°ã€‚
   -  åç§°æœ¬èº«å°±å¾ˆåˆ«æ‰­ã€‚

   å› æ­¤ï¼Œæˆ‘ä»¬ä¸åº”è¯¥é‡æ„ Java ä»£ç ï¼Œè€Œè¦å°† Kotlin ä»£ç æ›´æ–°ä¸ºé’ˆå¯¹è¿™äº›æ–¹æ³•ä½¿ç”¨ä¸åŒçš„åç§°ã€‚

   æ‰“å¼€ ``StringUtils.Kt``ï¼Œå¹¶æ‰¾åˆ°ä»¥ä¸‹è½¯ä»¶åŒ…å£°æ˜ï¼š

   ::

      package com.google.example.javafriendlykotlin

   æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `@file:JvmName <https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#package-level-functions>`__
   è®© Kotlin ä¸ºè½¯ä»¶åŒ…çº§æ–¹æ³•ä½¿ç”¨ä¸åŒçš„åç§°ã€‚æˆ‘ä»¬è¦ä½¿ç”¨è¯¥æ³¨è§£ä¸ºç±» ``StringUtils`` å‘½åã€‚

   ::

      @file:JvmName("StringUtils")

      package com.google.example.javafriendlykotlin

   ç°åœ¨ï¼Œå¦‚æœé‡æ–°æŸ¥çœ‹ ``UseCase.java``ï¼Œå°±ä¼šå‘ç° ``StringUtils.nameToLogin()``
   çš„é”™è¯¯å·²å¾—åˆ°è§£å†³ã€‚

   é—æ†¾çš„æ˜¯ï¼Œéšç€è¿™ä¸ªé—®é¢˜å¾—åˆ°è§£å†³ï¼Œæ–°çš„é—®é¢˜åˆå†’å‡ºæ¥äº†ï¼šä¼ é€’åˆ° ``User`` çš„æ„é€ å‡½æ•°çš„å‚æ•°å‡ºé—®é¢˜äº†ã€‚
   æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¦æ‰§è¡Œä¸‹ä¸€æ­¥æ“ä½œï¼Œå¹¶ä¿®æ­£ ``UseCase.registerGuest()`` ä¸­çš„æœ€åä¸€é¡¹é”™è¯¯ã€‚

   `@JvmName <https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#handling-signature-clashes-with-jvmname>`__
   æ³¨è§£æ˜¯ä¸€ç§åŠŸèƒ½å¼ºå¤§çš„å·¥å…·ï¼Œå¯ä»¥å½±å“ Kotlin å¯¹å…¶é’ˆå¯¹ Java è™šæ‹Ÿæœº (JVM) ç”Ÿæˆçš„å­—èŠ‚ç ä¸­çš„ç±»ã€
   å±æ€§å’Œæ–¹æ³•çš„å‘½åæ–¹å¼ã€‚åœ¨æ­¤ Codelab ç¨åçš„éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†è®¨è®ºå®ƒçš„å¦ä¸€ç§ç”¨é€”ã€‚


ç”¨æˆ·ç±»å’Œ @JvmOverloads
----------------------------

   Kotlin æ”¯æŒ `é»˜è®¤å‚æ•°å€¼ <https://kotlinlang.org/docs/reference/functions.html#default-arguments>`__ã€‚
   æˆ‘ä»¬å¯ä»¥é€šè¿‡æŸ¥çœ‹ ``Repository.kt`` çš„ ``init`` ä»£ç å—çš„å†…å®¹æ¥äº†è§£é»˜è®¤å€¼ä½¿ç”¨æƒ…å†µã€‚

   ``Repository.kt:``

   ::

      _users.add(User(102, "sarha", "Sarha Mitcham", listOf("admin", "staff", "sys")))
      _users.add(User(103, "warlow", groups = listOf("staff", "inactive")))

   å¯ä»¥çœ‹åˆ°ï¼Œå¯¹äºç”¨æˆ·â€œwarlowâ€ï¼Œæˆ‘ä»¬å¯ä»¥è·³è¿‡ä¸º ``displayName`` è¾“å…¥å€¼çš„æ­¥éª¤ï¼Œå› ä¸º
   ``User.kt`` ä¸­ä¸ºå…¶æŒ‡å®šäº†é»˜è®¤å€¼ã€‚

   ``User.kt:``

   ::

      data class User(
         val id: Int,
         val username: String,
         val displayName: String = username.toTitleCase(),
         val groups: List<String> = listOf("guest")
      )

   é—æ†¾çš„æ˜¯ï¼Œä» Java è°ƒç”¨è¯¥æ–¹æ³•æ—¶ï¼Œå…¶å·¥ä½œåŸç†æœ‰æ‰€ä¸åŒã€‚

   ``UseCase.java:``

   ::

      User guest = new User(Repository.getNextGuestId(), StringUtils.nameToLogin(name), name);

   Java ç¼–ç¨‹è¯­è¨€ä¸æ”¯æŒé»˜è®¤å€¼ã€‚ä¸ºè§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬è¦å€ŸåŠ© `@JvmOverloads <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/index.html#jvmoverloads>`__
   æ³¨è§£è®© Kotlin é’ˆå¯¹æ„é€ å‡½æ•°ç”Ÿæˆé‡è½½ã€‚

   é¦–å…ˆï¼Œæˆ‘ä»¬å¿…é¡»å¯¹ ``User.kt`` ç¨ä½œæ›´æ–°ã€‚

   ç”±äº ``User`` ç±»åªæœ‰ä¸€ä¸ª `ä¸»è¦æ„é€ å‡½æ•° <https://kotlinlang.org/docs/reference/classes.html#constructors>`__ï¼Œ
   å¹¶ä¸”è¯¥æ„é€ å‡½æ•°ä¸åŒ…å«ä»»ä½•æ³¨è§£ï¼Œå› æ­¤ç³»ç»Ÿå¿½ç•¥äº† ``constructor`` å…³é”®å­—ã€‚ä¸è¿‡ï¼Œæ—¢ç„¶æˆ‘ä»¬è¦ä¸ºå…¶
   æ·»åŠ æ³¨è§£ï¼Œå°±å¿…é¡»åŒ…å« ``constructor`` å…³é”®å­—ï¼š

   ::

      data class User constructor(
          val id: Int,
          val username: String,
          val displayName: String = username.toTitleCase(),
          val groups: List<String> = listOf("guest")
      )

   åœ¨å­˜åœ¨ ``constructor`` å…³é”®å­—çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥æ·»åŠ  ``@JvmOverloads`` æ³¨è§£ï¼š

   ::

      data class User @JvmOverloads constructor(
          val id: Int,
          val username: String,
          val displayName: String = username.toTitleCase(),
          val groups: List<String> = listOf("guest")
      )

   å¦‚æœåˆ‡æ¢å› ``UseCase.java``ï¼Œå°±ä¼šå‘ç° ``registerGuest`` å‡½æ•°ä¸­å·²ç»æ²¡æœ‰ä»»ä½•é”™è¯¯äº†ï¼

   ä¸‹ä¸€æ­¥è¦ä¿®å¤ ``UseCase.getSystemUsers()`` ä¸­å¯¹ ``user.hasSystemAccess()``
   çš„å¼‚å¸¸è°ƒç”¨ã€‚æ‚¨å¯ä»¥ç»§ç»­æ‰§è¡Œä¸‹ä¸€æ­¥æ“ä½œä»¥å®ç°è¯¥ç›®çš„ï¼Œä¹Ÿå¯ä»¥ç»§ç»­é˜…è¯»ä»¥æ·±å…¥äº†è§£
   ``@JvmOverloads`` ä¸ºä¿®æ­£é”™è¯¯è€Œæ‰§è¡Œçš„æ“ä½œã€‚


@JvmOverloads

   ä¸ºäº†æ›´å¥½åœ°äº†è§£ ``@JvmOverloads`` çš„ä½œç”¨ï¼Œæˆ‘ä»¬è¦åœ¨ ``UseCase.java`` ä¸­åˆ›å»ºä¸€ä¸ªæµ‹è¯•æ–¹æ³•ï¼š

   ::

      private void testJvmOverloads() {
         User syrinx = new User(1001, "syrinx");
         User ione = new User(1002, "ione", "Ione Saldana");

         List<String> groups = new ArrayList<>();
         groups.add("staff");
         User beaulieu = new User(1002, "beaulieu", groups);
      }

   æˆ‘ä»¬åªéœ€ä½¿ç”¨ ``id`` å’Œ ``username`` è¿™ä¸¤ä¸ªå‚æ•°å³å¯æ„é€ ä¸€ä¸ª ``User``ï¼š

   ::

      User syrinx = new User(1001, "syrinx");

   æˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡å¦ä¸€ç§æ–¹æ³•æ¥æ„é€  ``User``ï¼Œå³åŒ…å«é’ˆå¯¹ ``displayName``
   çš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼ŒåŒæ—¶ä»ç„¶ä½¿ç”¨ ``groups`` çš„é»˜è®¤å€¼ï¼š

   ::

      User ione = new User(1002, "ione", "Ione Saldana");

   ä½†æ˜¯ï¼Œè¦æƒ³è·³è¿‡ ``displayName``ï¼Œåªä¸º ``groups``
   æä¾›ä¸€ä¸ªå€¼ï¼Œè€Œä¸ç¼–å†™å…¶ä»–ä»£ç ï¼Œé‚£æ˜¯ä¸å¯èƒ½çš„ï¼š

   |e33040916c6c32e4.png|

   å› æ­¤ï¼Œæˆ‘ä»¬è¦åˆ é™¤è¿™ä¸€è¡Œä»£ç ï¼Œæˆ–åœ¨å…¶å‰é¢æ·»åŠ  â€œ//â€ ä»¥å°†å…¶æ³¨è§£æ‰ã€‚

   åœ¨ Kotlin ä¸­ï¼Œå¦‚æœè¦åˆå¹¶é»˜è®¤å‚æ•°å’Œéé»˜è®¤å‚æ•°ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨å‘½åå‚æ•°ã€‚

   ::

      // This doesn't work...
      User(104, "warlow", listOf("staff", "inactive"))
      // But using named parameters, it does...
      User(104, "warlow", groups = listOf("staff", "inactive"))

   è¿™æ˜¯å› ä¸ºï¼ŒKotlin ä¼šä¸ºå‡½æ•°ï¼ˆåŒ…æ‹¬æ„é€ å‡½æ•°ï¼‰ç”Ÿæˆé‡è½½ï¼Œä½†å®ƒåªä¼šä¸ºæ¯ä¸ªå‚æ•°åˆ›å»ºä¸€ä¸ªå…·æœ‰é»˜è®¤å€¼çš„é‡è½½ã€‚


ç”¨æˆ·å’Œ @JvmName
----------------------------

   æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¦å›é¡¾ä¸€ä¸‹ ``UseCase.java``ï¼Œå¹¶è§£å†³ä¸‹ä¸€ä¸ªé—®é¢˜ï¼šåœ¨
   ``UseCase.getSystemUsers()`` æ–¹æ³•ä¸­è°ƒç”¨ ``user.hasSystemAccess()``ï¼š

   ::

      public static List<User> getSystemUsers() {
         ArrayList<User> systemUsers = new ArrayList<>();
         for (User user : Repository.getUsers()) {
             if (user.hasSystemAccess()) {     // Now has an error!
                 systemUsers.add(user);
             }
         }
         return systemUsers;
      }

   è¿™ä¸ªé”™è¯¯å¾ˆæœ‰æ„æ€ï¼å¦‚æœæ‚¨å¯¹ç±» ``User`` ä½¿ç”¨ IDE è‡ªåŠ¨è¡¥å…¨åŠŸèƒ½ï¼Œå°±ä¼šå‘ç°
   ``hasSystemAccess()`` å·²é‡å‘½åä¸º ``getHasSystemAccess()``ã€‚

   ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬è¦è®© Kotlin ä¸º ``val`` å±æ€§ ``hasSystemAccess``
   ç”Ÿæˆå¦ä¸€ä¸ªåç§°ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ ``@JvmName`` æ³¨è§£ã€‚è®©æˆ‘ä»¬åˆ‡æ¢å›
   ``User.kt``ï¼Œçœ‹çœ‹åº”è¯¥å°†è¿™ä¸ªæ³¨è§£åº”ç”¨åˆ°ä»€ä¹ˆåœ°æ–¹ã€‚

   æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼æ¥åº”ç”¨è¿™ä¸ªæ³¨è§£ã€‚ç¬¬ä¸€ç§æ˜¯ç›´æ¥å°†å…¶åº”ç”¨äº ``get()`` æ–¹æ³•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

   ::

      val hasSystemAccess
         @JvmName("hasSystemAccess")
         get() = "sys" in groups

   è¿™ä¼šæŒ‡ç¤º Kotlin å°†æ˜¾å¼å®šä¹‰ getter çš„ç­¾åæ›´æ”¹ä¸ºæ‰€æä¾›çš„åç§°ã€‚

   æˆ–è€…ï¼Œæ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨ ``get:`` å‰ç¼€å°†å…¶åº”ç”¨äºç›¸åº”å±æ€§ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

   ::

      @get:JvmName("hasSystemAccess")
      val hasSystemAccess
         get() = "sys" in groups

   å¤‡ç”¨æ–¹æ³•å¯¹äºä½¿ç”¨é»˜è®¤çš„éšå¼å®šä¹‰ getter çš„å±æ€§ç‰¹åˆ«æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼š

   ::

      @get:JvmName("isActive")
      val active: Boolean

   è¿™æ ·ï¼Œæ‚¨æ— éœ€æ˜¾å¼å®šä¹‰ getterï¼Œå³å¯æ›´æ”¹ getter çš„åç§°ã€‚

   è™½ç„¶æœ‰ä¸Šè¿°åŒºåˆ«ï¼Œä½†æ‚¨å¯ä»¥è§†éœ€è¦ä½¿ç”¨ä»»ä¸€æ–¹å¼ã€‚è¿™ä¸¤ç§æ–¹å¼éƒ½èƒ½è®© Kotlin åˆ›å»ºåä¸º
   ``hasSystemAccess()`` çš„ getterã€‚

   å¦‚æœåˆ‡æ¢å› ``UseCase.java``ï¼Œå³å¯éªŒè¯ ``getSystemUsers()`` ç°åœ¨å·²ä¸å­˜åœ¨ä»»ä½•é”™è¯¯ï¼

   ä¸‹ä¸€ä¸ªé”™è¯¯ä½äº ``formatUser()`` ä¸­ï¼Œä½†å¦‚æœæ‚¨æƒ³æ·±å…¥äº†è§£ Kotlin getter
   å‘½åæƒ¯ä¾‹ï¼Œè¯·ç»§ç»­é˜…è¯»æœ¬éƒ¨åˆ†ï¼Œè€Œæš‚æ—¶ä¸è¦æ‰§è¡Œä¸‹ä¸€æ­¥æ“ä½œã€‚


getter å’Œ setter çš„å‘½å

   ç¼–å†™ Kotlin ä»£ç æ—¶ï¼Œå¾ˆå®¹æ˜“å¿½ç•¥çš„ä¸€ç‚¹æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬ç¼–å†™å¦‚ä¸‹æ‰€ç¤ºçš„ä»£ç ï¼š

   ::

      val myString = "Logged in as ${user.displayName}")

   è¿™å®é™…ä¸Šä¼šè°ƒç”¨å‡½æ•°æ¥è·å– ``displayName`` çš„å€¼ã€‚è‹¥è¦éªŒè¯è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨èœå•ä¸­ä¾æ¬¡è½¬åˆ°
   **Tools > Kotlin > Show Kotlin Bytecode**ï¼Œç„¶åç‚¹å‡» **Decompile** æŒ‰é’®ï¼š

   ::

      String myString = "Logged in as " + user.getDisplayName();

   å¦‚æœè¦ä» Java è®¿é—®è¿™äº›å…ƒç´ ï¼Œæˆ‘ä»¬éœ€è¦æ˜¾å¼å†™å‡ºç›¸åº” getter çš„åç§°ã€‚

   åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼ŒKotlin å±æ€§çš„ getter çš„ Java åç§°å°±æ˜¯ ``get`` + å±æ€§åç§°ï¼Œå¦‚
   ``User.getHasSystemAccess()`` å’Œ ``User.getDisplayName()``
   æ‰€ç¤ºã€‚å”¯ä¸€çš„ä¾‹å¤–æƒ…å†µæ˜¯åç§°ä»¥â€œisâ€å¼€å¤´çš„å±æ€§ã€‚åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œgetter çš„ Java åç§°æ˜¯ Kotlin
   å±æ€§çš„åç§°ã€‚

   ä¾‹å¦‚ï¼Œ``User`` ä¸Šçš„å±æ€§ï¼Œä¾‹å¦‚ï¼š

   ::

      val isAdmin get() = //...

   å¯ä½¿ç”¨ä»¥ä¸‹ä»£ç ä» Java è¿›è¡Œè®¿é—®ï¼š

   ::

      boolean userIsAnAdmin = user.isAdmin();

   é€šè¿‡ä½¿ç”¨ ``@JvmName`` æ³¨è§£ï¼ŒKotlin
   ä¼šä¸ºå¸¦æ³¨è§£çš„é¡¹ç”Ÿæˆå…·æœ‰æŒ‡å®šåç§°ï¼ˆè€Œéé»˜è®¤åç§°ï¼‰çš„å­—èŠ‚ç ã€‚

   å¯¹äº setter ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œå…¶ç”Ÿæˆçš„åç§°å§‹ç»ˆæ˜¯ ``set`` + å±æ€§åç§°ã€‚ä¾‹å¦‚ï¼Œé‡‡ç”¨ä»¥ä¸‹ç±»ï¼š

   ::

      class Color {
         var red = 0f
         var green = 0f
         var blue = 0f
      }

   å‡å®šæˆ‘ä»¬è¦å°† setter çš„åç§°ä» ``setRed()`` æ›´æ”¹ä¸º ``updateRed()``ï¼Œè€Œä¸æ›´æ”¹
   getterã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ ``@set:JvmName`` ç‰ˆæœ¬æ¥å®ç°è¿™ä¸€ç›®çš„ï¼š

   ::

      class Color {
         @set:JvmName("updateRed")
         var red = 0f
         @set:JvmName("updateGreen")
         var green = 0f
         @set:JvmName("updateBlue")
         var blue = 0f
      }

   ç„¶åï¼Œåœ¨ Java ä¸­ï¼Œæˆ‘ä»¬å³å¯ç¼–å†™ä»¥ä¸‹ä»£ç ï¼š

   ::

      color.updateRed(0.8f);


@JvmField å’Œ const
----------------------------

   ``UseCase.formatUser()`` ä½¿ç”¨ç›´æ¥å­—æ®µè®¿é—®æ¥è·å– ``User`` å¯¹è±¡çš„å±æ€§å€¼ã€‚

   åœ¨ Kotlin ä¸­ï¼Œå±æ€§é€šå¸¸é€šè¿‡ getter å’Œ setter å…¬å¼€ã€‚å…¶ä¸­åŒ…æ‹¬ ``val`` å±æ€§ã€‚

   è‹¥è¦æ›´æ”¹è¿™ä¸ªè¡Œä¸ºï¼Œå¯ä»¥ä½¿ç”¨ `@JvmField æ³¨è§£ <https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#instance-fields>`__ã€‚
   å¦‚æœå°†è¯¥æ³¨è§£åº”ç”¨äºæŸä¸ªç±»ä¸­çš„æŸä¸ªå±æ€§ï¼ŒKotlin å°±ä¼šè·³è¿‡ç”Ÿæˆ getter æ–¹æ³•çš„æ­¥éª¤ï¼ˆå¯¹äº ``var`` å±æ€§ï¼Œ
   åˆ™è·³è¿‡ç”Ÿæˆ setter çš„æ­¥éª¤ï¼‰ï¼Œå¹¶è®©åå¤‡å­—æ®µå¯ä¾›ç›´æ¥è®¿é—®ã€‚

   ç”±äº ``User`` å¯¹è±¡æ˜¯ä¸å¯å˜çš„ï¼Œå› æ­¤æˆ‘ä»¬è¦å°†å…¶æ‰€æœ‰å±æ€§éƒ½å…¬å¼€ä¸ºå­—æ®µï¼Œå› æ­¤ï¼Œæˆ‘ä»¬ä¼šä¸ºæ¯ä¸ªå±æ€§åˆ†åˆ«
   æ·»åŠ  ``@JvmField`` æ³¨è§£ï¼š

   ::

      data class User @JvmOverloads constructor(
         @JvmField val id: Int,
         @JvmField val username: String,
         @JvmField val displayName: String = username.toTitleCase(),
         @JvmField val groups: List<String> = listOf("guest")
      ) {
         @get:JvmName("hasSystemAccess")
         val hasSystemAccess
             get() = "sys" in groups
      }


   ç°åœ¨ï¼Œå¦‚æœé‡æ–°æŸ¥çœ‹ ``UseCase.formatUser()``ï¼Œå°±ä¼šå‘ç°é”™è¯¯å·²å¾—åˆ°è§£å†³ï¼

   **@JvmField è¿˜æ˜¯ const**

   æ¥ç€ï¼Œ ``UseCase.java`` æ–‡ä»¶ä¸­è¿˜æœ‰ä¸€ä¸ªç±»ä¼¼çš„é”™è¯¯ï¼š

   ::

      Repository.saveAs(Repository.BACKUP_PATH);

   æ­¤æ—¶ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨è‡ªåŠ¨è¡¥å…¨åŠŸèƒ½ï¼Œå°±ä¼šå‘ç°æœ‰ä¸€ä¸ª
   ``Repository.getBACKUP_PATH()``ï¼Œå› æ­¤ï¼Œæ‚¨å¯èƒ½ä¼šæƒ³å°† ``BACKUP_PATH`` ä¸Šçš„æ³¨è§£ä»
   ``@JvmStatic`` æ›´æ”¹ä¸º ``@JvmField``ã€‚

   è¯•è¯•çœ‹å§ã€‚åˆ‡æ¢å› ``Repository.kt``ï¼Œç„¶åæ›´æ–°æ³¨è§£ï¼š

   ::

      object Repository {
         @JvmField
         val BACKUP_PATH = "/backup/user.repo"

   ç°åœ¨ï¼Œå¦‚æœæŸ¥çœ‹ ``UseCase.java``ï¼Œå°±ä¼šå‘ç°é”™è¯¯å·²æ¶ˆå¤±ï¼Œä½† ``BACKUP_PATH``
   ä¸Šè¿˜æœ‰ä¸€ä¸ªå¤‡æ³¨ï¼š

   å¯ä»¥ä½¿ç”¨ ``'const'`` ä»£æ›¿ ``'@JvmField'``

   åœ¨ Kotlin ä¸­ï¼Œåªæœ‰ ``const`` ç±»å‹å¯ä»¥æ˜¯åŸºå…ƒï¼Œä¾‹å¦‚ ``int``ã€``float`` å’Œ
   ``String``ã€‚åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œç”±äº ``BACKUP_PATH`` æ˜¯å­—ç¬¦ä¸²ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨
   ``const val``ï¼ˆè€Œä¸æ˜¯å¸¦æœ‰ ``@JvmField`` æ³¨è§£çš„
   ``val``ï¼‰æ¥è·å¾—æ›´å¥½çš„æ€§èƒ½ï¼ŒåŒæ—¶ä¿ç•™å°†å€¼ä½œä¸ºå­—æ®µè¿›è¡Œè®¿é—®çš„èƒ½åŠ›ã€‚

   ç°åœ¨ï¼Œæˆ‘ä»¬è¦åœ¨ Repository.kt ä¸­è¿›è¡Œç›¸å…³æ›´æ”¹ï¼š

   ::

      object Repository {
         const val BACKUP_PATH = "/backup/user.repo"

   å¦‚æœé‡æ–°æŸ¥çœ‹ ``UseCase.java``ï¼Œå°±ä¼šå‘ç°åªå‰©ä¸€é¡¹é”™è¯¯äº†ã€‚


@Throws
----------------------------

   æœ€åä¸€é¡¹é”™è¯¯çš„å†…å®¹ä¸ºï¼š``Exception: 'java.io.IOException' is never thrown in the corresponding try block.``

   ä¸è¿‡ï¼Œå¦‚æœæŸ¥çœ‹ ``Repository.kt`` ä¸­ ``Repository.saveAs``
   çš„ç›¸å…³ä»£ç ï¼Œå°±ä¼šå‘ç°å®ƒç¡®å®ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚è¿™æ˜¯æ€ä¹ˆå›äº‹ï¼Ÿ

   Java
   ä¸­æœ‰â€œå—æ£€å¼‚å¸¸â€çš„æ¦‚å¿µã€‚å—æ£€å¼‚å¸¸æ˜¯æŒ‡å¯ä»¥æ¢å¤çš„å¼‚å¸¸ï¼Œä¾‹å¦‚ç”¨æˆ·é”™è¯¯è¾“å…¥æ–‡ä»¶åï¼Œæˆ–ç½‘ç»œæš‚æ—¶ä¸å¯ç”¨ã€‚æ•è·å—æ£€å¼‚å¸¸åï¼Œå¼€å‘è€…å¯ä»¥ä¸ºç”¨æˆ·æä¾›å…³äºå¦‚ä½•è§£å†³ç›¸åº”é—®é¢˜çš„åé¦ˆã€‚

   ç”±äºç³»ç»Ÿä¼šåœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å—æ£€å¼‚å¸¸ï¼Œå› æ­¤ï¼Œæ‚¨è¦åœ¨ç›¸åº”æ–¹æ³•çš„ç­¾åä¸­å£°æ˜è¿™äº›å¼‚å¸¸ï¼š

   ::

      public void openFile(File file) throws FileNotFoundException {
         // ...
      }

   å¦ä¸€æ–¹é¢ï¼ŒKotlin æ²¡æœ‰å—æ£€å¼‚å¸¸ï¼Œè¿™å°±æ˜¯å¯¼è‡´å‡ºç°ä¸Šè¿°é—®é¢˜çš„åŸå› ã€‚

   è§£å†³æ–¹æ¡ˆæ˜¯è®© Kotlin å°†å¯èƒ½æŠ›å‡ºçš„ ``IOException`` æ·»åŠ åˆ° ``Repository.saveAs()``
   çš„ç­¾åï¼Œä»¥ä¾¿è®© JVM å­—èŠ‚ç å°†å…¶ä½œä¸ºå—æ£€å¼‚å¸¸è¿›è¡Œæ·»åŠ ã€‚

   ä¸ºæ­¤ï¼Œæˆ‘ä»¬è¦ä½¿ç”¨ Kotlin ``@Throws`` æ³¨è§£ï¼Œè¯¥æ³¨è§£æœ‰åŠ©äº Java/Kotlin çš„äº’æ“ä½œæ€§ã€‚åœ¨
   Kotlin ä¸­ï¼Œå¼‚å¸¸çš„è¡Œä¸ºä¸ Java ç±»ä¼¼ï¼Œä½†ä¸ Java ä¸åŒçš„æ˜¯ï¼ŒKotlin
   åªæœ‰ä¸å—æ£€å¼‚å¸¸ã€‚å› æ­¤ï¼Œå¦‚æœæ‚¨è¦æŒ‡ç¤º Java ä»£ç  Kotlin å‡½æ•°ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œæ‚¨éœ€è¦å¯¹ Kotlin
   å‡½æ•°ç­¾åä½¿ç”¨ @Throws æ³¨è§£ã€‚åˆ‡æ¢åˆ° ``Repository.kt file``ï¼Œç„¶åæ›´æ–° ``saveAs()``
   ä»¥åŒ…å«æ–°æ³¨è§£ï¼š

   ::

      @JvmStatic
      @Throws(IOException::class)
      fun saveAs(path: String?) {
         val outputFile = File(path)
         if (!outputFile.canWrite()) {
             throw FileNotFoundException("Could not write to file: $path")
         }
         // Write data...
      }

   æ·»åŠ  ``@Throws`` æ³¨è§£åï¼Œå°±ä¼šå‘ç° ``UseCase.java``
   ä¸­çš„ç¼–è¯‘å™¨é”™è¯¯å…¨éƒ½å¾—åˆ°ä¿®æ­£äº†ï¼å¤ªæ£’äº†ï¼

   æ‚¨å¯èƒ½æƒ³çŸ¥é“ï¼Œç°åœ¨ä» Kotlin è°ƒç”¨ ``saveAs()`` æ—¶ï¼Œæ‚¨æ˜¯å¦å¿…é¡»ä½¿ç”¨ ``try`` å’Œ ``catch``
   å—ã€‚

   ä¸éœ€è¦ï¼è¯·è®°ä½ï¼ŒKotlin æ²¡æœ‰å—æ£€å¼‚å¸¸ï¼Œè€Œä¸”å‘æ–¹æ³•æ·»åŠ  ``@Throws`` å¹¶ä¸ä¼šæ”¹å˜è¿™ç§æƒ…å†µï¼š

   ::

      fun saveFromKotlin(path: String) {
         Repository.saveAs(path)
      }

   åœ¨å¼‚å¸¸èƒ½å¤Ÿå¾—åˆ°å¤„ç†æ—¶ï¼Œæ•è·å¼‚å¸¸ä»æ˜¯æœ‰ç”¨çš„ï¼Œä½† Kotlin å¹¶ä¸å¼ºåˆ¶æ‚¨å¤„ç†å¼‚å¸¸ã€‚


å°ç»“
----------------------------

   åœ¨æ­¤ Codelab ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº†å¦‚ä½•ç¼–å†™ Kotlin ä»£ç ï¼ŒåŒæ—¶è¿˜è¦è®© Kotlin ä»£ç æ”¯æŒç¼–å†™æƒ¯ç”¨çš„
   Java ä»£ç ã€‚

   æˆ‘ä»¬è®¨è®ºäº†å¦‚ä½•ä½¿ç”¨æ³¨è§£æ¥æ›´æ”¹ Kotlin ç”Ÿæˆ JVM å­—èŠ‚ç çš„æ–¹å¼ï¼Œä¾‹å¦‚ï¼š

   -  ``@JvmStatic`` ç”¨äºç”Ÿæˆé™æ€æˆå‘˜å’Œæ–¹æ³•ã€‚
   -  ``@JvmOverloads`` ç”¨äºä¸ºåŒ…å«é»˜è®¤å€¼çš„å‡½æ•°ç”Ÿæˆé‡è½½æ–¹æ³•ã€‚
   -  ``@JvmName`` ç”¨äºæ›´æ”¹ getter å’Œ setter çš„åç§°ã€‚
   -  ``@JvmField`` ç”¨äºå°†å±æ€§ç›´æ¥ä½œä¸ºå­—æ®µå…¬å¼€ï¼Œè€Œä¸æ˜¯é€šè¿‡ getter å’Œ setter å…¬å¼€ã€‚
   -  ``@Throws`` ç”¨äºå£°æ˜å—æ£€å¼‚å¸¸ã€‚

   æˆ‘ä»¬çš„æ–‡ä»¶çš„æœ€ç»ˆå†…å®¹ä¸ºï¼š


**User.kt**

   ::

      data class User @JvmOverloads constructor(
         @JvmField val id: Int,
         @JvmField val username: String,
         @JvmField val displayName: String = username.toTitleCase(),
         @JvmField val groups: List<String> = listOf("guest")
      ) {
         val hasSystemAccess
             @JvmName("hasSystemAccess")
             get() = "sys" in groups
      }


**Repository.kt**

   ::

      object Repository {
         const val BACKUP_PATH = "/backup/user.repo"

         private val _users = mutableListOf<User>()
         private var _nextGuestId = 1000

         @JvmStatic
         val users: List<User>
             get() = _users

         @JvmStatic
         val nextGuestId
             get() = _nextGuestId++

         init {
             _users.add(User(100, "josh", "Joshua Calvert", listOf("admin", "staff", "sys")))
             _users.add(User(101, "dahybi", "Dahybi Yadev", listOf("staff", "nodes")))
             _users.add(User(102, "sarha", "Sarha Mitcham", listOf("admin", "staff", "sys")))
             _users.add(User(103, "warlow", groups = listOf("staff", "inactive")))
         }

         @JvmStatic
         @Throws(IOException::class)
         fun saveAs(path: String?):Boolean {
             val backupPath = path ?: return false

             val outputFile = File(backupPath)
             if (!outputFile.canWrite()) {
                 throw FileNotFoundException("Could not write to file: $backupPath")
             }
             // Write data...
             return true
         }

         @JvmStatic
         fun addUser(user: User) {
             // Ensure the user isn't already in the collection.
             val existingUser = users.find { user.id == it.id }
             existingUser?.let { _users.remove(it) }
             // Add the user.
             _users.add(user)
         }
      }


**StringUtils.kt**

   ::

      @file:JvmName("StringUtils")

      package com.google.example.javafriendlykotlin

      fun String.toTitleCase(): String {
         if (isNullOrBlank()) {
             return this
         }

         return split(" ").map { word ->
             word.foldIndexed("") { index, working, char ->
                 val nextChar = if (index == 0) char.toUpperCase() else char.toLowerCase()
                 "$working$nextChar"
             }
         }.reduceIndexed { index, working, word ->
             if (index > 0) "$working $word" else word
         }
      }

      fun String.nameToLogin(): String {
         if (isNullOrBlank()) {
             return this
         }
         var working = ""
         toCharArray().forEach { char ->
             if (char.isLetterOrDigit()) {
                 working += char.toLowerCase()
             } else if (char.isWhitespace() and !working.endsWith(".")) {
                 working += "."
             }
         }
         return working
      }


.. |e33040916c6c32e4.png| image:: https://developer.android.google.cn/static/codelabs/java-friendly-kotlin/img/e33040916c6c32e4.png


ğŸŸ© TOC - Jetpack Compose for Android Developers
================================================

https://developer.android.google.cn/courses/jetpack-compose/course?hl=en

Learn how to use Jetpack Compose to build native Android UI! Youâ€™ll see how 
Compose simplifies and accelerates UI development on Android with less code, 
powerful tools, and intuitive Kotlin APIs.

.. code:: bash

   curl \
   https://developer.android.google.cn/courses/pathways/jetpack-compose-for-android-developers-5?hl=en \
   | sed -n '/devsite-main-content/,/devsite-playlist--footer/p' \
   | pandoc -trst -rhtml --column=95 \
   >> $0


Compose essentials
------------------

   https://developer.android.google.cn/courses/pathways/jetpack-compose-for-android-developers-1?hl=en

   Take your first steps with Jetpack Compose. Learn about composable functions, 
   basic layouts and state, Material Design, and more.


   * [ğŸ§­] Starter tutorial
      UI component with declarative functions. Understand
      composable functions, basic layouts, and how Material
      Design, lists and animations work in Compose.


   * [ğŸ§­] Thinking in Compose

      Learn how to think in Compose and shift your thinking
      to focus on "what" and not "how".


   * [ğŸ§­] Composable functions

      Learn the building blocks of Compose: composable
      functions.


   * [ğŸš€] Write your first Compose app
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-basics?hl=en>`__

      Go hands-on and learn the fundamentals of declarative
      UI, working with state, layouts, and theming. You'll
      see what composables and modifiers are, how to work
      with basic UI elements such as Row and Column, and how
      to give state to your app.


   * [ğŸ§­] The Compose UI toolkit

      Learn about the set of composables that are part of
      the Compose toolkit: Material Design components,
      layouts, modifiers, and more.


   * [ğŸš€] Implement a real-world design
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-layouts?hl=en>`__

      In this codelab, youâ€™ll learn how to implement
      real-world designs with the composables and modifiers
      that Compose provides out of the box.


   * [ğŸš€] Get started with state
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-state?hl=en>`__

      Learn how the app's state determines what is displayed
      in the UI, how Compose keeps the UI updated when state
      changes, how to optimize the structure of your
      composable functions, and work with ViewModels in a
      Compose app.


   * [ğŸ§­] Accelerate with tooling

      Learn how to accelerate your development using
      Compose-specific tooling in Android Studio.


   * [ğŸ§­] Migrate from the View system

      Have an existing app built with Views? Learn how to
      take an incremental approach to migrating.


   * [ğŸš€] Hands-on migration
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-migration?hl=en>`__

      Walk through a practical migration of a View based app
      to Jetpack Compose to understand how to incrementally
      adopt Compose, and explore the implications for your
      architecture and testing.


Layouts, theming, and animation
-------------------------------

   Use more advanced layouts, and add movement and style to your app.

   PATHWAY 2


   * [ğŸ§­] Starter tutorial
      UI component with declarative functions. Understand
      composable functions, basic layouts, and how Material
      Design, lists and animations work in Compose.


   * [ğŸ§­] Thinking in Compose

      Learn how to think in Compose and shift your thinking
      to focus on "what" and not "how".


   * [ğŸ§­] Composable functions

      Learn the building blocks of Compose: composable
      functions.


   * [ğŸš€] Write your first Compose app
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-basics?hl=en>`__

      Go hands-on and learn the fundamentals of declarative
      UI, working with state, layouts, and theming. You'll
      see what composables and modifiers are, how to work
      with basic UI elements such as Row and Column, and how
      to give state to your app.


   * [ğŸ§­] The Compose UI toolkit

      Learn about the set of composables that are part of
      the Compose toolkit: Material Design components,
      layouts, modifiers, and more.


   * [ğŸš€] Implement a real-world design
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-layouts?hl=en>`__

      In this codelab, youâ€™ll learn how to implement
      real-world designs with the composables and modifiers
      that Compose provides out of the box.


   * [ğŸš€] Get started with state
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-state?hl=en>`__

      Learn how the app's state determines what is displayed
      in the UI, how Compose keeps the UI updated when state
      changes, how to optimize the structure of your
      composable functions, and work with ViewModels in a
      Compose app.


   * [ğŸ§­] Accelerate with tooling

      Learn how to accelerate your development using
      Compose-specific tooling in Android Studio.


   * [ğŸ§­] Migrate from the View system

      Have an existing app built with Views? Learn how to
      take an incremental approach to migrating.


   * [ğŸš€] Hands-on migration
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-migration?hl=en>`__

      Walk through a practical migration of a View based app
      to Jetpack Compose to understand how to incrementally
      adopt Compose, and explore the implications for your
      architecture and testing.

   *  [ğŸ§­] Compose phases

      Learn how Jetpack Compose transforms data into UI.

   *  [ğŸ”¨] Architecting your Compose UI
      `Read article <https://developer.android.google.cn/develop/ui/compose/architecture>`__

      This guide focuses on how to implement the
      unidirectional data flow pattern in Compose, how to
      implement events and state holders, and how to work
      with ViewModels in Compose.


   *  [ğŸ§­] A Compose state of mind

      Learn about Compose's state model and the Composition,
      when to hoist state and create state holders or use
      AAC ViewModels, and how to mutate state when you're
      outside the Composition safely so that these changes
      are tracked by Compose.

   *  [ğŸ§­] Where to hoist your state

      Learn how and where to hoist state in Jetpack Compose.

   *  [ğŸš€] Advanced state and side effects
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-advanced-state-side-effects?hl=en>`__

      Learn advanced concepts related to state and side
      effects APIs in Jetpack Compose. Learn how to create a
      state holder for complex stateful composables, create
      coroutines and call suspend functions from Compose
      code, and trigger side effects for different use cases.


   *  [ğŸ§­] Navigation best practices

      Learn best practices for using Navigation Compose to
      set you up for expanding your navigation graph across
      multiple modules in a way that maintains type safety
      across all navigation calls.

   *  [ğŸš€] Navigation
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-navigation?hl=en>`__

      Learn how to use the Jetpack Navigation library in
      Compose, navigate within your application, navigate
      with arguments, support deep-links, and test your
      navigation.


   *  [ğŸ§­] State holders and state production

      Compose displays application data on the screen. But
      how is it done exactly? This video dives deep into the
      UI state production pipeline and state holders that
      manage UI complexity. Get to know the differences
      between UI and business logic, a ViewModel and a plain
      state holder class, state and events, and more! What
      is all that, when to use which, and how to do it.


Architecture and state
----------------------

   https://developer.android.google.cn/courses/pathways/jetpack-compose-for-android-developers-3?hl=en

   Build a functioning app using navigation, advanced state, and side effects.

   PATHWAY 3


   * [ğŸ§­] Compose phases

      Learn how Jetpack Compose transforms data into UI.


   * [ğŸ”¨] Architecting your Compose UI
      `Read article <https://developer.android.google.cn/develop/ui/compose/architecture>`__

      This guide focuses on how to implement the
      unidirectional data flow pattern in Compose, how to
      implement events and state holders, and how to work
      with ViewModels in Compose.


   * [ğŸ§­] A Compose state of mind

      Learn about Compose's state model and the Composition,
      when to hoist state and create state holders or use
      AAC ViewModels, and how to mutate state when you're
      outside the Composition safely so that these changes
      are tracked by Compose.


   * [ğŸ§­] Where to hoist your state

      Learn how and where to hoist state in Jetpack Compose.


   * [ğŸš€] Advanced state and side effects
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-advanced-state-side-effects?hl=en>`__

      Learn advanced concepts related to state and side
      effects APIs in Jetpack Compose. Learn how to create a
      state holder for complex stateful composables, create
      coroutines and call suspend functions from Compose
      code, and trigger side effects for different use
      cases.


   * [ğŸ§­] Navigation best practices

      Learn best practices for using Navigation Compose to
      set you up for expanding your navigation graph across
      multiple modules in a way that maintains type safety
      across all navigation calls.


   * [ğŸš€] Navigation
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-navigation?hl=en>`__

      Learn how to use the Jetpack Navigation library in
      Compose, navigate within your application, navigate
      with arguments, support deep-links, and test your
      navigation.


   * [ğŸ§­] State holders and state production

      Compose displays application data on the screen. But
      how is it done exactly? This video dives deep into the
      UI state production pipeline and state holders that
      manage UI complexity. Get to know the differences
      between UI and business logic, a ViewModel and a plain
      state holder class, state and events, and more! What
      is all that, when to use which, and how to do it.


Accessibility, testing, and performance
---------------------------------------

   https://developer.android.google.cn/courses/pathways/jetpack-compose-for-android-developers-4?hl=en

   Make your app accessible for all users, improve performance, and write automated tests.

   PATHWAY 4


   * [ğŸ§­] Write your first UI test

      Write your very first Compose UI test


   * [ğŸš€] Testing
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-testing?hl=en>`__

      Learn about testing Jetpack Compose UIs. Write your
      first tests, and learn about testing in isolation,
      debugging tests, the semantics tree, and test
      synchronization.


   * [ğŸ§­] How Compose improves UI testing

      Learn how Compose improves UI testing.


   * [ğŸ§­] Add accessibility features to your app

      Add accessibility features to your Jetpack Compose app.


   * [ğŸš€] Accessibility
      `Take codelab <https://developer.android.google.cn/codelabs/jetpack-compose-accessibility?hl=en>`__

      Learn how you can improve your app's usability,
      particularly for users with disabilities. Increase
      touch target sizes, add content descriptions, create
      custom actions, and more.


   * [ğŸ§­] Debugging recomposition

      A showcase of how we debugged and fixed a performance
      issue in one of the Compose sample apps.


   * [ğŸ§­] Performance Gotchas

      Jetpack Compose can feel like magic, but what do you
      do when the magic isn't as performant as you want?
      Discover best practices in Jetpack Compose with
      regards to performance, common mistakes, and how to
      avoid them.


   * [ğŸ§­] More performance tips

      Learn the details of why deferring reads of Compose
      state works, learn about stability and how Compose
      infers it, have a look at a new API for
      reportFullyDrawn, and more.


Form factors
------------

   https://developer.android.google.cn/courses/pathways/jetpack-compose-for-android-developers-5
   Use Compose to develop apps for multiple screen formats and device types.

   PATHWAY 5

   *  [ğŸ§­] Implementing Android apps for all screen sizes

      Get a better understanding of how to build your app to
      fill all screen formats. Explore development best
      practices to optimize applications for all devices
      with an emphasis on Jetpack Compose, navigation,
      managing state, and testing.

      Skip

   *  [ğŸš€] Build adaptive apps
      `Take codelab <https://codelabs.developers.google.cn/jetpack-compose-adaptability?hl=en>`__

      In this codelab youâ€™ll learn how to build adaptive
      apps for phones, tablets, and foldables, also learning
      about reachability. Youâ€™ll also learn best practices
      for Material 3 components and theming.


   *  [ğŸ§­] Compose for Wear OS introduction

      Learn what's similar, what's different, what's new in
      the Wear OS version of Compose, and quickly develop
      your own beautiful app with less code.

   *  [ğŸš€] Wear OS with Compose
      `Take codelab <https://developer.android.google.cn/codelabs/compose-for-wear-os?hl=en>`__

      In this codelab, youâ€™ll learn how to translate your
      Compose knowledge to wearables with the new Compose
      for Wear OS. By the end, youâ€™ll have created both
      simple and advanced composables in an app for your
      wrist.


   *  [ğŸ”¨] Compose and Glance for remote surfaces
      `Read article <https://android-developers.googleblog.com/2021/12/announcing-jetpack-glance-alpha-for-app.html>`__

      Glance offers similar modern, declarative Kotlin APIs
      that you are used to with Jetpack Compose, helping you
      build beautiful, responsive app widgets with way less
      code. Read the alpha release blog post to learn how to
      get started.



ğŸš€ Jetpack Compose basics
==========================

https://developer.android.google.cn/codelabs/jetpack-compose-basics?hl=en


1. Before you begin
-------------------


   `Jetpack Compose <https://developer.android.google.cn/jetpack/compose>`__ is a modern
   toolkit designed to simplify UI development. It combines a reactive programming model
   with the conciseness and ease of use of the Kotlin programming language. It is fully
   declarative, meaning you describe your UI by calling a series of functions that
   transform data into a UI hierarchy. When the underlying data changes, the framework
   automatically re-executes these functions, updating the UI hierarchy for you.

   A Compose app is made up of composable functions - just regular functions marked with
   ``@Composable``, which can call other composable functions. A function is all you need
   to create a new UI component. The annotation tells Compose to add special support to
   the function for updating and maintaining your UI over time. Compose lets you structure
   your code into small chunks. Composable functions are often referred to as
   "composables" for short.

   By making small reusable composables, it's easy to build up a library of UI elements
   used in your app. Each one is responsible for one part of the screen and can be edited
   independently.

   **Note**: In this codelab, the terms "UI Components," "Composable functions," and
   "composables" are used interchangeably to refer to the same concept.

   For more support as you're walking through this codelab, check out the following
   code-along:

   **Note**: The code-along uses Material 2 while the codelab is updated to use Material
   3. Be aware that there will be some steps where they are different.


Prerequisites

   -  Experience with Kotlin syntax, including lambdas


What you'll do

   In this codelab, you will learn:

   -  What Compose is
   -  How to build UIs with Compose
   -  How to manage state in composable functions
   -  How to create a performant list
   -  How to add animations
   -  How to style and theme an app

   You'll build an app with an onboarding screen, and a list of animated expanding items:

   |8d24a786bfe1a8f2.gif|


What you'll need

   -  `Latest Android Studio <https://developer.android.google.cn/studio>`__


2. Starting a new Compose project
---------------------------------


   To start a new Compose project, open Android Studio.

   If you're in the **Welcome to Android Studio** window, click **Start a new Android
   Studio** project. If you already have an Android Studio project open, select **File >
   New > New Project** from the menu bar.

   For a new project, choose **Empty Activity** from the available templates.

   |d12472c6323de500.png|

   Click **Next** and configure your project as usual, calling it "**Basics Codelab**".
   Make sure you select a *minimumSdkVersion* of at least API level 21, which is the
   minimum API Compose supports.

   **Note:** For more information about setting up Compose with an empty activity or
   adding it to an existing project, check out the `documentation <https://developer.android.google.cn/jetpack/compose/setup>`__.

   When choosing the **Empty Activity** template, the following code is generated for you
   in your project:

   -  The project is already configured to use Compose.
   -  The ``AndroidManifest.xml`` file is created.
   -  The ``build.gradle.kts`` and ``app/build.gradle.kts`` files contain options and
      dependencies needed for Compose.

   After syncing the project, open ``MainActivity.kt`` and check out the code.

   .. code:: prettyprint

      class MainActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContent {
                  BasicsCodelabTheme {
                      // A surface container using the 'background' color from the theme
                      Surface(
                          modifier = Modifier.fillMaxSize(),
                          color = MaterialTheme.colorScheme.background
                      ) {
                          Greeting("Android")
                      }
                  }
              }
          }
      }

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Text(
              text = "Hello $name!",
              modifier = modifier
          )
      }

      @Preview(showBackground = true)
      @Composable
      fun GreetingPreview() {
          BasicsCodelabTheme {
              Greeting("Android")
          }
      }

   **Warning**: The app theme used inside ``setContent`` depends on how your project is
   named. This codelab assumes that the project is called *BasicsCodelab*. If you
   copy-paste code from the codelab, don't forget to update ``BasicsCodelabTheme`` with
   the name of your theme available in the ``ui/Theme.kt`` file. We'll get into theming
   later in the codelab.

   In the next section, you'll see what each method does, and how you can improve them to
   create flexible and reusable layouts.


Solution to the codelab

   You can get the code for the solution of this codelab from GitHub:

   ::

      $ git clone https://github.com/android/codelab-android-compose

   Alternatively you can download the repository as a Zip file:

   `Download Zip <https://github.com/android/codelab-android-compose/archive/main.zip>`__

   You'll find the solution code in the ``BasicsCodelab`` project. We recommend that you
   follow the codelab step-by-step at your own pace and check the solution if you consider
   it necessary. During the codelab, you'll be presented with snippets of code that you'll
   need to add to the project.


3. Getting started with Compose
-------------------------------


   Go through the different classes and methods related to Compose that Android Studio has
   generated for you.


Composable functions

   A **composable function** is a regular function annotated with ``@Composable``. This
   enables your function to call other ``@Composable`` functions within it. You can see
   how the ``Greeting`` function is marked as ``@Composable``. This function will produce
   a piece of UI hierarchy displaying the given input, ``String``. ``Text`` is a
   composable function provided by the library.

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Text(
              text = "Hello $name!",
              modifier = modifier
          )
      }

   **Note:** Composable functions are Kotlin functions that are marked with the
   ``@Composable`` annotation, as you can see in the code snippet above.


Compose in an Android app

   With Compose, an ``Activity`` remains the entry point to an Android app. In our
   project, ``MainActivity`` is launched when the user opens the app (as it's specified in
   the ``AndroidManifest.xml`` file). You use ``setContent`` to define your layout, but
   instead of using an XML file as you'd do in the traditional View system, you call
   Composable functions within it.

   .. code:: prettyprint

      class MainActivity : AppCompatActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContent {
                  BasicsCodelabTheme {
                      // A surface container using the 'background' color from the theme
                      Surface(
                        modifier = Modifier.fillMaxSize(),
                        color = MaterialTheme.colorScheme.background
                      ) {
                          Greeting("Android")
                      }
                  }
              }
          }
      }

   ``BasicsCodelabTheme`` is a way to style Composable functions. You'll see more about
   this in the **Theming your app** section. To see how the text displays on the screen,
   you can either run the app in an emulator or device, or use the Android Studio preview.

   To use the Android Studio preview, you just have to mark any parameterless Composable
   function or functions with default parameters with the ``@Preview`` annotation and
   build your project. You can already see a ``Preview Composable`` function in the
   ``MainActivity.kt`` file. You can have multiple previews in the same file and give them
   names.

   .. code:: prettyprint

      @Preview(showBackground = true, name = "Text preview")
      @Composable
      fun GreetingPreview() {
          BasicsCodelabTheme {
              Greeting(name = "Android")
          }
      }

   |fb011e374b98ccff.png|

   **Note:** When importing classes related to Jetpack Compose in this project, use those
   from:

   -  ``androidx.compose.*`` for compiler and runtime classes
   -  ``androidx.compose.ui.*`` for UI toolkit and libraries

   The preview might not appear if **Code** |eeacd000622ba9b.png| is selected. Click
   **Split** |7093def1e32785b2.png| to see the preview.


4. Tweaking the UI
------------------


   Let's start by setting a different background color for the ``Greeting``. You can do
   this by wrapping the ``Text`` composable with a ``Surface``. ``Surface`` takes a color,
   so use **``MaterialTheme.colorScheme.primary``**.

   **Note**: ``Surface`` and ``MaterialTheme`` are concepts related to `Material Design <https://m3.material.io/>`__, 
   which is a design system created by Google to help you create user interfaces and experiences.

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Surface(color = MaterialTheme.colorScheme.primary) {
              Text(
                  text = "Hello $name!",
                  modifier = modifier
              )
          }
      }

   The components nested inside ``Surface`` will be drawn on top of that background color.

   **Note**: When you add that code to the project, your preview should refresh
   automatically. If it doesn't then you will see a **Build & Refresh** button in the
   top-right corner of Android Studio. Tap on it or build the project to see the new
   changes in the preview.

   |9632f3ca76cbe115.png|

   You can see the new changes in the preview:

   |c88121ec49bde8c7.png|

   You might have missed an important detail: **the text is now white**. When did we
   define this?

   You didn't! The Material components, such as ``androidx.compose.material3.Surface``,
   are built to make your experience better by taking care of common features that you
   probably want in your app, such as choosing an appropriate color for text. We say
   Material is *opinionated* because it provides good defaults and patterns that are
   common to most apps. The Material components in Compose are built on top of other
   foundational components (in ``androidx.compose.foundation``), which are also accessible
   from your app components in case you need more flexibility.

   In this case, ``Surface`` understands that, when the background is set to the
   ``primary`` color, any text on top of it should use the ``onPrimary`` color, which is
   also defined in the theme. You can learn more about this in the **Theming your app**
   section.

   **Note**: For an interactive list of Material components in Compose, check out the
   `Compose Material Catalog <https://play.google.com/store/apps/details?id=androidx.compose.material.catalog>`__
   app.


Modifiers

   Most Compose UI elements such as ``Surface`` and ``Text`` accept an optional
   ``modifier`` parameter. Modifiers tell a UI element how to lay out, display, or behave
   within its parent layout. You may have already noticed that the ``Greeting`` composable
   already has a default modifier, which is then passed to the ``Text``.

   For example, the ``padding`` modifier will apply an amount of space around the element
   it decorates. You can create a padding modifier with ``Modifier.padding()``. You can
   also add multiple modifiers by chaining them, so in our case we can add the padding
   modifier to the default one: ``modifier.padding(24.dp)``.

   Now, add padding to your ``Text`` on the screen:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.padding
      import androidx.compose.ui.unit.dp
      // ...

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Surface(color = MaterialTheme.colorScheme.primary) {
              Text(
                  text = "Hello $name!",
                  modifier = modifier.padding(24.dp)
              )
          }
      }

   |ef14f7c54ae7edf.png|

   There are dozens of modifiers which can be used to align, animate, lay out, make
   clickable or scrollable, transform, etc. For a comprehensive list, check out the 
   `List of Compose Modifiers <https://developer.android.google.cn/jetpack/compose/modifiers-list>`__.
   You'll use some of them in the next steps.


5. Reusing composables
----------------------


   The more components you add to the UI, the more levels of nesting you create. This can
   affect readability if a function becomes really large. By making small reusable
   components it's easy to build up a library of UI elements used in your app. Each one is
   responsible for one small part of the screen and can be edited independently.

   As a best practice, your function should include a Modifier parameter that is assigned
   an empty Modifier by default. Forward this modifier to the first composable you call
   inside your function. This way, the calling site can adapt layout instructions and
   behaviors from outside of your composable function.

   Create a Composable called ``MyApp`` that includes the greeting.

   .. code:: prettyprint

      @Composable
      fun MyApp(modifier: Modifier = Modifier) {
          Surface(
              modifier = modifier,
              color = MaterialTheme.colorScheme.background
          ) {
              Greeting("Android")
          }
      }

   This lets you clean up the ``onCreate`` callback and the preview as you can now reuse
   the ``MyApp`` composable, avoiding code duplication.

   In the preview, let's call ``MyApp`` and remove the name of the preview.

   Your ``MainActivity.kt`` file should look like this:

   .. code:: prettyprint

      package com.example.basicscodelab

      import android.os.Bundle
      import androidx.activity.ComponentActivity
      import androidx.activity.compose.setContent
      import androidx.compose.foundation.layout.fillMaxSize
      import androidx.compose.foundation.layout.padding
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Surface
      import androidx.compose.material3.Text
      import androidx.compose.runtime.Composable
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.tooling.preview.Preview
      import androidx.compose.ui.unit.dp
      import com.example.basicscodelab.ui.theme.BasicsCodelabTheme

      class MainActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContent {
                  BasicsCodelabTheme {
                      MyApp(modifier = Modifier.fillMaxSize())
                  }
              }
          }
      }

      @Composable
      fun MyApp(modifier: Modifier = Modifier) {
          Surface(
              modifier = modifier,
              color = MaterialTheme.colorScheme.background
          ) {
              Greeting("Android")
          }
      }

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Surface(color = MaterialTheme.colorScheme.primary) {
              Text(
                  text = "Hello $name!",
                  modifier = modifier.padding(24.dp)
              )
          }
      }

      @Preview(showBackground = true)
      @Composable
      fun GreetingPreview() {
          BasicsCodelabTheme {
              MyApp()
          }
      }


6. Creating columns and rows
----------------------------


   The three basic standard layout elements in Compose are ``Column``, ``Row`` and
   ``Box``.

   |518dbfad23ee1b05.png|

   They are Composable functions that take Composable content, so you can place items
   inside. For example, each child inside of a ``Column`` will be placed vertically.

   .. code:: prettyprint

      // Don't copy over
      Column {
          Text("First row")
          Text("Second row")
      }

   Now try to change ``Greeting`` so that it shows a column with two text elements like in
   this example:

   |bf27ee688c3231df.png|

   Note that you might have to move the padding around.

   Compare your result with this solution:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Column
      // ...

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Surface(color = MaterialTheme.colorScheme.primary) {
              Column(modifier = modifier.padding(24.dp)) {
                  Text(text = "Hello ")
                  Text(text = name)
              }
          }
      }


Compose and Kotlin

   Composable functions can be used like any other function in Kotlin. This makes building
   UIs really powerful since you can add statements to influence how the UI will be
   displayed.

   For example, you can use a ``for`` loop to add elements to the ``Column``:

   .. code:: prettyprint

      @Composable
      fun MyApp(
          modifier: Modifier = Modifier,
          names: List<String> = listOf("World", "Compose")
      ) {
          Column(modifier) {
              for (name in names) {
                  Greeting(name = name)
              }
          }
      }

   |a7ba2a8cb7a7d79d.png|

   You haven't set dimensions or added any constraints to the size of your composables
   yet, so each row takes the minimum space it can and the preview does the same thing.
   Let's change our preview to emulate a common width of a small phone, 320dp. Add a
   ``widthDp`` parameter to the ``@Preview`` annotation like so:

   .. code:: prettyprint

      @Preview(showBackground = true, widthDp = 320)
      @Composable
      fun GreetingPreview() {
          BasicsCodelabTheme {
              MyApp()
          }
      }

   |a5d5f6cdbdd918a2.png|

   Modifiers are used extensively in Compose so let's practice with a more advanced
   exercise: Try to replicate the following layout using the `fillMaxWidth <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier).fillMaxSize(kotlin.Float)>`__
   and `padding <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier).padding(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)>`__
   modifiers.

   |a9599061cf49a214.png|

   Now compare your code with the solution:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.fillMaxWidth

      @Composable
      fun MyApp(
          modifier: Modifier = Modifier,
          names: List<String> = listOf("World", "Compose")
      ) {
          Column(modifier = modifier.padding(vertical = 4.dp)) {
              for (name in names) {
                  Greeting(name = name)
              }
          }
      }

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Surface(
              color = MaterialTheme.colorScheme.primary,
              modifier = modifier.padding(vertical = 4.dp, horizontal = 8.dp)
          ) {
              Column(modifier = Modifier.fillMaxWidth().padding(24.dp)) {
                  Text(text = "Hello ")
                  Text(text = name)
              }
          }
      }

   Note that:

   -  Modifiers can have overloads so, for example, you can specify different ways to
      create a padding.
   -  To add multiple modifiers to an element, you simply chain them.

   There are multiple ways to achieve this result, so if your code doesn't match this
   snippet, that doesn't mean your code is wrong. However, copy and paste this code to
   continue with the codelab.


Adding a button

   In the next step you'll add a clickable element that expands the ``Greeting``, so we
   need to add that button first. The goal is to create the following layout:

   |ff2d8c3c1349a891.png|

   ``Button`` is a composable provided by the material3 package which takes a composable
   as the last argument. Since `trailing lambdas <https://kotlinlang.org/docs/lambdas.html#passing-trailing-lambdas>`__ 
   can be moved outside of the parentheses, you can add any content to the button as a 
   child. For example, a ``Text``:

   .. code:: prettyprint

      // Don't copy yet
      Button(
          onClick = { } // You'll learn about this callback later
      ) {
          Text("Show less")
      }

   **Note:** Compose provides different types of ``Button`` according to the 
   `Material Design Buttons spec <https://m3.material.io/components/buttons/implementation/android>`__
   â€” ``Button``, ``ElevatedButton``, ``FilledTonalButton``, ``OutlinedButton``, and 
   ``TextButton``. In your case, you'll use an ``ElevatedButton`` that wraps a ``Text`` 
   as the ``ElevatedButton`` content.

   To achieve this you need to learn how to place a composable at the end of a row.
   There's no ``alignEnd`` modifier so, instead, you give some ``weight`` to the
   composable at the start. The ``weight`` modifier makes the element fill all available
   space, making it *flexible*, effectively pushing away the other elements that don't
   have a weight, which are called *inflexible*. It also makes the ``fillMaxWidth``
   modifier redundant.

   Now try to add the button and place it as shown in the previous image.

   Check out the solution here:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Row
      import androidx.compose.material3.ElevatedButton
      // ...

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          Surface(
              color = MaterialTheme.colorScheme.primary,
              modifier = modifier.padding(vertical = 4.dp, horizontal = 8.dp)
          ) {
              Row(modifier = Modifier.padding(24.dp)) {
                  Column(modifier = Modifier.weight(1f)) {
                      Text(text = "Hello ")
                      Text(text = name)
                  }
                  ElevatedButton(
                      onClick = { /* TODO */ }
                  ) {
                      Text("Show more")
                  }
              }
          }
      }


7. State in Compose
-------------------


   In this section you'll add some interaction to your screen. So far you've created
   static layouts but now you'll make them react to user changes to achieve this:

   |6675d41779cac69.gif|

   Before getting into how to make a button clickable and how to resize an item, you need
   to store some value somewhere that indicates whether each item is expanded or notâ€“the
   **state** of the item. Since we need to have one of these values per greeting, the
   logical place for it is in the ``Greeting`` composable. Take a look at this
   ``expanded`` boolean and how it's used in the code:

   .. code:: prettyprint

      // Don't copy over
      @Composable
      fun Greeting(name: String) {
          var expanded = false // Don't do this!

          Surface(
              color = MaterialTheme.colorScheme.primary,
              modifier = Modifier.padding(vertical = 4.dp, horizontal = 8.dp)
          ) {
              Row(modifier = Modifier.padding(24.dp)) {
                  Column(modifier = Modifier.weight(1f)) {
                      Text(text = "Hello, ")
                      Text(text = name)
                  }
                  ElevatedButton(
                      onClick = { expanded = !expanded }
                  ) {
                      Text(if (expanded) "Show less" else "Show more")
                  }
              }
          }
      }

   Note that we also added an ``onClick`` action and a dynamic button text. More on that
   later.

   However, **this won't work as expected**. Setting a different value for the
   ``expanded`` variable won't make Compose detect it as a *state change* so nothing will
   happen.

   **Note**: Compose apps transform data into UI by calling composable functions. If your
   data changes, Compose re-executes these functions with the new data, creating an
   updated UIâ€”this is called **recomposition**. Compose also looks at what data is needed
   by an individual composable so that it only needs to recompose components whose data
   has changed and skip recomposing those that are not affected.

   As mentioned in `Thinking in Compose <https://developer.android.google.cn/jetpack/compose/mental-model#recomposition>`__:

   *Composable functions can execute frequently and in any order, you must not rely on the
   ordering in which the code is executed, or on how many times this function will be
   recomposed.*

   The reason why mutating this variable does not trigger recompositions is that **it's
   not being tracked by Compose**. Also, each time ``Greeting`` is called, the variable
   will be reset to false.

   To add internal state to a composable, you can use the ``mutableStateOf`` function,
   which makes Compose recompose functions that read that ``State``.

   **Note:** ``State`` and ``MutableState`` are interfaces that hold some value and
   trigger UI updates (recompositions) whenever that value changes.

   .. code:: prettyprint

      import androidx.compose.runtime.mutableStateOf
      // ...

      // Don't copy over
      @Composable
      fun Greeting() {
          val expanded = mutableStateOf(false) // Don't do this!
      }

   However **you can't just assign** ``mutableStateOf`` **to a variable inside a
   composable**. As explained before, recomposition can happen at any time which would
   call the composable again, resetting the state to a new mutable state with a value of
   ``false``.

   To preserve state across recompositions, *remember* the mutable state using
   ``remember``.

   .. code:: prettyprint

      import androidx.compose.runtime.mutableStateOf
      import androidx.compose.runtime.remember
      // ...

      @Composable
      fun Greeting(...) {
          val expanded = remember { mutableStateOf(false) }
          // ...
      }

   ``remember`` is used to **guard** against recomposition, so the state is not reset.

   Note that if you call the same composable from different parts of the screen you will
   create different UI elements, each with its own version of the state. **You can think
   of internal state as a private variable in a class.**

   The composable function will automatically be "subscribed" to the state. If the state
   changes, composables that read these fields will be recomposed to display the updates.


Mutating state and reacting to state changes

   In order to change the state, you might have noticed that ``Button`` has a parameter
   called ``onClick`` but it doesn't take a value, **it takes a function**.

   **Note**: If you're not familiar with functions being used this way, it is a very
   powerful Kotlin feature that is used extensively in Compose. Functions are 
   `first class citizens in Kotlin <https://kotlinlang.org/docs/lambdas.html>`__, 
   so they can be assigned to a variable, passed into other functions and even be returned from them. 
   You can `read how Compose uses Kotlin features here <https://developer.android.google.cn/jetpack/compose/kotlin#higher-order>`__.

   To learn more about how functions are defined and how you can instantiate them, read
   the `Function Types documentation <https://kotlinlang.org/docs/lambdas.html#function-types>`__.

   You can define the action to take *on click* by assigning a `lambda expression <https://kotlinlang.org/docs/lambdas.html#lambda-expression-syntax>`__ 
   to it. For example, let's toggle the value of the expanded state, and show a different
   text depending on the value.

   .. code:: prettyprint

      ElevatedButton(
          onClick = { expanded.value = !expanded.value },
      ) {
         Text(if (expanded.value) "Show less" else "Show more")
      }

   Run the app in interactive mode to see the behavior.

   |374998ad358bf8d6.png|

   When the button is clicked, ``expanded`` is toggled triggering a recomposition of the
   text inside the button. Each ``Greeting`` maintains its own expanded state, because
   they belong to different UI elements.

   |93d839b53b7d9bea.gif|

   Code up to this point:

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          val expanded = remember { mutableStateOf(false) }
          Surface(
              color = MaterialTheme.colorScheme.primary,
              modifier = modifier.padding(vertical = 4.dp, horizontal = 8.dp)
          ) {
              Row(modifier = Modifier.padding(24.dp)) {
                  Column(modifier = Modifier.weight(1f)) {
                      Text(text = "Hello ")
                      Text(text = name)
                  }
                  ElevatedButton(
                      onClick = { expanded.value = !expanded.value }
                  ) {
                      Text(if (expanded.value) "Show less" else "Show more")
                  }
              }
          }
      }


Expanding the item

   Now let's actually expand an item when requested. Add an additional variable that
   depends on our state:

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {

          val expanded = remember { mutableStateOf(false) }

          val extraPadding = if (expanded.value) 48.dp else 0.dp
      // ...

   You don't need to remember ``extraPadding`` against recomposition because it's doing a
   simple calculation.

   And now we can apply a new padding modifier to the Column:

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {
          val expanded = remember { mutableStateOf(false) }
          val extraPadding = if (expanded.value) 48.dp else 0.dp
          Surface(
              color = MaterialTheme.colorScheme.primary,
              modifier = modifier.padding(vertical = 4.dp, horizontal = 8.dp)
          ) {
              Row(modifier = Modifier.padding(24.dp)) {
                  Column(
                      modifier = Modifier
                          .weight(1f)
                          .padding(bottom = extraPadding)
                  ) {
                      Text(text = "Hello ")
                      Text(text = name)
                  }
                  ElevatedButton(
                      onClick = { expanded.value = !expanded.value }
                  ) {
                      Text(if (expanded.value) "Show less" else "Show more")
                  }
              }
          }
      }

   If you run on an emulator or in the interactive mode, you should see that each item can
   be expanded independently:

   |6675d41779cac69.gif|


8. State hoisting
-----------------


   In Composable functions, state that is read or modified by multiple functions should
   live in a common ancestorâ€”this process is called **state hoisting**. To *hoist* means
   to *lift* or *elevate*.

   Making state hoistable avoids duplicating state and introducing bugs, helps reuse
   composables, and makes composables substantially easier to test. Contrarily, state that
   doesn't need to be controlled by a composable's parent should not be hoisted. The
   **source of truth** belongs to whoever creates and controls that state.

   For example, let's create an onboarding screen for our app.

   |5d5f44508fcfa779.png|

   Add the following code to ``MainActivity.kt``:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Arrangement
      import androidx.compose.material3.Button
      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.setValue
      import androidx.compose.ui.Alignment
      // ...

      @Composable
      fun OnboardingScreen(modifier: Modifier = Modifier) {
          // TODO: This state should be hoisted
          var shouldShowOnboarding by remember { mutableStateOf(true) }

          Column(
              modifier = modifier.fillMaxSize(),
              verticalArrangement = Arrangement.Center,
              horizontalAlignment = Alignment.CenterHorizontally
          ) {
              Text("Welcome to the Basics Codelab!")
              Button(
                  modifier = Modifier.padding(vertical = 24.dp),
                  onClick = { shouldShowOnboarding = false } 
              ) {
                  Text("Continue")
              }
          }
      }

      @Preview(showBackground = true, widthDp = 320, heightDp = 320)
      @Composable
      fun OnboardingPreview() {
          BasicsCodelabTheme {
              OnboardingScreen()
          }
      }

   This code contains a bunch of new features:

   -  You have added a new composable called ``OnboardingScreen`` and also a new
      **preview**. If you build the project you'll notice you can have multiple previews
      at the same time. We also added a fixed height to verify that the content is aligned
      correctly.
   -  ``Column`` can be configured to display its contents in the center of the screen.
   -  ``shouldShowOnboarding`` is using a ``by`` keyword instead of the ``=``. This is a
      property delegate that saves you from typing ``.value`` every time.
   -  When the button is clicked, ``shouldShowOnboarding`` is set to ``false``, however
      you are not reading the state from anywhere yet.

   Now we can add this new onboarding screen to our app. We want to show it on launch and
   then hide it when the user presses "Continue".

   In Compose **you don't hide UI elements**. Instead, you simply don't add them to the
   composition, so they're not added to the UI tree that Compose generates. You do this
   with simple conditional Kotlin logic. For example to show the onboarding screen or the
   list of greetings you would do something like:

   .. code:: prettyprint

      // Don't copy yet
      @Composable
      fun MyApp(modifier: Modifier = Modifier) {
          Surface(modifier) {
              if (shouldShowOnboarding) { // Where does this come from?
                  OnboardingScreen()
              } else {
                  Greetings()
              }
          }
      }

   However we don't have access to ``shouldShowOnboarding`` . It's clear that we need to
   share the state that we created in ``OnboardingScreen`` with the ``MyApp`` composable.

   Instead of somehow sharing the value of the state with its parent, we **hoist** the
   stateâ€“we simply move it to the common ancestor that needs to access it.

   First, move the content of ``MyApp`` into a new composable called ``Greetings``. Also
   adapt the preview to call the ``Greetings`` method instead:

   .. code:: prettyprint

      @Composable
      fun MyApp(modifier: Modifier = Modifier) {
           Greetings()
      }

      @Composable
      private fun Greetings(
          modifier: Modifier = Modifier,
          names: List<String> = listOf("World", "Compose")
      ) {
          Column(modifier = modifier.padding(vertical = 4.dp)) {
              for (name in names) {
                  Greeting(name = name)
              }
          }
      }

      @Preview(showBackground = true, widthDp = 320)
      @Composable
      fun GreetingsPreview() {
          BasicsCodelabTheme {
              Greetings()
          }
      }

   Add a preview for our new top level MyApp composable so we can test its behavior:

   .. code:: prettyprint

      @Preview
      @Composable
      fun MyAppPreview() {
          BasicsCodelabTheme {
              MyApp(Modifier.fillMaxSize())
          }
      }

   Now add the logic to show the different screens in ``MyApp``, and **hoist** the state.

   .. code:: prettyprint

      @Composable
      fun MyApp(modifier: Modifier = Modifier) {

          var shouldShowOnboarding by remember { mutableStateOf(true) }

          Surface(modifier) {
              if (shouldShowOnboarding) {
                  OnboardingScreen(/* TODO */)
              } else {
                  Greetings()
              }
          }
      }

   We also need to share ``shouldShowOnboarding`` with the onboarding screen but we are
   not going to pass it directly. Instead of letting ``OnboardingScreen`` mutate our
   state, it would be better to let it notify us when the user clicked on the *Continue*
   button.

   How do we pass events up? By **passing callbacks down**. Callbacks are functions that
   are passed as arguments to other functions and get executed when the event occurs.

   Try to add a function parameter to the onboarding screen defined as
   ``onContinueClicked: () -> Unit`` so you can mutate the state from ``MyApp``.

   Solution:

   .. code:: prettyprint

      @Composable
      fun MyApp(modifier: Modifier = Modifier) {

          var shouldShowOnboarding by remember { mutableStateOf(true) }

          Surface(modifier) {
              if (shouldShowOnboarding) {
                  OnboardingScreen(onContinueClicked = { shouldShowOnboarding = false })
              } else {
                  Greetings()
              }
          }
      }

      @Composable
      fun OnboardingScreen(
          onContinueClicked: () -> Unit,
          modifier: Modifier = Modifier
      ) {


          Column(
              modifier = modifier.fillMaxSize(),
              verticalArrangement = Arrangement.Center,
              horizontalAlignment = Alignment.CenterHorizontally
          ) {
              Text("Welcome to the Basics Codelab!")
              Button(
                  modifier = Modifier
                      .padding(vertical = 24.dp),
                  onClick = onContinueClicked
              ) {
                  Text("Continue")
              }
          }

      }

   By passing a function and not a state to ``OnboardingScreen`` we are making this
   composable more reusable and protecting the state from being mutated by other
   composables. In general, it keeps things simple. A good example is how the onboarding
   preview needs to be modified to call the ``OnboardingScreen`` now:

   .. code:: prettyprint

      @Preview(showBackground = true, widthDp = 320, heightDp = 320)
      @Composable
      fun OnboardingPreview() {
          BasicsCodelabTheme {
              OnboardingScreen(onContinueClicked = {}) // Do nothing on click.
          }
      }

   Assigning ``onContinueClicked`` to an empty lambda expression means "do nothing", which
   is perfect for a preview.

   This is looking more and more like a real app, good job!

   |25915eb273a7ef49.gif|

   In ``MyApp`` composable we used the ``by`` property delegate for the first time to
   avoid using value every time. Let's use ``by`` instead of ``=`` also in the Greeting
   composable for the ``expanded`` property. Make sure you change ``expanded`` from
   ``val`` to ``var``.

   Full code so far:

   .. code:: prettyprint

      package com.example.basicscodelab

      import android.os.Bundle
      import androidx.activity.ComponentActivity
      import androidx.activity.compose.setContent
      import androidx.compose.foundation.layout.Arrangement
      import androidx.compose.foundation.layout.Column
      import androidx.compose.foundation.layout.Row
      import androidx.compose.foundation.layout.fillMaxSize
      import androidx.compose.foundation.layout.padding
      import androidx.compose.material3.Button
      import androidx.compose.material3.ElevatedButton
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Surface
      import androidx.compose.material3.Text
      import androidx.compose.runtime.Composable
      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.mutableStateOf
      import androidx.compose.runtime.remember
      import androidx.compose.runtime.setValue
      import androidx.compose.ui.Alignment
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.tooling.preview.Preview
      import androidx.compose.ui.unit.dp
      import com.codelab.basics.ui.theme.BasicsCodelabTheme

      class MainActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContent {
                  BasicsCodelabTheme {
                      MyApp(modifier = Modifier.fillMaxSize())
                  }
              }
          }
      }

      @Composable
      fun MyApp(modifier: Modifier = Modifier) {

          var shouldShowOnboarding by remember { mutableStateOf(true) }

          Surface(modifier) {
              if (shouldShowOnboarding) {
                  OnboardingScreen(onContinueClicked = { shouldShowOnboarding = false })
              } else {
                  Greetings()
              }
          }
      }

      @Composable
      fun OnboardingScreen(
          onContinueClicked: () -> Unit,
          modifier: Modifier = Modifier
      ) {

          Column(
              modifier = modifier.fillMaxSize(),
              verticalArrangement = Arrangement.Center,
              horizontalAlignment = Alignment.CenterHorizontally
          ) {
              Text("Welcome to the Basics Codelab!")
              Button(
                  modifier = Modifier.padding(vertical = 24.dp),
                  onClick = onContinueClicked
              ) {
                  Text("Continue")
              }
          }
      }

      @Composable
      private fun Greetings(
          modifier: Modifier = Modifier,
          names: List<String> = listOf("World", "Compose")
      ) {
          Column(modifier = modifier.padding(vertical = 4.dp)) {
              for (name in names) {
                  Greeting(name = name)
              }
          }
      }

      @Preview(showBackground = true, widthDp = 320, heightDp = 320)
      @Composable
      fun OnboardingPreview() {
          BasicsCodelabTheme {
              OnboardingScreen(onContinueClicked = {})
          }
      }

      @Composable
      fun Greeting(name: String, modifier: Modifier = Modifier) {

          var expanded by remember { mutableStateOf(false) }

          val extraPadding = if (expanded) 48.dp else 0.dp

          Surface(
              color = MaterialTheme.colorScheme.primary,
              modifier = modifier.padding(vertical = 4.dp, horizontal = 8.dp)
          ) {
              Row(modifier = Modifier.padding(24.dp)) {
                  Column(
                      modifier = Modifier
                      .weight(1f)
                      .padding(bottom = extraPadding)
                  ) {
                      Text(text = "Hello, ")
                      Text(text = name)
                  }
                  ElevatedButton(
                      onClick = { expanded = !expanded }
                  ) {
                      Text(if (expanded) "Show less" else "Show more")
                  }
              }
          }
      }

      @Preview(showBackground = true, widthDp = 320)
      @Composable
      fun GreetingPreview() {
          BasicsCodelabTheme {
              Greetings()
          }
      }

      @Preview
      @Composable
      fun MyAppPreview() {
          BasicsCodelabTheme {
              MyApp(Modifier.fillMaxSize())
          }
      }


9. Creating a performant lazy list
----------------------------------


   Now let's make the names list more realistic. So far you have displayed two greetings
   in a ``Column``. But, can it handle thousands of them?

   Change the default list value in the ``Greetings`` parameters to use another list
   constructor which allows to set the list size and fill it with the value contained in
   its lambda (here ``$it`` represents the list index):

   .. code:: prettyprint

      names: List<String> = List(1000) { "$it" }

   This creates 1000 greetings, even the ones that don't fit in the screen. Obviously this
   is not performant. You can try to run it on an emulator (warning: this code might
   freeze your emulator).

   To display a scrollable column we use a ``LazyColumn``. ``LazyColumn`` renders only the
   visible items on screen, allowing performance gains when rendering a big list.

   **Note**: ``LazyColumn`` and ``LazyRow`` are equivalent to ``RecyclerView`` in Android
   Views.

   In its basic usage, the ``LazyColumn`` API provides an ``items`` element within its
   scope, where individual item rendering logic is written:

   .. code:: prettyprint

      import androidx.compose.foundation.lazy.LazyColumn
      import androidx.compose.foundation.lazy.items
      // ...

      @Composable
      private fun Greetings(
          modifier: Modifier = Modifier,
          names: List<String> = List(1000) { "$it" } 
      ) {
          LazyColumn(modifier = modifier.padding(vertical = 4.dp)) {
              items(items = names) { name ->
                  Greeting(name = name)
              }
          }
      }

   **Note:** Make sure you import ``androidx.compose.foundation.lazy.items`` as Android
   Studio will pick a different items function by default.

   **Note:** ``LazyColumn`` doesn't recycle its children like ``RecyclerView``. It emits
   new Composables as you scroll through it and is still performant, as emitting
   Composables is relatively cheap compared to instantiating Android ``Views``.

   |284f925eb984fb56.gif|


10. Persisting state
--------------------


   Our app has two problems:

   *  Persisting the expanded state of the list items
   *  Persisting the onboarding screen state


Persisting the onboarding screen state

   If you run the app on a device, click on the buttons and then you rotate, the
   onboarding screen is shown again. The ``remember`` function works **only as long as the
   composable is kept in the Composition**. When you rotate, the whole activity is
   restarted so all state is lost. This also happens with any configuration change and on
   process death.

   Instead of using ``remember`` you can use ``rememberSaveable``. This will save each
   state surviving configuration changes (such as rotations) and process death.

   Now replace the use of ``remember`` in ``shouldShowOnboarding`` with
   ``rememberSaveable``:

   .. code:: prettyprint

          import androidx.compose.runtime.saveable.rememberSaveable
          // ...

          var shouldShowOnboarding by rememberSaveable { mutableStateOf(true) }

   Run, rotate, change to dark mode or kill the process. The onboarding screen is not
   shown unless you have previously exited the app.


Persisting the expanded state of the list items

   If you expand a list item and then either scroll the list until the item is out of
   view, or rotate the device and then go back to the expanded item, you'll see that the
   item is now back to its initial state.

   The solution for this is to use rememberSaveable for the expanded state as well:

   .. code:: prettyprint

         var expanded by rememberSaveable { mutableStateOf(false) }

   With around 120 lines of code so far, you were able to display a long and performant
   scrolling list of items each holding their own state. Also, as you can see, your app
   has a perfectly correct dark mode without extra lines of code. You'll learn about
   theming later.


11. Animating your list
-----------------------


   In Compose, there are multiple ways to animate your UI: from high-level APIs for simple
   animations to low-level methods for full control and complex transitions. You can read
   about them in the `documentation <https://developer.android.google.cn/jetpack/compose/animation>`__.

   In this section you will use one of the low-level APIs but don't worry, they can also
   be very simple. Let's animate the change in size that we already implemented:

   |9efa14ce118d3835.gif|

   For this you'll use the ``animateDpAsState`` composable. It returns a State object
   whose ``value`` will continuously be updated by the animation until it finishes. It
   takes a "target value" whose type is ``Dp``.

   Create an animated ``extraPadding`` that depends on the expanded state.

   .. code:: prettyprint

      import androidx.compose.animation.core.animateDpAsState

      @Composable
      private fun Greeting(name: String, modifier: Modifier = Modifier) {

          var expanded by rememberSaveable { mutableStateOf(false) }

          val extraPadding by animateDpAsState(
              if (expanded) 48.dp else 0.dp
          )
          Surface(
              color = MaterialTheme.colorScheme.primary,
              modifier = modifier.padding(vertical = 4.dp, horizontal = 8.dp)
          ) {
              Row(modifier = Modifier.padding(24.dp)) {
                  Column(modifier = Modifier
                      .weight(1f)
                      .padding(bottom = extraPadding)
                  ) {
                      Text(text = "Hello, ")
                      Text(text = name)
                  }
                  ElevatedButton(
                      onClick = { expanded = !expanded }
                  ) {
                      Text(if (expanded) "Show less" else "Show more")
                  }

              }
          }
      }

   Run the app and try the animation out.

   **Note**: If you expand item number 1, you scroll away to number 20 and come back to 1,
   you'll notice that 1 is back to the original size. You could save this data with
   ``rememberSaveable`` if it were a requirement, but we are keeping the example simple.

   ``animateDpAsState`` takes an optional ``animationSpec`` parameter that lets you
   customize the animation. Let's do something more fun like adding a spring-based
   animation:

   .. code:: prettyprint

      import androidx.compose.animation.core.Spring
      import androidx.compose.animation.core.spring


      @Composable
      private fun Greeting(name: String, modifier: Modifier = Modifier) {

          var expanded by rememberSaveable { mutableStateOf(false) }

          val extraPadding by animateDpAsState(
              if (expanded) 48.dp else 0.dp,
              animationSpec = spring(
                  dampingRatio = Spring.DampingRatioMediumBouncy,
                  stiffness = Spring.StiffnessLow
              )
          )

          Surface(
          // ...
                  Column(modifier = Modifier
                      .weight(1f)
                      .padding(bottom = extraPadding.coerceAtLeast(0.dp))

          // ...

          )
      }

   Note that we are also making sure that padding is never negative, otherwise it could
   crash the app. This introduces a subtle animation bug that we'll fix later in
   **Finishing touches**.

   The ``spring`` spec does not take any time-related parameters. Instead it relies on
   physical properties (damping and stiffness) to make animations more natural. Run the
   app now to try the new animation:

   |9efa14ce118d3835.gif|

   Any animation created with ``animate*AsState`` is interruptible. This means that if the
   target value changes in the middle of the animation, ``animate*AsState`` restarts the
   animation and points to the new value. Interruptions look especially natural with
   spring-based animations:

   |d5dbf92de69db775.gif|

   If you want to explore the different types of animations, try out different parameters
   for ``spring``, different specs (``tween``, ``repeatable``) and different functions:
   ``animateColorAsState`` or a `different type of animation API <https://developer.android.google.cn/jetpack/compose/animation>`__.


Full code for this section

   .. code:: prettyprint

      package com.example.basicscodelab

      import android.os.Bundle
      import androidx.activity.ComponentActivity
      import androidx.activity.compose.setContent
      import androidx.compose.animation.core.Spring
      import androidx.compose.animation.core.animateDpAsState
      import androidx.compose.animation.core.spring
      import androidx.compose.foundation.layout.Arrangement
      import androidx.compose.foundation.layout.Column
      import androidx.compose.foundation.layout.Row
      import androidx.compose.foundation.layout.fillMaxSize
      import androidx.compose.foundation.layout.padding
      import androidx.compose.foundation.lazy.LazyColumn
      import androidx.compose.foundation.lazy.items
      import androidx.compose.material3.Button
      import androidx.compose.material3.ElevatedButton
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Surface
      import androidx.compose.material3.Text
      import androidx.compose.runtime.Composable
      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.mutableStateOf
      import androidx.compose.runtime.saveable.rememberSaveable
      import androidx.compose.runtime.setValue
      import androidx.compose.ui.Alignment
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.tooling.preview.Preview
      import androidx.compose.ui.unit.dp
      import com.codelab.basics.ui.theme.BasicsCodelabTheme

      class MainActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContent {
                  BasicsCodelabTheme {
                      MyApp(modifier = Modifier.fillMaxSize())
                  }
              }
          }
      }

      @Composable
      fun MyApp(modifier: Modifier = Modifier) {

          var shouldShowOnboarding by rememberSaveable { mutableStateOf(true) }

          Surface(modifier) {
              if (shouldShowOnboarding) {
                  OnboardingScreen(onContinueClicked = { shouldShowOnboarding = false })
              } else {
                  Greetings()
              }
          }
      }

      @Composable
      fun OnboardingScreen(
          onContinueClicked: () -> Unit,
          modifier: Modifier = Modifier
      ) {


          Column(
              modifier = modifier.fillMaxSize(),
              verticalArrangement = Arrangement.Center,
              horizontalAlignment = Alignment.CenterHorizontally
          ) {
              Text("Welcome to the Basics Codelab!")
              Button(
                  modifier = Modifier.padding(vertical = 24.dp),
                  onClick = onContinueClicked
              ) {
                  Text("Continue")
              }
          }

      }

      @Composable
      private fun Greetings(
          modifier: Modifier = Modifier,
          names: List<String> = List(1000) { "$it" }
      ) {
          LazyColumn(modifier = modifier.padding(vertical = 4.dp)) {
              items(items = names) { name ->
                  Greeting(name = name)
              }
          }
      }

      @Preview(showBackground = true, widthDp = 320, heightDp = 320)
      @Composable
      fun OnboardingPreview() {
          BasicsCodelabTheme {
              OnboardingScreen(onContinueClicked = {})
          }
      }

      @Composable
      private fun Greeting(name: String, modifier: Modifier = Modifier) {

          var expanded by rememberSaveable { mutableStateOf(false) }

          val extraPadding by animateDpAsState(
              if (expanded) 48.dp else 0.dp,
              animationSpec = spring(
                  dampingRatio = Spring.DampingRatioMediumBouncy,
                  stiffness = Spring.StiffnessLow
              )
          )
          Surface(
              color = MaterialTheme.colorScheme.primary,
              modifier = modifier.padding(vertical = 4.dp, horizontal = 8.dp)
          ) {
              Row(modifier = Modifier.padding(24.dp)) {
                  Column(modifier = Modifier
                      .weight(1f)
                      .padding(bottom = extraPadding.coerceAtLeast(0.dp))
                  ) {
                      Text(text = "Hello, ")
                      Text(text = name)
                  }
                  ElevatedButton(
                      onClick = { expanded = !expanded }
                  ) {
                      Text(if (expanded) "Show less" else "Show more")
                  }
              }
          }
      }

      @Preview(showBackground = true, widthDp = 320)
      @Composable
      fun GreetingPreview() {
          BasicsCodelabTheme {
              Greetings()
          }
      }

      @Preview
      @Composable
      fun MyAppPreview() {
          BasicsCodelabTheme {
              MyApp(Modifier.fillMaxSize())
          }
      }


12. Styling and theming your app
--------------------------------


   You didn't style any of the composables so far and yet you got a decent default,
   including dark mode support! Let's look into what ``BasicsCodelabTheme`` and
   ``MaterialTheme`` are.

   If you open the ``ui/theme/Theme.kt`` file, you see that ``BasicsCodelabTheme`` uses
   ``MaterialTheme`` in its implementation:

   .. code:: prettyprint

      // Do not copy
      @Composable
      fun BasicsCodelabTheme(
          darkTheme: Boolean = isSystemInDarkTheme(),
          // Dynamic color is available on Android 12+
          dynamicColor: Boolean = true,
          content: @Composable () -> Unit
      ) {
          // ...

          MaterialTheme(
              colorScheme = colorScheme,
              typography = Typography,
              content = content
          )
      }

   ``MaterialTheme`` is a composable function that reflects the styling principles from
   the `Material design specification <https://m3.material.io/>`__. That styling
   information cascades down to the components that are inside its ``content``, which may
   read the information to style themselves. In your UI, you are already using
   ``BasicsCodelabTheme`` as follows:

   .. code:: prettyprint

          BasicsCodelabTheme {
              MyApp(modifier = Modifier.fillMaxSize())
          }

   Because ``BasicsCodelabTheme`` wraps ``MaterialTheme`` internally, ``MyApp`` is styled
   with the properties defined in the theme. From any descendant composable you can
   retrieve three properties of ``MaterialTheme``: ``colorScheme``, ``typography`` and
   ``shapes``. Use them to set a header style for one of your ``Text``\ s:

   .. code:: prettyprint

                  Column(modifier = Modifier
                      .weight(1f)
                      .padding(bottom = extraPadding.coerceAtLeast(0.dp))
                  ) {
                      Text(text = "Hello, ")
                      Text(text = name, style = MaterialTheme.typography.headlineMedium)
                  }

   The ``Text`` composable in the example above sets a new ``TextStyle``. You can create
   your own ``TextStyle``, or you can retrieve a theme-defined style by using
   ``MaterialTheme.typography``, which is preferred. This construct gives you access to
   the Material-defined text styles, such as
   ``displayLarge, headlineMedium, titleSmall, bodyLarge, labelMedium`` etc. In your
   example, you use the ``headlineMedium`` style defined in the theme.

   Now build to see our newly styled text:

   |673955c38b076f1c.png|

   In general it's much better to keep your colors, shapes and font styles inside a
   ``MaterialTheme``. For example, dark mode would be hard to implement if you hard-code
   colors and it would require a lot of error-prone work to fix.

   However sometimes you need to deviate slightly from the selection of colors and font
   styles. In those situations it's better to base your color or style on an existing one.

   For this, you can modify a predefined style by using the ``copy`` function. Make the
   number extra bold:

   .. code:: prettyprint

      import androidx.compose.ui.text.font.FontWeight
      // ...
      Text(
          text = name,
          style = MaterialTheme.typography.headlineMedium.copy(
              fontWeight = FontWeight.ExtraBold
          )
      )

   This way if you need to change the font family or any other attribute of
   ``headlineMedium``, you don't have to worry about the small deviations.

   Now this should be the result in the preview window:

   |b33493882bda9419.png|


Set up a dark mode preview

   Currently, our preview shows only what the app will look like in light mode. Add an
   additional ``@Preview`` annotation to ``GreetingPreview`` with ``UI_MODE_NIGHT_YES``:

   .. code:: prettyprint

      import android.content.res.Configuration.UI_MODE_NIGHT_YES


      @Preview(
          showBackground = true,
          widthDp = 320,
          uiMode = UI_MODE_NIGHT_YES,
          name = "GreetingPreviewDark"
      )
      @Preview(showBackground = true, widthDp = 320)
      @Composable
      fun GreetingPreview() {
          BasicsCodelabTheme {
              Greetings()
          }
      }

   This adds a preview in dark mode.

   |2c94dc7775d80166.png|


Tweak your app's theme

   You can find everything related to the current theme in the files inside the
   ``ui/theme`` folder. For example, the default colors that we have been using so far are
   defined in ``Color.kt``.

   Let's start by defining new colors. Add these to ``Color.kt``:

   .. code:: prettyprint

      val Navy = Color(0xFF073042)
      val Blue = Color(0xFF4285F4)
      val LightBlue = Color(0xFFD7EFFE)
      val Chartreuse = Color(0xFFEFF7CF)

   Now assign them to the ``MaterialTheme``'s palette in ``Theme.kt``:

   .. code:: prettyprint

      private val LightColorScheme = lightColorScheme(
          surface = Blue,
          onSurface = Color.White,
          primary = LightBlue,
          onPrimary = Navy
      )

   If you go back to ``MainActivity.kt`` and refresh the preview, the preview colors don't
   actually change! That's because by default, your Preview will use `dynamic colors <https://m3.material.io/styles/color/dynamic-color/overview>`__. 
   You can see the logic for adding dynamic coloring in ``Theme.kt``, using the 
   ``dynamicColor`` boolean parameter.

   To see the non-adaptive version of your color scheme, run your app on a device with API
   level lower than 31 (corresponding to Android S, where adaptive colors were
   introduced). You'll see the new colors:

   |493d754584574e91.png|

   In ``Theme.kt``, define the palette for dark colors:

   .. code:: prettyprint

      private val DarkColorScheme = darkColorScheme(
          surface = Blue,
          onSurface = Navy,
          primary = Navy,
          onPrimary = Chartreuse
      )

   When we now run the app, we will see the dark colors in action:

   |84d2a903ffa6d8df.png|

   Final code for ``Theme.kt``

   .. code:: prettyprint

      import android.app.Activity
      import android.os.Build
      import androidx.compose.foundation.isSystemInDarkTheme
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.darkColorScheme
      import androidx.compose.material3.dynamicDarkColorScheme
      import androidx.compose.material3.dynamicLightColorScheme
      import androidx.compose.material3.lightColorScheme
      import androidx.compose.runtime.Composable
      import androidx.compose.runtime.SideEffect
      import androidx.compose.ui.graphics.Color
      import androidx.compose.ui.graphics.toArgb
      import androidx.compose.ui.platform.LocalContext
      import androidx.compose.ui.platform.LocalView
      import androidx.core.view.ViewCompat

      private val DarkColorScheme = darkColorScheme(
          surface = Blue,
          onSurface = Navy,
          primary = Navy,
          onPrimary = Chartreuse
      )

      private val LightColorScheme = lightColorScheme(
          surface = Blue,
          onSurface = Color.White,
          primary = LightBlue,
          onPrimary = Navy
      )

      @Composable
      fun BasicsCodelabTheme(
          darkTheme: Boolean = isSystemInDarkTheme(),
          // Dynamic color is available on Android 12+
          dynamicColor: Boolean = true,
          content: @Composable () -> Unit
      ) {
          val colorScheme = when {
              dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
                  val context = LocalContext.current
                  if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
              }
              darkTheme -> DarkColorScheme
              else -> LightColorScheme
          }
          val view = LocalView.current
          if (!view.isInEditMode) {
              SideEffect {
                  (view.context as Activity).window.statusBarColor = colorScheme.primary.toArgb()
                  ViewCompat.getWindowInsetsController(view)?.isAppearanceLightStatusBars = darkTheme
              }
          }

          MaterialTheme(
              colorScheme = colorScheme,
              typography = Typography,
              content = content
          )
      }


13. Finishing touches!
----------------------


   In this step, you'll apply what you already know and learn new concepts with only a few
   hints. You will create this:

   |8d24a786bfe1a8f2.gif|


Replace button with an icon

   -  Use the ``IconButton`` composable together with a child ``Icon``.
   -  Use ``Icons.Filled.ExpandLess`` and ``Icons.Filled.ExpandMore``, which are available
      in the ``material-icons-extended`` artifact. Add the following line to dependencies
      in your ``app/build.gradle.kts`` file.

   .. code:: prettyprint

      implementation("androidx.compose.material:material-icons-extended")

   -  Modify paddings to fix alignment.
   -  Add a content description for accessibility (see "Use string resources" below).


Use string resources

   Content description for "Show more" and "show less" should be present and you can add
   them with a simple ``if`` statement:

   .. code:: prettyprint

      contentDescription = if (expanded) "Show less" else "Show more"

   However, hard-coding strings is a bad practice and you should get them from the
   ``strings.xml`` file.

   You can use "Extract string resource" on each string, available in "Context Actions" in
   Android Studio to do this automatically.

   Alternatively, open ``app/src/res/values/strings.xml`` and add the following resources:

   .. code:: prettyprint

      <string name="show_less">Show less</string>
      <string name="show_more">Show more</string>


Showing more

   The "Composem ipsum" text appears and disappears, triggering a change in size of each
   card.

   -  Add a new ``Text`` to the Column inside ``Greeting`` that is displayed when the item
      is expanded.
   -  Remove the ``extraPadding`` and instead apply the ``animateContentSize`` modifier to
      the ``Row``. This is going to automate the process of creating the animation, which
      would be hard to do manually. Also, it removes the need to ``coerceAtLeast``.


Add elevation and shapes

   -  You could use the ``shadow`` modifier together with ``clip`` modifier to achieve the
      card look. However, there's a Material composable that does exactly that:
      `Card <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#card>`__.
      You can change the ``Card``'s colors by calling ``CardDefaults.cardColors`` and
      overriding the color you want to change.


Final code

   .. code:: prettyprint

      package com.example.basicscodelab

      import android.content.res.Configuration.UI_MODE_NIGHT_YES
      import android.os.Bundle
      import androidx.activity.ComponentActivity
      import androidx.activity.compose.setContent
      import androidx.compose.animation.animateContentSize
      import androidx.compose.animation.core.Spring
      import androidx.compose.animation.core.spring
      import androidx.compose.foundation.layout.Arrangement
      import androidx.compose.foundation.layout.Column
      import androidx.compose.foundation.layout.Row
      import androidx.compose.foundation.layout.fillMaxSize
      import androidx.compose.foundation.layout.padding
      import androidx.compose.foundation.lazy.LazyColumn
      import androidx.compose.foundation.lazy.items
      import androidx.compose.material.icons.Icons.Filled
      import androidx.compose.material.icons.filled.ExpandLess
      import androidx.compose.material.icons.filled.ExpandMore
      import androidx.compose.material3.Button
      import androidx.compose.material3.Card
      import androidx.compose.material3.CardDefaults
      import androidx.compose.material3.Icon
      import androidx.compose.material3.IconButton
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Surface
      import androidx.compose.material3.Text
      import androidx.compose.runtime.Composable
      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.mutableStateOf
      import androidx.compose.runtime.saveable.rememberSaveable
      import androidx.compose.runtime.setValue
      import androidx.compose.ui.Alignment
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.res.stringResource
      import androidx.compose.ui.text.font.FontWeight
      import androidx.compose.ui.tooling.preview.Preview
      import androidx.compose.ui.unit.dp
      import com.example.basicscodelab.ui.theme.BasicsCodelabTheme


      class MainActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContent {
                  BasicsCodelabTheme {
                      MyApp(modifier = Modifier.fillMaxSize())
                  }
              }
          }
      }

      @Composable
      fun MyApp(modifier: Modifier = Modifier) {
          var shouldShowOnboarding by rememberSaveable { mutableStateOf(true) }

          Surface(modifier, color = MaterialTheme.colorScheme.background) {
              if (shouldShowOnboarding) {
                  OnboardingScreen(onContinueClicked = { shouldShowOnboarding = false })
              } else {
                  Greetings()
              }
          }
      }

      @Composable
      fun OnboardingScreen(
          onContinueClicked: () -> Unit,
          modifier: Modifier = Modifier
      ) {
          Column(
              modifier = modifier.fillMaxSize(),
              verticalArrangement = Arrangement.Center,
              horizontalAlignment = Alignment.CenterHorizontally
          ) {
              Text("Welcome to the Basics Codelab!")
              Button(
                  modifier = Modifier.padding(vertical = 24.dp),
                  onClick = onContinueClicked
              ) {
                  Text("Continue")
              }
          }
      }

      @Composable
      private fun Greetings(
          modifier: Modifier = Modifier,
          names: List<String> = List(1000) { "$it" }
      ) {
          LazyColumn(modifier = modifier.padding(vertical = 4.dp)) {
              items(items = names) { name ->
                  Greeting(name = name)
              }
          }
      }

      @Composable
      private fun Greeting(name: String, modifier: Modifier = Modifier) {
          Card(
              colors = CardDefaults.cardColors(
                  containerColor = MaterialTheme.colorScheme.primary
              ),
              modifier = modifier.padding(vertical = 4.dp, horizontal = 8.dp)
          ) {
              CardContent(name)
          }
      }

      @Composable
      private fun CardContent(name: String) {
          var expanded by rememberSaveable { mutableStateOf(false) }

          Row(
              modifier = Modifier
                  .padding(12.dp)
                  .animateContentSize(
                      animationSpec = spring(
                          dampingRatio = Spring.DampingRatioMediumBouncy,
                          stiffness = Spring.StiffnessLow
                      )
                  )
          ) {
              Column(
                  modifier = Modifier
                      .weight(1f)
                      .padding(12.dp)
              ) {
                  Text(text = "Hello, ")
                  Text(
                      text = name, style = MaterialTheme.typography.headlineMedium.copy(
                          fontWeight = FontWeight.ExtraBold
                      )
                  )
                  if (expanded) {
                      Text(
                          text = ("Composem ipsum color sit lazy, " +
                              "padding theme elit, sed do bouncy. ").repeat(4),
                      )
                  }
              }
              IconButton(onClick = { expanded = !expanded }) {
                  Icon(
                      imageVector = if (expanded) Filled.ExpandLess else Filled.ExpandMore,
                      contentDescription = if (expanded) {
                          stringResource(R.string.show_less)
                      } else {
                          stringResource(R.string.show_more)
                      }
                  )
              }
          }
      }

      @Preview(
          showBackground = true,
          widthDp = 320,
          uiMode = UI_MODE_NIGHT_YES,
          name = "GreetingPreviewDark"
      )
      @Preview(showBackground = true, widthDp = 320)
      @Composable
      fun GreetingPreview() {
          BasicsCodelabTheme {
              Greetings()
          }
      }

      @Preview(showBackground = true, widthDp = 320, heightDp = 320)
      @Composable
      fun OnboardingPreview() {
          BasicsCodelabTheme {
              OnboardingScreen(onContinueClicked = {})
          }
      }

      @Preview
      @Composable
      fun MyAppPreview() {
          BasicsCodelabTheme {
              MyApp(Modifier.fillMaxSize())
          }
      }


14. Congratulations
-------------------


   Congratulations! You learned the basics of Compose!


Solution to the codelab

   You can get the code for the solution of this codelab from GitHub:

   ::

      $ git clone https://github.com/android/codelab-android-compose

   Alternatively you can download the repository as a Zip file:

   `Download Zip <https://github.com/android/codelab-android-compose/archive/main.zip>`__


What's next?

   Check out the other codelabs on the `Compose pathway <https://developer.android.google.cn/courses/pathways/compose>`__:

   -  `Compose Layouts <https://codelabs.developers.google.cn/codelabs/jetpack-compose-layouts/#0>`__
   -  `State in Compose <https://codelabs.developers.google.cn/codelabs/jetpack-compose-state>`__
   -  `Compose Theming <https://codelabs.developers.google.cn/codelabs/jetpack-compose-theming>`__
   -  `Compose for Existing Apps <https://codelabs.developers.google.cn/codelabs/jetpack-compose-migration>`__


Further reading

   -  `Jetpack Compose basics code-along <https://www.youtube.com/watch?v=k3jvNqj4m08>`__
   -  `Compose mental model guide <https://developer.android.google.cn/jetpack/compose/mental-model>`__
   -  `Sample apps <https://github.com/android/compose-samples/>`__ to see Compose in
      action!


.. |8d24a786bfe1a8f2.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/8d24a786bfe1a8f2.gif
.. |d12472c6323de500.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/d12472c6323de500.png
.. |fb011e374b98ccff.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/fb011e374b98ccff.png
.. |eeacd000622ba9b.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/eeacd000622ba9b.png
.. |7093def1e32785b2.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/7093def1e32785b2.png
.. |9632f3ca76cbe115.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/9632f3ca76cbe115.png
.. |c88121ec49bde8c7.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/c88121ec49bde8c7.png
.. |ef14f7c54ae7edf.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/ef14f7c54ae7edf.png
.. |518dbfad23ee1b05.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/518dbfad23ee1b05.png
.. |bf27ee688c3231df.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/bf27ee688c3231df.png
.. |a7ba2a8cb7a7d79d.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/a7ba2a8cb7a7d79d.png
.. |a5d5f6cdbdd918a2.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/a5d5f6cdbdd918a2.png
.. |a9599061cf49a214.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/a9599061cf49a214.png
.. |ff2d8c3c1349a891.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/ff2d8c3c1349a891.png
.. |6675d41779cac69.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/6675d41779cac69.gif
.. |374998ad358bf8d6.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/374998ad358bf8d6.png
.. |93d839b53b7d9bea.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/93d839b53b7d9bea.gif
.. |5d5f44508fcfa779.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/5d5f44508fcfa779.png
.. |25915eb273a7ef49.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/25915eb273a7ef49.gif
.. |284f925eb984fb56.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/284f925eb984fb56.gif
.. |9efa14ce118d3835.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/9efa14ce118d3835.gif
.. |d5dbf92de69db775.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/d5dbf92de69db775.gif
.. |673955c38b076f1c.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/673955c38b076f1c.png
.. |b33493882bda9419.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/b33493882bda9419.png
.. |2c94dc7775d80166.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/2c94dc7775d80166.png
.. |493d754584574e91.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/493d754584574e91.png
.. |84d2a903ffa6d8df.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-basics/img/84d2a903ffa6d8df.png


ğŸš€ Basic layouts in Compose
============================

https://developer.android.google.cn/codelabs/jetpack-compose-layouts?hl=en


1. Introduction
---------------


   Being a UI toolkit, Compose makes it easy to implement your app's designs. You describe
   how you want your UI to look, and Compose takes care of drawing it on screen. This
   codelab teaches you how to write Compose UIs. It assumes you understand the concepts
   taught in the `basics codelab <https://developer.android.google.cn/codelabs/jetpack-compose-basics>`__, 
   so make sure that you complete that codelab first. In the Basics codelab, you learned how
   to implement simple layouts using ``Surfaces``, ``Rows`` and ``Columns``. You also
   augmented these layouts with modifiers like ``padding``, ``fillMaxWidth``, and ``size``.

   In this codelab you implement a more **realistic and complex layout**, learning about
   various **out of the box composables** and **modifiers** along the way. After finishing
   this codelab, you should be able to transform a basic app's design into working code.

   This codelab does not add any actual behavior to the app. To learn about state and
   interaction instead, complete the `State in Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-state>`__
   instead.

   For more support as you're walking through this codelab, check out the following
   code-along:


What you'll learn


   In this codelab, you will learn:

   -  How modifiers help you augment your composables.
   -  How standard layout components like Column and LazyRow position child composables.
   -  How alignments and arrangements change the position of child composables in their
      parent.
   -  How Material composables like Scaffold and Bottom Navigation help you create
      comprehensive layouts.
   -  How to build flexible composables using slot APIs.
   -  How to build layouts for different screen configurations.


What you'll need

   -  `Latest Android Studio <https://developer.android.google.cn/studio>`__.
   -  Experience with Kotlin syntax, including lambdas.
   -  Basic experience with Compose. If you haven't already, complete the 
      `Jetpack Compose basics codelab <https://codelabs.developers.google.cn/codelabs/jetpack-compose-basics/>`__
      before starting this codelab.
   -  Basic knowledge of what a composable is, and what modifiers are.


What you'll build

   In this codelab, you implement a realistic app design based on mocks provided by a
   designer. **MySoothe** is a well-being app that lists various ways to improve your body
   and mind. It contains a section that lists your favorite collections, and a section
   with physical exercises. This is what the app looks like:

   |Portrait version of app|

   |Landscape version of app|


2. Getting set up
-----------------


   In this step, you download code that contains theming and some basic setup.


Get the code

   The code for this codelab can be found in the `GitHub repository <http://github.com/android/codelab-android-compose>`__. 
   To clone it, run:

   ::

      $ git clone https://github.com/android/codelab-android-compose

   Alternatively, you can download two zip files:

   -  `Starting point <https://github.com/android/codelab-android-compose/archive/refs/heads/main.zip>`__
   -  `Solution <https://github.com/android/codelab-android-compose/archive/refs/heads/end.zip>`__


Check out the code

   The downloaded code contains code for all available Compose codelabs. To complete this
   codelab, open the **``BasicLayoutsCodelab``** project inside Android Studio.

   The compose-codelabs repo contains starter code for all codelabs in the pathway.

   For this codelab, use the **BasicLayoutsCodelab** project.

   -  **BasicLayoutsCodelab** â€” Project that contains the starter and finished code for
      this codelab.

   The project is built in multiple git branches:

   -  **main** â€“ Contains the starter code for this project. Make your changes here to
      complete the codelab.
   -  **end** â€“ Contains the solution to this codelab.

   We recommend that you start with the code in the ``main`` branch and follow the codelab
   step by step at your own pace.


3. Start with a plan
--------------------


   We will start by implementing the portrait design of the app - let's take a closer
   look:

   |portrait design|

   When you're asked to implement a design, a good way to start is by getting a clear
   understanding of its structure. Don't start coding straight away, but instead **analyze
   the design itself**. How can you **split this UI into multiple reusable parts**?

   So let's give this a go with our design. At the highest abstraction level, we can break
   this design down into two pieces:

   -  The screen's content.
   -  The bottom navigation.

   |app design breakdown|

   Drilling down, the screen content contains three sub-parts:

   -  The Search bar.
   -  A section called "Align your body".
   -  A section called "Favorite collections".

   |layouts55.png|

   Inside each section, you can also see some lower level components that are re-used:

   -  The "align your body" element that's shown in a horizontally scrollable row.

   |align your body element|

   -  The "favorite collection" card that's shown in a horizontally scrollable grid.

   |favorite collection card|

   Now that you've analyzed the design, you can start implementing composables for every
   identified piece of the UI. Start with the lowest level composables and continue to
   combine these into more complex ones. By the end of the codelab, your new app will look
   like the provided design.


4. Search bar - Modifiers
-------------------------


   The first element to transform into a composable is the Search bar. Let's take another
   look at the design:

   |search bar|

   Based on this screenshot alone, it would be quite difficult to implement this design in
   a pixel-perfect way. Generally, a designer conveys more information about the design.
   They can give you access to their design tool, or share so-called redlining designs. In
   this case, our designer handed off the redlining designs, which you can use to read off
   any sizing values. The design is shown with an 8dp grid overlay, so you can easily see
   how much space is between and around elements. Additionally, some spacings are added
   explicitly to clarify certain sizes.

   |search bar redline|

   You can see that the search bar should have a height of 56 density-independent pixels.
   It should also fill the full width of its parent.

   To implement the search bar, use a Material component called `Text field <https://m3.material.io/components/text-fields/overview>`__. 
   The Compose Material library contains a composable called `TextField <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#TextField(androidx.compose.ui.text.input.TextFieldValue,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material3.TextFieldColors)>`__,
   which is the implementation of this Material component.

   Start with a basic ``TextField`` implementation. In your code base, open
   ``MainActivity.kt`` and search for the ``SearchBar`` composable.

   Inside the composable called ``SearchBar``, write the basic ``TextField``
   implementation:

   .. code:: prettyprint

      import androidx.compose.material3.TextField

      @Composable
      fun SearchBar(
         modifier: Modifier = Modifier
      ) {
         TextField(
             value = "",
             onValueChange = {},
             modifier = modifier
         )
      }

   Some points to notice:

   -  You hardcoded the text field's value, and the ``onValueChange`` callback doesn't do
      anything. Since this is a layout-focused codelab, you ignore anything that has to do
      with state.

   If you'd like to learn more about state in composables, check out the 
   `State in Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-state>`__.

   -  The ``SearchBar`` composable function accepts a ``modifier`` parameter and passes
      this on to the ``TextField``. This is a best practice as per `Compose guidelines <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/compose/docs/compose-api-guidelines.md#elements-accept-and-respect-a-modifier-parameter>`__.
      This allows the method's caller to modify the composable's look & feel, which makes
      it more flexible and reusable. You'll continue this best practice for all
      composables in this codelab.

   Let's look at the preview of this composable. Remember that you can use the 
   `Preview functionality <https://developer.android.google.cn/jetpack/compose/tooling#preview>`__
   in Android Studio to quickly iterate on your individual composables.
   ``MainActivity.kt`` contains previews for all the composables you'll build in this
   codelab. In this case, the method ``SearchBarPreview`` renders our ``SearchBar``
   composable, with some background and padding to give it a bit more context. With the
   implementation you just added, it should look like this:

   |search bar preview|

   There are some things missing. First, let's fix the size of the composable using
   `modifiers <https://developer.android.google.cn/jetpack/compose/modifiers>`__.

   When writing composables, you use **modifiers** to:

   -  Change the composable's size, layout, behavior, and appearance.
   -  Add information, like accessibility labels.
   -  Process user input.
   -  Add high-level interactions, like making an element clickable, scrollable,
      draggable, or zoomable.

   Each composable that you call has a ``modifier`` parameter that you can set to adapt
   that composable's look, feel and behavior. When you set the modifier, you can chain
   multiple modifier methods to create a more complex adaptation.

   If you want to learn more about the behavior of modifiers, check out the 
   `modifiers documentation <https://developer.android.google.cn/jetpack/compose/modifiers>`__. 
   You can also look at the `full list of available modifiers <https://developer.android.google.cn/jetpack/compose/modifiers-list>`__.

   In this case, the search bar should be at least 56dp high, and fill its parent's width.
   To find the right modifiers for this, you can go through the `list of modifiers <https://developer.android.google.cn/jetpack/compose/modifiers-list>`__ 
   and look at the `Size section <https://developer.android.google.cn/jetpack/compose/modifiers-list#Size>`__.
   For the height, you can use the `heightIn <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier).heightIn(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)>`__
   modifier. This makes sure that the composable has a specific minimum height. It can,
   however, become larger when, for example, the user enlarges their system font size. For
   the width you can use the `fillMaxWidth <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier).fillMaxWidth(kotlin.Float)>`__
   modifier. This modifier makes sure that the search bar uses up all the horizontal space
   of its parent.

   Update the modifier to match the code below:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.fillMaxWidth
      import androidx.compose.foundation.layout.heightIn
      import androidx.compose.material3.TextField

      @Composable
      fun SearchBar(
         modifier: Modifier = Modifier
      ) {
         TextField(
             value = "",
             onValueChange = {},
             modifier = modifier
                 .fillMaxWidth()
                 .heightIn(min = 56.dp)
         )
      }

   In this case, because one modifier influences the width, and the other the height, the
   order of these modifiers doesn't matter.

   You also have to set some parameters of the ``TextField``. Try to make the composable
   look like the design by setting the parameter values. Here's the design again as a
   reference:

   |search bar|

   These are the steps that you should take to update your implementation:

   -  Add the search icon. ``TextField`` contains a parameter ``leadingIcon`` that accepts
      another composable. Inside, you can set an ``Icon``, which in our case should be the
      ``Search`` icon. Make sure to use the right Compose ``Icon`` import.
   -  You can use the ``TextFieldDefaults.textFieldColors`` to override specific colors.
      Set the ``focusedContainerColor`` and the ``unfocusedContainerColor`` of the text
      field to MaterialTheme's ``surface`` color.
   -  Add a placeholder text "Search" (you can find this as string resource
      ``R.string.placeholder_search``).

   When you're done, your composable should look similar to this:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.fillMaxWidth
      import androidx.compose.foundation.layout.heightIn
      import androidx.compose.ui.res.stringResource
      import androidx.compose.material3.Icon
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Text
      import androidx.compose.material3.TextField
      import androidx.compose.material3.TextFieldDefaults
      import androidx.compose.material.icons.Icons
      import androidx.compose.material.icons.filled.Search


      @Composable
      fun SearchBar(
         modifier: Modifier = Modifier
      ) {
         TextField(
             value = "",
             onValueChange = {},
             leadingIcon = {
                 Icon(
                     imageVector = Icons.Default.Search,
                     contentDescription = null
                 )
             },
             colors = TextFieldDefaults.colors(
                 unfocusedContainerColor = MaterialTheme.colorScheme.surface,
                 focusedContainerColor = MaterialTheme.colorScheme.surface
             ),
             placeholder = {
                 Text(stringResource(R.string.placeholder_search))
             },
             modifier = modifier
                 .fillMaxWidth()
                 .heightIn(min = 56.dp)
         )
      }

   |search bar|

   Notice that:

   -  You added a ``leadingIcon`` showing the search icon. This icon does not need a
      content description, as the text field's placeholder already describes the meaning
      of the text field. Remember that a content description is normally used for
      accessibility purposes and gives the user of your app a textual representation of an
      image or icon.

   To learn more about accessibility, check out the `Accessibility codelab <https://developer.android.google.cn/codelabs/jetpack-compose-accessibility>`__
   or read the `Accessibility documentation <https://developer.android.google.cn/jetpack/compose/accessibility>`__.

   -  To adapt the background color of the text field, you set the ``colors`` property.
      Instead of a separate parameter for each color, the composable contains one combined
      parameter. Here you pass in a copy of the ``TextFieldDefaults`` data class, where
      you update only the colors that are different. In this case, that's only the
      ``unfocusedContainerColor`` and ``focusedContainerColor`` color.

   In this step you saw how you can use composable parameters and modifiers to change a
   composable's look and feel. This applies to both composables provided by the Compose
   and Material libraries, and to the ones you write yourself. You should always think
   about providing parameters to customize the composable you're writing. You should also
   add a ``modifier`` property so the composable's look and feel can be adapted from the
   outside.


5. Align your body - Alignment
------------------------------


   The next composable you'll implement is the "Align your body" element. Let's take a
   look at its design, including the redlines design next to it:

   |align your body component|

   |align your body redline|

   The redlines design now also contains baseline-oriented spacings. Here's the
   information we get from it:

   -  The image should be 88dp high.
   -  The spacing between the baseline of the text and the image should be 24dp.
   -  The spacing between the baseline and the bottom of the element should be 8dp.
   -  The text should have a typography style of bodyMedium.

   The **baseline** of a text is the line on which the letters "sit". It's considered a
   best practice among designers to align text elements based on their baseline, instead
   of their top or bottom.

   To implement this composable, you need an `Image <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/package-summary#Image(androidx.compose.ui.graphics.painter.Painter,kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,androidx.compose.ui.layout.ContentScale,kotlin.Float,androidx.compose.ui.graphics.ColorFilter)>`__
   and a `Text <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Text(kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.font.FontStyle,androidx.compose.ui.text.font.FontWeight,androidx.compose.ui.text.font.FontFamily,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextDecoration,androidx.compose.ui.text.style.TextAlign,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextOverflow,kotlin.Boolean,kotlin.Int,kotlin.Int,kotlin.Function1,androidx.compose.ui.text.TextStyle)>`__
   composable. They need to be included in a `Column <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Column(androidx.compose.ui.Modifier,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,kotlin.Function1)>`__,
   so they are positioned underneath each other.

   Find the ``AlignYourBodyElement`` composable in your code and update its content with
   this basic implementation:

   .. code:: prettyprint

      import androidx.compose.foundation.Image
      import androidx.compose.foundation.layout.Column
      import androidx.compose.ui.res.painterResource

      @Composable
      fun AlignYourBodyElement(
         modifier: Modifier = Modifier
      ) {
         Column(
             modifier = modifier
         ) {
             Image(
                 painter = painterResource(R.drawable.ab1_inversions),
                 contentDescription = null
             )
             Text(text = stringResource(R.string.ab1_inversions))
         }
      }

   Notice that:

   -  You set the ``contentDescription`` of the image to null, as this image is purely
      decorative. The text below the image describes enough of the meaning, so the image
      does not need an extra description.
   -  You are using a hard-coded image and text. In the next step, you'll move these to
      use parameters provided in the ``AlignYourBodyElement`` composable to make them
      dynamic.

   Take a look at the preview of this composable:

   |align your body preview|

   There are some improvements to be made. Most noticeably, the image is too large and not
   shaped as a circle. You can adapt the ``Image`` composable with the `size <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier).size(androidx.compose.ui.unit.Dp)>`__
   and `clip <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier).clip(androidx.compose.ui.graphics.Shape)>`__
   modifiers and the ``contentScale`` parameter.

   The ``size`` modifier adapts the composable to fit a certain size, similar to the
   ``fillMaxWidth`` and ``heightIn`` modifiers that you saw in the previous step. The
   ``clip`` modifier works differently and **adapts the composable's appearance**. You can
   set it to any `Shape <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/graphics/Shape>`__
   and it clips the composable's content to that shape.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.size
      import androidx.compose.foundation.shape.CircleShape
      import androidx.compose.ui.draw.clip
      @Composable
      fun AlignYourBodyElement(
         modifier: Modifier = Modifier
      ) {
         Column(
             modifier = modifier
         ) {
             Image(
                 painter = painterResource(R.drawable.ab1_inversions),
                 contentDescription = null,
                 modifier = Modifier
                     .size(88.dp)
                     .clip(CircleShape)
             )
             Text(text = stringResource(R.string.ab1_inversions))
         }
      }

   Currently your design in the Preview looks like this:

   |layouts16.png|

   The image also needs to be scaled correctly. To do so, we can use the ``Image``'s
   ``contentScale`` parameter. There are several options, most notably:

   |align your body content preview|

   In this case, the crop type is the correct one to use. After applying the modifiers and
   the parameter, your code should look like this:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.size
      import androidx.compose.foundation.shape.CircleShape
      import androidx.compose.ui.draw.clip
      import androidx.compose.ui.layout.ContentScale
      @Composable
      fun AlignYourBodyElement(
         modifier: Modifier = Modifier
      ) {
         Column(
             modifier = modifier
         ) {
             Image(
                 painter = painterResource(R.drawable.ab1_inversions),
                 contentDescription = null,
                 contentScale = ContentScale.Crop,
                 modifier = Modifier
                     .size(88.dp)
                     .clip(CircleShape)
             )
             Text( text = stringResource(R.string.ab1_inversions) )
         }
      }

   Your design should now look like this:

   |layouts18.png|

   As a next step, align the text horizontally by setting the alignment of the ``Column``.

   In general, to align composables inside a parent container, you set the **alignment**
   of that parent container. So instead of telling the child to position itself in its
   parent, you tell the parent how to align its children.

   For a ``Column``, you decide how its children should be aligned horizontally. The
   options are:

   -  Start
   -  CenterHorizontally
   -  End

   For a ``Row``, you set the vertical alignment. The options are similar to those of the
   ``Column``:

   -  Top
   -  CenterVertically
   -  Bottom

   For a ``Box``, you combine both horizontal and vertical alignment. The options are:

   -  TopStart
   -  TopCenter
   -  TopEnd
   -  CenterStart
   -  Center
   -  CenterEnd
   -  BottomStart
   -  BottomCenter
   -  BottomEnd

   All of the container's children will follow this same alignment pattern. You can
   override the behavior of a single child by adding an `align <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/ColumnScope#(androidx.compose.ui.Modifier).align(androidx.compose.ui.Alignment.Horizontal)>`__
   modifier to it.

   For this design, the text should be centered horizontally. To do that, set the
   ``Column``'s ``horizontalAlignment`` to center horizontally:

   .. code:: prettyprint

      import androidx.compose.ui.Alignment
      @Composable
      fun AlignYourBodyElement(
         modifier: Modifier = Modifier
      ) {
         Column(
             horizontalAlignment = Alignment.CenterHorizontally,
             modifier = modifier
         ) {
             Image(
                 //..
             )
             Text(
                 //..
             )
         }
      }

   With these parts implemented, there are only some minor changes that you need to make
   the composable identical to the design. Try to implement these by yourself or reference
   the final code if you get stuck. Think of the following steps:

   -  Make the image and text dynamic. Pass them as arguments to the composable function.
      Don't forget to update the corresponding Preview and pass in some hard-coded data.
   -  Update the text to use the bodyMedium typography style.
   -  Update the baseline spacings of the text element per the diagram.

   |align your body redline|

   When you're done implementing these steps, your code should look similar to this:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.paddingFromBaseline
      import androidx.compose.ui.Alignment
      import androidx.compose.ui.layout.ContentScale

      @Composable
      fun AlignYourBodyElement(
         @DrawableRes drawable: Int,
         @StringRes text: Int,
         modifier: Modifier = Modifier
      ) {
         Column(
             modifier = modifier,
             horizontalAlignment = Alignment.CenterHorizontally
         ) {
             Image(
                 painter = painterResource(drawable),
                 contentDescription = null,
                 contentScale = ContentScale.Crop,
                 modifier = Modifier
                     .size(88.dp)
                     .clip(CircleShape)
             )
             Text(
                 text = stringResource(text),
                 modifier = Modifier.paddingFromBaseline(top = 24.dp, bottom = 8.dp),
                 style = MaterialTheme.typography.bodyMedium
             )
         }
      }


      @Preview(showBackground = true, backgroundColor = 0xFFF5F0EE)
      @Composable
      fun AlignYourBodyElementPreview() {
         MySootheTheme {
             AlignYourBodyElement(
                 text = R.string.ab1_inversions,
                 drawable = R.drawable.ab1_inversions,
                 modifier = Modifier.padding(8.dp)
             )
         }
      }

   There are often various ways to get to the same result, so your implementation might be
   slightly different from this proposed solution. For example, you can often use a
   `Spacer <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Spacer(androidx.compose.ui.Modifier)>`__
   or set a padding, and both will have the same visual result. The most important part is
   that your implementation follows the design and Compose guidelines.

   Check out the AlignYourBodyElement in the Design tab.

   |layouts20.png|


6. Favorite collection card - Material Surface
----------------------------------------------


   The next composable to implement is in a way similar to the "Align the body" element.
   Here's the design, including the redlines:

   |layouts21.png|

   |favorite collection card redline|

   In this case, the full size of the composable is provided. You can see that the text
   should be titleMedium.

   This container uses surfaceVariant as its background color which is different from the
   background of the whole screen. It also has rounded corners. We specify these for the
   favorite collection card using Material's `Surface <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Surface(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.foundation.BorderStroke,kotlin.Function0)>`__
   composable.

   **Surface** is a component in the Compose Material library. It follows general Material
   Design patterns and you can adapt it by changing your app's theme. You can learn more
   about theming in the `Theming in Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-theming>`__ or in
   the `Theming documentation <https://developer.android.google.cn/jetpack/compose/themes>`__.

   You can adapt the ``Surface`` to your needs by setting its parameters and modifier. In
   this case, the surface should have rounded corners. You can use the ``shape`` parameter
   for this. Instead of setting the shape to a ``Shape`` as for the Image in the previous
   step, you'll use a value coming from our Material theme.

   Let's see what this would look like:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Row
      import androidx.compose.material3.Surface

      @Composable
      fun FavoriteCollectionCard(
         modifier: Modifier = Modifier
      ) {
         Surface(
             shape = MaterialTheme.shapes.medium,
             modifier = modifier
         ) {
             Row {
                 Image(
                     painter = painterResource(R.drawable.fc2_nature_meditations),
                     contentDescription = null
                 )
                 Text(text = stringResource(R.string.fc2_nature_meditations))
             }
         }
      }

   And let's see the Preview of this implementation:

   |favorite collection preview|

   Next, apply the lessons learned in the previous step.

   -  Set the width of the ``Row``, and align its children vertically.
   -  Set the size of the image per the diagram and crop it in its container.

   |favorite collection redline|

   Try to implement these changes yourself before looking at the solution code!

   Your code would now look something like this:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.width

      @Composable
      fun FavoriteCollectionCard(
         modifier: Modifier = Modifier
      ) {
         Surface(
             shape = MaterialTheme.shapes.medium,
             modifier = modifier
         ) {
             Row(
                 verticalAlignment = Alignment.CenterVertically,
                 modifier = Modifier.width(255.dp)
             ) {
                 Image(
                     painter = painterResource(R.drawable.fc2_nature_meditations),
                     contentDescription = null,
                     contentScale = ContentScale.Crop,
                     modifier = Modifier.size(80.dp)
                 )
                 Text(
                     text = stringResource(R.string.fc2_nature_meditations)
                 )
             }
         }
      }

   The preview should now look like this:

   |layouts25.png|

   To finish up this composable, implement the following steps:

   -  Make the image and text dynamic. Pass them in as arguments to the composable
      function.
   -  Update the color to surfaceVariant.
   -  Update the text to use the titleMedium typography style.
   -  Update the spacing between the image and the text.

   Your end result should look similar to this:

   .. code:: prettyprint

      @Composable
      fun FavoriteCollectionCard(
         @DrawableRes drawable: Int,
         @StringRes text: Int,
         modifier: Modifier = Modifier
      ) {
         Surface(
             shape = MaterialTheme.shapes.medium,
             color = MaterialTheme.colorScheme.surfaceVariant,
             modifier = modifier
         ) {
             Row(
                 verticalAlignment = Alignment.CenterVertically,
                 modifier = Modifier.width(255.dp)
             ) {
                 Image(
                     painter = painterResource(drawable),
                     contentDescription = null,
                     contentScale = ContentScale.Crop,
                     modifier = Modifier.size(80.dp)
                 )
                 Text(
                     text = stringResource(text),
                     style = MaterialTheme.typography.titleMedium,
                     modifier = Modifier.padding(horizontal = 16.dp)
                 )
             }
         }
      }


      //..


      @Preview(showBackground = true, backgroundColor = 0xFFF5F0EE)
      @Composable
      fun FavoriteCollectionCardPreview() {
         MySootheTheme {
             FavoriteCollectionCard(
                 text = R.string.fc2_nature_meditations,
                 drawable = R.drawable.fc2_nature_meditations,
                 modifier = Modifier.padding(8.dp)
             )
         }
      }

   Check out the Preview of the FavoriteCollectionCardPreview.

   |layouts26.png|


7. Align your body row - Arrangements
-------------------------------------


   Now that you've created the basic composables that are shown on the screen, you can
   start creating the different sections of the screen.

   Start with the "Align your body" scrollable row.

   |align your body scrollable|

   Here's the redline design for this component:

   |layouts28.png|

   Remember that one block of the grid represents 8dp. So in this design there's 16dp
   space before the first item, and after the last item in the row. There's 8dp of spacing
   between each item.

   In Compose, you can implement a scrollable row like this using the
   `LazyRow <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyRow(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__
   composable. The `documentation on lists <https://developer.android.google.cn/jetpack/compose/lists>`__ 
   contains much more information about Lazy lists like ``LazyRow`` and ``LazyColumn``. 
   For this codelab, it's enough to know that the ``LazyRow`` only renders the elements 
   that are shown on screen instead of all elements at the same time, which helps keep 
   your app performant.

   Start with a basic implementation of this ``LazyRow``:

   .. code:: prettyprint

      import androidx.compose.foundation.lazy.LazyRow
      import androidx.compose.foundation.lazy.items

      @Composable
      fun AlignYourBodyRow(
         modifier: Modifier = Modifier
      ) {
         LazyRow(
             modifier = modifier
         ) {
             items(alignYourBodyData) { item ->
                 AlignYourBodyElement(item.drawable, item.text)
             }
         }
      }

   As you can see, the children of a ``LazyRow`` aren't composables. Instead, you use the
   Lazy list DSL that provides methods like `item <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/LazyListScope#item(kotlin.Any,kotlin.Any,kotlin.Function1)>`__
   and `items <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/package-summary#(androidx.compose.foundation.lazy.LazyListScope).items(kotlin.collections.List,kotlin.Function1,kotlin.Function1,kotlin.Function2)>`__
   that emit composables as list items. For each item in the provided
   ``alignYourBodyData``, you emit a ``AlignYourBodyElement`` composable that you
   implemented earlier.

   Notice how this is displayed:

   |layouts29.png|

   The spacings that we saw in the redlines design are still missing. To implement these,
   you'll have to learn about **arrangements**.

   In the previous step you learned about alignments, which are used to align a
   container's children on the **cross-axis**. For a ``Column``, the cross-axis is the
   horizontal axis, while for a ``Row``, the cross-axis is the vertical axis.

   However, we can also make a decision on how to place child composables on a container's
   **main axis** (horizontal for ``Row``, vertical for ``Column``).

   For a ``Row``, you can choose the following arrangements:

   |row arrangements|

   And for a ``Column``:

   |col arrangements|

   In addition to these arrangements, you can also use the ``Arrangement.spacedBy()``
   method to add a fixed space in between each child composable.

   In the example, the ``spacedBy`` method is the one you need to use, as you want to
   place 8dp of spacing between each item in the ``LazyRow``.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Arrangement

      @Composable
      fun AlignYourBodyRow(
         modifier: Modifier = Modifier
      ) {
         LazyRow(
             horizontalArrangement = Arrangement.spacedBy(8.dp),
             modifier = modifier
         ) {
             items(alignYourBodyData) { item ->
                 AlignYourBodyElement(item.drawable, item.text)
             }
         }
      }

   Now the design looks like this:

   |layouts32.png|

   You need to add some padding on the sides of the ``LazyRow`` as well. Adding a simple
   padding modifier will not do the trick in this case. Try adding padding to the
   ``LazyRow`` and see how it behaves using the `interactive preview <https://developer.android.google.cn/jetpack/compose/tooling#preview-interactive>`__:

   |layouts33.gif|

   As you can see, when scrolling, the first and last visible item are cut off on both
   sides of the screen.

   To maintain the same padding, but still scroll your content within the bounds of your
   parent list without clipping it, all lists provide a parameter to the ``LazyRow``
   called ``contentPadding`` and set it to ``16.dp``.

   Make sure that your composable behaves correctly when you swipe through the list. You
   can use `interactive Preview <https://developer.android.google.cn/jetpack/compose/tooling#preview-interactive>`__
   to interact with your composable's Preview.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.PaddingValues

      @Composable
      fun AlignYourBodyRow(
         modifier: Modifier = Modifier
      ) {
         LazyRow(
             horizontalArrangement = Arrangement.spacedBy(8.dp),
             contentPadding = PaddingValues(horizontal = 16.dp),
             modifier = modifier
         ) {
             items(alignYourBodyData) { item ->
                 AlignYourBodyElement(item.drawable, item.text)
             }
         }
      }

   Try out the interactive preview to see the difference the padding makes.

   |align your body scrollable|


8. Favorite collections grid - Lazy grids
-----------------------------------------


   The next section to implement is the "Favorite collections" part of the screen. Instead
   of a single row, this composable needs a grid:

   |favorite collections scrolling|

   You could implement this section similarly to the previous section, by creating a
   ``LazyRow`` and let each item hold a ``Column`` with two ``FavoriteCollectionCard``
   instances. However, in this step you'll use the `LazyHorizontalGrid <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/grid/package-summary#LazyHorizontalGrid(androidx.compose.foundation.lazy.grid.GridCells,androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.grid.LazyGridState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__,
   which provides a nicer mapping from items to grid elements.

   Start with a simple implementation of the grid with two fixed rows:

   .. code:: prettyprint

      import androidx.compose.foundation.lazy.grid.GridCells
      import androidx.compose.foundation.lazy.grid.LazyHorizontalGrid
      import androidx.compose.foundation.lazy.grid.items

      @Composable
      fun FavoriteCollectionsGrid(
         modifier: Modifier = Modifier
      ) {
         LazyHorizontalGrid(
             rows = GridCells.Fixed(2),
             modifier = modifier
         ) {
             items(favoriteCollectionsData) { item ->
                 FavoriteCollectionCard(item.drawable, item.text)
             }
         }
      }

   As you can see, you simply replaced the ``LazyRow`` from the previous step with a
   ``LazyHorizontalGrid``. However, this won't give you the correct result just yet:

   |favorite collections preview|

   The grid takes up as much space as its parent, which means the favorite collection
   cards are stretched way too much vertically.

   Adapt the composable, so that

   -  The grid has horizontal contentPadding of 16.dp.
   -  The horizontal and vertical arrangement is spaced by 16.dp.
   -  The height of the grid is 168.dp.
   -  The modifier of the FavoriteCollectionCard specifies a height of 80.dp.

   The final code should look like this:

   .. code:: prettyprint

      @Composable
      fun FavoriteCollectionsGrid(
         modifier: Modifier = Modifier
      ) {
         LazyHorizontalGrid(
             rows = GridCells.Fixed(2),
             contentPadding = PaddingValues(horizontal = 16.dp),
             horizontalArrangement = Arrangement.spacedBy(16.dp),
             verticalArrangement = Arrangement.spacedBy(16.dp),
             modifier = modifier.height(168.dp)
         ) {
             items(favoriteCollectionsData) { item ->
                 FavoriteCollectionCard(item.drawable, item.text, Modifier.height(80.dp))
             }
         }
      }

   The Preview should look like this:

   |layouts36.png|


9. Home section - Slot APIs
---------------------------


   In the MySoothe home screen, there are multiple **sections** that follow the same
   pattern. They each have a title, with some content varying depending on the section.
   Here's the redline design we want to implement:

   |home section redline|

   As you can see, each section has a **title** and a **slot**. The title has some spacing
   and style information associated with it. The slot can be filled in dynamically with
   different content, depending on the section.

   To implement this flexible section container, you use so-called *slot APIs*. Before you
   implement this, read the section on the documentation page about `slot-based layouts <https://developer.android.google.cn/jetpack/compose/layouts/basics#slot-based-layouts>`__.
   This will help you understand what a slot-based layout is and how you can use slot APIs
   to build such a layout.

   **Slot-based layouts** leave an empty space in the UI for the developer to fill as they
   wish. You can use them to create more flexible layouts.

   Adapt the ``HomeSection`` composable to receive the title and slot content. You should
   also adapt the associated Preview to call this ``HomeSection`` with the "Align your
   body" title and content:

   .. code:: prettyprint

      @Composable
      fun HomeSection(
         @StringRes title: Int,
         modifier: Modifier = Modifier,
         content: @Composable () -> Unit
      ) {
         Column(modifier) {
             Text(stringResource(title))
             content()
         }
      }

      @Preview(showBackground = true, backgroundColor = 0xFFF5F0EE)
      @Composable
      fun HomeSectionPreview() {
         MySootheTheme {
             HomeSection(R.string.align_your_body) {
                 AlignYourBodyRow()
             }
         }
      }

   You can use the ``content`` parameter for the composable's slot. This way, when you use
   the ``HomeSection`` composable, you can use a trailing lambda to fill the content slot.
   When a composable provides multiple slots to fill in, you can give them meaningful
   names that represent their function in the bigger composable container. For example,
   Material's `TopAppBar <https://m3.material.io/components/top-app-bar/overview>`__
   provides the slots for ``title``, ``navigationIcon``, and ``actions``.

   Let's see how the section looks with this implementation:

   |home section preview|

   The Text composable needs some more information to make it align with the design.

   |home section redline|

   Update it so that:

   -  It uses the titleMedium typography.
   -  The spacing between the baseline of the text and the top is 40dp.
   -  The spacing between the baseline and the bottom of the element is 16dp.
   -  The horizontal padding is 16dp.

   Your final solution should look something like this:

   .. code:: prettyprint

      @Composable
      fun HomeSection(
         @StringRes title: Int,
         modifier: Modifier = Modifier,
         content: @Composable () -> Unit
      ) {
         Column(modifier) {
             Text(
                 text = stringResource(title),
                 style = MaterialTheme.typography.titleMedium,
                 modifier = Modifier
                     .paddingFromBaseline(top = 40.dp, bottom = 16.dp)
                     .padding(horizontal = 16.dp)
             )
             content()
         }
      }


10. Home screen - Scrolling
---------------------------


   Now that you have created all the separate building blocks, you can combine them into a
   full screen implementation.

   Here's the design you're trying to implement:

   |layouts59.png|

   We're simply placing the search bar and the two sections below one another. There's
   some spacing that you need to add to make everything fit the design. One composable
   that we haven't used before is the `Spacer <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#Spacer(androidx.compose.ui.Modifier)>`__,
   which helps us to put extra room inside our ``Column``. If you would instead set the
   ``Column``'s padding, you'd get the same cut-off behavior that we saw before in the
   Favorite Collections grid.

   .. code:: prettyprint

      @Composable
      fun HomeScreen(modifier: Modifier = Modifier) {
         Column(modifier) {
             Spacer(Modifier.height(16.dp))
             SearchBar(Modifier.padding(horizontal = 16.dp))
             HomeSection(title = R.string.align_your_body) {
                 AlignYourBodyRow()
             }
             HomeSection(title = R.string.favorite_collections) {
                 FavoriteCollectionsGrid()
             }
             Spacer(Modifier.height(16.dp))
         }
      }

   Although the design fits well on most device sizes, it needs to be scrollable
   vertically in case the device is not high enough - for example in landscape mode. This
   requires that you add scrolling behavior.

   As we saw earlier, Lazy layouts such as ``LazyRow`` and ``LazyHorizontalGrid``
   automatically add scrolling behavior. However, you don't always need a Lazy layout. In
   general, **you use a Lazy layout when you have many elements in a list or large data
   sets to load**, so emitting all items at once would come at a performance cost and
   would slow down your app. When a list has only a limited number of elements, you can
   instead choose to use a simple ``Column`` or ``Row`` and **add the scroll behavior
   manually**. To do so, you use the `verticalScroll <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier).verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)>`__
   or `horizontalScroll <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier).horizontalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean)>`__
   modifiers. These require a `ScrollState <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/ScrollState>`__,
   which contains the current state of the scroll, used to modify the scroll state from
   outside. In this case, you're not looking to modify the scroll state, so you simply
   create a persistent ``ScrollState`` instance using `rememberScrollState <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/package-summary#rememberScrollState(kotlin.Int)>`__.

   To learn more about ``remember`` and its role in Compose state, follow the `State in
   Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-state>`__

   Your final result should look like this:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Spacer
      import androidx.compose.foundation.rememberScrollState
      import androidx.compose.foundation.verticalScroll

      @Composable
      fun HomeScreen(modifier: Modifier = Modifier) {
         Column(
             modifier
                 .verticalScroll(rememberScrollState())
         ) {
             Spacer(Modifier.height(16.dp))
             SearchBar(Modifier.padding(horizontal = 16.dp))
             HomeSection(title = R.string.align_your_body) {
                 AlignYourBodyRow()
             }
             HomeSection(title = R.string.favorite_collections) {
                 FavoriteCollectionsGrid()
             }
             Spacer(Modifier.height(16.dp))
         }
      }

   To verify the composable's scrolling behavior, limit the Preview's height and run it in
   `interactive preview <https://developer.android.google.cn/jetpack/compose/tooling#preview-interactive>`__:

   .. code:: prettyprint

      @Preview(showBackground = true, backgroundColor = 0xFFF5F0EE, heightDp = 180)
      @Composable
      fun ScreenContentPreview() {
         MySootheTheme { HomeScreen() }
      }

   |screen content scroll|


11. Bottom navigation - Material
--------------------------------


   Now that you've implemented the content of the screen, you're ready to add the window
   decoration. In the case of MySoothe, there's a navigation bar that lets the user switch
   between different screens.

   First, implement the navigation bar composable, and then include it in your app.

   Let's take a look at the design:

   |bottom navigation design|

   Thankfully, you don't have to implement this entire composable from scratch by
   yourself. You can use the `NavigationBar <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#NavigationBar(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.WindowInsets,kotlin.Function1)>`__
   composable that's a part of the Compose Material library. Inside the ``NavigationBar``
   composable, you can add one or more ``NavigationBarItem`` elements, that will then get
   styled automatically by the Material library.

   If you're interested in **Material Design** and would like to learn more about how to
   implement a design system using Jetpack Compose, you can follow the 
   `Theming in Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-theming>`__
   or read the `Theming documentation <https://developer.android.google.cn/jetpack/compose/themes>`__.

   Start with a basic implementation of this bottom navigation:

   .. code:: prettyprint

      import androidx.compose.material3.NavigationBar
      import androidx.compose.material3.NavigationBarItem
      import androidx.compose.material.icons.filled.AccountCircle
      import androidx.compose.material.icons.filled.Spa

      @Composable
      private fun SootheBottomNavigation(modifier: Modifier = Modifier) {
         NavigationBar(
             modifier = modifier
         ) {
             NavigationBarItem(
                 icon = {
                     Icon(
                         imageVector = Icons.Default.Spa,
                         contentDescription = null
                     )
                 },
                 label = {
                     Text(
                         text = stringResource(R.string.bottom_navigation_home)
                     )
                 },
                 selected = true,
                 onClick = {}
             )
             NavigationBarItem(
                 icon = {
                     Icon(
                         imageVector = Icons.Default.AccountCircle,
                         contentDescription = null
                     )
                 },
                 label = {
                     Text(
                         text = stringResource(R.string.bottom_navigation_profile)
                     )
                 },
                 selected = false,
                 onClick = {}
             )
         }
      }

   This is what the basic implementation looks like - there isn't a lot of contrast
   between the content color and the navigation bar's color.

   |bottom navigation preview|

   There are some style adaptations you should make. First of all, you can update the
   background color of the bottom navigation by setting its ``containerColor`` parameter.
   You can use the surfaceVariant color from the Material theme for this. Your final
   solution should look something like this:

   .. code:: prettyprint

      @Composable
      private fun SootheBottomNavigation(modifier: Modifier = Modifier) {
         NavigationBar(
             containerColor = MaterialTheme.colorScheme.surfaceVariant,
             modifier = modifier
         ) {
             NavigationBarItem(
                 icon = {
                     Icon(
                         imageVector = Icons.Default.Spa,
                         contentDescription = null
                     )
                 },
                 label = {
                     Text(stringResource(R.string.bottom_navigation_home))
                 },
                 selected = true,
                 onClick = {}
             )
             NavigationBarItem(
                 icon = {
                     Icon(
                         imageVector = Icons.Default.AccountCircle,
                         contentDescription = null
                     )
                 },
                 label = {
                     Text(stringResource(R.string.bottom_navigation_profile))
                 },
                 selected = false,
                 onClick = {}
             )
         }
      }

   Now the navigation bar should look like this, notice how it provides more contrast.

   |layouts43.png|


12. MySoothe App - Scaffold
---------------------------


   For this step, create the full screen implementation, including the bottom navigation.
   Use Material's `Scaffold <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Scaffold(androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,androidx.compose.material3.FabPosition,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.foundation.layout.WindowInsets,kotlin.Function1)>`__
   composable. ``Scaffold`` gives you a **top-level configurable composable** for apps
   that implement Material design. It contains slots for various Material concepts, one of
   which is the bottom bar. In this bottom bar, you can place the bottom navigation
   composable that you created in the previous step.

   Implement the ``MySootheAppPortrait()`` composable. This is the top level composable
   for your app, so you should:

   -  Apply the ``MySootheTheme`` Material theme.
   -  Add the ``Scaffold``.
   -  Set the bottom bar to be your ``SootheBottomNavigation`` composable.
   -  Set the content to be your ``HomeScreen`` composable.

   Your final result should be:

   .. code:: prettyprint

      import androidx.compose.material3.Scaffold

      @Composable
      fun MySootheAppPortrait() {
         MySootheTheme {
             Scaffold(
                 bottomBar = { SootheBottomNavigation() }
             ) { padding ->
                 HomeScreen(Modifier.padding(padding))
             }
         }
      }

   Your implementation is now complete! If you want to check if your version is
   implemented in a pixel-perfect way, you can compare this image to your own Preview
   implementation.

   |my soothe implementation|


13. Navigation Rail - Material
------------------------------


   When creating layouts for apps, you also need to be mindful of what it will look like
   in multiple configurations including landscape mode on your phone. Here is the design
   for the app in landscape mode, notice how the bottom navigation turns into a rail on
   the left of the screen content.

   |landscape design|

   To implement this you will use the `NavigationRail <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#NavigationRail(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function1,androidx.compose.foundation.layout.WindowInsets,kotlin.Function1)>`__
   composable which is part of the Compose Material library and has a similar
   implementation to the `NavigationBar <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#NavigationBar(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.WindowInsets,kotlin.Function1)>`__
   that was used to create the bottom navigation bar. Inside the NavigationRail
   composable, you will add `NavigationRailItem <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#NavigationRailItem(kotlin.Boolean,kotlin.Function0,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Function0,kotlin.Boolean,androidx.compose.material3.NavigationRailItemColors,androidx.compose.foundation.interaction.MutableInteractionSource)>`__
   elements for Home and Profile.

   |layouts61.png|

   Let's start with the basic implementation for a Navigation Rail.

   .. code:: prettyprint

      import androidx.compose.material3.NavigationRail
      import androidx.compose.material3.NavigationRailItem

      @Composable
      private fun SootheNavigationRail(modifier: Modifier = Modifier) {
         NavigationRail(
         ) {
             Column(
             ) {
                 NavigationRailItem(
                     icon = {
                         Icon(
                             imageVector = Icons.Default.Spa,
                             contentDescription = null
                         )
                     },
                     label = {
                         Text(stringResource(R.string.bottom_navigation_home))
                     },
                     selected = true,
                     onClick = {}
                 )

                 NavigationRailItem(
                     icon = {
                         Icon(
                             imageVector = Icons.Default.AccountCircle,
                             contentDescription = null
                         )
                     },
                     label = {
                         Text(stringResource(R.string.bottom_navigation_profile))
                     },
                     selected = false,
                     onClick = {}
                 )
             }
         }
      }

   |navigation rail preview|

   There are some style adaptations you should make.

   -  Add 8.dp of padding at the start and end of the rail.
   -  Update the background color of the navigation rail by setting its ``containerColor``
      parameter using the background color from the Material Theme for this. By setting
      the background color, the color of the icons and texts automatically adapts to the
      ``onBackground`` color of the theme.
   -  The column should fill the maximum height.
   -  Set the column's vertical arrangement to center.
   -  Set the column's horizontal alignment to center horizontally.
   -  Add 8.dp of padding between the two icons.

   Your final solution should look something like this:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.fillMaxHeight

      @Composable
      private fun SootheNavigationRail(modifier: Modifier = Modifier) {
         NavigationRail(
             modifier = modifier.padding(start = 8.dp, end = 8.dp),
             containerColor = MaterialTheme.colorScheme.background,
         ) {
             Column(
                 modifier = modifier.fillMaxHeight(),
                 verticalArrangement = Arrangement.Center,
                 horizontalAlignment = Alignment.CenterHorizontally
             ) {
                 NavigationRailItem(
                     icon = {
                         Icon(
                             imageVector = Icons.Default.Spa,
                             contentDescription = null
                         )
                     },
                     label = {
                         Text(stringResource(R.string.bottom_navigation_home))
                     },
                     selected = true,
                     onClick = {}
                 )
                 Spacer(modifier = Modifier.height(8.dp))
                 NavigationRailItem(
                     icon = {
                         Icon(
                             imageVector = Icons.Default.AccountCircle,
                             contentDescription = null
                         )
                     },
                     label = {
                         Text(stringResource(R.string.bottom_navigation_profile))
                     },
                     selected = false,
                     onClick = {}
                 )
             }
         }
      }

   |navigation rail design|

   Now, let's add the Navigation Rail into the landscape layout.

   |layouts63.png|

   For the portrait version of the app you used a Scaffold. However, for landscape you'll
   use a Row and place the navigation rail and screen content next to each other.

   .. code:: prettyprint

      @Composable
      fun MySootheAppLandscape() {
         MySootheTheme {
             Row {
                 SootheNavigationRail()
                 HomeScreen()
             }
         }
      }

   When you used a Scaffold in the portrait version, it also took care of setting the
   content color to background for you. To set the color of the Navigation Rail, wrap the
   Row in a Surface and set it to background color.

   .. code:: prettyprint

      @Composable
      fun MySootheAppLandscape() {
         MySootheTheme {
             Surface(color = MaterialTheme.colorScheme.background) {
                 Row {
                     SootheNavigationRail()
                     HomeScreen()
                 }
             }
         }
      }

   |landscape preview|


14. MySoothe App - Window size
------------------------------


   You have the Preview for landscape mode looking great. However, if you run the app on a
   device or emulator and turn it to the side, it won't show you the landscape version.
   That is because we need to tell the app when to show which configuration of the app. To
   do this, use the `calculateWindowSizeClass() <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/windowsizeclass/package-summary#calculateWindowSizeClass(android.app.Activity)>`__
   function to see what configuration the phone is in.

   |window size diagram|

   There are three window size class widths: Compact, Medium and Expanded. When the app is
   in portrait mode it is Compact width, when it is in landscape mode it is Expanded
   width. For the purposes of this codelab, you won't be working with Medium width.

   In the MySootheApp Composable, update it to take in the device's `WindowSizeClass <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/windowsizeclass/WindowSizeClass>`__.
   If it is compact, pass in the portrait version of the app. If it is landscape, pass in
   the landscape version of the app.

   .. code:: prettyprint

      import androidx.compose.material3.windowsizeclass.WindowSizeClass
      import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
      @Composable
      fun MySootheApp(windowSize: WindowSizeClass) {
         when (windowSize.widthSizeClass) {
             WindowWidthSizeClass.Compact -> {
                 MySootheAppPortrait()
             }
             WindowWidthSizeClass.Expanded -> {
                 MySootheAppLandscape()
             }
         }
      }

   In ``setContent()`` create a val called windowSizeClass set to
   ``calculateWindowSize()`` and pass it into MySootheApp().

   Since ``calculateWindowSize()`` is still experimental you will need to opt into the
   ``ExperimentalMaterial3WindowSizeClassApi`` class.

   .. code:: prettyprint

      import androidx.compose.material3.windowsizeclass.ExperimentalMaterial3WindowSizeClassApi
      import androidx.compose.material3.windowsizeclass.calculateWindowSizeClass

      class MainActivity : ComponentActivity() {
         @OptIn(ExperimentalMaterial3WindowSizeClassApi::class)
         override fun onCreate(savedInstanceState: Bundle?) {
             super.onCreate(savedInstanceState)
             setContent {
                 val windowSizeClass = calculateWindowSizeClass(this)
                 MySootheApp(windowSizeClass)
             }
         }
      }

   Now - run the app on your emulator or device and observe how the display changes on
   rotation.

   |Portrait version of app|

   |Landscape version of app|


15. Congratulations
-------------------


   Congratulations, you've successfully completed this codelab and learned more about
   layouts in Compose. Through implementing a real-world design, you learned about
   modifiers, alignments, arrangements, Lazy layouts, slot APIs, scrolling, Material
   components and layout specific designs.

   Check out the other codelabs on the `Compose pathway <https://developer.android.google.cn/courses/pathways/compose>`__. 
   And check out the `code samples <http://goo.gle/compose-samples>`__.


Documentation

   For more information and guidance about these topics, check out the following
   documentation:

   -  `Layouts in Compose <https://developer.android.google.cn/jetpack/compose/layouts>`__
   -  `Modifiers <https://developer.android.google.cn/jetpack/compose/modifiers>`__
   -  `Support different screen sizes <https://developer.android.google.cn/develop/ui/compose/layouts/adaptive/support-different-screen-sizes>`__


.. |Portrait version of app| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts1.png
.. |Landscape version of app| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts2.png
.. |portrait design| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts4.png
.. |app design breakdown| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts54.png
.. |layouts55.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts55.png
.. |align your body element| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts7.png
.. |favorite collection card| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts8.png
.. |search bar| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts9.png
.. |search bar redline| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts10.png
.. |search bar preview| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts11.png
.. |align your body component| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts13.png
.. |align your body redline| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts56.png
.. |align your body preview| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts15.png
.. |layouts16.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts16.png
.. |align your body content preview| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts17.png
.. |layouts18.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts18.png
.. |layouts20.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts20.png
.. |layouts21.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts21.png
.. |favorite collection card redline| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts22.png
.. |favorite collection preview| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts23.png
.. |favorite collection redline| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts24.png
.. |layouts25.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts25.png
.. |layouts26.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts26.png
.. |align your body scrollable| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts27.gif
.. |layouts28.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts28.png
.. |layouts29.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts29.png
.. |row arrangements| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts30.gif
.. |col arrangements| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts31.gif
.. |layouts32.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts32.png
.. |layouts33.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts33.gif
.. |favorite collections scrolling| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts34.gif
.. |favorite collections preview| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts35.png
.. |layouts36.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts36.png
.. |home section redline| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts58.png
.. |home section preview| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts38.png
.. |layouts59.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts59.png
.. |screen content scroll| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/ScreenContentScroll.gif
.. |bottom navigation design| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts41.png
.. |bottom navigation preview| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts42.png
.. |layouts43.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts43.png
.. |my soothe implementation| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts44.png
.. |landscape design| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts45.png
.. |layouts61.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts61.png
.. |navigation rail preview| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts47.png
.. |navigation rail design| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts62.png
.. |layouts63.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts63.png
.. |landscape preview| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts50.png
.. |window size diagram| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-layouts/img/layouts51.png


ğŸš€ State in Jetpack Compose
============================

https://developer.android.google.cn/codelabs/jetpack-compose-state?hl=en


1. Before you begin
-------------------


   This codelab explains the core concepts related to using `State <https://developer.android.google.cn/jetpack/compose/state>`__ 
   in Jetpack Compose. It shows you how the app's state determines what is displayed in the UI, 
   how Compose updates the UI when state changes by working with different APIs, how to
   optimize the structure of our composable functions, and using ViewModels in a Compose
   world.


**Prerequisites**


   -  Knowledge of Kotlin syntax.
   -  Basic understanding of Compose (you can start with the `Jetpack Compose tutorial <https://developer.android.google.cn/jetpack/compose/tutorial>`__).
   -  Basic understanding of Architecture Component's `ViewModel <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__.


**What you'll learn**


   -  How to think about state and events in a Jetpack Compose UI.
   -  How Compose uses state to determine which elements to display on the screen.
   -  What state hoisting is.
   -  How stateful and stateless composable functions work.
   -  How Compose automatically tracks state with the ``State<T>`` API.
   -  How memory and internal state work in a composable function: using the ``remember``
      and ``rememberSaveable`` APIs.
   -  How to work with lists and state: using the ``mutableStateListOf`` and
      ``toMutableStateList`` APIs.
   -  How to use ``ViewModel`` with Compose.


**What you'll need**


Recommended/Optional


   -  Read `Thinking in Compose <https://developer.android.google.cn/jetpack/compose/mental-model>`__.
   -  Follow the `Jetpack Compose basics codelab <https://codelabs.developers.google.cn/codelabs/jetpack-compose-basics/>`__
      before this codelab. We will be doing a full recap of State in this codelab.


**What you'll build**


   |775940a48311302b.png|

   The app has two main functionalities:

   -  A water counter to track your water intake.
   -  A list of wellness tasks to do throughout the day.

   For more support as you're walking through this codelab, check out the following
   code-along:


2. Get set up
-------------



Start a new Compose project


   1. To start a new Compose project, open Android Studio.
   2. If you're in the **Welcome to Android Studio** window, click **Start a new Android
      Studio** project. If you already have an Android Studio project open, select **File
      > New > New Project** from the menu bar.
   3. For a new project, choose **Empty Activity** from the available templates.

   |New project|

   4. Click **Next** and configure your project, calling it "**BasicStateCodelab**".

   Make sure you select a *minimumSdkVersion* of at least API level 21, which is the
   minimum API Compose supports.

   **Note:** For more information about setting up Compose with an empty activity or
   adding it to an existing project, check out the `Compose Setup documentation <https://developer.android.google.cn/jetpack/compose/setup>`__.

   When you choose the **Empty Compose Activity** template, Android Studio sets up the
   following for you in your project:

   -  A ``MainActivity`` class configured with a composable function that displays some
      text on the screen.
   -  The ``AndroidManifest.xml`` file, which defines your app's permissions, components,
      and custom resources.
   -  The ``build.gradle.kts`` and ``app/build.gradle.kts`` files contain options and
      dependencies needed for Compose.


Solution to the codelab


   ::

      $ git clone https://github.com/android/codelab-android-compose

   Alternatively you can `download the repository as a Zip file <https://github.com/android/codelab-android-compose/archive/end.zip>`__.

   You'll find the solution code in the ``BasicStateCodelab`` project. We recommend that
   you follow the codelab step by step at your own pace and check the solution if you need
   help. During the codelab, you are presented with snippets of code that you need to add
   to your project.

   **Warning:** The project's name is `BasicStateCodelab <https://github.com/android/codelab-android-compose/tree/main/BasicStateCodelab>`__\ **.**


3. State in Compose
-------------------


   An app's "state" is any value that can change over time. This is a very broad
   definition and encompasses everything from a `Room <https://developer.android.google.cn/jetpack/androidx/releases/room>`__ 
   database to a variable in a class.

   All Android apps display state to the user. A few examples of state in Android apps
   are:

   -  The most recent messages received in a chat app.
   -  The user's profile photo.
   -  The scroll position in a list of items.

   **Key idea:** State determines what is shown in the UI at any particular time.

   Let's start writing your Wellness app.

   For simplicity, during the codelab:

   -  You can add all Kotlin files in the root ``com.codelabs.basicstatecodelab`` package
      of the ``app`` module. In a production app, however, files should be logically
      structured in subpackages.
   -  You'll hardcode all strings inline in snippets. In a real app, they should be added
      as string resources in the ``strings.xml`` file and referenced using Compose's
      `stringResource <https://developer.android.google.cn/jetpack/compose/resources#strings>`__
      API.

   The first piece of functionality you need to build is a water counter to count the
   number of glasses of water you consume during the day.

   Create a composable function called ``WaterCounter`` that contains a
   `Text <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/package-summary#Text(kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.font.FontStyle,androidx.compose.ui.text.font.FontWeight,androidx.compose.ui.text.font.FontFamily,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextDecoration,androidx.compose.ui.text.style.TextAlign,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextOverflow,kotlin.Boolean,kotlin.Int,kotlin.Function1,androidx.compose.ui.text.TextStyle)>`__
   composable that displays the number of glasses. The number of glasses should be stored
   in a value called ``count``, which you can hardcode for now.

   Create a new file ``WaterCounter.kt`` with the ``WaterCounter`` composable function,
   like this:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.padding
      import androidx.compose.material3.Text
      import androidx.compose.runtime.Composable
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.unit.dp

      @Composable
      fun WaterCounter(modifier: Modifier = Modifier) {
         val count = 0
         Text(
             text = "You've had $count glasses.", 
             modifier = modifier.padding(16.dp)
         )
      }

   **Note:** It's a good practice to provide a default `Modifier <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/Modifier>`__
   to all composable functions, as it increases reusability. It should appear as the first
   optional parameter in the parameter list, after all required parameters.

   Let's create a composable function that represents the whole screen, which will have
   two sections, the water counter and the list of wellness tasks. For now we'll just add
   our counter.

   1. Create a file ``WellnessScreen.kt``, which represents the main screen, and call our
      ``WaterCounter`` function:

   .. code:: prettyprint

      import androidx.compose.runtime.Composable
      import androidx.compose.ui.Modifier

      @Composable
      fun WellnessScreen(modifier: Modifier = Modifier) {
         WaterCounter(modifier)
      }

   2. Open the ``MainActivity.kt``. Remove the ``Greeting`` and the ``DefaultPreview``
      composables. Call the newly created ``WellnessScreen`` composable inside the
      Activity's ``setContent`` block, like this:

   .. code:: prettyprint

      class MainActivity : ComponentActivity() {
         override fun onCreate(savedInstanceState: Bundle?) {
             super.onCreate(savedInstanceState)
             setContent {
                 BasicStateCodelabTheme {
                     // A surface container using the 'background' color from the theme
                     Surface(
                         modifier = Modifier.fillMaxSize(),
                         color = MaterialTheme.colorScheme.background
                     ) {
                         WellnessScreen()
                     }
                 }
             }
         }
      }

   **Warning**: The app theme used in ``MainActivity`` inside ``setContent`` depends on
   how your project is named. This codelab assumes that the project is called
   *BasicStateCodelab*. If you copy-paste code from the codelab, don't forget to update
   ``BasicStateCodelab`` with the name of your theme available in the ``ui/Theme.kt``
   file.

   3. If you run the app now, you'll see our basic water counter screen with the hardcoded
      count of glasses of water.

   |7ed1e6fbd94bff04.jpeg|

   The state of the ``WaterCounter`` composable function is the variable ``count``. But
   having a static state is not very useful as it cannot be modified. To remedy this,
   you'll add a `Button <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Button(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.material3.ButtonElevation,androidx.compose.ui.graphics.Shape,androidx.compose.foundation.BorderStroke,androidx.compose.material3.ButtonColors,androidx.compose.foundation.layout.PaddingValues,kotlin.Function1)>`__
   to increase the count and track the amount of glasses of water you have throughout the
   day.

   Any action that causes the modification of state is called an "**event**" and we'll
   learn more about this in the next section.


4. Events in Compose
--------------------


   We talked about state as any value that changes over time, for example, the last
   messages received in a chat app. But what causes the state to update? In Android apps,
   state is updated in response to events.

   Events are inputs generated from outside or inside an application, such as:

   -  The user interacting with the UI by, for example, pressing a button.
   -  Other factors, such as sensors sending a new value, or network responses.

   **While the state of the app offers a description of what to display in the UI, events
   are the mechanism through which the state changes, resulting in changes to the UI.**

   **Key idea:** State *is*. Events *happen*.

   Events notify a part of a program that something has happened. In all Android apps,
   there's a core UI update loop that goes like this:

   |f415ca9336d83142.png|

   -  Event - An event is generated by the user or another part of the program.
   -  Update State - An event handler changes the state that is used by the UI.
   -  Display State - The UI is updated to display the new state.

   Managing state in Compose is all about understanding how state and events interact with
   each other.

   Now, add the button so that users can modify the state by adding more glasses of water.

   Go to the ``WaterCounter`` composable function to add the ``Button`` below our label
   ``Text``. A `Column <https://developer.android.google.cn/reference/kotlin/androidx/glance/layout/package-summary#column>`__
   will help you vertically align the ``Text`` with the ``Button`` composables. You can
   move the external padding to the ``Column`` composable and add some extra padding to
   the top of the ``Button`` so it's separated from the Text.

   The ``Button`` composable function receives an ``onClick`` `lambda function <https://kotlinlang.org/docs/lambdas.html>`__ - 
   this is the event that happens when the button is clicked. You'll see more examples 
   of lambda functions later.

   Change ``count`` to ``var`` instead of ``val`` so it becomes mutable.

   .. code:: prettyprint

      import androidx.compose.material3.Button
      import androidx.compose.foundation.layout.Column

      @Composable
      fun WaterCounter(modifier: Modifier = Modifier) {
         Column(modifier = modifier.padding(16.dp)) {
             var count = 0
             Text("You've had $count glasses.")
             Button(onClick = { count++ }, Modifier.padding(top = 8.dp)) {
                 Text("Add one")
             }
         }
      }

   The ``onClick`` event passed to ``Button`` uses the Kotlin lambda syntax. To learn more
   about lambdas in Kotlin, check out the `Kotlin documentation <https://kotlinlang.org/docs/reference/lambdas.html>`__.

   When you run the app and click the button, notice that nothing happens. Setting a
   different value for the ``count`` variable won't make Compose detect it as a *state
   change* so nothing happens. This is because you haven't told Compose that it should
   redraw the screen (that is, "recompose" the composable function), when the state
   changes. You'll fix this in the next step.

   |e4dfc3bef967e0a1.gif|

   **Warning:** You might be tempted to add logs in Logcat to debug your composable
   functions to try to figure out if they're working properly. However, be aware that this
   process might not be very reliable when working with Compose due to, for example,
   recompositions being discarded, as explored in `Thinking in Compose <https://developer.android.google.cn/jetpack/compose/mental-model>`__.


5. Memory in a composable function
----------------------------------


   Compose apps transform data into UI by calling composable functions. We refer to 
   **the Composition** as the description of the UI built by Compose when it executes
   composables. If a state change happens, Compose re-executes the affected composable
   functions with the new state, creating an updated UIâ€”this is called **recomposition**.
   Compose also looks at what data an individual composable needs, so that it only
   recomposes components whose data has changed and skips those that are not affected.

   **The Composition:** a description of the UI built by Jetpack Compose when it executes
   composables.

   **Initial composition:** creation of a Composition by running composables the first
   time.

   **Recomposition:** re-running composables to update the Composition when data changes.

   To be able to do this, **Compose needs to know what state to track,** so that when it
   receives an update it can schedule the recomposition.

   **Compose has a special state tracking system in place that schedules recompositions
   for any composables that read a particular state**. This lets Compose be granular and
   just recompose those composable functions that need to change, not the whole UI. This
   is done by tracking not only "writes" (that is, state changes), but also "reads" to the
   state.

   Use Compose's `State <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/State>`__
   and `MutableState <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/MutableState>`__
   types to make state observable by Compose.

   Compose keeps track of each composable that reads State ``value`` properties and
   triggers a recomposition when its ``value`` changes. You can use the
   `mutableStateOf <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#mutableStateOf(kotlin.Any,androidx.compose.runtime.SnapshotMutationPolicy)>`__
   function to create an observable ``MutableState``. It receives an initial value as a
   parameter that is wrapped in a ``State`` object, which then makes its ``value``
   observable.

   Compose also has other variants of ``mutableStateOf``, such as ``mutableIntStateOf``,
   ``mutableLongStateOf``, ``mutableFloatStateOf``, or ``mutableDoubleStateOf``, which are
   optimized for the primitive types. For the simplicity of this codelab, we will keep
   using its generic variant.

   Update ``WaterCounter`` composable, so that ``count`` uses ``mutableStateOf`` API with
   ``0`` as initial value. As ``mutableStateOf`` returns a ``MutableState`` type, you can
   update its ``value`` to update the state, and Compose will trigger a recomposition to
   those functions where its ``value`` is read.

   .. code:: prettyprint

      import androidx.compose.runtime.MutableState
      import androidx.compose.runtime.mutableStateOf

      @Composable
      fun WaterCounter(modifier: Modifier = Modifier) {
         Column(modifier = modifier.padding(16.dp)) {
             // Changes to count are now tracked by Compose
             val count: MutableState<Int> = mutableStateOf(0)

             Text("You've had ${count.value} glasses.")
              Button(onClick = { count.value++ }, Modifier.padding(top = 8.dp)) {
                 Text("Add one")
             }
         }
      }

   **Warning:** You might get a compilation warning by Android Studio:
   ``Creating a state object during composition without using remember.`` This is a valid
   warning that will be explained and fixed shortly. You can ignore it for now.

   As mentioned earlier, any changes to ``count`` schedules a recomposition of any
   composable functions that read ``count``'s ``value`` automatically. In this case,
   ``WaterCounter`` is recomposed whenever the button is clicked.

   If you run the app now, you'll notice again that nothing happens yet!

   |e4dfc3bef967e0a1.gif|

   Scheduling recompositions is working fine. However, when a recomposition happens, the
   variable ``count`` is re-initialized back to 0, so we need a way to preserve this value
   across recompositions.

   For this we can use the `remember <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0)>`__
   composable inline function. A value calculated by **``remember``** is stored in the
   Composition during the *initial composition*, and the stored value is kept across
   recompositions.

   You can think of using **``remember``** as a mechanism to store a single object in the
   Composition, in the same way a private val property does in an object.

   Usually ``remember`` and ``mutableStateOf`` are used together in composable functions.

   There are a few equivalent ways to write this as shown in the 
   `Compose State documentation <https://developer.android.google.cn/jetpack/compose/state#state-in-composables>`__.

   Modify ``WaterCounter``, surrounding the call to ``mutableStateOf`` with the
   ``remember`` inline composable function:

   .. code:: prettyprint

      import androidx.compose.runtime.remember

      @Composable
      fun WaterCounter(modifier: Modifier = Modifier) {
          Column(modifier = modifier.padding(16.dp)) {
              val count: MutableState<Int> = remember { mutableStateOf(0) } 
              Text("You've had ${count.value} glasses.")
              Button(onClick = { count.value++ }, Modifier.padding(top = 8.dp)) {
                  Text("Add one")
              }
          }
      }

   Alternatively, we could simplify the usage of ``count`` by using Kotlin's 
   `delegated properties <https://kotlinlang.org/docs/delegated-properties.html>`__.

   You can use the **by** keyword to define ``count`` as a var. Adding the delegate's
   getter and setter imports lets us read and mutate ``count`` indirectly without
   explicitly referring to the ``MutableState``'s ``value`` property every time.

   Now ``WaterCounter`` looks like this:

   .. code:: prettyprint

      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.setValue

      @Composable
      fun WaterCounter(modifier: Modifier = Modifier) {
         Column(modifier = modifier.padding(16.dp)) {
             var count by remember { mutableStateOf(0) }

             Text("You've had $count glasses.")
             Button(onClick = { count++ }, Modifier.padding(top = 8.dp)) {
                 Text("Add one")
             }
         }
      }

   You should pick the syntax that produces the easiest-to-read code in the composable
   you're writing.

   Now let's examine what we've done so far:

   -  Defined a variable that we remember over time called ``count``.
   -  Created a text display where we tell the user the number we remembered.
   -  Added a button that increments the number we remembered whenever it's clicked.

   This arrangement forms a data flow feedback loop with the user:

   -  The UI presents the state to the user (the current count is displayed as text).
   -  The user produces events that are combined with existing state to produce new state
      (clicking the button adds one to the current count)

   Your counter is ready and working!

   |a9d78ead2c8362b6.gif|

   **Note:** You might already be using other observable types like
   `LiveData <https://developer.android.google.cn/topic/libraries/architecture/livedata>`__,
   `StateFlow <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/>`__,
   `Flow <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html>`__,
   and RxJava's `Observable <http://reactivex.io/documentation/observable.html>`__ to
   store state in an app. To allow Compose to use this state and automatically recompose
   when the state changes you need to map them to a State<T>.

   There are extension functions designed to do this, so be sure to look them up in the
   `Compose and other libraries <https://developer.android.google.cn/jetpack/compose/libraries#streams>`__'
   documentation.


6. State driven UI
------------------


   Compose is a declarative UI framework. Instead of removing UI components or changing
   their visibility when state changes, we describe how the UI *is* under specific
   conditions of state. As a result of a recomposition being called and UI updated,
   composables might end up entering or leaving the Composition.

   |7d3509d136280b6c.png|

   This approach avoids the complexity of manually updating views as you would with the
   View system. It's also less error-prone, as you can't forget to update a view based on
   a new state, because it happens automatically.

   If a composable function is called during the initial composition or in recompositions,
   we say it is **present** in the Composition. A composable function that is not
   calledâ€”for example, because the function is called inside an **if** statement and the
   condition is not metâ€”-is **absent** from the Composition.

   You can learn more about the lifecycle `of composables <https://developer.android.google.cn/jetpack/compose/lifecycle#lifecycle-overview>`__
   in the documentation.

   **Key idea:** If the UI is what the user sees, the UI state is what the app says they
   should see. Like two sides of the same coin, the UI is the visual representation of the
   UI state. Any changes to the UI state are immediately reflected in the UI.

   The output of the Composition is a tree-structure that describes the UI.

   You can inspect the app layout generated by Compose using 
   `Android Studio's Layout inspector tool <https://developer.android.google.cn/studio/debug/layout-inspector>`__,
   which is what you'll do next.

   To demonstrate this, modify your code to show UI based on state. Open ``WaterCounter``
   and show the ``Text`` if the ``count`` is greater than 0:

   .. code:: prettyprint

      @Composable
      fun WaterCounter(modifier: Modifier = Modifier) {
         Column(modifier = modifier.padding(16.dp)) {
             var count by remember { mutableStateOf(0) }

             if (count > 0) {
                 // This text is present if the button has been clicked
                 // at least once; absent otherwise
                 Text("You've had $count glasses.")
             }
             Button(onClick = { count++ }, Modifier.padding(top = 8.dp)) {
                 Text("Add one")
             }
         }
      }

   Run the app, and open Android Studio's Layout inspector tool by navigating to 
   **Tools > Layout Inspector**.

   **Warning:** To see Compose nodes in the Inspector, use a device with API >= 29

   You'll see a split screen: the components tree to the left and a preview of the app to
   the right.

   Navigate the tree by tapping the root element ``BasicStateCodelabTheme`` on the left of
   the screen. Expand the whole component tree by clicking the *Expand all* button.

   Clicking on an element in the screen on the right navigates to the corresponding
   element of the tree.

   |677bc0a178670de8.png|

   If you press the *Add one* button on the app:

   -  Count increases to 1 and the state changes.
   -  A recomposition is called.
   -  Screen gets recomposed with the new elements.

   When you examine the component tree with Android Studio's Layout inspector tool, now
   you see the ``Text`` composable as well:

   |1f8e05f6497ec35f.png|

   **State drives which elements are present in the UI at a given moment.**

   Different parts of the UI can depend on the same state. Modify the ``Button`` so it's
   enabled until ``count`` is 10 and is then disabled (and you reach your goal for the
   day). Use the ``Button``'s ``enabled`` parameter to do this.

   .. code:: prettyprint

      @Composable
      fun WaterCounter(modifier: Modifier = Modifier) {
          ...
              Button(onClick = { count++ }, Modifier.padding(top = 8.dp), enabled = count < 10) {
          ...
      }

   Run the app now. Changes to state ``count`` determine whether or not to show the
   ``Text``, and whether the ``Button`` is enabled or disabled.

   |1a8f4095e384ba01.gif|


7. Remember in Composition
--------------------------


   `remember <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0)>`__
   stores objects in the Composition, and forgets the object if the source location where
   ``remember`` is called is not invoked again during a recomposition.

   To visualize this behavior, you'll implement the following piece of functionality in
   the app: when the user has had at least one glass of water, display a wellness task for
   the user to do, that they can also close. Because composables should be small and
   reusable, create a new composable called ``WellnessTaskItem`` that displays the
   wellness task based on a string received as a parameter, along with a *Close* icon
   button.

   Create a new file ``WellnessTaskItem.kt``, and add the following code. You'll use this
   composable function later in the codelab.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Row
      import androidx.compose.material3.Icon
      import androidx.compose.material3.IconButton
      import androidx.compose.material3.Text
      import androidx.compose.material.icons.Icons
      import androidx.compose.material.icons.filled.Close
      import androidx.compose.runtime.Composable
      import androidx.compose.ui.Alignment
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.unit.dp
      import androidx.compose.foundation.layout.padding

      @Composable
      fun WellnessTaskItem(
          taskName: String,
          onClose: () -> Unit,
          modifier: Modifier = Modifier
      ) {
          Row(
              modifier = modifier, verticalAlignment = Alignment.CenterVertically
          ) {
              Text(
                  modifier = Modifier.weight(1f).padding(start = 16.dp),
                  text = taskName
              )
              IconButton(onClick = onClose) {
                  Icon(Icons.Filled.Close, contentDescription = "Close")
              }
          }
      }

   The ``WellnessTaskItem`` function receives a task description and an ``onClose`` lambda
   function (just like the built-in ``Button`` composable receives an ``onClick``).

   ``WellnessTaskItem`` looks like this:

   |6e8b72a529e8dedd.png|

   To improve our app with more features, update ``WaterCounter`` to show the
   ``WellnessTaskItem`` when ``count`` > 0.

   When ``count`` is greater than 0, define a variable ``showTask`` that determines
   whether or not to show the ``WellnessTaskItem`` and initialize it to true.

   Add a new **if** statement to show ``WellnessTaskItem`` if ``showTask`` is true. Use
   the APIs you learned in the previous sections to make sure ``showTask`` value survives
   recompositions.

   .. code:: prettyprint

      @Composable
      fun WaterCounter() {
         Column(modifier = Modifier.padding(16.dp)) {
             var count by remember { mutableStateOf(0) }
             if (count > 0) {
                 var showTask by remember { mutableStateOf(true) }
                 if (showTask) {
                     WellnessTaskItem(
                         onClose = { },
                         taskName = "Have you taken your 15 minute walk today?"
                     )
                 }
                 Text("You've had $count glasses.")
             }

             Button(onClick = { count++ }, enabled = count < 10) {
                 Text("Add one")
             }
         }
      }

   Use the ``WellnessTaskItem``'s ``onClose`` lambda function, so that when the X button
   is pressed, the variable ``showTask`` changes to ``false`` and the task isn't shown
   anymore.

   .. code:: prettyprint

         ...
         WellnessTaskItem(
            onClose = { showTask = false },
            taskName = "Have you taken your 15 minute walk today?"
         )
         ...

   Next, add a new ``Button`` with the text *"Clear water count"* and place it beside the
   *"Add one"* ``Button``. A `Row <https://developer.android.google.cn/reference/androidx/leanback/widget/Row>`__
   can help align the two buttons. You can also add some padding to the ``Row``. When the
   *"Clear water count"* button is pressed, the variable ``count`` resets back to 0.

   Your ``WaterCounter`` composable function should look like this:

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Row


      @Composable
      fun WaterCounter(modifier: Modifier = Modifier) {
         Column(modifier = modifier.padding(16.dp)) {
             var count by remember { mutableStateOf(0) }
             if (count > 0) {
                 var showTask by remember { mutableStateOf(true) }
                 if (showTask) {
                     WellnessTaskItem(
                         onClose = { showTask = false },
                         taskName = "Have you taken your 15 minute walk today?"
                     )
                 }
                 Text("You've had $count glasses.")
             }

             Row(Modifier.padding(top = 8.dp)) {
                 Button(onClick = { count++ }, enabled = count < 10) {
                     Text("Add one")
                 }
                 Button(
                     onClick = { count = 0 }, 
                     Modifier.padding(start = 8.dp)) {
                         Text("Clear water count")
                 }
             }
         }
      }

   When you run the app, your screen shows the initial state:

   ====================== =========================================================================
   |8a849818f7721489.png| |Tree of components diagram, showing the app's initial state, count is 0|
   ====================== =========================================================================

   To the right, we have a simplified version of the components tree, which will help you
   analyze what is happening as state changes. ``count`` and ``showTask`` are remembered
   values.

   Now you can follow these steps in the app:

   -  Press the *Add one* button. That increments ``count`` (this causes a recomposition)
      and both ``WellnessTaskItem`` and counter ``Text`` start to display.

   |Tree of components diagram, showing state change, when Add one button is clicked, Text
   with tip appears and Text with glasses count appears.|

   |865af0485f205c28.png|

   -  Press the X of ``WellnessTaskItem`` component (this causes another recomposition).
      ``showTask`` is now false, which means ``WellnessTaskItem`` isn't displayed anymore.

   |Tree of components diagram, showing that when close button is clicked, the task
   composable disappears.|

   |82b5dadce9cca927.png|

   -  Press the *Add one* button (another recomposition). ``showTask`` remembers you've
      closed ``WellnessTaskItem`` in the next recompositions if you keep adding glasses.

   ====================== ======================
   |6223c8c6f4e3bb1f.png| |34c7d0b6ba09ec91.png|
   ====================== ======================

   -  Press the *Clear water count* button to reset ``count`` to 0 and cause a
      recomposition. ``Text`` showing ``count``, and all code related to
      ``WellnessTaskItem``, are not invoked and leave the Composition.

   |ae993e6ddc0d654a.png|

   -  ``showTask`` is forgotten because the code location where remember ``showTask`` is
      called was not invoked. You're back to the first step.

   ====================== ======================
   |55ae5538c40546f5.png| |d9d6eeaf6367f404.png|
   ====================== ======================

   -  Press the *Add one* button making ``count`` greater than 0 (recomposition).

   |7624eed0848a145c.png|

   -  ``WellnessTaskItem`` composable displays again, because the previous value of
      ``showTask`` was forgotten when it left the Composition above.

   What if we require ``showTask`` to persist after ``count`` goes back to 0, longer than
   what ``remember`` allows (that is, even if the code location where ``remember`` is
   called is not invoked during a recomposition)? We'll explore how to fix these scenarios
   and more examples in the next sections.

   Now that you understand how the UI and state are reset when they leave the Composition,
   clear your code and go back to the ``WaterCounter`` you had at the beginning of this
   section:

   .. code:: prettyprint

      @Composable
      fun WaterCounter(modifier: Modifier = Modifier) {
          Column(modifier = modifier.padding(16.dp)) {
              var count by remember { mutableStateOf(0) }
              if (count > 0) {
                  Text("You've had $count glasses.")
              }
              Button(onClick = { count++ }, Modifier.padding(top = 8.dp), enabled = count < 10) {
                  Text("Add one")
              }
          }
      }


8. Restore state in Compose
---------------------------


   Run the app, add some glasses of water to the counter, and then rotate your device.
   Make sure you have the device's Auto-rotate setting on.

   Because Activity is recreated after a configuration change (in this case, orientation),
   the state that was saved is forgotten: the counter disappears as it goes back to 0.

   |2c1134ad78e4b68a.gif|

   The same happens if you change language, switch between dark and light mode, or any
   other configuration change that makes Android recreate the running Activity.

   While ``remember`` helps you retain state across recompositions, it's **not retained
   across configuration changes**. For this, you must use `rememberSaveable <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/package-summary#rememberSaveable(kotlin.Array,androidx.compose.runtime.saveable.Saver,kotlin.String,kotlin.Function0)>`__
   instead of ``remember``.

   ``rememberSaveable`` automatically saves any value that can be saved in a `Bundle <https://developer.android.google.cn/reference/android/os/Bundle>`__. 
   For other values, you can pass in a custom saver object. For more information on 
   `Restoring state in Compose <https://developer.android.google.cn/jetpack/compose/state#restore-ui-state>`__,
   check out the documentation.

   In ``WaterCounter``, replace ``remember`` with ``rememberSaveable``:

   .. code:: prettyprint

      import androidx.compose.runtime.saveable.rememberSaveable

      @Composable
      fun WaterCounter(modifier: Modifier = Modifier) {
              ...
              var count by rememberSaveable { mutableStateOf(0) }
              ...
      }

   Run the app now and try some configuration changes. You should see the counter is
   properly saved.

   |bf2e1634eff47697.gif|

   Activity recreation is just one of the use cases of ``rememberSaveable``. We'll explore
   another use case later while working with lists.

   Use **``rememberSaveable``** to restore your UI state after an Activity is recreated.
   Besides retaining state across recompositions, **``rememberSaveable``** also retains
   state across Activity recreation and system-initiated process death.

   Consider whether to use ``remember`` or ``rememberSaveable`` depending on your app's
   state and UX needs.


9. State hoisting
-----------------


   A composable that uses **``remember``** to store an object contains internal state,
   which makes the composable **stateful**. This is useful in situations where a caller
   doesn't need to control the state and can use it without having to manage the state
   themselves. However, **composables with internal state tend to be less reusable and
   harder to test**.

   **Composables that don't hold any state are called stateless composables**. An easy way
   to create a **stateless** composable is by using state hoisting.

   State hoisting in Compose is a pattern of moving state to a composable's caller to make
   a composable stateless. The general pattern for state hoisting in Jetpack Compose is to
   replace the state variable with two parameters:

   -  **value: T** - the current value to display
   -  **onValueChange: (T) -> Unit** - an event that requests the value to change with a
      new value T

   where this value represents any state that could be modified.

   The pattern where the state goes down, and events go up is called Unidirectional Data
   Flow (UDF), and state hoisting is how we implement this architecture in Compose. You
   can learn more about this in the `Compose Architecture documentation <https://developer.android.google.cn/jetpack/compose/architecture#udf-compose>`__.

   State that is hoisted this way has some important properties:

   -  **Single source of truth**: By moving state instead of duplicating it, we're
      ensuring there's only one source of truth. This helps avoid bugs.
   -  **Shareable**: Hoisted state can be shared with multiple composables.
   -  **Interceptable**: Callers to the stateless composables can decide to ignore or
      modify events before changing the state.
   -  **Decoupled**: The state for a stateless composable function can be stored anywhere.
      For example, in a ViewModel.

   Try to implement this for the ``WaterCounter`` so it can benefit from all of the above.


Stateful vs Stateless


   When all state can be extracted from a composable function the resulting composable
   function is called stateless.

   A **stateless** composable is a composable that doesn't own any state, meaning it
   doesn't hold or define or modify new state.

   A **stateful** composable is a composable that owns a piece of state that can change
   over time.

   In real apps, having a 100% stateless composable can be difficult to achieve depending
   on the composable's responsibilities. You should design your composables in a way that
   they will own as little state as possible and allow the state to be hoisted, when it
   makes sense, by exposing it in the composable's API.

   Refactor ``WaterCounter`` composable by splitting it into two parts: stateful and
   stateless Counter.

   The role of the ``StatelessCounter`` is to display the ``count`` and call a function
   when you increment the ``count``. To do this, follow the pattern described above and
   pass the state, ``count`` (as a parameter to the composable function), and a lambda
   (``onIncrement``), that is called when the state needs to be incremented.
   ``StatelessCounter`` looks like this:

   .. code:: prettyprint

      @Composable
      fun StatelessCounter(count: Int, onIncrement: () -> Unit, modifier: Modifier = Modifier) {
         Column(modifier = modifier.padding(16.dp)) {
             if (count > 0) {
                 Text("You've had $count glasses.")
             }
             Button(onClick = onIncrement, Modifier.padding(top = 8.dp), enabled = count < 10) {
                 Text("Add one")
             }
         }
      }

   ``StatefulCounter`` owns the state. That means that it holds the ``count`` state and
   modifies it when calling the ``StatelessCounter`` function.

   .. code:: prettyprint

      @Composable
      fun StatefulCounter(modifier: Modifier = Modifier) {
         var count by rememberSaveable { mutableStateOf(0) }
         StatelessCounter(count, { count++ }, modifier)
      }

   Good job! You *hoisted* ``count`` from ``StatelessCounter`` to ``StatefulCounter``.

   You can plug this into your app and update ``WellnessScreen`` with the
   ``StatefulCounter``:

   .. code:: prettyprint

      @Composable
      fun WellnessScreen(modifier: Modifier = Modifier) {
         StatefulCounter(modifier)
      }

   **Key Point:** When hoisting state, there are three rules to help you figure out where
   state should go:

   1. State should be hoisted to at *least* the **lowest common parent** of all
      composables that use the state (read).
   2. State should be hoisted to at *least* the **highest level it may be changed**
      (write).
   3. If **two states change in response to the same events** they should be **hoisted to
      the same level.**

   You can hoist the state higher than these rules require, but if you don't hoist the
   state high enough, it might be difficult or impossible to follow unidirectional data
   flow.

   As mentioned, state hoisting has some benefits. We'll explore variations of this code
   to explain some of them, **you don't need to copy the following snippets in your app**.

   1. **Your stateless composable can now be reused**. Take for instance the following
      example.

   To count glasses of water and of juice you remember the ``waterCount`` and the
   ``juiceCount``, but use the same ``StatelessCounter`` composable function to display
   two different independent states.

   .. code:: prettyprint

      @Composable
      fun StatefulCounter() {
          var waterCount by remember { mutableStateOf(0) }

          var juiceCount by remember { mutableStateOf(0) }

          StatelessCounter(waterCount, { waterCount++ })
          StatelessCounter(juiceCount, { juiceCount++ })
      }

   |8211bd9e0a4c5db2.png|

   If ``juiceCount`` is modified then ``StatefulCounter`` is recomposed. During
   recomposition, Compose identifies which functions read ``juiceCount`` and triggers
   recomposition of only those functions.

   |2cb0dcdbe75dcfbf.png|

   When the user taps to increment ``juiceCount``, ``StatefulCounter`` recomposes, and so
   does the ``StatelessCounter`` that reads ``juiceCount``. But the ``StatelessCounter``
   that reads ``waterCount`` is not recomposed.

   |7fe6ee3d2886abd0.png|

   2. **Your stateful composable function can provide the same state to multiple
      composable functions**.

   .. code:: prettyprint

      @Composable
      fun StatefulCounter() {
         var count by remember { mutableStateOf(0) }

         StatelessCounter(count, { count++ })
         AnotherStatelessMethod(count, { count *= 2 })
      }

   In this case, if the count is updated by either ``StatelessCounter`` or
   ``AnotherStatelessMethod``, everything is recomposed, which is expected.

   Because hoisted state can be shared, be sure to **pass only the state that the
   composables need** to avoid unnecessary recompositions, and to increase reusability.

   **Key Point:** A best practice for the design of Composables is to pass them only the
   parameters they need.

   To read more about state and state hoisting, check out the `Compose State documentation <https://developer.android.google.cn/jetpack/compose/state#state-hoisting>`__.


10. Work with lists
-------------------


   Next, add the second feature of your app, the list of wellness tasks. You can perform
   two actions with items on the list:

   -  Check list items to mark the task as completed.
   -  Remove tasks from the list you're not interested in completing.


Setup


   1. First, modify the list item. You can reuse the ``WellnessTaskItem`` from the
      Remember in Composition section, and update it to contain the `Checkbox <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/package-summary#Checkbox(kotlin.Boolean,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.material.CheckboxColors)>`__.
      Make sure that you hoist the ``checked`` state and the ``onCheckedChange`` callback
      to make the function stateless.

   |a0f8724cfd33cb10.png|

   The ``WellnessTaskItem`` composable for this section should look like this:

   .. code:: prettyprint

      import androidx.compose.material3.Checkbox

      @Composable
      fun WellnessTaskItem(
          taskName: String,
          checked: Boolean,
          onCheckedChange: (Boolean) -> Unit,
          onClose: () -> Unit,
          modifier: Modifier = Modifier
      ) {
          Row(
              modifier = modifier, verticalAlignment = Alignment.CenterVertically
          ) {
              Text(
                  modifier = Modifier
                      .weight(1f)
                      .padding(start = 16.dp),
                  text = taskName
              )
              Checkbox(
                  checked = checked,
                  onCheckedChange = onCheckedChange
              )
              IconButton(onClick = onClose) {
                  Icon(Icons.Filled.Close, contentDescription = "Close")
              }
          }
      }

   2. In the same file, add a stateful ``WellnessTaskItem`` composable function that
      defines a state variable ``checkedState`` and passes it to the stateless method of
      the same name. Don't worry about ``onClose`` for now, you can pass an empty lambda
      function.

   .. code:: prettyprint

      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.setValue
      import androidx.compose.runtime.mutableStateOf
      import androidx.compose.runtime.remember

      @Composable
      fun WellnessTaskItem(taskName: String, modifier: Modifier = Modifier) {
         var checkedState by remember { mutableStateOf(false) }

         WellnessTaskItem(
             taskName = taskName,
             checked = checkedState,
             onCheckedChange = { newValue -> checkedState = newValue },
             onClose = {}, // we will implement this later!
             modifier = modifier,
         )
      }

   3. Create a file ``WellnessTask.kt`` to model a *task* that contains an ID and a label.
      Define it as a `data class <https://kotlinlang.org/docs/data-classes.html>`__.

   .. code:: prettyprint

      data class WellnessTask(val id: Int, val label: String)

   4. For the list of tasks itself, create a new file named ``WellnessTasksList.kt`` and
      add a method that generates some fake data:

   .. code:: prettyprint

      fun getWellnessTasks() = List(30) { i -> WellnessTask(i, "Task # $i") }

   Note that in a real app, you get your data from your `data layer <https://developer.android.google.cn/jetpack/guide/data-layer>`__.

   5. In ``WellnessTasksList.kt``, add a composable function that creates the list. Define
      a `LazyColumn <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyColumn(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__
      and items from the list method you created. Check out the `Lists documentation <https://developer.android.google.cn/jetpack/compose/lists>`__ 
      if you need help.

   .. code:: prettyprint

      import androidx.compose.foundation.lazy.LazyColumn
      import androidx.compose.foundation.lazy.items
      import androidx.compose.runtime.Composable
      import androidx.compose.ui.Modifier
      import androidx.compose.runtime.remember

      @Composable
      fun WellnessTasksList(
          modifier: Modifier = Modifier,
          list: List<WellnessTask> = remember { getWellnessTasks() }
      ) {
          LazyColumn(
              modifier = modifier
          ) {
              items(list) { task ->
                  WellnessTaskItem(taskName = task.label)
              }
          }
      }

   6. Add the list to ``WellnessScreen``. Use a ``Column`` to help vertically align the
      list with the counter you already have.

   **Note:** If you type ``WC`` in the editor area in Android Studio, it opens a
   suggestion box. If you press ``Enter`` and select the first option, a ``Column``
   template appears ready to use.

   To learn more about live templates in Android Studio for Compose and other useful
   tooling, check out the `Compose Tooling documentation <https://developer.android.google.cn/jetpack/compose/tooling#editor-actions>`__.

   .. code:: prettyprint

      import androidx.compose.foundation.layout.Column

      @Composable
      fun WellnessScreen(modifier: Modifier = Modifier) {
         Column(modifier = modifier) {
             StatefulCounter()
             WellnessTasksList()
         }
      }

   7. Run the app and give it a try! You should now be able to check tasks but not delete
      them. You'll implement that in a later section.

   |f9cbc49c960fd24c.gif|


Restore item state in LazyList


   ``checkedState`` belongs to each ``WellnessTaskItem`` composable independently, like a
   private variable. When ``checkedState`` changes, only that instance of
   ``WellnessTaskItem`` gets recomposed, not all ``WellnessTaskItem`` instances in the
   ``LazyColumn``.

   Try it out by following these steps:

   1. Check any element at the top of this list (for example elements 1 and 2).
   2. Scroll to the bottom of the list so that they're off the screen.
   3. Scroll back to the top to the items you checked before.
   4. Notice that they are unchecked.

   There is an issue, as you saw in a previous section, that when an item leaves the
   Composition, state that was remembered is forgotten. For items on a ``LazyColumn``,
   items leave the Composition entirely when you scroll past them and they're no longer
   visible.

   |a68b5473354d92df.gif|

   How do you fix this? Once again, use ``rememberSaveable``. Your state will survive the
   activity or process recreation using the saved instance state mechanism. Thanks to how
   ``rememberSaveable`` works together with the ``LazyList``, your items are able to also
   survive leaving the Composition.

   Just replace ``remember`` with ``rememberSaveable`` in your stateful
   ``WellnessTaskItem``, and that's it:

   .. code:: prettyprint

      import androidx.compose.runtime.saveable.rememberSaveable

      var checkedState by rememberSaveable { mutableStateOf(false) }

   |85796fb49cf5dd16.gif|


Common patterns in Compose


   Notice the implementation of `LazyColumn <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyColumn(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1)>`__:

   .. code:: prettyprint

      @Composable
      fun LazyColumn(
      ...
          state: LazyListState = rememberLazyListState(),
      ...

   The composable function ``rememberLazyListState`` creates an initial state for the list
   using ``rememberSaveable``. When the Activity is recreated, the scroll state is
   maintained without you having to code anything.

   Many apps need to react and listen to scroll position, item layout changes, and other
   events related to the list's state. Lazy components, like ``LazyColumn`` or
   ``LazyRow``, support this use case through hoisting the `LazyListState <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/LazyListState>`__.
   You can learn more about this pattern in the `documentation for state in lists <https://developer.android.google.cn/jetpack/compose/lists#react-to-scroll-position>`__.

   Having a state parameter with a default value provided by a public ``rememberX``
   function is a common pattern in built-in composable functions. Another example can be
   found in `BottomSheetScaffold <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#BottomSheetScaffold(kotlin.Function1,androidx.compose.ui.Modifier,androidx.compose.material3.BottomSheetScaffoldState,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,kotlin.Function0,kotlin.Boolean,kotlin.Function0,kotlin.Function1,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function1)>`__,
   which hoists state using `rememberBottomSheetScaffoldState <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#rememberBottomSheetScaffoldState(androidx.compose.material3.SheetState,androidx.compose.material3.SnackbarHostState)>`__.


11. Observable MutableList
--------------------------


   Next, to add the behavior of removing a task from our list, the first step is to make
   your list a mutable list.

   Using mutable objects for this, such as ``ArrayList<T>`` or ``mutableListOf,`` won't
   work. These types won't notify Compose that the items in the list have changed and
   schedule a recomposition of the UI. You need a different API.

   You need to create an instance of ``MutableList`` that is observable by Compose. This
   structure lets Compose track changes to recompose the UI when items are added or
   removed from the list.

   Start by defining our observable ``MutableList``. The extension function
   `toMutableStateList() <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#(kotlin.collections.Collection).toMutableStateList()>`__
   is the way to create an observable ``MutableList`` from an initial mutable or immutable
   ``Collection``, such as ``List``.

   Alternatively, you could also use the factory method `mutableStateListOf <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#mutableStateListOf()>`__
   to create the observable ``MutableList`` and then add the elements for your initial
   state.

   The ``mutableStateOf`` function returns an object of type ``MutableState<T>``.

   The ``mutableStateListOf`` and ``toMutableStateList`` functions return an object of
   type `SnapshotStateList<T> <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/snapshots/SnapshotStateList>`__.
   In this section, the terms "observable ``MutableList``" refer to this class.

   1. Open ``WellnessScreen.kt`` file. Move ``getWellnessTasks`` method to this file to be
      able to use it. Create the list by calling ``getWellnessTasks()`` first and then
      using the extension function ``toMutableStateList`` you learned before.

   .. code:: prettyprint

      import androidx.compose.runtime.remember
      import androidx.compose.runtime.toMutableStateList

      @Composable
      fun WellnessScreen(modifier: Modifier = Modifier) {
         Column(modifier = modifier) {
             StatefulCounter()

             val list = remember { getWellnessTasks().toMutableStateList() }
             WellnessTasksList(list = list, onCloseTask = { task -> list.remove(task) })
         }
      }

      private fun getWellnessTasks() = List(30) { i -> WellnessTask(i, "Task # $i") }

   **Warning**: You can use the ``mutableStateListOf`` API instead to create the list.
   However, the way you use it might result in unexpected recomposition and suboptimal UI
   performance.

   If you just define the list and then add the tasks in a different operation it would
   result in duplicated items being added for **every** recomposition.

   .. code:: prettyprint

      // Don't do this!

      val list = remember { mutableStateListOf<WellnessTask>() }

      list.addAll(getWellnessTasks())

   Instead, create the list with its initial value in a single operation and then pass it
   to the ``remember`` function, like this:

   .. code:: prettyprint

      // Do this instead. Don't need to copy

      val list = remember {

         mutableStateListOf<WellnessTask>().apply { addAll(getWellnessTasks()) }

      }

   2. Modify ``WellnessTasksList`` composable function by removing the list's default
      value, because the list is hoisted to the screen level. Add a new lambda function
      parameter ``onCloseTask`` (receiving a ``WellnessTask`` to delete). Pass
      ``onCloseTask`` to the ``WellnessTaskItem``.

   There's one more change you need to make. The ``items`` method receives a ``key``
   parameter. By default, each item's state is keyed against the position of the item in
   the list.

   In a mutable list, this causes issues when the data set changes, since items that
   change position effectively lose any remembered state.

   You can easily fix this by using the ``id`` of each ``WellnessTaskItem`` as the key for
   each item.

   To learn more about `item keys in a list <https://developer.android.google.cn/jetpack/compose/lists>`__, 
   check out the documentation.

   ``WellnessTasksList`` will look like this:

   .. code:: prettyprint

      @Composable
      fun WellnessTasksList(
         list: List<WellnessTask>,
         onCloseTask: (WellnessTask) -> Unit,
         modifier: Modifier = Modifier
      ) {
         LazyColumn(modifier = modifier) {
             items(
                 items = list,
                 key = { task -> task.id }
             ) { task ->
                 WellnessTaskItem(taskName = task.label, onClose = { onCloseTask(task) })
             }
         }
      }

   3. Modify ``WellnessTaskItem``: add the ``onClose`` lambda function as a parameter to
      the stateful ``WellnessTaskItem`` and call it.

   .. code:: prettyprint

      @Composable
      fun WellnessTaskItem(
         taskName: String, onClose: () -> Unit, modifier: Modifier = Modifier
      ) {
         var checkedState by rememberSaveable { mutableStateOf(false) }

         WellnessTaskItem(
             taskName = taskName,
             checked = checkedState,
             onCheckedChange = { newValue -> checkedState = newValue },
             onClose = onClose,
             modifier = modifier,
         )
      }

   Good job! The functionality is complete, and deleting an item from the list works.

   If you click the X in each row, the events go all the way up to the list that owns the
   state, removing the item from the list and causing Compose to recompose the screen.

   |47f4a64c7e9a5083.png|

   If you try to use ``rememberSaveable()`` to store the list in ``WellnessScreen``,
   you'll get a runtime exception:

   ``cannot be saved using the current SaveableStateRegistry. The default implementation only supports types which can be stored inside the Bundle. Please consider implementing a custom Saver for this class and pass it to rememberSaveable().``

   This error tells you that you need to provide a `custom saver <https://developer.android.google.cn/jetpack/compose/state#restore-ui-state>`__.
   However, you shouldn't be using **``rememberSaveable``** to store large amounts of data
   or complex data structures that require lengthy serialization or deserialization.

   Similar rules apply when working with Activity's `onSaveInstanceState <https://developer.android.google.cn/reference/android/app/Activity#onSaveInstanceState(android.os.Bundle)>`__;
   you can find more information in the `Save UI states documentation <https://developer.android.google.cn/topic/libraries/architecture/saving-states#onsaveinstancestate>`__.
   If you want to do this, you need an alternative storing mechanism. You can learn more
   about different `options for preserving UI state <https://developer.android.google.cn/topic/libraries/architecture/saving-states#options>`__
   in the documentation.

   Next, we'll look at ViewModel's role as a holder for the app's state.


12. State in ViewModel
----------------------


   The screen, or UI state, indicates what should display on the screen (for example, the
   list of tasks). **This state is usually connected with other layers of the hierarchy
   because it contains application data**.

   While the UI state describes what to show on the screen, the logic of an app describes
   how the app behaves and should react to state changes. There are two types of logic:
   the UI behavior or UI logic, and the business logic.

   -  The UI logic relates to *how to display* state changes on the screen (for example,
      the navigation logic or showing snackbars).
   -  The business logic is *what to do* with state changes (for example making a payment
      or storing user preferences). This logic is usually placed in the business or data
      layers, never in the UI layer.

   `ViewModels <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__
   provide the UI state and access to the business logic located in other layers of the
   app. Additionally, ViewModels survive configuration changes, so they have a longer
   lifetime than the Composition. They can follow the lifecycle of the host of Compose
   contentâ€”that is, activities, fragments, or the destination of a Navigation graph if
   you're using `Compose Navigation <https://developer.android.google.cn/jetpack/compose/navigation>`__.

   To learn more about architecture and UI layer, check the `UI layer documentation <https://developer.android.google.cn/jetpack/guide/ui-layer#define-ui-state>`__.

   **Warning:** ViewModels are not part of the Composition. Therefore, you should not hold
   state created in composables (for example, a remembered value) because this could cause
   memory leaks.


Migrate the list and remove method


   While the previous steps showed you how to manage the state directly in the Composable
   functions, it's a good practice to keep the UI logic and business logic separated from
   the UI state and migrate it to a ViewModel.

   Let's migrate the UI state, the list, to your ViewModel and also start extracting
   business logic into it.

   1. Create a file ``WellnessViewModel.kt`` to add your ViewModel class.

   Move your "data source" ``getWellnessTasks()`` to the ``WellnessViewModel``.

   Define an internal ``_tasks`` variable, using ``toMutableStateList`` as you did before,
   and expose ``tasks`` as a list, so it's not modifiable from outside the ViewModel.

   Implement a simple ``remove`` function that delegates to the list's builtin remove
   function.

   .. code:: prettyprint

      import androidx.compose.runtime.toMutableStateList
      import androidx.lifecycle.ViewModel

      class WellnessViewModel : ViewModel() {
          private val _tasks = getWellnessTasks().toMutableStateList()
          val tasks: List<WellnessTask>
              get() = _tasks


         fun remove(item: WellnessTask) {
             _tasks.remove(item)
         }
      }

      private fun getWellnessTasks() = List(30) { i -> WellnessTask(i, "Task # $i") }

   2. We can access this ViewModel from any composable by calling the `viewModel() <https://developer.android.google.cn/reference/kotlin/androidx/lifecycle/viewmodel/compose/package-summary#viewModel(androidx.lifecycle.ViewModelStoreOwner,kotlin.String,androidx.lifecycle.ViewModelProvider.Factory,androidx.lifecycle.viewmodel.CreationExtras)>`__
      function.

   To use this function, open the ``app/build.gradle.kts`` file, add the following
   library, and sync the new dependencies in Android Studio:

   .. code:: prettyprint

      implementation("androidx.lifecycle:lifecycle-viewmodel-compose:{latest_version}")

   Use version `2.6.2 <https://developer.android.google.cn/jetpack/androidx/releases/lifecycle#2.6.2>`__
   when working with Android Studio Giraffe. Else check the latest version of the library
   `here <https://developer.android.google.cn/jetpack/androidx/releases/lifecycle>`__.

   3. Open the ``WellnessScreen``. Instantiate the ``wellnessViewModel`` ViewModel by
      calling ``viewModel()``, as parameter of the Screen composable, so it can be
      replaced when testing this composable, and hoisted if required. Provide
      ``WellnessTasksList`` with the task list and remove function to the ``onCloseTask``
      lambda.

   .. code:: prettyprint

      import androidx.lifecycle.viewmodel.compose.viewModel

      @Composable
      fun WellnessScreen(
          modifier: Modifier = Modifier, 
          wellnessViewModel: WellnessViewModel = viewModel()
      ) {
         Column(modifier = modifier) {
             StatefulCounter()

             WellnessTasksList(
                 list = wellnessViewModel.tasks,
                 onCloseTask = { task -> wellnessViewModel.remove(task) })
         }
      }

   ``viewModel()`` returns an existing ``ViewModel`` or creates a new one in the given
   scope. The ViewModel instance is retained as long as the scope is alive. For example,
   if the composable is used in an activity, ``viewModel()`` returns the same instance
   until the activity is finished or the process is killed.

   And that's it! You've integrated the ViewModel with part of the state and business
   logic with your screen. Since the state is kept outside of the Composition and stored
   by the ViewModel, mutations to the list survive configuration changes.

   ViewModel won't automatically persist the state of the app in any scenario (for
   example, for system-initiated process death). For detailed information about
   `persisting your app's UI state <https://developer.android.google.cn/topic/libraries/architecture/saving-states>`__
   check the documentation.

   ViewModels are recommended to be used at screen-level composables, that is, close to a
   root composable called from an activity, fragment, or destination of a Navigation
   graph. ViewModels should never be passed down to other composables, instead you should
   pass only the data they need and functions that perform the required logic as
   parameters.

   Check the `ViewModel and state holders section <https://developer.android.google.cn/jetpack/compose/state#viewmodels-source-of-truth>`__
   and our `Compose and other libraries <https://developer.android.google.cn/jetpack/compose/libraries#viewmodel>`__
   documentation to learn more.


Migrate the checked state


   The last refactor is to migrate the checked state and logic to the ViewModel. This way
   the code is simpler and more testable, with all state managed by the ViewModel.

   1. First, modify the ``WellnessTask`` model class so that it's able to store the
      checked state and set false as default value.

   .. code:: prettyprint

      data class WellnessTask(val id: Int, val label: String, var checked: Boolean = false)

   2. In the ViewModel, implement a method ``changeTaskChecked`` that receives a task to
      modify with a new value for the checked state.

   .. code:: prettyprint

      class WellnessViewModel : ViewModel() {
         ...
         fun changeTaskChecked(item: WellnessTask, checked: Boolean) =
             _tasks.find { it.id == item.id }?.let { task ->
                 task.checked = checked
             }
      }

   3. In ``WellnessScreen``, provide the behavior for the list's ``onCheckedTask`` by
      calling the ViewModel's ``changeTaskChecked`` method. The functions should now look
      like this:

   .. code:: prettyprint

      @Composable
      fun WellnessScreen(
          modifier: Modifier = Modifier, 
          wellnessViewModel: WellnessViewModel = viewModel()
      ) {
         Column(modifier = modifier) {
             StatefulCounter()

             WellnessTasksList(
                 list = wellnessViewModel.tasks,
                 onCheckedTask = { task, checked ->
                     wellnessViewModel.changeTaskChecked(task, checked)
                 },
                 onCloseTask = { task ->
                     wellnessViewModel.remove(task)
                 }
             )
         }
      }

   **Warning:** It is a bad practice to pass down ``ViewModel`` instances to other
   composables. You should pass only the data they need and functions that perform the
   required logic as parameters. See the `Integrating Compose with your existing app architecture <https://developer.android.google.cn/jetpack/compose/interop/compose-in-existing-arch#viewmodel>`__
   page for more information.

   4. Open ``WellnessTasksList`` and add the ``onCheckedTask`` lambda function parameter
      so that you can pass it down to the ``WellnessTaskItem.``

   .. code:: prettyprint

      @Composable
      fun WellnessTasksList(
         list: List<WellnessTask>,
         onCheckedTask: (WellnessTask, Boolean) -> Unit,
         onCloseTask: (WellnessTask) -> Unit,
         modifier: Modifier = Modifier
      ) {
         LazyColumn(
             modifier = modifier
         ) {
             items(
                 items = list,
                 key = { task -> task.id }
             ) { task ->
                 WellnessTaskItem(
                     taskName = task.label,
                     checked = task.checked,
                     onCheckedChange = { checked -> onCheckedTask(task, checked) },
                     onClose = { onCloseTask(task) }
                 )
             }
         }
      }

   5. Clean up ``WellnessTaskItem.kt`` file. We no longer need a stateful method, as the
      CheckBox state will be hoisted to the List level. The file only has this composable
      function:

   .. code:: prettyprint

      @Composable
      fun WellnessTaskItem(
         taskName: String,
         checked: Boolean,
         onCheckedChange: (Boolean) -> Unit,
         onClose: () -> Unit,
         modifier: Modifier = Modifier
      ) {
         Row(
             modifier = modifier, verticalAlignment = Alignment.CenterVertically
         ) {
             Text(
                 modifier = Modifier
                     .weight(1f)
                     .padding(start = 16.dp),
                 text = taskName
             )
             Checkbox(
                 checked = checked,
                 onCheckedChange = onCheckedChange
             )
             IconButton(onClick = onClose) {
                 Icon(Icons.Filled.Close, contentDescription = "Close")
             }
         }
      }

   6. Run the app and try to check any task. Notice that checking any task doesn't quite
      work yet.

   |1d08ebcade1b9302.gif|

   This is because what Compose is tracking for the ``MutableList`` are changes related to
   adding and removing elements. This is why deleting works. But it's unaware of changes
   in the row item values (``checkedState`` in our case), unless you tell it to track them
   too.

   There are two ways to fix this:

   -  Change our data class ``WellnessTask`` so that ``checkedState`` becomes
      ``MutableState<Boolean>`` instead of ``Boolean``, which causes Compose to track an
      item change.
   -  Copy the item you're about to mutate, remove the item from your list and re-add the
      mutated item to the list, which causes Compose to track that list change.

   There are pros and cons to both approaches. For example, depending on your
   implementation of the list you're using, removing and reading the element might be
   costly.

   So let's say, you want to avoid potentially expensive list operations, and make
   ``checkedState`` observable as it's more efficient and Compose-idiomatic.

   Your new ``WellnessTask`` could look like this:

   .. code:: prettyprint

      import androidx.compose.runtime.MutableState
      import androidx.compose.runtime.mutableStateOf

      data class WellnessTask(val id: Int, val label: String, val checked: MutableState<Boolean> = mutableStateOf(false))

   As you saw before, you can use delegated properties, which results in a simpler usage
   of the variable ``checked`` for this case.

   Change ``WellnessTask`` to be a class instead of a data class. Make ``WellnessTask``
   receive an ``initialChecked`` variable with default value ``false`` in the constructor,
   then we can initialize the ``checked`` variable with the factory method
   ``mutableStateOf`` and taking ``initialChecked`` as default value.

   .. code:: prettyprint

      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.mutableStateOf
      import androidx.compose.runtime.setValue

      class WellnessTask(
          val id: Int,
          val label: String,
          initialChecked: Boolean = false
      ) {
          var checked by mutableStateOf(initialChecked)
      }

   That's it! This solution works, and all changes survive recomposition and configuration
   changes!

   |e7cc030cd7e8b66f.gif|


Testing


   Now that the business logic is refactored into the ViewModel instead of coupled inside
   composable functions, unit testing is much simpler.

   You can use instrumented testing to verify the correct behavior of your Compose code
   and that UI state is working properly. Consider taking the codelab `Testing in Compose <https://developer.android.google.cn/codelabs/jetpack-compose-testing#0>`__ 
   to learn how to test your Compose UI.


13. Congratulations
-------------------


   Good job! You've successfully completed this codelab and learned all the basic APIs to
   work with state in a Jetpack Compose app!

   You learned how to think about state and events to extract stateless composables in
   Compose, and how Compose uses state updates to drive change in the UI.


What's next?


   Check out the other codelabs on the `Compose pathway <https://developer.android.google.cn/courses/pathways/compose>`__.

   -  `Sample apps <https://github.com/android/compose-samples/>`__
   -  `JetNews <https://github.com/android/compose-samples/tree/master/JetNews>`__
      demonstrates the best practices explained in this codelab.


More documentation


   -  `Thinking in Compose <https://developer.android.google.cn/jetpack/compose/mental-model>`__
   -  `State and Jetpack Compose <https://developer.android.google.cn/jetpack/compose/state>`__
   -  `Unidirectional data flow in Jetpack Compose <https://developer.android.google.cn/jetpack/compose/architecture#udf-compose>`__
   -  `Restoring state in Compose <https://developer.android.google.cn/jetpack/compose/state#restore-ui-state>`__
   -  `ViewModel Overview <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__
   -  `Compose and other libraries <https://developer.android.google.cn/jetpack/compose/libraries>`__


Reference APIs


   -  `remember <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary.html#remember(kotlin.Function0)>`__
   -  `rememberSaveable <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/package-summary#rememberSaveable(kotlin.Array,androidx.compose.runtime.saveable.Saver,kotlin.String,kotlin.Function0)>`__
   -  `State <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/State>`__
   -  `MutableState <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/MutableState>`__
   -  `SnapshotStateList <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/snapshots/SnapshotStateList>`__
   -  `ViewModel <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__

.. |775940a48311302b.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/775940a48311302b.png
.. |New project| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/new_project.jpg
.. |7ed1e6fbd94bff04.jpeg| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/7ed1e6fbd94bff04.jpeg
.. |f415ca9336d83142.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/f415ca9336d83142.png
.. |e4dfc3bef967e0a1.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/e4dfc3bef967e0a1.gif
.. |a9d78ead2c8362b6.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/a9d78ead2c8362b6.gif
.. |7d3509d136280b6c.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/7d3509d136280b6c.png
.. |677bc0a178670de8.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/677bc0a178670de8.png
.. |1f8e05f6497ec35f.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/1f8e05f6497ec35f.png
.. |1a8f4095e384ba01.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/1a8f4095e384ba01.gif
.. |6e8b72a529e8dedd.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/6e8b72a529e8dedd.png
.. |8a849818f7721489.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/8a849818f7721489.png
.. |Tree of components diagram, showing the app's initial state, count is 0| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/d9d6eeaf6367f404.png
.. |Tree of components diagram, showing state change, when Add one button is clicked, Text with tip appears and Text with glasses count appears.| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/aca69b72c6518a5b.png
.. |865af0485f205c28.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/865af0485f205c28.png
.. |Tree of components diagram, showing that when close button is clicked, the task composable disappears.| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/e107acccb48c499c.png
.. |82b5dadce9cca927.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/82b5dadce9cca927.png
.. |6223c8c6f4e3bb1f.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/6223c8c6f4e3bb1f.png
.. |34c7d0b6ba09ec91.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/34c7d0b6ba09ec91.png
.. |ae993e6ddc0d654a.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/ae993e6ddc0d654a.png
.. |55ae5538c40546f5.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/55ae5538c40546f5.png
.. |d9d6eeaf6367f404.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/d9d6eeaf6367f404.png
.. |7624eed0848a145c.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/7624eed0848a145c.png
.. |2c1134ad78e4b68a.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/2c1134ad78e4b68a.gif
.. |bf2e1634eff47697.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/bf2e1634eff47697.gif
.. |8211bd9e0a4c5db2.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/8211bd9e0a4c5db2.png
.. |2cb0dcdbe75dcfbf.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/2cb0dcdbe75dcfbf.png
.. |7fe6ee3d2886abd0.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/7fe6ee3d2886abd0.png
.. |a0f8724cfd33cb10.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/a0f8724cfd33cb10.png
.. |f9cbc49c960fd24c.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/f9cbc49c960fd24c.gif
.. |a68b5473354d92df.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/a68b5473354d92df.gif
.. |85796fb49cf5dd16.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/85796fb49cf5dd16.gif
.. |47f4a64c7e9a5083.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/47f4a64c7e9a5083.png
.. |1d08ebcade1b9302.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/1d08ebcade1b9302.gif
.. |e7cc030cd7e8b66f.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-state/img/e7cc030cd7e8b66f.gif


ğŸš€ Migrating to Jetpack Compose
================================

https://developer.android.google.cn/codelabs/jetpack-compose-migration?hl=en


1. Introduction
---------------


   Compose and the View system can work together side by side.

   In this codelab, you'll be migrating parts of the
   `Sunflower <https://github.com/android/sunflower/tree/views>`__'s plant details screen
   to Compose. We created a copy of the project for you to try out migrating a realistic
   app to Compose.

   By the end of the codelab, you'll be able to continue with the migration and convert
   the rest of Sunflower's screens if you wish.

   For more support as you're walking through this codelab, check out the following
   code-along:


What you will learn

   In this codelab, you will learn:

   -  The different migration paths you can follow
   -  How to incrementally migrate an app to Compose
   -  How to add Compose to an existing screen built using Views
   -  How to use a View from inside Compose
   -  How you can create a theme in Compose
   -  How to test a mixed screen written in both Views and Compose


Prerequisites

   -  Experience with Kotlin syntax, including lambdas
   -  Knowing the `basics of Compose <https://codelabs.developers.google.cn/codelabs/jetpack-compose-basics/#0>`__


What you will need

   -  `Latest Android Studio <https://developer.android.google.cn/studio>`__


2. Migration strategy
---------------------


   Jetpack Compose was designed with View interoperability right from the start. To
   migrate to Compose, we recommend an incremental migration where Compose and View
   co-exist in your codebase until your app is fully in Compose.

   The recommended `migration strategy <https://developer.android.google.cn/jetpack/compose/interop/migration-strategy>`__
   is this:

   1. Build new screens with Compose
   2. As you're building features, identify reusable elements and start to create a
      library of common UI components
   3. Replace existing features one screen at a time


Build new screens with Compose

   Using Compose to build new features that encompass an entire screen is the best way to
   drive your adoption of Compose. With this strategy, you can add features and take
   advantage of the benefits of Compose while still catering to your company's business
   needs

   A new feature might encompass an entire screen, in which case the entire screen would
   be in Compose. If you are using Fragment-based navigation, that means you would create
   a new Fragment and have its contents in Compose.

   You can also introduce new features in an existing screen. In this case, Views and
   Compose will coexist on the same screen. For example, say the feature you are adding is
   a new view type in a RecyclerView. In that case, the new view type would be in Compose
   while keeping the other items the same.


Build a library of common UI components

   As you're building features with Compose, you'll quickly realize that you end up
   building a library of components. You'll want to identify reusable components to
   promote reuse across your app so that shared components have a single source of truth.
   New features you build can then depend on this library.


Replace existing features with Compose

   In addition to building new features, you'll want to gradually migrate existing
   features in your app to Compose. How you approach this is up to you, but here are a few
   good candidates:

   1. Simple screens - simple screens in your app with few UI elements and dynamicity such
      as a welcome screen, a confirmation screen, or a settings screen. These are good
      candidates for migrating to Compose as it can be done with few lines of code.
   2. Mixed View and Compose screens - screens that already contain a bit of Compose code
      are another good candidate as you can continue to migrate elements in that screen
      piece-by-piece. If you have a screen with only a subtree in Compose, you can
      continue migrating other parts of the tree until the entire UI is in Compose. This
      is called the *bottom-up* approach of migration.

   |Bottom-up approach of migrating a mixed Views and Compose UI to Compose|


The approach in this Codelab

   In this codelab, you'll be doing an incremental migration to Compose of the Sunflower's
   plant details screen having Compose and Views working together. After that, you'll know
   enough to continue with the migration if you wish.


3. Getting set up
-----------------



Get the code

   Get the codelab code from GitHub:

   ::

      $ git clone https://github.com/android/codelab-android-compose

   Alternatively you can download the repository as a Zip file:

   `Download Zip <https://github.com/android/codelab-android-compose/archive/main.zip>`__


Running the sample app

   The code you just downloaded contains code for all Compose codelabs available. To
   complete this codelab, open the **``MigrationCodelab``** project inside Android Studio.

   In this codelab, you're going to migrate
   `Sunflower <https://github.com/android/sunflower/tree/views>`__'s plant details screen
   to Compose. You can open the plant details screen by tapping in one of the plants
   available in the plant list screen.

   **Note:** The ``main`` branch of Sunflower already has parts of the app in Compose. For
   this exercise, we will be referencing the ``views`` branch which is the original
   implementation of the app.

   |9b53216a27f911f2.png|


Project setup

   The project is built in multiple git branches:

   -  The ``main`` branch is the codelab's starting point.
   -  The ``end`` contains the solution to this codelab.

   We recommend that you start with the code in the ``main`` branch and follow the codelab
   step-by-step at your own pace.

   During the codelab, you'll be presented with snippets of code that you'll need to add
   to the project. In some places, you'll also need to remove code that is explicitly
   mentioned in comments on the code snippets.

   To get the ``end`` branch using git, ``cd`` into the directory of the
   **``MigrationCodelab``** project followed by using the command:

   ::

      $ git checkout end

   Or download the solution code from here:

   `Download the final code <https://github.com/android/codelab-android-compose/archive/end.zip>`__


Frequently asked questions

   -  `How do I install Android Studio? <https://developer.android.google.cn/studio/install>`__
   -  `How do I set up a device for development? <http://developer.android.google.cn/tools/device.html>`__


4. Compose in Sunflower
-----------------------


   Compose is already added to the code you downloaded from the ``main`` branch. However,
   let's take a look at what's required to have it working.

   If you open the app-level ``build.gradle`` file, see how it imports the Compose
   dependencies and enables Android Studio to work with Compose by using the
   ``buildFeatures { compose true }`` flag.


app/build.gradle

   .. code:: prettyprint

      android {
          //...
          kotlinOptions {
              jvmTarget = '1.8'
          }
          buildFeatures {
              //...
              compose true
          }
          composeOptions {
              kotlinCompilerExtensionVersion '1.3.2'
          }
      }

      dependencies {
          //...
          // Compose
          def composeBom = platform('androidx.compose:compose-bom:2022.10.00')
          implementation(composeBom)
          androidTestImplementation(composeBom)

          implementation "androidx.compose.runtime:runtime"
          implementation "androidx.compose.ui:ui"
          implementation "androidx.compose.foundation:foundation"
          implementation "androidx.compose.foundation:foundation-layout"
          implementation "androidx.compose.material:material"
          implementation "androidx.compose.runtime:runtime-livedata"
          implementation "androidx.compose.ui:ui-tooling"
          //...
      }

   The version of those dependencies are defined in the project-level ``build.gradle``
   file.


5. Hello Compose!
-----------------


   In the plant details screen, we'll migrate the description of the plant to Compose
   while leaving the overall structure of the screen intact.

   Compose needs a host Activity or Fragment in order to render UI. In Sunflower, as all
   screens use fragments, you'll be using `ComposeView <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/platform/ComposeView>`__:
   an Android View that can host Compose UI content using its ``setContent`` method.


Removing XML code

   Let's start with the migration! Open ``fragment_plant_detail.xml`` and do the
   following:

   1. Switch to the Code view
   2. Remove the ``ConstraintLayout`` code and 4 nested ``TextView``\ s inside the
      ``NestedScrollView`` (the codelab will compare and reference the XML code when
      migrating individual items, having the code commented out will be useful)
   3. Add a ``ComposeView`` that will host Compose code instead with ``compose_view`` as
      view id


fragment_plant_detail.xml

   .. code:: prettyprint

      <androidx.core.widget.NestedScrollView
          android:id="@+id/plant_detail_scrollview"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:clipToPadding="false"
          android:paddingBottom="@dimen/fab_bottom_padding"
          app:layout_behavior="@string/appbar_scrolling_view_behavior">

          <!-- Step 2) Comment out ConstraintLayout and its children â€“->
          <androidx.constraintlayout.widget.ConstraintLayout
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:layout_margin="@dimen/margin_normal">

              <TextView
                  android:id="@+id/plant_detail_name"
              ...
          
          </androidx.constraintlayout.widget.ConstraintLayout>
          <!-- End Step 2) Comment out until here â€“->

          <!-- Step 3) Add a ComposeView to host Compose code â€“->
          <androidx.compose.ui.platform.ComposeView
              android:id="@+id/compose_view"
              android:layout_width="match_parent"
              android:layout_height="match_parent"/>

      </androidx.core.widget.NestedScrollView>


Adding Compose code

   At this point, you are ready to start migrating the plant details screen to Compose!

   Throughout the codelab, you'll be adding Compose code to the
   ``PlantDetailDescription.kt`` file under the ``plantdetail`` folder. Open it and see
   how we have a placeholder ``"Hello Compose"`` text already available in the project.


PlantDetailDescription.kt

   .. code:: prettyprint

      @Composable
      fun PlantDetailDescription() {
          Surface {
              Text("Hello Compose")
          }  
      }

   Let's display this on the screen by calling this composable from the ``ComposeView`` we
   added in the previous step. Open ``PlantDetailFragment.kt``.

   As the screen is using `data binding <https://developer.android.google.cn/topic/libraries/data-binding>`__, 
   you can directly access the ``composeView`` and call ``setContent`` to display Compose code on
   the screen. Call the ``PlantDetailDescription`` composable inside ``MaterialTheme`` as
   Sunflower uses material design.


PlantDetailFragment.kt

   .. code:: prettyprint

      class PlantDetailFragment : Fragment() {
          // ...
          override fun onCreateView(...): View? {
              val binding = DataBindingUtil.inflate<FragmentPlantDetailBinding>(
                  inflater, R.layout.fragment_plant_detail, container, false
              ).apply {
                  // ...
                  composeView.setContent {
                      // You're in Compose world!
                      MaterialTheme {
                          PlantDetailDescription()
                      }
                  }
              }
              // ...
          }
      }

   **Note:** Sunflower uses Material design for colors, typography and shapes. To apply
   Material theming to composables, you'll need to use the ``MaterialTheme`` composable
   which provides default values. However, you could also use your own design system if
   you wanted to. See `Design systems in Compose <https://developer.android.google.cn/jetpack/compose/designsystems>`__ 
   for more information.

   If you run the app, you can see "``Hello Compose``" displayed on the screen.

   |a3be172fdfe6efcb.png|


6. Creating a Composable out of XML
-----------------------------------


   Let's start by migrating the name of the plant. More exactly, the ``TextView`` with id
   ``@+id/plant_detail_name`` you removed in ``fragment_plant_detail.xml``. Here's the XML
   code:

   .. code:: prettyprint

      <TextView
          android:id="@+id/plant_detail_name"
          ...
          android:layout_marginStart="@dimen/margin_small"
          android:layout_marginEnd="@dimen/margin_small"
          android:gravity="center_horizontal"
          android:text="@{viewModel.plant.name}"
          android:textAppearance="?attr/textAppearanceHeadline5"
          ... />

   See how it has a ``textAppearanceHeadline5`` style, has a horizontal margin of ``8.dp``
   and it's centered horizontally on the screen. However, the title to be displayed is
   observed from a ``LiveData`` exposed by ``PlantDetailViewModel`` that comes from the
   repository layer.

   As observing a ``LiveData`` is covered later, let's assume we have the name available
   and is passed as a parameter to a *new* ``PlantName`` composable that we create in the
   ``PlantDetailDescription.kt`` file. This composable will be called from the
   ``PlantDetailDescription`` composable later.


PlantDetailDescription.kt

   .. code:: prettyprint

      @Composable
      private fun PlantName(name: String) {
          Text(
              text = name,
              style = MaterialTheme.typography.h5,
              modifier = Modifier
                  .fillMaxWidth()
                  .padding(horizontal = dimensionResource(R.dimen.margin_small))
                  .wrapContentWidth(Alignment.CenterHorizontally)
          )
      }

      @Preview
      @Composable
      private fun PlantNamePreview() {
          MaterialTheme {
              PlantName("Apple")
          }
      }

   With preview:

   |db91b149ddbc3613.png|

   **Note:** To avoid having to deploy changes to an emulator every time you want to see
   code changes, you can make use of the Android Studio Composable `preview <https://developer.android.google.cn/jetpack/compose/tooling#preview-features>`__
   feature.

   Where:

   -  ``Text``'s style is ``MaterialTheme.typography.h5`` which is similar to
      ``textAppearanceHeadline5`` from the XML code.
   -  The modifiers decorate the Text to make it look like the XML version:
   -  The ``fillMaxWidth`` modifier is used so that it occupies the maximum amount of
      width available. This modifier corresponds to the ``match_parent`` value of the
      ``layout_width`` attribute in XML code.
   -  The ``padding`` modifier is used so that a horizontal padding value of
      ``margin_small`` is applied. This corresponds to the ``marginStart`` and
      ``marginEnd`` declaration in XML. The ``margin_small`` value is also the existing
      dimension resource which is fetched using the ``dimensionResource`` helper function.
   -  The ``wrapContentWidth`` modifier is used to align the text so that it is centered
      horizontally. This is similar to having a ``gravity`` of ``center_horizontal`` in
      XML.

   **Note:** Compose provides convenient methods to get values from the ``dimens.xml`` and
   ``strings.xml`` files, namely: ``dimensionResource(id)`` and ``stringResource(id)``.

   With this, you have the View system as the source of truth.


7. ViewModels and LiveData
--------------------------


   Now, let's wire up the title to the screen. To do that, you'll need to load the data
   using the ``PlantDetailViewModel``. For that, Compose comes with integrations for
   `ViewModel <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__
   and `LiveData <https://developer.android.google.cn/topic/libraries/architecture/livedata>`__.


ViewModels

   As an instance of the ``PlantDetailViewModel`` is used in the Fragment, we could pass
   it as a parameter to ``PlantDetailDescription`` and that'd be it.

   **Note:** In a production app, a ``ViewModel`` should only be referenced by a
   screen-level composable. If child composables need data from a ``ViewModel``, it is
   best practice to only pass data that child composables need rather than the whole
   ViewModel. See `Screen UI state <https://developer.android.google.cn/jetpack/compose/state-hoisting#screen-ui>`__
   for more information.

   Composables don't have their own ViewModel instances, the same instance is shared
   between the composables and the lifecycle owner that hosts that Compose code (either
   Activity or Fragment).

   Open the ``PlantDetailDescription.kt`` file and add the ``PlantDetailViewModel``
   parameter to ``PlantDetailDescription``:


PlantDetailDescription.kt

   .. code:: prettyprint

      @Composable
      fun PlantDetailDescription(plantDetailViewModel: PlantDetailViewModel) {
          //...
      }

   Now, pass the instance of the ViewModel when calling this composable from the fragment:


PlantDetailFragment.kt

   .. code:: prettyprint

      class PlantDetailFragment : Fragment() {
          ...
          override fun onCreateView(...): View? {
              ...
              composeView.setContent {
                  MaterialTheme {
                      PlantDetailDescription(plantDetailViewModel)
                  }
              }
          }
      }


LiveData

   With this, you already have access to the ``PlantDetailViewModel``'s
   ``LiveData<Plant>`` field to get the plant's name.

   To observe LiveData from a composable, use the `LiveData.observeAsState() <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/runtime/runtime-livedata/src/main/java/androidx/compose/runtime/livedata/LiveDataAdapter.kt>`__
   function.

   **Note:**
   `LiveData.observeAsState() <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/runtime/runtime-livedata/src/main/java/androidx/compose/runtime/livedata/LiveDataAdapter.kt>`__
   starts observing the LiveData and represents its values as a ``State`` object. Every
   time there would be a new value posted into the LiveData the returned ``State`` will be
   updated causing recomposition of every ``State.value`` usage.

   As values emitted by the LiveData can be ``null``, you'd need to wrap its usage in a
   ``null`` check. Because of that, and for reusability, it's best to split the LiveData
   consumption and listening in different composables. So let's create a new composable
   called ``PlantDetailContent`` that will display ``Plant`` information.

   With these updates, the ``PlantDetailDescription.kt`` file should now look like this:


PlantDetailDescription.kt

   .. code:: prettyprint

      @Composable
      fun PlantDetailDescription(plantDetailViewModel: PlantDetailViewModel) {
          // Observes values coming from the VM's LiveData<Plant> field
          val plant by plantDetailViewModel.plant.observeAsState()

          // If plant is not null, display the content
          plant?.let {
              PlantDetailContent(it)
          }
      }

      @Composable
      fun PlantDetailContent(plant: Plant) {
          PlantName(plant.name)
      }

      @Preview
      @Composable
      private fun PlantDetailContentPreview() {
          val plant = Plant("id", "Apple", "description", 3, 30, "")
          MaterialTheme {
              PlantDetailContent(plant)
          }
      }

   ``PlantNamePreview`` should reflect our change without having to update it directly
   since ``PlantDetailContent`` just calls ``PlantName``:

   |4ae8fb531c2ede85.png|

   Now, you've wired up the ViewModel so that a plant name is displayed in Compose. In the
   next few sections, you'll build the rest of the composables and wire them up to the
   ViewModel in a similar way.


8. More XML code migration
--------------------------


   Now, it's easier to complete what's missing in our UI: the watering info and plant
   description. Following a similar approach as before, you can already migrate the rest
   of the screen.

   The watering info XML code you removed before from ``fragment_plant_detail.xml``
   consists of two TextViews with ids ``plant_watering_header`` and ``plant_watering``.

   .. code:: prettyprint

      <TextView
          android:id="@+id/plant_watering_header"
          ...
          android:layout_marginStart="@dimen/margin_small"
          android:layout_marginTop="@dimen/margin_normal"
          android:layout_marginEnd="@dimen/margin_small"
          android:gravity="center_horizontal"
          android:text="@string/watering_needs_prefix"
          android:textColor="?attr/colorAccent"
          android:textStyle="bold"
          ... />

      <TextView
          android:id="@+id/plant_watering"
          ...
          android:layout_marginStart="@dimen/margin_small"
          android:layout_marginEnd="@dimen/margin_small"
          android:gravity="center_horizontal"
          app:wateringText="@{viewModel.plant.wateringInterval}"
          .../>

   Similar to what you did before, create a new composable called ``PlantWatering`` and
   add ``Text`` composables to display the watering information on the screen:


PlantDetailDescription.kt

   .. code:: prettyprint

      @OptIn(ExperimentalComposeUiApi::class)
      @Composable
      private fun PlantWatering(wateringInterval: Int) {
          Column(Modifier.fillMaxWidth()) {
              // Same modifier used by both Texts
              val centerWithPaddingModifier = Modifier
                  .padding(horizontal = dimensionResource(R.dimen.margin_small))
                  .align(Alignment.CenterHorizontally)

              val normalPadding = dimensionResource(R.dimen.margin_normal)

              Text(
                  text = stringResource(R.string.watering_needs_prefix),
                  color = MaterialTheme.colors.primaryVariant,
                  fontWeight = FontWeight.Bold,
                  modifier = centerWithPaddingModifier.padding(top = normalPadding)
              )

              val wateringIntervalText = pluralStringResource(
                  R.plurals.watering_needs_suffix, wateringInterval, wateringInterval
              )
              Text(
                  text = wateringIntervalText,
                  modifier = centerWithPaddingModifier.padding(bottom = normalPadding)
              )
          }
      }

      @Preview
      @Composable
      private fun PlantWateringPreview() {
          MaterialTheme {
              PlantWatering(7)
          }
      }

   With preview:

   |e506690d1024be88.png|

   Some things to notice:

   -  As the horizontal padding and align decoration is shared by the ``Text``
      composables, you can reuse the Modifier by assigning it to a local variable (i.e.
      ``centerWithPaddingModifier``). Since modifiers are regular Kotlin objects, you can
      do that.
   -  Compose's ``MaterialTheme`` doesn't have an exact match to the ``colorAccent`` used
      in ``plant_watering_header``. For now, let's use
      ``MaterialTheme.colors.primaryVariant`` that you'll improve in the interop theming
      section.
   -  In Compose 1. 2.1, using ``pluralStringResource`` requires opting in to
      ``ExperimentalComposeUiApi``. In a future version of Compose this may no longer be
      needed.

   Let's connect all the pieces together and call ``PlantWatering`` from the
   ``PlantDetailContent`` as well. The ConstraintLayout XML code we removed at the
   beginning had a margin of ``16.dp`` that we need to include in our Compose code.

   .. code:: prettyprint

      <androidx.constraintlayout.widget.ConstraintLayout
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:layout_margin="@dimen/margin_normal">

   In ``PlantDetailContent``, create a ``Column`` to display the name and watering info
   together and have that as padding. Also, so that the background color and the text
   colors used are appropriate, add a ``Surface`` that will handle that.


PlantDetailDescription.kt

   .. code:: prettyprint

      @Composable
      fun PlantDetailContent(plant: Plant) {
          Surface {
              Column(Modifier.padding(dimensionResource(R.dimen.margin_normal))) {
                  PlantName(plant.name)
                  PlantWatering(plant.wateringInterval)
              }
          }
      }

   If you refresh the preview, you'll see this:

   |311e08a065f58cd3.png|


9. Views in Compose code
------------------------


   Now, let's migrate the plant description. The code in ``fragment_plant_detail.xml`` had
   a ``TextView`` with ``app:renderHtml="@{viewModel.plant.description}"`` to tell the XML
   what text to display on the screen. ``renderHtml`` is a binding adapter that you can
   find in the ``PlantDetailBindingAdapters.kt`` file. The implementation uses
   ``HtmlCompat.fromHtml`` to set the text on the ``TextView``!

   However, Compose doesn't have support for ``Spanned`` classes nor displaying HTML
   formatted text at the moment. Thus, we need to use a ``TextView`` from the View system
   in the Compose code to bypass this limitation.

   As Compose is not able to render HTML code yet, you'll create a ``TextView``
   programmatically to do exactly that using the `AndroidView <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/viewinterop/package-summary#AndroidView(kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Function1)>`__
   API.

   ``AndroidView`` allows you to construct a ``View`` in its ``factory`` lambda. It also
   provides an ``update`` lambda which gets invoked when the View has been inflated and on
   subsequent recompositions.

   **Note:** ``AndroidView`` allows you to create a View programmatically. In case you
   want to inflate a View from an XML file, you can do it using `view binding <https://developer.android.google.cn/topic/libraries/view-binding>`__ 
   with the ``AndroidViewBinding`` API from the ``androidx.compose.ui:ui-viewbinding`` library.

   Let's do this by creating a new ``PlantDescription`` composable. This composable calls
   ``AndroidView`` which constructs a ``TextView`` in its ``factory`` lambda. In the
   ``factory`` lambda, initialize a ``TextView`` that displays HTML formatted text
   followed by setting the ``movementMethod`` to an instance of ``LinkMovementMethod``.
   Finally, in the ``update`` lambda set the text of the ``TextView`` to be
   ``htmlDescription``.


PlantDetailDescription.kt

   .. code:: prettyprint

      @Composable
      private fun PlantDescription(description: String) {
          // Remembers the HTML formatted description. Re-executes on a new description
          val htmlDescription = remember(description) {
              HtmlCompat.fromHtml(description, HtmlCompat.FROM_HTML_MODE_COMPACT)
          }

          // Displays the TextView on the screen and updates with the HTML description when inflated
          // Updates to htmlDescription will make AndroidView recompose and update the text
          AndroidView(
              factory = { context ->
                  TextView(context).apply {
                      movementMethod = LinkMovementMethod.getInstance()
                  }
              },
              update = {
                  it.text = htmlDescription
              }
          )
      }

      @Preview
      @Composable
      private fun PlantDescriptionPreview() {
          MaterialTheme {
              PlantDescription("HTML<br><br>description")
          }
      }

   Preview:

   |12928a361edc390e.png|

   Notice that ``htmlDescription`` remembers the HTML description for a given
   ``description`` passed as a parameter. If the ``description`` parameter changes, the
   ``htmlDescription`` code inside ``remember`` will execute again.

   As a result, the ``AndroidView`` update callback will recompose if ``htmlDescription``
   changes. Any state read inside the ``update`` lambda causes a recomposition.

   Let's add ``PlantDescription`` to the ``PlantDetailContent`` composable and change
   preview code to display a HTML description too:


PlantDetailDescription.kt

   .. code:: prettyprint

      @Composable
      fun PlantDetailContent(plant: Plant) {
          Surface {
              Column(Modifier.padding(dimensionResource(R.dimen.margin_normal))) {
                  PlantName(plant.name)
                  PlantWatering(plant.wateringInterval)
                  PlantDescription(plant.description)
              }
          }
      }

      @Preview
      @Composable
      private fun PlantDetailContentPreview() {
          val plant = Plant("id", "Apple", "HTML<br><br>description", 3, 30, "")
          MaterialTheme {
              PlantDetailContent(plant)
          }
      }

   With preview:

   |38f43bf79290a9d7.png|

   At this point, you've migrated all the content inside the original ``ConstraintLayout``
   to Compose. You can run the app to check that it's working as expected.

   |c7021c18eb8b4d4e.gif|


10. ViewCompositionStrategy
---------------------------


   Compose disposes of `the Composition <https://developer.android.google.cn/jetpack/compose/lifecycle>`__ 
   whenever the ``ComposeView`` becomes detached from a window. This is undesirable when
   ``ComposeView`` is used in fragments for 2 reasons:

   -  The Composition must follow the `fragment's view lifecycle <https://developer.android.google.cn/reference/kotlin/androidx/fragment/app/Fragment.html#getviewlifecycleowner>`__
      for Compose UI ``View`` types to save state.
   -  When transitions happen, the underlying ``ComposeView`` will be at a detached state.
      However, Compose UI elements will still be visible during these transitions.

   To modify this behavior, call `setViewCompositionStrategy <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/platform/AbstractComposeView#setViewCompositionStrategy(androidx.compose.ui.platform.ViewCompositionStrategy)>`__
   with the appropriate ``ViewCompositionStrategy`` so it follows the fragment's view
   lifecycle instead. Specifically, you'll want to use the `DisposeOnViewTreeLifecycleDestroyed <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/platform/ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed>`__
   strategy to dispose of the Composition when the ``LifecycleOwner`` of the fragment is
   destroyed.

   As ``PlantDetailFragment`` has enter and exit transitions (check ``nav_garden.xml`` for
   more info), and we'll use ``View`` types inside Compose later, we need to make sure the
   ``ComposeView`` uses the ``DisposeOnViewTreeLifecycleDestroyed`` strategy. Nonetheless,
   it's `best practice <https://developer.android.google.cn/jetpack/compose/interop/interop-apis#composition-strategy>`__
   to always set this strategy when using ``ComposeView`` in fragments.


PlantDetailFragment.kt

   .. code:: prettyprint

      import androidx.compose.ui.platform.ViewCompositionStrategy
      ...

      class PlantDetailFragment : Fragment() {
          ...
          override fun onCreateView(...): View? {
              val binding = DataBindingUtil.inflate<FragmentPlantDetailBinding>(
                  inflater, R.layout.fragment_plant_detail, container, false
              ).apply {
                  ...
                  composeView.apply {
                      // Dispose the Composition when the view's LifecycleOwner
                      // is destroyed
                      setViewCompositionStrategy(
                          ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed
                      )
                      setContent {
                          MaterialTheme {
                              PlantDetailDescription(plantDetailViewModel)
                          }
                      }
                  }
              }
              ...
          }
      }


11. Material theming
--------------------


   We have the text content of plant details migrated to Compose. However, you might have
   noticed that Compose is not using the right theme colors. It's using purple in the
   plant name when it should be using green.

   To use the correct theme colors, you'll need to customize the ``MaterialTheme`` by
   defining your own theme and providing your theme's colors.

   **Note:** This codelab uses Material 2. However, we recommend that you use the latest
   version of Material â€” `Material 3 <https://developer.android.google.cn/jetpack/compose/designsystems/material3>`__
   â€” instead.


Customizing ``MaterialTheme``

   To create your own theme, open the ``Theme.kt`` file under the ``theme`` package.
   ``Theme.kt`` defines a composable called ``SunflowerTheme`` which accepts a content
   lambda and passes it down to a ``MaterialTheme``.

   It doesn't do anything interesting yetâ€”you'll customize that next.


Theme.kt

   .. code:: prettyprint

      import androidx.compose.material.MaterialTheme
      import androidx.compose.runtime.Composable

      @Composable
      fun SunflowerTheme(
          content: @Composable () -> Unit
      ) {
          MaterialTheme(content = content)
      }

   ``MaterialTheme`` allows you to customize its colors, typography and shapes. For now,
   go ahead and customize the colors by providing the same colors in the Sunflower View's
   theme. The ``SunflowerTheme`` can also accept a boolean parameter called ``darkTheme``
   which will default to ``true`` if the system is in dark mode, otherwise, ``false``.
   Using this parameter, we can pass the right color values to ``MaterialTheme`` to match
   the currently set system theme.


Theme.kt

   .. code:: prettyprint

      @Composable
      fun SunflowerTheme(
          darkTheme: Boolean = isSystemInDarkTheme(),
          content: @Composable () -> Unit
      ) {
          val lightColors  = lightColors(
              primary = colorResource(id = R.color.sunflower_green_500),
              primaryVariant = colorResource(id = R.color.sunflower_green_700),
              secondary = colorResource(id = R.color.sunflower_yellow_500),
              background = colorResource(id = R.color.sunflower_green_500),
              onPrimary = colorResource(id = R.color.sunflower_black),
              onSecondary = colorResource(id = R.color.sunflower_black),
          )
          val darkColors  = darkColors(
              primary = colorResource(id = R.color.sunflower_green_100),
              primaryVariant = colorResource(id = R.color.sunflower_green_200),
              secondary = colorResource(id = R.color.sunflower_yellow_300),
              onPrimary = colorResource(id = R.color.sunflower_black),
              onSecondary = colorResource(id = R.color.sunflower_black),
              onBackground = colorResource(id = R.color.sunflower_black),
              surface = colorResource(id = R.color.sunflower_green_100_8pc_over_surface),
              onSurface = colorResource(id = R.color.sunflower_white),
          )
          val colors = if (darkTheme) darkColors else lightColors
          MaterialTheme(
              colors = colors,
              content = content
          )
      }

   To use this, replace ``MaterialTheme`` uses for ``SunflowerTheme``. For example, in
   ``PlantDetailFragment``:


PlantDetailFragment.kt

   .. code:: prettyprint

      class PlantDetailFragment : Fragment() {
          ...
          composeView.apply {
              ...
              setContent {
                  SunflowerTheme {
                      PlantDetailDescription(plantDetailViewModel)
                  }
              }
          }
      }

   And all the preview composables in the ``PlantDetailDescription.kt`` file:


PlantDetailDescription.kt

   .. code:: prettyprint

      @Preview
      @Composable
      private fun PlantDetailContentPreview() {
          val plant = Plant("id", "Apple", "HTML<br><br>description", 3, 30, "")
          SunflowerTheme {
              PlantDetailContent(plant)
          }
      }

      @Preview
      @Composable
      private fun PlantNamePreview() {
          SunflowerTheme {
              PlantName("Apple")
          }
      }

      @Preview
      @Composable
      private fun PlantWateringPreview() {
          SunflowerTheme {
              PlantWatering(7)
          }
      }

      @Preview
      @Composable
      private fun PlantDescriptionPreview() {
          SunflowerTheme {
              PlantDescription("HTML<br><br>description")
          }
      }

   As you can see in the preview, the colors should now match the Sunflower theme's
   colors.

   |9b0953b7bb00a63d.png|

   You can also preview the UI in dark theme by creating a new function and passing
   ``Configuration.UI_MODE_NIGHT_YES`` to the ``uiMode`` of the preview:

   .. code:: prettyprint

      import android.content.res.Configuration
      ...

      @Preview(uiMode = Configuration.UI_MODE_NIGHT_YES)
      @Composable
      private fun PlantDetailContentDarkPreview() {
          val plant = Plant("id", "Apple", "HTML<br><br>description", 3, 30, "")
          SunflowerTheme {
              PlantDetailContent(plant)
          }
      }

   With preview:

   |51e24f4b9a7caf1.png|

   If you run the app, it behaves exactly the same as before the migration in both light
   and dark theme:

   |438d2dd9f8acac39.gif|


12. Testing
-----------


   After migrating parts of the plant detail screen to Compose, testing is critical to
   make sure you haven't broken anything.

   **Note:** In a real app, you shouldn't rewrite legacy code without tests. You should
   also refactor your tests and keep them green while migrating your code to Compose.

   In Sunflower, ``PlantDetailFragmentTest`` located in the ``androidTest`` folder tests
   some functionality of the app. Open the file and take a look at the current code:

   -  ``testPlantName`` checks for the name of the plant on the screen
   -  ``testShareTextIntent`` checks that the right intent is triggered after tapping on
      the share button

   When an activity or fragment uses compose, instead of using ``ActivityScenarioRule``,
   you need to use `createAndroidComposeRule <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/test/junit4/package-summary#createAndroidComposeRule()>`__
   that integrates ``ActivityScenarioRule`` with a ``ComposeTestRule`` that lets you test
   Compose code.

   In ``PlantDetailFragmentTest``, replace the usage ``ActivityScenarioRule`` with
   ``createAndroidComposeRule``. When the activity rule is needed to configure the test,
   use the ``activityRule`` attribute from ``createAndroidComposeRule`` as follows:

   .. code:: prettyprint

      @RunWith(AndroidJUnit4::class)
      class PlantDetailFragmentTest {

          @Rule
          @JvmField
          val composeTestRule = createAndroidComposeRule<GardenActivity>()
         
          ...

          @Before
          fun jumpToPlantDetailFragment() {
              populateDatabase()

              composeTestRule.activityRule.scenario.onActivity { gardenActivity ->
                  activity = gardenActivity

                  val bundle = Bundle().apply { putString("plantId", "malus-pumila") }
                  findNavController(activity, R.id.nav_host).navigate(R.id.plant_detail_fragment, bundle)
              }
          }

          ...
      }

   If you run the tests, ``testPlantName`` will fail! ``testPlantName`` checks for a
   TextView to be on the screen. However, you migrated that part of the UI to Compose.
   Thus, you need to use Compose assertions instead:

   .. code:: prettyprint

      @Test
      fun testPlantName() {
          composeTestRule.onNodeWithText("Apple").assertIsDisplayed()
      }

   If you run the tests, you'll see all of them pass.

   |b743660b5e840b06.png|


13. Congratulations
-------------------


   Congratulations, you've successfully completed this codelab!

   The `compose`` branch <http://goo.gle/sunflower-compose>`__ of the original Sunflower
   github project completely migrates the plant details screen to Compose. Apart from what
   you've done in this codelab, it also simulates the behavior of the
   CollapsingToolbarLayout. This involves:

   -  Loading images with Compose
   -  Animations
   -  Better dimensions handling
   -  And more!


What's next?

   Check out the other codelabs on the `Compose pathway <https://developer.android.google.cn/courses/pathways/compose>`__:

   -  `Compose Basics <https://codelabs.developers.google.cn/codelabs/jetpack-compose-basics/#0>`__
   -  `Compose Layouts <https://codelabs.developers.google.cn/codelabs/jetpack-compose-layouts>`__
   -  `Compose Theming <https://codelabs.developers.google.cn/codelabs/jetpack-compose-theming>`__
   -  `State in Compose <https://codelabs.developers.google.cn/codelabs/jetpack-compose-state>`__


Further reading

   -  `Jetpack Compose migration code-along <https://www.youtube.com/watch?v=wg4NHmxJ78g>`__
   -  `Migrate existing View-based apps <https://developer.android.google.cn/jetpack/compose/interop>`__ 
      documentation page


.. |Bottom-up approach of migrating a mixed Views and Compose UI to Compose| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/6874a64d0ada4d72.gif
.. |9b53216a27f911f2.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/9b53216a27f911f2.png
.. |a3be172fdfe6efcb.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/a3be172fdfe6efcb.png
.. |db91b149ddbc3613.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/db91b149ddbc3613.png
.. |4ae8fb531c2ede85.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/4ae8fb531c2ede85.png
.. |e506690d1024be88.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/e506690d1024be88.png
.. |311e08a065f58cd3.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/311e08a065f58cd3.png
.. |12928a361edc390e.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/12928a361edc390e.png
.. |38f43bf79290a9d7.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/38f43bf79290a9d7.png
.. |c7021c18eb8b4d4e.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/c7021c18eb8b4d4e.gif
.. |9b0953b7bb00a63d.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/9b0953b7bb00a63d.png
.. |51e24f4b9a7caf1.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/51e24f4b9a7caf1.png
.. |438d2dd9f8acac39.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/438d2dd9f8acac39.gif
.. |b743660b5e840b06.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-migration/img/b743660b5e840b06.png


ğŸš€ Advanced State and Side Effects in Jetpack Compose
======================================================

https://developer.android.google.cn/codelabs/jetpack-compose-advanced-state-side-effects?hl=en


1. Introduction
---------------


   In this codelab you will learn advanced concepts related to `State <https://developer.android.google.cn/jetpack/compose/state>`__ 
   and `Side Effects <https://developer.android.google.cn/jetpack/compose/side-effects>`__ 
   APIs in `Jetpack Compose <https://developer.android.google.cn/jetpack/compose>`__. 
   You'll see how to create a state holder for stateful composables whose logic isn't trivial, 
   how to create coroutines and call suspend functions from Compose code, and how to trigger side
   effects to accomplish different use cases.

   For more support as you're walking through this codelab, check out the following
   code-along:


What you'll learn


   -  How to observe streams of data from Compose code to update the UI.
   -  How to create a state holder for stateful composables.
   -  Side effect APIs such as `LaunchedEffect <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#LaunchedEffect(kotlin.Any,kotlin.coroutines.SuspendFunction1)>`__,
      `rememberUpdatedState <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#rememberUpdatedState(kotlin.Any)>`__,
      `DisposableEffect <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#DisposableEffect(kotlin.Any,kotlin.Function1)>`__,
      `produceState <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#produceState(kotlin.Any,kotlin.coroutines.SuspendFunction1)>`__,
      and `derivedStateOf <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#derivedStateOf(kotlin.Function0)>`__.
   -  How to create coroutines and call suspend functions in composables using the
      `rememberCoroutineScope <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#rememberCoroutineScope(kotlin.Function0)>`__
      API.


What you'll need


   -  `Latest Android Studio <https://developer.android.google.cn/studio>`__
   -  Experience with Kotlin syntax, including lambdas.
   -  Basic experience with Compose. Consider taking the 
      `Jetpack Compose basics codelab <https://codelabs.developers.google.cn/codelabs/jetpack-compose-basics/>`__
      before this codelab.
   -  `Basic state concepts in Compose <https://developer.android.google.cn/jetpack/compose/state>`__ 
      such as Unidirectional Data Flow (UDF), ViewModels, state hoisting, stateless/stateful
      composables, Slot APIs, and the ``remember`` and ``mutableStateOf`` state APIs. To
      obtain this knowledge, consider reading the `State and Jetpack Compose documentation <https://developer.android.google.cn/jetpack/compose/state>`__ 
      or completing the `Using State in Jetpack Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-state#0>`__.
   -  Basic knowledge of `Kotlin coroutines <https://developer.android.google.cn/kotlin/coroutines>`__.
   -  Basic understanding of the `lifecycle of composables <https://developer.android.google.cn/jetpack/compose/lifecycle>`__.


What you'll build


   In this codelab, you'll start from an unfinished application, the 
   `Crane material study <https://material.io/design/material-studies/crane.html>`__ 
   app, and add features to improve the app.

   |b2c6b8989f4332bb.gif|


2. Getting set up
-----------------



Get the code


   The code for this codelab can be found in the `Github repository <https://github.com/googlecodelabs/android-compose-codelabs>`__. 
   To clone it, run:

   ::

      $ git clone https://github.com/android/codelab-android-compose

   Alternatively, you can download the repository as a zip file:

   `Download Zip <https://github.com/android/codelab-android-compose/archive/main.zip>`__


Check out the sample app


   The code you just downloaded contains code for all Compose codelabs available. To
   complete this codelab, open the **``AdvancedStateAndSideEffectsCodelab``** project
   inside Android Studio.

   The compose-codelabs repo contains starter code for all codelabs in the pathway.

   For this codelab, use the **AdvancedStateAndSideEffectsCodelab** project.

   -  |android_studio_folder.png| **AdvancedStateAndSideEffectsCodelab** â€” Project that
      contains the start and finished code for this codelab.

   The project is built in multiple git branches:

   -  **main** â€“ the starter code for this project; you will make changes to this to
      complete the codelab.
   -  **end** â€“ contains the solution to this codelab.

   We recommend that you start with the code in the main branch and follow the codelab
   step-by-step at your own pace.

   During the codelab, you'll be presented with snippets of code that you'll need to add
   to the project. In some places, you'll also need to remove code that is explicitly
   mentioned in comments on the code snippets.


Getting familiar with the code and running the sample app


   Take a moment to explore the project structure and run the app.

   |162c42b19dafa701.png|

   When you run the app from the main branch, you'll see that some functionality such as
   the drawer, or loading flight destinations doesn't work! That's what you'll be doing in
   the next steps of the codelab.

   |b2c6b8989f4332bb.gif|


UI tests


   The app is covered with very basic UI tests available in the ``androidTest`` folder.
   They should pass for both the ``main`` and ``end`` branches at all times.


[Optional] Displaying the map on the details screen


   Displaying the map of the city on the details screen is not necessary at all to follow
   along. However, if you want to see it, you need to get a personal API key as the 
   `Maps documentation <https://developers.google.cn/maps/documentation/android-sdk/get-api-key>`__
   says. Include that key in the ``local.properties`` file as follows:

   .. code:: prettyprint

      // local.properties file
      google.maps.key={insert_your_api_key_here}

   When setting up the credentials in the Google dashboard, make sure to use
   ``androidx.compose.samples.crane`` as the package name, and
   ``A0:BD:B3:B6:F0:C4:BE:90:C6:9D:5F:4C:1D:F0:90:80:7F:D7:FE:1F`` as the SHA-1
   certificate fingerprint.


Solution to the codelab


   To get the ``end`` branch using git, use this command:

   ::

      $ git clone -b end https://github.com/android/codelab-android-compose

   Alternatively, you can download the solution code from here:

   `Download the final code <https://github.com/android/codelab-android-compose/archive/end.zip>`__


Frequently asked questions


   -  `How do I install Android Studio? <https://developer.android.google.cn/studio/install>`__
   -  `How do I set up a device for development? <http://developer.android.google.cn/tools/device.html>`__


3. UI state production pipeline
-------------------------------


   As you might've noticed when running the app from the ``main`` branch, the list of
   flight destinations is empty!

   To fix this, you have to complete two steps:

   -  Add the logic in the `ViewModel <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__
      to produce the `UI state <https://developer.android.google.cn/topic/architecture/ui-layer/stateholders#elements-ui>`__.
      In your case, this is the list of suggested destinations.
   -  Consume the UI state from the UI, which will display the UI on the screen.

   In this section, you'll complete the first step.

   A good architecture for an application is organized in layers to obey basic good system
   design practices, like separation of concerns and testability.

   `UI State production <https://developer.android.google.cn/topic/architecture/ui-layer/state-production>`__
   refers to the process in which the app accesses the data layer, applies business rules
   if needed, and exposes UI state to be consumed from the UI.

   The data layer in this application is already implemented. Now, you'll produce the
   state (the list of suggested destinations) so that the UI can consume it.

   There are a few APIs that can be used to produce UI state. The alternatives are
   summarized in the `Output types in state production pipelines <https://developer.android.google.cn/topic/architecture/ui-layer/state-production#output-types>`__
   documentation. In general, it is a good practice to use Kotlin's `StateFlow <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/>`__
   to produce UI state.

   To produce the UI state, follow these steps:

   1. Open ``home/MainViewModel.kt``.
   2. Define a private ``_suggestedDestinations`` variable of type `MutableStateFlow <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/>`__
      to represent the list of suggested destinations, and set an empty list as the start
      value.

   .. code:: prettyprint

      private val _suggestedDestinations = MutableStateFlow<List<ExploreModel>>(emptyList())

   3. Define a second immutable variable ``suggestedDestinations`` of type ``StateFlow``.
      This is the public read-only variable that can be consumed from the UI. Exposing a
      read-only variable while using the mutable variable internally is a good practice.
      By doing this, you ensure the UI state cannot be modified unless it is through the
      ``ViewModel``, which makes it the single source of truth. The extension function
      `asStateFlow <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/as-state-flow.html>`__
      converts the flow from mutable to immutable.

   .. code:: prettyprint

      private val _suggestedDestinations = MutableStateFlow<List<ExploreModel>>(emptyList())

      val suggestedDestinations: StateFlow<List<ExploreModel>> = _suggestedDestinations.asStateFlow()

   4. In the ``ViewModel``'s init block, add a call from ``destinationsRepository`` to get
      the destinations from the data layer.

   .. code:: prettyprint

      private val _suggestedDestinations = MutableStateFlow<List<ExploreModel>>(emptyList())

      val suggestedDestinations: StateFlow<List<ExploreModel>> = _suggestedDestinations.asStateFlow()

      init {
          _suggestedDestinations.value = destinationsRepository.destinations
      }

   5. Finally, uncomment the usages of the internal variable ``_suggestedDestinations``
      you find in this class, so it can be updated properly with events coming from the
      UI.

   That's itâ€“ the first step is done! Now, the ``ViewModel`` is able to produce UI state.
   In the next step, you will consume this state from the UI.


4. Consuming a Flow safely from the ViewModel
---------------------------------------------


   The list of flight destinations is still empty. In the previous step, you produced the
   UI state in the ``MainViewModel``. Now, you'll consume the UI state exposed by
   ``MainViewModel`` to display in the UI.

   Open the ``home/CraneHome.kt`` file and look at the ``CraneHomeContent`` composable.

   There's a TODO comment above the definition of ``suggestedDestinations`` which is
   assigned to a remembered empty list. This is what's showing on the screen: an empty
   list! In this step, you'll fix that and show the suggested destinations that the
   ``MainViewModel`` exposes.

   |66ae2543faaf2e91.png|

   Open ``home/MainViewModel.kt`` and take a look at the ``suggestedDestinations``
   `StateFlow <https://developer.android.google.cn/kotlin/flow/stateflow-and-sharedflow>`__
   that is initialized to ``destinationsRepository.destinations``, and gets updated when
   the ``updatePeople`` or ``toDestinationChanged`` functions get called.

   You want your UI in the ``CraneHomeContent`` composable to update whenever there's a
   new item emitted into the ``suggestedDestinations`` stream of data. You can use the
   `collectAsStateWithLifecycle() <https://developer.android.google.cn/reference/kotlin/androidx/lifecycle/compose/package-summary#(kotlinx.coroutines.flow.Flow).collectAsStateWithLifecycle(kotlin.Any,androidx.lifecycle.Lifecycle,androidx.lifecycle.Lifecycle.State,kotlin.coroutines.CoroutineContext)>`__
   function. ``collectAsStateWithLifecycle()`` collects values from the ``StateFlow`` and
   represents the latest value via Compose's `State <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/State>`__
   API in a lifecycle-aware manner. This will make the Compose code that reads that state
   value recompose on new emissions.

   To start using the ``collectAsStateWithLifecycle`` API, first add the following
   `dependency <https://developer.android.google.cn/jetpack/androidx/releases/lifecycle>`__
   in ``app/build.gradle``. The variable ``lifecycle_version`` is defined already in the
   project with the appropriate version.

   .. code:: prettyprint

      dependencies {
          implementation "androidx.lifecycle:lifecycle-runtime-compose:$lifecycle_version"
      }

   **Note:** To learn more about the ``collectAsStateWithLifecycle()`` API, see the
   `Consuming flows safely in Jetpack Compose <https://medium.com/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3>`__
   blog post.

   Go back to the ``CraneHomeContent`` composable and replace the line that assigns
   ``suggestedDestinations`` with a call to ``collectAsStateWithLifecycle`` on the
   ``ViewModel``'s ``suggestedDestinations`` property:

   .. code:: prettyprint

      import androidx.lifecycle.compose.collectAsStateWithLifecycle

      @Composable
      fun CraneHomeContent(
          onExploreItemClicked: OnExploreItemClicked,
          openDrawer: () -> Unit,
          modifier: Modifier = Modifier,
          viewModel: MainViewModel = viewModel(),
      ) {
          val suggestedDestinations by viewModel.suggestedDestinations.collectAsStateWithLifecycle()
          // ...
      }

   If you run the app, you'll see that the list of destinations are populated, and that
   they change whenever you tap the number of people traveling.

   |d656748c7c583eb8.gif|

   Compose also offers APIs for Android's most popular stream-based solutions:

   -  `LiveData.observeAsState() <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/livedata/package-summary#observeAsState(androidx.lifecycle.LiveData)>`__
      included in the ``androidx.compose.runtime:runtime-livedata:$composeVersion``
      artifact.
   -  `Observable.subscribeAsState() <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/rxjava2/package-summary#subscribeAsState(io.reactivex.Observable,kotlin.Any)>`__
      included in the ``androidx.compose.runtime:runtime-rxjava2:$composeVersion`` or
      ``androidx.compose.runtime:runtime-rxjava3:$composeVersion`` artifact.

   See the `Other supported types of state <https://developer.android.google.cn/jetpack/compose/state#use-other-types-of-state-in-jetpack-compose>`__
   page in the State documentation to learn more.


5. LaunchedEffect and rememberUpdatedState
------------------------------------------


   In the project, there's a ``home/LandingScreen.kt`` file that's not used at the moment.
   You want to add a landing screen to the app, which potentially could be used to load
   all the data needed in the background.

   The landing screen will occupy the whole screen and show the app's logo in the middle
   of the screen. Ideally, you'd show the screen andâ€”after all the data's been
   loadedâ€”you'd notify the caller that the landing screen can be dismissed using the
   ``onTimeout`` callback.

   Kotlin coroutines are the recommended way to perform asynchronous operations in
   Android. An app would usually use coroutines to load things in the background when it
   starts. Jetpack Compose offers APIs that make using coroutines safe within the UI
   layer. As this app doesn't communicate with a backend, you'll use the coroutines'
   `delay <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html>`__
   function to simulate loading things in the background.

   **A side-effect in Compose is a change to the state of the app that happens outside the
   scope of a composable function.** For example, opening a new screen when the user taps
   on a button, or showing a message when the app doesn't have Internet connection.

   A side-effect in Compose is a change to the state of the app that happens outside the
   scope of a composable function. Changing the state to show/hide the landing screen will
   happen in the ``onTimeout`` callback and since before calling ``onTimeout`` you need to
   load things using coroutines, the state change needs to happen in the context of a
   coroutine!

   To call suspend functions safely from inside a composable, use the
   `LaunchedEffect <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#LaunchedEffect(kotlin.Any,kotlin.coroutines.SuspendFunction1)>`__
   API, which triggers a coroutine-scoped side-effect in Compose.

   When ``LaunchedEffect`` enters the Composition, it launches a coroutine with the block
   of code passed as a parameter. The coroutine will be canceled if ``LaunchedEffect``
   leaves the composition.

   Although the next code is not correct, let's see how to use this API and discuss why
   the following code is wrong. You'll call the ``LandingScreen`` composable later in this
   step.

   .. code:: prettyprint

      // home/LandingScreen.kt file

      import androidx.compose.runtime.LaunchedEffect
      import kotlinx.coroutines.delay

      @Composable
      fun LandingScreen(onTimeout: () -> Unit, modifier: Modifier = Modifier) {
          Box(modifier = modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
              // Start a side effect to load things in the background
              // and call onTimeout() when finished.
              // Passing onTimeout as a parameter to LaunchedEffect
              // is wrong! Don't do this. We'll improve this code in a sec.
              LaunchedEffect(onTimeout) {
                  delay(SplashWaitTime) // Simulates loading things
                  onTimeout()
              }
              Image(painterResource(id = R.drawable.ic_crane_drawer), contentDescription = null)
          }
      }

   Some side-effect APIs like ``LaunchedEffect`` take a variable number of keys as a
   parameter that are used to **restart** the effect whenever one of those keys changes.
   Have you spotted the error? We wouldn't want to restart the ``LaunchedEffect`` if
   callers to this composable function pass a different ``onTimeout`` lambda value. That'd
   make the ``delay`` start again and you wouldn't be meeting the requirements.

   Let's fix this. To trigger the side-effect only once during the 
   `lifecycle of this composable <https://developer.android.google.cn/jetpack/compose/lifecycle>`__, 
   use a constant as a key, for example ``LaunchedEffect(Unit) { ... }``. However, 
   now there's a different issue.

   If ``onTimeout`` changes while the side-effect is in progress, there's no guarantee
   that the last ``onTimeout`` is called when the effect finishes. To guarantee that the
   last ``onTimeout`` is called, remember ``onTimeout`` using the `rememberUpdatedState <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#rememberUpdatedState(kotlin.Any)>`__
   API. This API captures and updates the newest value:

   .. code:: prettyprint

      // home/LandingScreen.kt file

      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.rememberUpdatedState
      import kotlinx.coroutines.delay

      @Composable
      fun LandingScreen(onTimeout: () -> Unit, modifier: Modifier = Modifier) {
          Box(modifier = modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
              // This will always refer to the latest onTimeout function that
              // LandingScreen was recomposed with
              val currentOnTimeout by rememberUpdatedState(onTimeout)

              // Create an effect that matches the lifecycle of LandingScreen.
              // If LandingScreen recomposes or onTimeout changes, 
              // the delay shouldn't start again.
              LaunchedEffect(Unit) {
                  delay(SplashWaitTime)
                  currentOnTimeout()
              }

              Image(painterResource(id = R.drawable.ic_crane_drawer), contentDescription = null)
          }
      }

   You should use ``rememberUpdatedState`` when a long-lived lambda or object expression
   references parameters or values computed during composition, which might be common when
   working with ``LaunchedEffect``.


Showing the landing screen


   Now, you need to show the landing screen when the app is opened. Open the
   ``home/MainActivity.kt`` file and check out the ``MainScreen`` composable that's first
   called.

   In the ``MainScreen`` composable, you can simply add an internal state that tracks
   whether the landing should be shown or not:

   .. code:: prettyprint

      // home/MainActivity.kt file

      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.mutableStateOf
      import androidx.compose.runtime.remember
      import androidx.compose.runtime.setValue

      @Composable
      private fun MainScreen(onExploreItemClicked: OnExploreItemClicked) {
          Surface(color = MaterialTheme.colors.primary) {
              var showLandingScreen by remember { mutableStateOf(true) }
              if (showLandingScreen) {
                  LandingScreen(onTimeout = { showLandingScreen = false })
              } else {
                  CraneHome(onExploreItemClicked = onExploreItemClicked)
              }
          }
      }

   If you run the app now, you should see the ``LandingScreen`` appearing and disappearing
   after 2 seconds.

   |e3fd932a5b95faa0.gif|


6. rememberCoroutineScope
-------------------------


   In this step, you'll make the navigation drawer work. Currently, nothing happens if you
   try to tap the hamburger menu.

   Open the ``home/CraneHome.kt`` file and check out the ``CraneHome`` composable to see
   where you need to open the navigation drawer: in the ``openDrawer`` callback!

   In ``CraneHome``, you have a `scaffoldState <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/ScaffoldState>`__
   that contains a ``DrawerState``. `DrawerState <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/DrawerState>`__
   has methods to open and close the navigation drawer programmatically. However, if you
   attempt to write ``scaffoldState.drawerState.open()`` in the ``openDrawer`` callback,
   you'll get an error! That's because the ``open`` function is a **suspend** function.
   We're in the realm of coroutines again.

   Apart from APIs to make calling coroutines safe from the UI layer, some Compose APIs
   are suspend functions. One example of this is the API to open the navigation drawer.
   Suspend functions, in addition to being able to run asynchronous code, also help
   represent concepts that happen over time. As opening the drawer requires some time,
   movement, and potential animations, that's perfectly reflected with the suspend
   function, which will suspend the execution of the coroutine where it's been called
   until it finishes and resumes execution.

   ``scaffoldState.drawerState.open()`` must be called within a coroutine. What can you
   do? ``openDrawer`` is a simple callback function, therefore:

   -  You cannot simply call suspend functions in it because ``openDrawer`` is not
      executed in the context of a coroutine.
   -  You cannot use ``LaunchedEffect`` as before because we cannot call composables in
      ``openDrawer``. We're not in the Composition.

   You want to launch a coroutine; which scope should we use? Ideally, you'd want a
   ``CoroutineScope`` that follows the lifecycle of its call-site. Using the
   `rememberCoroutineScope <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#rememberCoroutineScope(kotlin.Function0)>`__
   API returns a ``CoroutineScope`` bound to the point in the Composition where you call
   it. The scope will be automatically canceled once it leaves the Composition. With that
   scope, you can start coroutines when you're not in the Composition, for example, in the
   ``openDrawer`` callback.

   .. code:: prettyprint

      // home/CraneHome.kt file

      import androidx.compose.runtime.rememberCoroutineScope
      import kotlinx.coroutines.launch

      @Composable
      fun CraneHome(
          onExploreItemClicked: OnExploreItemClicked,
          modifier: Modifier = Modifier,
      ) {
          val scaffoldState = rememberScaffoldState()
          Scaffold(
              scaffoldState = scaffoldState,
              modifier = Modifier.statusBarsPadding(),
              drawerContent = {
                  CraneDrawer()
              }
          ) {
              val scope = rememberCoroutineScope()
              CraneHomeContent(
                  modifier = modifier,
                  onExploreItemClicked = onExploreItemClicked,
                  openDrawer = {
                      scope.launch {
                          scaffoldState.drawerState.open()
                      }
                  }
              )
          }
      }

   If you run the app, you'll see that the navigation drawer opens when you tap the
   hamburger menu icon.

   |92957c04a35e91e3.gif|


LaunchedEffect vs rememberCoroutineScope


   Using ``LaunchedEffect`` in this case wasn't possible because you needed to trigger the
   call to create a coroutine in a regular callback that was outside of the Composition.

   Looking back at the landing screen step that used ``LaunchedEffect``, could you use
   ``rememberCoroutineScope`` and call ``scope.launch { delay(); onTimeout(); }`` instead
   of using ``LaunchedEffect``?

   You could've done that, and it would've seemed to work, but it wouldn't be correct. As
   explained in the `Thinking in Compose documentation <https://developer.android.google.cn/jetpack/compose/mental-model#any-order>`__,
   composables can be called by Compose at any moment. ``LaunchedEffect`` guarantees that
   the side-effect will be executed when the call to that composable makes it into the
   Composition. If you use ``rememberCoroutineScope`` and ``scope.launch`` in the body of
   the ``LandingScreen``, the coroutine will be executed every time ``LandingScreen`` is
   called by Compose regardless of whether that call makes it into the Composition or not.
   Therefore, you'll waste resources and you won't be executing this side-effect in a
   controlled environment.


7. Creating a state holder
--------------------------


   Have you noticed that if you tap *Choose Destination* you can edit the field and filter
   cities based on your search input? You also probably noticed that whenever you modify
   *Choose Destination*, the text style changes.

   |dde9ef06ca4e5191.gif|

   Open the ``base/EditableUserInput.kt`` file. The ``CraneEditableUserInput`` stateful
   composable takes some parameters such as the ``hint`` and a ``caption`` which
   corresponds to the optional text next to the icon. For example, the ``caption`` *To*
   appears when you search for a destination.

   .. code:: prettyprint

      // base/EditableUserInput.kt file - code in the main branch

      @Composable
      fun CraneEditableUserInput(
          hint: String,
          caption: String? = null,
          @DrawableRes vectorImageId: Int? = null,
          onInputChanged: (String) -> Unit
      ) {
          // TODO Codelab: Encapsulate this state in a state holder
          var textState by remember { mutableStateOf(hint) }
          val isHint = { textState == hint }

          ...
      }


Why?


   The logic to update the ``textState`` and determine whether what's been displayed
   corresponds to the hint or not is all in the body of the ``CraneEditableUserInput``
   composable. This brings some downsides with it:

   -  The value of the ``TextField`` is not hoisted and therefore cannot be controlled
      from outside, making testing harder.
   -  The logic of this composable could become more complex and the internal state could
      be out of sync more easily.

   By creating a state holder responsible for the internal state of this composable, you
   can centralize all state changes in one place. With this, it's more difficult for the
   state to be out of sync, and the related logic is all grouped together in a single
   class. Furthermore, this state can be easily hoisted up and can be consumed from
   callers of this composable.

   In this case, hoisting the state is a good idea since this is a low-level UI component
   that might be reused in other parts of the app. Therefore, the more flexible and
   controllable it is, the better.


Creating the state holder


   As ``CraneEditableUserInput`` is a reusable component, create a regular class as state
   holder named ``EditableUserInputState`` in the same file that looks like the following:

   .. code:: prettyprint

      // base/EditableUserInput.kt file

      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.mutableStateOf
      import androidx.compose.runtime.setValue

      class EditableUserInputState(private val hint: String, initialText: String) {

          var text by mutableStateOf(initialText)
             private set

          fun updateText(newText: String) {
             text = newText
          }

          val isHint: Boolean
              get() = text == hint
      }

   The class should have the following traits:

   -  ``text`` is a mutable state of type ``String``, just as you have in
      ``CraneEditableUserInput``. It's important to use ``mutableStateOf`` so that Compose
      tracks changes to the value and recomposes when changes happen.
   -  ``text`` is a ``var``, with a private ``set`` so it can't be directly mutated from
      outside the class. Instead of making this variable public, you can expose an event
      ``updateText`` to modify it, which makes the class the single source of truth.
   -  The class takes an ``initialText`` as a dependency that is used to initialize
      ``text``.
   -  The logic to know if the ``text`` is the hint or not is in the ``isHint`` property
      that performs the check on-demand.

   If the logic gets more complex in the future, you only need to make changes to one
   class: ``EditableUserInputState``.


Remembering the state holder


   State holders always need to be remembered in order to keep them in the Composition and
   not create a new one every time. It's a good practice to create a method in the same
   file that does this to remove boilerplate and avoid any mistakes that might occur. In
   the ``base/EditableUserInput.kt`` file, add this code:

   .. code:: prettyprint

      // base/EditableUserInput.kt file

      @Composable
      fun rememberEditableUserInputState(hint: String): EditableUserInputState =
          remember(hint) {
              EditableUserInputState(hint, hint)
          }

   If you *only* ``remember`` this state, it won't survive activity recreations. To
   achieve that, you can use the `rememberSaveable <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/package-summary#rememberSaveable(kotlin.Array,androidx.compose.runtime.saveable.Saver,kotlin.String,kotlin.Function0)>`__
   API instead which behaves similarly to ``remember``, but the stored value also survives
   activity and process recreation. Internally, it uses the saved instance state
   mechanism.

   ``rememberSaveable`` does all this with no extra work for objects that can be stored
   inside a `Bundle <https://developer.android.google.cn/reference/android/os/Bundle>`__.
   That's not the case for the ``EditableUserInputState`` class that you created in your
   project. Therefore, you need to tell ``rememberSaveable`` how to save and restore an
   instance of this class using a `Saver <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/package-summary#Saver(kotlin.Function2,kotlin.Function1)>`__.


Creating a custom saver


   A `Saver <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/package-summary#Saver(kotlin.Function2,kotlin.Function1)>`__
   describes how an object can be converted into something which is `Saveable <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/Saver>`__.
   Implementations of a `Saver <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/package-summary#Saver(kotlin.Function2,kotlin.Function1)>`__
   need to override two functions:

   -  ``save`` to convert the original value to a saveable one.
   -  ``restore`` to convert the restored value to an instance of the original class.

   For this case, instead of creating a custom implementation of `Saver <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/package-summary#Saver(kotlin.Function2,kotlin.Function1)>`__
   for the ``EditableUserInputState`` class, you can use some of the existing Compose APIs
   such as `listSaver <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/package-summary#listSaver(kotlin.Function2,kotlin.Function1)>`__
   or `mapSaver <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/package-summary#mapSaver(kotlin.Function2,kotlin.Function1)>`__
   (that stores the values to save in a ``List`` or ``Map``) to reduce the amount of code
   that you need to write.

   It's a good practice to place ``Saver`` definitions close to the class they work with.
   Because it needs to be statically accessed, add the ``Saver`` for
   ``EditableUserInputState`` in a ``companion object``. In the
   ``base/EditableUserInput.kt`` file, add the implementation of the ``Saver``:

   .. code:: prettyprint

      // base/EditableUserInput.kt file

      import androidx.compose.runtime.saveable.Saver
      import androidx.compose.runtime.saveable.listSaver

      class EditableUserInputState(private val hint: String, initialText: String) {
          var text by mutableStateOf(initialText)

          val isHint: Boolean
              get() = text == hint

          companion object {
              val Saver: Saver<EditableUserInputState, *> = listSaver(
                  save = { listOf(it.hint, it.text) },
                  restore = {
                      EditableUserInputState(
                          hint = it[0],
                          initialText = it[1],
                      )
                  }
              )
          }
      }

   In this case, you use a ``listSaver`` as an implementation detail to store and restore
   an instance of ``EditableUserInputState`` in the saver.

   Now, you can use this saver in ``rememberSaveable`` (instead of ``remember``) in the
   ``rememberEditableUserInputState`` method you created before:

   .. code:: prettyprint

      // base/EditableUserInput.kt file
      import androidx.compose.runtime.saveable.rememberSaveable

      @Composable
      fun rememberEditableUserInputState(hint: String): EditableUserInputState =
          rememberSaveable(hint, saver = EditableUserInputState.Saver) {
              EditableUserInputState(hint, hint)
          }

   With this, the ``EditableUserInput`` remembered state will survive process and activity
   recreations.


Using the state holder


   You're going to use ``EditableUserInputState`` instead of ``text`` and ``isHint``, but
   you don't want to just use it as an internal state in ``CraneEditableUserInput`` as
   there's no way for the caller composable to control the state. Instead, you want to
   *hoist* ``EditableUserInputState`` so that callers can control the state of
   ``CraneEditableUserInput``. If you hoist the state, then the composable can be used in
   previews and be tested more easily since you're able to modify its state from the
   caller.

   To do this, you need to change the parameters of the composable function and give it a
   default value in case it is needed. Because you might want to allow
   ``CraneEditableUserInput`` with empty hints, add a default argument:

   .. code:: prettyprint

      @Composable
      fun CraneEditableUserInput(
          state: EditableUserInputState = rememberEditableUserInputState(""),
          caption: String? = null,
          @DrawableRes vectorImageId: Int? = null
      ) { /* ... */ }

   You've probably noticed that the ``onInputChanged`` parameter is not there anymore!
   Since the state can be hoisted, if callers want to know if the input changed, they can
   control the state and pass that state into this function.

   Next, you need to tweak the function body to use the hoisted state instead of the
   internal state that was used before. After the refactoring, the function should look
   like this:

   .. code:: prettyprint

      @Composable
      fun CraneEditableUserInput(
          state: EditableUserInputState = rememberEditableUserInputState(""),
          caption: String? = null,
          @DrawableRes vectorImageId: Int? = null
      ) {
          CraneBaseUserInput(
              caption = caption,
              tintIcon = { !state.isHint },
              showCaption = { !state.isHint },
              vectorImageId = vectorImageId
          ) {
              BasicTextField(
                  value = state.text,
                  onValueChange = { state.updateText(it) },
                  textStyle = if (state.isHint) {
                      captionTextStyle.copy(color = LocalContentColor.current)
                  } else {
                      MaterialTheme.typography.body1.copy(color = LocalContentColor.current)
                  },
                  cursorBrush = SolidColor(LocalContentColor.current)
              )
          }
      }


State holder callers


   Since you changed the API of ``CraneEditableUserInput``, you need to check in all
   places where it's called to make sure you pass in the appropriate parameters.

   The only place in the project that you call this API is in the
   ``home/SearchUserInput.kt`` file. Open it and go to the ``ToDestinationUserInput``
   composable function; you should see a build error there. As the hint is now part of the
   state holder, and you want a custom hint for this instance of
   ``CraneEditableUserInput`` in the Composition, you need to remember the state at the
   ``ToDestinationUserInput`` level and pass it into ``CraneEditableUserInput``:

   .. code:: prettyprint

      // home/SearchUserInput.kt file

      import androidx.compose.samples.crane.base.rememberEditableUserInputState

      @Composable
      fun ToDestinationUserInput(onToDestinationChanged: (String) -> Unit) {
          val editableUserInputState = rememberEditableUserInputState(hint = "Choose Destination")
          CraneEditableUserInput(
              state = editableUserInputState,
              caption = "To",
              vectorImageId = R.drawable.ic_plane
          )
      }


snapshotFlow


   The code above is missing functionality to notify ``ToDestinationUserInput``'s caller
   when the input changes. Due to how the app is structured, you don't want to hoist the
   ``EditableUserInputState`` any higher up in the hierarchy. You wouldn't want to couple
   the other composables such as ``FlySearchContent`` with this state. How can you call
   the ``onToDestinationChanged`` lambda from ``ToDestinationUserInput`` and still keep
   this composable reusable?

   You can trigger a side-effect using ``LaunchedEffect`` every time the input changes and
   call the ``onToDestinationChanged`` lambda:

   .. code:: prettyprint

      // home/SearchUserInput.kt file

      import androidx.compose.runtime.LaunchedEffect
      import androidx.compose.runtime.rememberUpdatedState
      import androidx.compose.runtime.snapshotFlow
      import kotlinx.coroutines.flow.collect
      import kotlinx.coroutines.flow.filter

      @Composable
      fun ToDestinationUserInput(onToDestinationChanged: (String) -> Unit) {
          val editableUserInputState = rememberEditableUserInputState(hint = "Choose Destination")
          CraneEditableUserInput(
              state = editableUserInputState,
              caption = "To",
              vectorImageId = R.drawable.ic_plane
          )

          val currentOnDestinationChanged by rememberUpdatedState(onToDestinationChanged)
          LaunchedEffect(editableUserInputState) {
              snapshotFlow { editableUserInputState.text }
                  .filter { !editableUserInputState.isHint }
                  .collect {
                      currentOnDestinationChanged(editableUserInputState.text)
                  }
          }
      }

   You've already used ``LaunchedEffect`` and ``rememberUpdatedState`` before, but the
   code above also uses a new API! The `snapshotFlow <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#snapshotFlow(kotlin.Function0)>`__
   **API** converts Compose `State<T> <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/State>`__
   objects into a `Flow <https://developer.android.google.cn/kotlin/flow>`__. When the
   state read inside ``snapshotFlow`` mutates, the Flow will emit the new value to the
   collector. In this case, you convert the state into a flow to use the power of flow
   operators. With that, you ``filter`` when the ``text`` is not the ``hint``, and
   ``collect`` the emitted items to notify the parent that the current destination
   changed.

   There are no visual changes in this step of the codelab, but you've improved the
   quality of this part of the code. If you run the app now, you should see everything is
   working as it did previously.


8. DisposableEffect
-------------------


   When you tap on a destination, the details screen opens and you can see where the city
   is on the map. That code is in the ``details/DetailsActivity.kt`` file. In the
   ``CityMapView`` composable, you're calling the ``rememberMapViewWithLifecycle``
   function. If you open this function, which is in the ``details/MapViewUtils.kt`` file,
   you'll see that it's not connected to any lifecycle! It just remembers a ``MapView``
   and calls ``onCreate`` on it:

   .. code:: prettyprint

      // details/MapViewUtils.kt file - code in the main branch

      @Composable
      fun rememberMapViewWithLifecycle(): MapView {
          val context = LocalContext.current
          // TODO Codelab: DisposableEffect step. Make MapView follow the lifecycle
          return remember {
              MapView(context).apply {
                  id = R.id.map
                  onCreate(Bundle())
              }
          }
      }

   Even though the app runs fine, this is a problem because the ``MapView`` is not
   following the correct lifecycle. Therefore, it won't know when the app is moved to the
   background, when the View should be paused, etc. Let's fix this!

   **Note:** If you don't see the map, check out the *[Optional] Displaying the map on the
   details screen* section of the *Getting set up* step. However, it's not necessary for
   this section to see the map on the screen.

   As the ``MapView`` is a View and not a composable, you want it to follow the lifecycle
   of the Activity where it's used as well as the lifecycle of the Composition. That means
   you need to create a `LifecycleEventObserver <https://developer.android.google.cn/reference/androidx/lifecycle/LifecycleEventObserver>`__
   to listen for lifecycle events and call the right methods on the `MapView <https://developers.google.cn/android/reference/com/google/android/gms/maps/MapView>`__.
   Then, you need to add this observer to the current activity's lifecycle.

   Start by creating a function that returns a ``LifecycleEventObserver`` that calls the
   corresponding methods in a ``MapView`` given a certain event:

   .. code:: prettyprint

      // details/MapViewUtils.kt file

      import androidx.lifecycle.Lifecycle
      import androidx.lifecycle.LifecycleEventObserver

      private fun getMapLifecycleObserver(mapView: MapView): LifecycleEventObserver =
          LifecycleEventObserver { _, event ->
              when (event) {
                  Lifecycle.Event.ON_CREATE -> mapView.onCreate(Bundle())
                  Lifecycle.Event.ON_START -> mapView.onStart()
                  Lifecycle.Event.ON_RESUME -> mapView.onResume()
                  Lifecycle.Event.ON_PAUSE -> mapView.onPause()
                  Lifecycle.Event.ON_STOP -> mapView.onStop()
                  Lifecycle.Event.ON_DESTROY -> mapView.onDestroy()
                  else -> throw IllegalStateException()
              }
          }

   Now, you need to add this observer to the current lifecycle, which you can get using
   the current `LifecycleOwner <https://developer.android.google.cn/reference/androidx/lifecycle/LifecycleOwner>`__
   with the ``LocalLifecycleOwner`` composition local. However, it's not enough to add the
   observer; you also need to be able to remove it! You need a side effect that tells you
   when the effect is leaving the Composition so that you can perform some cleanup code.
   The side-effect API you're looking for is `DisposableEffect <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#DisposableEffect(kotlin.Any,kotlin.Function1)>`__.

   ``DisposableEffect`` is meant for side effects that need to be cleaned up after the
   keys change or the composable leaves the Composition. The final
   ``rememberMapViewWithLifecycle`` code does exactly that. Implement the following lines
   in your project:

   .. code:: prettyprint

      // details/MapViewUtils.kt file

      import androidx.compose.runtime.DisposableEffect
      import androidx.compose.ui.platform.LocalLifecycleOwner

      @Composable
      fun rememberMapViewWithLifecycle(): MapView {
          val context = LocalContext.current
          val mapView = remember {
              MapView(context).apply {
                  id = R.id.map
              }
          }

          val lifecycle = LocalLifecycleOwner.current.lifecycle
          DisposableEffect(key1 = lifecycle, key2 = mapView) {
              // Make MapView follow the current lifecycle
              val lifecycleObserver = getMapLifecycleObserver(mapView)
              lifecycle.addObserver(lifecycleObserver)
              onDispose {
                  lifecycle.removeObserver(lifecycleObserver)
              }
          }

          return mapView
      }

   The observer is added to the current ``lifecycle``, and it'll be removed whenever the
   current lifecycle changes or this composable leaves the Composition. With the
   ``key``s in ``DisposableEffect``, if either the ``lifecycle`` or the ``mapView``
   change, the observer will be removed and added again to the right ``lifecycle``.

   With the changes you've just made, the ``MapView`` will always follow the ``lifecycle``
   of the current ``LifecycleOwner`` and its behavior would be just as if it was used in
   the View world.

   Feel free to run the app and open the details screen to make sure that the ``MapView``
   still renders properly. There are no visual changes in this step.

   **Note:** This section explores how to define a ``LifecycleEventObserver`` to react to
   ``LifecycleOwner`` events from Compose. You also learned how to use
   ``DisposableEffect`` API to safely dispose of resources to avoid memory leaks. The
   example used the view-based component ``MapView``. In a real Compose app, you can use
   the new `Maps for Compose library <https://developers.google.cn/maps/documentation/android-sdk/maps-compose>`__
   which will handle lifecycle events for you.


9. produceState
---------------


   In this section, you'll improve how the details screen starts. The ``DetailsScreen``
   composable in the ``details/DetailsActivity.kt`` file gets the ``cityDetails``
   synchronously from the ViewModel and calls ``DetailsContent`` if the result is
   successful.

   However, ``cityDetails`` could evolve to be more costly to load on the UI thread and it
   could use coroutines to move the loading of the data to a different thread. You'll
   improve this code to add a loading screen and display the ``DetailsContent`` when the
   data is ready.

   One way to model the state of the screen is with the following class that covers all
   possibilities: data to display on the screen, and the loading and error signals. Add
   the ``DetailsUiState`` class to the ``DetailsActivity.kt`` file:

   .. code:: prettyprint

      // details/DetailsActivity.kt file

      data class DetailsUiState(
          val cityDetails: ExploreModel? = null,
          val isLoading: Boolean = false,
          val throwError: Boolean = false
      )

   You could map what the screen needs to display and the ``UiState`` in the ViewModel
   layer by using a stream of data, a ``StateFlow`` of type ``DetailsUiState``, that the
   ViewModel updates when the information is ready and that Compose collects with the
   ``collectAsStateWithLifecycle()`` API that you already know about.

   However, for the sake of this exercise, you're going to implement an alternative. If
   you wanted to move the ``uiState`` mapping logic to the Compose world, you could use
   the `produceState <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#produceState(kotlin.Any,kotlin.coroutines.SuspendFunction1)>`__
   API.

   ``produceState`` allows you to convert non-Compose state into Compose `State <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/State>`__.
   It launches a coroutine scoped to the Composition that can push values into the
   returned ``State`` using the ``value`` property. As with ``LaunchedEffect``,
   ``produceState`` also takes keys to cancel and restart the computation.

   For your use case, you can use ``produceState`` to emit ``uiState`` updates with an
   initial value of ``DetailsUiState(isLoading = true)`` as follows:

   .. code:: prettyprint

      // details/DetailsActivity.kt file

      import androidx.compose.runtime.produceState

      @Composable
      fun DetailsScreen(
          onErrorLoading: () -> Unit,
          modifier: Modifier = Modifier,
          viewModel: DetailsViewModel = viewModel()
      ) {

          val uiState by produceState(initialValue = DetailsUiState(isLoading = true)) {
              // In a coroutine, this can call suspend functions or move
              // the computation to different Dispatchers
              val cityDetailsResult = viewModel.cityDetails
              value = if (cityDetailsResult is Result.Success<ExploreModel>) {
                  DetailsUiState(cityDetailsResult.data)
              } else {
                  DetailsUiState(throwError = true)
              }
          }

          // TODO: ... 
      }

   Next, depending on the ``uiState``, you show the data, show the loading screen, or
   report the error. Here's the complete code for the ``DetailsScreen`` composable:

   .. code:: prettyprint

      // details/DetailsActivity.kt file

      import androidx.compose.foundation.layout.Box
      import androidx.compose.material.CircularProgressIndicator

      @Composable
      fun DetailsScreen(
          onErrorLoading: () -> Unit,
          modifier: Modifier = Modifier,
          viewModel: DetailsViewModel = viewModel()
      ) {
          val uiState by produceState(initialValue = DetailsUiState(isLoading = true)) {
              val cityDetailsResult = viewModel.cityDetails
              value = if (cityDetailsResult is Result.Success<ExploreModel>) {
                  DetailsUiState(cityDetailsResult.data)
              } else {
                  DetailsUiState(throwError = true)
              }
          }

          when {
              uiState.cityDetails != null -> {
                  DetailsContent(uiState.cityDetails!!, modifier.fillMaxSize())
              }
              uiState.isLoading -> {
                  Box(modifier.fillMaxSize()) {
                      CircularProgressIndicator(
                          color = MaterialTheme.colors.onSurface,
                          modifier = Modifier.align(Alignment.Center)
                      )
                  }
              }
              else -> { onErrorLoading() }
          }
      }

   If you run the app, you'll see how the loading spinner appears before showing the city
   details.

   |aa8fd1ac660266e9.gif|

   **Note:** ``collectAsStateWithLifecycle()`` API uses ``produceState()`` API under the
   hood.


10. derivedStateOf
------------------


   The last improvement you're going to make to Crane is showing a button to *Scroll to
   top* whenever you scroll in the flight destinations list after you pass the first
   element of the screen. Tapping the button takes you to the first element on the list.

   |2c112d73f48335e0.gif|

   Open the ``base/ExploreSection.kt`` file that contains this code. The
   ``ExploreSection`` composable corresponds to what you see in the backdrop of the
   scaffold.

   To calculate whether the user has passed the first item, use
   `LazyColumn <https://developer.android.google.cn/jetpack/compose/lists>`__'s
   `LazyListState <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/LazyListState>`__
   and check if ``listState.firstVisibleItemIndex > 0``.

   A naive implementation would look like the following:

   .. code:: prettyprint

      // DO NOT DO THIS - It's executed on every recomposition
      val showButton = listState.firstVisibleItemIndex > 0

   This solution is not as efficient as it could be, because the composable function
   reading ``showButton`` recomposes as often as ``firstVisibleItemIndex`` changes - which
   happens frequently when scrolling. Instead, you want the function to recompose only
   when the condition changes between ``true`` and ``false``.

   There's an API that allows you to do this: the `derivedStateOf <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#derivedStateOf(kotlin.Function0)>`__
   API.

   ``listState`` is an observable Compose ``State``. Your calculation, ``showButton``,
   also needs to be a Compose ``State`` since you want the UI to recompose when its value
   changes, and show or hide the button.

   Use ``derivedStateOf`` when you want a Compose ``State`` that's derived from another
   ``State``. The ``derivedStateOf`` calculation block is executed every time the internal
   state changes, but the composable function only recomposes when the result of the
   calculation is different from the last one. This minimizes the amount of times
   functions reading ``showButton`` recompose.

   Using the ``derivedStateOf`` API in this case is a better and more efficient
   alternative. You'll also wrap the call with the ``remember`` API, so the calculated
   value survives recomposition.

   .. code:: prettyprint

      // Show the button if the first visible item is past
      // the first item. We use a remembered derived state to
      // minimize unnecessary recompositions
      val showButton by remember {
          derivedStateOf {
              listState.firstVisibleItemIndex > 0
          }
      }

   The new code for the ``ExploreSection`` composable should be familiar to you already.
   You're using a ``Box`` to place the ``Button`` that is shown conditionally on top of
   ``ExploreList``. And you use ``rememberCoroutineScope`` to call the
   ``listState.scrollToItem`` suspend function inside the ``Button``'s ``onClick``
   callback.

   .. code:: prettyprint

      // base/ExploreSection.kt file

      import androidx.compose.material.FloatingActionButton
      import androidx.compose.runtime.derivedStateOf
      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.remember
      import androidx.compose.runtime.rememberCoroutineScope
      import androidx.compose.foundation.layout.navigationBarsPadding
      import kotlinx.coroutines.launch

      @Composable
      fun ExploreSection(
          modifier: Modifier = Modifier,
          title: String,
          exploreList: List<ExploreModel>,
          onItemClicked: OnExploreItemClicked
      ) {
          Surface(modifier = modifier.fillMaxSize(), color = Color.White, shape = BottomSheetShape) {
              Column(modifier = Modifier.padding(start = 24.dp, top = 20.dp, end = 24.dp)) {
                  Text(
                      text = title,
                      style = MaterialTheme.typography.caption.copy(color = crane_caption)
                  )
                  Spacer(Modifier.height(8.dp))
                  Box(Modifier.weight(1f)) {
                      val listState = rememberLazyListState()
                      ExploreList(exploreList, onItemClicked, listState = listState)

                      // Show the button if the first visible item is past
                      // the first item. We use a remembered derived state to
                      // minimize unnecessary compositions
                      val showButton by remember {
                          derivedStateOf {
                              listState.firstVisibleItemIndex > 0
                          }
                      }
                      if (showButton) {
                          val coroutineScope = rememberCoroutineScope()
                          FloatingActionButton(
                              backgroundColor = MaterialTheme.colors.primary,
                              modifier = Modifier
                                  .align(Alignment.BottomEnd)
                                  .navigationBarsPadding()
                                  .padding(bottom = 8.dp),
                              onClick = {
                                  coroutineScope.launch {
                                      listState.scrollToItem(0)
                                  }
                              }
                          ) {
                              Text("Up!")
                          }
                      }
                  }
              }
          }
      }

   If you run the app, you'll see the button appearing at the bottom once you scroll and
   pass the first element of the screen.

   **Note:** To learn more about the ``derivedStateOf()`` API, see the 
   `When should I use derivedStateOf? <https://medium.com/androiddevelopers/jetpack-compose-when-should-i-use-derivedstateof-63ce7954c11b>`__
   blog post.


11. Congratulations!
--------------------


   Congratulations, you've successfully completed this codelab and learned advanced
   concepts of state and side-effect APIs in a Jetpack Compose app!

   You learned about how to create state holders, side effect APIs such as
   `LaunchedEffect <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#LaunchedEffect(kotlin.Any,kotlin.coroutines.SuspendFunction1)>`__,
   `rememberUpdatedState <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#rememberUpdatedState(kotlin.Any)>`__,
   `DisposableEffect <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#DisposableEffect(kotlin.Any,kotlin.Function1)>`__,
   `produceState <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#produceState(kotlin.Any,kotlin.coroutines.SuspendFunction1)>`__,
   and `derivedStateOf <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/package-summary#derivedStateOf(kotlin.Function0)>`__,
   and how to use coroutines in Jetpack Compose.


What's next?


   Check out the other codelabs on the `Compose pathway <https://developer.android.google.cn/courses/pathways/compose>`__, 
   and other `code samples <http://goo.gle/compose-samples>`__, including Crane.


Documentation


   For more information and guidance about these topics, check out the following
   documentation:

   -  `State and Jetpack Compose <https://developer.android.google.cn/jetpack/compose/state>`__
   -  `Lifecycle of composables <https://developer.android.google.cn/jetpack/compose/lifecycle>`__
   -  `Side-effects in Compose <https://developer.android.google.cn/jetpack/compose/side-effects>`__
   -  `Compose and other libraries <https://developer.android.google.cn/jetpack/compose/libraries>`__
   -  `Architecting your Compose UI <https://developer.android.google.cn/jetpack/compose/architecture>`__

.. |b2c6b8989f4332bb.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-advanced-state-side-effects/img/b2c6b8989f4332bb.gif
.. |android_studio_folder.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-advanced-state-side-effects/img/bb745dc85ae69f6b.png
.. |162c42b19dafa701.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-advanced-state-side-effects/img/162c42b19dafa701.png
.. |b2c6b8989f4332bb.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-advanced-state-side-effects/img/b2c6b8989f4332bb.gif
.. |66ae2543faaf2e91.png| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-advanced-state-side-effects/img/66ae2543faaf2e91.png
.. |d656748c7c583eb8.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-advanced-state-side-effects/img/d656748c7c583eb8.gif
.. |e3fd932a5b95faa0.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-advanced-state-side-effects/img/e3fd932a5b95faa0.gif
.. |92957c04a35e91e3.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-advanced-state-side-effects/img/92957c04a35e91e3.gif
.. |dde9ef06ca4e5191.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-advanced-state-side-effects/img/dde9ef06ca4e5191.gif
.. |aa8fd1ac660266e9.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-advanced-state-side-effects/img/aa8fd1ac660266e9.gif
.. |2c112d73f48335e0.gif| image:: https://developer.android.google.cn/static/codelabs/jetpack-compose-advanced-state-side-effects/img/2c112d73f48335e0.gif


ğŸš€ Jetpack Compose Navigation
==============================

https://developer.android.google.cn/codelabs/jetpack-compose-navigation?hl=en


1. Introduction
---------------


   **Last Updated:** 2022-07-25


**What you'll need**


   -  `Latest Android Studio <https://developer.android.google.cn/studio>`__
   -  Knowledge of Kotlin and `trailing lambdas <https://kotlinlang.org/docs/lambdas.html#lambda-expression-syntax>`__
   -  Basic understanding of navigation and its terms, like back stack
   -  Basic understanding of Compose
   -  Consider taking the `Jetpack Compose basics codelab <https://codelabs.developers.google.cn/codelabs/jetpack-compose-basics/>`__
      before this
   -  Basic understanding of state management in Compose
   -  Consider taking the `State in Jetpack Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-state>`__
      before this


**Navigating with Compose**


   `Navigation <https://developer.android.google.cn/guide/navigation>`__ is a Jetpack
   library that enables navigating from one destination within your app to another. The
   Navigation library also provides a specific artifact to enable consistent and idiomatic
   `navigation with Jetpack Compose <https://developer.android.google.cn/jetpack/compose/navigation>`__. 
   This artifact (``navigation-compose``) is the focal point of this codelab.


**What you'll do**


   You're going to use the `Rally Material study <https://material.io/design/material-studies/rally.html#about-rally>`__ 
   as the base for this codelab to implement the Jetpack Navigation component and enable
   navigation between composable Rally screens.


**What you'll learn**


   -  Basics of using Jetpack Navigation with Jetpack Compose
   -  Navigating between composables
   -  Integrating a custom tab bar composable into your navigation hierarchy
   -  Navigating with arguments
   -  Navigating using deep links
   -  Testing navigation


2. Setup
--------


   To follow along, clone the starting point (``main`` branch) for the codelab.

   ::

      $ git clone https://github.com/android/codelab-android-compose.git

   Alternatively, you can download two zip files:

   -  `Starting point <https://github.com/android/codelab-android-compose/archive/refs/heads/main.zip>`__
   -  `Solution <https://github.com/android/codelab-android-compose/archive/refs/heads/end.zip>`__

   Now that you've downloaded the code, open the **NavigationCodelab** project folder in
   Android Studio. You're now ready to get started.

   The compose-codelabs repo contains starter code for all codelabs in the pathway.

   For this codelab, use the **NavigationCodelab** project.

   -  |android_studio_folder.png| **NavigationCodelab** â€” Project that contains the start
      and finished code for this codelab

   The project is built in multiple git branches:

   -  **main** â€“ the **starter code** for this project, you will make changes to this to
      complete the codelab
   -  **end** â€“ contains the **solution** to this codelab


3. Overview of the Rally app
----------------------------


   As a first step, you should get familiar with the Rally app and its codebase. Run the
   app and explore it a bit.

   Rally has three main screens as composables:

   1. **``OverviewScreen``** â€” overview of all financial transactions and alerts
   2. **``AccountsScreen``** â€” insights into existing accounts
   3. **``BillsScreen``** â€” scheduled expenses

   |Screenshot of the overview screen containing information on Alerts, Accounts and
   Bills.| |Screenshot of the Accounts Screen, containing information on several
   accounts.| |Screenshot of the Bills Screen, containing information on several outgoing
   bills.|

   At the very top of the screen, Rally is using a **custom tab bar composable** 
   (``RallyTabRow`` ) to navigate between these three screens. Tapping on each
   icon should expand the current selection and take you to its corresponding screen:

   |336ba66858ae3728.png| |e26281a555c5820d.png|

   When navigating to these composable screens, you can also think of them as *navigation
   destinations*, as we want to land on each at a specific point. These destinations are
   predefined in the ``RallyDestinations.kt`` file.

   Inside, you will find all three main destinations defined as objects
   (``Overview, Accounts`` and ``Bills``) as well as a ``SingleAccount``, which will be
   added to the app later. Each object extends from the ``RallyDestination`` interface and
   contains the necessary information on each destination for navigation purposes:

   1. An ``icon`` for the top bar
   2. A String ``route`` (which is necessary for the Compose Navigation as a path that
      leads to that destination)
   3. A ``screen`` representing the entire composable for this destination

   When you run the app, you will notice that you can actually navigate between the
   destinations currently using the top bar. However, the app isn't in fact using Compose
   Navigation, but instead its current navigation mechanism is relying on some manual
   switching of composables and triggering `recomposition <https://developer.android.google.cn/jetpack/compose/mental-model#recomposition>`__
   to show the new content. Therefore, the goal of this codelab is to successfully migrate
   and implement Compose Navigation.


4. Migrating to Compose Navigation
----------------------------------


   The basic migration to Jetpack Compose follows several steps:

   1. Add the latest `Compose Navigation dependency <https://mvnrepository.com/artifact/androidx.navigation/navigation-compose>`__
   2. Set up the `NavController <https://developer.android.google.cn/jetpack/compose/navigation#getting-started>`__
   3. Add a `NavHost <https://developer.android.google.cn/jetpack/compose/navigation#create-navhost>`__
      and create the navigation graph
   4. Prepare routes for navigating between different app destinations
   5. Replace the current navigation mechanism with Compose Navigation

   Let's cover these steps one by one, in more detail.


Add the Navigation dependency


   Open the app's build file, found at ``app/build.gradle``. In the dependencies section,
   add the ``navigation-compose`` dependency.

   .. code:: prettyprint

      dependencies {
        implementation "androidx.navigation:navigation-compose:{latest_version}"
        // ...
      }

   You can find the latest version of navigation-compose `here <https://developer.android.google.cn/jetpack/androidx/releases/navigation>`__.

   Now, sync the project and you're ready to start using Navigation in Compose.


**Set up the NavController**


   The `NavController <https://developer.android.google.cn/jetpack/compose/navigation#getting-started>`__
   is the central component when using Navigation in Compose. It keeps track of back stack
   composable entries, moves the stack forward, enables back stack manipulation, and
   navigates between destination states. Because ``NavController`` is central to
   navigation, it has to be created as a first step in setting up Compose Navigation.

   A ``NavController`` is obtained by calling the `rememberNavController() <https://developer.android.google.cn/reference/kotlin/androidx/navigation/compose/package-summary#rememberNavController(kotlin.Array)>`__
   function. This creates and `remembers <https://developer.android.google.cn/jetpack/compose/state#state-in-composables>`__
   a ``NavController`` which survives configuration changes (using
   `rememberSaveable <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/saveable/package-summary#rememberSaveable(kotlin.Array,androidx.compose.runtime.saveable.Saver,kotlin.String,kotlin.Function0)>`__).

   **Note:** This codelab will not explain the basics of state management in Compose. If
   you need to learn more about this, consider reading through 
   `State and Jetpack Compose documentation <https://developer.android.google.cn/jetpack/compose/state>`__ 
   or taking the `State in Jetpack Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-state#0>`__.

   You should always create and place the ``NavController`` at the top level in your
   composable hierarchy, usually within your ``App`` composable. Then, all composables
   that need to reference the ``NavController`` have access to it. This follows the
   principles of `state hoisting <https://developer.android.google.cn/jetpack/compose/state#state-hoisting>`__
   and ensures the ``NavController`` is the main source of truth for navigating between
   composable screens and maintaining the back stack.

   Open ``RallyActivity.kt``. Fetch the ``NavController`` by using
   ``rememberNavController()`` within ``RallyApp``, as it is the root composable and the
   entry point for the entire application:

   .. code:: prettyprint

      import androidx.navigation.compose.rememberNavController
      // ...

      @Composable
      fun RallyApp() {
          RallyTheme {
              var currentScreen: RallyDestination by remember { mutableStateOf(Overview) }
              val navController = rememberNavController()
              Scaffold(
                  // ...
              ) { 
                  // ...
             }
      }


**Routes in Compose Navigation**


   As previously mentioned, Rally App has three main destinations and one additional to be
   added later (``SingleAccount``). These are defined in ``RallyDestinations.kt``. and we
   mentioned that each destination has a defined ``icon``, ``route`` and ``screen``:

   |Screenshot of the overview screen containing information on Alerts, Accounts and
   Bills.| |Screenshot of the Accounts Screen, containing information on several
   accounts.| |Screenshot of the Bills Screen, containing information on several outgoing
   bills.|

   The next step is to add these destinations to your navigation graph, with ``Overview``
   as the start destination when the app is launched.

   When using Navigation within Compose, each composable destination in your navigation
   graph is associated with a
   `route <https://developer.android.google.cn/jetpack/compose/navigation#create-navhost>`__.
   Routes are represented as Strings that define the path to your composable and guide
   your ``navController`` to land on the right place. You can think of it as an implicit
   deep link that leads to a specific destination. **Each destination must have a unique
   route**.

   To accomplish this, we'll use the ``route`` property of each ``RallyDestination``
   object. For example, ``Overview.route`` is the route that will take you to the
   ``Overview`` screen composable.


**Calling the NavHost composable with the navigation graph**


   The next step is to add a `NavHost <https://developer.android.google.cn/jetpack/compose/navigation#create-navhost>`__
   and create your navigation graph.

   The 3 main parts of Navigation are the ``NavController``, ``NavGraph``, and
   ``NavHost``. The ``NavController`` is always associated with a single ``NavHost``
   composable. The ``NavHost`` acts as a container and is responsible for displaying the
   current destination of the graph. As you navigate between composables, the content of
   the ``NavHost`` is automatically `recomposed <https://developer.android.google.cn/jetpack/compose/mental-model#recomposition>`__.
   It also links the ``NavController`` with a navigation graph ( `NavGraph <https://developer.android.google.cn/reference/androidx/navigation/NavGraph>`__)
   that maps out the composable destinations to navigate between. It is essentially a
   collection of fetchable destinations.

   Go back to the ``RallyApp`` composable in ``RallyActivity.kt``. Replace the ``Box``
   composable inside the ``Scaffold``, which contains the current screen's contents for
   manual switching of the screens, with a new ``NavHost`` that you can create by
   following the code example below.

   Pass in the ``navController`` we created in the previous step to hook it up to this
   ``NavHost``. As mentioned previously, each ``NavController`` must be associated with a
   single ``NavHost``.

   The ``NavHost`` also needs a ``startDestination`` route to know which destination to
   show when the app is launched, so set this to ``Overview.route``. Additionally, pass a
   ``Modifier`` to accept the outer ``Scaffold`` padding and apply it to the ``NavHost``.

   The final parameter ``builder: NavGraphBuilder.() -> Unit`` is responsible for defining
   and building the navigation graph. It uses the lambda syntax from the 
   `Navigation Kotlin DSL <https://developer.android.google.cn/guide/navigation/navigation-kotlin-dsl#navgraphbuilder>`__,
   so it can be passed as a trailing lambda inside the body of the function and pulled out
   of the parentheses:

   .. code:: prettyprint

      import androidx.navigation.compose.NavHost
      ...

      Scaffold(...) { innerPadding ->
          NavHost(
              navController = navController,
              startDestination = Overview.route,
              modifier = Modifier.padding(innerPadding)
          ) { 
             // builder parameter will be defined here as the graph
          }
      }


Adding destinations to the **NavGraph**


   Now, you can define your navigation graph and the destinations that the
   ``NavController`` can navigate to. As mentioned, the ``builder`` parameter expects a
   function, so Navigation Compose provides the `NavGraphBuilder.composable <https://developer.android.google.cn/reference/kotlin/androidx/navigation/compose/package-summary#(androidx.navigation.NavGraphBuilder).composable(kotlin.String,%20kotlin.collections.List,%20kotlin.collections.List,%20kotlin.Function1)>`__
   extension function to easily add individual composable destinations to the navigation
   graph and define the necessary navigation information.

   The first destination will be ``Overview``, so you need to add it via the
   ``composable`` extension function and set its unique String ``route``. This just adds
   the destination to your nav graph, so you also need to define the actual UI to be
   displayed when you navigate to this destination. This will also be done via a trailing
   lambda inside the body of the ``composable`` function, a 
   `pattern that is frequently used in Compose <https://developer.android.google.cn/jetpack/compose/kotlin#trailing-lambdas>`__:

   .. code:: prettyprint

      import androidx.navigation.compose.composable
      // ...

      NavHost(
          navController = navController,
          startDestination = Overview.route,
          modifier = Modifier.padding(innerPadding)
      ) { 
          composable(route = Overview.route) { 
              Overview.screen()
          }
      }

   Following this pattern, we'll add all three main screen composables as three
   destinations:

   .. code:: prettyprint

      NavHost(
          navController = navController,
          startDestination = Overview.route,
          modifier = Modifier.padding(innerPadding)
      ) { 
          composable(route = Overview.route) {
              Overview.screen()
          }
          composable(route = Accounts.route) {
              Accounts.screen()
          }
          composable(route = Bills.route) {
              Bills.screen()
          }
      }

   Now run the app - you will see the ``Overview`` as the start destination and its
   corresponding UI shown.

   We mentioned before a custom top tab bar, ``RallyTabRow`` composable, that previously
   handled the manual navigation between the screens. At this point, it's not yet
   connected with the new navigation, so you can verify that clicking on the tabs won't
   change the destination of the displayed screen composable. Let's fix that next!


5. Integrate RallyTabRow with navigation
----------------------------------------


   In this step, you'll wire up the ``RallyTabRow`` with the ``navController`` and the
   navigation graph to enable it to navigate to the correct destinations.

   To do this, you need to use your new ``navController`` to define the correct navigation
   action for the ``RallyTabRow``'s ``onTabSelected`` callback. This callback defines what
   should happen when a specific tab icon is selected and performs the navigation action
   via `navController.navigate(route) <https://developer.android.google.cn/jetpack/compose/navigation#nav-to-composable>`__\ ``.``

   **Note:** To make your code testable and reusable, it is advised not to pass the entire
   ``navController`` to your composables directly. Instead, you should always provide
   callbacks that define the exact navigation actions you wish to trigger.

   Following this guidance, in ``RallyActivity``, find the ``RallyTabRow`` composable and
   its callback parameter ``onTabSelected``.

   Since we want the tab to navigate to a specific destination when tapped, you also need
   to know which exact tab icon was selected. Luckily,
   ``onTabSelected: (RallyDestination) -> Unit`` parameter provides this already. You will
   use that information and the ``RallyDestination`` route to guide your ``navController``
   and call ``navController.navigate(newScreen.route)`` when a tab is selected:

   .. code:: prettyprint

      @Composable
      fun RallyApp() {
          RallyTheme {
              var currentScreen: RallyDestination by remember { mutableStateOf(Overview) }
              val navController = rememberNavController()
              Scaffold(
                  topBar = {
                      RallyTabRow(
                          allScreens = rallyTabRowScreens,
                          // Pass the callback like this,
                          // defining the navigation action when a tab is selected:
                          onTabSelected = { newScreen ->
                              navController.navigate(newScreen.route)
                          },
                          currentScreen = currentScreen,
                      )
                  }

   If you run the app now, you can verify that tapping on individual tabs in
   ``RallyTabRow`` does indeed navigate to the correct composable destination. However,
   there are currently two issues you might have noticed:

   1. Retapping the same tab in a row launches the multiple copies of the same destination
   2. The tab's UI is not matching the correct destination shown - meaning, the expanding
      and collapsing of selected tabs isn't working as intended:

   |336ba66858ae3728.png| |e26281a555c5820d.png|

   Let's fix both!


**Launching a single copy of a destination**


   To fix the first issue and make sure there will be at most one copy of a given
   destination on the top of the back stack, Compose Navigation API provides a
   `launchSingleTop <https://developer.android.google.cn/reference/kotlin/androidx/navigation/NavOptionsBuilder#launchSingleTop()>`__
   flag you can pass to your ``navController.navigate()`` action, like this:

   ``navController.navigate(route) { launchSingleTop = true }``

   Since you want this behavior across the app, for every destination, instead of copy
   pasting this flag to all of your .\ ``navigate(...)`` calls, you can extract it into a
   helper extension at the bottom of your ``RallyActivity``:

   .. code:: prettyprint

      import androidx.navigation.NavHostController
      // ...

      fun NavHostController.navigateSingleTopTo(route: String) =
          this.navigate(route) { launchSingleTop = true }

   Now you can replace the ``navController.navigate(newScreen.route)`` call with
   ``navigateSingleTopTo(...)``. Rerun the app and verify you will now get only one
   copy of a single destination when clicking multiple times on its icon in the top bar:

   .. code:: prettyprint

      @Composable
      fun RallyApp() {
          RallyTheme {
              var currentScreen: RallyDestination by remember { mutableStateOf(Overview) }
              val navController = rememberNavController()
              Scaffold(
                  topBar = {
                      RallyTabRow(
                          allScreens = rallyTabRowScreens,
                          onTabSelected = { newScreen ->
                              navController
                                  .navigateSingleTopTo(newScreen.route)
                          },
                          currentScreen = currentScreen,
                      )
                  }


**Controlling the navigation options and back stack state**


   Apart from ``launchSingleTop``, there are also other flags that you can use from the
   `NavOptionsBuilder <https://developer.android.google.cn/reference/kotlin/androidx/navigation/NavOptionsBuilder>`__
   to control and customize your navigation behavior even more. Since our ``RallyTabRow``
   acts similarly to a `BottomNavigation <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/package-summary#BottomNavigation(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,kotlin.Function1)>`__,
   you should also think about whether you want to save and restore a destination state
   when you navigate to and from it. For example, if you scroll to the bottom of Overview
   and then navigate to Accounts and back, do you want to keep the scroll position? Do you
   want to re-tap on the same destination in the ``RallyTabRow`` to reload your screen
   state or not? These are all valid questions and should be determined by the
   requirements of your own app design.

   We will cover some additional options that you can use within the same
   ``navigateSingleTopTo`` extension function:

   -  ``launchSingleTop = true`` - as mentioned, this makes sure there will be at most one
      copy of a given destination on the top of the back stack
   -  In Rally app, this would mean that re-tapping the same tab multiple times doesn't
      launch multiple copies of the same destination
   -  ``popUpTo(startDestination) { saveState = true }`` - pop up to the start destination
      of the graph to avoid building up a large stack of destinations on the back stack as
      you select tabs
   -  In Rally, this would mean that pressing the back arrow from any destination would
      pop the entire back stack to Overview
   -  ``restoreState = true`` - determines whether this navigation action should restore
      any state previously saved by ``PopUpToBuilder.saveState`` or the
      ``popUpToSaveState`` attribute. Note that, if no state was previously saved with the
      destination ID being navigated to, **this has no effect**
   -  In Rally, this would mean that, re-tapping the same tab would keep the previous data
      and user state on the screen without reloading it again

   You can add all of these options one by one to the code, run the app after each and
   verify the exact behavior after adding each flag. That way, you'll be able to see in
   practice how each flag changes the navigation and back stack state:

   .. code:: prettyprint

      import androidx.navigation.NavHostController
      import androidx.navigation.NavGraph.Companion.findStartDestination
      // ...

      fun NavHostController.navigateSingleTopTo(route: String) =
          this.navigate(route) { 
              popUpTo(
                  this@navigateSingleTopTo.graph.findStartDestination().id
              ) {
                  saveState = true
              }
              launchSingleTop = true
              restoreState = true
      }

   **Note:** If you need more guidance on managing multiple back stacks, take a look at
   the `documentation on supporting multiple backstacks <https://developer.android.google.cn/guide/navigation/multi-back-stacks>`__.


**Fixing the tab UI**


   At the very start of the codelab, while still using the manual navigation mechanism,
   ``RallyTabRow`` was using the ``currentScreen`` variable to determine whether to expand
   or collapse each tab.

   However, after the changes you've made, ``currentScreen`` will no longer be updated.
   This is why expanding and collapsing of selected tabs inside the ``RallyTabRow``
   doesn't work anymore.

   To re-enable this behavior using Compose Navigation, you need to know at each point
   what is the current destination shown, or in navigation terms, what is the top of your
   current back stack entry, and then update your ``RallyTabRow`` every time this changes.

   To get real time updates on your current destination from the back stack in a form of
   `State <https://developer.android.google.cn/reference/kotlin/androidx/compose/runtime/State>`__,
   you can use `navController.currentBackStackEntryAsState() <https://developer.android.google.cn/reference/kotlin/androidx/navigation/compose/package-summary#(androidx.navigation.NavController).currentBackStackEntryAsState()>`__
   and then grab its current ``destination:``

   **Note:** This codelab will not explain the basics of state management in Compose. If
   you need to learn more about this, consider reading through 
   `State and Jetpack Compose documentation <https://developer.android.google.cn/jetpack/compose/state>`__ 
   or taking the `State in Jetpack Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-state#0>`__.

   .. code:: prettyprint

      import androidx.navigation.compose.currentBackStackEntryAsState
      import androidx.compose.runtime.getValue
      // ...

      @Composable
      fun RallyApp() {
          RallyTheme {
              val navController = rememberNavController()

              val currentBackStack by navController.currentBackStackEntryAsState()
              // Fetch your currentDestination: 
              val currentDestination = currentBackStack?.destination
              // ...
          }
      }

   ``currentBackStack?.destination`` returns `NavDestination <https://developer.android.google.cn/reference/kotlin/androidx/navigation/NavDestination>`__\ ``.``\ To
   properly update the ``currentScreen`` again, you need to find a way of matching the
   return `NavDestination <https://developer.android.google.cn/reference/kotlin/androidx/navigation/NavDestination>`__
   with one of Rally's three main screen composables. You must determine which one is
   *currently* shown so that you can then pass this information to the ``RallyTabRow.`` As
   mentioned previously, each destination has a unique route, so we can use this String
   route as an ID of sorts to do a verified comparison and find a unique match.

   To update the ``currentScreen``, you need to iterate through the ``rallyTabRowScreens``
   list to find a matching route and then return the corresponding ``RallyDestination``.
   Kotlin provides a handy `.find() <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/find.html>`__
   function for that:

   .. code:: prettyprint

      import androidx.navigation.compose.currentBackStackEntryAsState
      import androidx.compose.runtime.getValue
      // ...

      @Composable
      fun RallyApp() {
          RallyTheme {
              val navController = rememberNavController()

              val currentBackStack by navController.currentBackStackEntryAsState()
              val currentDestination = currentBackStack?.destination

              // Change the variable to this and use Overview as a backup screen if this returns null
              val currentScreen = rallyTabRowScreens.find { it.route == currentDestination?.route } ?: Overview
              // ...
          }
      }

   Since ``currentScreen`` is already being passed to the ``RallyTabRow``, you can run the
   app and verify the tab bar UI is now being updated accordingly.

   **Note:** At this point, the back behavior navigation is supported as well for free,
   through the Navigation Component. You don't have to do any additional setup for it.
   Switching between the destinations and then pressing the back button will result in
   popping the back stack correctly and bringing you to the previous destination.


6. Extracting screen composables from RallyDestinations
-------------------------------------------------------


   Until now, for simplicity, we were using the ``screen`` property from the
   ``RallyDestination`` interface and the screen objects extending from it, to add the
   composable UI in the ``NavHost (RallyActivity.kt``):

   .. code:: prettyprint

      import com.example.compose.rally.ui.overview.OverviewScreen
      // ...

      NavHost(
          navController = navController,
          startDestination = Overview.route,
          modifier = Modifier.padding(innerPadding)
      ) { 
          composable(route = Overview.route) { 
              Overview.screen()
          }
          // ...
      }

   However, the following steps in this codelab (such as click events) require passing
   additional information to your composable screens directly. In a production
   environment, there will certainly be even more data that would need to be passed.

   The correct- and cleaner!- way of achieving this would be to add the composables
   directly in the ``NavHost`` navigation graph and extract them from the
   ``RallyDestination``. After that, ``RallyDestination`` and the screen objects would
   only hold navigation-specific information, like the ``icon`` and ``route``, and would
   be decoupled from anything Compose UI related.

   Open ``RallyDestinations.kt``. Extract each screen's composable from the ``screen``
   parameter of ``RallyDestination`` objects and into the corresponding ``composable``
   functions in your ``NavHost``, replacing the previous ``.screen()`` call, like
   this:

   .. code:: prettyprint

      import com.example.compose.rally.ui.accounts.AccountsScreen
      import com.example.compose.rally.ui.bills.BillsScreen
      import com.example.compose.rally.ui.overview.OverviewScreen
      // ...

      NavHost(
          navController = navController,
          startDestination = Overview.route,
          modifier = Modifier.padding(innerPadding)
      ) {
          composable(route = Overview.route) {
              OverviewScreen()
          }
          composable(route = Accounts.route) {
              AccountsScreen()
          }
          composable(route = Bills.route) {
              BillsScreen()
          }
      }

   At this point you can safely remove the ``screen`` parameter from ``RallyDestination``
   and its objects:

   .. code:: prettyprint

      interface RallyDestination {
          val icon: ImageVector
          val route: String
      }

      /**
       * Rally app navigation destinations
       */
      object Overview : RallyDestination {
          override val icon = Icons.Filled.PieChart
          override val route = "overview"
      }
      // ...

   Run the app again and verify that everything is still working as before. Now that
   you've completed this step, you'll be able to set up click events inside your
   composable screens.


**Enable clicks on OverviewScreen**


   Currently, any click events in your ``OverviewScreen`` are ignored. This means that the
   Accounts and Bills subsection "SEE ALL" buttons are clickable, but do not in fact take
   you anywhere. The goal of this step is to enable navigation for these click events.

   |Screen recording of the overview screen, scrolling to eventual click destinations, and
   attempting to click. Clicks don't work as they aren't implemented yet.|

   ``OverviewScreen`` composable can accept several functions as callbacks to set as click
   events, which, for this case, should be navigation actions taking you to
   ``AccountsScreen`` or ``BillsScreen``. Let's pass these navigation callbacks to
   ``onClickSeeAllAccounts`` and ``onClickSeeAllBills`` to navigate to relevant
   destinations.

   Open ``RallyActivity.kt``, find ``OverviewScreen`` within ``NavHost`` and pass
   ``navController.navigateSingleTopTo(...)`` to both navigation callbacks with the
   corresponding routes:

   .. code:: prettyprint

      OverviewScreen(
          onClickSeeAllAccounts = {
              navController.navigateSingleTopTo(Accounts.route) 
          },
          onClickSeeAllBills = { 
              navController.navigateSingleTopTo(Bills.route) 
          }
      )

   The ``navController`` will now have sufficient information, like the route of the exact
   destination\ ``,``\ to navigate to the right destination on a button click. If you look
   at the implementation of ``OverviewScreen``, you will see that these callbacks are
   already being set to the corresponding ``onClick`` parameters\ ``:``

   .. code:: prettyprint

      @Composable
      fun OverviewScreen(...) {
          // ...
          AccountsCard(
              onClickSeeAll = onClickSeeAllAccounts,
              onAccountClick = onAccountClick
          )
          // ...
          BillsCard(
              onClickSeeAll = onClickSeeAllBills
          )
      }

   As mentioned previously, keeping the ``navController`` at the top level of your
   navigation hierarchy and hoisted to the level of your ``App`` composable (instead of
   passing it directly into, for example, ``OverviewScreen)`` makes it easy to preview,
   reuse and test ``OverviewScreen`` composable in isolation â€“ without having to rely on
   an actual or mocked ``navController`` instances. Passing callbacks instead also allows
   quick changes to your click events!


7. Navigating to SingleAccountScreen with arguments
---------------------------------------------------


   Let's add some new functionality to our ``Accounts`` and ``Overview`` screens!
   Currently, these screens display a list of several different types of accounts -
   "Checking", "Home Savings" etc.

   |2f335ceab09e449a.png| |2e78a5e090e3fccb.png|

   However, clicking on these account types doesn't do anything (yet!). Let's fix this!
   When we tap on each account type, we want to show a new screen with the full account
   details. To do so, we need to provide additional information to our ``navController``
   about which exact account type we're clicking on. This can be done via `arguments <https://developer.android.google.cn/jetpack/compose/navigation#nav-with-args>`__.

   Arguments are a very powerful tool that make navigation routing dynamic by passing one
   or more arguments to a route. It enables displaying different information based on the
   different arguments provided.

   **Note:** A named argument is defined by appending it to routes inside curly braces,
   like this: ``{argument}``. It is a syntax that looks similar to Kotlin's String
   template syntax, using the dollar sign, if necessary, to escape variable names, like:
   ``${argument}``

   In ``RallyApp``, add a new destination ``SingleAccountScreen``, which will handle
   displaying these individual accounts, to the graph by adding a new ``composable``
   function to the existing ``NavHost:``

   .. code:: prettyprint

      import com.example.compose.rally.ui.accounts.SingleAccountScreen
      // ...

      NavHost(
          navController = navController,
          startDestination = Overview.route,
          modifier = Modifier.padding(innerPadding)
      ) {
          ...
          composable(route = SingleAccount.route) {
              SingleAccountScreen()
          }
      }


**Set up the SingleAccountScreen landing destination**


   When you land on ``SingleAccountScreen``, this destination would require additional
   information to know which exact account type it should display when opened. We can use
   arguments to pass this kind of information. You need to specify that its route
   additionally requires an argument ``{account_type}``. If you take a look at the
   ``RallyDestination`` and its ``SingleAccount`` object, you will notice that this
   argument has already been defined for you to use, as an ``accountTypeArg`` String.

   To pass the argument alongside your route when navigating, you need to append them
   together, following a pattern: ``"route/{argument}"``. In your case, that would look
   like this: ``"${SingleAccount.route}/{${SingleAccount.accountTypeArg}}"``. Remember
   that $ sign is used to escape variables:

   .. code:: prettyprint

      import androidx.navigation.NavType
      import androidx.navigation.compose.navArgument
      // ...

      composable(
          route =
              "${SingleAccount.route}/{${SingleAccount.accountTypeArg}}"
      ) { 
          SingleAccountScreen()
      }

   This will ensure that, when an action is triggered to navigate to
   ``SingleAccountScreen``, an ``accountTypeArg`` argument must be passed as well,
   otherwise the navigation will be unsuccessful. Think of it as a signature or a contract
   that needs to be followed by other destinations that want to navigate to
   ``SingleAccountScreen``.

   **Note:** To make your code safer and handle any edge cases, you can also set default
   values to arguments and specify their type explicitly.

   Second step to this is to make this ``composable`` aware that it should accept
   arguments. You do that by defining its ``arguments`` parameter. You could define as
   many arguments as you need, as the ``composable`` function by default accepts a list of
   arguments. In your case, you just need to add a single one called ``accountTypeArg``
   and add some additional safety by specifying it as type ``String``. If you don't set a
   type explicitly, it will be inferred from the default value of this argument:

   .. code:: prettyprint

      import androidx.navigation.NavType
      import androidx.navigation.compose.navArgument
      // ...

      composable(
          route =
              "${SingleAccount.route}/{${SingleAccount.accountTypeArg}}",
          arguments = listOf(
              navArgument(SingleAccount.accountTypeArg) { type = NavType.StringType }
          )
      ) { 
          SingleAccountScreen()
      }

   This would work perfectly and you could choose to keep the code like this. However,
   since all of our destination specific information is in ``RallyDestinations.kt`` and
   its objects, let's continue using the same approach (just as we did above for
   ``Overview``, ``Accounts,``\ and ``Bills``) and move this list of arguments into
   ``SingleAccount:``

   .. code:: prettyprint

      object SingleAccount : RallyDestination {
          // ...
          override val route = "single_account"
          const val accountTypeArg = "account_type"
          val arguments = listOf(
              navArgument(accountTypeArg) { type = NavType.StringType }
          )
      }

   Replace the previous arguments with ``SingleAccount.arguments`` now back into the
   NavHost corresponding ``composable``. This also ensures we keep the ``NavHost`` as
   clean and readable as possible:

   .. code:: prettyprint

      composable(
          route = "${SingleAccount.route}/{${SingleAccount.accountTypeArg}}",
          arguments =  SingleAccount.arguments
      ) {
          SingleAccountScreen()
      }

   Now that you've defined your complete route with arguments for ``SingleAccountScreen``,
   the next step is to make sure this ``accountTypeArg`` is passed down further to the
   ``SingleAccountScreen`` composable, so that it knows which account type to display
   correctly. If you look at the implementation of the ``SingleAccountScreen``, you will
   see that it's already set up and waiting to accept an ``accountType`` parameter:

   .. code:: prettyprint

      fun SingleAccountScreen(
          accountType: String? = UserData.accounts.first().name
      ) { 
         // ... 
      }

   To recap, so far:

   -  You've made sure we define the route to request arguments, as a signal to its
      preceding destinations
   -  You made sure that the ``composable`` knows it needs to accept arguments

   Our final step is to actually **retrieve the passed argument** value somehow.

   In Compose Navigation, each ``NavHost`` composable function has access to the current
   `NavBackStackEntry <https://developer.android.google.cn/reference/kotlin/androidx/navigation/NavBackStackEntry>`__
   - a class which holds the information on the current route and passed arguments of an
   entry in the back stack. You can use this to get the required ``arguments`` list from
   ``navBackStackEntry`` and then search and retrieve the exact argument you need, to pass
   it down further to your composable screen.

   In this case, you will request ``accountTypeArg`` from the ``navBackStackEntry``. Then,
   you need to pass it down further to ``SingleAccountScreen'``\ s ``accountType``
   parameter.

   You also could provide a default value for the argument, as a placeholder, in case it
   has not been provided and make your code ever safer by covering this edge case.

   Your code should now look like this:

   .. code:: prettyprint

      NavHost(...) {
          // ...
          composable(
              route =
                "${SingleAccount.route}/{${SingleAccount.accountTypeArg}}",
              arguments = SingleAccount.arguments
          ) { navBackStackEntry ->
              // Retrieve the passed argument
              val accountType =
                  navBackStackEntry.arguments?.getString(SingleAccount.accountTypeArg)

              // Pass accountType to SingleAccountScreen
              SingleAccountScreen(accountType)
          }
      }

   Now your ``SingleAccountScreen`` has the necessary information to display the correct
   account type when you navigate to it. If you look at the implementation of
   ``SingleAccountScreen,`` you can see that it already does the matching of the passed
   ``accountType`` to the ``UserData`` source to fetch the corresponding account details.

   Let's do one minor optimization task again and move the
   ``"${SingleAccount.route}/{${SingleAccount.accountTypeArg}}"`` route as well into
   ``RallyDestinations.kt`` and its ``SingleAccount`` object\ ``:``

   .. code:: prettyprint

      object SingleAccount : RallyDestination {
          // ...
          override val route = "single_account"
          const val accountTypeArg = "account_type"
          val routeWithArgs = "${route}/{${accountTypeArg}}"
          val arguments = listOf(
              navArgument(accountTypeArg) { type = NavType.StringType }
          )
      }

   And again, replace it in the corresponding ``NavHost composable:``

   .. code:: prettyprint

      // ...
      composable(
          route = SingleAccount.routeWithArgs,
          arguments = SingleAccount.arguments
      ) {...}


**Setup the Accounts and Overview starting destinations**


   Now that you've defined your ``SingleAccountScreen`` route and the argument it requires
   and accepts to make a successful navigation to ``SingleAccountScreen``, you need to
   make sure that the same ``accountTypeArg`` argument is being passed from the previous
   destination (meaning, whichever destination you're coming from).

   As you can see, there are two sides to this - the starting destination that provides
   and passes an argument and the landing destination that accepts that argument and uses
   it to display the correct information. **Both need to be defined explicitly.**

   As an example, when you're on the ``Accounts`` destination and you tap on "Checking"
   account type, the Accounts destination needs to pass a "Checking" String as an
   argument, appended to the "single_account" String route, to successfully open the
   corresponding ``SingleAccountScreen``. Its String route would look like this:
   ``"single_account/Checking"``

   You would use this exact same route with the passed argument when using the
   ``navController.navigateSingleTopTo(...),`` like this:

   ``navController.navigateSingleTopTo("${SingleAccount.route}/$accountType")``.

   Pass this navigation action callback to the ``onAccountClick`` parameter of
   ``OverviewScreen`` and ``AccountsScreen``. Note that these parameters are predefined
   as: ``onAccountClick: (String) -> Unit``, with String as input. This means that, when
   the user taps on a specific account type in ``Overview`` and ``Account``, that account
   type String will already be available to you and can easily be passed as an nav
   argument:

   .. code:: prettyprint

      OverviewScreen(
          // ...
          onAccountClick = { accountType ->
              navController
                .navigateSingleTopTo("${SingleAccount.route}/$accountType")
          }
      )
      // ...
                          
      AccountsScreen(
          // ...
          onAccountClick = { accountType ->
              navController
                .navigateSingleTopTo("${SingleAccount.route}/$accountType")
          }
      )

   To keep things readable, you could extract this navigation action into a private
   helper, extension function:

   .. code:: prettyprint

      import androidx.navigation.NavHostController
      // ...
      OverviewScreen(
          // ...
          onAccountClick = { accountType ->
              navController.navigateToSingleAccount(accountType)
          }
      )

      // ...
                          
      AccountsScreen(
          // ...
          onAccountClick = { accountType ->
              navController.navigateToSingleAccount(accountType)
          }
      )

      // ...

      private fun NavHostController.navigateToSingleAccount(accountType: String) {
          this.navigateSingleTopTo("${SingleAccount.route}/$accountType")
      }

   When you run the app at this point, you're able to click on each account type and will
   be taken to its corresponding ``SingleAccountScreen``, displaying data for the given
   account.

   |Screen recording of the overview screen, scrolling to eventual click destinations, and
   attempting to click. Clicks lead to destinations now.|


8. Enable deep link support
---------------------------


   In addition to adding arguments, you can also add `deep links <https://developer.android.google.cn/jetpack/compose/navigation#deeplinks>`__ to
   associate a specific URL, action, and/or mime type with a composable. In Android, a
   deep link is a link that takes you directly to a specific destination within an app.
   Navigation Compose supports `implicit deep links <https://developer.android.google.cn/guide/navigation/navigation-deep-link#implicit>`__.
   When an implicit deep link is invokedâ€”for example, when a user clicks a linkâ€”Android
   can then open your app to the corresponding destination.

   In this section, you'll add a new deep link for navigating to the
   ``SingleAccountScreen`` composable with a corresponding account type and enable this
   deep link to be exposed to external apps as well. To refresh your memory, the route for
   this composable was ``"single_account/{account_type}"`` and this is what you'll also
   use for the deep link, with some minor deep link related changes.

   Since exposing deep links to external apps isn't enabled by default , you must also add
   ``<intent-filter>`` elements to your app's ``manifest.xml`` file, so this will be your
   first step.

   Start by adding the deep link to the app's ``AndroidManifest.xml``. You need to create
   a new intent filter via ``<intent-filter>`` inside of the ``<activity>``, with the
   action ``VIEW`` and categories ``BROWSABLE`` and ``DEFAULT``.

   Then inside the filter, you need the ``data`` tag to add a **``scheme``** (``rally`` -
   name of your app) and **``host``** (``single_account`` - route to your composable) to
   define your precise deep link. This will give you ``rally://single_account`` as the
   deep link URL.

   Note that you don't need to declare the ``account_type`` argument in the
   ``AndroidManifest``. This will be appended later inside the ``NavHost`` composable
   function.

   .. code:: prettyprint

      <activity
          android:name=".RallyActivity"
          android:windowSoftInputMode="adjustResize"
          android:label="@string/app_name"
          android:exported="true">
          <intent-filter>
              <action android:name="android.intent.action.MAIN" />
              <category android:name="android.intent.category.LAUNCHER" />
          </intent-filter>
          <intent-filter>
              <action android:name="android.intent.action.VIEW" />
              <category android:name="android.intent.category.DEFAULT" />
              <category android:name="android.intent.category.BROWSABLE" />
              <data android:scheme="rally" android:host="single_account" />
          </intent-filter>
      </activity>


Trigger and verify the deep link


   Now you can react to the incoming intents from within ``RallyActivity``.

   The composable ``SingleAccountScreen`` accepts arguments already, but now it also needs
   to accept the newly created deep link to launch this destination when its deep link is
   triggered.

   Inside the composable function of ``SingleAccountScreen``, add one more parameter
   ``deepLinks``. Similarly to ``arguments,`` it also accepts a list of ``navDeepLink``,
   as you could define multiple deep links leading to the same destination. Pass the
   ``uriPattern``, matching the one defined in ``intent-filter`` in your manifest -
   ``rally://singleaccount``, but this time you'll also append its ``accountTypeArg``
   argument:

   .. code:: prettyprint

      import androidx.navigation.navDeepLink
      // ...

      composable(
          route = SingleAccount.routeWithArgs,
          // ...
          deepLinks = listOf(navDeepLink {
              uriPattern = "rally://${SingleAccount.route}/{${SingleAccount.accountTypeArg}}"
          })
      )

   You know what's next, right? Move this list into ``RallyDestinations SingleAccount:``

   .. code:: prettyprint

      object SingleAccount : RallyDestination {
          // ...
          val arguments = listOf(
              navArgument(accountTypeArg) { type = NavType.StringType }
          )
          val deepLinks = listOf(
             navDeepLink { uriPattern = "rally://$route/{$accountTypeArg}"}
          )
      }

   And again, replace it in the corresponding ``NavHost`` composable:

   .. code:: prettyprint

      // ...
      composable(
          route = SingleAccount.routeWithArgs,
          arguments = SingleAccount.arguments,
          deepLinks = SingleAccount.deepLinks
      ) {...}


Test the deep link using adb


   Now your app and ``SingleAccountScreen`` are ready to handle deep links. To test that
   it behaves correctly, do a fresh install of Rally on a connected emulator or device,
   open a command line and execute the following command, to simulate a deep link launch:

   .. code:: prettyprint

      adb shell am start -d "rally://single_account/Checking" -a android.intent.action.VIEW

   This will take you directly into the "Checking" account, but you can also verify it
   works correctly for all other account types.


9. Extract the NavHost into RallyNavHost
----------------------------------------


   Now your ``NavHost`` is complete. However, to make it testable and to keep your
   ``RallyActivity`` cleaner, you can extract your current ``NavHost`` and its helper
   functions, like ``navigateToSingleAccount``, from the ``RallyApp`` composable to its
   own composable function and name it ``RallyNavHost``.

   ``RallyApp`` is the one and only composable that should work directly with the
   ``navController``. As mentioned before, every other nested composable screen should
   only obtain navigation callbacks, not the ``navController`` itself.

   Therefore, the new ``RallyNavHost`` will accept the ``navController`` and ``modifier``
   as parameters from ``RallyApp``:

   .. code:: prettyprint

      @Composable
      fun RallyNavHost(
          navController: NavHostController,
          modifier: Modifier = Modifier
      ) {
          NavHost(
              navController = navController,
              startDestination = Overview.route,
              modifier = modifier
          ) {
              composable(route = Overview.route) {
                  OverviewScreen(
                      onClickSeeAllAccounts = {
                          navController.navigateSingleTopTo(Accounts.route)
                      },
                      onClickSeeAllBills = {
                          navController.navigateSingleTopTo(Bills.route)
                      },
                      onAccountClick = { accountType ->
                         navController.navigateToSingleAccount(accountType)
                      }
                  )
              }
              composable(route = Accounts.route) {
                  AccountsScreen(
                      onAccountClick = { accountType ->
                         navController.navigateToSingleAccount(accountType)
                      }
                  )
              }
              composable(route = Bills.route) {
                  BillsScreen()
              }
              composable(
                  route = SingleAccount.routeWithArgs,
                  arguments = SingleAccount.arguments,
                  deepLinks = SingleAccount.deepLinks
              ) { navBackStackEntry ->
                  val accountType =
                    navBackStackEntry.arguments?.getString(SingleAccount.accountTypeArg)
                  SingleAccountScreen(accountType)
              }
          }
      }

      fun NavHostController.navigateSingleTopTo(route: String) =
          this.navigate(route) { launchSingleTop = true }

      private fun NavHostController.navigateToSingleAccount(accountType: String) {
          this.navigateSingleTopTo("${SingleAccount.route}/$accountType")
      }

   Now add the new ``RallyNavHost`` to your ``RallyApp`` and rerun the app to verify
   everything works as previously:

   .. code:: prettyprint

      fun RallyApp() {
          RallyTheme {
          ...
              Scaffold(
              ...
              ) { innerPadding ->
                  RallyNavHost(
                      navController = navController,
                      modifier = Modifier.padding(innerPadding)
                  )
              }
           }
      }


10. Testing Compose Navigation
------------------------------


   **Note:** This codelab does not teach the Compose testing basics. To learn these, visit
   `Compose Testing documentation <https://developer.android.google.cn/jetpack/compose/testing>`__ 
   or `Testing in Jetpack Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-testing>`__.

   From the beginning of this codelab, you made sure not to pass the ``navController``
   directly into any composables (other than the high level app) and instead pass nav
   callbacks as parameters. This allows all your composables to be `individually testable <https://developer.android.google.cn/jetpack/compose/navigation#testing>`__,
   as they do not require an instance of ``navController`` in tests.

   You should always test that the entire Compose Navigation mechanism works as intended
   in your app, by testing ``RallyNavHost`` and navigation actions passed to your
   composables. These will be the main goals of this section. To test individual
   composable functions in isolation, make sure to check out the 
   `Testing in Jetpack Compose codelab. <https://developer.android.google.cn/codelabs/jetpack-compose-testing>`__

   To begin testing, we first need to add the necessary testing dependencies, so go back
   to your app's build file, found at ``app/build.gradle``. In the testing dependencies
   section, add the ``navigation-testing`` dependency:

   .. code:: prettyprint

      dependencies {
      // ...
        androidTestImplementation "androidx.navigation:navigation-testing:$rootProject.composeNavigationVersion"
        // ...
      }


Prepare the NavigationTest class


   Your ``RallyNavHost`` can be tested in isolation from the ``Activity`` itself.

   As this test still will run on an Android device, you'll need to create your test
   directory ``/app/src/androidTest/java/com/example/compose/rally`` , then create a new
   test file test class and name it ``NavigationTest``.

   As a first step, to use the Compose testing APIs, as well as test and control
   composables and applications using Compose, add a `Compose test rule <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/test/junit4/ComposeTestRule>`__:

   .. code:: prettyprint

      import androidx.compose.ui.test.junit4.createComposeRule
      import org.junit.Rule

      class NavigationTest {

          @get:Rule
          val composeTestRule = createComposeRule()

      }


**Write your first test**


   Create a public ``rallyNavHost`` test function and annotate it with ``@Test``. In that
   function, you first need to set the Compose content that you want to test. Do this,
   using ``composeTestRule``'s ``setContent``. It takes a composable parameter as body and
   enables you to write Compose code and add composables in a test environment, as if you
   were in a regular, production environment app.

   Inside the ``setContent``, you can set up your current test subject, ``RallyNavHost``
   and pass an instance of a new ``navController`` instance to it. The Navigation testing
   artifact provides a handy `TestNavHostController <https://developer.android.google.cn/reference/kotlin/androidx/navigation/testing/TestNavHostController>`__
   to use. So let's add this step:

   .. code:: prettyprint

      import androidx.compose.ui.platform.LocalContext
      import androidx.navigation.compose.ComposeNavigator
      import androidx.navigation.testing.TestNavHostController
      import org.junit.Assert.fail
      import org.junit.Test
      // ...

      class NavigationTest {

          @get:Rule
          val composeTestRule = createComposeRule()

          lateinit var navController: TestNavHostController

          @Test
          fun rallyNavHost() {
              composeTestRule.setContent {
                  // Creates a TestNavHostController
                  navController = 
                      TestNavHostController(LocalContext.current)
                  // Sets a ComposeNavigator to the navController so it can navigate through composables
                  navController.navigatorProvider.addNavigator(
                      ComposeNavigator()
                  )
                  RallyNavHost(navController = navController)
              }
              fail()
          }
      }

   If you copied above code, the ``fail()`` call will ensure that your test fails until
   there is an actual assertion made. It serves as a reminder to finish implementing the
   test.

   **Note:** To check that your ``RallyNavHost`` is working correctly, its hierarchy will
   have to be composed first before anything else can be tested. This means that your test
   assertions and verifications will have to be written **outside of and after** the
   ``setContent`` function.

   To verify that the correct screen composable is displayed, you can use its
   ``contentDescription`` and assert that it is displayed. In this codelab,
   ``contentDescription``\ s for Accounts and Overview destinations have previously been
   set, so you can already use them for test verifications.

   As a first verification, you should check that the Overview screen is displayed as the
   first destination when ``RallyNavHost`` is initialized for the first time. You should
   also rename the test to reflect that - call it
   ``rallyNavHost_verifyOverviewStartDestination``. Do this by replacing the ``fail()``
   call with the following:

   .. code:: prettyprint

      import androidx.compose.ui.test.assertIsDisplayed
      import androidx.compose.ui.test.onNodeWithContentDescription
      // ...

      class NavigationTest {

          @get:Rule
          val composeTestRule = createComposeRule()

          lateinit var navController: TestNavHostController

          @Test
          fun rallyNavHost_verifyOverviewStartDestination() {
              composeTestRule.setContent {
                  navController = 
                      TestNavHostController(LocalContext.current)
                  navController.navigatorProvider.addNavigator(
                      ComposeNavigator()
                  )
                  RallyNavHost(navController = navController)
              }

              composeTestRule
                  .onNodeWithContentDescription("Overview Screen")
                  .assertIsDisplayed()
          }
      }

   Run the test again, and verify that it passes.

   Since you need to setup ``RallyNavHost`` in the same way for each of the upcoming
   tests, you can extract its initialization into an annotated ``@Before`` function to
   avoid unnecessary repetition and keep your tests more concise:

   .. code:: prettyprint

      import org.junit.Before
      // ...

      class NavigationTest {

          @get:Rule
          val composeTestRule = createComposeRule()
          lateinit var navController: TestNavHostController

          @Before
          fun setupRallyNavHost() {
              composeTestRule.setContent {
                  navController = 
                      TestNavHostController(LocalContext.current)
                  navController.navigatorProvider.addNavigator(
                      ComposeNavigator()
                  )
                  RallyNavHost(navController = navController)
              }
          }

          @Test
          fun rallyNavHost_verifyOverviewStartDestination() {
              composeTestRule
                  .onNodeWithContentDescription("Overview Screen")
                  .assertIsDisplayed()
          }
      }


Navigating in tests


   You can test your navigation implementation in multiple ways, by performing clicks on
   the UI elements and then either verifying the displayed destination or by comparing the
   expected route against the current route.


**Testing via UI clicks and screen contentDescription**


   As you want to test your concrete app's implementation, clicks on the UI are
   preferable. Next text can verify that, while in the Overview screen, clicking on the
   "SEE ALL" button in the Accounts subsection takes you to the Accounts destination:

   |5a9e82acf7efdd5b.png|

   You will again use the ``contentDescription`` set on this specific button in the
   ``OverviewScreenCard`` composable, simulating a click on it via ``performClick()`` and
   verifying that the Accounts destination is then displayed:

   .. code:: prettyprint

      import androidx.compose.ui.test.performClick
      // ...

      @Test
      fun rallyNavHost_clickAllAccount_navigatesToAccounts() {
          composeTestRule
              .onNodeWithContentDescription("All Accounts")
              .performClick()

          composeTestRule
              .onNodeWithContentDescription("Accounts Screen")
              .assertIsDisplayed()
      }

   You can follow this pattern to test all of the remaining click navigation actions in
   the app.


Testing via UI clicks and routes comparison


   You also can use the ``navController`` to check your assertions by comparing the
   current String routes to the expected one. To do this, perform a click on the UI, same
   as in the previous section, and then, compare the current route to the one you expect,
   using ``navController.currentBackStackEntry?.destination?.route``.

   One additional step is to make sure you first scroll to the Bills subsection on your
   Overview screen, otherwise the test will fail as it wouldn't be able to find a node
   with ``contentDescription`` "All Bills":

   .. code:: prettyprint

      import androidx.compose.ui.test.performScrollTo
      import org.junit.Assert.assertEquals
      // ...

      @Test
      fun rallyNavHost_clickAllBills_navigateToBills() {
          composeTestRule.onNodeWithContentDescription("All Bills")
              .performScrollTo()
              .performClick()

          val route = navController.currentBackStackEntry?.destination?.route
          assertEquals(route, "bills")
      }

   **Note:** To learn more about advanced testing of navigation code, visit the 
   `Test Navigation <https://developer.android.google.cn/guide/navigation/navigation-testing>`__
   guide.

   Following these patterns, you can complete your test class by covering any additional
   navigation routes, destinations and click actions. Run the whole set of tests now to
   verify they are all passing.


11. Congratulations
-------------------


   Congratulations, you've successfully completed this codelab! You can find the 
   `solution code here <https://github.com/android/codelab-android-compose/tree/end/NavigationCodelab>`__
   and compare it with yours.

   You added Jetpack Compose navigation to the Rally app and now are familiar with its key
   concepts. You learned how to set up a navigation graph of composable destinations,
   define your navigation routes and actions, pass additional information to routes via
   arguments, set up deep links and test your navigation.

   For more topics and information, such as `bottom nav bar integration <https://developer.android.google.cn/jetpack/compose/navigation#bottom-nav>`__,
   multi-module navigation and `nested graphs <https://developer.android.google.cn/jetpack/compose/navigation#nested-nav>`__,
   you can check out the `Now in Android GitHub repository <https://github.com/android/nowinandroid>`__ 
   and see how it was implemented there.


**What's next?**


   Check out these materials to continue your `Jetpack Compose learning pathway <http://goo.gle/compose-pathway>`__ :

   -  `Testing Compose codelab <https://developer.android.google.cn/codelabs/jetpack-compose-testing>`__
   -  `Common Performance Gotchas in Jetpack Compose video <https://www.youtube.com/watch?v=EOQB8PTLkpY>`__

   More information on Jetpack Navigation:

   -  `Jetpack Navigation <https://developer.android.google.cn/guide/navigation>`__
   -  `Learn Jetpack Navigation codelab <https://developer.android.google.cn/codelabs/android-navigation>`__


Reference docs


   -  `Navigating with Compose documentation <https://developer.android.google.cn/jetpack/compose/navigation>`__
   -  `Navigation-Compose reference documentation <https://developer.android.google.cn/reference/kotlin/androidx/navigation/compose/package-summary>`__


.. |android_studio_folder.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-navigation/img/bb745dc85ae69f6b.png
.. |Screenshot of the overview screen containing information on Alerts, Accounts and Bills.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-navigation/img/87e7dfa76ef51d50.png
.. |Screenshot of the Accounts Screen, containing information on several accounts.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-navigation/img/a7c8a51fe2503409.png
.. |Screenshot of the Bills Screen, containing information on several outgoing bills.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-navigation/img/9e4c38a6bff0fdbb.png
.. |336ba66858ae3728.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-navigation/img/336ba66858ae3728.png
.. |e26281a555c5820d.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-navigation/img/e26281a555c5820d.png
.. |Screen recording of the overview screen, scrolling to eventual click destinations, and attempting to click. Clicks don't work as they aren't implemented yet.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-navigation/img/474a311ec9a31bbe.gif
.. |2f335ceab09e449a.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-navigation/img/2f335ceab09e449a.png
.. |2e78a5e090e3fccb.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-navigation/img/2e78a5e090e3fccb.png
.. |Screen recording of the overview screen, scrolling to eventual click destinations, and attempting to click. Clicks lead to destinations now.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-navigation/img/8a14184ac7649ca4.gif
.. |5a9e82acf7efdd5b.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-navigation/img/5a9e82acf7efdd5b.png


ğŸš€ Testing in Jetpack Compose
==============================

https://developer.android.google.cn/codelabs/jetpack-compose-testing?hl=en


1. Introduction and setup
-------------------------


   In this codelab you'll learn about testing UIs created with `Jetpack Compose <https://developer.android.google.cn/jetpack/compose>`__. 
   You will write your first tests while learning about testing in isolation, 
   debugging tests, semantics trees and synchronization.


What you'll need


   -  `Latest Android Studio <https://developer.android.google.cn/studio>`__
   -  Knowledge of Kotlin
   -  Basic understanding of Compose (such as the ``@Composable`` annotation)
   -  Basic familiarity with `modifiers <https://developer.android.google.cn/jetpack/compose/layouts/basics#modifiers>`__
   -  Optional: Consider taking the `Jetpack Compose basics codelab <https://codelabs.developers.google.cn/codelabs/jetpack-compose-basics/>`__
      before this codelab


Check out the code for this codelab (Rally)


   You're going to use the `Rally Material study <https://material.io/design/material-studies/rally.html#about-rally>`__ 
   as the base for this codelab. You'll find it in the android-compose-codelabs Github
   repository. To clone, run:

   .. code:: prettyprint

      git clone https://github.com/android/codelab-android-compose.git

   Once downloaded, open the ``TestingCodelab`` project.

   Alternatively, you can download two zip files:

   -  `Starting point <https://github.com/android/codelab-android-compose/archive/refs/heads/main.zip>`__
   -  `Solution <https://github.com/android/codelab-android-compose/archive/refs/heads/end.zip>`__

   Open the TestingCodelab folder, which contains an app called Rally.

   The compose-codelabs repo contains starter code for all codelabs in the pathway.

   For this codelab, use the **TestingCodelab** project.

   -  |android_studio_folder.png| **TestingCodelab** â€” Project that contains the start and
      finished code for this codelab

   The project is built in multiple git branches:

   -  **main** â€“ the starter code for this project, you will make changes to this to
      complete the codelab
   -  **end** â€“ contains the solution to this codelab


Examine the project structure


   Compose tests are instrumented tests. This means they require a device (physical device
   or emulator) to run on.

   Rally already contains some Instrumented UI tests. You can find them in the androidTest
   source set:

   |b14721ae60ee9022.png|

   This is the directory where you'll place the new tests. Feel free to take a look at the
   ``AnimatingCircleTests.kt`` file to learn what a Compose test looks like.

   Rally is already configured, but all you need to enable Compose tests in a new project
   is the testing dependencies in the ``build.gradle`` file of the relevant module, which
   are:

   .. code:: prettyprint

      androidTestImplementation "androidx.compose.ui:ui-test-junit4:$version"

      debugImplementation "androidx.compose.ui:ui-test-manifest:$rootProject.composeVersion"

   Note: For more information about how to set up testing in your Compose app, check out
   the `Testing documentation <https://developer.android.google.cn/jetpack/compose/testing#setup>`__.

   Feel free to run the app and familiarize yourself with it.


2. What to test?
----------------


   We're going to focus on Rally's tab bar, which contains a row of `tabs <https://material.io/components/tabs>`__ 
   (Overview, Accounts, and Bills). It looks like this in context:

   |19c6a7eb9d732d37.gif|

   In this codelab you'll test the UI of the bar.

   This could mean many things:

   -  Test that the tabs show the intended icon and text
   -  Test that the animation matches the spec
   -  Test that the triggered navigation events are correct
   -  Test the placement and distances of the UI elements in different states
   -  Take a screenshot of the bar and compare it with a previous screenshot

   There are no exact rules about how much or how to test a component. You could do all of
   the above! In this codelab you're going to test that the state logic is correct by
   verifying that:

   -  **A tab shows its label only when it is selected**.
   -  **The active screen defines the tab that is selected**


3. Create a simple UI test
--------------------------



Create the TopAppBarTest file


   Create a new file in the same folder as ``AnimatingCircleTests.kt``
   (``app/src/androidTest/com/example/compose/rally``) and call it ``TopAppBarTest.kt``.

   Compose comes with a ``ComposeTestRule`` that you can obtain by calling
   ``createComposeRule()``. This rule lets you set the Compose content under test and
   interact with it.


Add the ComposeTestRule


   .. code:: prettyprint

      package com.example.compose.rally

      import androidx.compose.ui.test.junit4.createComposeRule
      import org.junit.Rule

      class TopAppBarTest {

          @get:Rule
          val composeTestRule = createComposeRule()
          
          // TODO: Add tests
      }


Testing in isolation


   In a Compose test, we can start the app's main activity similarly to how you would do
   it in the Android View world using Espresso, for example. You can do this with
   ``createAndroidComposeRule``.

   .. code:: prettyprint

      // Don't copy this over

      @get:Rule
      val composeTestRule = createAndroidComposeRule(RallyActivity::class.java)

   However, with Compose, we can simplify things considerably by testing a component in
   isolation. You can choose what Compose UI content to use in the test. This is done with
   the ``setContent`` method of the ``ComposeTestRule``, and you can call it anywhere (but
   just once).

   .. code:: prettyprint

      // Don't copy this over

      class TopAppBarTest {

          @get:Rule
          val composeTestRule = createComposeRule()
          
          @Test
          fun myTest() {
              composeTestRule.setContent { 
                  Text("You can set any Compose content!")
              }
          }
      }

   We want to test the TopAppBar, so let's focus on that. Call ``RallyTopAppBar`` inside
   ``setContent`` and let Android Studio complete the names of the parameters.

   .. code:: prettyprint

      import androidx.compose.ui.test.junit4.createComposeRule
      import com.example.compose.rally.ui.components.RallyTopAppBar
      import org.junit.Rule
      import org.junit.Test

      class TopAppBarTest {

          @get:Rule
          val composeTestRule = createComposeRule()
          
          @Test
          fun rallyTopAppBarTest() {
              composeTestRule.setContent { 
                  RallyTopAppBar(
                      allScreens = ,
                      onTabSelected = { /*TODO*/ },
                      currentScreen = 
                  )
              }
          }
      }


The importance of a testable Composable


   ``RallyTopAppBar`` takes three parameters that are easy to provide so we can pass fake
   data that we control. For example:

   .. code:: prettyprint

          @Test
          fun rallyTopAppBarTest() {
              val allScreens = RallyScreen.values().toList()
              composeTestRule.setContent { 
                  RallyTopAppBar(
                      allScreens = allScreens,
                      onTabSelected = { },
                      currentScreen = RallyScreen.Accounts
                  )
              }
              Thread.sleep(5000)
          }

   We also add a ``sleep()`` so you can see what's going on. Right-click on the
   ``rallyTopAppBarTest`` and click on "Run rallyTopAppBarTest()...".

   |baca545ddc8c3fa9.png|

   The test shows the top app bar (for 5 seconds), but it doesn't look as we expected: it
   has a light theme!

   The reason is that the bar is built using Material Components, which expect to be
   within a `MaterialTheme <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/MaterialTheme>`__,
   else they fall back to "baseline" styles colors.

   `MaterialTheme <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/MaterialTheme>`__
   has good defaults so it doesn't crash. Since we're not going to test the theme or take
   screenshots, we can omit it and work with its default light theme. Feel free to wrap
   ``RallyTopAppBar`` with ``RallyTheme`` to fix it.


Verify that the tab is selected


   Finding UI elements, checking their properties and performing actions is done through
   the test rule, following this pattern:

   .. code:: prettyprint

      composeTestRule{.finder}{.assertion}{.action}

   In this test you will look for the word "Accounts" to verify that the label for the
   selected tab is shown.

   |baca545ddc8c3fa9.png|

   A good way to understand what tools are available is using the 
   `Compose Testing Cheat Sheet <https://developer.android.google.cn/jetpack/compose/testing-cheatsheet>`__ 
   or the `test package reference documentation <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/test/package-summary>`__.
   Look for finders and assertions that might help in our situation. For example:
   ``onNodeWithText``, ``onNodeWithContentDescription``, ``isSelected``,
   ``hasContentDescription``, ``assertIsSelected``...

   Each tab has a different content description:

   -  Overview
   -  Accounts
   -  Bills

   Knowing this, replace the ``Thread.sleep(5000)`` with a statement that looks for a
   content description and asserts that it exists:

   .. code:: prettyprint

      import androidx.compose.ui.test.assertIsSelected
      import androidx.compose.ui.test.onNodeWithContentDescription
      ...

      @Test
      fun rallyTopAppBarTest_currentTabSelected() {
          val allScreens = RallyScreen.values().toList()
          composeTestRule.setContent {
              RallyTopAppBar(
                  allScreens = allScreens,
                  onTabSelected = { },
                  currentScreen = RallyScreen.Accounts
              )
          }

          composeTestRule
              .onNodeWithContentDescription(RallyScreen.Accounts.name)
              .assertIsSelected()
      }

   Now run the test again and you should see a green test:

   |75bab3b37e795b65.png|

   **Congratulations!** You've written your first Compose test. You've learned how to test
   in isolation, and how to use finders and assertions.

   This was straightforward, but it required some previous knowledge about the component
   (the content descriptions and the *selected* property). You'll learn how to inspect
   what properties are available in the next step.


4. Debugging tests
------------------


   In this step you'll verify that the label of the current tab is displayed, in upper
   case.

   |baca545ddc8c3fa9.png|

   A possible solution would be to try to find the text and assert that it exists:

   .. code:: prettyprint

      import androidx.compose.ui.test.onNodeWithText
      ...

      @Test
      fun rallyTopAppBarTest_currentLabelExists() {
          val allScreens = RallyScreen.values().toList()
          composeTestRule.setContent {
              RallyTopAppBar(
                  allScreens = allScreens,
                  onTabSelected = { },
                  currentScreen = RallyScreen.Accounts
              )
          }

          composeTestRule
              .onNodeWithText(RallyScreen.Accounts.name.uppercase())
              .assertExists()
      }

   However, if you run the test, it fails ğŸ˜±

   |5755586203324389.png|

   In this step you'll learn how to debug this using the semantics tree.


Semantics tree


   Compose tests use a structure called the `semantics tree <https://developer.android.google.cn/jetpack/compose/testing#semantics>`__ 
   to look for elements on the screen and read their properties. This is the structure that
   accessibility services use as well, as they're meant to be read by a service such as
   `TalkBack <https://support.google.com/accessibility/android/answer/6283677>`__.

   Warning: Layout Inspector support for Semantics properties is not available yet.

   You can print the Semantics tree using the ``printToLog`` function on a node. Add a new
   line to the test:

   .. code:: prettyprint

      import androidx.compose.ui.test.onRoot
      import androidx.compose.ui.test.printToLog
      ...

      fun rallyTopAppBarTest_currentLabelExists() {
          val allScreens = RallyScreen.values().toList()
          composeTestRule.setContent {
              RallyTopAppBar(
                  allScreens = allScreens,
                  onTabSelected = { },
                  currentScreen = RallyScreen.Accounts
              )
          }

          composeTestRule.onRoot().printToLog("currentLabelExists")

          composeTestRule
              .onNodeWithText(RallyScreen.Accounts.name.uppercase())
              .assertExists() // Still fails
      }

   Now run the test and check out the Logcat in Android Studio (you can look for
   ``currentLabelExists``).

   .. code:: prettyprint

      ...com.example.compose.rally D/currentLabelExists: printToLog:
          Printing with useUnmergedTree = 'false'
          Node #1 at (l=0.0, t=63.0, r=1080.0, b=210.0)px
           |-Node #2 at (l=0.0, t=63.0, r=1080.0, b=210.0)px
             [SelectableGroup]
             MergeDescendants = 'true'
              |-Node #3 at (l=42.0, t=105.0, r=105.0, b=168.0)px
              | Role = 'Tab'
              | Selected = 'false'
              | StateDescription = 'Not selected'
              | ContentDescription = 'Overview'
              | Actions = [OnClick]
              | MergeDescendants = 'true'
              | ClearAndSetSemantics = 'true'
              |-Node #6 at (l=189.0, t=105.0, r=468.0, b=168.0)px
              | Role = 'Tab'
              | Selected = 'true'
              | StateDescription = 'Selected'
              | ContentDescription = 'Accounts'
              | Actions = [OnClick]
              | MergeDescendants = 'true'
              | ClearAndSetSemantics = 'true'
              |-Node #11 at (l=552.0, t=105.0, r=615.0, b=168.0)px
                Role = 'Tab'
                Selected = 'false'
                StateDescription = 'Not selected'
                ContentDescription = 'Bills'
                Actions = [OnClick]
                MergeDescendants = 'true'
                ClearAndSetSemantics = 'true'

   Hopefully now you understand the convenience of isolation. The semantics tree of a full
   app would be very long!

   Warning: Composables don't have IDs and you can't use the Node numbers shown in the
   tree to match them. If matching a node with its semantics properties is impractical or
   impossible, you can use the `testTag <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/platform/package-summary#(androidx.compose.ui.Modifier).testTag(kotlin.String)>`__
   modifier with the `hasTestTag <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/test/package-summary#hasTestTag(kotlin.String)>`__
   matcher as a last resort.

   Taking a look at the Semantics tree, you can see there is a ``SelectableGroup`` with 3
   child elements, which are the tabs of the top app bar. Turns out, there is no ``text``
   property with a value of "ACCOUNTS" and this is why the test fails. However, there is a
   **content description for each tab**. You can check how this property is set in the
   ``RallyTab`` composable inside ``RallyTopAppBar.kt``:

   .. code:: prettyprint

      private fun RallyTab(text: String...)
      ...
          Modifier
              .clearAndSetSemantics { contentDescription = text }

   This modifier is clearing the properties from descendants and setting its own content
   description, so that's why you see "Accounts" and not "ACCOUNTS".

   Replace the finder ``onNodeWithText`` with ``onNodeWithContentDescription`` and run the
   test again:

   .. code:: prettyprint

      fun rallyTopAppBarTest_currentLabelExists() {
          val allScreens = RallyScreen.values().toList()
          composeTestRule.setContent {
              RallyTopAppBar(
                  allScreens = allScreens,
                  onTabSelected = { },
                  currentScreen = RallyScreen.Accounts
              )
          }

          composeTestRule
              .onNodeWithContentDescription(RallyScreen.Accounts.name)
              .assertExists()
      }

   |b5a7ae9f8f0ed750.png|

   Congratulations! You've fixed the test and you learned about the ``ComposeTestRule``,
   testing in isolation, finders, assertions, and debugging with the Semantics tree.

   **Bad news though**: this test is not very useful! If you look at the Semantics tree
   closely, the content descriptions of all three tabs are there whether or not their tab
   is selected. We must go deeper!


5. Merged and unmerged Semantics trees
--------------------------------------


   The Semantics tree always tries to be as compact as possible, showing only the
   information that is relevant.

   For example, in our ``TopAppBar``, there is no need for the icons and labels to be
   different nodes. Take a look at the "Overview" node:

   |120e5327856286cd.png|

   .. code:: prettyprint

              |-Node #3 at (l=42.0, t=105.0, r=105.0, b=168.0)px
              | Role = 'Tab'
              | Selected = 'false'
              | StateDescription = 'Not selected'
              | ContentDescription = 'Overview'
              | Actions = [OnClick]
              | MergeDescendants = 'true'
              | ClearAndSetSemantics = 'true'

   This node has properties (such as ``Selected`` and ``Role``) that are defined
   specifically for a `selectable <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/selection/package-summary#selectable(androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.semantics.Role,kotlin.Function0)>`__
   component and a content description for the whole tab. These are high-level properties,
   very useful for simple tests. Details about the icon or the text would be redundant so
   they're not shown.

   Compose exposes these Semantics properties automatically in some composables such as
   ``Text``. You can also customize and **merge** them to represent a single component
   made up of one or multiple descendants. For example: you can represent a ``Button``
   containing a ``Text`` composable. The property ``MergeDescendants = 'true'`` is telling
   us that **this node had descendants, but they have been merged into it**. In tests we
   oftentimes need to access all nodes.

   In order to verify whether the ``Text`` inside the tab is displayed or not, we can
   query the **unmerged** Semantics tree passing ``useUnmergedTree = true`` to the
   ``onRoot`` finder.

   .. code:: prettyprint

      @Test
      fun rallyTopAppBarTest_currentLabelExists() {
          val allScreens = RallyScreen.values().toList()
          composeTestRule.setContent {
              RallyTopAppBar(
                  allScreens = allScreens,
                  onTabSelected = { },
                  currentScreen = RallyScreen.Accounts
              )
          }

          composeTestRule.onRoot(useUnmergedTree = true).printToLog("currentLabelExists")

      }

   The output in Logcat is slightly longer now:

   .. code:: prettyprint

          Printing with useUnmergedTree = 'true'
          Node #1 at (l=0.0, t=63.0, r=1080.0, b=210.0)px
           |-Node #2 at (l=0.0, t=63.0, r=1080.0, b=210.0)px
             [SelectableGroup]
             MergeDescendants = 'true'
              |-Node #3 at (l=42.0, t=105.0, r=105.0, b=168.0)px
              | Role = 'Tab'
              | Selected = 'false'
              | StateDescription = 'Not selected'
              | ContentDescription = 'Overview'
              | Actions = [OnClick]
              | MergeDescendants = 'true'
              | ClearAndSetSemantics = 'true'
              |-Node #6 at (l=189.0, t=105.0, r=468.0, b=168.0)px
              | Role = 'Tab'
              | Selected = 'true'
              | StateDescription = 'Selected'
              | ContentDescription = 'Accounts'
              | Actions = [OnClick]
              | MergeDescendants = 'true'
              | ClearAndSetSemantics = 'true'
              |  |-Node #9 at (l=284.0, t=105.0, r=468.0, b=154.0)px
              |    Text = 'ACCOUNTS'
              |    Actions = [GetTextLayoutResult]
              |-Node #11 at (l=552.0, t=105.0, r=615.0, b=168.0)px
                Role = 'Tab'
                Selected = 'false'
                StateDescription = 'Not selected'
                ContentDescription = 'Bills'
                Actions = [OnClick]
                MergeDescendants = 'true'
                ClearAndSetSemantics = 'true'

   Node #3 still has no descendants:

   .. code:: prettyprint

              |-Node #3 at (l=42.0, t=105.0, r=105.0, b=168.0)px
              | Role = 'Tab'
              | Selected = 'false'
              | StateDescription = 'Not selected'
              | ContentDescription = 'Overview'
              | Actions = [OnClick]
              | MergeDescendants = 'true'
              | ClearAndSetSemantics = 'true'

   But node 6, the selected tab, has one and we can now see the â€˜Text' property:

   .. code:: prettyprint

              |-Node #6 at (l=189.0, t=105.0, r=468.0, b=168.0)px
              | Role = 'Tab'
              | Selected = 'true'
              | StateDescription = 'Selected'
              | ContentDescription = 'Accounts'
              | Actions = [OnClick]
              | MergeDescendants = 'true'
              |  |-Node #9 at (l=284.0, t=105.0, r=468.0, b=154.0)px
              |    Text = 'ACCOUNTS'
              |    Actions = [GetTextLayoutResult]

   In order to verify the correct behavior as we wanted, you'll write a matcher that finds
   one node with text "ACCOUNTS" whose parent is a node with content description
   "Accounts".

   Check the `Compose Testing Cheat Sheet <https://developer.android.google.cn/jetpack/compose/testing-cheatsheet>`__ 
   again and try to find a way to write that matcher. Note that you can use boolean operators
   such as ``and`` and ``or`` with matchers.

   All finders have a parameter called ``useUnmergedTree``. Set it to ``true`` to use the
   unmerged tree.

   Try to write the test without looking at the solution!


*Solution*


   .. code:: prettyprint

      import androidx.compose.ui.test.hasParent
      import androidx.compose.ui.test.hasText
      ...

      @Test
      fun rallyTopAppBarTest_currentLabelExists() {
          val allScreens = RallyScreen.values().toList()
          composeTestRule.setContent {
              RallyTopAppBar(
                  allScreens = allScreens,
                  onTabSelected = { },
                  currentScreen = RallyScreen.Accounts
              )
          }

          composeTestRule
              .onNode(
                  hasText(RallyScreen.Accounts.name.uppercase()) and
                  hasParent(
                      hasContentDescription(RallyScreen.Accounts.name)
                  ),
                  useUnmergedTree = true
              )
              .assertExists()
      }

   Note: In this case, strictly, you don't have to add the parent to the matcher because
   it's a very isolated test. However, it's a good idea to avoid using broad finders alone
   (such as ``hasText``) which might fail in larger tests (when other instances of the
   text might be found).

   Go ahead and run it:

   |94c57e2cfc12c10b.png|

   Congratulations! In this step you've learned about property merging and the merged and
   unmerged Semantics trees.


6. Synchronization
------------------


   Any test that you write must be properly synchronized with the subject under test. For
   example, when you use a finder such as ``onNodeWithText``, the test waits until the app
   is *idle* before querying the semantics tree. Without synchronization, tests could look
   for elements before they're displayed or they could wait unnecessarily.

   We'll use the Overview screen for this step, which looks like this when you run the
   app:

   |8c467af3570b8de6.gif|

   Note the repeating flashing animation of the Alerts card, drawing attention to this
   element.

   Create another test class called ``OverviewScreenTest`` and add the following content:

   .. code:: prettyprint

      package com.example.compose.rally

      import androidx.compose.ui.test.assertIsDisplayed
      import androidx.compose.ui.test.junit4.createComposeRule
      import androidx.compose.ui.test.onNodeWithText
      import com.example.compose.rally.ui.overview.OverviewBody
      import org.junit.Rule
      import org.junit.Test

      class OverviewScreenTest {

          @get:Rule
          val composeTestRule = createComposeRule()

          @Test
          fun overviewScreen_alertsDisplayed() {
              composeTestRule.setContent {
                  OverviewBody()
              }

              composeTestRule
                  .onNodeWithText("Alerts")
                  .assertIsDisplayed()
          }
      }

   If you run this test, you'll notice it never finishes (it times out after 30 seconds).

   |b2d71bd417326bd3.png|

   The error says:

   .. code:: prettyprint

      androidx.compose.ui.test.junit4.android.ComposeNotIdleException: Idling resource timed out: possibly due to compose being busy.
      IdlingResourceRegistry has the following idling resources registered:
      - [busy] androidx.compose.ui.test.junit4.android.ComposeIdlingResource@d075f91 

   This is basically telling you that Compose is permanently busy so there is no way to
   synchronize the app with the test.

   You might already have guessed that the problem is the infinite flashing animation. The
   app is never idle so the test can't continue.

   Let's look at the implementation of the infinite animation:


app/src/main/java/com/example/compose/rally/ui/overview/OverviewBody.kt


   .. code:: prettyprint

      var currentTargetElevation by remember {  mutableStateOf(1.dp) }
      LaunchedEffect(Unit) {
          // Start the animation
          currentTargetElevation = 8.dp
      }
      val animatedElevation = animateDpAsState(
          targetValue = currentTargetElevation,
          animationSpec = tween(durationMillis = 500),
          finishedListener = {
              currentTargetElevation = if (currentTargetElevation > 4.dp) {
                  1.dp
              } else {
                  8.dp
              }
          }
      )
      Card(elevation = animatedElevation.value) { ... }

   This code is essentially waiting for an animation to finish (``finishedListener``) and
   then runs it again.

   One approach to fix this test would be to disable animations in developer options. It's
   one of the widely accepted ways of dealing with it in the ``View`` world.

   In Compose, the animation APIs were designed with testability in mind, so the problem
   can be fixed by using the correct API. Instead of restarting the `animateDpAsState <https://developer.android.google.cn/jetpack/compose/animation#animate-as-state>`__
   animation, we can use `infinite animations <https://developer.android.google.cn/jetpack/compose/animation#rememberinfinitetransition>`__.

   **Infinite animations** are a special case that Compose tests *understand* so they're
   not going to keep the test busy.

   Replace the code in ``OverviewScreen`` with the proper API:

   .. code:: prettyprint

      import androidx.compose.animation.core.RepeatMode
      import androidx.compose.animation.core.VectorConverter
      import androidx.compose.animation.core.animateValue
      import androidx.compose.animation.core.infiniteRepeatable
      import androidx.compose.animation.core.rememberInfiniteTransition
      import androidx.compose.animation.core.tween
      import androidx.compose.ui.unit.Dp
      ...

          val infiniteElevationAnimation = rememberInfiniteTransition()
          val animatedElevation: Dp by infiniteElevationAnimation.animateValue(
              initialValue = 1.dp,
              targetValue = 8.dp,
              typeConverter = Dp.VectorConverter,
              animationSpec = infiniteRepeatable(
                  animation = tween(500),
                  repeatMode = RepeatMode.Reverse
              )
          )
          Card(elevation = animatedElevation) {

   If you run the test, it will pass now:

   |369e266eed40e4e4.png|

   Congratulations! In this step you've learned about synchronization and how animations
   can affect tests.


7. Optional exercise
--------------------


   In this step, you'll use an action (see the `Testing Cheat Sheet <https://developer.android.google.cn/jetpack/compose/testing-cheatsheet>`__) 
   to verify that clicking on the different tabs of the ``RallyTopAppBar`` changes the
   selection.

   Hints:

   -  The scope of the test needs to include the state, which is owned by ``RallyApp``.
   -  Verify state, not behavior. Use assertions on the state of the UI instead of relying
      on which objects have been called and how.

   There's no provided solution for this exercise.


8. Next steps
-------------


   Congratulations! You've completed the **Testing in Jetpack Compose.** Now you have the
   basic building blocks to create a good testing strategy for your Compose UIs.

   If you want to learn more about Testing and Compose, check out these resources:

   1. The `testing documentation <https://developer.android.google.cn/jetpack/compose/testing#matchers>`__
      has more information about finders, assertions, actions and matchers, as well as
      synchronization mechanisms, time manipulation, etc.
   2. Bookmark the `Testing Cheat Sheet <https://developer.android.google.cn/jetpack/compose/testing-cheatsheet>`__!
   3. The Rally sample comes with a simple screenshot test class. Explore the
      ``AnimatingCircleTests.kt`` file to learn more about it.
   4. For general guidance about testing Android apps, you can follow these three
      codelabs:

   -  `Testing Basics <https://developer.android.google.cn/codelabs/advanced-android-kotlin-training-testing-basics/#0>`__
   -  `Dependency Injection and Test Doubles <https://developer.android.google.cn/codelabs/advanced-android-kotlin-training-testing-test-doubles>`__
   -  `Survey of Testing Topics <https://developer.android.google.cn/codelabs/advanced-android-kotlin-training-testing-survey>`__

   5. The `Compose samples <https://github.com/android/compose-samples>`__ repository on
      Github has multiple apps with UI tests.
   6. The `Jetpack Compose Pathway <http://goo.gle/compose-pathway>`__ shows a list of
      resources to get you started with Compose.

   Happy testing!


.. |android_studio_folder.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/bb745dc85ae69f6b.png
.. |b14721ae60ee9022.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/b14721ae60ee9022.png
.. |19c6a7eb9d732d37.gif| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/19c6a7eb9d732d37.gif
.. |baca545ddc8c3fa9.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/baca545ddc8c3fa9.png
.. |baca545ddc8c3fa9.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/baca545ddc8c3fa9.png
.. |75bab3b37e795b65.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/75bab3b37e795b65.png
.. |baca545ddc8c3fa9.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/baca545ddc8c3fa9.png
.. |5755586203324389.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/5755586203324389.png
.. |b5a7ae9f8f0ed750.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/b5a7ae9f8f0ed750.png
.. |120e5327856286cd.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/120e5327856286cd.png
.. |94c57e2cfc12c10b.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/94c57e2cfc12c10b.png
.. |8c467af3570b8de6.gif| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/8c467af3570b8de6.gif
.. |b2d71bd417326bd3.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/b2d71bd417326bd3.png
.. |369e266eed40e4e4.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-testing/img/369e266eed40e4e4.png


ğŸš€ Accessibility in Jetpack Compose
====================================

https://developer.android.google.cn/codelabs/jetpack-compose-accessibility?hl=en


1. Introduction
---------------


   In this codelab you will learn how to use Jetpack Compose to improve your app's
   accessibility. We will walk through several common use cases and improve a sample app
   step by step. We will cover touch target sizes, content descriptions, click labels, and
   more.

   People with impaired vision, color blindness, impaired hearing, impaired dexterity,
   cognitive disabilities, and many other disabilities use Android devices to complete
   tasks in their day-to-day lives. When you develop apps with accessibility in mind, you
   make the user experience better, particularly for users with these and other
   accessibility needs.

   During this codelab, we will use `TalkBack <https://support.google.com/accessibility/android/answer/6283677>`__ 
   to manually test our code changes. TalkBack is an accessibility service primarily used by
   people with visual impairments. Make sure to also test any changes to your code with
   other accessibility services, for example `Switch Access <https://support.google.com/accessibility/android/answer/6122836>`__.

   |TalkBack focus rectangle moving through the home screen of Jetnews. The text that
   TalkBack announces is shown at the bottom of the screen.|

   *TalkBack in action in the Jetnews app.*

   **Note:** You can also use the `Accessibility Scanner <https://support.google.com/accessibility/android/answer/6376570>`__ 
   to search for accessibility issues like touch target sizes. However, it doesn't 
   catch all issues, so manual testing is always required as well.


What you'll learn


   In this codelab, you will learn:

   -  How to cater to users with impaired dexterity by increasing touch target sizes.
   -  What semantics properties are and how you change them.
   -  How to provide information to composables to make them more accessible.


What you'll need


   -  Experience with Kotlin syntax, including lambdas.
   -  Basic experience with Compose. Consider taking the 
      `Jetpack Compose basics codelab <https://codelabs.developers.google.cn/codelabs/jetpack-compose-basics/>`__
      before this codelab.
   -  An Android device or emulator `with TalkBack enabled <https://support.google.com/accessibility/android/answer/6007100>`__.


What you'll build


   In this codelab we will improve the accessibility of a news-reading app. We will start
   with an app that misses vital accessibility features and apply what we learn to make
   our app more usable for people with accessibility needs.


2. Getting set up
-----------------


   In this step, you will download the code for this which comprises a simple news-reader
   app.


What you will need


   -  `Latest Android Studio <https://developer.android.google.cn/studio>`__


Get the code


   The code for this codelab can be found in the `Github repository <https://github.com/android/codelab-android-compose>`__. 
   To clone it, run:

   ::

      $ git clone https://github.com/android/codelab-android-compose

   Alternatively, you can download two zip files:

   -  `Starting point <https://github.com/android/codelab-android-compose/archive/refs/heads/main.zip>`__
   -  `Solution <https://github.com/android/codelab-android-compose/archive/refs/heads/end.zip>`__


Check out the sample app


   The code you just downloaded contains code for all Compose codelabs available. To
   complete this codelab, open the **``AccessibilityCodelab``** project inside Android
   Studio.

   The compose-codelabs repo contains starter code for all codelabs in the pathway.

   For this codelab, use the **AccessibilityCodelab** project.

   -  |android_studio_folder.png| **AccessibilityCodelab** â€” Project that contains the
      start and finished code for this codelab

   The project is built in multiple git branches:

   -  **main** â€“ Contains the starter code for this project, you will make changes to this
      to complete the codelab
   -  **end** â€“ Contains the solution to this codelab

   We recommend that you start with the code in the ``main`` branch and follow the codelab
   step-by-step at your own pace.


Set up TalkBack


   During this Codelab, we will use TalkBack to check our changes. When you use a physical
   device for testing, follow `these instructions to turn TalkBack on <https://support.google.com/accessibility/android/answer/6007100>`__. 
   Emulators don't come with TalkBack installed by default. Choose an emulator that includes the
   Play Store, and `download the Android Accessibility Suite <https://play.google.com/store/apps/details?id=com.google.android.marvin.talkback>`__.


3. Touch target size
--------------------


   Any on-screen element that someone can click, touch, or otherwise interact with should
   be large enough for reliable interaction. You should make sure these elements have a
   **width and height of at least 48dp**.

   If these controls are sized dynamically, or resize based on the size of their content,
   consider using the `sizeIn <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier).sizeIn(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)>`__
   modifier to set a lower bound on their dimensions.

   Some Material components set these sizes for you. For example, the Button composable
   has its `MinHeight <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/ButtonDefaults#MinHeight()>`__
   set to 36dp, and uses 8dp vertical padding. This adds up to the required 48dp height.

   When we open our sample app and run TalkBack, we will notice that the cross icon in the
   post cards has a very small touch target. We'd like this touch target to be at least
   48dp.

   Here's a screenshot with our original app on the left, versus our improved solution on
   the right.

   |Comparison of a list item showing a small outline of cross icon on the left, large
   outline on the right.|

   Let's look at the implementation and check the size of this composable. Open
   ``PostCards.kt`` and look for the ``PostCardHistory`` composable. As you can see, the
   implementation sets the size of the overflow menu icon to 24dp:

   .. code:: prettyprint

      @Composable
      fun PostCardHistory(post: Post, navigateToArticle: (String) -> Unit) {
         // ...

         Row(
             // ...
         ) {
             // ...
             CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                 Icon(
                     imageVector = Icons.Default.Close,
                     contentDescription = stringResource(R.string.cd_show_fewer),
                     modifier = Modifier
                         .clickable { openDialog = true }
                         .size(24.dp)
                 )
             }
         }
         // ...
      }

   To increase the touch target size of this ``Icon``, we can add padding:

   .. code:: prettyprint

      @Composable
      fun PostCardHistory(post: Post, navigateToArticle: (String) -> Unit) {
         // ...
         Row(
             // ...
         ) {
             // ...
             CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                 Icon(
                     imageVector = Icons.Default.Close,
                     contentDescription = stringResource(R.string.cd_show_fewer),
                     modifier = Modifier
                         .clickable { openDialog = true }
                         .padding(12.dp)
                         .size(24.dp)
                 )
             }
         }
         // ...
      }

   **Note:** The order of modifier functions is **significant**. Since each function makes
   changes to the ``Modifier`` returned by the previous function, the sequence affects the
   final result. In this case, we apply the ``padding`` *before* setting the size, but
   *after* applying the ``clickable`` modifier. This way the padding will be added to the
   size, and the whole element will be clickable.

   In our use case, there is an easier way to make sure the touch target is at least 48dp.
   We can make use of the Material component ``IconButton`` that will handle this for us:

   .. code:: prettyprint

      @Composable
      fun PostCardHistory(post: Post, navigateToArticle: (String) -> Unit) {
         // ...
         Row(
             // ...
         ) {
             // ...
             CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                 IconButton(onClick = { openDialog = true }) {
                     Icon(
                         imageVector = Icons.Default.Close,
                         contentDescription = stringResource(R.string.cd_show_fewer)
                     )
                 }
             }
         }
         // ...
      }

   Going through the screen with TalkBack now correctly shows a touch target area of 48dp.
   In addition, the ``IconButton`` also adds a ripple indication, which shows the user
   that the element is clickable.


4. Click labels
---------------


   Clickable elements in your app by default don't provide any information on what
   clicking that element will do. Therefore, accessibility services like TalkBack will use
   a very generic default description.

   To provide the best experience for users with accessibility needs, we can provide a
   specific description that explains what will happen when the user clicks this element.

   In the Jetnews app, users can click on the various post cards to read the full post. By
   default this will read out the content of the clickable element, followed by the text
   "Double tap to activate". Instead, we'd like to be more specific and use "Double tap to
   read article". This is what the original version looks like, compared to our ideal
   solution:

   |Two screen recordings with TalkBack enabled, tapping a post in a vertical list and a
   post in a horizontal carousel.|

   *Changing the click label of a composable. Before (on the left) vs after (on the
   right).*

   The ``clickable`` modifier includes a parameter that allows you to directly set this
   click label.

   Let's take another look at the ``PostCardHistory`` implementation:

   .. code:: prettyprint

      @Composable
      fun PostCardHistory(
         // ...
      ) {
         Row(
             Modifier.clickable { navigateToArticle(post.id) }
         ) {
             // ...
         }
      }

   As you can see, this implementation uses the ``clickable`` modifier. To set a click
   label, we can set the ``onClickLabel`` parameter:

   .. code:: prettyprint

      @Composable
      fun PostCardHistory(
         // ...
      ) {
         Row(
             Modifier.clickable(
                     // R.string.action_read_article = "read article"
                     onClickLabel = stringResource(R.string.action_read_article)
                 ) {
                     navigateToArticle(post.id)
                 }
         ) {
             // ...
         }
      }

   TalkBack now correctly announces "Double tap to **read article**".

   The other post cards in our home screen have the same generic click label. Let's take a
   look at the implementation of the ``PostCardPopular`` composable and update its click
   label:

   .. code:: prettyprint

      @Composable
      fun PostCardPopular(
         // ...
      ) {
         Card(
             shape = MaterialTheme.shapes.medium,
             modifier = modifier.size(280.dp, 240.dp),
             onClick = { navigateToArticle(post.id) }
         ) {
             // ...
         }
      }

   This composable uses the ``Card`` composable internally, which does not allow you to
   directly set the click label. Instead, you can use the ``semantics`` modifier to set
   the click label:

   .. code:: prettyprint

      @OptIn(ExperimentalMaterialApi::class)
      @Composable
      fun PostCardPopular(
         post: Post,
         navigateToArticle: (String) -> Unit,
         modifier: Modifier = Modifier
      ) {
         val readArticleLabel = stringResource(id = R.string.action_read_article)
         Card(
             shape = MaterialTheme.shapes.medium,
             modifier = modifier
                .size(280.dp, 240.dp)
                .semantics { onClick(label = readArticleLabel, action = null) },
             onClick = { navigateToArticle(post.id) }
         ) {
             // ...
         }
      }


5. Custom actions
-----------------


   Many apps show some sort of list, where each item in the list contains one or more
   actions. When using a screen reader, navigating such a list can become tedious, as the
   same action would be focused over and over again.

   Instead, we can add custom accessibility actions to a composable. This way the actions
   that relate to the same list item can be grouped together.

   In the Jetnews app, we're showing a list of articles that the user can read. Each list
   item includes an action to indicate that the user wants to see less of this topic. In
   this section we'll move this action to a custom accessibility action, so navigating
   through the list gets easier.

   On the left you can see the default situation, where each cross icon is focusable. On
   the right, you can see the solution, where the action is included in the custom actions
   in TalkBack:

   |Two screen recordings with TalkBack enabled. Screen on the left shows how the cross
   icon on the post item is selectable. Double tapping opens a dialog. Screen on the right
   shows using a three-tap gesture to open a custom Actions menu. Tapping action 'Show
   fewer of this' opens the same dialog.|

   *Adding a custom action to a post item. Before (on the left) vs after (on the right).*

   Let's open ``PostCards.kt`` and look at the implementation of the ``PostCardHistory``
   composable. Note the clickable properties of both the ``Row`` and ``IconButton``, using
   ``Modifier.clickable`` and ``onClick``:

   .. code:: prettyprint

      @Composable
      fun PostCardHistory(post: Post, navigateToArticle: (String) -> Unit) {
         // ...
         Row(
             Modifier.clickable(
                 onClickLabel = stringResource(R.string.action_read_article)
             ) {
                 navigateToArticle(post.id)
             }
         ) {
             // ...
             CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                 IconButton(onClick = { openDialog = true }) {
                     Icon(
                         imageVector = Icons.Default.Close,
                         contentDescription = stringResource(R.string.cd_show_fewer)
                     )
                 }
             }
         }
         // ...
      }

   By default, both the ``Row`` and the ``IconButton`` composable are clickable and as a
   result will be focused by TalkBack. This happens for each item in our list, which means
   a lot of swiping while navigating the list. We rather want the action related to the
   ``IconButton`` to be included as a custom action on the list item. We can tell
   Accessibility Services not to interact with this ``Icon`` by using the
   ``clearAndSetSemantics`` modifier:

   .. code:: prettyprint

      @Composable
      fun PostCardHistory(post: Post, navigateToArticle: (String) -> Unit) {
         // ...
         Row(
             Modifier.clickable(
                 onClickLabel = stringResource(R.string.action_read_article)
             ) {
                 navigateToArticle(post.id)
             }
         ) {
             // ...
             CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                  IconButton(
                      modifier = Modifier.clearAndSetSemantics { },
                      onClick = { openDialog = true }
                  ) {
                      Icon(
                          imageVector = Icons.Default.Close,
                          contentDescription = stringResource(R.string.cd_show_fewer)
                      )
                  }
             }
         }
         // ...
      }

   However, by removing the semantics of the ``IconButton``, there is now no way to
   execute the action anymore. We can add the action to the list item instead by adding a
   custom action in the ``semantics`` modifier:

   .. code:: prettyprint

      @Composable
      fun PostCardHistory(post: Post, navigateToArticle: (String) -> Unit) {
         // ...
         val showFewerLabel = stringResource(R.string.cd_show_fewer)
         Row(
              Modifier
                  .clickable(
                      onClickLabel = stringResource(R.string.action_read_article)
                  ) {
                      navigateToArticle(post.id)
                  }
                  .semantics {
                      customActions = listOf(
                          CustomAccessibilityAction(
                              label = showFewerLabel,
                              // action returns boolean to indicate success
                              action = { openDialog = true; true }
                          )
                      )
                  }
         ) {
             // ...
             CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                  IconButton(
                      modifier = Modifier.clearAndSetSemantics { },
                      onClick = { openDialog = true }
                  ) {
                      Icon(
                          imageVector = Icons.Default.Close,
                          contentDescription = showFewerLabel
                      )
                  }
             }
         }
         // ...
      }

   Now we can use the custom action popup in TalkBack to apply the action. This becomes
   more and more relevant as the number of actions inside a list item increases.


6. Visual element descriptions
------------------------------


   Not every user of your app will be able to see or interpret visual elements that show
   in the app, like icons and illustrations. There's also no way for accessibility
   services to make sense of visual elements based on their pixels alone. This makes it
   necessary for you as a developer to pass more information on the visual elements in
   your app to the accessibility services.

   Visual composables like `Image <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/package-summary#Image(androidx.compose.ui.graphics.vector.ImageVector,kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,androidx.compose.ui.layout.ContentScale,kotlin.Float,androidx.compose.ui.graphics.ColorFilter)>`__
   and `Icon <https://developer.android.google.cn/reference/androidx/wear/compose/material/IconKt#Icon(androidx.compose.ui.graphics.vector.ImageVector,kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color)>`__
   include a parameter ``contentDescription``. Here you pass a **localized** description
   of that visual element, or ``null`` if the element is purely decorative.

   **Note:** Choosing a fitting content description is not trivial. Read more guidance on
   choosing your content description on `Material Accessibility guidelines <https://material.io/design/usability/accessibility.html#imagery>`__ 
   or read the `W3C guide <https://www.w3.org/WAI/tutorials/images/>`__.

   In our app, the article screen is missing some content descriptions. Let's run the app
   and select the top article to navigate to the article screen.

   |Two screen recordings with TalkBack enabled, tapping the back button in the article
   screen. Left calls out 'Buttonâ€”double tap to activate'. Right calls out 'Navigate
   upâ€”double tap to activate'.|

   *Adding a visual content description. Before (on the left) vs after (on the right).*

   When we don't provide any information, the top left navigation icon will simply
   announce "Button, double tap to activate". This does not tell the user anything about
   the action that will be taken when they activate that button. Let's open
   ``ArticleScreen.kt``:

   .. code:: prettyprint

      @Composable
      fun ArticleScreen(
         // ...
      ) {
         // ...
         Scaffold(
             topBar = {
                 InsetAwareTopAppBar(
                     title = {
                         // ...
                     },
                     navigationIcon = {
                         IconButton(onClick = onBack) {
                             Icon(
                                 imageVector = Icons.Filled.ArrowBack,
                                 contentDescription = null
                             )
                         }
                     }
                 )
             }
         ) { 
             // ...
         }
      }

   Add a meaningful content description to the Icon:

   .. code:: prettyprint

      @Composable
      fun ArticleScreen(
         // ...
      ) {
         // ...
         Scaffold(
             topBar = {
                 InsetAwareTopAppBar(
                     title = {
                         // ...
                     },
                     navigationIcon = {
                         IconButton(onClick = onBack) {
                             Icon(
                                 imageVector = Icons.Filled.ArrowBack,
                                 contentDescription = stringResource(
                                     R.string.cd_navigate_up
                                 )
                             )
                         }
                     }
                 )
             }
         ) { 
             // ...
         }
      }

   Another visual element in this article is the header image. In our case, this image is
   purely decorative, it doesn't show anything that we need to convey to the user.
   Therefore, the content description is set to ``null`` and the element is skipped when
   we use an accessibility service.

   The last visual element in our screen is the profile picture. In this case we're using
   a generic avatar, so adding a content description here is not necessary. When we would
   use the actual profile picture of this author, we could ask them to 
   `provide a fitting content description <https://jakearchibald.com/2021/great-alt-text/>`__ 
   for it.


7. Headings
-----------


   When a screen contains a lot of text, like our article screen, it is quite hard for
   users with visual difficulties to quickly find the section they're looking for. To help
   with that, we can indicate which parts of the text are headings. Users can then
   navigate quickly through these different headings by swiping up or down.

   **Note:** You will have to configure your device to navigate by headings by 
   `following these instructions <https://support.google.com/accessibility/android/answer/6006598>`__. 
   The gestures will be different depending on your TalkBack version.

   By default, no composables are marked as headings, so there will be no navigation
   possible. We would like our article screen to provide heading by heading navigation:

   |Two screen recordings with TalkBack enabled, using swipe down to navigate through
   headings. Left screen reads out 'No next heading'. Right screen cycles through the
   headings and reads each of them out loud.|

   *Adding headings. Before (on the left) vs after (on the right).*

   The headings in our article are defined in ``PostContent.kt``. Let's open that file and
   scroll to the ``Paragraph`` composable:

   .. code:: prettyprint

      @Composable
      private fun Paragraph(paragraph: Paragraph) {
         // ...
         Box(modifier = Modifier.padding(bottom = trailingPadding)) {
             when (paragraph.type) {
                 // ...
                 ParagraphType.Header -> {
                     Text(
                         modifier = Modifier.padding(4.dp),
                         text = annotatedString,
                         style = textStyle.merge(paragraphStyle)
                     )
                 }
                 // ...
             }
         }
      }

   Here, the ``Header`` is defined as a simple ``Text`` composable. We can set the
   `heading <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/semantics/package-summary#(androidx.compose.ui.semantics.SemanticsPropertyReceiver).heading()>`__
   semantics property to indicate that this composable is a heading.

   .. code:: prettyprint

      @Composable
      private fun Paragraph(paragraph: Paragraph) {
         // ...
         Box(modifier = Modifier.padding(bottom = trailingPadding)) {
             when (paragraph.type) {
                 // ...
                 ParagraphType.Header -> {
                     Text(
                         modifier = Modifier.padding(4.dp)
                           .semantics { heading() },
                         text = annotatedString,
                         style = textStyle.merge(paragraphStyle)
                     )
                 }
                 // ...
             }
         }
      }


8. Custom merging
-----------------


   As we've seen in the previous steps, accessibility services like TalkBack navigate a
   screen element by element. By default, each low level composable in Jetpack Compose
   that sets *at least one* semantics property receives focus. So for example, a ``Text``
   composable sets the ``text`` semantics property and thus receives focus.

   However, having too many focusable elements on screen can lead to confusion as the user
   navigates them one by one. Instead, composables can be merged together using the
   `semantics <https://developer.android.google.cn/reference/kotlin/androidx/compose/ui/semantics/package-summary#(androidx.compose.ui.Modifier).semantics(kotlin.Boolean,kotlin.Function1)>`__
   modifier with its ``mergeDescendants`` property.

   Let's check our article screen. Most of the elements get the right level of focus. But
   the metadata of the article is currently read aloud as several separate items. It can
   be improved by merging that into one focusable entity:

   |Two screen recordings with TalkBack enabled. Left sreen shows separate green TalkBack
   rectangles for Author and Metadata fields. Right screen shows one rectangle around both
   fields and reads the concatenated content.|

   *Merging composables. Before (on the left) vs after (on the right).*

   Let's open ``PostContent.kt`` and check the ``PostMetadata`` composable:

   .. code:: prettyprint

      @Composable
      private fun PostMetadata(metadata: Metadata) {
         // ...
         Row {
             Image(
                 // ...
             )
             Spacer(Modifier.width(8.dp))
             Column {
                 Text(
                     // ...
                 )

                 CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                     Text(
                         // ..
                     )
                 }
             }
         }
      }

   We can tell the top level row to merge its descendants, which will lead to the behavior
   we want:

   .. code:: prettyprint

      @Composable
      private fun PostMetadata(metadata: Metadata) {
         // ...
         Row(Modifier.semantics(mergeDescendants = true) {}) {
             Image(
                 // ...
             )
             Spacer(Modifier.width(8.dp))
             Column {
                 Text(
                     // ...
                 )

                 CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                     Text(
                         // ..
                     )
                 }
             }
         }
      }


9. Switches and checkboxes
--------------------------


   Toggleable elements like ``Switch`` and ``Checkbox`` read out loud their checked state
   as they are selected by TalkBack. Without context it can be hard to understand what
   these toggleable elements refer to though. We can include context for a toggleable
   element by lifting the toggleable state up, so a user can toggle the ``Switch`` or
   ``Checkbox`` by either pressing the composable itself, or the label that describes it.

   We can see an example of this in our Interests screen. You can navigate there by
   opening the navigation drawer from the Home screen. On the Interests screen we have a
   list of topics that a user can subscribe to. By default, the checkboxes on this screen
   are focused separately from their labels, which makes it hard to understand their
   context. We'd prefer the whole ``Row`` to be toggleable:

   |Two screen recordings with TalkBack enabled, showing the interests screen with a list
   of selectable topics. On the left screen, TalkBack separately selects each Checkbox. On
   the right screen, TalkBack selects the whole row.|

   *Working with checkboxes. Before (on the left) vs after (on the right).*

   Let's open ``InterestsScreen.kt`` and look at the implementation of the ``TopicItem``
   composable:

   .. code:: prettyprint

      @Composable
      private fun TopicItem(itemTitle: String, selected: Boolean, onToggle: () -> Unit) {
         // ...
         Row(
             modifier = Modifier
                 .padding(horizontal = 16.dp, vertical = 8.dp)
         ) {
             // ...
             Checkbox(
                 checked = selected,
                 onCheckedChange = { onToggle() },
                 modifier = Modifier.align(Alignment.CenterVertically)
             )
         }
      }

   As you can see here, the ``Checkbox`` has an ``onCheckedChange`` callback which handles
   toggling the element. We can lift this callback to the level of the whole ``Row``:

   .. code:: prettyprint

      @Composable
      private fun TopicItem(itemTitle: String, selected: Boolean, onToggle: () -> Unit) {
         // ...
         Row(
             modifier = Modifier
                 .toggleable(
                     value = selected,
                     onValueChange = { _ -> onToggle() },
                     role = Role.Checkbox
                 )
                 .padding(horizontal = 16.dp, vertical = 8.dp)
         ) {
             // ...
             Checkbox(
                 checked = selected,
                 onCheckedChange = null,
                 modifier = Modifier.align(Alignment.CenterVertically)
             )
         }
      }


10. State descriptions
----------------------


   In the previous step, we lifted the toggle behavior from a ``Checkbox`` to the parent
   ``Row``. We can improve the accessibility of this element even more by adding a custom
   description for the state of the composable.

   By default, our ``Checkbox`` status is read as either "Ticked" or "Not ticked". We can
   replace this description with our own custom description:

   |Two screen recordings with TalkBack enabled, tapping a topic in the interests screen.
   Left screen announces 'Not ticked', while right screen announces 'Not subscribed'.|

   *Adding state descriptions. Before (on the left) vs after (on the right).*

   We can continue with the ``TopicItem`` composable that we adapted in the last step:

   .. code:: prettyprint

      @Composable
      private fun TopicItem(itemTitle: String, selected: Boolean, onToggle: () -> Unit) {
         // ...
         Row(
             modifier = Modifier
                 .toggleable(
                     value = selected,
                     onValueChange = { _ -> onToggle() },
                     role = Role.Checkbox
                 )
                 .padding(horizontal = 16.dp, vertical = 8.dp)
         ) {
             // ...
             Checkbox(
                 checked = selected,
                 onCheckedChange = null,
                 modifier = Modifier.align(Alignment.CenterVertically)
             )
         }
      }

   We can add our custom state descriptions using the ``stateDescription`` property inside
   the ``semantics`` modifier:

   .. code:: prettyprint

      @Composable
      private fun TopicItem(itemTitle: String, selected: Boolean, onToggle: () -> Unit) {
         // ...
         val stateNotSubscribed = stringResource(R.string.state_not_subscribed)
         val stateSubscribed = stringResource(R.string.state_subscribed)
         Row(
             modifier = Modifier
                 .semantics {
                     stateDescription = if (selected) {
                         stateSubscribed
                     } else {
                         stateNotSubscribed
                     }
                 }
                 .toggleable(
                     value = selected,
                     onValueChange = { _ -> onToggle() },
                     role = Role.Checkbox
                 )
                 .padding(horizontal = 16.dp, vertical = 8.dp)
         ) {
             // ...
             Checkbox(
                 checked = selected,
                 onCheckedChange = null,
                 modifier = Modifier.align(Alignment.CenterVertically)
             )
         }
      }


11. Congratulations!
--------------------


   Congratulations, you've successfully completed this codelab and learned more about
   accessibility in Compose. You learned about touch targets, visual element descriptions,
   and state descriptions. You added click labels, headings, custom actions. You know how
   to add custom merging, and how to work with switches and checkboxes. Applying these
   learnings to your apps will greatly improve their accessibility!

   Check out the other codelabs on the `Compose pathway <https://developer.android.google.cn/courses/pathways/compose>`__. 
   And other `code samples <http://goo.gle/compose-samples>`__, including Jetnews.


Documentation


   For more information and guidance about these topics, check out the following
   documentation:

   -  `Accessibility in Jetpack Compose <https://developer.android.google.cn/jetpack/compose/accessibility>`__
   -  `Semantics in Jetpack Compose <https://developer.android.google.cn/jetpack/compose/semantics>`__


.. |TalkBack focus rectangle moving through the home screen of Jetnews. The text that TalkBack announces is shown at the bottom of the screen.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-accessibility/img/45cd79220ee41307.gif
.. |android_studio_folder.png| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-accessibility/img/bb745dc85ae69f6b.png
.. |Comparison of a list item showing a small outline of cross icon on the left, large outline on the right.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-accessibility/img/8fc987bd362b9386.png
.. |Two screen recordings with TalkBack enabled, tapping a post in a vertical list and a post in a horizontal carousel.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-accessibility/img/8d6e8e27f2741f1c.gif
.. |Two screen recordings with TalkBack enabled. Screen on the left shows how the cross icon on the post item is selectable. Double tapping opens a dialog. Screen on the right shows using a three-tap gesture to open a custom Actions menu. Tapping action 'Show fewer of this' opens the same dialog.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-accessibility/img/cdeea78300677cd9.gif
.. |Two screen recordings with TalkBack enabled, tapping the back button in the article screen. Left calls out 'Buttonâ€”double tap to activate'. Right calls out 'Navigate upâ€”double tap to activate'.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-accessibility/img/60c5a2adf0e35075.gif
.. |Two screen recordings with TalkBack enabled, using swipe down to navigate through headings. Left screen reads out 'No next heading'. Right screen cycles through the headings and reads each of them out loud.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-accessibility/img/6c273b1a1eb1ee9f.gif
.. |Two screen recordings with TalkBack enabled. Left sreen shows separate green TalkBack rectangles for Author and Metadata fields. Right screen shows one rectangle around both fields and reads the concatenated content.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-accessibility/img/2b14a47abbf68e99.gif
.. |Two screen recordings with TalkBack enabled, showing the interests screen with a list of selectable topics. On the left screen, TalkBack separately selects each Checkbox. On the right screen, TalkBack selects the whole row.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-accessibility/img/5ec7c946fab1f32a.gif
.. |Two screen recordings with TalkBack enabled, tapping a topic in the interests screen. Left screen announces 'Not ticked', while right screen announces 'Not subscribed'.| image:: https://codelabs.developers.google.cn/static/codelabs/jetpack-compose-accessibility/img/1de080322f990115.gif


ğŸš€ Build adaptive apps with Jetpack Compose
============================================

https://codelabs.developers.google.cn/jetpack-compose-adaptability?hl=en


1. Introduction
---------------

   In this codelab you will learn how to build adaptive apps for phones, tablets, and
   foldables, and how they enhance reachability with Jetpack Compose. You will also learn
   best practices for using Material 3 components and theming.

   Before we dive in, it's important to understand what we mean by adaptability.


Adaptability


   The UI for your app should be responsive to account for different window sizes,
   orientations, and form factors. An adaptive layout changes based on the screen space
   available to it. These changes range from simple layout adjustments to fill up space,
   choosing respective navigation styles, to changing layouts completely to make use of
   additional room.

   To learn more, check out `Adaptive design <https://m3.material.io/foundations/adaptive-design/overview>`__.

   In this codelab, you explore how to use and think about adaptability when using Jetpack
   Compose. You build an application, called Reply, that shows you how to implement
   adaptability for all kinds of screens, and how adaptability and reachability work
   together to give users an optimal experience.


What you'll learn


   -  How to design your app to target all window sizes with Jetpack Compose.
   -  How to target your app for different foldables.
   -  How to use different types of navigation for better reachability and accessibility.
   -  How to use Material 3 components to provide the best experience for every window
      size.


What you'll need


   -  `Android Studio JellyFish or higher <https://developer.android.google.cn/studio>`__.
   -  `An Android 13 resizable virtual device <https://developer.android.google.cn/about/versions/14/get#resizable-emulator>`__.
   -  Knowledge of Kotlin.
   -  Basic understanding of Compose (such as the ``@Composable`` annotation).
   -  Basic familiarity with Compose layouts (e.g. ``Row`` and ``Column``).
   -  Basic familiarity with modifiers (e.g. ``Modifier.padding()``).

   You'll use the `Resizable emulator <https://developer.android.google.cn/about/versions/14/get#resizable-emulator>`__
   for this codelab, which lets you switch between different types of devices and window
   sizes.

   |Resizable emulator with options of phone, unfolded, tablet and desktop.|

   If you're unfamiliar with Compose, consider taking the `Jetpack Compose basics <https://codelabs.developers.google.cn/codelabs/jetpack-compose-basics/>`__
   before completing this codelab.


What you'll build


   -  An interactive email client app using best practices for adaptable designs,
      different Material navigations, and optimal screen space usage.

   |Multiple device support showcase that you will achieve in this codelab|


2. Get set up
-------------

   To get the code for this codelab, clone the GitHub repository from the command line:

   ::

      git clone https://github.com/android/codelab-android-compose.git
      cd codelab-android-compose/AdaptiveUiCodelab

   Alternatively, you can download the repository as a ZIP file:

   `Download ZIP <https://github.com/android/codelab-android-compose/archive/refs/heads/main.zip>`__

   The ``codelab-android-compose`` repo contains starter code for all codelabs in the
   pathway.

   For this codelab, use the ``AdaptiveUiCodelab`` project. The project is built in
   multiple git branches:

   -  **``main``** - Contains the starter code for this project. You will make changes to
      this to complete the codelab.
   -  **``end``** - Contains the solution to this codelab.

   We recommend that you start with the code in the **main** branch and follow the codelab
   step-by-step at your own pace.


Open project in Android Studio


   1. On the **Welcome to Android Studio** window, select |c01826594f360d94.png|\ **Open
      an Existing Project.**
   2. Select the folder **``<Download Location>/AdaptiveUiCodelab``** (make sure you
      select the **``AdaptiveUiCodelab``** directory containing **``build.gradle``**).
   3. When Android Studio has imported the project, test that you can run the **``main``**
      branch.


Explore the start code


   The **main** branch code contains the **``ui``** package. You will work with the
   following files in that package:

   -  **``MainActivity.kt``** - Entry point activity where you start your app.
   -  **``ReplyApp.kt``** - Contains main screen UI composables.
   -  **``ReplyHomeViewModel.kt``** - Provides the data and UI state for the app content.
   -  **``ReplyListContent.kt``** - Contains composables for providing lists and detail
      screens.

   You'll first focus on **``MainActivity.kt``**.

   **MainActivity.kt**

   .. code:: prettyprint

      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)

          setContent {
              ReplyTheme {
                  val uiState by viewModel.uiState.collectAsStateWithLifecycle()
                  ReplyApp(
                      replyHomeUIState = uiState,
                      onEmailClick = viewModel::setSelectedEmail
                  )
              }
          }
      }

   If you run this app on a resizable emulator and try different device types, like a
   phone or tablet, the UI just expands to the given space instead of taking advantage of
   screen space or providing reachability ergonomics.

   |Initial screen on phone|

   |Initial stretched view on tablet|

   You'll update it to take advantage of the screen space, increase usability, and improve
   the overall user experience.


3. Make apps adaptable
----------------------

   This section introduces what making apps adaptable means, and what components Material
   3 provides to make that easier. It also covers the types of screens and states you'll
   target, including phones, tablets, large tablets, and foldables.

   You'll start by going through the fundamentals of window sizes, fold postures, and
   different types of navigation options. Then, you can use these APIs in your app to make
   it more adaptive.


Window sizes


   Android devices come in all shapes and sizes, from phones to foldables to tablets and
   ChromeOS devices. To support as many window sizes as possible, your UI needs to be
   responsive and adaptive. To help you find the right threshold at which to change the UI
   of your app, we've defined breakpoint values that help classify devices into predefined
   size classes (compact, medium, and expanded), called `window size classes <https://developer.android.google.cn/develop/ui/compose/layouts/adaptive/window-size-classes>`__.
   These are a set of opinionated viewport breakpoints that help you design, develop, and
   test responsive and adaptive application layouts.

   The categories were chosen specifically to balance layout simplicity, with the
   flexibility to optimize your app for unique cases. Window size class is always
   determined by the screen space available to the app, which may not be the entire
   physical screen for multitasking or other segmentations.

   |WindowWidthSizeClass for compact, medium, and expanded width.|

   |WindowHeightSizeClass for compact, medium, and expanded height.|

   Both width and height are classified separately, so at any point in time, your app has
   two window size classesâ€”one for width and one for height. Available width is usually
   more important than available height due to the ubiquity of vertical scrolling, so for
   this case you'll also use width size classes.


Fold states


   Foldable devices present yet more situations your app can adapt to because of their
   varying sizes and the presence of hinges. Hinges can obscure part of the display,
   making that area unsuitable to show content; they could also be separating, meaning
   there are two separate physical displays when the device is unfolded.

   |Foldable postures, flat and half-open|

   Additionally, the user could be looking at the inner display while the hinge is partly
   open, resulting in different physical postures based on the orientation of the fold:
   tabletop posture (horizontal fold, shown to the right in the image above) and book
   posture (vertical fold).

   Read more about `fold postures and hinges <https://m3.material.io/foundations/layout/understanding-layout/hardware-considerations#45b18023-e549-45b8-9304-0b8133ae2c5c>`__.

   All of these are things to consider when implementing adaptive layouts that support
   foldables.


Get adaptive information


   The Material3 `adaptive <https://developer.android.google.cn/jetpack/androidx/releases/compose-material3-adaptive>`__
   library provides convenient access to information about the window your app is running
   in.

   1. Add entries for this artifact and its version to the version catalog file:

   **gradle/libs.versions.toml**

   .. code:: prettyprint

      [versions]
      material3Adaptive = "1.0.0-beta01"

      [libraries]
      androidx-material3-adaptive = { module = "androidx.compose.material3.adaptive:adaptive", version.ref = "material3Adaptive" }

   2. In the build file of the app module, add the new library dependency and then perform
      a Gradle sync:

   **app/build.gradle.kts**

   .. code:: prettyprint

      dependencies {

          implementation(libs.androidx.material3.adaptive)
      }

   Now, in any composable scope, you can use `currentWindowAdaptiveInfo() <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/adaptive/package-summary#currentWindowAdaptiveInfo()>`__
   to get a `WindowAdaptiveInfo <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/adaptive/WindowAdaptiveInfo>`__
   object containing information like the current window size class and whether the device
   is in a foldable posture like tabletop posture.

   You can try this now in ``MainActivity``.

   3. In ``onCreate()`` inside of the ``ReplyTheme`` block, get the window adaptive info
      and display the size classes in a ``Text`` composable (you can add this after the
      ``ReplyApp()`` element):

   **MainActivity.kt**

   .. code:: prettyprint

      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)

          setContent {
              ReplyTheme {
                  val uiState by viewModel.uiState.collectAsStateWithLifecycle()
                  ReplyApp(
                      replyHomeUIState = uiState,
                      onEmailClick = viewModel::setSelectedEmail
                  )

                  val adaptiveInfo = currentWindowAdaptiveInfo()
                  val sizeClassText =
                      "${adaptiveInfo.windowSizeClass.windowWidthSizeClass}\n" +
                      "${adaptiveInfo.windowSizeClass.windowHeightSizeClass}"
                  Text(
                      text = sizeClassText,
                      color = Color.Magenta,
                      modifier = Modifier.padding(20.dp)
                  )
              }
          }
      }

   Running the app now will show the window size classes printed over the app content.
   Feel free to explore what else is provided in the window adaptive info. Afterwards you
   can remove this ``Text`` since it covers the app content and it won't be necessary for
   the next steps.


4. Dynamic navigation
---------------------

   Now you'll adapt the app's navigation as the device state and size changes in order to
   improve reachability.

   Reachability is the ability to navigate or initiate an interaction with an app without
   requiring extreme hand positions or changing hand placements. When users hold a phone,
   their fingers are usually at the bottom of the screen. When users hold an opened
   foldable device or a tablet, their fingers are usually close to the sides. As you
   design your app and decide where to place interactive UI elements in your layout,
   consider the ergonomic implications of different regions of the screen.

   -  Which areas are comfortable to reach while holding the device?
   -  Which areas can be reached only by extending fingers, which may be inconvenient?
   -  Which areas are challenging to reach or are far away from where the user holds the
      device?

   Navigation is the first thing users interact with and it contains high-importance
   actions related to critical user journeys, so it should be placed in areas that are
   easiest to reach. Material provides several components that help you implement
   navigation, depending on the window size class of the device.


Bottom navigation


   Bottom navigation is perfect for **compact** sizes, as we naturally hold the device
   where our thumb can easily reach all the bottom navigation touch points. Use it
   whenever you have a compact device size or a foldable in a compact folded state.

   |Bottom navigation bar with items|


Navigation rail


   For a **medium** width window size, the navigation rail is ideal for reachability as
   our thumb naturally falls along the side of the device. You can also combine a
   navigation rail with a navigation drawer to show more information.

   |Navigation rail with items|


Navigation drawer


   The navigation drawer provides an easy way to see detailed information for navigation
   tabs, and is easily accessible when you're using **tablets or larger devices**. There
   are two kinds of navigation drawers available: a modal navigation drawer and a
   permanent navigation drawer.

   **Modal navigation drawer**

   You can use a modal navigation drawer for compact to medium size phones and tablets as
   it can be expanded or hidden as an overlay on the content. This can sometimes be
   combined with a navigation rail.

   |Modal navigation drawer with items|

   **Permanent navigation drawer**

   You can use a permanent navigation drawer for fixed navigation on large tablets,
   Chromebooks, and desktops.

   |Permanent navigation drawer with items|


Implement dynamic navigation


   Now, you'll switch between different types of navigation as the device state and size
   changes.

   Currently, the app always shows a ``NavigationBar`` below the screen content regardless
   of the device state. Instead, you can use the Material `NavigationSuiteScaffold <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/adaptive/navigationsuite/package-summary#NavigationSuiteScaffold(kotlin.Function1,androidx.compose.ui.Modifier,androidx.compose.material3.adaptive.navigationsuite.NavigationSuiteType,androidx.compose.material3.adaptive.navigationsuite.NavigationSuiteColors,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function0)>`__
   component to automatically switch between the different navigation components based on
   information like the current window size class.

   1. Add the Gradle dependency to get this component by updating the version catalog and
      the app's build script, then perform a Gradle sync:

   **gradle/libs.versions.toml**

   .. code:: prettyprint

      [versions]
      material3AdaptiveNavSuite = "1.3.0-beta01"

      [libraries]
      androidx-material3-adaptive-navigation-suite = { module = "androidx.compose.material3:material3-adaptive-navigation-suite", version.ref = "material3AdaptiveNavSuite" }

   **app/build.gradle.kts**

   .. code:: prettyprint

      dependencies {

          implementation(libs.androidx.material3.adaptive.navigation.suite)
      }

   2. Find the ``ReplyNavigationWrapper()`` composable function in **``ReplyApp.kt``** and
      replace the ``Column`` and its contents with a ``NavigationSuiteScaffold``:

   **ReplyApp.kt**

   .. code:: prettyprint

      @Composable
      private fun ReplyNavigationWrapperUI(
          content: @Composable () -> Unit = {}
      ) {
          var selectedDestination: ReplyDestination by remember {
              mutableStateOf(ReplyDestination.Inbox)
          }

          NavigationSuiteScaffold(
              navigationSuiteItems = {
                  ReplyDestination.entries.forEach {
                      item(
                          selected = it == selectedDestination,
                          onClick = { /*TODO update selection*/ },
                          icon = {
                              Icon(
                                  imageVector = it.icon,
                                  contentDescription = stringResource(it.labelRes)
                              )
                          },
                          label = {
                              Text(text = stringResource(it.labelRes))
                          },
                      )
                  }
              }
          ) {
              content()
          }
      }

   The ``navigationSuiteItems`` argument is a block that lets you add items using the
   ``item()`` function, similar to adding items in a ``LazyColumn``. Inside the trailing
   lambda, this code calls the ``content()`` passed as an argument to
   ``ReplyNavigationWrapperUI()``.

   Run the app on the emulator and try changing sizes between phone, foldable, and tablet,
   and you will see the navigation bar change to a navigation rail and back.

   On very wide windows, such as on a tablet in landscape, you may want to show the
   permanent navigation drawer. ``NavigationSuiteScaffold`` does support showing a
   permanent drawer, though it's not shown in any of the current ``WindowWidthSizeClass``
   values. However, you can make it do so with a small change.

   3. Add the following code just before the call to ``NavigationSuiteScaffold``:

   **ReplyApp.kt**

   .. code:: prettyprint

      @Composable
      private fun ReplyNavigationWrapperUI(
          content: @Composable () -> Unit = {}
      ) {
          var selectedDestination: ReplyDestination by remember {
              mutableStateOf(ReplyDestination.Inbox)
          }

          val windowSize = with(LocalDensity.current) {
              currentWindowSize().toSize().toDpSize()
          }
          val layoutType = if (windowSize.width >= 1200.dp) {
              NavigationSuiteType.NavigationDrawer
          } else {
              NavigationSuiteScaffoldDefaults.calculateFromAdaptiveInfo(
                  currentWindowAdaptiveInfo()
              )
          }

          NavigationSuiteScaffold(
              layoutType = layoutType,
              ...
          ) {
              content()
          }
      }

   This code first gets the window size and converts it to DP units using
   ``currentWindowSize()`` and ``LocalDensity.current``, and then compares the window
   width to decide the layout type of the navigation UI. If the window width is at least
   ``1200.dp``, it uses ``NavigationSuiteType.NavigationDrawer``. Otherwise, it falls back
   to the default calculation.

   When you run the app again on your resizable emulator and try out different types,
   notice that whenever the screen configuration changes or you unfold a folding device,
   the navigation changes to the appropriate type for that size.

   |Showing adaptability changes for different size of devices.|

   Congratulations, you've learned about different types of navigation to support
   different types of window sizes and states!

   In the next section, you explore how to take advantage of any remaining screen area
   instead of stretching the same list item edge to edge.


5. Screen space use
-------------------

   No matter if you're running the app on a small tablet, unfolded device, or large
   tablet, the screen is stretched to fill the remaining space. You want to make sure you
   can take advantage of that screen space to show more info, like for this app, showing
   email and threads to users on the same page.

   Material 3 defines three canonical layouts which each have configurations for compact,
   medium, and expanded window size classes. The `List Detail <https://m3.material.io/foundations/layout/canonical-layouts/list-detail>`__
   canonical layout is perfect for this use case, and is available in compose as
   ``ListDetailPaneScaffold``.

   1. Get this component by adding the following dependencies and performing a Gradle
      sync:

   **gradle/libs.versions.toml**

   .. code:: prettyprint

      [versions]
      material3Adaptive = "1.0.0-beta01"

      [libraries]
      androidx-material3-adaptive-layout = { module = "androidx.compose.material3.adaptive:adaptive-layout", version.ref = "material3Adaptive" }
      androidx-material3-adaptive-navigation = { module = "androidx.compose.material3.adaptive:adaptive-navigation", version.ref = "material3Adaptive" }

   **app/build.gradle.kts**

   .. code:: prettyprint

      dependencies {

          implementation(libs.androidx.material3.adaptive.layout)
          implementation(libs.androidx.material3.adaptive.navigation)
      }

   2. Find the ``ReplyAppContent()`` composable function in **``ReplyApp.kt``**, which
      currently only shows the list pane by calling ``ReplyListPane()``. Replace this
      implementation with ``ListDetailPaneScaffold`` by inserting the following code.
      Since this is an experimental API, you will also add the ``@OptIn`` annotation on
      the ``ReplyAppContent()`` function:

   **ReplyApp.kt**

   .. code:: prettyprint

      @OptIn(ExperimentalMaterial3AdaptiveApi::class)
      @Composable
      fun ReplyAppContent(
          replyHomeUIState: ReplyHomeUIState,
          onEmailClick: (Email) -> Unit,
      ) {
          val navigator = rememberListDetailPaneScaffoldNavigator<Long>()

          ListDetailPaneScaffold(
              directive = navigator.scaffoldDirective,
              value = navigator.scaffoldValue,
              listPane = {
                  ReplyListPane(replyHomeUIState, onEmailClick)
              },
              detailPane = {
                  ReplyDetailPane(replyHomeUIState.emails.first())
              }
          )
      }

   This code first creates a navigator using ``rememberListDetailPaneNavigator()``. The
   navigator provides some control over which pane is displayed and what content should be
   represented in that pane, which will be demonstrated later.

   ``ListDetailPaneScaffold`` will show two panes when the window width size class is
   expanded. Otherwise, it will show one pane or the other pane based on values provided
   for two parameters: the scaffold directive, and the scaffold value. To get the default
   behavior, this code uses the scaffold directive and the scaffold value provided by the
   navigator.

   The remaining required parameters are composable lambdas for the panes.
   ``ReplyListPane()`` and ``ReplyDetailPane()`` (found in **``ReplyListContent.kt``**)
   are used to fill in the roles of the list and detail panes, respectively.
   ``ReplyDetailPane()`` expects an email argument, so for now this code uses the first
   email from the list of emails in ``ReplyHomeUIState``.

   Run the app and switch the emulator view to foldable or tablet (you might also have to
   change orientation) to see the two pane layout. This already looks a lot better than
   before!

   Now let's address some of the desired behavior of this screen. When the user taps on an
   email in the list pane, it should be shown in the detail pane along with all of the
   replies. Currently, the app doesn't keep track of which email was selected, and tapping
   an item does nothing. The best place to keep this information is with the rest of the
   UI state in ``ReplyHomeUIState``.

   3. Open **``ReplyHomeViewModel.kt``** and find the ``ReplyHomeUIState`` data class. Add
      a property for the selected email, with a default value of ``null``:

   **ReplyHomeViewModel.kt**

   .. code:: prettyprint

      data class ReplyHomeUIState(
          val emails : List<Email> = emptyList(),
          val selectedEmail: Email? = null,
          val loading: Boolean = false,
          val error: String? = null
      )

   4. In the same file, ``ReplyHomeViewModel`` has a ``setSelectedEmail()`` function that
      is called when the user taps a list item. Modify this function to copy the UI state
      and record the selected email:

   **ReplyHomeViewModel.kt**

   .. code:: prettyprint

      fun setSelectedEmail(email: Email) {
          _uiState.update {
              it.copy(selectedEmail = email)
          }
      }

   Something to consider is what happens before the user has tapped any item and the
   selected email is ``null``. What should be displayed in the detail pane? There are
   multiple ways to handle this case, such as showing the first item in the list by
   default.

   5. In the same file, modify the ``observeEmails()`` function. When the list of emails
      is loaded, if the previous UI state did not have a selected email, set it to the
      first item:

   **ReplyHomeViewModel.kt**

   .. code:: prettyprint

      private fun observeEmails() {
          viewModelScope.launch {
              emailsRepository.getAllEmails()
                  .catch { ex ->
                      _uiState.value = ReplyHomeUIState(error = ex.message)
                  }
                  .collect { emails ->
                      val currentSelection = _uiState.value.selectedEmail
                      _uiState.value = ReplyHomeUIState(
                          emails = emails,
                          selectedEmail = currentSelection ?: emails.first()
                      )
                  }
          }
      }

   6. Return to **``ReplyApp.kt``** and use the selected email, if it's available, to
      populate the detail pane content:

   **ReplyApp.kt**

   .. code:: prettyprint

      ListDetailPaneScaffold(
          // ...
          detailPane = {
              if (replyHomeUIState.selectedEmail != null) {
                  ReplyDetailPane(replyHomeUIState.selectedEmail)
              }
          }
      )

   Run the app again and switch the emulator to tablet size, and see that tapping on a
   list item updates the contents of the detail pane.

   This is working great when both panes are visible, but when the window only has room to
   show one pane, it looks like nothing happens when you tap an item. Try switching the
   emulator view to a phone, or a foldable device in portrait, and notice that only the
   list pane is visible even after tapping an item. That's because even though the
   selected email is updated, the ``ListDetailPaneScaffold`` is keeping focus on the list
   pane in these configurations.

   7. To fix that, insert the following code as the lambda passed to ``ReplyListPane``:

   **ReplyApp.kt**

   .. code:: prettyprint

      ListDetailPaneScaffold(
          // ...
          listPane = {
              ReplyListPane(
                  replyHomeUIState = replyHomeUIState,
                  onEmailClick = { email ->
                      onEmailClick(email)
                      navigator.navigateTo(ListDetailPaneScaffoldRole.Detail, email.id)
                  }
              )
          },
          // ...
      )

   This lambda uses the navigator created earlier to add additional behavior when an item
   is clicked. It will call the original lambda passed to this function, and then also
   calls ``navigator.navigateTo()`` specifying which pane should be shown. Each pane in
   the scaffold has a role associated with it, and for the detail pane it is
   ``ListDetailPaneScaffoldRole.Detail``. On smaller windows, this will give the
   appearance that the app has navigated forward.

   The app also needs to handle what happens when the user presses the back button from
   the detail pane, and this behavior will be different depending on whether there is one
   pane or two panes visible.

   8. Support back navigation by adding the following code.

   **ReplyApp.kt**

   .. code:: prettyprint

      @OptIn(ExperimentalMaterial3AdaptiveApi::class)
      @Composable
      fun ReplyAppContent(
          replyHomeUIState: ReplyHomeUIState,
          onEmailClick: (Email) -> Unit,
      ) {
          val navigator = rememberListDetailPaneScaffoldNavigator<Long>()

          BackHandler(navigator.canNavigateBack()) {
              navigator.navigateBack()
          }

          ListDetailPaneScaffold(
              directive = navigator.scaffoldDirective,
              value = navigator.scaffoldValue,
              listPane = {
                  AnimatedPane {
                      ReplyListPane(
                          replyHomeUIState = replyHomeUIState,
                          onEmailClick = { email ->
                              onEmailClick(email)
                              navigator.navigateTo(ListDetailPaneScaffoldRole.Detail, email.id)
                          }
                      )
                  }
              },
              detailPane = {
                  AnimatedPane {
                      if (replyHomeUIState.selectedEmail != null) {
                          ReplyDetailPane(replyHomeUIState.selectedEmail)
                      }
                  }
              }
          )
      }

   The navigator knows the full state of the ``ListDetailPaneScaffold``, whether back
   navigation is possible, and what to do in all these scenarios. This code creates a
   ``BackHandler`` that is enabled whenever the navigator can navigate back, and inside
   the lambda calls ``navigateBack()``. Also, to make the transition between panes much
   smoother, each pane is wrapped in an ``AnimatedPane()`` composable.

   Run the app again on a resizable emulator for all the different types of devices and
   notice that whenever the screen configuration changes, or you unfold a folding device,
   the navigation and screen content dynamically changes in response to the device state
   changes. Also try tapping emails in the list pane and see how the layout behaves on
   different screens, showing both panes side by side or animating between them smoothly.

   |Showing adaptability changes for different size of devices.|

   Congratulations, you've successfully made your app adaptable for all kinds of device
   states and sizes. Go ahead and play around with running the app in foldables, tablets,
   or other mobile devices.


6. Congratulations
------------------

   Congratulations! You've successfully completed this codelab and learned how to make
   apps adaptive with Jetpack Compose.

   You learned how to check a device's size and fold state, and update your app's UI,
   navigation, and other functions accordingly. You also learned how adaptability improves
   reachability and enhances the user experience.


What's next?


   Check out the other codelabs on the `Compose pathway <https://developer.android.google.cn/courses/pathways/compose>`__.


Sample apps


   -  The `compose samples <https://github.com/android/compose-samples/>`__ are a
      collection of many apps that incorporate the best practices explained in codelabs.


Reference docs


   -  `Material 3 Adaptive design <https://m3.material.io/foundations/adaptive-design/overview>`__
   -  `Designing for large screens <https://m3.material.io/foundations/adaptive-design/large-screens/overviewhttps://m3.material.io/foundations/adaptive-design/large-screens/overview>`__
   -  `Introducing Material Theme Builder <https://material.io/blog/material-theme-builder>`__
   -  `Material 3 Introducing Material You <https://m3.material.io/>`__

.. |Resizable emulator with options of phone, unfolded, tablet and desktop.| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/488e1ad99a26fc65.png
.. |Multiple device support showcase that you will achieve in this codelab| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/3af7bd9e52a98fce.gif
.. |c01826594f360d94.png| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/c01826594f360d94.png
.. |Initial screen on phone| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/800bdfe10dadef68.png
.. |Initial stretched view on tablet| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/bdabe741f218212f.png
.. |WindowWidthSizeClass for compact, medium, and expanded width.| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/42db283a2ba29045.png
.. |WindowHeightSizeClass for compact, medium, and expanded height.| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/2c932129fca12cea.png
.. |Foldable postures, flat and half-open| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/foldable_postures.png
.. |Bottom navigation bar with items| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/b26b9b49eb60f05a.png
.. |Navigation rail with items| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/12459fd3794f5fea.png
.. |Modal navigation drawer with items| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/5f9fe9df8c6599e.png
.. |Permanent navigation drawer with items| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/25336d06d9178917.png
.. |Showing adaptability changes for different size of devices.| image:: https://codelabs.developers.google.cn/static/jetpack-compose-adaptability/img/3af7bd9e52a98fce.gif


ğŸš€ Compose for Wear OS Codelab
===============================

https://developer.android.google.cn/codelabs/compose-for-wear-os?hl=en


1. Introduction
---------------

   |2c9dd335c9d65f10.png|

   Compose for Wear OS lets you translate the knowledge you've learned building apps with
   Jetpack Compose to wearable devices.

   With built-in support for Material Design, Compose for Wear OS `simplifies and
   accelerates UI
   development <https://developer.android.google.cn/jetpack/compose/why-adopt#less-code>`__
   and helps you create beautiful apps with less code.

   For this codelab, we expect you to have some knowledge of Compose, but you certainly
   don't need to be an expert.

   We will be using `Horologist <https://google.github.io/horologist>`__ which is an open
   source project built on top of Jetpack Compose, which helps developers accelerate app
   development.

   You will create several Wear specific composables (both simple and complex), and, by
   the end, you can start writing your own apps for Wear OS. Let's get started!


What you will learn


   -  Similarities/differences between your previous experience with Compose
   -  Simple composables and how they work on Wear OS
   -  Wear OS specific composables
   -  Wear OS's ``LazyColumn`` (``ScalingLazyColumn``)
   -  Wear OS's version of the ``Scaffold``


What you will build


   You'll build a simple app that displays a scrollable list of composables optimized for
   Wear OS.

   Because you will be using `Scaffold <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#Scaffold(androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0)>`__,
   you'll also get a curved text time at the top, a `vignette <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#Vignette(androidx.wear.compose.material.VignettePosition,androidx.compose.ui.Modifier)>`__,
   and finally a scrolling indicator tied to the side of the device.

   Here's what it will look like when you are finished with the code lab:

   |31cb08c0fa035400.gif|


Prerequisites


   -  Basic understanding of `Android development <https://developer.android.google.cn/>`__
   -  Basic understanding of `Kotlin <https://developer.android.google.cn/kotlin>`__
   -  Basic knowledge of `Compose <https://developer.android.google.cn/jetpack/compose>`__


2. Getting Set Up
-----------------

   In this step, you will set up your environment and download the starter project.


What you will need


   -  Latest stable version of `Android Studio <https://developer.android.google.cn/studio>`__
   -  Wear OS device or emulator (New to this? `Here's <https://developer.android.google.cn/training/wearables/apps/creating#emulator>`__
      how to set it up.)


Download code


   If you have git installed, you can simply run the command below to clone the code from
   `this repo <https://github.com/android/codelab-compose-for-wear-os>`__. To check
   whether git is installed, type ``git --version`` in the terminal or command line and
   verify that it executes correctly.

   ::

      git clone https://github.com/android/codelab-compose-for-wear-os.git
      cd compose-for-wear-os

   If you do not have git, you can click the following button to download all the code for
   this codelab:

   `Download ZIP <https://github.com/android/codelab-compose-for-wear-os/archive/main.zip>`__

   The sample directory contains the **start** and **finished** code for this codelab. In
   the Project view on the left of Android Studio you will find two modules.

   -  |d61ffd479bdbcb9f.png| **start** â€“ the starter code for this project; you will make
      changes to this to complete the codelab
   -  |d61ffd479bdbcb9f.png| **finished** â€“ the completed code for this codelab; used to
      check your work

   At any time you can run either module in Android Studio by changing the run
   configuration in the toolbar.

   |b059413b0cf9113a.png|


Open project in Android Studio


   1. On the Welcome to Android Studio window select |c01826594f360d94.png| **Open an
      Existing Project**
   2. Select the folder **``[Download Location]``**
   3. When Android Studio has imported the project, test that you can run the ``start``
      and ``finished`` modules on a Wear OS emulator or physical device.
   4. The ``start`` module should look like the screenshot below. It's where you will be
      doing all your work.

   |d6d4b92ac53d9b3e.png|


Explore the start code


   -  ``build.gradle`` contains a basic app configuration. It includes the dependencies
      necessary to create a Composable Wear OS App. We'll discuss what's similar and
      different between Jetpack Compose and the Wear OS version.
   -  ``main > AndroidManifest.xml`` includes the elements necessary to create a Wear OS
      application. This is the same as a non-Compose app and similar to a mobile app, so
      we won't review this.
   -  ``main > theme/`` folder contains the ``Color``, ``Type``, and ``Theme`` files used
      by Compose for the theme.
   -  ``main > MainActivity.kt`` contains boilerplate for creating an app with Compose. It
      also contains the top-level composables (like the ``Scaffold`` and
      ``ScalingLazyList``) for our app.
   -  ``main > ReusableComponents.kt`` contains functions for most of the Wear specific
      composables we'll create. We will do a lot of our work in this file.


3. Review the dependencies
--------------------------

   Most of the Wear related dependency changes you make will be at the top 
   `architectural layers <https://developer.android.google.cn/jetpack/compose/layering>`__ 
   (highlighted in red below).

   |d92519e0b932f964.png|

   That means many of the dependencies you already use with Jetpack Compose don't change
   when targeting Wear OS. For example, the UI, Runtime, Compiler, and Animation
   dependencies will remain the same.

   However, you will need to use the proper Wear OS **Material**, **Foundation**, and
   **Navigation** libraries which are different from the libraries you have used before.

   Below is a comparison to help clarify the differences:

   .. list-table::

      - 

         - **Wear OS Dependency** (androidx.wear.*)
         - **Comparison**
         - **Standard Dependency** (androidx.*)
      - 

         - `androidx.wear.compose:compose-material <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary>`__
         - **instead of**
         - androidx.compose.material:material **â‚**
      - 

         - `androidx.wear.compose:compose-navigation <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/navigation/package-summary>`__
         - **instead of**
         - androidx.navigation:navigation-compose
      - 

         - `androidx.wear.compose:compose-foundation <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/foundation/package-summary>`__
         - **in addition to**
         - androidx.compose.foundation:foundation
      - 

         - `androidx.wear.compose:compose-ui-tooling <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/ui/tooling/preview/package-summary>`__
         - **in addition to**
         - androidx.compose.ui:ui-tooling-preview

   *1. Developers can continue to use other material related libraries like material
   ripple and material icons extended with the Wear Compose Material library.*

   **Note:** While it's technically possible to use the standard dependencies on Wear OS,
   we always recommend using the wear-specific versions for the best experience.

   Open the ``build.gradle``, search for "**``TODO: Review Dependencies``**" in your
   ``start`` module. (This step is just to review the dependencies, you will not be adding
   any code.)

   start/build.gradle:

   .. code:: prettyprint

         def composeBom = platform(libs.androidx.compose.bom)

          // General compose dependencies
          implementation composeBom
          implementation libs.androidx.activity.compose
          implementation libs.compose.ui.tooling.preview

          implementation(libs.androidx.material.icons.extended)

          // Compose for Wear OS Dependencies
          implementation libs.wear.compose.material

          // Foundation is additive, so you can use the mobile version in your Wear OS app.
          implementation libs.wear.compose.foundation

          // Compose preview annotations for Wear OS.
          implementation(libs.androidx.compose.ui.tooling)

          debugImplementation libs.compose.ui.tooling
          debugImplementation libs.androidx.ui.test.manifest
          debugImplementation composeBom

   You should recognize many of the general Compose dependencies, so we won't cover those.

   Let's move to the Wear OS dependencies.

   Just as outlined earlier, only the Wear OS specific version of **``material``**
   (``androidx.wear.compose:compose-material``) is included. That is, you will not see or
   include ``androidx.compose.material:material`` in your project.

   It's important to call out that you can use other material libraries with Wear
   Material. We actually do that in this codelab by including
   ``androidx.compose.material:material-icons-extended``.

   Finally, we include the Wear **``foundation``** library for Compose
   (``androidx.wear.compose:compose-foundation``) . This is additive, so you can use it
   with the standard **``foundation``** you've used before. In fact, you probably already
   recognized we included it in the general compose dependencies!

   Ok, now that we understand the dependencies, let's have a look at the main app.


4. Review MainActivity
----------------------

   **We will do all our work in the**

   **``start``**

   **module, so make sure every file you open is in there.**

   Let's start by opening ``MainActivity`` in the ``start`` module.

   This is a pretty simple class that extends ``ComponentActivity`` and uses
   ``setContent { WearApp() }`` to create the UI.

   From your previous knowledge of Compose, this should look familiar to you. We are just
   setting up the UI.

   Scroll down to the ``WearApp()`` composable function. Before we talk about the code
   itself, you should see a bunch of TODOs scattered throughout the code. These each
   represent steps in this codelab. You can ignore them for now.

   It should look something like this:

   **Code in fun WearApp():**

   .. code:: prettyprint

      WearAppTheme {
           /* *************************** Part 4: Wear OS Scaffold *************************** */
          // TODO (Start): Create a AppScaffold (Wear Version)

          // TODO: Swap to ScalingLazyColumnState
          val listState = rememberLazyListState()

          /* *************************** Part 4: Wear OS Scaffold *************************** */
          // TODO (Start): Create a ScreenScaffold (Wear Version)

          // Modifiers used by our Wear composables.
          val contentModifier = Modifier.fillMaxWidth().padding(bottom = 8.dp)
          val iconModifier = Modifier.size(24.dp).wrapContentSize(align = Alignment.Center)

          /* *************************** Part 3: ScalingLazyColumn *************************** */
          // TODO: Swap a ScalingLazyColumn (Wear's version of LazyColumn)
          LazyColumn(
              modifier = Modifier.fillMaxSize(),
              contentPadding = PaddingValues(
                  top = 32.dp,
                  start = 8.dp,
                  end = 8.dp,
                  bottom = 32.dp,
              ),
              verticalArrangement = Arrangement.Center,
              state = listState,
          ) {
              // TODO: Remove item; for beginning only.
              item { StartOnlyTextComposables() }

              /* ******************* Part 1: Simple composables ******************* */
              item { ButtonExample(contentModifier, iconModifier) }
              item { TextExample(contentModifier) }
              item { CardExample(contentModifier, iconModifier) }

              /* ********************* Part 2: Wear unique composables ********************* */
              item { ChipExample(contentModifier, iconModifier) }
              item { ToggleChipExample(contentModifier) }
              }

          // TODO (End): Create a ScreenScaffold (Wear Version)
          // TODO (End): Create a AppScaffold (Wear Version)
      }

   We start by setting the theme, ``WearAppTheme { }``. This is exactly the same way
   you've written it before, that is, you set a `MaterialTheme <https://developer.android.google.cn/jetpack/compose/themes/material>`__
   with colors, typography, and shapes.

   However, in the case of Wear OS, we generally recommend using the default 
   `Material Wear shapes <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/Shapes>`__
   which are optimized for round devices, so if you dive into our ``theme/Theme.kt``, you
   can see we don't override shapes.

   If you wish, you can open the ``theme/Theme.kt`` to explore it further, but, again,
   it's the same as on the phone.

   Next, we create some Modifiers for the Wear composables we're going to build out, so we
   don't need to specify them every time. It's mostly centering the content and adding
   some padding.

   We then create a `LazyColumn <https://developer.android.google.cn/jetpack/compose/lists>`__ 
   which is used to produce a vertically scrolling list for a bunch of items (just like you did
   before).

   **Code:**

   .. code:: prettyprint

      item { StartOnlyTextComposables() }

      /* ******************* Part 1: Simple composables ******************* */
      item { ButtonExample(contentModifier, iconModifier) }
      item { TextExample(contentModifier) }
      item { CardExample(contentModifier, iconModifier) }

      /* ********************* Part 2: Wear unique composables ********************* */
      item { ChipExample(contentModifier, iconModifier) }
      item { ToggleChipExample(contentModifier) }

   For the items themselves, only ``StartOnlyTextComposables()`` produces any UI. (We will
   populate the rest throughout the code lab.)

   These functions are actually in the ``ReusableComponents.kt`` file, which we will visit
   in the next section.

   Let's get started with Compose for Wear OS!


5. Add Simple Composables
-------------------------

   We'll start with three composables (``Button``, ``Text``, and ``Card``) that you are
   probably already familiar with.

   First, we are going to remove the hello world composable.

   Search for "**``TODO: Remove item``**" and **erase** both the comment and the line
   below it:

   **Step 1**

   .. code:: prettyprint

      // TODO: Remove item; for beginning only.
      item { StartOnlyTextComposables() }

   Next, let's add our first composable.


Create a Button composable


   Open ``ReusableComponents.kt`` in the ``start`` module and search for
   "**``TODO: Create a Button Composable``**" and replace the current composable method
   with this code.

   **Step 2**

   .. code:: prettyprint

      // TODO: Create a Button Composable (with a Row to center)
      @Composable
      fun ButtonExample(
          modifier: Modifier = Modifier,
          iconModifier: Modifier = Modifier
      ) {
          Row(
              modifier = modifier,
              horizontalArrangement = Arrangement.Center
          ) {
              // Button
              Button(
                  modifier = Modifier.size(ButtonDefaults.LargeButtonSize),
                  onClick = { /* ... */ },
              ) {
                  Icon(
                      imageVector = Icons.Rounded.Phone,
                      contentDescription = "triggers phone action",
                      modifier = iconModifier
                  )
              }
          }
      }

   The ``ButtonExample()`` composable function (where this code exists) will now generate
   a centered button.

   Let's walk through the code.

   The ``Row`` is only used here to center the `Button <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#Button(kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.wear.compose.material.ButtonColors,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function1)>`__
   composable on the round screen. You can see we are doing that by applying the modifier
   we created in ``MainActivity`` and passing it into this function. Later, when we scroll
   on a circular screen, we want to make sure our content isn't cut off (which is why it's
   centered).

   Next, we create the ``Button`` itself. The code is the same as you would use for a
   Button before, but, in our case, we use the `ButtonDefault.LargeButtonSize <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/ButtonDefaults#LargeButtonSize()>`__.
   These are preset sizes optimized for Wear OS devices, so make sure you use them!

   After that, we set the click event to an empty lamba. In our case, these composables
   are just for a demo, so we won't need that. However, in a real app, we'd communicate
   with a, for example, ViewModel to perform business logic.

   Then we set an Icon inside our button. This code is the same as you have seen for an
   ``Icon`` before. We are also getting our icon from the
   ``androidx.compose.material:material-icons-extended`` library.

   Finally, we set the modifier we set earlier for Icons.

   If you run the app, you should get something like this:

   |881cfe2dcdef5687.png|

   This is code you have probably already written before (which is great). The difference
   is now you get a button optimized for Wear OS.

   Pretty straightforward, let's look at another one.


Create a Text composable


   In ``ReusableComponents.kt``, search for "**``TODO: Create a Text Composable``**" and
   replace the current composable method with this code.

   **Step 3**

   .. code:: prettyprint

      // TODO: Create a Text Composable
      @Composable
      fun TextExample(modifier: Modifier = Modifier) {
          Text(
              modifier = modifier,
              textAlign = TextAlign.Center,
              color = MaterialTheme.colors.primary,
              text = stringResource(R.string.device_shape)
          )
      }

   We create the `Text <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#Text(kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.font.FontStyle,androidx.compose.ui.text.font.FontWeight,androidx.compose.ui.text.font.FontFamily,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextDecoration,androidx.compose.ui.text.style.TextAlign,androidx.compose.ui.unit.TextUnit,androidx.compose.ui.text.style.TextOverflow,kotlin.Boolean,kotlin.Int,kotlin.Function1,androidx.compose.ui.text.TextStyle)>`__
   composable, set its modifier, align the text, set a color, and finally set the text
   itself from a String resource.

   Text composables should look very familiar to Compose developers and the code is
   actually identical to the code you've used before.

   Let's see what it looks like:

   |b4f0e65e666cf3eb.png|

   The ``TextExample()`` composable function (where we placed our code) now produces a
   Text composable in our main material color. The string is pulled from our
   ``res/values/strings.xml`` file.

   So far, so good. Let's look at our last similar composable, ``Card``.


Create a Card composable


   In ``ReusableComponents.kt``, search for "**``TODO: Create a Card``**" and replace the
   current composable method with this code.

   **Step 4**

   .. code:: prettyprint

      // TODO: Create a Card (specifically, an AppCard) Composable
      @Composable
      fun CardExample(
          modifier: Modifier = Modifier,
          iconModifier: Modifier = Modifier
      ) {
          AppCard(
              modifier = modifier,
              appImage = {
                  Icon(
                      imageVector = Icons.Rounded.Message,
                      contentDescription = "triggers open message action",
                      modifier = iconModifier
                  )
              },
              appName = { Text("Messages") },
              time = { Text("12m") },
              title = { Text("Kim Green") },
              onClick = { /* ... */ }
          ) {
              Text("On my way!")
          }
      }

   Wear is a little different in that we have two major cards, `AppCard <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#AppCard(kotlin.Function0,kotlin.Function1,kotlin.Function1,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Function1,androidx.compose.ui.graphics.painter.Painter,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function1)>`__
   and `TitleCard <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#TitleCard(kotlin.Function0,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Function1,androidx.compose.ui.graphics.painter.Painter,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function1)>`__.

   In our case, we want an `Icon <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#Icon(androidx.compose.ui.graphics.vector.ImageVector,kotlin.String,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color)>`__
   in our card, so we are going to use ``AppCard``. (``TitleCard`` has less slots, see
   `Cards <https://developer.android.google.cn/training/wearables/compose/cards>`__ guide
   for more information.)

   We create the ``AppCard`` composable, set its modifier, add an ``Icon``, add several
   ``Text`` composable parameters (each for a different space on the card), and finally
   set the main content text at the end.

   Let's see what it looks like:

   |430eaf85d8ee5883.png|

   At this point, you probably recognize that for these composables the Compose code is
   virtually the same as you've used before which is great, right? You get to reuse all
   that knowledge you've already gained!

   Ok, let's look at some new composables.


6. Add Wear Unique Composables
------------------------------

   For this section, we will explore the ``Chip`` and ``ToggleChip`` composables.


Create a Chip composable


   `Chips are actually specified in the material guidelines <https://material.io/components/chips>`__, 
   but there isn't an actual composable function in the standard material library.

   They are meant to be a quick, one tap action, which makes especially good sense for a
   Wear device with limited screen real estate.

   Here's a couple variations of the `Chip <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#Chip(kotlin.Function0,androidx.wear.compose.material.ChipColors,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.foundation.layout.PaddingValues,androidx.compose.ui.graphics.Shape,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.semantics.Role,kotlin.Function1)>`__
   composable function to give you an idea of what you can create:

   ====================== ====================== ======================
   |575e497e33ef256a.png| |25fd61613669fc2c.png| |27f034a59f833b93.png|
   ====================== ====================== ======================

   Let's write some code.

   In ``ReusableComponents.kt``, search for "**``TODO: Create a Chip``**" and replace the
   current composable method with this code.

   **Step 5**

   .. code:: prettyprint

      // TODO: Create a Chip Composable
      @Composable
      fun ChipExample(
          modifier: Modifier = Modifier,
          iconModifier: Modifier = Modifier
      ) {
          Chip(
              modifier = modifier,
              onClick = { /* ... */ },
              label = {
                  Text(
                      text = "5 minute Meditation",
                      maxLines = 1,
                      overflow = TextOverflow.Ellipsis
                  )
              },
              icon = {
                  Icon(
                      imageVector = Icons.Rounded.SelfImprovement,
                      contentDescription = "triggers meditation action",
                      modifier = iconModifier
                  )
              },
          )
      }

   The ``Chip`` composable uses many of the same parameters as you are used to with other
   composables (modifier and ``onClick``), so we don't need to review those.

   It also takes a label (which we create a ``Text`` composable for) and an icon.

   The ``Icon`` code should look exactly the same as the code you saw in other
   composables, but for this one, we are pulling the ``Self Improvement`` icon from the
   ``androidx.compose.material:material-icons-extended`` library.

   Let's see what it looks like (remember to scroll down):

   |bd178a52438cfcbc.png|

   Ok, let's look at a variation on ``Toggle``, the ``ToggleChip`` composable.


Create a ToggleChip composable


   `ToggleChip <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#ToggleChip(kotlin.Boolean,kotlin.Function1,kotlin.Function1,kotlin.Function0,androidx.compose.ui.Modifier,kotlin.Function1,kotlin.Function1,androidx.wear.compose.material.ToggleChipColors,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.foundation.layout.PaddingValues,androidx.compose.ui.graphics.Shape)>`__
   is just like a ``Chip`` but allows the user to interact with a radio button, toggle, or
   checkbox.

   ====================== ======================
   |9630812c95359a1c.png| |38eaf923eea16d1b.png|
   ====================== ======================

   In ``ReusableComponents.kt``, search for "**``TODO: Create a ToggleChip``**" and
   replace the current composable method with this code.

   **Step 6**

   .. code:: prettyprint

      // TODO: Create a ToggleChip Composable
      @Composable
      fun ToggleChipExample(modifier: Modifier = Modifier) {
          var checked by remember { mutableStateOf(true) }
          ToggleChip(
              modifier = modifier,
              checked = checked,
              toggleControl = {
                  Switch(
                      checked = checked,
                      modifier = Modifier.semantics {
                          this.contentDescription = if (checked) "On" else "Off"
                      }
                  )
              },
              onCheckedChange = {
                  checked = it
              },
              label = {
                  Text(
                      text = "Sound",
                      maxLines = 1,
                      overflow = TextOverflow.Ellipsis
                  )
              }
          )
      }

   Now the ``ToggleChipExample()`` composable function (where this code exists) generates
   a ``ToggleChip`` using a switch toggle (instead of a checkbox or radio button).

   First, we create a ``MutableState``. We haven't been doing this in the other functions,
   because we are mainly doing UI demos so you can see what Wear offers.

   In a normal app, you would probably want to pass in the checked state and the lambda
   for handling the tap, so the composable can be stateless ( `more info here <https://developer.android.google.cn/jetpack/compose/state#stateful-vs-stateless>`__).

   In our case, we are just keeping it simple to show off what the ``ToggleChip`` looks
   like in action with a working toggle (even though we don't do anything with the state).

   Next, we set the modifier, the checked state, and the toggle control to give us the
   switch we want.

   We then create a lambda for changing the state and finally set the label with a
   ``Text`` composable (and some basic parameters).

   Let's see what it looks like:

   |76a0b8d96fd36438.png|

   Ok, now you've seen a lot of Wear OS specific composables and, as stated before, most
   of the code is almost the same as what you've written before.

   Let's look at something a little more advanced.


7. Migrate to ScalingLazyColumn
-------------------------------

   You probably have used `LazyColumn <https://developer.android.google.cn/jetpack/compose/lists#lazy>`__ 
   in your mobile apps to produce a vertically scrolling list.

   Because a round device is smaller at the top and bottom, there is less space to show
   items. Therefore, Wear OS has its own version of ``LazyColumn`` to better support those
   round devices.

   `ScalingLazyColumn <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#ScalingLazyColumn(androidx.compose.ui.Modifier,androidx.wear.compose.material.ScalingLazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,androidx.wear.compose.material.ScalingParams,androidx.wear.compose.material.ScalingLazyListAnchorType,androidx.wear.compose.material.AutoCenteringParams,kotlin.Function1)>`__
   extends ``LazyColumn`` to support both scaling and transparency at the top and bottom
   of the screen to make the content more readable to the user.

   Here's a demo:

   |198ee8e8fa799f08.gif|

   Notice how as the item gets near the center it scales up to its full size and then as
   it moves away it scales back down (along with getting more transparent).

   Here is a more concrete example from an app:

   |a5a83ab2e5d5230f.gif|

   We've found this really helps with readability.

   Now that you've seen `ScalingLazyColumn <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#ScalingLazyColumn(androidx.compose.ui.Modifier,androidx.wear.compose.material.ScalingLazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,androidx.wear.compose.material.ScalingParams,androidx.wear.compose.material.ScalingLazyListAnchorType,androidx.wear.compose.material.AutoCenteringParams,kotlin.Function1)>`__
   in action, let's get started converting our ``LazyColumn``.

   We will use `Horologist ScalinglazyColumn <https://google.github.io/horologist/compose-layout/#scalinglazycolumn-responsive-layout>`__
   to ensure items in the list have correct padding and are not clipped on different
   device screen sizes.


Convert to a Horologist ScalingLazyColumnState


   In ``MainActivity.kt``, search for "**``TODO: Swap to ScalingLazyColumnState``**" and
   replace that comment and line below with this code, note how we specify which ones are
   the first and last component so that the best padding values are used to avoid any
   content clipping.

   **Step 7**

   .. code:: prettyprint

      // TODO: Swap to ScalingLazyColumnState
      val listState = rememberResponsiveColumnState(
          contentPadding = ScalingLazyColumnDefaults.padding(
              first = ItemType.SingleButton,
              last = ItemType.Chip,
          ),
      )

   The names are almost identical. Just like ``LazyListState`` handles state for a
   ``LazyColumn``, ``ScalingLazyColumnState`` handles it for a ``ScalingLazyColumn``.


Convert to a Horologist ScalingLazyColumn


   Next we swap in ``ScalingLazyColumn``.

   In ``MainActivity.kt``, search for "**``TODO: Swap a ScalingLazyColumn``**". First,
   replace ``LazyColumn`` with Horologist ``ScalingLazyColumn``.

   Then remove ``contentPadding, verticalArrangement, modifier`` and ``autocentering``
   altogether - Horologist ``ScalingLazyColumn`` already provides default settings that
   guarantee a better default visual effect as most of the viewport will be filled with
   list items. In most cases default parameters will be sufficient, if you have header on
   top we recommend putting it into `ResponsiveListHeader <https://github.com/google/horologist/blob/release-0.5.x/compose-material/src/main/java/com/google/android/horologist/compose/material/ResponsiveListHeader.kt>`__
   as a first item.

   **Step 8**

   .. code:: prettyprint

      // TODO: Swap a ScalingLazyColumn (Wear's version of LazyColumn)
      ScalingLazyColumn(
          columnState = listState

   That's it! Let's see what it looks like:

   |442700f212089fd0.png|

   You can see the content is scaled and the transparency is adjusted at the top and
   bottom of the screen as you scroll with very little work to migrate!

   You can really notice it with the meditation composables as you move it up and down.

   Now onto the last topic, Wear OS's ``Scaffold``.


8. Add a Scaffold
-----------------

   `Scaffold <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#Scaffold(androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0)>`__
   provides a layout structure to help you arrange screens in common patterns, just like
   mobile, but instead of an `App Bar, FAB, Drawer, or other mobile specific elements <https://developer.android.google.cn/jetpack/compose/layouts/material#scaffold>`__,
   it supports four Wear specific layouts with top-level components: time, scroll/position
   indicator and the page indicator.

   Here's what they look like:

   .. list-table::

      - 

         - |eb6931f6234ec60a.png|
         - `TimeText <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#TimeText(androidx.compose.ui.Modifier,androidx.wear.compose.material.TimeSource,androidx.compose.ui.text.TextStyle,androidx.compose.foundation.layout.PaddingValues,kotlin.Function0,kotlin.Function1,kotlin.Function0,kotlin.Function1,kotlin.Function0,kotlin.Function1)>`__
      - 

         - |ecd5a88c0e425e55.png|
         - `PositionIndicator <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#PositionIndicator(androidx.compose.foundation.ScrollState,androidx.compose.ui.Modifier,kotlin.Boolean)>`__
      - 

         - |54fbe1811709f17e.png|
         - `PageIndicator <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#HorizontalPageIndicator(androidx.wear.compose.material.PageIndicatorState,androidx.compose.ui.Modifier,androidx.wear.compose.material.PageIndicatorStyle,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.ui.graphics.Shape)>`__

   We'll look at the first three components in detail, but, first, let's put the scaffold
   in place.

   We will be using Horologist ``AppScaffold`` and ``ScreenScaffold`` which add a
   ``TimeText``

   by default to the screen and make sure it animates correctly when navigating between
   screens.

   Additionally, ``ScreenScaffold`` adds a ``PositionIndicator`` for scrollable content.


Add a Scaffold


   Let's add the boilerplate for the ``AppScaffold`` and ``ScreenScaffold`` now.

   Find "**``TODO (Start): Create a AppScaffold (Wear Version)``**" and add the code below
   it.

   **Step 9**

   .. code:: prettyprint

      WearAppTheme {
      // TODO (Start): Create a Horologist AppScaffold (Wear Version)
      AppScaffold {

   Find **``"TODO (Start): Create a ScreenScaffold (Wear Version)"``** and add the code
   below it.

   .. code:: prettyprint

      // TODO (Start): Create a Horologist ScreenScaffold (Wear Version)
      ScreenScaffold( 
          scrollState = listState,
      ){

   Next, make sure you add the closing bracket to the right location.

   Find **``"TODO (End): Create a ScreenScaffold (Wear Version)"``** and add the closing
   bracket there:

   **Step 10**

   .. code:: prettyprint

      // TODO (End): Create a ScreenScaffold (Wear Version)
      }

   Find **``"TODO (End): Create a AppScaffold (Wear Version)"``** and add the closing
   bracket there:

   **Step 10**

   .. code:: prettyprint

      // TODO (End): Create a AppScaffold (Wear Version)
      }

   Let's run it first. You should see something like this:

   |c2cb637a495bc977.png|

   Notice that it adds:

   -  A `TimeText <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#TimeText(androidx.compose.ui.Modifier,androidx.wear.compose.material.TimeSource,androidx.compose.ui.text.TextStyle,androidx.compose.foundation.layout.PaddingValues,kotlin.Function0,kotlin.Function1,kotlin.Function0,kotlin.Function1,kotlin.Function0,kotlin.Function1)>`__
      which uses curved text under the hood and gives developers an easy way to show the
      time without placing the composable or having to do any work with time related
      classes. Additionally, the `Material Guidelines recommend that you display the time <https://developer.android.google.cn/training/wearables/design/overlays#time>`__
      at the top of any screen within the app and it fades away while scrolling.
   -  A `PositionIndicator <https://developer.android.google.cn/reference/kotlin/androidx/wear/compose/material/package-summary#PositionIndicator(androidx.wear.compose.material.ScalingLazyListState,androidx.compose.ui.Modifier,kotlin.Boolean)>`__
      (also known as the Scrolling Indicator) which is an indicator on the right side of
      the screen to show the current indicator location based on the type of state object
      you pass in. In our case, that will be the `ScalingLazyColumnState <https://github.com/google/horologist/blob/release-0.5.x/compose-layout/src/main/java/com/google/android/horologist/compose/layout/ScalingLazyColumnState.kt>`__.

   Ok, let's see what this looks like now:

   |1b6fa8091b920587.png|

   Try scrolling it up and down. You should only see the scrolling indicator show up when
   you are scrolling.

   Nice job, you have finished a UI demo of most of the Wear OS composables!


9. Congratulations
------------------

   Congratulations! You learned the basics of using Compose on Wear OS!

   Now you can reapply all your Compose knowledge to making beautiful Wear OS apps!


What's next?


   Check out the other Wear OS codelabs:

   -  `Create your first Wear OS Tile <https://developer.android.google.cn/codelabs/wear-tiles>`__


Further reading


   -  `Compose for Wear OS is now 1.0 <https://android-developers.googleblog.com/2022/07/compose-for-wear-os-10-stable.html>`__
      blogpost
   -  `Simple sample <https://github.com/android/wear-os-samples#wear-os-samples-repository>`__ of
      Compose for Wear OS on Github
   -  `Build apps for the wrist with Wear OS <https://developer.android.google.cn/wear>`__
      for more guides


Feedback


   We'd love to hear from you about your experiences using Compose for Wear OS and what
   you are able to build! Join the discussion in the `Kotlin Slack <https://surveys.jetbrains.com/s3/kotlin-slack-sign-up>`__ 
   **#compose-wear** channel and keep providing feedback on the `issue tracker <https://issuetracker.google.com/issues/new?component=1077552&template=1598429>`__.

   Happy coding!

.. |2c9dd335c9d65f10.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/2c9dd335c9d65f10.png
.. |31cb08c0fa035400.gif| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/31cb08c0fa035400.gif
.. |d61ffd479bdbcb9f.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/d61ffd479bdbcb9f.png
.. |b059413b0cf9113a.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/b059413b0cf9113a.png
.. |c01826594f360d94.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/c01826594f360d94.png
.. |d6d4b92ac53d9b3e.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/d6d4b92ac53d9b3e.png
.. |d92519e0b932f964.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/d92519e0b932f964.png
.. |881cfe2dcdef5687.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/881cfe2dcdef5687.png
.. |b4f0e65e666cf3eb.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/b4f0e65e666cf3eb.png
.. |430eaf85d8ee5883.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/430eaf85d8ee5883.png
.. |575e497e33ef256a.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/575e497e33ef256a.png
.. |25fd61613669fc2c.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/25fd61613669fc2c.png
.. |27f034a59f833b93.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/27f034a59f833b93.png
.. |bd178a52438cfcbc.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/bd178a52438cfcbc.png
.. |9630812c95359a1c.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/9630812c95359a1c.png
.. |38eaf923eea16d1b.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/38eaf923eea16d1b.png
.. |76a0b8d96fd36438.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/76a0b8d96fd36438.png
.. |198ee8e8fa799f08.gif| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/198ee8e8fa799f08.gif
.. |a5a83ab2e5d5230f.gif| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/a5a83ab2e5d5230f.gif
.. |442700f212089fd0.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/442700f212089fd0.png
.. |eb6931f6234ec60a.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/eb6931f6234ec60a.png
.. |ecd5a88c0e425e55.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/ecd5a88c0e425e55.png
.. |54fbe1811709f17e.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/54fbe1811709f17e.png
.. |c2cb637a495bc977.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/c2cb637a495bc977.png
.. |1b6fa8091b920587.png| image:: https://codelabs.developers.google.cn/static/codelabs/compose-for-wear-os/img/1b6fa8091b920587.png


ğŸŸ© TOC - Modern Android app architecture
========================================

   https://developer.android.google.cn/courses/pathways/android-architecture?hl=en

   Learn about best practices and recommended architecture for building robust, 
   production-quality apps.

   â­ Training level: Intermediate

   * [ğŸ§­] Why invest in app architecture?

      How do you build a successful app? Our advice: think like a building
      architect. If you need help getting started, we have the perfect blueprint
      for success when building on Android. Check out our updated guide to
      Android App Architecture, and build something that your users will love.

   * [ğŸ”¨] Architecture Overview
      `Read article <https://developer.android.google.cn/topic/architecture>`__

      Understand why designing a good app Architecture matters. Learn about
      common architectural principles, the recommended app architecture, how to
      manage dependencies between components, and general best practices.


   * [ğŸ”¨] UI Layer
      `Read article <https://developer.android.google.cn/topic/architecture/ui-layer>`__

      Learn about the role of the UI layer, how to define, manage, expose, and
      consume UI state using the principles of Unidirectional Data Flow, and how
      to show in-progress operations and errors on the screen.


   * [ğŸ§­] The UI layer - MAD Skills

      Get an overview of UI state representation, production and consumption all
      within the context of a unidirectional data flow app.


   * [ğŸ”¨] Data Layer
      `Read article <https://developer.android.google.cn/topic/architecture/data-layer>`__

      Learn about the role of the Data layer, the different entities involved,
      the APIs to expose, threading, how to define a source of truth, the
      different types of data operations, how to test this layer, and examples of
      common tasks this layer usually performs.


   * [ğŸ§­] The Data layer - MAD Skills

      Learn about the data layer and its two basic components: repositories and
      data sources. We'll also cover data immutability, error handling,
      threading, testing and more tricks and recommendations.


   * [ğŸ”¨] Domain Layer
      `Read article <https://developer.android.google.cn/topic/architecture/domain-layer>`__

      Learn about the role of the Domain layer, why it's optional and when you
      should need it, how to better invoke use cases, and examples of common
      tasks this layer could perform.


   * [ğŸ§­] The Domain layer - MAD Skills

      Learn how the domain layer can simplify your app architecture, making it
      easier to understand and test.


   * [ğŸ”¨] Handling UI events
      `Read article <https://developer.android.google.cn/topic/architecture/ui-layer/events>`__

      Learn how to handle different types of UI events in the UI layer for events
      that are triggered both by the user or parts of your code. Also, learn what
      to do if your use case seems to be different from the ones covered in this
      page.


   * [ğŸ§­] Handling UI events - MAD Skills

      Learn about the different types of UI events, the best practices for
      handling them, and more!


   * [ğŸ”¨] Build an offline-first app
      `Read article <https://developer.android.google.cn/topic/architecture/data-layer/offline-first>`__

      This guide helps you design your app to properly handle reads, writes,
      syncs, and conflict resolution on devices with no Internet connectivity.


   * [ğŸ”¨] State holders and UI state
      `Read article <https://developer.android.google.cn/topic/architecture/ui-layer/stateholders>`__

      Take a closer look at state holders and how to deal with the different
      types of state and logic in the UI layer.


   * [ğŸ”¨] State production
      `Read article <https://developer.android.google.cn/topic/architecture/ui-layer/state-production>`__

      Learn best practices about how to model and expose UI state depending on
      the sources of state change.


   * [ğŸ”¨] Recommendations for Android architecture
      `Read article <https://developer.android.google.cn/topic/architecture/recommendations>`__

      Page that consolidates and centralizes important best practices you can
      find in our documentation.


ğŸŸ© TOC - Accessibility
======================

   https://developer.android.google.cn/courses/pathways/make-your-android-app-accessible

   Learn to make your Android apps usable by everyone, including people with accessibility needs.

   â­ Training level: Intermediate


   * [ğŸ§­] Get started with Android Accessibility

      Learn about accessibility and get introduced to the concepts covered in
      this series.

   * [ğŸ§­] Accessibility in Android

      Learn how users with disabilities can modify the default configurations of
      their Android device to make the device more functional for them.

   * [ğŸ§­] Accessibility Services and the Android Accessibility Model

      Learn how the Android Framework communicates with Accessibility Services,
      providing an alternate way for users with disabilities to interact with
      Android devices.


   * [ğŸ”¨] Common accessibility problems
      `Read article <https://developer.android.google.cn/guide/topics/ui/accessibility/apps>`__

      Learn how users with disabilities can modify the default configurations of
      their Android device to make the device more functional for them.


   * [ğŸ”¨] Test your app's accessibility
      `Read article <https://developer.android.google.cn/guide/topics/ui/accessibility/testing>`__

      Learn how to test for accessibility and experience your app from the
      perspective of your users.


   * [ğŸš€] Troubleshoot common accessibility issues
      `Take codelab <https://developer.android.google.cn/codelabs/starting-android-accessibility>`__

      Learn how to implement best practices for content labeling, touch target
      implementation, and contrast implementation, and how to troubleshoot and
      fix these issues.


ğŸš€ Starting Android Accessibility
==================================

https://developer.android.google.cn/codelabs/starting-android-accessibility?hl=en


1. Introduction
---------------


   |logo_accessibility_color_2x_web_96dp.png|

   **Android apps should be usable by everyone, including people with accessibility
   needs**. Common conditions that affect a person's use of an Android device include
   blindness or low vision, deafness or impaired hearing, restricted motor skills,
   cognitive disabilities, and color blindness. And this is just a partial list.

   In this codelab, you will learn about commonly occurring accessibility issues in apps.
   Specifically, you will focus on three such issues:

   1. Missing labels
   2. Inadequate touch targets
   3. Poor contrast between foreground and background

   You will learn how these issues affect users, how you can check if these issues are
   present in your apps, and how you can go about fixing them.

   The codelab is structured in small, discrete steps. Each step focuses on a specific
   aspect of accessibility.


**Audience and Prerequisites**


   This codelab is intended for Android developers who want to understand how to make
   their apps accessible to users with accessibility needs. **No previous knowledge of
   accessibility APIs or guidelines is assumed.**

   This codelab assumes the following:

   1. Basic familiarity with writing Android apps.
   2. Access to an Android device running Lollipop (API level 21) or higher.
   3. Ability to install the `Accessibility Scanner <https://play.google.com/store/apps/details?id=com.google.android.apps.accessibility.auditor&hl=en>`__
      app from the Google Play Store.

   Since this is an entry-level codelab, you will not learn how to use accessibility
   services in this codelab. Instead, you will focus on developing a conceptual
   understanding of common accessibility issues using **Accessibility Scanner**. See the
   links at the end of the codelab for other ways to learn about testing with
   accessibility services like `Switch Access <https://support.google.com/accessibility/android/answer/6122836>`__ 
   and `Talkback <https://support.google.com/accessibility/android/answer/6283677>`__.


2. Getting Set Up
-----------------


What you'll be building


   In this codelab, you'll be working with an existing app, **Counter**. This app allows
   users to track, increment, and decrement a numerical count. Even though the app is
   simple, you'll discover that it has numerous accessibility issues that make it hard for
   many users to properly interact with it.

   During the course of this codelab, you'll improve this app and make it more accessible.
   Your improvements will help blind and low vision users as well as users with mobility
   and dexterity issues. Fixing **Counter** will provide you with basic knowledge about
   accessibility that you can use to improve the accessibility of your own apps.


Download the Code


   You can get the `source code for starting <https://github.com/android/codelab-android-accessibility>`__ 
   of the app from GitHub. Clone the repo, and open **Counter** in Android Studio.

   You'll work in the **master** branch throughout this codelab. If you get stuck (or just
   want to peek ahead), you can see the `finished version of the app <https://github.com/android/codelab-android-accessibility/tree/accessible>`__ 
   on the **accessible** branch.

   Each step in this codelab is structured so that you work on a feature that has been
   implemented in a less accessible manner. By the end of each step, you will have
   modified the code, and you will have made the screen or feature more accessible.


**Launching the demo application**


   1. Launch Android Studio and open the **Counter** project. Make sure a device is
      connected to your computer.
   2. Press the green **Play** icon |Screen Shot 2016-05-11 at 8.53.21 AM.png| from the
      menu bar towards the top of the screen. This should launch the **Counter** app. The
      landing page for that app looks something like this:

   |782e10ac891e76d4.png|

   3. Play with the demo app a little bit, using the increment (**"+"**) and decrement
      (**"-"**) buttons to change the count.

   For many users, this is an easy app to use. But accessibility issues make it
   challenging for some users. You'll find out more about those challenges in this
   codelab.

   First, you'll set up `Accessibility Scanner <https://play.google.com/store/apps/details?id=com.google.android.apps.accessibility.auditor&hl=en>`__,
   the tool you'll be using in this codelab to identify accessibility issues.


3. Accessibility Scanner
------------------------


   **Accessibility Scanner** is a tool created by Google that suggests accessibility
   improvements for Android appsâ€”such as enlarging small touch targets, increasing
   contrast, and providing content descriptionsâ€”so that individuals with accessibility
   needs can use your app more easily.

   |Accessibility Scanner on the Play Store|

   You can download and configure **Accessibility Scanner** using the following steps:

   1. `Download Accessibility Scanner from the Google Play Store <https://play.google.com/store/apps/details?id=com.google.android.apps.accessibility.auditor>`__.
   2. After you've installed **Accessibility Scanner**, navigate to **Settings >
      Accessibility** on your device. Locate and turn on Accessibility Scanner (Tap
      **"Allow"** or **"OK"**, then **"Begin Authorization"** to complete the setup
      workflow).
   3. Return to the **Counter** app. Your screen should now look like this:

   |e79b056386dbc742.png|

   You'll notice that **Accessibility Scanner** creates a blue Floating Action Button
   (FAB), which is overlaid on top of any content you have on the screen.

   |fb39571ce90d713.png|

   You can tap the FAB to start an accessibility scan (you'll do that in a moment). To
   move the FAB to another area of the screen, you can long-press on it and drag it.


4. Scanning the Counter App
---------------------------


   In this section you'll perform an accessibility audit of the screen using
   **Accessibility Scanner**:

   1. Tap on |fb39571ce90d713.png| to launch the scan. When you do this, **Accessibility
      Scanner** examines the UI of your screen, performs a quick audit for accessibility,
      and prepares suggestions for accessibility-related improvement.
   2. Examine the output from running a scan. It should look something like this:

   |bdd8e1ce7558eb81.png|

   **Accessibility Scanner** highlights the views that may have accessibility issues, and
   offers suggestions for how you can fix those issues.


Understanding Accessibility **Scanner's suggestions**


   **Accessibility Scanner** has five suggestions for improving **Counter**'s
   accessibility.


Insufficient contrast


   **Accessibility Scanner** recommends fixing the poor color contrast in the view that
   shows the current count.

   1. Tap on the count field, outlined in orange in the middle of the screen, and see
      **Scanner's** suggestion:

   |fa2bf7446019bf2c.png|

   2. Expand the error and see details about how to apply **Scanner's** suggestion. You'll
      notice that **Scanner** shows you the foreground and background colors and the
      existing and suggested contrast ratios:

   |b88532209a57e916.png|

   **Why does color contrast matter for accessibility?** Users with impaired vision have
   more difficulty reading information on a screen if there is not enough contrast between
   the foreground and background colors. **Low contrast ratios can cause views to blur
   together for some users**, while high contrast ratios make the views stand out more
   clearly. Different lighting situations can amplify the difficulties created by low
   contrast ratios.

   A *temporary* or *situational* disability can often pose accessibility-related
   challenges for users who do not consider themselves to have an accessibility need and
   who do not usually rely on assistive technologies.

   In this example, even a person with good eyesight may find that due to the low color
   contrast, the count field might be harder to read in bright outdoor light, thus making
   the app less accessible.

   Thinking about accessibility helps **all** users, not just users with accessibility
   needs.


**Missing labels**


   **Scanner** flags the missing labels in the **"-"** and **"+"** ``ImageButtons``, which
   makes it hard for screenreader users to know the purpose of these controls.

   1. Tap on the errors associated with either the **"-"** and **"+"** buttons, and read
      the suggestions related to the missing labels:

   |4c8476ac798a3089.png|

   **Why are missing labels problematic for accessibility?** Users who are blind or
   visually impaired use screenreaders like `Talkback <https://support.google.com/accessibility/android/answer/6283677>`__ 
   to interact with their devices. Talkback announces the screen content to the user who can
   then interact with the discovered content. When an element does not have associated
   text (an ``ImageButton``, for example), Talkback doesn't know how to properly convey
   that element's purpose to the user; in such a case, it may default to announcing
   "Unlabelled button", which is unhelpful to the user. When you provide a properly
   descriptive label, Talkback can announce it to the user.


**Insufficient Touch Targets**


   In addition to the missing labels, **Scanner** suggests increasing the touchable area
   for the **"-"** and **"+"** buttons:

   |4bde82d712530aaf.png|

   **Why are small touch targets problematic for accessibility?** Many people have
   difficulty focusing on small touch targets on the screen. This could simply be because
   their fingers are large, or because they have a medical condition that impairs their
   motor skills. Small touch targets also make it harder for screen reader users to
   navigate apps by moving a finger around the screen, such as when using the 
   `Explore by Touch <https://support.google.com/accessibility/android/answer/6006598>`__ 
   feature in TalkBack.

   Inadequate touch target sizes make apps less accessible for all users in some
   circumstances, not just users with accessibility needs.

   In the case of the increment/decrement buttons, the touch area is small even for a user
   with excellent motor skills. If such a user were to rapidly tap either button for a few
   seconds, they might notice that some of their touches don't register. If they tried
   doing this while walking (with reduced touch precision), the experience could be even
   more challenging.

   Remember, thinking about accessibility helps all users, not just users with
   accessibility needs.


**Summary**


   You've explored only a tiny fraction of the functionality provided by **Accessibility
   Scanner**. But the suggestions that **Accessibility Scanner** providedâ€”those related to
   color contrast, item labels, and touch targetsâ€”commonly appear in Android apps.
   Applying the suggestions can go a long way towards making your apps more accessible.
   And the fixes are often pretty straightforward.

   So, let's get coding!


5. Ensuring Adequate Color Contrast
-----------------------------------


   In **Counter**, the color contrast is straightforward to improve. The ``TextView``
   displaying the count uses a light grey background and a grey text color:

   .. code:: prettyprint

      <TextView
         ...
         android:background="@color/lightGrey"
         android:textColor="@color/grey"
         ...
       />

   You can remove the background, pick a lighter background, or pick a darker text color.
   In this codelab, you'll pick a darker text color. Here are some colors that have been
   defined for you in **colors.xml**:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <resources>
         ...
         <color name="lightGrey">#EEEEEE</color>
         <color name="grey">#999999</color>
         <color name="darkGrey">#666666</color>
      </resources>

   Open **res/layout/activity_main.xml** and change ``android:textColor="@color/grey"`` to
   ``android:textColor="@color/darkGrey"`` :

   .. code:: prettyprint

      <TextView
         ...
         android:background="@color/lightGrey"
         android:textColor="@color/darkGrey"
         ...
       />

   Now run the app, and observe the changed contrast:

   ====================== ======================
   Before                  After
   |e48af782c716ea54.png| |d0d90bf68ab4f5a6.png|
   ====================== ======================

   The contrast ratio is now 4.94:1, which is considerably better than 2.45: 1, which is
   what you had before:

   ====== ============== ==================== ==================
   \      **Background** **Text Color**       **Contrast ratio**
   Before #EEEEEE        Light gray (#999999) **2.45:1**
   After  #EEEEEE        Dark gray (#666666)  **4.94:1**
   ====== ============== ==================== ==================

   So, what constitutes adequate contrast? The `Web Content Accessibility
   Guidelines <https://www.w3.org/WAI/standards-guidelines/wcag/>`__ recommend a 
   `minimum contrast ratio <http://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html>`__
   of **4.5:1** for all text, with a contrast ratio of **3.0:1** considered acceptable for
   large or bold text. Try to meet or exceed these contrast ratios in your applications.

   **Accessibility Scanner** will help you spot color contrast issues once you have a
   working app. But it is better to consider contrast issues while designing the color
   palette of your app. You can use `one of the many contrast checkers <http://webaim.org/resources/contrastchecker/>`__ 
   available online to check your contrast ratios.

   |fb39571ce90d713.png| Press the FAB to begin another scan using **Accessibility
   Scanner,** and you'll see that the app no longer makes any suggestions related to color
   contrast:

   |5b375bcb2af0d91d.png|

   **Accessibility Scanner** still has 4 suggestions for improving **Counter**'s
   accessibility, so let's keep working on the app.


6. Adding Missing Labels
------------------------


   Since the **"-"** and **"+"** ``ImageButtons`` are missing labels, a screenreader like
   Talkback cannot properly relay the views' semantics to the user, and it simply
   announces "Unlabelled, Button" when a user focuses on either button:

   |a2b9ac2003f260cf.png|

   To fix this, assign an **``android:contentDescription``** for each button:

   .. code:: prettyprint

      <ImageButton
         android:id="@+id/subtract_button"
         ...
         
         android:contentDescription="@string/decrement" />


      <ImageButton
         android:id="@+id/add_button"
         ...
         android:contentDescription="@string/increment" />

   Ensure that you use localized strings for content descriptions so that they can be
   properly translated. For this codelab, the strings have already been defined in
   **res/values/strings.xml**.

   A screenreader now announces the value of the ``contentDescription`` that you provided
   (appropriately translated to the locale language) when the screenreader user focuses on
   the buttons.

   Note: In this codelab, you won't be turning on and learning how to use TalkBack;
   instead, you'll continue to use **Accessibility Scanner** to audit the app's
   accessibility. To learn how to use Talkback to debug your apps' accessibility, consider
   working through the `Basic Android Accessibility <https://codelabs.developers.google.cn/codelabs/basic-android-accessibility/>`__
   codelab.

   |fb39571ce90d713.png| Run **Accessibility Scanner** again. You'll notice that there are
   no suggestions related to missing labels.

   |ee84419e9b6b5866.png|


7. Making Touch Targets Larger
------------------------------


   **Accessibility Scanner** continues to suggest that the **"-"** and **"+"** should have
   a larger touch size. In this step, you'll follow that suggestion.

   The two buttons in **Counter** are small (24dp X 24dp). In general, you want the
   touchable area of focusable items to be at least 48dp X 48dp. Larger than that is even
   better. Note that by increasing the touchable area from 24dp X 24dp to 48dp X 48dp, you
   expand the touchable area by a factor of 4.

   You have several options for increasing the touchable area of the buttons. For example,
   you can do either of the following:

   -  Add padding around the icons.
   -  Add a ``minWidth`` and/or a ``minHeight`` (this will make the icons larger).
   -  Register a `TouchDelegate <https://developer.android.google.cn/reference/android/view/TouchDelegate>`__.

   Before you change anything, let's get a better sense of how the buttons' touchable area
   can be measured.


**Tooling and layout bounds**


   For this step, make sure you enable `Developer Options <https://developer.android.google.cn/studio/debug/dev-options>`__ 
   on your device.

   Go to **Settings > System > Developer Options**. Under the **Drawing** category, enable
   **"Show layout bounds"**. Your screen should now show the clip bounds, margins, etc. of
   every visible view.

   |Screenshot showing layout bounds on screen.|

   Now observe the layout bounds of **Counter** screen, focusing on the two
   buttons:

   |9dd9b146259ae346.png|

   The touchable area extends only to the layout bounds of the icons, and **Accessibility
   Scanner** has already informed you that the touchable area (24dp X 24dp) is too small.
   Let's increase the area for both buttons.

   Looking at **res/layout/activity_main.xml**, you see the following definitions for the
   two buttons:

   .. code:: prettyprint

      <ImageButton
         android:id="@+id/add_button"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         ... />


      <ImageButton
         android:id="@+id/subtract_button"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
        ... />

   Add some padding to each view:

   .. code:: prettyprint

      <ImageButton
         ...
         android:padding="@dimen/icon_padding"
         ... />


      <ImageButton
         ...
         android:padding="@dimen/icon_padding"
        ... />

   The value of ``@dimen/icon_padding`` is set to 12dp (see **res/dimens.xml**). When this
   padding is applied, the touchable area of the control becomes 48dp X 48dp (24dp + 12dp
   in each direction).

   Run the app again to confirm the new layout bounds:

   ====================== ======================
   Before                  After
   |955fe903fe7eab70.png| |d931e161aa1b6047.png|
   ====================== ======================

   Go back to **Settings > Developer Options > Drawing** category, find "**Show layout
   bounds**", and turn it off.

   |fb39571ce90d713.png| Run **Accessibility Scanner** again. This time, the scan should
   complete without suggestions:

   |29debb90665c4fcc.png|

   Congratulations, by completing these few simple steps, you've made your app more
   accessible!


8. Limitations of Accessibility Scanner
---------------------------------------


   While tools like **Accessibility Scanner** can help you make some significant
   improvements to your app's accessibility, these tools are no replacement for manual
   testing.

   Accessibility needs to be approached holisticallyâ€”**Accessibility Scanner**, for
   example, will tell you if you're missing a label, but cannot tell whether that label
   makes sense. Generally, **Accessibility Scanner** cannot determine whether your user
   interface conveys semantic information simply and clearly. In addition, **Accessibility
   Scanner** cannot report on how well an app supports multiple modes of interaction
   (touch vs. voice), or if users can successfully complete your app's most common use
   cases. But **Accessibility Scanner** provides an introduction to accessibility, and
   it's an invaluable accessibility tool that you should consider using often.

   **Accessibility Scanner gets you started with accessibility. But always remember to
   test with real users.**


Turning off Accessibility Scanner


   Navigate to **Settings > Accessibility** and set **Accessibility Scanner** to **Off.**


9. Links and Resources
----------------------


   You've touched on a lot of topics related to Android accessibility. Here are some links
   and resources you can explore:

   -  To continue learning about Android accessibility, visit `developer.android.com <https://developer.android.google.cn/guide/topics/ui/accessibility/index.html>`__.
   -  To learn more about accessibility services, visit the `Android Accessibility Help Center <https://support.google.com/accessibility/android>`__, 
      where you can find documentation for **TalkBack**, **Voice Access**, **Switch Access**, 
      and other Android accessibility features.
   -  Read about the `accessibility and Material Design. <https://m3.material.io/foundations/accessible-design/overview>`__


.. |logo_accessibility_color_2x_web_96dp.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/bd6e392271bac146.png
.. |Screen Shot 2016-05-11 at 8.53.21 AM.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/1fecbe8cf96f1d28.png
.. |782e10ac891e76d4.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/782e10ac891e76d4.png
.. |Accessibility Scanner on the Play Store| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/80422bba6e519497.png
.. |e79b056386dbc742.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/e79b056386dbc742.png
.. |fb39571ce90d713.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/fb39571ce90d713.png
.. |bdd8e1ce7558eb81.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/bdd8e1ce7558eb81.png
.. |fa2bf7446019bf2c.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/fa2bf7446019bf2c.png
.. |b88532209a57e916.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/b88532209a57e916.png
.. |4c8476ac798a3089.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/4c8476ac798a3089.png
.. |4bde82d712530aaf.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/4bde82d712530aaf.png
.. |e48af782c716ea54.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/e48af782c716ea54.png
.. |d0d90bf68ab4f5a6.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/d0d90bf68ab4f5a6.png
.. |5b375bcb2af0d91d.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/5b375bcb2af0d91d.png
.. |a2b9ac2003f260cf.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/a2b9ac2003f260cf.png
.. |ee84419e9b6b5866.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/ee84419e9b6b5866.png
.. |Screenshot showing layout bounds on screen.| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/3538af1684a9d265.png
.. |9dd9b146259ae346.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/9dd9b146259ae346.png
.. |955fe903fe7eab70.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/955fe903fe7eab70.png
.. |d931e161aa1b6047.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/d931e161aa1b6047.png
.. |29debb90665c4fcc.png| image:: https://developer.android.google.cn/static/codelabs/starting-android-accessibility/img/29debb90665c4fcc.png



ğŸŸ© TOC - Kotlin coroutines
==========================

   https://developer.android.google.cn/courses/pathways/android-coroutines?hl=en

   Use coroutines to simplify task management for commons use cases like making 
   network calls and accessing local data.

   â­ Training level: Intermediate

   *  Use Kotlin coroutines in your Android apps
      `Take codelab <https://developer.android.google.cn/codelabs/kotlin-coroutines>`__

      Learn best practices for integrating coroutines into your appâ€™s UI, as well
      as with Room, Retrofit, and WorkManager.

   *  Threading in CoroutineWorker

      Learn to use WorkManager with coroutines to schedule asynchronous tasks
      that run even if the app exits or the device restarts.

   *  Access data with Room data access objects
      `Read article <https://developer.android.google.cn/training/data-storage/room/accessing-data>`__

      Learn to add the suspend Kotlin keyword to your DAO methods to make them
      asynchronous with Kotlin coroutines functionality.

   *  Android Room with a View-Kotlin
      `Take codelab <https://developer.android.google.cn/codelabs/android-room-with-a-view-kotlin>`__

      Learn to build an app that gets and saves data from a database using
      Android Architecture Components with coroutines.


ğŸš€ Use Kotlin Coroutines in your Android App
=============================================

https://developer.android.google.cn/codelabs/kotlin-coroutines


1. Before you begin
-------------------


   In this codelab you'll learn how to use `Kotlin Coroutines <https://kotlinlang.org/docs/reference/coroutines.html>`__ 
   in an Android appâ€”the recommended way of managing background threads that can 
   simplify code by reducing the need for callbacks.

   Coroutines are a Kotlin feature that converts async callbacks for long-running tasks,
   such as database or network access, into *sequential* code.

   Here is a code snippet to give you an idea of what you'll be doing:

   .. code:: prettyprint

      // Async callbacks
      networkRequest { result ->
         // Successful network request
         databaseSave(result) { rows ->
           // Result saved
         }
      }

   The callback-based code will be converted to sequential code using coroutines:

   .. code:: prettyprint

      // The same code with coroutines
      val result = networkRequest()
      // Successful network request
      databaseSave(result)
      // Result saved

   You will start with an existing app, built using `Architecture Components <https://developer.android.google.cn/topic/libraries/architecture/>`__, 
   that uses a callback style for long-running tasks.

   By the end of this codelab, you'll have enough experience to use coroutines in your app
   to load data from the network, and you will be able to integrate coroutines into an
   app. You'll also be familiar with best practices for coroutines, and how to write a
   test against code that uses coroutines.


**Prerequisites**


   -  Familiarity with the Architecture Components ``ViewModel``, ``LiveData``,
      ``Repository``, and ``Room``.
   -  Experience with Kotlin syntax, including extension functions and lambdas.
   -  A basic understanding of using threads on Android, including the main thread,
      background threads, and callbacks.


**What you'll do**


   -  Call code written with coroutines and obtain results.
   -  Use suspend functions to make async code sequential.
   -  Use ``launch`` and ``runBlocking`` to control how code executes.
   -  Learn techniques to convert existing APIs to coroutines using ``suspendCoroutine``.
   -  Use coroutines with Architecture Components.
   -  Learn best practices for testing coroutines.

   -  For an introduction to Room, see 
      `Accessing data using Room DAOs <https://developer.android.google.cn/training/data-storage/room/accessing-data>`__.
   -  For an introduction to the other Architecture Components used in this codelab, see
      `Guide to app architecture <https://developer.android.google.cn/jetpack/docs/guide>`__.
   -  For an introduction to Kotlin syntax, see 
      `Kotlin Bootcamp for Programmers <https://www.udacity.com/course/kotlin-bootcamp-for-programmers--ud9011>`__.
   -  For an introduction to threading basics on Android, see 
      `Running Android tasks in background threads <https://developer.android.google.cn/guide/background/threading>`__.


**What you'll need**


   -  `Android Studio 4.1 <https://developer.android.google.cn/studio/>`__ (the codelab
      may work with other versions, but some things might be missing or look different).

   If you run into any issues (code bugs, grammatical errors, unclear wording, etc.) as
   you work through this codelab, please report the issue via the **Report a mistake**
   link in the lower left corner of the codelab.


2. Getting set up
-----------------


**Download the code**


   Click the following link to download all the code for this codelab:

   `Download Zip <https://github.com/android/codelab-kotlin-coroutines/archive/master.zip>`__

   ... or clone the GitHub repository from the command line by using the following
   command:

   ::

      $ git clone https://github.com/android/codelab-kotlin-coroutines.git

   The **kotlin-coroutines** repository contains the code for two codelabs. This codelab
   uses the project in the **coroutines-codelab** directory. There are two app modules in
   that project:

   -  |android_studio_folder.png| **start** â€” Simple app that uses Android Architecture
      Components that you will add coroutines to
   -  |android_studio_folder.png| **finished_code** â€” The project with coroutines already
      added


Frequently asked questions


   -  `How do I install Android Studio? <https://developer.android.google.cn/studio/>`__
   -  `How do I set up a device for development? <http://developer.android.google.cn/tools/device.html>`__


3. Run the starting sample app
------------------------------


   First, let's see what the starting sample app looks like. Follow these instructions to
   open the sample app in Android Studio.

   1. If you downloaded the ``kotlin-coroutines`` zip file, unzip the file.
   2. Open the ``coroutines-codelab`` project in Android Studio.
   3. Select the ``start`` application module.
   4. Click the |execute.png|\ **Run** button, and either choose an emulator or connect
      your Android device, which must be capable of running Android Lollipop (the minimum
      SDK supported is 21). The Kotlin Coroutines screen should appear:


|1d65055551232a9.png|


   If you see a "**Android framework is detected. Click to configure**" error message,
   ensure that you're opening the ``coroutines-codelab`` directory and not the parent
   directory.

   This starter app uses threads to increment the count a short delay after you press the
   screen. It will also fetch a new title from the network and display it on screen. Give
   it a try now, and you should see the count and message change after a short delay. In
   this codelab you'll convert this application to use coroutines.

   This app uses Architecture Components to separate the UI code in ``MainActivity`` from
   the application logic in ``MainViewModel``. Take a moment to familiarize yourself with
   the structure of the project.

   |cbc7d16909facb7c.png|

   1. ``MainActivity`` displays the UI, registers click listeners, and can display a
      ``Snackbar``. It passes events to ``MainViewModel`` and updates the screen based on
      ``LiveData`` in ``MainViewModel``.
   2. ``MainViewModel`` handles events in ``onMainViewClicked`` and will communicate to
      ``MainActivity`` using ``LiveData.``
   3. ``Executors`` defines ``BACKGROUND,`` which can run things on a background thread.
   4. ``TitleRepository`` fetches results from the network and saves them to the database.


**Adding coroutines to a project**


   To use coroutines in Kotlin, you must include the ``coroutines-core`` library in the
   ``build.gradle (Module: app)`` file of your project. The codelab projects have already
   done this for you, so you don't need to do this to complete the codelab.

   Coroutines on Android are available as a core library, and Android specific extensions:

   -  **kotlinx-coroutines-core** â€” Main interface for using coroutines in Kotlin
   -  **kotlinx-coroutines-android** â€” Support for the Android Main thread in coroutines

   The starter app already includes the dependencies in ``build.gradle.``\ When creating a
   new app project, you'll need to open ``build.gradle (Module: app)`` and add the
   coroutines dependencies to the project.

   ::

      dependencies {
        ...
        implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:x.x.x"
        implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:x.x.x"
      }

   You can find the latest version number of the Coroutines library to substitute for
   "x.x.x" on the `Kotlin Coroutines releases page <https://github.com/Kotlin/kotlinx.coroutines/releases>`__.

   **Coroutines and RxJava**

   If you're using `RxJava <https://github.com/ReactiveX/RxJava>`__ in your current
   codebase, you can integrate with coroutines by using a `kotlin-coroutines-rx <https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive>`__
   library.


4. Coroutines in Kotlin
-----------------------


   On Android, it's essential to avoid blocking the main thread. The main thread is a
   single thread that handles all updates to the UI. It's also the thread that calls all
   click handlers and other UI callbacks. As such, it has to run smoothly to guarantee a
   great user experience.

   For your app to display to the user without any visible pauses, the main thread has to
   update the screen roughly `every 16ms <https://medium.com/androiddevelopers/exceed-the-android-speed-limit-b73a0692abc1>`__,
   which is about 60 frames per second. Many common tasks take longer than this, such as
   parsing large JSON datasets, writing data to a database, or fetching data from the
   network. Therefore, calling code like this from the main thread can cause the app to
   pause, stutter, or even freeze. And if you block the main thread for too long, the app
   may even crash and present an **Application Not Responding** dialog.

   Watch the video below for an introduction to how coroutines solve this problem for us
   on Android by introducing main-safety.


**The callback pattern**


   One pattern for performing long-running tasks without blocking the main thread is
   callbacks. By using callbacks, you can start long-running tasks on a background thread.
   When the task completes, the callback is called to inform you of the result on the main
   thread.

   Take a look at an example of the callback pattern.

   .. code:: prettyprint

      // Slow request with callbacks
      @UiThread
      fun makeNetworkRequest() {
          // The slow network request runs on another thread
          slowFetch { result ->
              // When the result is ready, this callback will get the result
              show(result)
          }
          // makeNetworkRequest() exits after calling slowFetch without waiting for the result
      }

   Because this code is annotated with `@UiThread <https://developer.android.google.cn/reference/android/support/annotation/UiThread>`__,
   it must run fast enough to execute on the main thread. That means, it needs to return
   very quickly, so that the next screen update is not delayed. However, since
   ``slowFetch`` will take seconds or even minutes to complete, the main thread can't wait
   for the result. The ``show(result)`` callback allows ``slowFetch`` to run on a
   background thread and return the result when it's ready.


**Using coroutines to remove callbacks**


   Callbacks are a great pattern, however they have a few drawbacks. Code that heavily
   uses callbacks can become hard to read and harder to reason about. In addition,
   callbacks don't allow the use of some language features, such as exceptions.

   Kotlin coroutines let you convert callback-based code to sequential code. Code written
   sequentially is typically easier to read, and can even use language features such as
   exceptions.

   In the end, they do the exact same thing: wait until a result is available from a
   long-running task and continue execution. However, in code they look very different.

   The keyword ``suspend`` is Kotlin's way of marking a function, or function type,
   available to coroutines. When a coroutine calls a function marked ``suspend``, instead
   of blocking until that function returns like a normal function call, it **suspends**
   execution until the result is ready then it **resumes** where it left off with the
   result. While it's suspended waiting for a result, **it unblocks the thread that it's
   running on** so other functions or coroutines can run.

   For example in the code below, ``makeNetworkRequest()`` and ``slowFetch()`` are both
   ``suspend`` functions.

   .. code:: prettyprint

      // Slow request with coroutines
      @UiThread
      suspend fun makeNetworkRequest() {
          // slowFetch is another suspend function so instead of 
          // blocking the main thread  makeNetworkRequest will `suspend` until the result is 
          // ready
          val result = slowFetch()
          // continue to execute after the result is ready
          show(result)
      }

      // slowFetch is main-safe using coroutines
      suspend fun slowFetch(): SlowResult { ... }

   Just like with the callback version, ``makeNetworkRequest`` must return from the main
   thread right away because it's marked ``@UiThread``. This means that usually it could
   not call blocking methods like ``slowFetch``. Here's where the ``suspend`` keyword
   works its magic.

   **Important**: The ``suspend`` keyword doesn't specify the thread code runs on. Suspend
   functions may run on a background thread or the main thread.

   Compared to callback-based code, coroutine code accomplishes the same result of
   unblocking the current thread with less code. Due to its sequential style, it's easy to
   chain several long running tasks without creating multiple callbacks. For example, code
   that fetches a result from two network endpoints and saves it to the database can be
   written as a function in coroutines with no callbacks. Like so:

   .. code:: prettyprint

      // Request data from network and save it to database with coroutines

      // Because of the @WorkerThread, this function cannot be called on the
      // main thread without causing an error.
      @WorkerThread
      suspend fun makeNetworkRequest() {
          // slowFetch and anotherFetch are suspend functions
          val slow = slowFetch()
          val another = anotherFetch()
          // save is a regular function and will block this thread
          database.save(slow, another)
      }

      // slowFetch is main-safe using coroutines
      suspend fun slowFetch(): SlowResult { ... }
      // anotherFetch is main-safe using coroutines
      suspend fun anotherFetch(): AnotherResult { ... }

   **Coroutines by another name**

   The pattern of ``async`` and ``await`` in other languages is based on coroutines. If
   you're familiar with this pattern, the ``suspend`` keyword is similar to ``async``.
   However in Kotlin, ``await()`` is implicit when calling a ``suspend`` function.

   Kotlin has a method ``Deferred.await()`` that is used to wait for the result from a
   coroutine started with the ``async`` builder.

   You will introduce coroutines to the sample app in the next section.


5. Controlling the UI with coroutines
-------------------------------------


   In this exercise you will write a coroutine to display a message after a delay. To get
   started, make sure you have the module ``start`` open in Android Studio.


Understanding CoroutineScope


   In Kotlin, all coroutines run inside a `CoroutineScope <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/>`__.
   A scope controls the lifetime of coroutines through its job. When you cancel the job of
   a scope, it cancels all coroutines started in that scope. On Android, you can use a
   scope to cancel all running coroutines when, for example, the user navigates away from
   an ``Activity`` or ``Fragment``. Scopes also allow you to specify a default dispatcher.
   A dispatcher controls which thread runs a coroutine.

   For coroutines started by the UI, it is typically correct to start them on
   `Dispatchers.Main <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html>`__
   which is the main thread on Android. A coroutine started on `Dispatchers.Main <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html>`__
   won't block the main thread while suspended. Since a ``ViewModel`` coroutine almost
   always updates the UI on the main thread, starting coroutines on the main thread saves
   you extra thread switches. A coroutine started on the Main thread can switch
   dispatchers any time after it's started. For example, it can use another dispatcher to
   parse a large JSON result off the main thread.

   **Coroutines offer main-safety**

   Because coroutines can easily switch threads at any time and pass results back to the
   original thread, it's a good idea to start UI-related coroutines on the Main thread.

   Libraries like `Room <https://developer.android.google.cn/jetpack/androidx/releases/room>`__ 
   and `Retrofit <https://github.com/square/retrofit>`__ offer **main-safety** out of the
   box when using coroutines, so you don't need to manage threads to make network or
   database calls. This can often lead to substantially simpler code.

   However, **blocking code** like sorting a list or reading from a file still requires
   explicit code to create **main-safety**, even when using coroutines. This is also true
   if you're using a networking or database library that doesn't (yet) support coroutines.


**Using viewModelScope**


   The AndroidX ``lifecycle-viewmodel-ktx`` library adds a CoroutineScope to ViewModels
   that's configured to start UI-related coroutines. To use this library, you must include
   it in the ``build.gradle (Module: start)`` file of your project. That step is already
   done in the codelab projects.

   ::

      dependencies {
        ...
        // replace x.x.x with latest version
        implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:x.x.x"
      }

   The library adds a `viewModelScope <https://developer.android.google.cn/topic/libraries/architecture/coroutines#viewmodelscope>`__
   as an extension function of the ``ViewModel`` class. This scope is bound to
   ``Dispatchers.Main`` and will automatically be cancelled when the ``ViewModel`` is
   cleared.


**Switch from threads to coroutines**


   In ``MainViewModel.kt`` find the next TODO along with this code:


**MainViewModel.kt**


   .. code:: prettyprint

      /**
      * Wait one second then update the tap count.
      */
      private fun updateTaps() {
         // TODO: Convert updateTaps to use coroutines
         tapCount++
         BACKGROUND.submit {
             Thread.sleep(1_000)
             _taps.postValue("$tapCount taps")
         }
      }

   This code uses the ``BACKGROUND ExecutorService`` (defined in ``util/Executor.kt``) to
   run in a background thread. Since ``sleep`` blocks the current thread it would freeze
   the UI if it were called on the main thread. One second after the user clicks the main
   view, it requests a snackbar.

   You can see that happen by removing the BACKGROUND from the code and running it again.
   The loading spinner won't display and everything will "jump" to the final state one
   second later.


**MainViewModel.kt**


   .. code:: prettyprint

      /**
      * Wait one second then update the tap count.
      */
      private fun updateTaps() {
         // TODO: Convert updateTaps to use coroutines
         tapCount++
         Thread.sleep(1_000)
         _taps.postValue("$tapCount taps")
      }

   Replace ``updateTaps`` with this coroutine based code that does the same thing. You
   will have to import ``launch`` and ``delay``.


**MainViewModel.kt**


   .. code:: prettyprint

      /**
      * Wait one second then display a snackbar.
      */
      fun updateTaps() {
         // launch a coroutine in viewModelScope
         viewModelScope.launch {
             tapCount++
             // suspend this coroutine for one second
             delay(1_000)
             // resume in the main dispatcher
             // _snackbar.value can be called directly from main thread
             _taps.postValue("$tapCount taps")
         }
      }

   This code does the same thing, waiting one second before showing a snackbar. However,
   there are some important differences:

   1. ``viewModelScope.`` `launch <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html>`__
      will start a coroutine in the ``viewModelScope``. This means when the job that we
      passed to ``viewModelScope`` gets canceled, all coroutines in this job/scope will be
      cancelled. If the user left the Activity before ``delay`` returned, this coroutine
      will automatically be cancelled when ``onCleared`` is called upon destruction of the
      ViewModel.
   2. Since ``viewModelScope`` has a default dispatcher of ``Dispatchers.Main``, this
      coroutine will be launched in the main thread. We'll see later how to use different
      threads.
   3. The function ``delay`` is a ``suspend`` function. This is shown in Android Studio by
      the |716807c07961aacd.png| icon in the left gutter. Even though this coroutine runs
      on the main thread, ``delay`` won't block the thread for one second. Instead, the
      dispatcher will schedule the coroutine to resume in one second at the next
      statement.

   Go ahead and run it. When you click on the main view you should see a snackbar one
   second later.

   In the next section we'll consider how to test this function.


6. Testing coroutines through behavior
--------------------------------------


   In this exercise you'll write a test for the code you just wrote. This exercise shows
   you how to test coroutines running on ``Dispatchers.Main`` using the
   `kotlinx-coroutines-test <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/>`__
   library. Later in this codelab you'll implement a test that interacts with coroutines
   directly.

   The ``kotlinx-coroutines-test`` library used in this section is marked as experimental
   and may have breaking changes before release.


**Review the existing code**


   Open ``MainViewModelTest.kt`` in the ``test`` folder.


**MainViewModelTest.kt**


   .. code:: prettyprint

      class MainViewModelTest {
         @get:Rule
         val coroutineScope =  MainCoroutineScopeRule()
         @get:Rule
         val instantTaskExecutorRule = InstantTaskExecutorRule()

         lateinit var subject: MainViewModel

         @Before
         fun setup() {
             subject = MainViewModel(
                 TitleRepository(
                         MainNetworkFake("OK"),
                         TitleDaoFake("initial")
                 ))
         }
      }

   A rule is a way to run code before and after the execution of a test in JUnit. Two
   rules are used to allow us to test MainViewModel in an off-device test:

   1. `InstantTaskExecutorRule <https://developer.android.google.cn/reference/androidx/arch/core/executor/testing/InstantTaskExecutorRule>`__
      is a JUnit rule that configures ``LiveData`` to execute each task synchronously
   2. ``MainCoroutineScopeRule`` is a custom rule in this codebase that configures
      ``Dispatchers.Main`` to use a
      `TestCoroutineDispatcher <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-dispatcher/>`__
      from ``kotlinx-coroutines-test``. This allows tests to advance a *virtual-clock* for
      testing, and allows code to use ``Dispatchers.Main`` in unit tests.

   In the ``setup`` method, a new instance of ``MainViewModel`` is created using testing
   fakes â€“ these are fake implementations of the network and database provided in the
   starter code to help write tests without using the real network or database.

   For this test, the fakes are only needed to satisfy the dependencies of
   ``MainViewModel``. Later in this code lab you'll update the fakes to support
   coroutines.


Write a test that controls coroutines


   Add a new test that ensures that taps are updated one second after the main view is
   clicked:


**MainViewModelTest.kt**


   .. code:: prettyprint

      @Test
      fun whenMainClicked_updatesTaps() {
         subject.onMainViewClicked()
         Truth.assertThat(subject.taps.getValueForTest()).isEqualTo("0 taps")
         coroutineScope.advanceTimeBy(1000)
         Truth.assertThat(subject.taps.getValueForTest()).isEqualTo("1 taps")
      }

   By calling ``onMainViewClicked``, the coroutine we just created will be launched. This
   test checks that the taps text stays *"0 taps"* right after ``onMainViewClicked`` is
   called, then 1 second later it gets updated to *"1 taps"*.

   This test uses **virtual-time** to control the execution of the coroutine launched by
   ``onMainViewClicked``. The ``MainCoroutineScopeRule`` lets you pause, resume, or
   control the execution of coroutines that are launched on the ``Dispatchers.Main``. Here
   we're calling ``advanceTimeBy(1_000)`` which will cause the main dispatcher to
   immediately execute coroutines that are scheduled to resume 1 second later.

   This test is fully deterministic, which means it will always execute the same way. And,
   because it has full control over the execution of coroutines launched on the
   ``Dispatchers.Main`` it doesn't have to wait one second for the value to be set.


**Run the existing test**


   1. Right click on the class name ``MainViewModelTest`` in your editor to open a context
      menu.
   2. In the context menu choose |execute.png| **Run â€˜MainViewModelTest'**
   3. For future runs you can select this test configuration in the configurations next to
      the |execute.png| button in the toolbar. By default, the configuration will be
      called **MainViewModelTest**.

   You should see the test pass! And it should take quite a bit less than one second to
   run.

   In the next exercise you'll learn how to convert from an existing callback APIs to use
   coroutines.


7. Moving from callbacks to coroutines
--------------------------------------


   In this step, you will start converting a repository to use coroutines. To do this, we
   will add coroutines to the ``ViewModel``, ``Repository``, ``Room`` and ``Retrofit``.

   It's a good idea to understand what each part of the architecture is responsible for
   before we switch them to using coroutines.

   1. ``MainDatabase`` implements a database using Room that saves and loads a ``Title``.
   2. ``MainNetwork`` implements a network API that fetches a new title. It uses Retrofit
      to fetch titles. ``Retrofit`` is configured to randomly return errors or mock data,
      but otherwise behaves as if it's making real network requests.
   3. ``TitleRepository`` implements a single API for fetching or refreshing the title by
      combining data from the network and database.
   4. ``MainViewModel`` represents the screen's state and handles events. It will tell the
      repository to refresh the title when the user taps on the screen.

   Since the network request is driven by UI-events and we want to start a coroutine based
   on them, the natural place to start using coroutines is in the ``ViewModel``.


**The callback version**


   Open ``MainViewModel.kt`` to see the declaration of ``refreshTitle``.


**MainViewModel.kt**


   .. code:: prettyprint

      /**
      * Update title text via this LiveData
      */
      val title = repository.title


      // ... other code ...


      /**
      * Refresh the title, showing a loading spinner while it refreshes and errors via snackbar.
      */
      fun refreshTitle() {
         // TODO: Convert refreshTitle to use coroutines
         _spinner.value = true
         repository.refreshTitleWithCallbacks(object: TitleRefreshCallback {
             override fun onCompleted() {
                 _spinner.postValue(false)
             }

             override fun onError(cause: Throwable) {
                 _snackBar.postValue(cause.message)
                 _spinner.postValue(false)
             }
         })
      }

   This function is called every time the user clicks on the screen â€“ and it will cause
   the repository to refresh the title and write the new title to the database.

   This implementation uses a callback to do a few things:

   -  Before it starts a query, it displays a loading spinner with
      ``_spinner.value = true``
   -  When it gets a result, it clears the loading spinner with ``_spinner.value = false``
   -  If it gets an error, it tells a snackbar to display and clears the spinner

   Note that the ``onCompleted`` callback is not passed the ``title``. Since we write all
   titles to the ``Room`` database, the UI updates to the current title by observing a
   ``LiveData`` that's updated by ``Room``.

   In the update to coroutines, we'll keep the exact same behavior. It's a good pattern to
   use an observable data source like a ``Room`` database to automatically keep the UI up
   to date.

   **What does** ``object: TitleRefreshCallback`` mean?

   This is the way to build an anonymous class in Kotlin. It makes a new object that
   implements ``TitleRefreshCallback``.


**The coroutines version**


   Let's rewrite ``refreshTitle`` with coroutines!

   Since we'll need it right away, let's make an empty suspend function in our repository
   (``TitleRespository.kt``). Define a new function that uses the ``suspend`` operator to
   tell Kotlin that it works with coroutines.


TitleRepository.kt


   .. code:: prettyprint

      suspend fun refreshTitle() {
          // TODO: Refresh from network and write to database
          delay(500)
      }

   When you're done with this codelab, you will update this to use Retrofit and Room to
   fetch a new title and write it to the database using coroutines. For now, it'll just
   spend 500 milliseconds pretending to do work and then continue.

   In ``MainViewModel``, replace the callback version of ``refreshTitle`` with one that
   launches a new coroutine:


**MainViewModel.kt**


   .. code:: prettyprint

      /**
      * Refresh the title, showing a loading spinner while it refreshes and errors via snackbar.
      */
      fun refreshTitle() {
         viewModelScope.launch {
             try {
                 _spinner.value = true
                 repository.refreshTitle()
             } catch (error: TitleRefreshError) {
                 _snackBar.value = error.message
             } finally {
                 _spinner.value = false
             }
         }
      }

   Let's step through this function:

   .. code:: prettyprint

      viewModelScope.launch {

   Just like the coroutine to update the tap count, begin by launching a new coroutine in
   ``viewModelScope``. This will use ``Dispatchers.Main`` which is OK. Even though
   ``refreshTitle`` will make a network request and database query it can use coroutines
   to expose a **main-safe** interface. This means it'll be safe to call it from the main
   thread.

   Because we're using ``viewModelScope``, when the user moves away from this screen the
   work started by this coroutine will automatically be cancelled. That means it won't
   make extra network requests or database queries.

   When creating a coroutine from a non-coroutine, start with `launch <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html>`__.

   That way, if they throw an uncaught exception it'll automatically be propagated to
   uncaught exception handlers (which by default crash the app). A coroutine started with
   `async <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html>`__
   won't throw an exception to its caller until you call `await <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html>`__.
   However, you can only call ``await`` from inside a coroutine, since it is a suspend
   function.

   Once inside a coroutine, you can use launch or async to start child coroutines. Use
   ``launch`` for when you don't have a result to return, and ``async`` when you do.

   The next few lines of code actually call ``refreshTitle`` in the ``repository``.

   .. code:: prettyprint

      try {
          _spinner.value = true
          repository.refreshTitle()
      }

   Before this coroutine does anything it starts the loading spinner â€“ then it calls
   ``refreshTitle`` just like a regular function. However, since ``refreshTitle`` is a
   suspending function, it executes differently than a normal function.

   We don't have to pass a callback. The coroutine will suspend until it is resumed by
   ``refreshTitle``. While it *looks* just like a regular blocking function call, it will
   automatically wait until the network and database query are complete before resuming
   *without* blocking the main thread.

   .. code:: prettyprint

      } catch (error: TitleRefreshError) {
          _snackBar.value = error.message
      } finally {
          _spinner.value = false
      }

   Exceptions in suspend functions work just like errors in regular functions. If you
   throw an error in a suspend function, it will be thrown to the caller. So even though
   they execute quite differently, you can use regular try/catch blocks to handle them.
   This is useful because it lets you rely on the built-in language support for error
   handling instead of building custom error handling for every callback.

   And, if you throw an exception out of a coroutine â€“ that coroutine will cancel its
   parent by default. That means it's easy to cancel several related tasks together.

   And then, in a finally block, we can make sure that the spinner is always turned off
   after the query runs.

   **What happens to uncaught exceptions**

   Uncaught exceptions in a coroutine are similar to uncaught exceptions in non-coroutine
   code. By default, they'll cancel the coroutine's ``Job``, and notify parent coroutines
   that they should cancel themselves. If no coroutine handles the exception, it will
   eventually be passed to an uncaught exception handler on the ``CoroutineScope``.

   By default, uncaught exceptions will be sent to the thread's uncaught exception handler
   on the JVM. You can customize this behavior by providing a `CoroutineExceptionHandler <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-exception-handler/>`__.

   Run the application again by selecting the **start** configuration then pressing
   |execute.png|, you should see a loading spinner when you tap anywhere. The title will
   stay the same because we haven't hooked up our network or database yet.

   In the next exercise you'll update the repository to actually do work.


8. Making main-safe functions from blocking code
------------------------------------------------


   In this exercise you'll learn how to switch the thread a coroutine runs on in order to
   implement a working version of ``TitleRepository``.


**Review the existing callback code in refreshTitle**


   Open ``TitleRepository.kt`` and review the existing callback-based implementation.


**TitleRepository.kt**


   .. code:: prettyprint

      // TitleRepository.kt

      fun refreshTitleWithCallbacks(titleRefreshCallback: TitleRefreshCallback) {
         // This request will be run on a background thread by retrofit
         BACKGROUND.submit {
             try {
                 // Make network request using a blocking call
                 val result = network.fetchNextTitle().execute()
                 if (result.isSuccessful) {
                     // Save it to database
                     titleDao.insertTitle(Title(result.body()!!))
                     // Inform the caller the refresh is completed
                     titleRefreshCallback.onCompleted()
                 } else {
                     // If it's not successful, inform the callback of the error
                     titleRefreshCallback.onError(
                             TitleRefreshError("Unable to refresh title", null))
                 }
             } catch (cause: Throwable) {
                 // If anything throws an exception, inform the caller
                 titleRefreshCallback.onError(
                         TitleRefreshError("Unable to refresh title", cause))
             }
         }
      }

   In ``TitleRepository.kt`` the method ``refreshTitleWithCallbacks`` is implemented with
   a callback to communicate the loading and error state to the caller.

   This function does quite a few things in order to implement the refresh.

   1. Switch to another thread with ``BACKGROUND`` ``ExecutorService``
   2. Run the ``fetchNextTitle`` network request using the blocking ``execute()`` method.
      This will run the network request in the current thread, in this case one of the
      threads in ``BACKGROUND``.
   3. If the result is successful, save it to the database with ``insertTitle`` and call
      the ``onCompleted()`` method.
   4. If the result was not successful, or there is an exception, call the onError method
      to tell the caller about the failed refresh.

   This callback based implementation is **main-safe** because it won't block the main
   thread. But, it has to use a callback to inform the caller when the work completes. It
   also calls the callbacks on the ``BACKGROUND`` thread that it switched too.


**Calling blocking calls from coroutines**


   Without introducing coroutines to the network or database, we can make this code
   **main-safe** using coroutines. This will let us get rid of the callback and allow us
   to pass the result back to the thread that initially called it.

   You can use this pattern anytime you need to do blocking or CPU intensive work from
   inside a coroutine such as sorting and filtering a large list or reading from disk.

   This pattern should be used for integrating with blocking APIs in your code or
   performing CPU intensive work. When possible, it's better to use regular suspend
   functions from libraries like Room or Retrofit.

   To switch between any dispatcher, coroutines uses `withContext <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html>`__.
   Calling ``withContext`` switches to the other dispatcher *just for the lambda* then
   comes back to the dispatcher that called it with the result of that lambda.

   By default, Kotlin coroutines provides three Dispatchers:
   `Main <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html>`__,
   `IO <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html>`__,
   and `Default <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html>`__.
   The IO dispatcher is optimized for IO work like reading from the network or disk, while
   the Default dispatcher is optimized for CPU intensive tasks.


**TitleRepository.kt**


   .. code:: prettyprint

      suspend fun refreshTitle() {
         // interact with *blocking* network and IO calls from a coroutine
         withContext(Dispatchers.IO) {
             val result = try {
                 // Make network request using a blocking call
                 network.fetchNextTitle().execute()
             } catch (cause: Throwable) {
                 // If the network throws an exception, inform the caller
                 throw TitleRefreshError("Unable to refresh title", cause)
             }
            
             if (result.isSuccessful) {
                 // Save it to database
                 titleDao.insertTitle(Title(result.body()!!))
             } else {
                 // If it's not successful, inform the callback of the error
                 throw TitleRefreshError("Unable to refresh title", null)
             }
         }
      }

   This implementation uses blocking calls for the network and database â€“ but it's still a
   bit simpler than the callback version.

   This code still uses **blocking** calls. Calling ``execute()`` and ``insertTitle(...)``
   will both block the thread that this coroutine is running in. However, by switching to
   ``Dispatchers.IO`` using ``withContext``, we're blocking one of the threads in the IO
   dispatcher. The coroutine that called this, possibly running on ``Dispatchers.Main``,
   will be suspended until the ``withContext`` lambda is complete.

   Compared to the callback version, there are two important differences:

   1. ``withContext`` returns its result back to the Dispatcher that called it, in this
      case ``Dispatchers.Main``. The callback version called the callbacks on a thread in
      the ``BACKGROUND`` executor service.
   2. The caller doesn't have to pass a callback to this function. They can rely on
      suspend and resume to get the result or error.

   **Advanced tip**

   This code doesn't support coroutine cancellation, but it can! 
   `Coroutine cancellation is cooperative <https://kotlinlang.org/docs/reference/coroutines/cancellation-and-timeouts.html>`__.
   That means your code needs to check for cancellation explicitly, which happens for you
   whenever you call the functions in kotlinx-coroutines.

   Because this ``withContext`` block only calls *blocking* calls it will not be cancelled
   until it returns from ``withContext``.

   To fix this, you can call `yield <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html>`__
   regularly to give other coroutines a chance to run and check for cancellation. Here you
   would add a call to ``yield`` between the network request and the database query. Then,
   if the coroutine is cancelled during the network request, it won't save the result to
   the database.

   You can also check cancellation explicitly, which you should do when making low-level
   coroutine interfaces.


Run the app again


   If you run the app again, you'll see that the new coroutines-based implementation is
   loading results from the network!

   In the next step you'll integrate coroutines into Room and Retrofit.


9. Coroutines in Room & Retrofit
--------------------------------


   To continue the coroutines integration, we're going to use the support for suspend
   functions in the stable version of Room and Retrofit, then simplify the code we just
   wrote substantially by using the suspend functions.


**Coroutines in Room**


   First open ``MainDatabase.kt`` and make ``insertTitle`` a suspend function:


**MainDatabase.kt**


   .. code:: prettyprint

      // add the suspend modifier to the existing insertTitle

      @Insert(onConflict = OnConflictStrategy.REPLACE)
      suspend fun insertTitle(title: Title)

   When you do this, Room will make your query **main-safe** and execute it on a
   background thread automatically. However, it also means that you can only call this
   query from inside a coroutine.

   And â€“ that's all you have to do to use coroutines in Room. Pretty nifty.


**Coroutines in Retrofit**


   Next let's see how to integrate coroutines with Retrofit. Open up ``MainNetwork.kt``
   and change ``fetchNextTitle`` to a suspend function. Also change the return type from
   ``Call<String>`` to ``String``.

   Suspend function support requires Retrofit 2.6.0 or higher.


MainNetwork.kt


   .. code:: prettyprint

      // add suspend modifier to the existing fetchNextTitle
      // change return type from Call<String> to String

      interface MainNetwork {
         @GET("next_title.json")
         suspend fun fetchNextTitle(): String
      }

   To use suspend functions with Retrofit you have to do two things:

   1. Add a suspend modifier to the function
   2. Remove the ``Call`` wrapper from the return type. Here we're returning ``String``,
      but you could return complex json-backed type as well. If you still wanted to
      provide access to Retrofit's full ``Result``, you can return ``Result<String>``
      instead of ``String`` from the suspend function.

   Retrofit will automatically make suspend functions **main-safe** so you can call them
   directly from ``Dispatchers.Main``.

   Both Room and Retrofit make suspending functions **main-safe**.

   It's safe to call these suspend funs from ``Dispatchers.Main``, even though they fetch
   from the network and write to the database.

   Both Room and Retrofit use a custom dispatcher and do not use ``Dispatchers.IO``.

   Room will run coroutines using the default `query <https://developer.android.google.cn/reference/androidx/room/RoomDatabase.Builder.html#setQueryExecutor(java.util.concurrent.Executor)>`__
   and `transaction <https://developer.android.google.cn/reference/androidx/room/RoomDatabase.Builder.html#setTransactionExecutor(java.util.concurrent.Executor)>`__
   ``Executor`` that's configured.

   Retrofit will create a new ``Call`` object under the hood, and call `enqueue <https://square.github.io/retrofit/2.x/retrofit/retrofit2/Call.html#enqueue-retrofit2.Callback->`__
   on it to send the request asynchronously.


**Using Room and Retrofit**


   Now that Room and Retrofit support suspend functions, we can use them from our
   repository. Open up ``TitleRepository.kt`` and see how using suspending functions
   greatly simplifies logic, even compared to the blocking version:


Title **Repository.kt**


   .. code:: prettyprint

      suspend fun refreshTitle() {
         try {
             // Make network request using a blocking call
             val result = network.fetchNextTitle()
             titleDao.insertTitle(Title(result))
         } catch (cause: Throwable) {
             // If anything throws an exception, inform the caller
             throw TitleRefreshError("Unable to refresh title", cause)
         }
      }

   Wow, that's a *lot* shorter. What happened? It turns out relying on suspend and resume
   lets code be much shorter. Retrofit lets us use return types like ``String`` or a
   ``User`` object here, instead of a ``Call``. That's safe to do, because inside the
   suspend function, ``Retrofit`` is able to run the network request on a background
   thread and resume the coroutine when the call completes.

   Even better, we got rid of the ``withContext``. Since both Room and Retrofit provide
   **main-safe** suspending functions, it's safe to orchestrate this async work from
   ``Dispatchers.Main``.

   You do not need to use ``withContext`` to call **main-safe** suspending functions.

   By convention, you should ensure that ``suspend`` functions written in your application
   are **main-safe**. That way it is safe to call them from any dispatcher, even
   ``Dispatchers.Main``.


**Fixing compiler errors**


   Moving to coroutines does involve changing the signature of functions as you can't call
   a suspend function from a regular function. When you added the ``suspend`` modifier in
   this step, a few compiler errors were generated that show what would happen if you
   changed a function to suspend in a real project.

   Go through the project and fix the compiler errors by changing the function to suspend
   created. Here are the quick resolutions for each:


**TestingFakes.kt**


   Update the testing fakes to support the new suspend modifiers.


*TitleDaoFake*


   1. Hit alt-enter (option-enter on a Mac) add suspend modifiers to all functions in the
      hierarchy


*MainNetworkFake*


   1. Hit alt-enter add suspend modifiers to all functions in the hierarchy
   2. Replace ``fetchNextTitle`` with this function

   .. code:: prettyprint

      override suspend fun fetchNextTitle() = result


*MainNetworkCompletableFake*


   1. Hit alt-enter add suspend modifiers to all functions in the hierarchy
   2. Replace ``fetchNextTitle`` with this function

   .. code:: prettyprint

      override suspend fun fetchNextTitle() = completable.await()


**TitleRepository.kt**


   -  Delete the ``refreshTitleWithCallbacks`` function as it is not used anymore.


**Run the app**


   Run the app again, once it compiles, you will see that it's loading data using
   coroutines all the way from the ViewModel to Room and Retrofit!

   Congratulations, you've completely swapped this app to using coroutines! To wrap up
   we'll talk a bit about how to test what we just did.


10. Testing coroutines directly
-------------------------------


   In this exercise, you'll write a test that calls a ``suspend`` function directly.

   Since ``refreshTitle`` is exposed as a public API it will be tested directly, showing
   how to call coroutines functions from tests.

   Here's the ``refreshTitle`` function you implemented in the last exercise:


**TitleRepository.kt**


   .. code:: prettyprint

      suspend fun refreshTitle() {
         try {
             // Make network request using a blocking call
             val result = network.fetchNextTitle()
             titleDao.insertTitle(Title(result))
         } catch (cause: Throwable) {
             // If anything throws an exception, inform the caller
             throw TitleRefreshError("Unable to refresh title", cause)
         }
      }


**Write a test that calls a suspend function**


   Open ``TitleRepositoryTest.kt`` in the ``test`` folder which has two TODOS.

   Try to call ``refreshTitle`` from the first test
   ``whenRefreshTitleSuccess_insertsRows``.

   .. code:: prettyprint

      @Test
      fun whenRefreshTitleSuccess_insertsRows() {
         val subject = TitleRepository(
             MainNetworkFake("OK"),
             TitleDaoFake("title")
         )

         subject.refreshTitle()
      }

   Since ``refreshTitle`` is a ``suspend`` function Kotlin doesn't know how to call it
   except from a coroutine or another suspend function, and you will get a compiler error
   like, *"Suspend function refreshTitle should be called only from a coroutine or another
   suspend function."*

   The test runner doesn't know anything about coroutines so we can't make this test a
   suspend function. We could ``launch`` a coroutine using a ``CoroutineScope`` like in a
   ``ViewModel``, however tests need to run coroutines to completion before they return.
   Once a test function returns, the test is over. Coroutines started with ``launch`` are
   asynchronous code, which may complete at some point in the future. Therefore to test
   that asynchronous code, you need some way to tell the test to wait until your coroutine
   completes. Since ``launch`` is a non-blocking call, that means it returns right away
   and can continue to run a coroutine after the function returns - it can't be used in
   tests. For example:

   .. code:: prettyprint

      @Test
      fun whenRefreshTitleSuccess_insertsRows() {
         val subject = TitleRepository(
             MainNetworkFake("OK"),
             TitleDaoFake("title")
         )

         // launch starts a coroutine then immediately returns
         GlobalScope.launch {
             // since this is asynchronous code, this may be called *after* the test completes
             subject.refreshTitle()
         }
         // test function returns immediately, and
         // doesn't see the results of refreshTitle
      }

   This test will **sometimes** fail. The call to ``launch`` will return immediately and
   execute at the same time as the rest of the test case. The test has no way to know if
   ``refreshTitle`` has run yet or not â€“ and any assertions like checking that the
   database was updated would be flakey. And, if ``refreshTitle`` threw an exception, it
   will not be thrown in the test call stack. It will instead be thrown into
   **``GlobalScope``**'s uncaught exception handler.

   The library ``kotlinx-coroutines-test`` has the `runBlockingTest <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-blocking-test.html>`__
   function that blocks while it calls suspend functions. When ``runBlockingTest`` calls a
   suspend function or ``launches`` a new coroutine, it executes it immediately by
   default. You can think of it as a way to convert suspend functions and coroutines into
   normal function calls.

   In addition, ``runBlockingTest`` will rethrow uncaught exceptions for you. This makes
   it easier to test when a coroutine is throwing an exception.

   **Important**: The function `runBlockingTest <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-blocking-test.html>`__
   will always block the caller, just like a regular function call. The coroutine will run
   synchronously on the same thread. You should avoid `runBlocking <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html>`__
   and ``runBlockingTest`` in your application code and prefer ``launch`` which returns
   immediately.

   ``runBlockingTest`` should only be used from tests as it executes coroutines in a
   test-controlled manner, while ``runBlocking`` can be used to provide blocking
   interfaces to coroutines.


**Implement a test with one coroutine**


   Wrap the call to ``refreshTitle`` with ``runBlockingTest`` and remove the
   ``GlobalScope.launch`` wrapper from subject.refreshTitle().


**TitleRepositoryTest.kt**


   .. code:: prettyprint

      @Test
      fun whenRefreshTitleSuccess_insertsRows() = runBlockingTest {
         val titleDao = TitleDaoFake("title")
         val subject = TitleRepository(
                 MainNetworkFake("OK"),
                 titleDao
         )

         subject.refreshTitle()
         Truth.assertThat(titleDao.nextInsertedOrNull()).isEqualTo("OK")
      }

   This test uses the fakes provided to check that "OK" is inserted to the database by
   ``refreshTitle``.

   When the test calls ``runBlockingTest``, it will block until the coroutine started by
   ``runBlockingTest`` completes. Then inside, when we call ``refreshTitle`` it uses the
   regular suspend and resume mechanism to wait for the database row to be added to our
   fake.

   After the test coroutine completes, ``runBlockingTest`` returns.


**Write a timeout test**


   We want to add a short timeout to the network request. Let's write the test first then
   implement the timeout. Create a new test:


**TitleRepositoryTest.kt**


   .. code:: prettyprint

      @Test(expected = TitleRefreshError::class)
      fun whenRefreshTitleTimeout_throws() = runBlockingTest {
         val network = MainNetworkCompletableFake()
         val subject = TitleRepository(
                 network,
                 TitleDaoFake("title")
         )

         launch {
             subject.refreshTitle()
         }

         advanceTimeBy(5_000)
      }

   This test uses the provided fake ``MainNetworkCompletableFake``, which is a network
   fake that's designed to suspend callers until the test continues them. When
   ``refreshTitle`` tries to make a network request, it'll hang forever because we want to
   test timeouts.

   Then, it launches a separate coroutine to call ``refreshTitle``. This is a key part of
   testing timeouts, the timeout should happen in a different coroutine than the one
   ``runBlockingTest`` creates. By doing so, we can call the next line,
   ``advanceTimeBy(5_000)`` which will advance time by 5 seconds and cause the other
   coroutine to timeout.

   This is a complete timeout test, and it will pass once we implement timeout.

   Run it now and see what happens:

   ::

      Caused by: kotlinx.coroutines.test.UncompletedCoroutinesError: Test finished with active jobs: ["...]

   One of the features of ``runBlockingTest`` is that it won't let you leak coroutines
   after the test completes. If there are any unfinished coroutines, like our launch
   coroutine, at the end of the test, it will fail the test.


**Add a timeout**


   Open up ``TitleRepository`` and add a five second timeout to the network fetch. You can
   do this by using the `withTimeout <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html>`__
   function:


**TitleRepository.kt**


   .. code:: prettyprint

      suspend fun refreshTitle() {
         try {
             // Make network request using a blocking call
             val result = withTimeout(5_000) {
                 network.fetchNextTitle()
             }
             titleDao.insertTitle(Title(result))
         } catch (cause: Throwable) {
             // If anything throws an exception, inform the caller
             throw TitleRefreshError("Unable to refresh title", cause)
         }
      }

   Run the test. When you run the tests you should see all tests pass!

   |17c2c9cab594f2f5.png|

   In the next exercise you'll learn how to write higher order functions using coroutines.

   ``runBlockingTest`` relies upon ``TestCoroutineDispatcher`` to control coroutines.

   As a result, it's a good idea to inject a ``TestCoroutineDispatcher`` or
   ``TestCoroutineScope`` when using ``runBlockingTest``. This has the effect of making
   the coroutines single threaded and offers the ability to explicitly control all
   coroutines in tests.

   If you *don't* want to change the behavior of coroutines â€“ for example in an
   integration test â€“ you can instead use ``runBlocking`` with the default implementations
   of all dispatchers.

   ``runBlockingTest`` is **experimental**, and currently has a **bug** that makes it fail
   the test if a coroutine switches to a dispatcher that executes a coroutine on another
   thread. The final stable is not expected to have this bug.


11. Using coroutines in higher order functions
----------------------------------------------


   In this exercise you'll refactor ``refreshTitle`` in ``MainViewModel`` to use a general
   data loading function. This will teach you how to build higher order functions that use
   coroutines.

   The current implementation of ``refreshTitle`` works, but we can create a general data
   loading coroutine that always shows the spinner. This might be helpful in a codebase
   that loads data in response to several events, and wants to ensure the loading spinner
   is consistently displayed.

   Reviewing the current implementation every line except ``repository.refreshTitle()`` is
   boilerplate to show the spinner and display errors.

   .. code:: prettyprint

      // MainViewModel.kt

      fun refreshTitle() {
         viewModelScope.launch {
             try {
                 _spinner.value = true
                 // this is the only part that changes between sources
                 repository.refreshTitle() 
             } catch (error: TitleRefreshError) {
                 _snackBar.value = error.message
             } finally {
                 _spinner.value = false
             }
         }
      }

   **Important**: Even though we only use viewModelScope in this codelab, generally it's
   fine to add a scope anywhere that it makes sense. Don't forget to cancel it if it's no
   longer needed.

   For example, you might declare one in a RecyclerView Adapter to do DiffUtil operations.


**Using coroutines in higher order functions**


   Add this code to MainViewModel.kt


**MainViewModel.kt**


   .. code:: prettyprint

      private fun launchDataLoad(block: suspend () -> Unit): Job {
         return viewModelScope.launch {
             try {
                 _spinner.value = true
                 block()
             } catch (error: TitleRefreshError) {
                 _snackBar.value = error.message
             } finally {
                 _spinner.value = false
             }
         }
      }

   Now refactor ``refreshTitle()`` to use this higher order function.


**MainViewModel.kt**


   .. code:: prettyprint

      fun refreshTitle() {
         launchDataLoad {
             repository.refreshTitle()
         }
      }

   By abstracting the logic around showing a loading spinner and showing errors, we've
   simplified our actual code needed to load data. Showing a spinner or displaying an
   error is something that's easy to generalize to any data loading, while the actual data
   source and destination needs to be specified every time.

   To build this abstraction, ``launchDataLoad`` takes an argument ``block`` that is a
   suspend lambda. A suspend lambda allows you to call suspend functions. That's how
   Kotlin implements the coroutine builders ``launch`` and ``runBlocking`` we've been
   using in this codelab.

   .. code:: prettyprint

      // suspend lambda

      block: suspend () -> Unit

   To make a suspend lambda, start with the ``suspend`` keyword. The function arrow and
   return type ``Unit`` complete the declaration.

   You don't often have to declare your own suspend lambdas, but they can be helpful to
   create abstractions like this that encapsulate repeated logic!


12. Using coroutines with WorkManager
-------------------------------------


   In this exercise you'll learn how to use coroutine based code from WorkManager.

   **What is WorkManager**

   There are many options on Android for deferrable background work. This exercise shows
   you how to integrate `WorkManager <https://developer.android.google.cn/arch/work>`__
   with coroutines. WorkManager is a compatible, flexible and simple library for
   deferrable background work. WorkManager is the recommended solution for these use cases
   on Android.

   WorkManager is part of `Android Jetpack <http://d.android.com/jetpack>`__, and an
   `Architecture Component <http://d.android.com/arch>`__ for background work that needs a
   combination of opportunistic and guaranteed execution. Opportunistic execution means
   that WorkManager will do your background work as soon as it can. Guaranteed execution
   means that WorkManager will take care of the logic to start your work under a variety
   of situations, even if you navigate away from your app.

   Because of this, WorkManager is a good choice for tasks that must complete eventually.

   Some examples of tasks that are a good use of WorkManager:

   -  Uploading logs
   -  Applying filters to images and saving the image
   -  Periodically syncing local data with the network

   To learn more about WorkManager check out the `documentation <https://developer.android.google.cn/topic/libraries/architecture/workmanager/>`__.


Using coroutines with WorkManager


   WorkManager provides different implementations of its base ``ListenableWorker`` class
   for different use cases.

   The simplest Worker class allows us to have some synchronous operation executed by
   WorkManager. However, having worked so far to convert our codebase to use coroutines
   and suspend functions, the best way to use WorkManager is through the
   ``CoroutineWorker`` class that allows to define our ``doWork()`` function as a suspend
   function.

   To get started, open up ``RefreshMainDataWork``. It already extends
   ``CoroutineWorker``, and you need to implement ``doWork``.

   Inside the ``suspend`` ``doWork`` function, call ``refreshTitle()`` from the repository
   and return the appropriate result!

   After you've completed the TODO, the code will look like this:

   .. code:: prettyprint

      override suspend fun doWork(): Result {
         val database = getDatabase(applicationContext)
         val repository = TitleRepository(network, database.titleDao)

         return try {
             repository.refreshTitle()
             Result.success()
         } catch (error: TitleRefreshError) {
             Result.failure()
         }
      }

   Note that ``CoroutineWorker.doWork()`` is a suspending function. Unlike the simpler
   ``Worker`` class, this code does NOT run on the Executor specified in your WorkManager
   configuration, but instead uses ``Dispatchers.Default``. You can switch to other
   dispatchers by using ``withContext()``.


Testing our CoroutineWorker


   No codebase should be complete without testing.

   WorkManager makes available a couple of different ways to test your ``Worker`` classes,
   to learn more about the original testing infrastructure, you can read the
   `documentation <https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/testing>`__.

   WorkManager v2.1 introduces a new set of APIs to support a simpler way to test
   ``ListenableWorker`` classes and, as a consequence, CoroutineWorker. In our code we're
   going to use one of these new API: `TestListenableWorkerBuilder <https://developer.android.google.cn/reference/androidx/work/testing/TestListenableWorkerBuilder>`__.

   To add our new test, update the ``RefreshMainDataWorkTest`` file under the
   ``androidTest`` folder.

   The content of the file is:

   .. code:: prettyprint

      package com.example.android.kotlincoroutines.main

      import android.content.Context
      import androidx.test.core.app.ApplicationProvider
      import androidx.work.ListenableWorker.Result
      import androidx.work.testing.TestListenableWorkerBuilder
      import com.example.android.kotlincoroutines.fakes.MainNetworkFake
      import com.google.common.truth.Truth.assertThat
      import org.junit.Test
      import org.junit.runner.RunWith
      import org.junit.runners.JUnit4

      @RunWith(JUnit4::class)
      class RefreshMainDataWorkTest {

      @Test
      fun testRefreshMainDataWork() {
         val fakeNetwork = MainNetworkFake("OK")

         val context = ApplicationProvider.getApplicationContext<Context>()
         val worker = TestListenableWorkerBuilder<RefreshMainDataWork>(context)
                 .setWorkerFactory(RefreshMainDataWork.Factory(fakeNetwork))
                 .build()

         // Start the work synchronously
         val result = worker.startWork().get()

         assertThat(result).isEqualTo(Result.success())
      }

      }

   Before we get to the test, we tell ``WorkManager`` about the factory so we can inject
   the fake network.

   The test itself uses the ``TestListenableWorkerBuilder`` to create our worker that we
   can then run calling the ``startWork()`` method.

   WorkManager is just one example of how coroutines can be used to simplify APIs design.


13. Congratulations!
--------------------


   In this codelab we have covered the basics you'll need to start using coroutines in
   your app!

   We covered:

   -  How to integrate coroutines to Android apps from both the UI and WorkManager jobs to
      simplify asynchronous programming,
   -  How to use coroutines inside a ``ViewModel`` to fetch data from the network and save
      it to a database without blocking the main thread.
   -  And how to cancel all coroutines when the ``ViewModel`` is finished.

   For testing coroutine based code, we covered both by testing behavior as well as
   directly calling ``suspend`` functions from tests.


**Learn more**


   Check out the " `Advanced Coroutines with Kotlin Flow and LiveData <https://developer.android.google.cn/codelabs/advanced-kotlin-coroutines#1>`__"
   codelab to learn more advanced coroutines usage on Android.

   To learn more about cancellation and exceptions in coroutines, check out this article
   series: 
   
   *  `Part 1: Coroutines <https://medium.com/androiddevelopers/coroutines-first-things-first-e6187bf3bb21>`__,
   *  `Part 2: Cancellation in coroutines <https://medium.com/androiddevelopers/cancellation-in-coroutines-aa6b90163629>`__,
   *  `Part 3: Exceptions in coroutines <https://medium.com/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c>`__.

   Kotlin coroutines have many features that weren't covered by this codelab. If you're
   interested in learning more about Kotlin coroutines, read the `coroutines guides <https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutines-guide.md>`__
   published by JetBrains. Also check out " `Improve app performance with Kotlin coroutines <https://developer.android.google.cn/kotlin/coroutines>`__" for more usage
   patterns of coroutines on Android.

.. |android_studio_folder.png| image:: https://developer.android.google.cn//static/codelabs/kotlin-coroutines/img/a1beacb239657647.png
.. |execute.png| image:: https://developer.android.google.cn//static/codelabs/kotlin-coroutines/img/c8b8a080b7ead886.png
.. |1d65055551232a9.png| image:: https://developer.android.google.cn//static/codelabs/kotlin-coroutines/img/1d65055551232a9.png
.. |cbc7d16909facb7c.png| image:: https://developer.android.google.cn//static/codelabs/kotlin-coroutines/img/cbc7d16909facb7c.png
.. |716807c07961aacd.png| image:: https://developer.android.google.cn//static/codelabs/kotlin-coroutines/img/716807c07961aacd.png
.. |17c2c9cab594f2f5.png| image:: https://developer.android.google.cn//static/codelabs/kotlin-coroutines/img/17c2c9cab594f2f5.png


ğŸš€ Android Room with a View - Kotlin
=====================================

https://developer.android.google.cn/codelabs/android-room-with-a-view-kotlin


1. Before you begin
-------------------


   The Android `Architecture Components <https://developer.android.google.cn/topic/libraries/architecture/index.html>`__
   collection provides guidance on app architecture, with libraries for common tasks like
   lifecycle management and data persistence. Using architecture components can help you
   structure your app in a way that is robust, testable, and maintainable, with less
   boilerplate code.

   The Architecture Component libraries are part of `Android Jetpack <https://developer.android.google.cn/jetpack>`__.

   This is the Kotlin version of the codelab. The version in the Java programming language
   can be found `here <https://developer.android.google.cn/codelabs/android-room-with-a-view>`__.

   If you run into any issues as you work through this codelab, like code bugs,
   grammatical errors, or simply confusing content, please report the issue via the
   **Report a mistake** link in the lower left corner of the codelab.


**Prerequisites**


   You need to be familiar with Kotlin, object-oriented design concepts, and Android
   development fundamentals, in particular:

   -  ``RecyclerView`` and adapters
   -  SQLite database and the SQLite query language
   -  Basic coroutines (If you're not familiar with coroutines, you can start with 
      `Using Kotlin Coroutines in your Android App <https://developer.android.google.cn/codelabs/kotlin-coroutines?continue=https%3A%2F%2Fdeveloper.android.com%2Fcourses%2Fpathways%2Fandroid-coroutines%23codelab-https%3A%2F%2Fdeveloper.android.com%2Fcodelabs%2Fkotlin-coroutines#0>`__.)

   It also helps to be familiar with software architectural patterns that separate data
   from the user interface, such as Model-View-Presenter (MVP) or Model-View-Controller
   (MVC). This codelab implements the architecture defined in the `Guide to app architecture <https://developer.android.google.cn/topic/libraries/architecture/guide.html>`__
   Android developer documentation.

   This codelab is focused on Android Architecture Components. Off-topic concepts and code
   are provided for you to simply copy and paste.


**What you'll do**


   You'll learn how to design and construct an app using the architecture components Room,
   ViewModel, and LiveData. Your app will:

   -  implement the `recommended architecture <https://developer.android.google.cn/topic/libraries/architecture/guide.html>`__
      using Android Architecture Components.
   -  work with a database to get and save data, and pre-populate the database with sample
      words.
   -  display all the words in a ``RecyclerView`` in the ``MainActivity`` class.
   -  open a second activity when the user taps the + button. When the user enters a word,
      that word is added to the database and displayed in the ``RecyclerView`` list.

   The app is no-frills, but sufficiently complex that you can use it as a template to
   build upon. Here's a preview:

   ====================== ====================== ======================
   |a659fcbf9eb9a5ee.png| |91f5273394909e39.png| |b924184f07268c35.png|
   ====================== ====================== ======================


**What you'll need**


   -  `Android Studio Arctic Fox <https://developer.android.google.cn/studio/index.html>`__, 
      and knowledge of how to use it. Make sure Android Studio is updated, as well as 
      your SDK and Gradle.
   -  An Android device or emulator.

   This codelab provides all the code you need to build the complete app.

   **Note**: The solution code is available as a `zip file <https://github.com/android/codelab-android-room-with-a-view/archive/kotlin.zip>`__
   or `github repo <https://github.com/android/codelab-android-room-with-a-view/tree/kotlin>`__. 
   We encourage you to create the app from scratch and look at this code only if 
   you get stuck.


2. Using the Architecture Components
------------------------------------


   Here is a short diagram to introduce you to the Architecture Components and how they
   work together. Note that this codelab focuses on a subset of the components, namely
   LiveData, ViewModel and Room. Each component is explained in detail as you use it in
   your app.

   |8e4b761713e3a76b.png|

   `LiveData <https://developer.android.google.cn/topic/libraries/architecture/livedata>`__ :
   A data holder class that can be `observed <https://en.wikipedia.org/wiki/Observer_pattern>`__. 
   Always holds/caches the latest version of data, and notifies its observers when 
   data has changed. ``LiveData`` is lifecycle aware. UI components just observe 
   relevant data and don't stop or resume observation. LiveData automatically manages 
   all of this since it's aware of the relevant lifecycle status changes while observing.

   `ViewModel <https://developer.android.google.cn/topic/libraries/architecture/viewmodel>`__ :
   Acts as a communication center between the Repository (data) and the UI. The UI no
   longer needs to worry about the origin of the data. ViewModel instances survive
   Activity/Fragment recreation.

   **Repository:** A class that you create that is primarily used to manage multiple data
   sources.

   `Entity <https://developer.android.google.cn/reference/androidx/room/Entity>`__ :
   Annotated class that describes a database table when working with `Room <https://developer.android.google.cn/topic/libraries/architecture/room>`__.

   `Room database <https://developer.android.google.cn/topic/libraries/architecture/room>`__ :
   Simplifies database work and serves as an access point to the underlying SQLite
   database (hides ``SQLiteOpenHelper)``. The Room database uses the DAO to issue queries
   to the SQLite database.

   **SQLite database:** On device storage. The Room persistence library creates and
   maintains this database for you.

   `DAO <https://developer.android.google.cn/reference/androidx/room/Dao.html>`__ :
   Data access object. A mapping of SQL queries to functions. When you use a DAO, you call
   the methods, and Room takes care of the rest.

   Looking for more? Check out the full `Guide to App Architecture <https://developer.android.google.cn/topic/libraries/architecture/guide.html>`__.


**RoomWordSample architecture overview**


   The following diagram shows how all of the pieces of the app should interact. Each of
   the rectangular boxes (not the SQLite database) represents a class that you will
   create.

   |a70aca8d4b737712.png|


3. Create your app
------------------


   1. Open Android Studio and click **Start a new Android Studio project.**
   2. In the Create New Project window, choose **Empty Activity,** and click **Next.**
   3. On the next screen, name the app RoomWordSample, and click **Finish**.

   |9b6cbaec81794071.png|


4. Update Gradle files
----------------------


   Next, you'll have to add the component libraries to your Gradle files.

   1. In Android Studio, click the Projects tab and expand the Gradle Scripts folder.

   Open ``build.gradle`` (**Module: app**).

   2. Apply the ``kapt`` `annotation processor <https://kotlinlang.org/docs/reference/kapt.html>`__ 
      Kotlin plugin by adding it **in the plugins section** defined on the top of your 
      ``build.gradle`` (**Module: app**) file.

   .. code:: prettyprint

      plugins {
          id 'com.android.application'
          id 'kotlin-android'
          id 'kotlin-kapt'
      }

   3. Some of the APIs you will use require 1.8 ``jvmTarget``, so add that to the
      ``android`` block as well.

   .. code:: prettyprint

      android {
          // other configuration (buildTypes, defaultConfig, etc.)

          packagingOptions {
              exclude 'META-INF/atomicfu.kotlin_module'
          }

          kotlinOptions {
              jvmTarget = "1.8"
          }

      }

   4. Replace the ``dependencies`` block with:

   .. code:: prettyprint

      dependencies {
          implementation "androidx.appcompat:appcompat:$rootProject.appCompatVersion"
          implementation "androidx.activity:activity-ktx:$rootProject.activityVersion"

          // Dependencies for working with Architecture components
          // You'll probably have to update the version numbers in build.gradle (Project)

          // Room components
          implementation "androidx.room:room-ktx:$rootProject.roomVersion"
          kapt "androidx.room:room-compiler:$rootProject.roomVersion"
          androidTestImplementation "androidx.room:room-testing:$rootProject.roomVersion"

          // Lifecycle components
          implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$rootProject.lifecycleVersion"
          implementation "androidx.lifecycle:lifecycle-livedata-ktx:$rootProject.lifecycleVersion"
          implementation "androidx.lifecycle:lifecycle-common-java8:$rootProject.lifecycleVersion"

          // Kotlin components
          implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
          api "org.jetbrains.kotlinx:kotlinx-coroutines-core:$rootProject.coroutines"
          api "org.jetbrains.kotlinx:kotlinx-coroutines-android:$rootProject.coroutines"

          // UI
          implementation "androidx.constraintlayout:constraintlayout:$rootProject.constraintLayoutVersion"
          implementation "com.google.android.material:material:$rootProject.materialVersion"

          // Testing
          testImplementation "junit:junit:$rootProject.junitVersion"
          androidTestImplementation "androidx.arch.core:core-testing:$rootProject.coreTestingVersion"
          androidTestImplementation ("androidx.test.espresso:espresso-core:$rootProject.espressoVersion", {
              exclude group: 'com.android.support', module: 'support-annotations'
          })
          androidTestImplementation "androidx.test.ext:junit:$rootProject.androidxJunitVersion"
      }

   Gradle may complain about missing or undefined versions at this point. They should be
   fixed with the next step.

   5. In your ``build.gradle`` (**Project: RoomWordsSample**) file, make the following
      changes: at the top of the buildscript block add the kotlin_version and then, add
      the version numbers to the end of the file, as given in the code below.

   Get the most current version numbers from the `AndroidX releases <https://developer.android.google.cn/jetpack/androidx/versions>`__ 
   page.

   .. code:: prettyprint

      buildscript {
          ext.kotlin_version = '1.5.31'

          ...
      }
      ext {
          activityVersion = '1.4.0'
          appCompatVersion = '1.4.0'
          constraintLayoutVersion = '2.1.2'
          coreTestingVersion = '2.1.0'
          coroutines = '1.5.2'
          lifecycleVersion = '2.4.0'
          materialVersion = '1.4.0'
          roomVersion = '2.3.0'
          // testing
          junitVersion = '4.13.2'
          espressoVersion = '3.4.0'
          androidxJunitVersion = '1.1.3'
      }


5. Create an Entity
-------------------


   The data for this app is words, and you will need a simple table to hold those values:

   |3821ac1a6cb01278.png|

   Room allows you to create tables via an `Entity <https://developer.android.google.cn/training/data-storage/room/defining-data.html>`__.
   Let's do this now.

   1. Create a new Kotlin class file called ``Word`` containing the ``Word`` 
      `data class <https://kotlinlang.org/docs/reference/data-classes.html>`__. 
      This class will describe the Entity (which represents the SQLite table) 
      for your words. Each property in the class represents a column in the table. 
      Room will ultimately use these properties to both create the table and 
      instantiate objects from rows in the database.

   Here is the code:

   .. code:: prettyprint

      data class Word(val word: String)

   To make the ``Word`` class meaningful to a Room database, you need to create an
   association between the class and the database using Kotlin `annotations <https://kotlinlang.org/docs/reference/annotations.html>`__. 
   You will use specific annotations to identify how each part of this class relates 
   to an entry in the database. Room uses this extra information to generate code.

   If you type the annotations yourself (instead of pasting), Android Studio will
   auto-import the annotation classes.

   2. Update your ``Word`` class with annotations as shown in this code:

   .. code:: prettyprint

      @Entity(tableName = "word_table")
      class Word(@PrimaryKey @ColumnInfo(name = "word") val word: String)

   If you paste the code in, you can move the cursor over each highlighted error and use
   the `"Project quick fix" keyboard shortcut <https://developer.android.google.cn/studio/intro/keyboard-shortcuts>`__
   (**Alt+Enter** on Windows/Linux, **Option+Enter** on Mac) to import classes quickly.

   Let's see what these annotations do:

   -  ``@Entity(tableName = "word_table")`` Each ``@Entity`` class
      represents a SQLite table. Annotate your class declaration to indicate that it's an
      entity. You can specify the name of the table if you want it to be different from
      the name of the class. This names the table "word_table".
   -  ``@PrimaryKey`` Every entity needs a primary key. To keep things simple, each word
      acts as its own primary key.
   -  ``@ColumnInfo(name = "word")`` Specifies the name of the column in the
      table if you want it to be different from the name of the member variable. This
      names the column "word".
   -  Every property that's stored in the database needs to have public visibility, which
      is the Kotlin default.

   You can find a complete list of annotations in the `Room package summary reference <https://developer.android.google.cn/reference/kotlin/androidx/room/package-summary.html>`__.

   See `Defining data using Room entities <https://developer.android.google.cn/training/data-storage/room/defining-data.html>`__.

   **Tip:** You can `autogenerate <https://developer.android.google.cn/reference/androidx/room/PrimaryKey.html>`__
   unique keys by annotating the primary key as follows:

   .. code:: prettyprint

      @Entity(tableName = "word_table")
      class Word(

          @PrimaryKey(autoGenerate = true) val id: Int,
          @ColumnInfo(name = "word") val word: String

      )


6. Create the DAO
-----------------



**What is the DAO?**


   In the `DAO <https://developer.android.google.cn/training/data-storage/room/accessing-data.html>`__
   (data access object), you specify SQL queries and associate them with method calls. The
   compiler checks the SQL and generates queries from convenience annotations for common
   queries, such as ``@Insert``. Room uses the DAO to create a clean API for your code.

   The DAO must be an interface or abstract class.

   By default, all queries must be executed on a separate thread.

   Room has `Kotlin coroutines <https://kotlinlang.org/docs/reference/coroutines-overview.html>`__ 
   support. This allows your queries to be annotated with the ``suspend`` modifier and 
   then called from a coroutine or from another suspension function.


**Implement the DAO**


   Let's write a DAO that provides queries for:

   -  Getting all words ordered alphabetically
   -  Inserting a word
   -  Deleting all words

   1. Create a new Kotlin class file called ``WordDao``.
   2. Copy and paste the following code into ``WordDao`` and fix the imports as necessary
      to make it compile.

   .. code:: prettyprint

      @Dao
      interface WordDao {

          @Query("SELECT * FROM word_table ORDER BY word ASC")
          fun getAlphabetizedWords(): List<Word>

          @Insert(onConflict = OnConflictStrategy.IGNORE)
          suspend fun insert(word: Word)

          @Query("DELETE FROM word_table")
          suspend fun deleteAll()
      }

   Let's walk through it:

   -  ``WordDao`` is an interface; DAOs must either be interfaces or abstract classes.
   -  The ``@Dao`` annotation identifies it as a DAO class for Room.
   -  ``suspend fun insert(word: Word)`` : Declares a `suspend function <https://kotlinlang.org/docs/reference/coroutines/basics.html>`__ 
      to insert one word.
   -  The `@Insert annotation <https://developer.android.google.cn/reference/androidx/room/Insert>`__
      is a special DAO method annotation where you don't have to provide any SQL! (There
      are also `@Delete <https://developer.android.google.cn/reference/androidx/room/Delete>`__
      and `@Update <https://developer.android.google.cn/reference/androidx/room/Update>`__
      annotations for deleting and updating rows, but you are not using them in this app.)
   -  ``onConflict = OnConflictStrategy.IGNORE``: The selected onConflict strategy ignores
      a new word if it's exactly the same as one already in the list. To know more about
      the available conflict strategies, check out the `documentation <https://developer.android.google.cn/reference/androidx/room/OnConflictStrategy.html>`__.
   -  ``suspend fun deleteAll()``: Declares a suspend function to delete all the words.
   -  There is no convenience annotation for deleting multiple entities, so it's annotated
      with the generic ``@Query``.
   -  `@Query <https://developer.android.google.cn/reference/androidx/room/Query>`__ 
      ``("DELETE FROM word_table")``:
      ``@Query`` requires that you provide a SQL query as a string parameter to the
      annotation, allowing for complex read queries and other operations.
   -  **``fun getAlphabetizedWords(): List<Word>``**: A method to get all the words and
      have it return a ``List`` of ``Words``.
   -  ``@Query("SELECT * FROM word_table ORDER BY word ASC")``: Query that
      returns a list of words sorted in ascending order.

   Learn more about `Room DAOs <https://developer.android.google.cn/training/data-storage/room/accessing-data.html>`__.


7. Observing database changes
-----------------------------


   When data changes, you usually want to take some action, such as displaying the updated
   data in the UI. This means you have to observe the data so when it changes, you can
   react.

   To observe data changes you will use `Flow <https://kotlinlang.org/docs/reference/coroutines/flow.html>`__ 
   from ``kotlinx-coroutines``. Use a return value of type ``Flow`` in your method description,
   and Room generates all necessary code to update the ``Flow`` when the database is
   updated.

   **A Flow is an async sequence of values**

   ``Flow`` produces values one at a time (instead of all at once) that can generate
   values from *async* operations like network requests, database calls, or other *async*
   code. It supports coroutines throughout its API, so you can transform a flow using
   coroutines as well!

   In ``WordDao``, change the ``getAlphabetizedWords()`` method signature so that the
   returned ``List<Word>`` is wrapped with ``Flow``.

   .. code:: prettyprint

         @Query("SELECT * FROM word_table ORDER BY word ASC")
         fun getAlphabetizedWords(): Flow<List<Word>>

   Later in this codelab, we'll transform the Flow to LiveData in the ViewModel. But more
   on these components once we get to implement them.


8. Add a Room database
----------------------



What is a Room database?


   -  Room is a database layer on top of an SQLite database.
   -  Room takes care of mundane tasks that you used to handle with an
      `SQLiteOpenHelper <https://developer.android.google.cn/reference/android/database/sqlite/SQLiteOpenHelper.html>`__.
   -  Room uses the DAO to issue queries to its database.
   -  By default, to avoid poor UI performance, Room doesn't allow you to issue queries on
      the main thread. When Room queries return ``Flow``, the queries are automatically
      run asynchronously on a background thread.
   -  Room provides compile-time checks of SQLite statements.


**Implement the Room database**


   Your Room database class must be abstract and extend ``RoomDatabase``. Usually, you
   only need one instance of a Room database for the whole app.

   Let's make one now.

   1. Create a Kotlin class file called ``WordRoomDatabase`` and add this code to it:

   .. code:: prettyprint

      // Annotates class to be a Room Database with a table (entity) of the Word class
      @Database(entities = arrayOf(Word::class), version = 1, exportSchema = false)
      public abstract class WordRoomDatabase : RoomDatabase() {

         abstract fun wordDao(): WordDao

         companion object {
              // Singleton prevents multiple instances of database opening at the
              // same time. 
              @Volatile
              private var INSTANCE: WordRoomDatabase? = null

              fun getDatabase(context: Context): WordRoomDatabase {
                  // if the INSTANCE is not null, then return it,
                  // if it is, then create the database
                  return INSTANCE ?: synchronized(this) {
                      val instance = Room.databaseBuilder(
                              context.applicationContext,
                              WordRoomDatabase::class.java, 
                              "word_database"
                          ).build()
                      INSTANCE = instance
                      // return instance
                      instance
                  }
              }
         }
      }

   Let's walk through the code:

   -  The database class for Room must be ``abstract`` and extend ``RoomDatabase.``
   -  You annotate the class to be a Room database with ``@Database`` and use the
      annotation parameters to declare the entities that belong in the database and set
      the version number. Each entity corresponds to a table that will be created in the
      database. Database migrations are beyond the scope of this codelab, so
      ``exportSchema`` has been set to false here, in order to avoid a build warning. In a
      real app, consider setting a directory for Room to use to export the schema so you
      can check the current schema into your version control system.
   -  The database exposes DAOs through an abstract "getter" method for each @Dao.
   -  You defined a `singleton <https://en.wikipedia.org/wiki/Singleton_pattern>`__,
      ``WordRoomDatabase,`` to prevent having multiple instances of the database opened at
      the same time.
   -  ``getDatabase`` returns the singleton. It'll create the database the first time it's
      accessed, using Room's database builder to create a `RoomDatabase <https://developer.android.google.cn/reference/androidx/room/RoomDatabase.html>`__
      object in the application context from the ``WordRoomDatabase`` class and names it
      ``"word_database"``.

   **Note:** When you modify the database schema, you'll need to update the version number
   and define a migration strategy.

   For example, a destroy and re-create strategy can be sufficient. But for a real app,
   you must implement a migration strategy. See `Understanding migrations with Room <https://medium.com/google-developers/understanding-migrations-with-room-f01e04b07929>`__.

   In Android Studio, if you get errors when you paste code or during the build process,
   select **Build >Clean Project**. Then select **Build > Rebuild Project**, and then
   build again. If you use the provided code, there should be no errors at the points
   where you are instructed to build the app, but there may be errors in-between.


9. Create the Repository
------------------------


**What is a Repository?**


   A repository class abstracts access to multiple data sources. The repository is not
   part of the Architecture Components libraries, but is a suggested best practice for
   code separation and architecture. A Repository class provides a clean API for data
   access to the rest of the application.

   |cdfae5b9b10da57f.png|


**Why use a Repository?**


   A Repository manages queries and allows you to use multiple backends. In the most
   common example, the Repository implements the logic for deciding whether to fetch data
   from a network or use results cached in a local database.


**Implementing the Repository**


   Create a Kotlin class file called ``WordRepository`` and paste the following code into it:

   .. code:: prettyprint

      // Declares the DAO as a private property in the constructor. Pass in the DAO
      // instead of the whole database, because you only need access to the DAO
      class WordRepository(private val wordDao: WordDao) {

          // Room executes all queries on a separate thread.
          // Observed Flow will notify the observer when the data has changed.
          val allWords: Flow<List<Word>> = wordDao.getAlphabetizedWords()

          // By default Room runs suspend queries off the main thread, therefore, we don't need to
          // implement anything else to ensure we're not doing long running database work
          // off the main thread.
          @Suppress("RedundantSuspendModifier")
          @WorkerThread
          suspend fun insert(word: Word) {
              wordDao.insert(word)
          }
      }

   The main takeaways:

   -  The DAO is passed into the repository constructor as opposed to the whole database.
      This is because it only needs access to the DAO, since the DAO contains all the
      read/write methods for the database. There's no need to expose the entire database
      to the repository.
   -  The list of words is a public property. It's initialized by getting the ``Flow``
      list of words from Room; you can do this because of how you defined the
      ``getAlphabetizedWords`` method to return ``Flow`` in the "Observing database
      changes" step. Room executes all queries on a separate thread.
   -  The ``suspend`` modifier tells the compiler that this needs to be called from a
      coroutine or another suspending function.
   -  Room executes suspend queries off the main thread.

   Repositories are meant to mediate between different data sources. In this simple
   example, you only have one data source, so the Repository doesn't do much. See the
   `BasicSample <https://github.com/android/architecture-components-samples/tree/master/BasicSample>`__
   for a more complex implementation.


10. Create the ViewModel
------------------------


**What is a ViewModel?**


   The ``ViewModel``'s role is to provide data to the UI and survive configuration
   changes. A ``ViewModel`` acts as a communication center between the Repository and the
   UI. You can also use a ``ViewModel`` to share data between fragments. The ViewModel is
   part of the `lifecycle library <https://developer.android.google.cn/topic/libraries/architecture/lifecycle.html>`__.

   |72848dfccfe5777b.png|

   For an introductory guide to this topic, see `ViewModel Overview <https://developer.android.google.cn/topic/libraries/architecture/viewmodel.html>`__
   or the `ViewModels: A Simple Example <https://medium.com/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e>`__
   blog post.


**Why use a ViewModel?**


   A ``ViewModel`` holds your app's UI data in a lifecycle-conscious way that survives
   configuration changes. Separating your app's UI data from your ``Activity`` and
   ``Fragment`` classes lets you better follow the single responsibility principle: Your
   activities and fragments are responsible for drawing data to the screen, while your
   ``ViewModel`` can take care of holding and processing all the data needed for the UI.


**LiveData and ViewModel**


   `LiveData <https://developer.android.google.cn/topic/libraries/architecture/livedata>`__
   is an observable data holder - you can get notified every time the data changes. Unlike
   Flow, LiveData is lifecycle aware, meaning that it will respect the lifecycle of other
   components like Activity or Fragment. LiveData automatically stops or resumes
   observation depending on the lifecycle of the component that listens for changes. This
   makes LiveData the perfect component to be used for for changeable data that the UI
   will use or display.

   The ViewModel will transform the data from the Repository, from Flow to LiveData and
   expose the list of words as LiveData to the UI. This ensures that every time the data
   changes in the database, your UI is automatically updated.


**viewModelScope**


   In Kotlin, all coroutines run inside a `CoroutineScope <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-coroutine-scope/>`__.
   A scope controls the lifetime of coroutines through its job. When you cancel the job of
   a scope, it cancels all coroutines started in that scope.

   The AndroidX ``lifecycle-viewmodel-ktx`` library adds a ``viewModelScope`` as an
   extension function of the ``ViewModel`` class, enabling you to work with scopes.

   To find out more about working with coroutines in the ViewModel, check out Step 5 of
   the `Using Kotlin Coroutines in your Android App <https://codelabs.developers.google.cn/codelabs/kotlin-coroutines/index.html?index=..%2F..index#4>`__
   codelab or the `Easy Coroutines in Android: viewModelScope blogpost <https://medium.com/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471>`__.


**Implement the ViewModel**


   Create a Kotlin class file for ``WordViewModel`` and add this code to it:

   .. code:: prettyprint

      class WordViewModel(private val repository: WordRepository) : ViewModel() {

          // Using LiveData and caching what allWords returns has several benefits:
          // - We can put an observer on the data (instead of polling for changes) and only update the
          //   the UI when the data actually changes.
          // - Repository is completely separated from the UI through the ViewModel.
          val allWords: LiveData<List<Word>> = repository.allWords.asLiveData()

          /**
           * Launching a new coroutine to insert the data in a non-blocking way
           */
          fun insert(word: Word) = viewModelScope.launch {
              repository.insert(word)
          }
      }

      class WordViewModelFactory(private val repository: WordRepository) : ViewModelProvider.Factory {
          override fun <T : ViewModel> create(modelClass: Class<T>): T {
              if (modelClass.isAssignableFrom(WordViewModel::class.java)) {
                  @Suppress("UNCHECKED_CAST")
                  return WordViewModel(repository) as T
              }
              throw IllegalArgumentException("Unknown ViewModel class")
          }
      }

   Let's break down this code. Here, you have:

   -  created a class called ``WordViewModel`` that gets the ``WordRepository`` as a
      parameter and extends ``ViewModel``. The Repository is the only dependency that the
      ViewModel needs. If other classes would have been needed, they would have been
      passed in the constructor as well.
   -  added a public ``LiveData`` member variable to cache the list of words.
   -  initialized ``LiveData`` with the ``allWords`` Flow from the Repository. You then
      converted the Flow to LiveData by calling ``asLiveData().``
   -  created a wrapper ``insert()`` method that calls the Repository's ``insert()``
      method. This way, the implementation of ``insert()`` is encapsulated from the UI.
      We're launching a new coroutine and calling the repository's insert, which is a
      suspend function. As mentioned, ViewModels have a coroutine scope based on their
      lifecycle called ``viewModelScope``, which you'll use here.
   -  created the ViewModel and implemented a ``ViewModelProvider.Factory`` that gets as a
      parameter the dependencies needed to create ``WordViewModel``: the
      ``WordRepository``.

   By using ``viewModels`` and ``ViewModelProvider.Factory``,the framework will take care
   of the lifecycle of the ViewModel. It will survive configuration changes and even if
   the Activity is recreated, you'll always get the right instance of the
   ``WordViewModel`` class.

   **Warning**: Don't keep a reference to a ``Context`` that has a shorter lifecycle than
   your ViewModel! Examples are:

   -  Activity
   -  Fragment
   -  View

   Keeping a reference can cause a memory leak, e.g. the ViewModel has a reference to a
   destroyed Activity! All these objects can be destroyed by the operating system and
   recreated when there's a configuration change, and this can happen many times during
   the lifecycle of a ViewModel.

   **Important:** ``ViewModel``s don't survive the app's process being killed in the
   background when the OS needs more resources. For UI data that needs to survive process
   death due to running out of resources, you can use the `Saved State module for ViewModels <https://developer.android.google.cn/topic/libraries/architecture/viewmodel-savedstate>`__.
   Learn more `here <https://medium.com/google-developers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090>`__.

   To learn more about ``ViewModel`` classes, watch the `Android Jetpack: ViewModel <https://www.youtube.com/watch?v=5qlIPTDE274>`__ 
   video.

   To learn more about coroutines, check out the `Coroutines codelab <https://codelabs.developers.google.cn/codelabs/kotlin-coroutines/#0>`__.


11. Add XML layout
------------------


   Next, you need to add the XML layout for the list and items.

   This codelab assumes that you are familiar with creating layouts in XML, so we are just
   providing you with the code.

   Make your application theme material by setting the ``AppTheme`` parent to
   ``Theme.MaterialComponents.Light.DarkActionBar``. Add a style for list items in
   ``values/styles.xml``:

   .. code:: prettyprint

      <resources>

          <!-- Base application theme. -->
          <style name="AppTheme" parent="Theme.MaterialComponents.Light.DarkActionBar">
              <!-- Customize your theme here. -->
              <item name="colorPrimary">@color/colorPrimary</item>
              <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
              <item name="colorAccent">@color/colorAccent</item>
          </style>

          <!-- The default font for RecyclerView items is too small.
          The margin is a simple delimiter between the words. -->
          <style name="word_title">
              <item name="android:layout_marginBottom">8dp</item>
              <item name="android:paddingLeft">8dp</item>
              <item name="android:background">@android:color/holo_orange_light</item>
              <item name="android:textAppearance">@android:style/TextAppearance.Large</item>
          </style>
      </resources>

   Create a new dimension resource file:

   1. Click the app module in the **Project** window.
   2. Select **File > New > Android Resource File.**
   3. From the Available Qualifiers, select **Dimension.**
   4. Name the file: dimens

   |aa5895240838057.png|

   Add this dimension resources in ``values/dimens.xml``:

   .. code:: prettyprint

      <dimen name="big_padding">16dp</dimen>

   Add a ``layout/recyclerview_item.xml`` layout:

   .. code:: prettyprint

      <?xml version="1.0" encoding="utf-8"?>
      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:orientation="vertical" 
          android:layout_width="match_parent"
          android:layout_height="wrap_content">

          <TextView
              android:id="@+id/textView"
              style="@style/word_title"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:background="@android:color/holo_orange_light" />
      </LinearLayout>

   In ``layout/activity_main.xml``, replace the ``TextView`` with a ``RecyclerView`` and
   add a floating action button (FAB). Now your layout should look like this:

   .. code:: prettyprint

      <androidx.constraintlayout.widget.ConstraintLayout
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          xmlns:tools="http://schemas.android.com/tools"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          tools:context=".MainActivity">

          <androidx.recyclerview.widget.RecyclerView
              android:id="@+id/recyclerview"
              android:layout_width="0dp"
              android:layout_height="0dp"
              tools:listitem="@layout/recyclerview_item"
              android:padding="@dimen/big_padding"
              app:layout_constraintBottom_toBottomOf="parent"
              app:layout_constraintLeft_toLeftOf="parent"
              app:layout_constraintRight_toRightOf="parent"
              app:layout_constraintTop_toTopOf="parent" />

          <com.google.android.material.floatingactionbutton.FloatingActionButton
              android:id="@+id/fab"
              app:layout_constraintBottom_toBottomOf="parent"
              app:layout_constraintEnd_toEndOf="parent"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_margin="16dp"
              android:contentDescription="@string/add_word"/>

      </androidx.constraintlayout.widget.ConstraintLayout>

   Your FAB's appearance should correspond to the available action, so you'll want to
   replace the icon with a â€˜+' symbol.

   First, you need to add a new Vector Asset:

   1. Select **File > New > Vector Asset**.
   2. Click the Android robot icon in the **Clip Art:** field. |de077eade4adf77.png|
   3. Search for "add" and select the â€˜+' asset. Click **OK.** |758befc99c8cc794.png|
   4. On the **Asset Studio** window, click **Next**. |de62e3548d443c7f.png|
   5. Confirm the icon path as ``main > drawable`` and click **Finish** to add the asset.
      |2922fa2214257ec1.png|
   6. Still in ``layout/activity_main.xml``, update the FAB to include the new drawable:

   .. code:: prettyprint

      <com.google.android.material.floatingactionbutton.FloatingActionButton
              android:id="@+id/fab"
              app:layout_constraintBottom_toBottomOf="parent"
              app:layout_constraintEnd_toEndOf="parent"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_margin="16dp"
              android:contentDescription="@string/add_word"
              android:src="@drawable/ic_add_black_24dp"/>


12. Add a RecyclerView
----------------------


   You are going to display the data in a ``RecyclerView``, which is a little nicer than
   just throwing the data in a ``TextView``. This codelab assumes that you know how
   `RecyclerView <https://developer.android.google.cn/reference/kotlin/androidx/recyclerview/widget/RecyclerView>`__,
   `RecyclerView.ViewHolder <https://developer.android.google.cn/reference/kotlin/androidx/recyclerview/widget/RecyclerView.ViewHolder>`__,
   and `ListAdapter <https://developer.android.google.cn/reference/androidx/recyclerview/widget/ListAdapter>`__
   work.

   You'll need to create:

   -  The ``WordListAdapter`` class that extends ``ListAdapter``.
   -  A nested `DiffUtil.ItemCallback <https://developer.android.google.cn/reference/androidx/recyclerview/widget/DiffUtil.ItemCallback>`__
      class part of the ``WordListAdapter.``
   -  The ``ViewHolder`` that will display each word in our list.

   Here is the code:

   .. code:: prettyprint

      class WordListAdapter : ListAdapter<Word, WordViewHolder>(WordsComparator()) {

          override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): WordViewHolder {
              return WordViewHolder.create(parent)
          }

          override fun onBindViewHolder(holder: WordViewHolder, position: Int) {
              val current = getItem(position)
              holder.bind(current.word)
          }

          class WordViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
              private val wordItemView: TextView = itemView.findViewById(R.id.textView)

              fun bind(text: String?) {
                  wordItemView.text = text
              }

              companion object {
                  fun create(parent: ViewGroup): WordViewHolder {
                      val view: View = LayoutInflater.from(parent.context)
                          .inflate(R.layout.recyclerview_item, parent, false)
                      return WordViewHolder(view)
                  }
              }
          }

          class WordsComparator : DiffUtil.ItemCallback<Word>() {
              override fun areItemsTheSame(oldItem: Word, newItem: Word): Boolean {
                  return oldItem === newItem
              }

              override fun areContentsTheSame(oldItem: Word, newItem: Word): Boolean {
                  return oldItem.word == newItem.word
              }
          }
      }

   Here you have:

   -  The ``WordViewHolder`` class, that allows us to bind a text to a ``TextView``. The
      class exposes a static ``create()`` function that handles inflating the layout.
   -  The ``WordsComparator`` defines how to compute if two words are the same or if the
      contents are the same.
   -  The ``WordListAdapter`` creates the ``WordViewHolder`` in ``onCreateViewHolder`` and
      binds it in ``onBindViewHolder``.

   Add the ``RecyclerView`` in the ``onCreate()`` method of ``MainActivity``.

   In the ``onCreate()`` method after ``setContentView``:

   .. code:: prettyprint

         val recyclerView = findViewById<RecyclerView>(R.id.recyclerview)
         val adapter = WordListAdapter()
         recyclerView.adapter = adapter
         recyclerView.layoutManager = LinearLayoutManager(this)

   Run your app to make sure everything works. There are no items, because you have not
   hooked up the data yet.

   |79cb875d4296afce.png|


13. Instantiate the repository and the database
-----------------------------------------------


   You want to have only one instance of the database and of the repository in your app.
   An easy way to achieve this is by creating them as members of the ``Application``
   class. Then they will just be retrieved from the Application whenever they're needed,
   rather than constructed every time.

   For other patterns to manage dependencies, check out the 
   `dependency injection documentation <https://developer.android.google.cn/training/dependency-injection>`__.

   Create a new class called ``WordsApplication`` that extends ``Application``. Here's the
   code:

   .. code:: prettyprint

      class WordsApplication : Application() {
          // Using by lazy so the database and the repository are only created when they're needed
          // rather than when the application starts
          val database by lazy { WordRoomDatabase.getDatabase(this) }
          val repository by lazy { WordRepository(database.wordDao()) }
      }

   Here's what you've done:

   -  Created a database instance.
   -  Created a repository instance, based on the database DAO.
   -  Because these objects should only be created when they're first needed, rather than
      at app startup, you're using Kotlin's property delegation:
      `by lazy <https://kotlinlang.org/docs/reference/delegated-properties.html#lazy>`__.

   Now that you created the Application class, update the ``AndroidManifest`` file and set
   ``WordsApplication`` as ``application`` ``android:name``.

   Here's how the application tag should look:

   .. code:: prettyprint

      <application
              android:name=".WordsApplication"
              android:allowBackup="true"
              android:icon="@mipmap/ic_launcher"
              android:label="@string/app_name"
              android:roundIcon="@mipmap/ic_launcher_round"
              android:supportsRtl="true"
              android:theme="@style/AppTheme">
      ...


14. Populate the database
-------------------------


   At the moment, there is no data in the database. You will add data in two ways: Add
   some data when the database is created, and add an ``Activity`` for adding words.

   To delete all content and repopulate the database whenever the app is created, you'll
   create a `RoomDatabase.Callback <https://developer.android.google.cn/reference/androidx/room/RoomDatabase.Callback.html>`__
   and override ``onCreate()``. Because you cannot do Room database operations on the UI
   thread, ``onCreate()`` launches a coroutine on the IO Dispatcher.

   To launch a coroutine you need a ``CoroutineScope``. Update the ``getDatabase`` method
   of the ``WordRoomDatabase`` class, to also get a coroutine scope as parameter:

   .. code:: prettyprint

      fun getDatabase(
             context: Context,
             scope: CoroutineScope
        ): WordRoomDatabase {
      ...
      }

   Populating the database isn't related to a UI lifecycle, therefore you shouldn't use a
   CoroutineScope like viewModelScope. It's related to the app's lifecycle. You'll update
   the ``WordsApplication`` to contain an ``applicationScope``, then pass that to the
   ``WordRoomDatabase.getDatabase``.

   .. code:: prettyprint

      class WordsApplication : Application() {
          // No need to cancel this scope as it'll be torn down with the process
          val applicationScope = CoroutineScope(SupervisorJob())

          // Using by lazy so the database and the repository are only created when they're needed
          // rather than when the application starts
          val database by lazy { WordRoomDatabase.getDatabase(this, applicationScope) }
          val repository by lazy { WordRepository(database.wordDao()) }
      }

   In the ``WordRoomDatabase``, you'll create a custom implementation of the
   ``RoomDatabase.Callback()``, that also gets a ``CoroutineScope`` as constructor
   parameter. Then, you override the ``onCreate`` method to populate the database.

   Here is the code for creating the callback **within** the ``WordRoomDatabase`` class:

   .. code:: prettyprint

      private class WordDatabaseCallback(
          private val scope: CoroutineScope
      ) : RoomDatabase.Callback() {

          override fun onCreate(db: SupportSQLiteDatabase) {
              super.onCreate(db)
              INSTANCE?.let { database ->
                  scope.launch {
                      populateDatabase(database.wordDao())
                  }
              }
          }

          suspend fun populateDatabase(wordDao: WordDao) {
              // Delete all content here.
              wordDao.deleteAll()

              // Add sample words.
              var word = Word("Hello")
              wordDao.insert(word)
              word = Word("World!")
              wordDao.insert(word)

              // TODO: Add your own words!
          }
      }

   Finally, add the callback to the database build sequence right before calling
   ``.build()`` on the ``Room.databaseBuilder()``:

   .. code:: prettyprint

      .addCallback(WordDatabaseCallback(scope))

   Here is what the final code should look like:

   .. code:: prettyprint

      @Database(entities = arrayOf(Word::class), version = 1, exportSchema = false)
      abstract class WordRoomDatabase : RoomDatabase() {

         abstract fun wordDao(): WordDao

         private class WordDatabaseCallback(
             private val scope: CoroutineScope
         ) : RoomDatabase.Callback() {

             override fun onCreate(db: SupportSQLiteDatabase) {
                 super.onCreate(db)
                 INSTANCE?.let { database ->
                     scope.launch {
                         var wordDao = database.wordDao()

                         // Delete all content here.
                         wordDao.deleteAll()

                         // Add sample words.
                         var word = Word("Hello")
                         wordDao.insert(word)
                         word = Word("World!")
                         wordDao.insert(word)

                         // TODO: Add your own words!
                         word = Word("TODO!")
                         wordDao.insert(word)
                     }
                 }
             }
         }

         companion object {
             @Volatile
             private var INSTANCE: WordRoomDatabase? = null

             fun getDatabase(
                 context: Context,
                 scope: CoroutineScope
             ): WordRoomDatabase {
                  // if the INSTANCE is not null, then return it,
                  // if it is, then create the database
                  return INSTANCE ?: synchronized(this) {
                      val instance = Room.databaseBuilder(
                              context.applicationContext,
                              WordRoomDatabase::class.java,
                              "word_database"
                      )
                       .addCallback(WordDatabaseCallback(scope))
                       .build()
                      INSTANCE = instance
                      // return instance
                      instance
              }
           }
         }
      }


15. Add NewWordActivity
-----------------------


   Add these string resources in ``values/strings.xml``:

   .. code:: prettyprint

      <string name="hint_word">Word...</string>
      <string name="button_save">Save</string>
      <string name="empty_not_saved">Word not saved because it is empty.</string>
      <string name="add_word">Add word</string>

   Add this color resource in ``value/colors.xml``:

   .. code:: prettyprint

      <color name="buttonLabel">#FFFFFF</color>

   Add a ``min_height`` dimension resource in ``values/dimens.xml``:

   .. code:: prettyprint

      <dimen name="min_height">48dp</dimen>

   Create a new empty Android ``Activity`` with the Empty Activity template:

   1. Select **File > New > Activity > Empty Activity**
   2. Enter ``NewWordActivity`` for the Activity name.
   3. Verify that the new activity has been added to the Android Manifest.

   .. code:: prettyprint

      <activity android:name=".NewWordActivity"></activity>

   Update the ``activity_new_word.xml`` file in the layout folder with the following code:

   .. code:: prettyprint

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:orientation="vertical"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <EditText
              android:id="@+id/edit_word"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:minHeight="@dimen/min_height"
              android:fontFamily="sans-serif-light"
              android:hint="@string/hint_word"
              android:inputType="textAutoComplete"
              android:layout_margin="@dimen/big_padding"
              android:textSize="18sp" />

          <Button
              android:id="@+id/button_save"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:background="@color/colorPrimary"
              android:text="@string/button_save"
              android:layout_margin="@dimen/big_padding"
              android:textColor="@color/buttonLabel" />

      </LinearLayout>

   Update the code for the activity:

   .. code:: prettyprint

      class NewWordActivity : AppCompatActivity() {

          private lateinit var editWordView: EditText

          public override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContentView(R.layout.activity_new_word)
              editWordView = findViewById(R.id.edit_word)

              val button = findViewById<Button>(R.id.button_save)
              button.setOnClickListener {
                  val replyIntent = Intent()
                  if (TextUtils.isEmpty(editWordView.text)) {
                      setResult(Activity.RESULT_CANCELED, replyIntent)
                  } else {
                      val word = editWordView.text.toString()
                      replyIntent.putExtra(EXTRA_REPLY, word)
                      setResult(Activity.RESULT_OK, replyIntent)
                  }
                  finish()
              }
          }

          companion object {
              const val EXTRA_REPLY = "com.example.android.wordlistsql.REPLY"
          }
      }


16. Connect with the data
-------------------------


   The final step is to connect the UI to the database by saving new words the user enters
   and displaying the current contents of the word database in the ``RecyclerView``.

   To display the current contents of the database, add an observer that observes the
   ``LiveData`` in the ``ViewModel``.

   Whenever the data changes, the ``onChanged()`` callback is invoked, which calls the
   adapter's ``setWords()`` method to update the adapter's cached data and refresh the
   displayed list.

   In ``MainActivity``, create the ``ViewModel``:

   .. code:: prettyprint

      private val wordViewModel: WordViewModel by viewModels {
          WordViewModelFactory((application as WordsApplication).repository)
      }

   To create the ViewModel you used the ``viewModels`` delegate, passing in an instance of
   our ``WordViewModelFactory``. This is constructed based on the repository retrieved
   from the ``WordsApplication``.

   Also in ``onCreate()``, add an observer for the allWords ``LiveData`` property from the
   ``WordViewModel``.

   The ``onChanged()`` method (the default method for our Lambda) fires when the observed
   data changes and the activity is in the foreground:

   .. code:: prettyprint

      wordViewModel.allWords.observe(this, Observer { words ->
                  // Update the cached copy of the words in the adapter.
                  words?.let { adapter.submitList(it) }
      })

   You want to open the ``NewWordActivity`` when tapping on the FAB and, once you are back
   in the ``MainActivity``, to either insert the new word in the database or show a
   ``Toast``.

   To achieve this, start by defining a request code:

   .. code:: prettyprint

      private val newWordActivityRequestCode = 1

   In ``MainActivity``, add the ``onActivityResult()`` code for the ``NewWordActivity``.

   If the activity returns with ``RESULT_OK``, insert the returned word into the database
   by calling the ``insert()`` method of the ``WordViewModel``:

   .. code:: prettyprint

      override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
          super.onActivityResult(requestCode, resultCode, data)

          if (requestCode == newWordActivityRequestCode && resultCode == Activity.RESULT_OK) {
              data?.getStringExtra(NewWordActivity.EXTRA_REPLY)?.let {
                  val word = Word(it)
                  wordViewModel.insert(word)
              }
          } else {
              Toast.makeText(
                  applicationContext,
                  R.string.empty_not_saved,
                  Toast.LENGTH_LONG).show()
          }
      }

   In ``MainActivity,`` start ``NewWordActivity`` when the user taps the FAB. In the
   ``MainActivity`` ``onCreate``, find the FAB and add an ``onClickListener`` with this
   code:

   .. code:: prettyprint

      val fab = findViewById<FloatingActionButton>(R.id.fab)
      fab.setOnClickListener {
        val intent = Intent(this@MainActivity, NewWordActivity::class.java)
        startActivityForResult(intent, newWordActivityRequestCode)
      }

   Your finished code should look like this:

   .. code:: prettyprint

      class MainActivity : AppCompatActivity() {

          private val newWordActivityRequestCode = 1
          private val wordViewModel: WordViewModel by viewModels {
              WordViewModelFactory((application as WordsApplication).repository)
          }

          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContentView(R.layout.activity_main)

              val recyclerView = findViewById<RecyclerView>(R.id.recyclerview)
              val adapter = WordListAdapter()
              recyclerView.adapter = adapter
              recyclerView.layoutManager = LinearLayoutManager(this)

              // Add an observer on the LiveData returned by getAlphabetizedWords.
              // The onChanged() method fires when the observed data changes and the activity is
              // in the foreground.
              wordViewModel.allWords.observe(owner = this) { words ->
                  // Update the cached copy of the words in the adapter.
                  words.let { adapter.submitList(it) }
              }

              val fab = findViewById<FloatingActionButton>(R.id.fab)
              fab.setOnClickListener {
                  val intent = Intent(this@MainActivity, NewWordActivity::class.java)
                  startActivityForResult(intent, newWordActivityRequestCode)
              }
          }

          override fun onActivityResult(requestCode: Int, resultCode: Int, intentData: Intent?) {
              super.onActivityResult(requestCode, resultCode, intentData)

              if (requestCode == newWordActivityRequestCode && resultCode == Activity.RESULT_OK) {
                  intentData?.getStringExtra(NewWordActivity.EXTRA_REPLY)?.let { reply ->
                      val word = Word(reply)
                      wordViewModel.insert(word)
                  }
              } else {
                  Toast.makeText(
                      applicationContext,
                      R.string.empty_not_saved,
                      Toast.LENGTH_LONG
                  ).show()
              }
          }
      }

   Now run your app! When you add a word to the database in ``NewWordActivity``, the UI
   will automatically update.


17. Summary
-----------


   Now that you have a working app, let's recap what you've built. Here is the app
   structure again:

   |a70aca8d4b737712.png|

   The components of the app are:

   -  ``MainActivity``: displays words in a list using a ``RecyclerView`` and the
      ``WordListAdapter``. In ``MainActivity``, there is an ``Observer`` that observes the
      words from the database and is notified when they change.
   -  ``NewWordActivity:`` adds a new word to the list.
   -  ``WordViewModel``: provides methods for accessing the data layer, and it returns
      LiveData so that MainActivity can set up the observer relationship.\*
   -  ``LiveData<List<Word>>``: Makes possible the automatic updates in the UI components.
      You can convert from ``Flow``, to ``LiveData`` by calling ``flow.toLiveData()``.
   -  ``Repository:`` manages one or more data sources. The ``Repository`` exposes methods
      for the ViewModel to interact with the underlying data provider. In this app, that
      backend is a Room database.
   -  ``Room``: is a wrapper around and implements a SQLite database. Room does a lot of
      work for you that you used to have to do yourself.
   -  DAO: maps method calls to database queries, so that when the Repository calls a
      method such as ``getAlphabetizedWords()``, Room can execute
      **``SELECT * FROM word_table ORDER BY word ASC``.**
   -  DAO can expose ``suspend`` queries for one-shot requests and ``Flow`` queries - when
      you want to be notified of changes in the database.
   -  ``Word``: is the entity class that contains a single word.
   -  ``Views`` and ``Activities`` (and ``Fragments``) only interact with the data through
      the ``ViewModel``. As such, it doesn't matter where the data comes from.


**Flow of Data for Automatic UI Updates (Reactive UI)**


   The automatic update is possible because you are using LiveData. In the
   ``MainActivity``, there is an ``Observer`` that observes the words LiveData from the
   database and is notified when they change. When there is a change, the observer's
   ``onChange()`` method is executed and updates ``mWords`` in the ``WordListAdapter``.

   The data can be observed because it is ``LiveData``. And what is observed is the
   ``LiveData<List<Word>>`` that is returned by the ``WordViewModel`` ``allWords``
   property.

   The ``WordViewModel`` hides everything about the backend from the UI layer. It provides
   methods for accessing the data layer, and it returns ``LiveData`` so that
   ``MainActivity`` can set up the observer relationship. ``Views`` and ``Activities``
   (and ``Fragments``) only interact with the data through the ``ViewModel``. As such, it
   doesn't matter where the data comes from.

   In this case, the data comes from a ``Repository``. The ``ViewModel`` does not need to
   know what that Repository interacts with. It just needs to know how to interact with
   the ``Repository``, which is through the methods exposed by the ``Repository``.

   The Repository manages one or more data sources. In the ``WordListSample`` app, that
   backend is a Room database. Room is a wrapper around and implements a SQLite database.
   Room does a lot of work for you that you used to have to do yourself. For example, Room
   does everything that you used to do with an ``SQLiteOpenHelper`` class.

   The DAO maps method calls to database queries, so that when the Repository calls a
   method such as ``getAllWords()``, Room can execute
   **``SELECT * FROM word_table ORDER BY word ASC``**

   **.**

   Because the result returned from the query is observed ``LiveData``, every time the
   data in Room changes, the ``Observer`` interface's ``onChanged()`` method is executed
   and the UI updated.


18. Congratulations!
--------------------



**[Optional] Download the solution code**


   If you haven't already, you can take a look at the solution code for the codelab. You
   can look at the `github repository <https://github.com/android/codelab-android-room-with-a-view/tree/kotlin>`__
   or download the code here:

   `Download source code <https://github.com/android/codelab-android-room-with-a-view/archive/kotlin.zip>`__

   Unpack the downloaded zip file. This will unpack a root folder,
   ``android-room-with-a-view-kotlin``, which contains the complete app.

   The `solution code <https://github.com/android/codelab-android-room-with-a-view/tree/kotlin>`__
   includes unit tests for the Room database. Testing is beyond the scope of this codelab.
   Take a look at the code if you are interested.

   If you need to migrate an app, see `7 Steps to Room <https://medium.com/google-developers/7-steps-to-room-27a5fe5f99b2>`__ 
   after you successfully complete this codelab. Note that it is incredibly satisfying 
   to delete your `SQLiteOpenHelper <https://developer.android.google.cn/reference/android/database/sqlite/SQLiteOpenHelper.html>`__
   class and a whole lot of other code.

   When you have lots of data, consider using the `paging library <https://developer.android.google.cn/topic/libraries/architecture/paging.html>`__.
   The paging codelab is `here <https://codelabs.developers.google.cn/codelabs/android-paging/>`__.

   **More on Architecture, Room, LiveData and ViewModel**

   -  `Guide to App Architecture <https://developer.android.google.cn/topic/libraries/architecture/guide.html>`__
   -  `Android Architecture overview (video) <https://www.youtube.com/watch?v=vOJCrbr144o>`__ 
   -  `Android lifecycle-aware components codelab <https://codelabs.developers.google.cn/codelabs/android-lifecycles/#0>`__
      (``ViewModel``, ``LiveData``, ``LifecycleOwner``, ``LifecycleRegistryOwner``)
   -  `Architecture Component code samples <https://github.com/googlesamples/android-architecture-components>`__
   -  `Developing Android Apps with Kotlin <https://classroom.udacity.com/courses/ud9012>`__ 
      free online training - includes lessons on ViewModel, LiveData, Room, the 
      repository class and more with code examples.

   **Other Architecture Component codelabs**

   -  `Databinding Codelab <https://codelabs.developers.google.cn/codelabs/android-databinding/index.html>`__ -
      Remove even more code from your activities and fragments; works great with
      ViewModel and LiveData -  `Paging Codelab <https://codelabs.developers.google.cn/codelabs/android-paging/#0>`__ -
      Page through huge lists of data from Room
   -  `Navigation Codelab <https://codelabs.developers.google.cn/codelabs/android-navigation>`__ -
      Handle in app navigation using the Navigation component and tooling
   -  `WorkManager Codelab <https://codelabs.developers.google.cn/codelabs/android-workmanager>`__ -
      Efficiently do work when your app is in the background

.. |a659fcbf9eb9a5ee.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/a659fcbf9eb9a5ee.png
.. |91f5273394909e39.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/91f5273394909e39.png
.. |b924184f07268c35.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/b924184f07268c35.png
.. |8e4b761713e3a76b.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/8e4b761713e3a76b.png
.. |a70aca8d4b737712.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/a70aca8d4b737712.png
.. |9b6cbaec81794071.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/9b6cbaec81794071.png
.. |3821ac1a6cb01278.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/3821ac1a6cb01278.png
.. |cdfae5b9b10da57f.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/cdfae5b9b10da57f.png
.. |72848dfccfe5777b.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/72848dfccfe5777b.png
.. |aa5895240838057.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/aa5895240838057.png
.. |de077eade4adf77.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/de077eade4adf77.png
.. |758befc99c8cc794.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/758befc99c8cc794.png
.. |de62e3548d443c7f.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/de62e3548d443c7f.png
.. |2922fa2214257ec1.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/2922fa2214257ec1.png
.. |79cb875d4296afce.png| image:: https://developer.android.google.cn//static/codelabs/android-room-with-a-view-kotlin/img/79cb875d4296afce.png



ğŸŸ© TOC - Android Basics with Compose and Firebase
==================================================

https://developer.android.google.cn/courses/android-basics-compose-firebase/course?hl=en

Welcome to Android Basics with Compose and Firebase! In this course, you'll 
learn the basics of building Android apps with Jetpack Compose and Firebase. 
You'll develop a collection of Android apps using Compose and connect them to 
a Firebase project to gain access to a set of easy-to-use services such as 
Cloud Firestore, Firebase Authentication, Remote Config and Performance Monitoring.

All units are now available!


Unit 1: Your first Android app
------------------------------

   https://developer.android.google.cn/courses/android-basics-compose-firebase/unit-1?hl=en

   Learn programming basics and create your first Android app.


Introduction to Kotlin
~~~~~~~~~~~~~~~~~~~~~~


   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-1-pathway-1?hl=en

   Pathway 1

   Learn introductory programming concepts in Kotlin to prepare for building
   Android apps in Kotlin.

   April 2022


Set up Android Studio
~~~~~~~~~~~~~~~~~~~~~


   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-1-pathway-2?hl=en

   Pathway 2

   Install and set up Android Studio, create your first project, and run it
   on a device or emulator.

   April 2022


Build a basic layout
~~~~~~~~~~~~~~~~~~~~


   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-1-pathway-3?hl=en

   Pathway 3

   Build an Android app with a simple user interface that displays text and
   images.

   April 2022


Unit 2: Building app UI
-----------------------

   https://developer.android.google.cn/courses/android-basics-compose-firebase/unit-2?hl=en

   Continue learning the fundamentals of Kotlin, and start building more
   interactive apps.


Kotlin fundamentals
~~~~~~~~~~~~~~~~~~~

   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-2-pathway-1?hl=en

   Pathway 1

   Learn more fundamentals of Kotlin, object-oriented programming, and
   lambdas.

   April 2022


Add a button to an app
~~~~~~~~~~~~~~~~~~~~~~

   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-2-pathway-2?hl=en

   Pathway 2

   Learn how to respond to a button click in an Android app.

   April 2022


Interact with UI and state
~~~~~~~~~~~~~~~~~~~~~~~~~~

   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-2-pathway-3?hl=en

   Pathway 3

   Create a tip calculator app that calculates the tip from user input.

   April 2022



Unit 3: Display lists and use Material Design
---------------------------------------------

   https://developer.android.google.cn/courses/android-basics-compose-firebase/unit-3?hl=en

   Build apps that display a list of data and learn how to make your apps
   more beautiful with Material Design.


More Kotlin fundamentals
~~~~~~~~~~~~~~~~~~~~~~~~

   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-3-pathway-1?hl=en

   Pathway 1

   Learn additional Kotlin programming concepts that will enable you to build
   more interesting and fun Android apps.

   July 2022


Build a scrollable list
~~~~~~~~~~~~~~~~~~~~~~~

   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-3-pathway-2?hl=en

   Pathway 2

   Create an app that displays a scrollable list of text and images using
   Compose.

   July 2022


Build beautiful apps
~~~~~~~~~~~~~~~~~~~~

   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-3-pathway-3?hl=en

   Pathway 3

   Make your apps more beautiful and intuitive to use with Material Design,
   animations, and accessibility best practices.

   July 2022



Unit 4: Navigation and app architecture
---------------------------------------

   https://developer.android.google.cn/courses/android-basics-compose-firebase/unit-4?hl=en

   Learn the best practices of app architecture to build more complex
   apps.


Architecture Components
~~~~~~~~~~~~~~~~~~~~~~~

   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-4-pathway-1?hl=en

   Pathway 1

   Learn about app architecture and how to use ViewModels, UI State, and
   StateFlow to build more complex apps.

   August 2022


Navigation in Jetpack Compose
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-4-pathway-2?hl=en

   Pathway 2

   Learn how to use the Navigation component to build more complex apps with
   more screens and how to navigate and pass data between different
   composables.

   August 2022


Adapt for different screen sizes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   https://developer.android.google.cn/courses/pathways/android-basics-compose-unit-4-pathway-3?hl=en

   Pathway 3

   In this pathway, you'll learn how to adapt your app to different screen
   sizes and provide a better user experience, as well as how to test your
   adaptive UI.

   August 2022


Unit 5: Add Firebase to an Android app
--------------------------------------

   https://developer.android.google.cn/courses/android-basics-compose-firebase/unit-5?hl=en

   Learn how to build an Android app that follows Android app architecture
   and add Firebase to gain access to a set of easy-to-use services such
   as Cloud Firestore, Firebase Authentication, Remote Config and
   Performance Monitoring.


Build an Android app with Jetpack Compose and Firebase
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   https://developers.google.cn/learn/pathways/firebase-android-jetpack?hl=en

   Pathway 1

   Learn how to build an Android app that follows the Model-View-ViewModel
   (MVVM) architecture, add Firebase services to it and prepare the codebase
   to use different environments.

   April 2023


   * [ğŸ§­] Introduction to modern Android architecture

      Learn about modern Android architecture with Compose, how the
      Model-View-ViewModel (MVVM) architecture looks in a Compose app, and how flow
      fits into this architecture.


   * [ğŸ”¨] Building an Android app with Jetpack Compose and Firebase
      `Read article <https://firebase.googleblog.com/2022/04/building-an-app-android-jetpack-compose-firebase.html>`__

      Learn about Jetpack Compose, how to structure your app following recommended
      best practices, MVVM architecture, and how Firebase fits into this
      architecture.


   * [ğŸ”¨] Adding Firebase Authentication to a Jetpack Compose app
      `Read article <https://firebase.googleblog.com/2022/05/adding-firebase-auth-to-jetpack-compose-app.html>`__

      Learn how to implement the login and sign-up flows with Firebase
      Authentication, how the ViewModel class connects the business logic with the
      composable functions, and how to add Firebase Authentication to your app.


   * [ğŸ”¨] Adding Cloud Firestore to a Jetpack Compose app
      `Read article <https://firebase.googleblog.com/2022/07/adding-cloud-firestore-to-jetpack-compose-app.html>`__

      Learn about Cloud Firestore, how to add Cloud Firestore to your app, and how
      to listen to changes on stored items and update the Compose UI based on these
      events.


   * [ğŸ”¨] Using Coroutines and Flows with Firebase on an Android app
      `Read article <https://firebase.googleblog.com/2022/10/using-coroutines-flows-with-firebase-on-android.html>`__

      Learn how to add Kotlin coroutines and flow to the MVVM architecture, and use
      it to call Cloud Firestore and Firebase Authentication APIs.


   * [ğŸ”¨] Adding Firebase Performance Monitoring to a Jetpack Compose app
      `Read article <https://firebase.googleblog.com/2022/11/adding-performance-monitoring-to-jetpack-compose-app.html>`__

      Learn about Firebase Performance Monitoring, and how to add it and custom
      traces to monitor your app's performance.


   * [ğŸ”¨] Adding Firebase Remote Config to a Jetpack Compose app
      `Read article <https://firebase.googleblog.com/2022/11/adding-remote-config-to-jetpack-compose-app.html>`__

      Learn how to add Firebase Remote Config to your app to remotely control its
      behavior and appearance, rather than require users to download and install an
      update.


   * [ğŸš€] Build an Android app with Firebase and Compose
      `Take codelab <https://firebase.google.cn/codelabs/build-android-app-with-firebase-compose>`__

      Learn how to add Firebase Authentication, Cloud Firestore, Performance
      Monitoring, and Remote Config to an Android app built with Compose.


   * [ğŸ§­] Environments and emulators

      Learn how to set up Firebase projects for different environments and use
      emulators in some of them.


   * [ğŸ§­] Target different environments with Firebase

      Learn how to target different environments in your Android app with Firebase.


