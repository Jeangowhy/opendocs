
.. code:: bash

   # pandoc -trst -rhtml https://exploringjs.com/js/index.html >> $0
   # pandoc -trst -rhtml https://exploringjs.com/js/book/index.html >> $0
   while read -r url
   do
     echo $url
     #if [[ $url =~ .*index ]]; then
        curl $url                                 \
        | sed -n '/<h2/,/next-chapter/p' \
        | pandoc -trst -rhtml --column=80 --list-table=false >> $0
        #break
     #fi
   done << EOF
   https://exploringjs.com/js/book/pt_background.html
   https://exploringjs.com/js/book/ch_about-book.html
   https://exploringjs.com/js/book/ch_faq-book.html
   https://exploringjs.com/js/book/ch_why-js.html
   https://exploringjs.com/js/book/ch_nature.html
   https://exploringjs.com/js/book/ch_history.html
   https://exploringjs.com/js/book/ch_new-javascript-features.html
   https://exploringjs.com/js/book/ch_faq-language.html
   https://exploringjs.com/js/book/pt_first-steps.html
   https://exploringjs.com/js/book/ch_big-picture.html
   https://exploringjs.com/js/book/ch_syntax.html
   https://exploringjs.com/js/book/ch_console.html
   https://exploringjs.com/js/book/ch_assertion-api.html
   https://exploringjs.com/js/book/ch_exercises.html
   https://exploringjs.com/js/book/pt_variables-values.html
   https://exploringjs.com/js/book/ch_variables-assignment.html
   https://exploringjs.com/js/book/ch_values.html
   https://exploringjs.com/js/book/ch_operators.html
   https://exploringjs.com/js/book/pt_primitive-values.html
   https://exploringjs.com/js/book/ch_undefined-null.html
   https://exploringjs.com/js/book/ch_booleans.html
   https://exploringjs.com/js/book/ch_numbers.html
   https://exploringjs.com/js/book/ch_math.html
   https://exploringjs.com/js/book/ch_bigints.html
   https://exploringjs.com/js/book/ch_unicode.html
   https://exploringjs.com/js/book/ch_strings.html
   https://exploringjs.com/js/book/ch_template-literals.html
   https://exploringjs.com/js/book/ch_symbols.html
   https://exploringjs.com/js/book/pt_control-flow-data-flow.html
   https://exploringjs.com/js/book/ch_control-flow.html
   https://exploringjs.com/js/book/ch_exception-handling.html
   https://exploringjs.com/js/book/ch_callables.html
   https://exploringjs.com/js/book/ch_dynamic-code-evaluation.html
   https://exploringjs.com/js/book/pt_modularity.html
   https://exploringjs.com/js/book/ch_modules.html
   https://exploringjs.com/js/book/ch_objects.html
   https://exploringjs.com/js/book/ch_classes.html
   https://exploringjs.com/js/book/pt_collections.html
   https://exploringjs.com/js/book/ch_sync-iteration.html
   https://exploringjs.com/js/book/ch_arrays.html
   https://exploringjs.com/js/book/ch_typed-arrays.html
   https://exploringjs.com/js/book/ch_maps.html
   https://exploringjs.com/js/book/ch_weakmaps.html
   https://exploringjs.com/js/book/ch_sets.html
   https://exploringjs.com/js/book/ch_weaksets.html
   https://exploringjs.com/js/book/ch_destructuring.html
   https://exploringjs.com/js/book/ch_sync-generators.html
   https://exploringjs.com/js/book/pt_async.html
   https://exploringjs.com/js/book/ch_async-js.html
   https://exploringjs.com/js/book/ch_promises.html
   https://exploringjs.com/js/book/ch_async-functions.html
   https://exploringjs.com/js/book/ch_async-iteration.html
   https://exploringjs.com/js/book/pt_more-standard-library.html
   https://exploringjs.com/js/book/ch_regexps.html
   https://exploringjs.com/js/book/ch_dates.html
   https://exploringjs.com/js/book/ch_json.html
   https://exploringjs.com/js/book/pt_misc.html
   https://exploringjs.com/js/book/ch_next-steps.html
   https://exploringjs.com/js/book/pt_appendices.html
   https://exploringjs.com/js/book/ch_index.html
   EOF

    exit

Exploring JavaScript ES2024 Edition
===================================

    .. figure:: https://exploringjs.com/js/img/cover-homepage.jpg
    :target: https://exploringjs.com/js/index.html


    `Dr. Axel Rauschmayer <http://dr-axel.de/>`__ 
    Blogger (`2ality <http://2ality.com/>`__), book author, trainer


About the book
--------------

   â€œExploring JavaScriptâ€ makes the language less challenging to learn
   for newcomers, by offering a modern view that is as consistent as
   possible.

   Highlights:

   -  Get started quickly, by initially focusing on modern features.
   -  Test-driven exercises available for most chapters.
   -  Covers all essential features of JavaScript, up to and including ES2024.
   -  Optional advanced sections let you dig deeper.

   No prior knowledge of JavaScript is required, but you should know how
   to program.

   In case you were wondering: **This book was previously called
   â€œJavaScript for impatient programmersâ€.** The new name reflects its
   rather large scope â€“ which has exceeded initial plans for a long
   time.


Read all chapters online for free
---------------------------------

   Free content:

   -  `Read the full book online <book/index.html>`__
   -  Download previews (50%):

      -  `Ebook (PDF) <downloads/exploring-js-screen-preview.pdf>`__
      -  `Ebook (EPUB) <downloads/exploring-js-ebook-preview.epub>`__
      -  `Test-driven exercises (ZIP) <downloads/exploring-js-code-preview.zip>`__


Buy the book
------------

   The free online version is made possible by the sales of the book.
   There are digital packages and a print version. Thanks for your
   support!

Digital packages
----------------

   +--------------------------+-----------------+----------------------------+
   |                          | Package â€œbookâ€  | Package â€œbook & exercisesâ€ |
   +==========================+=================+============================+
   | Price                    | USD 39          | USD 45                     |
   +--------------------------+-----------------+----------------------------+
   |                          | `Buy now`_      | `Buy book & exercises`_    |
   +--------------------------+-----------------+----------------------------+
   | HTML archive (no ads)    | âœ”ï¸               | âœ”ï¸                        |
   +--------------------------+-----------------+----------------------------+
   | DRM-free EPUB            | âœ”ï¸               | âœ”ï¸                        |
   +--------------------------+-----------------+----------------------------+
   | DRM-free PDF (687 pages) | âœ”ï¸               | âœ”ï¸                        |
   +--------------------------+-----------------+----------------------------+
   | **Exercises**            |                 | âœ”ï¸                         |
   +--------------------------+-----------------+----------------------------+

.. _Buy now: https://payhip.com/b/Bl4eN
.. _Buy book & exercises: https://payhip.com/b/sSWqK


Print version: â€œJavaScript for impatient programmersâ€ (ES2019 edition)
----------------------------------------------------------------------

   Available on: 
   ğŸ‡ºğŸ‡¸ `Amazon.com (USD) <https://www.amazon.com/dp/1091210098/>`__, 
   ğŸ‡¬ğŸ‡§ `Amazon.co.uk (GBP) <https://www.amazon.co.uk/dp/1091210098/>`__, 
   ğŸ‡©ğŸ‡ª `Amazon.de (EUR) <https://www.amazon.de/dp/1091210098/>`__, 
   ğŸ‡«ğŸ‡· `Amazon.fr (EUR) <https://www.amazon.fr/dp/1091210098/>`__, 
   ğŸ‡ªğŸ‡¸ `Amazon.es (EUR) <https://www.amazon.es/dp/1091210098/>`__, 
   ğŸ‡®ğŸ‡¹ `Amazon.it (EUR) <https://www.amazon.it/dp/1091210098/>`__, 
   ğŸ‡³ğŸ‡± `Amazon.nl (EUR) <https://www.amazon.nl/dp/1091210098/>`__, 
   ğŸ‡¯ğŸ‡µ `Amazon.co.jp (JPY) <https://www.amazon.co.jp/dp/1091210098/>`__, 
   ğŸ‡®ğŸ‡³ `Amazon.in (INR) <https://www.amazon.in/dp/1091210098/>`__, 
   ğŸ‡¨ğŸ‡¦ `Amazon.ca (CAD) <https://www.amazon.ca/dp/1091210098/>`__, 
   ğŸ‡§ğŸ‡· `Amazon.com.br (BRL) <https://www.amazon.com.br/dp/1091210098/>`__, 
   ğŸ‡²ğŸ‡½ `Amazon.com.mx (MXN) <https://www.amazon.com.mx/dp/1091210098/>`__,
   ğŸ‡¦ğŸ‡º `Amazon.com.au (AUD) <https://www.amazon.com.au/dp/1091210098/>`__

Upgrading from old editions or smaller packages
-----------------------------------------------

   Upgrading from old editions:

   -  Upgrading from any old edition to any new package: 75% discount
      (`see instructions below <#how-to-upgrade>`__)
   -  If you bought the ES2022 edition on May 1 or later, you get the
      new edition for free (I should have already sent you an email).

   Upgrading from a smaller package:

   -  Upgrading from package â€œbookâ€ to package â€œexercisesâ€: USD 6.75
      (`see instructions below <#how-to-upgrade>`__)


How to upgrade
--------------

   -  Go to the download page (from which you downloaded your ebooks).
   -  At the bottom there is a box saying â€œAs a thank you for
      purchasing, you've received a special discountâ€.
   -  Click on the button â€œLearn Moreâ€.
   -  A new page opens that lists all available discounts.

   If you couldnâ€™t upgrade:

   -  Did you lose the purchase receipt (an email from Payhip) that
      contains the link to the download page?

      -  `Email me <https://dr-axel.de/#contact>`__ and tell me the
         email address you used for your purchase. Then Iâ€™ll resend the
         receipt.

   -  Did you buy your ebook in 2018 (before Payhip supported upgrades)?

      -  `Please use this form <https://docs.google.com/forms/d/e/1FAIpQLScE7eEmMPt4zgCL_eGwd8aoLUctsYS99EHq_Regq0JEXRYIsw/viewform>`__
         and Iâ€™ll send you a discount code.


Discounts and bulk purchases (digital version only)
---------------------------------------------------

   -  Discounts:

      -  If a digital package is beyond your means, you can get a
         discount via `this form <https://docs.google.com/forms/d/e/1FAIpQLSfUOlOIx7wEPv8AK4-YapGSmpBeJRIcy-t56iX4LNJISHzWpw/viewform>`__.
      -  If you own the print version of the book, you can get package
         â€œexercisesâ€ for USD 19 via `this form <https://docs.google.com/forms/d/e/1FAIpQLSfUOlOIx7wEPv8AK4-YapGSmpBeJRIcy-t56iX4LNJISHzWpw/viewform>`__.

   -  Bulk purchases: If you intend to buy more than 10 digital copies,
      please contact me via email at ``dr_axel AT icloud.com`` and Iâ€™ll
      help you make the purchase (Payhip doesnâ€™t currently directly
      support bulk purchases).


About the author
----------------

   |axel-head.jpg| 
   `Dr. Axel Rauschmayer <http://dr-axel.de/>`__ specializes in JavaScript 
   and web development. He `blogs <http://www.2ality.com/>`__, writes books 
   and teaches classes.

   Axel has been writing about JavaScript `since 2009 <http://2ality.com/2009/02/javascript-is-becoming-nice-language.html>`__.

.. |axel-head.jpg| image:: https://exploringjs.com/js/img/axel-head.jpg
   :width: 200px



Table of contents
=================

   #. `Iâ€ƒBackground <https://exploringjs.com/js/book/pt_background.html#background>`__

      #. `1â€ƒBefore you buy the book <https://exploringjs.com/js/book/ch_about-book.html#ch_about-book>`__

         #. `1.1â€ƒAbout the content <https://exploringjs.com/js/book/ch_about-book.html#about-the-content>`__
         #. `1.2â€ƒPreviewing and buying this book <https://exploringjs.com/js/book/ch_about-book.html#previewing-and-buying-this-book>`__
         #. `1.3â€ƒAbout the author <https://exploringjs.com/js/book/ch_about-book.html#about-the-author>`__
         #. `1.4â€ƒAcknowledgements <https://exploringjs.com/js/book/ch_about-book.html#acknowledgements>`__

      #. `2â€ƒFAQ: book and supplementary material <https://exploringjs.com/js/book/ch_faq-book.html#ch_faq-book>`__

         #. `2.1â€ƒHow to read this book <https://exploringjs.com/js/book/ch_faq-book.html#how-to-read-this-book>`__
         #. `2.2â€ƒI own a digital version <https://exploringjs.com/js/book/ch_faq-book.html#i-own-a-digital-version>`__
         #. `2.3â€ƒI own the print version (â€œJavaScript for impatient programmersâ€) <https://exploringjs.com/js/book/ch_faq-book.html#i-own-the-print-version-javascript-for-impatient-programmers>`__
         #. `2.4â€ƒNotations and conventions <https://exploringjs.com/js/book/ch_faq-book.html#notations-and-conventions>`__

      #. `3â€ƒWhy JavaScript? <https://exploringjs.com/js/book/ch_why-js.html#ch_why-js>`__

         #. `3.1â€ƒThe cons of JavaScript <https://exploringjs.com/js/book/ch_why-js.html#the-cons-of-javascript>`__
         #. `3.2â€ƒThe pros of JavaScript <https://exploringjs.com/js/book/ch_why-js.html#the-pros-of-javascript>`__
         #. `3.3â€ƒPro and con of JavaScript: innovation <https://exploringjs.com/js/book/ch_why-js.html#pro-and-con-of-javascript-innovation>`__

      #. `4â€ƒThe nature of JavaScript <https://exploringjs.com/js/book/ch_nature.html#ch_nature>`__

         #. `4.1â€ƒJavaScriptâ€™s influences <https://exploringjs.com/js/book/ch_nature.html#javascript-s-influences>`__
         #. `4.2â€ƒThe nature of JavaScript <https://exploringjs.com/js/book/ch_nature.html#the-nature-of-javascript>`__
         #. `4.3â€ƒTips for getting started with JavaScript <https://exploringjs.com/js/book/ch_nature.html#tips-for-getting-started-with-javascript>`__

      #. `5â€ƒHistory and evolution of JavaScript <https://exploringjs.com/js/book/ch_history.html#ch_history>`__

         #. `5.1â€ƒHow JavaScript was created <https://exploringjs.com/js/book/ch_history.html#how-javascript-was-created>`__
         #. `5.2â€ƒStandardization: JavaScript vs. ECMAScript <https://exploringjs.com/js/book/ch_history.html#standardizing-javascript>`__
         #. `5.3â€ƒTimeline of ECMAScript versions <https://exploringjs.com/js/book/ch_history.html#timeline-of-ecmascript-versions>`__
         #. `5.4â€ƒEvolving JavaScript: TC39 (Ecma Technical CommitteeÂ 39) <https://exploringjs.com/js/book/ch_history.html#tc39>`__
         #. `5.5â€ƒThe TC39 process for proposed ECMAScript features <https://exploringjs.com/js/book/ch_history.html#tc39-process>`__
         #. `5.6â€ƒHow to not break the web while changing JavaScript <https://exploringjs.com/js/book/ch_history.html#backward-compatibility>`__
         #. `5.7â€ƒFAQ: ECMAScript and TC39 <https://exploringjs.com/js/book/ch_history.html#faq-ecmascript-tc39>`__

      #. `6â€ƒNew JavaScript features <https://exploringjs.com/js/book/ch_new-javascript-features.html#ch_new-javascript-features>`__

         #. `6.1â€ƒNew in ECMAScript 2024 <https://exploringjs.com/js/book/ch_new-javascript-features.html#new-in-es2024>`__
         #. `6.2â€ƒNew in ECMAScript 2023 <https://exploringjs.com/js/book/ch_new-javascript-features.html#new-in-es2023>`__
         #. `6.3â€ƒNew in ECMAScript 2022 <https://exploringjs.com/js/book/ch_new-javascript-features.html#new-in-es2022>`__
         #. `6.4â€ƒNew in ECMAScript 2021 <https://exploringjs.com/js/book/ch_new-javascript-features.html#new-in-es2021>`__
         #. `6.5â€ƒNew in ECMAScript 2020 <https://exploringjs.com/js/book/ch_new-javascript-features.html#new-in-es2020>`__
         #. `6.6â€ƒNew in ECMAScript 2019 <https://exploringjs.com/js/book/ch_new-javascript-features.html#new-in-es2019>`__
         #. `6.7â€ƒNew in ECMAScript 2018 <https://exploringjs.com/js/book/ch_new-javascript-features.html#new-in-es2018>`__
         #. `6.8â€ƒNew in ECMAScript 2017 <https://exploringjs.com/js/book/ch_new-javascript-features.html#new-in-es2017>`__
         #. `6.9â€ƒNew in ECMAScript 2016 <https://exploringjs.com/js/book/ch_new-javascript-features.html#new-in-es2016>`__
         #. `6.10â€ƒSource of this chapter <https://exploringjs.com/js/book/ch_new-javascript-features.html#source-of-this-chapter>`__

      #. `7â€ƒFAQ: JavaScript <https://exploringjs.com/js/book/ch_faq-language.html#ch_faq-language>`__

         #. `7.1â€ƒWhat are good references for JavaScript? <https://exploringjs.com/js/book/ch_faq-language.html#what-are-good-references-for-javascript>`__
         #. `7.2â€ƒHow do I find out what JavaScript features are supported where? <https://exploringjs.com/js/book/ch_faq-language.html#how-do-i-find-out-what-javascript-features-are-supported-where>`__
         #. `7.3â€ƒWhere can I look up what features are planned for JavaScript? <https://exploringjs.com/js/book/ch_faq-language.html#where-can-i-look-up-what-features-are-planned-for-javascript>`__
         #. `7.4â€ƒWhy does JavaScript fail silently so often? <https://exploringjs.com/js/book/ch_faq-language.html#why-does-javascript-fail-silently-so-often>`__
         #. `7.5â€ƒWhy canâ€™t we clean up JavaScript, by removing quirks and outdated features? <https://exploringjs.com/js/book/ch_faq-language.html#why-can-t-we-clean-up-javascript-by-removing-quirks-and-outdated-features>`__
         #. `7.6â€ƒHow can I quickly try out a piece of JavaScript code? <https://exploringjs.com/js/book/ch_faq-language.html#how-can-i-quickly-try-out-a-piece-of-javascript-code>`__

   #. `IIâ€ƒFirst steps <https://exploringjs.com/js/book/pt_first-steps.html#pt_first-steps>`__

      #. `8â€ƒUsing JavaScript: the big picture <https://exploringjs.com/js/book/ch_big-picture.html#ch_big-picture>`__

         #. `8.1â€ƒWhat are you learning in this book? <https://exploringjs.com/js/book/ch_big-picture.html#what-are-you-learning-in-this-book>`__
         #. `8.2â€ƒThe structure of browsers and Node.js <https://exploringjs.com/js/book/ch_big-picture.html#the-structure-of-browsers-and-node-js>`__
         #. `8.3â€ƒJavaScript references <https://exploringjs.com/js/book/ch_big-picture.html#javascript-references>`__
         #. `8.4â€ƒFurther reading <https://exploringjs.com/js/book/ch_big-picture.html#further-reading>`__

      #. `9â€ƒSyntax <https://exploringjs.com/js/book/ch_syntax.html#ch_syntax>`__

         #. `9.1â€ƒAn overview of JavaScriptâ€™s syntax <https://exploringjs.com/js/book/ch_syntax.html#an-overview-of-javascript-s-syntax>`__
         #. `9.2â€ƒ(Advanced) <https://exploringjs.com/js/book/ch_syntax.html#advanced>`__
         #. `9.3â€ƒHashbang lines (Unix shell scripts) <https://exploringjs.com/js/book/ch_syntax.html#hashbang-lines>`__
         #. `9.4â€ƒIdentifiers <https://exploringjs.com/js/book/ch_syntax.html#identifiers>`__
         #. `9.5â€ƒStatement vs. expression <https://exploringjs.com/js/book/ch_syntax.html#statement-vs-expression>`__
         #. `9.6â€ƒAmbiguous syntax <https://exploringjs.com/js/book/ch_syntax.html#ambiguous-syntax>`__
         #. `9.7â€ƒSemicolons <https://exploringjs.com/js/book/ch_syntax.html#semicolons>`__
         #. `9.8â€ƒAutomatic semicolon insertion (ASI) <https://exploringjs.com/js/book/ch_syntax.html#automatic-semicolon-insertion-asi>`__
         #. `9.9â€ƒSemicolons: best practices <https://exploringjs.com/js/book/ch_syntax.html#semicolons-best-practices>`__
         #. `9.10â€ƒStrict mode vs. sloppy mode <https://exploringjs.com/js/book/ch_syntax.html#strict-mode>`__

      #. `10â€ƒConsoles: interactive JavaScript command lines <https://exploringjs.com/js/book/ch_console.html#ch_console>`__

         #. `10.1â€ƒTrying out JavaScript code <https://exploringjs.com/js/book/ch_console.html#trying-out-code>`__
         #. `10.2â€ƒThe console.* API: printing data and more <https://exploringjs.com/js/book/ch_console.html#the-console-api-printing-data-and-more>`__

      #. `11â€ƒAssertion API <https://exploringjs.com/js/book/ch_assertion-api.html#ch_assertion-api>`__

         #. `11.1â€ƒAssertions in software development <https://exploringjs.com/js/book/ch_assertion-api.html#assertions-in-software-development>`__
         #. `11.2â€ƒHow assertions are used in this book <https://exploringjs.com/js/book/ch_assertion-api.html#how-assertions-are-used-in-this-book>`__
         #. `11.3â€ƒNormal comparison vs. deep comparison <https://exploringjs.com/js/book/ch_assertion-api.html#normal-comparison-vs-deep-comparison>`__
         #. `11.4â€ƒQuick reference: module assert <https://exploringjs.com/js/book/ch_assertion-api.html#quick-reference-module-assert>`__

      #. `12â€ƒGetting started with exercises <https://exploringjs.com/js/book/ch_exercises.html#ch_exercises>`__

         #. `12.1â€ƒExercises <https://exploringjs.com/js/book/ch_exercises.html#exercises>`__
         #. `12.2â€ƒUnit tests in JavaScript <https://exploringjs.com/js/book/ch_exercises.html#unit-tests-in-javascript>`__

   #. `IIIâ€ƒVariables and values <https://exploringjs.com/js/book/pt_variables-values.html#pt_variables-values>`__

      #. `13â€ƒVariables and assignment <https://exploringjs.com/js/book/ch_variables-assignment.html#ch_variables-assignment>`__

         #. `13.1â€ƒlet <https://exploringjs.com/js/book/ch_variables-assignment.html#let>`__
         #. `13.2â€ƒconst <https://exploringjs.com/js/book/ch_variables-assignment.html#const>`__
         #. `13.3â€ƒDeciding between const and let <https://exploringjs.com/js/book/ch_variables-assignment.html#deciding-between-const-and-let>`__
         #. `13.4â€ƒThe scope of a variable <https://exploringjs.com/js/book/ch_variables-assignment.html#the-scope-of-a-variable>`__
         #. `13.5â€ƒ(Advanced) <https://exploringjs.com/js/book/ch_variables-assignment.html#advanced-1>`__
         #. `13.6â€ƒTerminology: static vs. dynamic <https://exploringjs.com/js/book/ch_variables-assignment.html#terminology-static-vs-dynamic>`__
         #. `13.7â€ƒGlobal variables and the global object <https://exploringjs.com/js/book/ch_variables-assignment.html#global-variables-and-the-global-object>`__
         #. `13.8â€ƒDeclarations: scope and activation <https://exploringjs.com/js/book/ch_variables-assignment.html#declarations-scope-activation>`__
         #. `13.9â€ƒClosures <https://exploringjs.com/js/book/ch_variables-assignment.html#closures>`__

      #. `14â€ƒValues <https://exploringjs.com/js/book/ch_values.html#ch_values>`__

         #. `14.1â€ƒWhatâ€™s a type? <https://exploringjs.com/js/book/ch_values.html#what-s-a-type>`__
         #. `14.2â€ƒJavaScriptâ€™s type hierarchy <https://exploringjs.com/js/book/ch_values.html#javascript-s-type-hierarchy>`__
         #. `14.3â€ƒThe types of the language specification <https://exploringjs.com/js/book/ch_values.html#the-types-of-the-language-specification>`__
         #. `14.4â€ƒPrimitive values vs. objects <https://exploringjs.com/js/book/ch_values.html#primitive-values-vs-objects>`__
         #. `14.5â€ƒThe operators typeof and instanceof: whatâ€™s the type of a value? <https://exploringjs.com/js/book/ch_values.html#the-operators-typeof-and-instanceof-what-s-the-type-of-a-value>`__
         #. `14.6â€ƒClasses and constructor functions <https://exploringjs.com/js/book/ch_values.html#classes-and-constructor-functions>`__
         #. `14.7â€ƒConverting between types <https://exploringjs.com/js/book/ch_values.html#converting-between-types>`__

      #. `15â€ƒOperators <https://exploringjs.com/js/book/ch_operators.html#ch_operators>`__

         #. `15.1â€ƒMaking sense of operators <https://exploringjs.com/js/book/ch_operators.html#making-sense-of-operators>`__
         #. `15.2â€ƒThe plus operator (+) <https://exploringjs.com/js/book/ch_operators.html#the-plus-operator>`__
         #. `15.3â€ƒAssignment operators <https://exploringjs.com/js/book/ch_operators.html#assignment-operators>`__
         #. `15.4â€ƒEquality: == vs. === <https://exploringjs.com/js/book/ch_operators.html#equality-vs>`__
         #. `15.5â€ƒOrdering operators <https://exploringjs.com/js/book/ch_operators.html#ordering-operators>`__
         #. `15.6â€ƒVarious other operators <https://exploringjs.com/js/book/ch_operators.html#various-other-operators>`__

   #. `IVâ€ƒPrimitive values <https://exploringjs.com/js/book/pt_primitive-values.html#pt_primitive-values>`__

      #. `16â€ƒThe non-values undefined and null <https://exploringjs.com/js/book/ch_undefined-null.html#ch_undefined-null>`__

         #. `16.1â€ƒundefined vs. null <https://exploringjs.com/js/book/ch_undefined-null.html#undefined-vs-null>`__
         #. `16.2â€ƒOccurrences of undefined and null <https://exploringjs.com/js/book/ch_undefined-null.html#occurrences-of-undefined-and-null>`__
         #. `16.3â€ƒChecking for undefined or null <https://exploringjs.com/js/book/ch_undefined-null.html#checking-for-undefined-or-null>`__
         #. `16.4â€ƒThe nullish coalescing operator (??) for default values [ES2020] <https://exploringjs.com/js/book/ch_undefined-null.html#nullish-coalescing-operator>`__
         #. `16.5â€ƒundefined and null donâ€™t have properties <https://exploringjs.com/js/book/ch_undefined-null.html#undefined-and-null-don-t-have-properties>`__
         #. `16.6â€ƒThe history of undefined and null <https://exploringjs.com/js/book/ch_undefined-null.html#the-history-of-undefined-and-null>`__

      #. `17â€ƒBooleans <https://exploringjs.com/js/book/ch_booleans.html#ch_booleans>`__

         #. `17.1â€ƒConverting to boolean <https://exploringjs.com/js/book/ch_booleans.html#converting-to-boolean>`__
         #. `17.2â€ƒFalsy and truthy values <https://exploringjs.com/js/book/ch_booleans.html#falsiness-truthiness>`__
         #. `17.3â€ƒTruthiness-based existence checks <https://exploringjs.com/js/book/ch_booleans.html#truthiness-existence-checks>`__
         #. `17.4â€ƒConditional operator (? :) <https://exploringjs.com/js/book/ch_booleans.html#conditional-operator>`__
         #. `17.5â€ƒBinary logical operators: And (x && y), Or (x || y) <https://exploringjs.com/js/book/ch_booleans.html#binary-logical-operators-and-x-y-or-x-y>`__
         #. `17.6â€ƒLogical Not (!) <https://exploringjs.com/js/book/ch_booleans.html#logical-not>`__

      #. `18â€ƒNumbers <https://exploringjs.com/js/book/ch_numbers.html#ch_numbers>`__

         #. `18.1â€ƒNumbers are used for both floating point numbers and integers <https://exploringjs.com/js/book/ch_numbers.html#numbers-are-used-for-both-floating-point-numbers-and-integers>`__
         #. `18.2â€ƒNumber literals <https://exploringjs.com/js/book/ch_numbers.html#number-literals>`__
         #. `18.3â€ƒArithmetic operators <https://exploringjs.com/js/book/ch_numbers.html#arithmetic-operators>`__
         #. `18.4â€ƒConverting to number <https://exploringjs.com/js/book/ch_numbers.html#converting-to-number>`__
         #. `18.5â€ƒError values <https://exploringjs.com/js/book/ch_numbers.html#error-values>`__
         #. `18.6â€ƒThe precision of numbers: careful with decimal fractions <https://exploringjs.com/js/book/ch_numbers.html#the-precision-of-numbers-careful-with-decimal-fractions>`__
         #. `18.7â€ƒ(Advanced) <https://exploringjs.com/js/book/ch_numbers.html#advanced-2>`__
         #. `18.8â€ƒBackground: floating point precision <https://exploringjs.com/js/book/ch_numbers.html#floating-point-precision>`__
         #. `18.9â€ƒInteger numbers in JavaScript <https://exploringjs.com/js/book/ch_numbers.html#integer-numbers-in-javascript>`__
         #. `18.10â€ƒBitwise operators <https://exploringjs.com/js/book/ch_numbers.html#bitwise-operators>`__
         #. `18.11â€ƒQuick reference: numbers <https://exploringjs.com/js/book/ch_numbers.html#quick-reference-numbers>`__

      #. `19â€ƒMath <https://exploringjs.com/js/book/ch_math.html#ch_math>`__

         #. `19.1â€ƒData properties <https://exploringjs.com/js/book/ch_math.html#data-properties>`__
         #. `19.2â€ƒExponents, roots, logarithms <https://exploringjs.com/js/book/ch_math.html#exponents-roots-logarithms>`__
         #. `19.3â€ƒRounding <https://exploringjs.com/js/book/ch_math.html#math-rounding>`__
         #. `19.4â€ƒTrigonometric Functions <https://exploringjs.com/js/book/ch_math.html#trigonometric-functions>`__
         #. `19.5â€ƒVarious other functions <https://exploringjs.com/js/book/ch_math.html#various-other-functions>`__
         #. `19.6â€ƒSources <https://exploringjs.com/js/book/ch_math.html#sources-1>`__

      #. `20â€ƒBigints â€“ arbitrary-precision integers [ES2020] (advanced) <https://exploringjs.com/js/book/ch_bigints.html#ch_bigints>`__

         #. `20.1â€ƒWhy bigints? <https://exploringjs.com/js/book/ch_bigints.html#why-bigints>`__
         #. `20.2â€ƒBigints <https://exploringjs.com/js/book/ch_bigints.html#bigints>`__
         #. `20.3â€ƒBigint literals <https://exploringjs.com/js/book/ch_bigints.html#bigint-literals>`__
         #. `20.4â€ƒReusing number operators for bigints (overloading) <https://exploringjs.com/js/book/ch_bigints.html#reusing-number-operators-for-bigints-overloading>`__
         #. `20.5â€ƒThe wrapper constructor BigInt <https://exploringjs.com/js/book/ch_bigints.html#the-wrapper-constructor-bigint>`__
         #. `20.6â€ƒCoercing bigints to other primitive types <https://exploringjs.com/js/book/ch_bigints.html#coercing-bigints-to-other-primitive-types>`__
         #. `20.7â€ƒTypedArrays and DataView operations for 64-bit values <https://exploringjs.com/js/book/ch_bigints.html#typedarrays-and-dataview-operations-for-64-bit-values>`__
         #. `20.8â€ƒBigints and JSON <https://exploringjs.com/js/book/ch_bigints.html#bigints-and-json>`__
         #. `20.9â€ƒFAQ: Bigints <https://exploringjs.com/js/book/ch_bigints.html#faq-bigints>`__

      #. `21â€ƒUnicode â€“ a brief introduction (advanced) <https://exploringjs.com/js/book/ch_unicode.html#ch_unicode>`__

         #. `21.1â€ƒCode points vs. code units <https://exploringjs.com/js/book/ch_unicode.html#code-points-vs-code-units>`__
         #. `21.2â€ƒEncodings used in web development: UTF-16 and UTF-8 <https://exploringjs.com/js/book/ch_unicode.html#encodings-used-in-web-development-utf-16-and-utf-8>`__
         #. `21.3â€ƒGrapheme clusters â€“ the real characters <https://exploringjs.com/js/book/ch_unicode.html#grapheme-clusters>`__

      #. `22â€ƒStrings <https://exploringjs.com/js/book/ch_strings.html#ch_strings>`__

         #. `22.1â€ƒCheat sheet: strings <https://exploringjs.com/js/book/ch_strings.html#cheat-sheet-strings>`__
         #. `22.2â€ƒPlain string literals <https://exploringjs.com/js/book/ch_strings.html#plain-string-literals>`__
         #. `22.3â€ƒAccessing JavaScript characters <https://exploringjs.com/js/book/ch_strings.html#accessing-javascript-characters>`__
         #. `22.4â€ƒString concatenation <https://exploringjs.com/js/book/ch_strings.html#string-concatenation>`__
         #. `22.5â€ƒConverting to string <https://exploringjs.com/js/book/ch_strings.html#converting-to-string>`__
         #. `22.6â€ƒComparing strings <https://exploringjs.com/js/book/ch_strings.html#comparing-strings>`__
         #. `22.7â€ƒAtoms of text: code points, JavaScript characters, grapheme clusters <https://exploringjs.com/js/book/ch_strings.html#atoms-of-text>`__
         #. `22.8â€ƒQuick reference: Strings <https://exploringjs.com/js/book/ch_strings.html#quickref-string>`__

      #. `23â€ƒUsing template literals and tagged templates [ES6] <https://exploringjs.com/js/book/ch_template-literals.html#ch_template-literals>`__

         #. `23.1â€ƒDisambiguation: â€œtemplateâ€ <https://exploringjs.com/js/book/ch_template-literals.html#disambiguation-template>`__
         #. `23.2â€ƒTemplate literals <https://exploringjs.com/js/book/ch_template-literals.html#template-literals>`__
         #. `23.3â€ƒTagged templates <https://exploringjs.com/js/book/ch_template-literals.html#tagged-templates>`__
         #. `23.4â€ƒExamples of tagged templates (as provided via libraries) <https://exploringjs.com/js/book/ch_template-literals.html#examples-of-tagged-templates-as-provided-via-libraries>`__
         #. `23.5â€ƒRaw string literals <https://exploringjs.com/js/book/ch_template-literals.html#raw-string-literals>`__
         #. `23.6â€ƒ(Advanced) <https://exploringjs.com/js/book/ch_template-literals.html#advanced-3>`__
         #. `23.7â€ƒMultiline template literals and indentation <https://exploringjs.com/js/book/ch_template-literals.html#multiline-template-literals-and-indentation>`__
         #. `23.8â€ƒSimple templating via template literals <https://exploringjs.com/js/book/ch_template-literals.html#simple-templating-via-template-literals>`__

      #. `24â€ƒSymbols [ES6] <https://exploringjs.com/js/book/ch_symbols.html#ch_symbols>`__

         #. `24.1â€ƒSymbols are primitives that are also like objects <https://exploringjs.com/js/book/ch_symbols.html#symbols-are-primitives-that-are-also-like-objects>`__
         #. `24.2â€ƒThe descriptions of symbols <https://exploringjs.com/js/book/ch_symbols.html#symbol-descriptions>`__
         #. `24.3â€ƒUse cases for symbols <https://exploringjs.com/js/book/ch_symbols.html#use-cases-for-symbols>`__
         #. `24.4â€ƒPublicly known symbols <https://exploringjs.com/js/book/ch_symbols.html#publicly-known-symbols>`__
         #. `24.5â€ƒConverting symbols <https://exploringjs.com/js/book/ch_symbols.html#converting-symbols>`__

   #. `Vâ€ƒControl flow and data flow <https://exploringjs.com/js/book/pt_control-flow-data-flow.html#pt_control-flow-data-flow>`__

      #. `25â€ƒControl flow statements <https://exploringjs.com/js/book/ch_control-flow.html#ch_control-flow>`__

         #. `25.1â€ƒControlling loops: break and continue <https://exploringjs.com/js/book/ch_control-flow.html#controlling-loops-break-and-continue>`__
         #. `25.2â€ƒConditions of control flow statements <https://exploringjs.com/js/book/ch_control-flow.html#conditions-of-control-flow-statements>`__
         #. `25.3â€ƒif statements [ES1] <https://exploringjs.com/js/book/ch_control-flow.html#if>`__
         #. `25.4â€ƒswitch statements [ES3] <https://exploringjs.com/js/book/ch_control-flow.html#switch>`__
         #. `25.5â€ƒwhile loops [ES1] <https://exploringjs.com/js/book/ch_control-flow.html#while>`__
         #. `25.6â€ƒdo-while loops [ES3] <https://exploringjs.com/js/book/ch_control-flow.html#do-while>`__
         #. `25.7â€ƒfor loops [ES1] <https://exploringjs.com/js/book/ch_control-flow.html#for>`__
         #. `25.8â€ƒfor-of loops [ES6] <https://exploringjs.com/js/book/ch_control-flow.html#for-of>`__
         #. `25.9â€ƒfor-await-of loops [ES2018] <https://exploringjs.com/js/book/ch_control-flow.html#for-await-of-loops>`__
         #. `25.10â€ƒfor-in loops (avoid) [ES1] <https://exploringjs.com/js/book/ch_control-flow.html#for-in>`__
         #. `25.11â€ƒRecomendations for looping <https://exploringjs.com/js/book/ch_control-flow.html#recomendations-for-looping>`__

      #. `26â€ƒException handling <https://exploringjs.com/js/book/ch_exception-handling.html#ch_exception-handling>`__

         #. `26.1â€ƒMotivation: throwing and catching exceptions <https://exploringjs.com/js/book/ch_exception-handling.html#motivation-throwing-and-catching-exceptions>`__
         #. `26.2â€ƒthrow <https://exploringjs.com/js/book/ch_exception-handling.html#throw>`__
         #. `26.3â€ƒThe try statement <https://exploringjs.com/js/book/ch_exception-handling.html#the-try-statement>`__
         #. `26.4â€ƒError and its subclasses <https://exploringjs.com/js/book/ch_exception-handling.html#error-classes>`__
         #. `26.5â€ƒChaining errors <https://exploringjs.com/js/book/ch_exception-handling.html#chaining-errors>`__

      #. `27â€ƒCallable values <https://exploringjs.com/js/book/ch_callables.html#ch_callables>`__

         #. `27.1â€ƒKinds of functions <https://exploringjs.com/js/book/ch_callables.html#kinds-of-functions>`__
         #. `27.2â€ƒOrdinary functions <https://exploringjs.com/js/book/ch_callables.html#ordinary-functions>`__
         #. `27.3â€ƒSpecialized functions [ES6] <https://exploringjs.com/js/book/ch_callables.html#specialized-functions>`__
         #. `27.4â€ƒSummary: kinds of callable values <https://exploringjs.com/js/book/ch_callables.html#summary-kinds-of-callable-values>`__
         #. `27.5â€ƒReturning values from functions and methods <https://exploringjs.com/js/book/ch_callables.html#returning-values-from-functions-and-methods>`__
         #. `27.6â€ƒParameter handling <https://exploringjs.com/js/book/ch_callables.html#parameter-handling>`__
         #. `27.7â€ƒMethods of functions: .call(), .apply(), .bind() <https://exploringjs.com/js/book/ch_callables.html#methods-of-functions>`__

      #. `28â€ƒEvaluating code dynamically: eval(), new Function() (advanced) <https://exploringjs.com/js/book/ch_dynamic-code-evaluation.html#ch_dynamic-code-evaluation>`__

         #. `28.1â€ƒeval() <https://exploringjs.com/js/book/ch_dynamic-code-evaluation.html#eval>`__
         #. `28.2â€ƒnew Function() <https://exploringjs.com/js/book/ch_dynamic-code-evaluation.html#new-function>`__
         #. `28.3â€ƒRecommendations <https://exploringjs.com/js/book/ch_dynamic-code-evaluation.html#recommendations>`__

   #. `VIâ€ƒModularity <https://exploringjs.com/js/book/pt_modularity.html#pt_modularity>`__

      #. `29â€ƒModules [ES6] <https://exploringjs.com/js/book/ch_modules.html#ch_modules>`__

         #. `29.1â€ƒCheat sheet: modules <https://exploringjs.com/js/book/ch_modules.html#cheat-sheet-modules>`__
         #. `29.2â€ƒJavaScript source code formats <https://exploringjs.com/js/book/ch_modules.html#javascript-source-code-formats>`__
         #. `29.3â€ƒBefore we had modules, we had scripts <https://exploringjs.com/js/book/ch_modules.html#scripts>`__
         #. `29.4â€ƒModule systems created prior to ES6 <https://exploringjs.com/js/book/ch_modules.html#module-systems-created-prior-to-es6>`__
         #. `29.5â€ƒECMAScript modules <https://exploringjs.com/js/book/ch_modules.html#ecmascript-modules>`__
         #. `29.6â€ƒNamed exports and imports <https://exploringjs.com/js/book/ch_modules.html#named-exports-and-imports>`__
         #. `29.7â€ƒDefault exports and imports <https://exploringjs.com/js/book/ch_modules.html#default-exports-and-imports-1>`__
         #. `29.8â€ƒRe-exporting <https://exploringjs.com/js/book/ch_modules.html#re-exporting>`__
         #. `29.9â€ƒMore details on exporting and importing <https://exploringjs.com/js/book/ch_modules.html#more-details-on-exporting-and-importing>`__
         #. `29.10â€ƒnpm packages <https://exploringjs.com/js/book/ch_modules.html#npm-packages>`__
         #. `29.11â€ƒNaming modules <https://exploringjs.com/js/book/ch_modules.html#naming-modules>`__
         #. `29.12â€ƒModule specifiers <https://exploringjs.com/js/book/ch_modules.html#module-specifiers>`__
         #. `29.13â€ƒimport.meta â€“ metadata for the current module [ES2020] <https://exploringjs.com/js/book/ch_modules.html#import.meta>`__
         #. `29.14â€ƒLoading modules dynamically via import() [ES2020] (advanced) <https://exploringjs.com/js/book/ch_modules.html#dynamic-imports>`__
         #. `29.15â€ƒTop-level await in modules [ES2022] (advanced) <https://exploringjs.com/js/book/ch_modules.html#top-level-await>`__
         #. `29.16â€ƒPolyfills: emulating native web platform features (advanced) <https://exploringjs.com/js/book/ch_modules.html#polyfills>`__

      #. `30â€ƒObjects <https://exploringjs.com/js/book/ch_objects.html#ch_objects>`__

         #. `30.1â€ƒCheat sheet: objects <https://exploringjs.com/js/book/ch_objects.html#cheat-sheet-objects>`__
         #. `30.2â€ƒWhat is an object? <https://exploringjs.com/js/book/ch_objects.html#what-is-an-object>`__
         #. `30.3â€ƒFixed-layout objects <https://exploringjs.com/js/book/ch_objects.html#fixed-layout-objects>`__
         #. `30.4â€ƒSpreading into object literals (...) [ES2018] <https://exploringjs.com/js/book/ch_objects.html#spreading-into-object-literals>`__
         #. `30.5â€ƒMethods and the special variable this <https://exploringjs.com/js/book/ch_objects.html#methods-and-this>`__
         #. `30.6â€ƒOptional chaining for property getting and method calls [ES2020] (advanced) <https://exploringjs.com/js/book/ch_objects.html#optional-chaining>`__
         #. `30.7â€ƒDictionary objects (advanced) <https://exploringjs.com/js/book/ch_objects.html#dictionary-objects>`__
         #. `30.8â€ƒProperty attributes and property descriptors [ES5] (advanced) <https://exploringjs.com/js/book/ch_objects.html#property-attributes-property-descriptors>`__
         #. `30.9â€ƒProtecting objects from being changed [ES5] (advanced) <https://exploringjs.com/js/book/ch_objects.html#protecting-objects>`__
         #. `30.10â€ƒPrototype chains <https://exploringjs.com/js/book/ch_objects.html#prototype-chains>`__
         #. `30.11â€ƒFAQ: objects <https://exploringjs.com/js/book/ch_objects.html#faq-objects>`__
         #. `30.12â€ƒQuick reference: Object <https://exploringjs.com/js/book/ch_objects.html#quickref-object-api>`__
         #. `30.13â€ƒQuick reference: Reflect <https://exploringjs.com/js/book/ch_objects.html#quickref-reflect>`__

      #. `31â€ƒClasses [ES6] <https://exploringjs.com/js/book/ch_classes.html#ch_classes>`__

         #. `31.1â€ƒCheat sheet: classes <https://exploringjs.com/js/book/ch_classes.html#cheat-sheet-classes>`__
         #. `31.2â€ƒThe essentials of classes <https://exploringjs.com/js/book/ch_classes.html#classes>`__
         #. `31.3â€ƒThe internals of classes <https://exploringjs.com/js/book/ch_classes.html#internals-of-classes>`__
         #. `31.4â€ƒPrototype members of classes <https://exploringjs.com/js/book/ch_classes.html#prototype-members-of-classes>`__
         #. `31.5â€ƒInstance members of classes [ES2022] <https://exploringjs.com/js/book/ch_classes.html#instance-members-of-classes>`__
         #. `31.6â€ƒStatic members of classes <https://exploringjs.com/js/book/ch_classes.html#static-members-of-classes>`__
         #. `31.7â€ƒSubclassing <https://exploringjs.com/js/book/ch_classes.html#subclassing>`__
         #. `31.8â€ƒThe methods and accessors of Object.prototype (advanced) <https://exploringjs.com/js/book/ch_classes.html#the-methods-and-accessors-of-object-prototype>`__
         #. `31.9â€ƒFAQ: classes <https://exploringjs.com/js/book/ch_classes.html#faq-classes>`__

   #. `VIIâ€ƒCollections <https://exploringjs.com/js/book/pt_collections.html#pt_collections>`__

      #. `32â€ƒSynchronous iteration [ES6] <https://exploringjs.com/js/book/ch_sync-iteration.html#ch_sync-iteration>`__

         #. `32.1â€ƒWhat is synchronous iteration about? <https://exploringjs.com/js/book/ch_sync-iteration.html#what-is-synchronous-iteration-about>`__
         #. `32.2â€ƒCore iteration constructs: iterables and iterators <https://exploringjs.com/js/book/ch_sync-iteration.html#iterable-iterator-iteratorresult>`__
         #. `32.3â€ƒIterating manually <https://exploringjs.com/js/book/ch_sync-iteration.html#iterating-manually>`__
         #. `32.4â€ƒIteration in practice <https://exploringjs.com/js/book/ch_sync-iteration.html#iteration-in-practice>`__
         #. `32.5â€ƒGrouping iterables [ES2024] <https://exploringjs.com/js/book/ch_sync-iteration.html#grouping-sync-iterables>`__
         #. `32.6â€ƒExample: grouping by property value <https://exploringjs.com/js/book/ch_sync-iteration.html#example-grouping-by-property-value>`__
         #. `32.7â€ƒQuick reference: synchronous iteration <https://exploringjs.com/js/book/ch_sync-iteration.html#quickref-sync-iteration>`__

      #. `33â€ƒArrays (Array) <https://exploringjs.com/js/book/ch_arrays.html#ch_arrays>`__

         #. `33.1â€ƒCheat sheet: Arrays <https://exploringjs.com/js/book/ch_arrays.html#cheat-sheet-arrays>`__
         #. `33.2â€ƒWays of using Arrays: fixed layout vs. sequence <https://exploringjs.com/js/book/ch_arrays.html#arrays-fixed-layout-vs-sequence>`__
         #. `33.3â€ƒBasic Array operations <https://exploringjs.com/js/book/ch_arrays.html#basic-array-operations>`__
         #. `33.4â€ƒfor-of and Arrays <https://exploringjs.com/js/book/ch_arrays.html#for-of-and-arrays>`__
         #. `33.5â€ƒArray-like objects <https://exploringjs.com/js/book/ch_arrays.html#array-like-objects>`__
         #. `33.6â€ƒConverting iterables and Array-like values to Arrays <https://exploringjs.com/js/book/ch_arrays.html#converting-to-array>`__
         #. `33.7â€ƒCreating and filling Arrays with arbitrary lengths <https://exploringjs.com/js/book/ch_arrays.html#filling-arrays>`__
         #. `33.8â€ƒMultidimensional Arrays <https://exploringjs.com/js/book/ch_arrays.html#multidimensional-arrays>`__
         #. `33.9â€ƒArrays are actually dictionaries (advanced) <https://exploringjs.com/js/book/ch_arrays.html#arrays-are-actually-dictionaries>`__
         #. `33.10â€ƒDestructive vs. non-destructive Array operations <https://exploringjs.com/js/book/ch_arrays.html#array-operations-destructive-vs-non-destructive>`__
         #. `33.11â€ƒAdding and removing elements at either end of an Array <https://exploringjs.com/js/book/ch_arrays.html#adding-and-removing-elements-at-either-end-of-an-array>`__
         #. `33.12â€ƒArray methods that accept element callbacks <https://exploringjs.com/js/book/ch_arrays.html#array-element-callbacks>`__
         #. `33.13â€ƒTransforming with element callbacks: .map(), .filter(), .flatMap() <https://exploringjs.com/js/book/ch_arrays.html#transforming-with-element-callbacks-map-filter-flatmap>`__
         #. `33.14â€ƒ.reduce(): computing a summary for an Array <https://exploringjs.com/js/book/ch_arrays.html#Array.prototype.reduce>`__
         #. `33.15â€ƒ.sort(): sorting Arrays <https://exploringjs.com/js/book/ch_arrays.html#Array.prototype.sort>`__
         #. `33.16â€ƒArrays can use operations for iterables <https://exploringjs.com/js/book/ch_arrays.html#arrays-can-use-operations-for-iterables>`__
         #. `33.17â€ƒQuick reference: Array <https://exploringjs.com/js/book/ch_arrays.html#quickref-Array>`__

      #. `34â€ƒTyped Arrays: handling binary data [ES6] (advanced) <https://exploringjs.com/js/book/ch_typed-arrays.html#ch_typed-arrays>`__

         #. `34.1â€ƒAn overview of the API <https://exploringjs.com/js/book/ch_typed-arrays.html#an-overview-of-the-api>`__
         #. `34.2â€ƒUsing Typed Arrays <https://exploringjs.com/js/book/ch_typed-arrays.html#using-typed-arrays>`__
         #. `34.3â€ƒUsing DataViews <https://exploringjs.com/js/book/ch_typed-arrays.html#using-dataviews>`__
         #. `34.4â€ƒElement types <https://exploringjs.com/js/book/ch_typed-arrays.html#element-types>`__
         #. `34.5â€ƒConverting to and from Typed Arrays <https://exploringjs.com/js/book/ch_typed-arrays.html#converting-to-and-from-typed-arrays>`__
         #. `34.6â€ƒResizing ArrayBuffers [ES2024] <https://exploringjs.com/js/book/ch_typed-arrays.html#resizing-array-buffers>`__
         #. `34.7â€ƒTransferring and detaching ArrayBuffers [ES2024] <https://exploringjs.com/js/book/ch_typed-arrays.html#transferring-detaching-array-buffers>`__
         #. `34.8â€ƒQuick references: indices vs. offsets <https://exploringjs.com/js/book/ch_typed-arrays.html#typed-arrays-indices-offsets>`__
         #. `34.9â€ƒQuick reference: ArrayBuffers <https://exploringjs.com/js/book/ch_typed-arrays.html#quick-reference-arraybuffers>`__
         #. `34.10â€ƒQuick reference: Typed Arrays <https://exploringjs.com/js/book/ch_typed-arrays.html#quick-reference-typed-arrays>`__
         #. `34.11â€ƒQuick reference: DataViews <https://exploringjs.com/js/book/ch_typed-arrays.html#quick-reference-dataviews>`__

      #. `35â€ƒMaps (Map) [ES6] <https://exploringjs.com/js/book/ch_maps.html#ch_maps>`__

         #. `35.1â€ƒUsing Maps <https://exploringjs.com/js/book/ch_maps.html#using-maps>`__
         #. `35.2â€ƒExample: Counting characters <https://exploringjs.com/js/book/ch_maps.html#example-counting-characters>`__
         #. `35.3â€ƒA few more details about the keys of Maps (advanced) <https://exploringjs.com/js/book/ch_maps.html#a-few-more-details-about-the-keys-of-maps>`__
         #. `35.4â€ƒMissing Map operations <https://exploringjs.com/js/book/ch_maps.html#missing-map-operations>`__
         #. `35.5â€ƒQuick reference: Map <https://exploringjs.com/js/book/ch_maps.html#quickref-maps>`__
         #. `35.6â€ƒFAQ: Maps <https://exploringjs.com/js/book/ch_maps.html#faq-maps>`__

      #. `36â€ƒWeakMaps (WeakMap) [ES6] (advanced) <https://exploringjs.com/js/book/ch_weakmaps.html#ch_weakmaps>`__

         #. `36.1â€ƒWeakMaps are black boxes <https://exploringjs.com/js/book/ch_weakmaps.html#weakmaps-as-black-boxes>`__
         #. `36.2â€ƒThe keys of a WeakMap are weakly held <https://exploringjs.com/js/book/ch_weakmaps.html#weakmap-keys-are-weakly-held>`__
         #. `36.3â€ƒAttaching values to objects via WeakMaps <https://exploringjs.com/js/book/ch_weakmaps.html#attaching-values-to-objects-via-weakmaps>`__
         #. `36.4â€ƒQuick reference: WeakMap <https://exploringjs.com/js/book/ch_weakmaps.html#quickref-weakmaps>`__

      #. `37â€ƒSets (Set) [ES6] <https://exploringjs.com/js/book/ch_sets.html#ch_sets>`__

         #. `37.1â€ƒUsing Sets <https://exploringjs.com/js/book/ch_sets.html#using-sets>`__
         #. `37.2â€ƒExamples of using Sets <https://exploringjs.com/js/book/ch_sets.html#examples-of-using-sets>`__
         #. `37.3â€ƒWhat Set elements are considered equal? <https://exploringjs.com/js/book/ch_sets.html#what-set-elements-are-considered-equal>`__
         #. `37.4â€ƒMissing Set operations <https://exploringjs.com/js/book/ch_sets.html#missing-set-operations>`__
         #. `37.5â€ƒSets can use operations for iterables <https://exploringjs.com/js/book/ch_sets.html#sets-can-use-operations-for-iterables>`__
         #. `37.6â€ƒQuick reference: Set <https://exploringjs.com/js/book/ch_sets.html#quickref-sets>`__
         #. `37.7â€ƒFAQ: Sets <https://exploringjs.com/js/book/ch_sets.html#faq-sets>`__

      #. `38â€ƒWeakSets (WeakSet) [ES6] (advanced) <https://exploringjs.com/js/book/ch_weaksets.html#ch_weaksets>`__

         #. `38.1â€ƒExample: Marking objects as safe to use with a method <https://exploringjs.com/js/book/ch_weaksets.html#example-marking-objects-as-safe-to-use-with-a-method>`__
         #. `38.2â€ƒWeakSet API <https://exploringjs.com/js/book/ch_weaksets.html#weakset-api>`__

      #. `39â€ƒDestructuring [ES6] <https://exploringjs.com/js/book/ch_destructuring.html#ch_destructuring>`__

         #. `39.1â€ƒA first taste of destructuring <https://exploringjs.com/js/book/ch_destructuring.html#a-first-taste-of-destructuring>`__
         #. `39.2â€ƒConstructing vs. extracting <https://exploringjs.com/js/book/ch_destructuring.html#constructing-vs-extracting>`__
         #. `39.3â€ƒWhere can we destructure? <https://exploringjs.com/js/book/ch_destructuring.html#where-can-we-destructure>`__
         #. `39.4â€ƒObject-destructuring <https://exploringjs.com/js/book/ch_destructuring.html#object-destructuring>`__
         #. `39.5â€ƒArray-destructuring <https://exploringjs.com/js/book/ch_destructuring.html#array-destructuring>`__
         #. `39.6â€ƒExamples of destructuring <https://exploringjs.com/js/book/ch_destructuring.html#examples-of-destructuring>`__
         #. `39.7â€ƒWhat happens if a pattern part does not match anything? <https://exploringjs.com/js/book/ch_destructuring.html#what-happens-if-a-pattern-part-does-not-match-anything>`__
         #. `39.8â€ƒWhat values canâ€™t be destructured? <https://exploringjs.com/js/book/ch_destructuring.html#what-values-can-t-be-destructured>`__
         #. `39.9â€ƒ(Advanced) <https://exploringjs.com/js/book/ch_destructuring.html#advanced-4>`__
         #. `39.10â€ƒDefault values <https://exploringjs.com/js/book/ch_destructuring.html#default-values>`__
         #. `39.11â€ƒParameter definitions are similar to destructuring <https://exploringjs.com/js/book/ch_destructuring.html#parameter-definitions-are-similar-to-destructuring>`__
         #. `39.12â€ƒNested destructuring <https://exploringjs.com/js/book/ch_destructuring.html#nested-destructuring>`__

      #. `40â€ƒSynchronous generators [ES6] (advanced) <https://exploringjs.com/js/book/ch_sync-generators.html#ch_sync-generators>`__

         #. `40.1â€ƒWhat are synchronous generators? <https://exploringjs.com/js/book/ch_sync-generators.html#what-are-synchronous-generators>`__
         #. `40.2â€ƒCalling generators from generators (advanced) <https://exploringjs.com/js/book/ch_sync-generators.html#calling-generators-from-generators>`__
         #. `40.3â€ƒBackground: external iteration vs. internal iteration <https://exploringjs.com/js/book/ch_sync-generators.html#external-iteration-internal-iteration>`__
         #. `40.4â€ƒUse case for generators: reusing traversals <https://exploringjs.com/js/book/ch_sync-generators.html#reusing-traversals>`__
         #. `40.5â€ƒAdvanced features of generators <https://exploringjs.com/js/book/ch_sync-generators.html#advanced-features-of-generators>`__

   #. `VIIIâ€ƒAsynchronicity <https://exploringjs.com/js/book/pt_async.html#pt_async>`__

      #. `41â€ƒFoundations of asynchronous programming in JavaScript <https://exploringjs.com/js/book/ch_async-js.html#ch_async-js>`__

         #. `41.1â€ƒA roadmap for asynchronous programming in JavaScript <https://exploringjs.com/js/book/ch_async-js.html#a-roadmap-for-asynchronous-programming-in-javascript>`__
         #. `41.2â€ƒThe call stack <https://exploringjs.com/js/book/ch_async-js.html#the-call-stack>`__
         #. `41.3â€ƒThe event loop <https://exploringjs.com/js/book/ch_async-js.html#the-event-loop>`__
         #. `41.4â€ƒHow to avoid blocking the JavaScript process <https://exploringjs.com/js/book/ch_async-js.html#how-to-avoid-blocking-the-javascript-process>`__
         #. `41.5â€ƒPatterns for delivering asynchronous results <https://exploringjs.com/js/book/ch_async-js.html#patterns-for-delivering-asynchronous-results>`__
         #. `41.6â€ƒAsynchronous code: the downsides <https://exploringjs.com/js/book/ch_async-js.html#asynchronous-code-the-downsides>`__
         #. `41.7â€ƒResources <https://exploringjs.com/js/book/ch_async-js.html#resources>`__

      #. `42â€ƒPromises for asynchronous programming [ES6] <https://exploringjs.com/js/book/ch_promises.html#ch_promises>`__

         #. `42.1â€ƒThe basics of using Promises <https://exploringjs.com/js/book/ch_promises.html#the-basics-of-using-promises>`__
         #. `42.2â€ƒExamples <https://exploringjs.com/js/book/ch_promises.html#examples>`__
         #. `42.3â€ƒError handling: donâ€™t mix rejections and exceptions <https://exploringjs.com/js/book/ch_promises.html#error-handling-don-t-mix-rejections-and-exceptions>`__
         #. `42.4â€ƒPromise-based functions start synchronously, settle asynchronously <https://exploringjs.com/js/book/ch_promises.html#promise-based-funcs-sync-start-async-settlement>`__
         #. `42.5â€ƒPromise combinator functions: working with Arrays of Promises <https://exploringjs.com/js/book/ch_promises.html#promise-combinators>`__
         #. `42.6â€ƒConcurrency and Promise.all() (advanced) <https://exploringjs.com/js/book/ch_promises.html#concurrency-and-promise-all>`__
         #. `42.7â€ƒTips for chaining Promises <https://exploringjs.com/js/book/ch_promises.html#tips-for-chaining-promises>`__
         #. `42.8â€ƒQuick reference: Promise combinator functions <https://exploringjs.com/js/book/ch_promises.html#quick-reference-promise-combinator-functions>`__

      #. `43â€ƒAsync functions [ES2017] <https://exploringjs.com/js/book/ch_async-functions.html#ch_async-functions>`__

         #. `43.1â€ƒAsync functions: the basics <https://exploringjs.com/js/book/ch_async-functions.html#async-functions-the-basics>`__
         #. `43.2â€ƒReturning from async functions <https://exploringjs.com/js/book/ch_async-functions.html#returning-from-async-functions>`__
         #. `43.3â€ƒawait: working with Promises <https://exploringjs.com/js/book/ch_async-functions.html#await-working-with-promises>`__
         #. `43.4â€ƒ(Advanced) <https://exploringjs.com/js/book/ch_async-functions.html#advanced-5>`__
         #. `43.5â€ƒConcurrency and await <https://exploringjs.com/js/book/ch_async-functions.html#concurrency-and-await>`__
         #. `43.6â€ƒTips for using async functions <https://exploringjs.com/js/book/ch_async-functions.html#tips-for-using-async-functions>`__

      #. `44â€ƒAsynchronous iteration [ES2018] <https://exploringjs.com/js/book/ch_async-iteration.html#ch_async-iteration>`__

         #. `44.1â€ƒBasic asynchronous iteration <https://exploringjs.com/js/book/ch_async-iteration.html#basic-asynchronous-iteration>`__
         #. `44.2â€ƒAsynchronous generators <https://exploringjs.com/js/book/ch_async-iteration.html#async-generators>`__
         #. `44.3â€ƒAsync iteration over Node.js streams <https://exploringjs.com/js/book/ch_async-iteration.html#async-iteration-over-node-js-streams>`__

   #. `IXâ€ƒMore standard library <https://exploringjs.com/js/book/pt_more-standard-library.html#pt_more-standard-library>`__

      #. `45â€ƒRegular expressions (RegExp) <https://exploringjs.com/js/book/ch_regexps.html#ch_regexps>`__

         #. `45.1â€ƒCreating regular expressions <https://exploringjs.com/js/book/ch_regexps.html#creating-regular-expressions>`__
         #. `45.2â€ƒSyntax characters and escaping <https://exploringjs.com/js/book/ch_regexps.html#escaping-for-regexp>`__
         #. `45.3â€ƒSyntax: atoms of regular expressions <https://exploringjs.com/js/book/ch_regexps.html#syntax-atoms-of-regular-expressions>`__
         #. `45.4â€ƒSyntax: character class escapes <https://exploringjs.com/js/book/ch_regexps.html#syntax-character-class-escapes>`__
         #. `45.5â€ƒSyntax: character classes <https://exploringjs.com/js/book/ch_regexps.html#syntax-character-classes>`__
         #. `45.6â€ƒSyntax: capture groups <https://exploringjs.com/js/book/ch_regexps.html#syntax-capture-groups>`__
         #. `45.7â€ƒSyntax: quantifiers <https://exploringjs.com/js/book/ch_regexps.html#syntax-quantifiers>`__
         #. `45.8â€ƒSyntax: assertions <https://exploringjs.com/js/book/ch_regexps.html#syntax-assertions>`__
         #. `45.9â€ƒSyntax: disjunction (|) <https://exploringjs.com/js/book/ch_regexps.html#syntax-disjunction>`__
         #. `45.10â€ƒRegular expression flags <https://exploringjs.com/js/book/ch_regexps.html#reg-exp-flags>`__
         #. `45.11â€ƒProperties of regular expression objects <https://exploringjs.com/js/book/ch_regexps.html#properties-of-regular-expression-objects>`__
         #. `45.12â€ƒMatch objects <https://exploringjs.com/js/book/ch_regexps.html#match-objects>`__
         #. `45.13â€ƒMethods for working with regular expressions <https://exploringjs.com/js/book/ch_regexps.html#methods-for-working-with-regular-expressions>`__
         #. `45.14â€ƒThe flags /g and /y, and the property .lastIndex (advanced) <https://exploringjs.com/js/book/ch_regexps.html#regexp-flags-gy>`__
         #. `45.15â€ƒTechniques for working with regular expressions <https://exploringjs.com/js/book/ch_regexps.html#techniques-for-working-with-regular-expressions>`__

      #. `46â€ƒDates (Date) <https://exploringjs.com/js/book/ch_dates.html#ch_dates>`__

         #. `46.1â€ƒBest practice: avoid the built-in Date <https://exploringjs.com/js/book/ch_dates.html#date-libraries>`__
         #. `46.2â€ƒTime standards <https://exploringjs.com/js/book/ch_dates.html#time-standards>`__
         #. `46.3â€ƒBackground: date time formats (ISO) <https://exploringjs.com/js/book/ch_dates.html#date-time-formats>`__
         #. `46.4â€ƒTime values <https://exploringjs.com/js/book/ch_dates.html#time-values>`__
         #. `46.5â€ƒCreating Dates <https://exploringjs.com/js/book/ch_dates.html#creating-dates>`__
         #. `46.6â€ƒGetters and setters <https://exploringjs.com/js/book/ch_dates.html#getters-and-setters>`__
         #. `46.7â€ƒConverting Dates to strings <https://exploringjs.com/js/book/ch_dates.html#converting-dates-to-strings>`__

      #. `47â€ƒCreating and parsing JSON (JSON) <https://exploringjs.com/js/book/ch_json.html#ch_json>`__

         #. `47.1â€ƒThe discovery and standardization of JSON <https://exploringjs.com/js/book/ch_json.html#the-discovery-and-standardization-of-json>`__
         #. `47.2â€ƒJSON syntax <https://exploringjs.com/js/book/ch_json.html#json-syntax>`__
         #. `47.3â€ƒUsing the JSON API <https://exploringjs.com/js/book/ch_json.html#using-the-json-api>`__
         #. `47.4â€ƒCustomizing stringification and parsing (advanced) <https://exploringjs.com/js/book/ch_json.html#json-replacers-revivers>`__
         #. `47.5â€ƒFAQ <https://exploringjs.com/js/book/ch_json.html#faq>`__

   #. `Xâ€ƒMiscellaneous topics <https://exploringjs.com/js/book/pt_misc.html#pt_misc>`__

      #. `48â€ƒNext steps: overview of web development <https://exploringjs.com/js/book/ch_next-steps.html#ch_next-steps>`__

         #. `48.1â€ƒTips against feeling overwhelmed <https://exploringjs.com/js/book/ch_next-steps.html#tips-against-feeling-overwhelmed>`__
         #. `48.2â€ƒThings worth learning for web development <https://exploringjs.com/js/book/ch_next-steps.html#things-worth-learning-for-web-development>`__
         #. `48.3â€ƒAn overview of JavaScript tools <https://exploringjs.com/js/book/ch_next-steps.html#overview-of-js-tools>`__
         #. `48.4â€ƒTools not related to JavaScript <https://exploringjs.com/js/book/ch_next-steps.html#tools-not-related-to-javascript>`__

   #. `XIâ€ƒAppendices <https://exploringjs.com/js/book/pt_appendices.html#pt_appendices>`__

      #. `Aâ€ƒIndex <https://exploringjs.com/js/book/ch_index.html#ch_index>`__




.. _ch_about-book:

1â€ƒBefore you buy the book
==========================

   #. `1.1â€ƒAbout the content <#about-the-content>`__

      #. `1.1.1â€ƒWhatâ€™s in this book? <#what-s-in-this-book>`__
      #. `1.1.2â€ƒWhat is not covered by this book? <#what-is-not-covered-by-this-book>`__

   #. `1.2â€ƒPreviewing and buying this book <#previewing-and-buying-this-book>`__

      #. `1.2.1â€ƒHow can I preview the book and its bundled material? <#how-can-i-preview-the-book-and-its-bundled-material>`__
      #. `1.2.2â€ƒHow can I buy a digital version of this book? <#how-can-i-buy-a-digital-version-of-this-book>`__
      #. `1.2.3â€ƒHow can I buy the print version of this book? <#how-can-i-buy-the-print-version-of-this-book>`__

   #. `1.3â€ƒAbout the author <#about-the-author>`__
   #. `1.4â€ƒAcknowledgements <#acknowledgements>`__

1.1â€ƒAbout the content
----------------------



.. _what-s-in-this-book:

1.1.1â€ƒWhatâ€™s in this book?
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This book makes JavaScript less challenging to learn for newcomers by offering a
   modern view that is as consistent as possible.

   Highlights:

   -  Get started quickly by initially focusing on modern features.
   -  Test-driven exercises available for most chapters.
   -  Covers all essential features of JavaScript, up to and including ES2022.
   -  Optional advanced sections let you dig deeper.

   No prior knowledge of JavaScript is required, but you should know how to
   program.

1.1.2â€ƒWhat is not covered by this book?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  Some advanced language features are not explained, but references to
      appropriate material are provided â€“ for example, to my other JavaScript books
      at `ExploringJS.com <https://exploringjs.com/>`__, which are free to read
      online.
   -  This book deliberately focuses on the language. Browser-only features, etc.
      are not described.

1.2â€ƒPreviewing and buying this book
------------------------------------

1.2.1â€ƒHow can I preview the book and its bundled material?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Go to `the homepage of this book <https://exploringjs.com/js/>`__:

   -  All chapters of this book are free to read online.
   -  Most material has free preview versions (with about 50% of their content)
      that are available at the homepage.

1.2.2â€ƒHow can I buy a digital version of this book?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The homepage of *Exploring JavaScript*
   `explains <https://exploringjs.com/js/#buy>`__ how you can buy one of its
   digital packages.

1.2.3â€ƒHow can I buy the print version of this book?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An older edition of *Exploring JavaScript* is called *JavaScript for impatient
   programmers*. Its paper version is available on Amazon.

1.3â€ƒAbout the author
---------------------

   Dr. Axel Rauschmayer specializes in JavaScript and web development. He has been
   developing web applications since 1995. In 1999, he was technical manager at a
   German internet startup that later expanded internationally. In 2006, he held
   his first talk on Ajax. In 2010, he received a PhD in Informatics from the
   University of Munich.

   Since 2011, he has been blogging about web development at 2ality.com and has
   written several books on JavaScript. He has held trainings and talks for
   companies such as eBay, Bank of America, and Oâ€™Reilly Media.

   He lives in Munich, Germany.

1.4â€ƒAcknowledgements
---------------------

   -  Cover image by `Fran Caye <http://francaye.com>`__
   -  Thanks for answering questions, discussing language topics, etc.:

      -  Allen Wirfs-Brock
      -  Benedikt Meurer
      -  Brian Terlson
      -  Daniel Ehrenberg
      -  Jordan Harband
      -  Maggie Johnson-Pint
      -  Mathias Bynens
      -  Myles Borins
      -  Rob Palmer
      -  Å ime Vidas
      -  And many others

   -  Thanks for reviewing:

      -  Johannes Weber

   `Comments <https://github.com/rauschma/exploring-js/issues/1>`__


.. _ch_faq-book:

2â€ƒFAQ: book and supplementary material
=======================================

   #. `2.1â€ƒHow to read this book <#how-to-read-this-book>`__

      #. `2.1.1â€ƒIn which order should I read the content in this book? <#order-of-reading>`__
      #. `2.1.2â€ƒWhy are some chapters and sections marked with â€œ(advanced)â€? <#why-are-some-chapters-and-sections-marked-with-advanced>`__

   #. `2.2â€ƒI own a digital version <#i-own-a-digital-version>`__

      #. `2.2.1â€ƒHow do I submit feedback and corrections? <#how-do-i-submit-feedback-and-corrections>`__
      #. `2.2.2â€ƒHow do I get updates for the downloads I bought at Payhip? <#how-do-i-get-updates-for-the-downloads-i-bought-at-payhip>`__
      #. `2.2.3â€ƒHow do I upgrade from a smaller package to a larger one or an older package to a newer one? <#how-do-i-upgrade-from-a-smaller-package-to-a-larger-one-or-an-older-package-to-a-newer-one>`__

   #. `2.3â€ƒI own the print version (â€œJavaScript for impatient programmersâ€) <#i-own-the-print-version-javascript-for-impatient-programmers>`__

      #. `2.3.1â€ƒCan I get a discount for a digital version? <#can-i-get-a-discount-for-a-digital-version>`__
      #. `2.3.2â€ƒHow do I submit feedback and corrections? <#how-do-i-submit-feedback-and-corrections-1>`__

   #. `2.4â€ƒNotations and conventions <#notations-and-conventions>`__

      #. `2.4.1â€ƒWhat is a type signature? Why am I sometimes seeing static types in this book? <#what-is-a-type-signature-why-am-i-sometimes-seeing-static-types-in-this-book>`__
      #. `2.4.2â€ƒWhat do the notes with icons mean? <#what-do-the-notes-with-icons-mean>`__

   This chapter answers questions you may have and gives tips for reading this
   book.

2.1â€ƒHow to read this book
--------------------------



.. _order-of-reading:

2.1.1â€ƒIn which order should I read the content in this book?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This book is three books in one:

   -  You can use it to get started with JavaScript as quickly as possible:

      -  Start reading with `â€œUsing JavaScript: the big pictureâ€
         (Â§8) <#ch_big-picture>`__.
      -  Skip all chapters and sections marked as â€œadvancedâ€, and all quick
         references.

   -  It gives you a comprehensive look at current JavaScript. In this â€œmodeâ€, you
      read everything and donâ€™t skip advanced content and quick references.
   -  It serves as a reference. If there is a topic that you are interested in, you
      can find information on it via the table of contents or via the index. Due to
      basic and advanced content being mixed, everything you need is usually in a
      single location.

   `Exercises <#ch_exercises>`__ play an important part in helping
   you practice and retain what you have learned.

2.1.2â€ƒWhy are some chapters and sections marked with â€œ(advanced)â€?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Several chapters and sections are marked with â€œ(advanced)â€. The idea is that you
   can initially skip them. That is, you can get a quick working knowledge of
   JavaScript by only reading the basic (non-advanced) content.

   As your knowledge evolves, you can later come back to some or all of the
   advanced content.

2.2â€ƒI own a digital version
----------------------------

2.2.1â€ƒHow do I submit feedback and corrections?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The HTML version of this book (online, or ad-free archive in the paid version)
   has a link at the end of each chapter that enables you to give feedback.

2.2.2â€ƒHow do I get updates for the downloads I bought at Payhip?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  The receipt email for the purchase includes a link. Youâ€™ll always be able to
      download the latest version of the files at that location.

   -  If you opted into emails while buying, youâ€™ll get an email whenever there is
      new content. To opt in later, you must contact Payhip (see bottom of
      ``payhip.com``).

2.2.3â€ƒHow do I upgrade from a smaller package to a larger one or an older package to a newer one?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The bookâ€™s homepage `explains <https://exploringjs.com/js/#upgrading>`__ how to
   do that.

2.3â€ƒI own the print version (â€œJavaScript for impatient programmersâ€)
---------------------------------------------------------------------

2.3.1â€ƒCan I get a discount for a digital version?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If you bought the print version, you can get a discount for a digital version.
   `The homepage <https://exploringjs.com/js/#discounts>`__ explains how.

   Alas, the reverse is not possible: you cannot get a discount for the print
   version if you bought a digital version.



.. _how-do-i-submit-feedback-and-corrections-1:

2.3.2â€ƒHow do I submit feedback and corrections?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  Before reporting an error, please go to `the online version of â€œExploring
      JavaScriptâ€ <https://exploringjs.com/js/>`__ and check the latest release of
      this book. The error may already have been corrected online.
   -  If the error is still there, you can use the comment link at the end of each
      chapter to report it.
   -  You can also use the comments to give feedback.

2.4â€ƒNotations and conventions
------------------------------

2.4.1â€ƒWhat is a type signature? Why am I sometimes seeing static types in this book?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   For example, you may see:

   .. code:: javascript
      :name: language-ts

      Number.isFinite(num: number): boolean

   That is called the *type signature* of ``Number.isFinite()``. This notation,
   especially the static types ``number`` of ``num`` and ``boolean`` of the result,
   are not real JavaScript. The notation is borrowed from the compile-to-JavaScript
   language TypeScript (which is mostly just JavaScript plus static typing).

   Why is this notation being used? It helps give you a quick idea of how a
   function works. The notation is explained in detail in `â€œTackling
   TypeScriptâ€ <https://exploringjs.com/tackling-ts/ch_typescript-essentials.html>`__,
   but is usually relatively intuitive.

2.4.2â€ƒWhat do the notes with icons mean?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**Reading instructions**

      .. container:: boxout-vspace

      Explains how to best read the content.

   .. container:: boxout

      |Icon â€œexternalâ€|â€‚**External content**

      .. container:: boxout-vspace

      Points to additional, external, content.

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Tip**

      .. container:: boxout-vspace

      Gives a tip related to the current content.

   .. container:: boxout

      |Icon â€œquestionâ€|â€‚**Question**

      .. container:: boxout-vspace

      Asks and answers a question pertinent to the current content (think FAQ).

   .. container:: boxout

      |Icon â€œwarningâ€|â€‚**Warning**

      .. container:: boxout-vspace

      Warns about pitfalls, etc.

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Details**

      .. container:: boxout-vspace

      Provides additional details, complementing the current content. It is similar
      to a footnote.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise**

      .. container:: boxout-vspace

      Mentions the path of a test-driven exercise that you can do at that point.

   `Comments <https://github.com/rauschma/exploring-js/issues/33>`__

   .. |Icon â€œreadingâ€| image:: https://exploringjs.com/js/book/icon/reading.svg
      :height: 24px
   .. |Icon â€œexternalâ€| image:: https://exploringjs.com/js/book/icon/external.svg
      :height: 24px
   .. |Icon â€œtipâ€| image:: https://exploringjs.com/js/book/icon/tip.svg
      :height: 24px
   .. |Icon â€œquestionâ€| image:: https://exploringjs.com/js/book/icon/question.svg
      :height: 24px
   .. |Icon â€œwarningâ€| image:: https://exploringjs.com/js/book/icon/warning.svg
      :height: 24px
   .. |Icon â€œdetailsâ€| image:: https://exploringjs.com/js/book/icon/details.svg
      :height: 24px
   .. |Icon â€œexerciseâ€| image:: https://exploringjs.com/js/book/icon/exercise.svg
      :height: 24px


.. _ch_why-js:

3â€ƒWhy JavaScript?
==================

   #. `3.1â€ƒThe cons of JavaScript <#the-cons-of-javascript>`__
   #. `3.2â€ƒThe pros of JavaScript <#the-pros-of-javascript>`__

      #. `3.2.1â€ƒCommunity <#community>`__
      #. `3.2.2â€ƒPractically useful <#practically-useful>`__
      #. `3.2.3â€ƒLanguage <#language>`__

   #. `3.3â€ƒPro and con of JavaScript: innovation <#pro-and-con-of-javascript-innovation>`__

   In this chapter, we examine the pros and cons of JavaScript.

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**â€œECMAScript 6â€ and â€œES6â€ refer to versions of JavaScript**

      .. container:: boxout-vspace

      ECMAScript is the name of the language standard; the number refers to the
      version of that standard. For more information, consult `â€œStandardization:
      JavaScript vs. ECMAScriptâ€ (Â§5.2) <#standardizing-javascript>`__.

3.1â€ƒThe cons of JavaScript
---------------------------

   Among programmers, JavaScript isnâ€™t always well liked. One reason is that it has
   a fair amount of quirks. Some of them are just unusual ways of doing something.
   Others are considered bugs. Either way, learning *why* JavaScript does something
   the way it does, helps with dealing with the quirks and with accepting
   JavaScript (maybe even liking it). Hopefully, this book can be of assistance
   here.

   Additionally, many traditional quirks have been eliminated now. For example:

   -  Traditionally, JavaScript variables werenâ€™t block-scoped. ES6 introduced
      ``let`` and ``const``, which let you declare block-scoped variables.
   -  Prior to ES6, implementing object factories and inheritance via ``function``
      and ``.prototype`` was clumsy. ES6 introduced classes, which provide more
      convenient syntax for these mechanisms.
   -  Traditionally, JavaScript did not have built-in modules. ES6 added them to
      the language.

   Lastly, JavaScriptâ€™s standard library is limited, but:

   -  There are `plans <https://github.com/tc39/proposal-built-in-modules>`__ for
      adding more functionality.
   -  Many libraries are easily available via `the npm software
      registry <https://www.npmjs.com>`__.

3.2â€ƒThe pros of JavaScript
---------------------------

   On the plus side, JavaScript offers many benefits.

3.2.1â€ƒCommunity
~~~~~~~~~~~~~~~~

   JavaScriptâ€™s popularity means that itâ€™s well supported and well documented.
   Whenever you create something in JavaScript, you can rely on many people being
   (potentially) interested. And there is a large pool of JavaScript programmers
   from which you can hire, if you need to.

   No single party controls JavaScript â€“ it is evolved by
   `TC39 <#tc39>`__, a committee comprising many organizations. The
   language is evolved via an open process that encourages feedback from the
   public.

3.2.2â€ƒPractically useful
~~~~~~~~~~~~~~~~~~~~~~~~~

   With JavaScript, you can write apps for many client platforms. These are a few
   example technologies:

   -  `Progressive Web Apps <https://web.dev/explore/progressive-web-apps>`__ can
      be installed natively on Android and many desktop operating systems.
   -  `Electron <https://electronjs.org>`__ lets you build cross-platform desktop
      apps.
   -  `React Native <https://reactnative.dev>`__ lets you write apps for iOS and
      Android that have native user interfaces.
   -  `Node.js <https://nodejs.org/>`__ provides extensive support for writing
      shell scripts (in addition to being a platform for web servers).

   JavaScript is supported by many server platforms and services â€“ for example:

   -  Node.js (many of the following services are based on Node.js or support its
      APIs)
   -  ZEIT Now
   -  Microsoft Azure Functions
   -  AWS Lambda
   -  Google Cloud Functions

   There are many data technologies available for JavaScript: many databases
   support it and intermediate layers (such as GraphQL) exist. Additionally, 
   `the standard data format JSON (JavaScript Object Notation) <#ch_json>`__
   is based on JavaScript and supported by its standard library.

   Lastly, many, if not most, tools for JavaScript are written in JavaScript. That
   includes IDEs, build tools, and more. As a consequence, you install them the
   same way you install your libraries and you can customize them in JavaScript.

3.2.3â€ƒLanguage
~~~~~~~~~~~~~~~

   -  Many libraries are available, via the de-facto standard in the JavaScript
      universe, `the npm software registry <https://www.npmjs.com>`__.
   -  If you are unhappy with â€œplainâ€ JavaScript, it is relatively easy to add more
      features:

      -  You can compile future and modern language features to current and past
         versions of JavaScript, via `Babel <https://babeljs.io>`__.
      -  You can add static typing, via
         `TypeScript <https://www.typescriptlang.org>`__ and
         `Flow <https://flow.org>`__.
      -  You can work with ReasonML, which is, roughly, OCaml with JavaScript
         syntax. It can be compiled to JavaScript or native code.

   -  The language is flexible: it is dynamic and supports both object-oriented
      programming and functional programming.
   -  JavaScript has become suprisingly fast for such a dynamic language.

      -  Whenever it isnâ€™t fast enough, you can switch to
         `WebAssembly <#web-assembly>`__, a universal virtual
         machine built into most JavaScript engines. It can run static code at
         nearly native speeds.

3.3â€ƒPro and con of JavaScript: innovation
------------------------------------------

   There is much innovation in the JavaScript ecosystem: new approaches to
   implementing user interfaces, new ways of optimizing the delivery of software,
   and more. The upside is that you will constantly learn new things. The downside
   is that the constant change can be exhausting at times. Thankfully, things have
   somewhat slowed down, recently: all of ES6 (which was a considerable
   modernization of the language) is becoming established, as are certain tools and
   workflows.

   `Comments <https://github.com/rauschma/exploring-js/issues/46>`__



.. _ch_nature:

4â€ƒThe nature of JavaScript
===========================

   #. `4.1â€ƒJavaScriptâ€™s influences <#javascript-s-influences>`__
   #. `4.2â€ƒThe nature of JavaScript <#the-nature-of-javascript>`__

      #. `4.2.1â€ƒJavaScript often fails silently <#silent-failures-in-js>`__

   #. `4.3â€ƒTips for getting started with JavaScript <#tips-for-getting-started-with-javascript>`__



.. _javascript-s-influences:

4.1â€ƒJavaScriptâ€™s influences
----------------------------

   When JavaScript was created in 1995, it was influenced by several programming
   languages:

   -  JavaScriptâ€™s syntax is largely based on Java.
   -  Self inspired JavaScriptâ€™s prototypal inheritance.
   -  Closures and environments were borrowed from Scheme.
   -  AWK influenced JavaScriptâ€™s functions (including the keyword ``function``).
   -  JavaScriptâ€™s strings, Arrays, and regular expressions take cues from Perl.
   -  HyperTalk inspired event handling via ``onclick`` in web browsers.

   With ECMAScript 6, new influences came to JavaScript:

   -  Generators were borrowed from Python.
   -  The syntax of arrow functions came from CoffeeScript.
   -  C++ contributed the keyword ``const``.
   -  Destructuring was inspired by Lispâ€™s *destructuring bind*.
   -  Template literals came from the E language (where they are called *quasi
      literals*).

4.2â€ƒThe nature of JavaScript
-----------------------------

   These are a few traits of the language:

   -  Its syntax is part of the C family of languages (curly braces, etc.).

   -  It is a dynamic language: most objects can be changed in various ways at
      runtime, objects can be created directly, etc.

   -  It is a dynamically typed language: variables donâ€™t have fixed static types
      and you can assign any value to a given (mutable) variable.

   -  It has functional programming features: first-class functions, closures,
      partial application via ``bind()``, etc.

   -  It has object-oriented features: mutable state, objects, inheritance,
      classes, etc.

   -  It often fails silently: see the next subsection for details.

   -  It is deployed as source code. But that source code is often *minified*
      (rewritten to require less storage). And there are `plans for a binary source
      code format <https://github.com/tc39/proposal-binary-ast>`__.

   -  JavaScript is part of the web platform â€“ it is the language built into web
      browsers. But it is also used elsewhere â€“ for example, in Node.js, for server
      things, and shell scripting.

   -  JavaScript engines often optimize less-efficient language mechanisms under
      the hood. For example, in principle, JavaScript Arrays are dictionaries. But
      under the hood, engines store Arrays contiguously if they have contiguous
      indices.



.. _silent-failures-in-js:

4.2.1â€ƒJavaScript often fails silently
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScript often fails silently. Letâ€™s look at two examples.

   First example: If the operands of an operator donâ€™t have the appropriate types,
   they are converted as necessary.

   .. code:: javascript
      :name: language-node-repl

      > '3' * '5'
      15

   Second example: If an arithmetic computation fails, you get an error value, not
   an exception.

   .. code:: javascript
      :name: language-node-repl

      > 1 / 0
      Infinity

   The reason for the silent failures is historical: JavaScript did not have
   exceptions until ECMAScript 3. Since then, its designers have tried to avoid
   silent failures.

4.3â€ƒTips for getting started with JavaScript
---------------------------------------------

   These are a few tips to help you get started with JavaScript:

   -  Take your time to really get to know this language. The conventional C-style
      syntax hides that this is a very unconventional language. Learn especially
      the quirks and the rationales behind them. Then you will understand and
      appreciate the language better.

      -  In addition to details, this book also teaches simple rules of thumb to be
         safe â€“ for example, â€œAlways use ``===`` to determine if two values are
         equal, never ``==``.â€

   -  Language tools make it easier to work with JavaScript. For example:

      -  You can statically type JavaScript via
         `TypeScript <https://www.typescriptlang.org>`__.
      -  You can check for problems and anti-patterns via linters such as
         `ESLint <https://eslint.org>`__.
      -  You can format your code automatically via code formatters such as
         `Prettier <https://prettier.io>`__.
      -  For more information on JavaScript tooling, see `â€œNext steps: overview of
         web developmentâ€ (Â§48) <#ch_next-steps>`__.

   -  Get in contact with the community:

      -  Social media services such as Mastodon are popular among JavaScript
         programmers. As a mode of communication that sits between the spoken and
         the written word, it is well suited for exchanging knowledge.
      -  Many cities have regular free meetups where people come together to learn
         topics related to JavaScript.
      -  JavaScript conferences are another convenient way of meeting other
         JavaScript programmers.

   -  Read books and blogs. Much material is free online!

   `Comments <https://github.com/rauschma/exploring-js/issues/47>`__


.. _ch_history:

5â€ƒHistory and evolution of JavaScript
======================================

   #. `5.1â€ƒHow JavaScript was created <#how-javascript-was-created>`__
   #. `5.2â€ƒStandardization: JavaScript vs. ECMAScript <#standardizing-javascript>`__
   #. `5.3â€ƒTimeline of ECMAScript versions <#timeline-of-ecmascript-versions>`__
   #. `5.4â€ƒEvolving JavaScript: TC39 (Ecma Technical CommitteeÂ 39) <#tc39>`__
   #. `5.5â€ƒThe TC39 process for proposed ECMAScript features <#tc39-process>`__

      #. `5.5.1â€ƒTip: Think in individual features and stages, not ECMAScript versions <#tip-think-in-individual-features-and-stages-not-ecmascript-versions>`__
      #. `5.5.2â€ƒThe details of the TC39 process (advanced) <#the-details-of-the-tc39-process>`__

   #. `5.6â€ƒHow to not break the web while changing JavaScript <#backward-compatibility>`__
   #. `5.7â€ƒFAQ: ECMAScript and TC39 <#faq-ecmascript-tc39>`__

      #. `5.7.1â€ƒWhere can I look up which features were added in a given ECMAScript version? <#where-can-i-look-up-which-features-were-added-in-a-given-ecmascript-version>`__
      #. `5.7.2â€ƒHow is [my favorite proposed JavaScript feature] doing? <#how-is-my-favorite-proposed-javascript-feature-doing>`__
      #. `5.7.3â€ƒWhy does stage 2.7 have such a peculiar number? <#why-does-stage-2-7-have-such-a-peculiar-number>`__

5.1â€ƒHow JavaScript was created
-------------------------------

   JavaScript was created in May 1995 in 10 days, by Brendan Eich. Eich worked at
   Netscape and implemented JavaScript for their web browser, *Netscape Navigator*.

   The idea was that major interactive parts of the client-side web were to be
   implemented in Java. JavaScript was supposed to be a glue language for those
   parts and to also make HTML slightly more interactive. Given its role of
   assisting Java, JavaScript had to look like Java. That ruled out existing
   solutions such as Perl, Python, TCL, and others.

   Initially, JavaScriptâ€™s name changed several times:

   -  Its code name was *Mocha*.
   -  In the Netscape Navigator 2.0 betas (September 1995), it was called
      *LiveScript*.
   -  In Netscape Navigator 2.0 beta 3 (December 1995), it got its final name,
      *JavaScript*.



.. _standardizing-javascript:

5.2â€ƒStandardization: JavaScript vs. ECMAScript
-----------------------------------------------

   There are two standards for JavaScript:

   -  ECMA-262 is hosted by Ecma International. It is the primary standard.
   -  ISO/IEC 16262 is hosted by the International Organization for Standardization
      (ISO) and the International Electrotechnical Commission (IEC). This is a
      secondary standard.

   The language described by these standards is called *ECMAScript*, not
   *JavaScript*. A different name was chosen because Sun (now Oracle) had a
   trademark for the latter name. The â€œECMAâ€ in â€œECMAScriptâ€ comes from the
   organization that hosts the primary standard.

   The original name of that organization was *ECMA*, an acronym for *European
   Computer Manufacturers Association*. It was later changed to *Ecma
   International* (with â€œEcmaâ€ being a proper name, not an acronym) because the
   organizationâ€™s activities had expanded beyond Europe. The initial all-caps
   acronym explains the spelling of ECMAScript.

   **Often, JavaScript and ECMAScript mean the same thing.** Sometimes the
   following distinction is made:

   -  The term *JavaScript* refers to the language and its implementations.
   -  The term *ECMAScript* refers to the language standard and language versions.

   Therefore, *ECMAScript 6* is a version of the language (its 6th edition).

5.3â€ƒTimeline of ECMAScript versions
------------------------------------

   This is a brief timeline of ECMAScript versions:

   -  `ECMAScript 1` (June 1997): First version of the standard.
   -  `ECMAScript 2` (June 1998): Small update to keep ECMA-262 in sync with the ISO
      standard.
   -  `ECMAScript 3` (December 1999): Adds many core features â€“ â€œ[â€¦] regular
      expressions, better string handling, new control statements [do-while,
      switch], try/catch exception handling, [â€¦]â€
   -  `ECMAScript 4` (abandoned in July 2008): Would have been a massive upgrade
      (with static typing, modules, namespaces, and more), but ended up being too
      ambitious and dividing the languageâ€™s stewards.
   -  `ECMAScript 5` (December 2009): Brought minor improvements â€“ a few standard
      library features and `strict mode <#strict-mode>`__.
   -  `ECMAScript 5`.1 (June 2011): Another small update to keep Ecma and ISO
      standards in sync.
   -  `ECMAScript 6` (June 2015): A large update that fulfilled many of the promises
      of `ECMAScript 4`. This version is the first one whose official name â€“
      `ECMAScript 2015` â€“ is based on the year of publication.
   -  `ECMAScript 2016` (June 2016): First yearly release. The shorter release life
      cycle resulted in fewer new features compared to the large ES6.
   -  `ECMAScript 2017` (June 2017). Second yearly release.
   -  Subsequent ECMAScript versions (ES2018, etc.) are always ratified in June.



.. _tc39:

5.4â€ƒEvolving JavaScript: TC39 (Ecma Technical CommitteeÂ 39)
------------------------------------------------------------

   TC39 is the committee that evolves JavaScript. Its members are, strictly
   speaking, companies: Adobe, Apple, Facebook, Google, Microsoft, Mozilla, Opera,
   Twitter, and others. That is, companies that are usually competitors are working
   together on JavaScript.

   Every two months, TC39 has meetings that member-appointed delegates and invited
   experts attend. The minutes of those meetings are public in `a GitHub
   repository <https://github.com/tc39/notes>`__.

   Outside of meetings, TC39 also collaborates with various members and groups of
   the JavaScript community.



.. _tc39-process:

5.5â€ƒThe TC39 process for proposed ECMAScript features
------------------------------------------------------

   With ECMAScript 6, two issues with the release process used at that time became
   obvious:

   -  If too much time passes between releases then features that are ready early,
      have to wait a long time until they can be released. And features that are
      ready late, risk being rushed to make the deadline.

   -  Features were often designed long before they were implemented and used.
      Design deficiencies related to implementation and use were therefore
      discovered too late.

   In response to these issues, TC39 instituted the new *TC39 process*:

   -  ECMAScript features are designed independently and go through six stages: a
      strawperson stage 0 and five â€œmaturityâ€ stages (1, 2, 2.7, 3, 4).
   -  Especially the later stages require prototype implementations and real-world
      testing, leading to feedback loops between designs and implementations.
   -  ECMAScript versions are released once per year and include all features that
      have reached stage 4 prior to a release deadline.

   The result: smaller, incremental releases, whose features have already been
   field-tested.

   ES2016 was the first ECMAScript version that was designed according to the TC39
   process.

5.5.1â€ƒTip: Think in individual features and stages, not ECMAScript versions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Up to and including ES6, it was most common to think about JavaScript in terms
   of ECMAScript versions â€“ for example, â€œDoes this browser support ES6 yet?â€

   Starting with ES2016, itâ€™s better to think in individual features: once a
   feature reaches stage 4, we can safely use it (if itâ€™s supported by the
   JavaScript engines we are targeting). We donâ€™t have to wait until the next
   ECMAScript release.



.. _the-details-of-the-tc39-process:

5.5.2â€ƒThe details of the TC39 process (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ECMAScript features are designed via *proposals* that go through the so-called
   *TC39 process*. That process comprises six stages:

   -  Stage 0 means a proposal has yet to enter the actual process. This is where
      most proposals start.

   -  Then the proposal goes through the five maturity stages 1, 2, 2.7, 3 and 4.
      If it reaches stage 4, it is complete and ready for inclusion in the
      ECMAScript standard.

5.5.2.1â€ƒArtifacts associated with an ECMAScript proposal
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The following artifacts are associated with an ECMAScript proposal:

   -  Proposal document: Describes the proposal to JavaScript programmers, with
      English prose and code examples. Usually the readme of a GitHub repository.

   -  Specification: Written in `Ecmarkup <https://tc39.es/ecmarkup/>`__, an HTML
      and Markdown dialect that is supported by a toolchain. That toolchain checks
      Ecmarkup and renders it to HTML with features tailored to reading
      specifications (cross-references, highlighting of variable occurrences,
      etc.).

      -  The HTML can also be printed to a PDF.
      -  If a proposal makes it to stage 4, its specification is integrated into
         the full ECMAScript specification (which is also written in Ecmarkup).

   -  Tests: Written in JavaScript that check if an implementation conforms to the
      specification.

      -  If a proposal makes it to stage 4, its tests are integrated into
         `Test262 <https://github.com/tc39/test262>`__, the official ECMAScript
         conformance test suite.

   -  Implementations: The functionality of the proposal, implemented in engines
      and transpilers (such as Babel and TypeScript).

   Each stage has entrance criteria regarding the state of the artifacts:

      ====== ========== ============== ============ ===================
      |Stage |Proposal  |Specification |Tests       |Implementations
      |0     |          |              |            |
      |1     |draft     |              |            |
      |2     |finished  |draft         |            |
      |2.7   |          |finished      |            |
      |3     |          |              |finished    |prototypes
      |4     |          |              |            |2 implementations
      ====== ========== ============== ============ ===================

5.5.2.2â€ƒRoles of the people that manage a proposal
'''''''''''''''''''''''''''''''''''''''''''''''''''

   -  Author: A proposal is written by one or more authors.
   -  Champion: Each proposal has one or more TC39 delegates that guide the
      proposal through the TC39 process. This is especially important if an author
      has no experience with the process.
   -  Reviewer: Reviewers give feedback for the specification during stage 2 and
      must sign off on it before the proposal can reach stage 2.7. They are
      appointed by TC39 (excluding the authors and champions of the proposal).
   -  Editor: Someone in charge of managing the ECMAScript specification. The
      current editors are listed `at the beginning of the ECMAScript
      specification <https://tc39.es/ecma262/>`__.

5.5.2.3â€ƒThe stages of a proposal
'''''''''''''''''''''''''''''''''

   -  Stage 0: ideation and exploration

      -  Not part of the usual advancement process. Any author can create a draft
         proposal and assign it stage 0.

   -  Stage 1: designing a solution

      -  Entrance criteria:

         -  Pick champions
         -  Repository with proposal

      -  Status:

         -  Proposal is under consideration.

   -  Stage 2: refining the solution

      -  Entrance criteria:

         -  Proposal is complete.
         -  Draft of specification.

      -  Status:

         -  Proposal is likely (but not guaranteed) to be standardized.

   -  Stage 2.7: testing and validation

      -  Entrance criteria:

         -  Specification is complete and approved by reviewers and editors.

      -  Status:

         -  The specification is finished. Itâ€™s time to validate it through tests
            and spec-compliant prototypes.
         -  No more changes, aside from issues discovered through validation.

   -  Stage 3: gaining implementation experience

      -  Entrance criteria:

         -  Tests are finished.

      -  Status:

         -  The proposal is ready to be implemented.
         -  No changes except if web incompatibilities are discovered.

   -  Stage 4: integration into draft specification and eventual inclusion in
      standard

      -  Entrance criteria:

         -  Two implementation that pass the tests
         -  Significant in-the-field experience with shipping implementations
         -  Pull request for TC39 repository, approved by editors

      -  Status:

         -  Proposed feature is complete:

            -  Its specification is ready to be included in the ECMAScript
               specification.
            -  Its tests are ready to be included in the ECMAScript conformance
               test suite Test262.

   `Figure 5.1 <#fig:tc39-process-stages>`__ illustrates the TC39 process.

   .. figure:: https://exploringjs.com/js/book/img-book/history/tc39-process-stages.svg
      name: fig:tc39-process-stages
      :width: 351px
      :height: 483px

      Figure 5.1: Each ECMAScript feature proposal goes through stages that are
      numbered from 0 to 4.

   Sources of this section:

   -  `â€œThe TC39 Processâ€ <https://tc39.es/process-document/>`__ (official document
      by TC39)
   -  `The TC39 GitHub repository
      ``how-we-work <https://github.com/tc39/how-we-work>`__, especially `the
      document that explains the work of a proposal
      champion <https://github.com/tc39/how-we-work/blob/main/champion.md>`__.
   -  `The colophon of the ECMAScript
      specification <https://tc39.es/ecma262/#sec-colophon>`__. A colophon is
      content at the end of a book. It usually contains information about the
      bookâ€™s production.



.. _backward-compatibility:

5.6â€ƒHow to not break the web while changing JavaScript
-------------------------------------------------------

   One idea that occasionally comes up is to clean up JavaScript by removing old
   features and quirks. While the appeal of that idea is obvious, it has
   significant downsides.

   Letâ€™s assume we create a new version of JavaScript that is not backward
   compatible and fixes all of its flaws. As a result, weâ€™d encounter the following
   problems:

   -  JavaScript engines become bloated: they need to support both the old and the
      new version. The same is true for tools such as IDEs and build tools.
   -  Programmers need to know, and be continually conscious of, the differences
      between the versions.
   -  We can either migrate all of an existing code base to the new version (which
      can be a lot of work). Or we can mix versions and refactoring becomes harder
      because we canâ€™t move code between versions without changing it.
   -  We somehow have to specify per piece of code â€“ be it a file or code embedded
      in a web page â€“ what version it is written in. Every conceivable solution has
      pros and cons. For example, `strict mode <#strict-mode>`__ is a
      slightly cleaner version of ES5. One of the reasons why it wasnâ€™t as popular
      as it should have been: it was a hassle to opt in via a directive at the
      beginning of a file or a function.

   So what is the solution? This is how JavaScript is evolved:

   -  New versions are always completely backward compatible (but there may
      occasionally be minor, hardly noticeable clean-ups).

   -  Old features arenâ€™t removed or fixed. Instead, better versions of them are
      introduced. One example is declaring variables via ``let`` â€“ which is an
      improved version of ``var``.

   -  If aspects of the language are changed, it is done inside new syntactic
      constructs. That is, we opt in implicitly â€“ for example:

      -  ``yield`` is only a keyword inside generators (which were introduced in
         ES6).
      -  All code inside modules and classes (both introduced in ES6) is implicitly
         in strict mode.



.. _faq-ecmascript-tc39:

5.7â€ƒFAQ: ECMAScript and TC39
-----------------------------

5.7.1â€ƒWhere can I look up which features were added in a given ECMAScript version?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   There are several places where you can look up whatâ€™s new in each ECMAScript
   version:

   -  In this book, there is `a chapter that lists whatâ€™s new in each ECMAScript
      version <#ch_new-javascript-features>`__. It
      also links to explanations.

   -  The TC39 repository has a table with `finished
      proposals <https://github.com/tc39/proposals/blob/main/finished-proposals.md>`__
      that states in which ECMAScript versions they were (or will be) introduced.

   -  `Section â€œIntroductionâ€ of the ECMAScript language
      specification <https://tc39.es/ecma262/#sec-intro>`__ lists the new features
      of each ECMAScript version.

   -  The ECMA-262 repository has `a page with releases <https://github.com/tc39/ecma262/releases>`__.

5.7.2â€ƒHow is [my favorite proposed JavaScript feature] doing?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If you are wondering what stages various proposed features are in, consult
   `the GitHub repository ``proposals <https://github.com/tc39/proposals>`__.



.. _why-does-stage-2-7-have-such-a-peculiar-number:

5.7.3â€ƒWhy does stage 2.7 have such a peculiar number?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Stage 2.7 was added in `late 2023 <https://github.com/tc39/process-document/pull/37/commits>`__, 
   after stages 0, 1, 2, 3, 4 had already been in use for years.

   -  Q: Why not renumber the stages?

      -  A: Renumbering was not in the cards because it would have made old
         documents difficult to read.

   -  Q: Why not another number such as 2.5?

      -  The .7 reflects that stage 2.7 is closer to stage 3 than to stage 2.

   -  Q: How about 3a for the new stage and 3b for the old stage 3?

      -  A: If you read â€œstage 3â€ in an old document, it can be confusing as to
         whether this refers to the new stage 3a or the new stage 3b.

   Source: `TC39 discussion on 2023-11-30 <https://github.com/tc39/notes/blob/main/meetings/2023-11/november-30.md#continuation-of-the-new-stage-discussion>`__

   `Comments <https://github.com/rauschma/exploring-js/issues/23>`__


.. _ch_new-javascript-features:

6â€ƒNew JavaScript features
==========================

   #. `6.1â€ƒNew in ECMAScript 2024 <#new-in-es2024>`__
   #. `6.2â€ƒNew in ECMAScript 2023 <#new-in-es2023>`__
   #. `6.3â€ƒNew in ECMAScript 2022 <#new-in-es2022>`__
   #. `6.4â€ƒNew in ECMAScript 2021 <#new-in-es2021>`__
   #. `6.5â€ƒNew in ECMAScript 2020 <#new-in-es2020>`__
   #. `6.6â€ƒNew in ECMAScript 2019 <#new-in-es2019>`__
   #. `6.7â€ƒNew in ECMAScript 2018 <#new-in-es2018>`__
   #. `6.8â€ƒNew in ECMAScript 2017 <#new-in-es2017>`__
   #. `6.9â€ƒNew in ECMAScript 2016 <#new-in-es2016>`__
   #. `6.10â€ƒSource of this chapter <#source-of-this-chapter>`__

   This chapter lists whatâ€™s new in recent ECMAScript versions â€“ in reverse
   chronological order. It ends before ES6 (ES2015): ES2016 was the first truly
   incremental release of ECMAScript â€“ which is why ES6 has too many features to
   list here. If you want to get a feeling for earlier releases:

   -  My book `â€œExploring ES6â€ <https://exploringjs.com/es6.html>`__ describes what
      was added in ES6 (ES2015).
   -  My book `â€œSpeaking JavaScriptâ€ <https://exploringjs.com/es5/>`__ describes
      all of the features of ES5 â€“ and is therefore a useful time capsule.



.. _new-in-es2024:

6.1â€ƒNew in ECMAScript 2024
---------------------------

   -  `Grouping synchronous
      iterables <#grouping-sync-iterables>`__:

      ``Map.groupBy()`` groups the items of an iterable into Map entries whose keys
      are provided by a callback:

      .. code:: javascript

         assert.deepEqual(
         Map.groupBy([0, -5, 3, -4, 8, 9], x => Math.sign(x)),
         new Map()
            .set(0, [0])
            .set(-1, [-5,-4])
            .set(1, [3,8,9])
         );

      There is also ``Object.groupBy()`` which produces an object instead of a Map:

      .. code:: javascript

         assert.deepEqual(
         Object.groupBy([0, -5, 3, -4, 8, 9], x => Math.sign(x)),
         {
            '0': [0],
            '-1': [-5,-4],
            '1': [3,8,9],
            __proto__: null,
         }
         );

   -  `Promise.withResolvers() <#Promise.withResolvers>`__
      provides a new way of creating Promises that we want to resolve:

      .. code:: javascript

         const { promise, resolve, reject } = Promise.withResolvers();

   -  `The new regular expression flag ``/v``
      (``.unicodeSets``) <#regexp-flag-unicode-sets>`__ enables
      these features:

      -  Escapes for Unicode string properties (ğŸ˜µâ€ğŸ’« consists of three code points):

         .. code:: javascript

            // Previously: Unicode code point property `Emoji` via /u
            assert.equal(
            /^\p{Emoji}$/u.test('ğŸ˜µâ€ğŸ’«'), false
            );
            // New: Unicode string property `RGI_Emoji` via /v
            assert.equal(
            /^\p{RGI_Emoji}$/v.test('ğŸ˜µâ€ğŸ’«'), true
            );

      -  String literals via ``\q{}`` in character classes:

         .. code:: javascript
            :name: language-node-repl

            > /^[\q{ğŸ˜µâ€ğŸ’«}]$/v.test('ğŸ˜µâ€ğŸ’«')
            true
            > /^[\q{abc|def}]$/v.test('abc')
            true

      -  Set operations for character classes:

         .. code:: javascript
            :name: language-node-repl

            > /^[\w--[a-g]]$/v.test('a')
            false
            > /^[\p{Number}--[0-9]]$/v.test('Ù£')
            true
            > /^[\p{RGI_Emoji}--\q{ğŸ˜µâ€ğŸ’«}]$/v.test('ğŸ˜µâ€ğŸ’«')
            false

      -  Improved matching with ``/i`` if a Unicode property escape is negated via
         ``[^Â·Â·Â·]``

   -  ArrayBuffers get two new features:

      -  They can be `resized <#resizing-array-buffers>`__ in
         place:

         .. code:: javascript

            const buf = new ArrayBuffer(2, {maxByteLength: 4});
            // `typedArray` starts at offset 2
            const typedArray = new Uint8Array(buf, 2);
            assert.equal(
            typedArray.length, 0
            );
            buf.resize(4);
            assert.equal(
            typedArray.length, 2
            );

      -  They get a method ``.transfer()`` for
         `transferring <#transferring-detaching-array-buffers>`__
         them.

   -  SharedArrayBuffers can be resized, but they can only grow and never shrink.
      They are not transferrable and therefore donâ€™t get the method ``.transfer()``
      that ``ArrayBuffers`` got.

   -  Two new methods help us ensure that strings are well-formed (w.r.t.
      `UTF-16 <#utf-16>`__ code units):

      -  `String method
         ``.isWellFormed() <#qref-String.prototype.isWellFormed>`__
         checks if a JavaScript string is *well-formed* and does not contain any
         `lone surrogates <#unicode-lone-surrogate>`__.
      -  `String method
         ``.toWellFormed() <#qref-String.prototype.isWellFormed>`__
         returns a copy of the receiver where each lone surrogate is replaced with
         the code unit 0xFFFD (which represents the code point with the same
         number, whose name is â€œreplacement characterâ€). The result is therefore
         well-formed.

   -  ``Atomics.waitAsync()`` lets us wait asynchronously for a change to shared
      memory. Its functionality is beyond the scope of this book. See `the MDN Web
      Docs <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/waitAsync>`__
      for more information.



.. _new-in-es2023:

6.2â€ƒNew in ECMAScript 2023
---------------------------

   -  `â€œChange Array by
      copyâ€ <#array-operations-destructive-vs-non-destructive>`__:
      Arrays and Typed Arrays get new non-destructive methods that copy receivers
      before changing them:

      -  ``.toReversed()`` is the non-destructive version of ``.reverse()``:

         .. code:: javascript

            const original = ['a', 'b', 'c'];
            const reversed = original.toReversed();
            assert.deepEqual(reversed, ['c', 'b', 'a']);
            // The original is unchanged
            assert.deepEqual(original, ['a', 'b', 'c']);

      -  ``.toSorted()`` is the non-destructive version of ``.sort()``:

         .. code:: javascript

            const original = ['c', 'a', 'b'];
            const sorted = original.toSorted();
            assert.deepEqual(sorted, ['a', 'b', 'c']);
            // The original is unchanged
            assert.deepEqual(original, ['c', 'a', 'b']);

      -  ``.toSpliced()`` is the non-destructive version of ``.splice()``:

         .. code:: javascript

            const original = ['a', 'b', 'c', 'd'];
            const spliced = original.toSpliced(1, 2, 'x');
            assert.deepEqual(spliced, ['a', 'x', 'd']);
            // The original is unchanged
            assert.deepEqual(original, ['a', 'b', 'c', 'd']);

      -  ``.with()`` is the non-destructive version of setting a value with square
         brackets:

         .. code:: javascript

            const original = ['a', 'b', 'c'];
            const updated = original.with(1, 'x');
            assert.deepEqual(updated, ['a', 'x', 'c']);
            // The original is unchanged
            assert.deepEqual(original, ['a', 'b', 'c']);

   -  â€œArray find from lastâ€: `Arrays <#ch_arrays>`__ and `Typed
      Arrays <#ch_typed-arrays>`__ get two new methods:

      -  ``.findLast()`` is similar to ``.find()`` but starts searching at the end
         of an Array:

         .. code:: javascript
            :name: language-node-repl

            > ['', 'a', 'b', ''].findLast(s => s.length > 0)
            'b'

      -  ``.findLastIndex()`` is similar to ``.findIndex()`` but starts searching
         at the end of an Array:

         .. code:: javascript
            :name: language-node-repl

            > ['', 'a', 'b', ''].findLastIndex(s => s.length > 0)
            2

   -  `Symbols as WeakMap keys <#weakmap-keys-criteria>`__: Before
      this feature, only objects could be used as keys in WeakMaps. This feature
      also lets us use symbols â€“ except for *registered symbols* (created via
      ``Symbol.for()``).

   -  `â€œHashbang grammarâ€ <#hashbang-lines>`__: JavaScript now
      ignores the first line of a file if it starts with a hash (``#``) and a bang
      (``!``). Some JavaScript runtimes, such as Node.js, have done this for a long
      time. Now it is also part of the language proper. This is an example of a
      â€œhashbangâ€ line:

      ::

         #!/usr/bin/env node



.. _new-in-es2022:

6.3â€ƒNew in ECMAScript 2022
---------------------------

   -  New members of classes:

      -  Properties (public slots) can now be created via:

         -  `Instance public fields <#instance-public-fields>`__
         -  `Static public fields <#static-public-fields>`__

      -  `Private slots <#private-slots>`__ are new and can be
         created via:

         -  Private fields (`instance private fields <#instance-private-fields>`__ 
            and `static private fields <#static-private-methods-accessors-fields>`__)
         -  Private methods and accessors (`non-static <#private-methods-accessors>`__ 
            and `static <#static-private-methods-accessors-fields>`__)

      -  `Static initialization
         blocks <#class-static-initialization-blocks>`__

   -  `Private slot checks <#private-slot-checks>`__ (â€œergonomic
      brand checks for private fieldsâ€): The following expression checks if ``obj``
      has a private slot ``#privateSlot``:

      .. code:: javascript

         #privateSlot in obj

   -  `Top-level ``await`` in modules <#top-level-await>`__: We can
      now use ``await`` at the top levels of modules and donâ€™t have to enter async
      functions or methods anymore.

   -  `error.cause <#error.cause>`__: ``Error`` and
      its subclasses now let us specify which error caused the current one:

      .. code:: javascript

         new Error('Something went wrong', {cause: otherError})

   -  `Method ``.at()`` of indexable values <#Array.prototype.at>`__
      lets us read an element at a given index (like the bracket operator ``[]``)
      and supports negative indices (unlike the bracket operator).

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'c'].at(0)
         'a'
         > ['a', 'b', 'c'].at(-1)
         'c'

      The following â€œindexableâ€ types have method ``.at()``:

      -  ``string``
      -  ``Array``
      -  All Typed Array classes: ``Uint8Array`` etc.

   -  `RegExp match indices <#regexp-match-indices>`__: If we add a
      flag to a regular expression, using it produces match objects that record the
      start and end index of each group capture.

   -  `Object.hasOwn(obj, propKey) <#Object.hasOwn>`__ provides
      a safe way to check if an object ``obj`` has an own property with the key
      ``propKey``.



.. _new-in-es2021:

6.4â€ƒNew in ECMAScript 2021
---------------------------

   -  `String.prototype.replaceAll() <#replace-replaceAll>`__
      lets us replace all matches of a regular expression or a string
      (``.replace()`` only replaces the first occurrence of a string):

      .. code:: javascript
         :name: language-node-repl

         > 'abbbaab'.replaceAll('b', 'x')
         'axxxaax'

   -  `Promise.any() <#Promise.any>`__ and
      `AggregateError <#AggregateError>`__: ``Promise.any()``
      returns a Promise that is fulfilled as soon as the first Promise in an
      iterable of Promises is fulfilled. If there are only rejections, they are put
      into an ``AggregateError`` which becomes the rejection value.

      We use ``Promise.any()`` when we are only interested in the first fulfilled
      Promise among several.

   -  `Logical assignment
      operators <#logical-assignment-operators>`__:

      .. code:: javascript

         a ||= b
         a &&= b
         a ??= b

   -  Underscores (``_``) as separators in:

      -  `Number literals <#numeric-separator-number-literals>`__:
         ``123_456.789_012``
      -  `Bigint literals <#numeric-separator-bigint-literals>`__:
         ``6_000_000_000_000_000_000_000_000n``

   -  WeakRefs: This feature is beyond the scope of this book. `Quoting its
      proposal <https://github.com/tc39/proposal-weakrefs>`__ states:

      -  [This proposal] encompasses two major new pieces of functionality:

         -  Creating weak references to objects with the ``WeakRef`` class
         -  Running user-defined finalizers after objects are garbage-collected,
            with the ``FinalizationRegistry`` class

      -  Their correct use takes careful thought, and they are best avoided if
         possible.

   -  ``Array.prototype.sort`` has been stable since ES2019. In ES2021, â€œ[it] was
      made more precise, reducing the amount of cases that result in an
      implementation-defined sort orderâ€
      [`source <https://tc39.es/ecma262/#sec-intro>`__]. For more information, see
      `the pull request for this improvement <https://github.com/tc39/ecma262/pull/1585>`__.



.. _new-in-es2020:

6.5â€ƒNew in ECMAScript 2020
---------------------------

   -  New module features:

      -  `Dynamic imports via ``import() <#dynamic-imports>`__:
         The normal ``import`` statement is static: We can only use it at the top
         levels of modules and its module specifier is a fixed string. ``import()``
         changes that. It can be used anywhere (including conditional statements)
         and we can compute its argument.

      -  `import.meta <#import.meta>`__ contains metadata for
         the current module. Its first widely supported property is
         ``import.meta.url`` which contains a string with the URL of the current
         moduleâ€™s file.

      -  `Namespace re-exporting <#cheat-sheet-modules>`__: The
         following expression imports all exports of module ``'mod'`` in a
         namespace object ``ns`` and exports that object.

         .. code:: javascript

            export * as ns from 'mod';

   -  `Optional chaining for property accesses and method calls <#optional-chaining>`__. 
      One example of optional chaining is:

      .. code:: javascript

         value?.prop

      This expression evaluates to ``undefined`` if ``value`` is either
      ``undefined`` or ``null``. Otherwise, it evaluates to ``value.prop``. This
      feature is especially useful in chains of property reads when some of the
      properties may be missing.

   -  `Nullish coalescing operator
      (``??``) <#nullish-coalescing-operator>`__:

      .. code:: javascript

         value ?? defaultValue

      This expression is ``defaultValue`` if ``value`` is either ``undefined`` or
      ``null`` and ``value`` otherwise. This operator lets us use a default value
      whenever something is missing.

      Previously the Logical Or operator (``||``) was used in this case but it has
      downsides here because it returns the default value whenever the left-hand
      side is falsy (which isnâ€™t always correct).

   -  `Bigints â€“ arbitrary-precision integers <#ch_bigints>`__:
      Bigints are a new primitive type. It supports integer numbers that can be
      arbitrarily large (storage for them grows as necessary).

   -  `String.prototype.matchAll() <#String.prototype.matchAll>`__:
      This method throws if flag ``/g`` isnâ€™t set and returns an iterable with all
      match objects for a given string.

   -  `Promise.allSettled() <#Promise.allSettled>`__ receives
      an iterable of Promises. It returns a Promise that is fulfilled once all the
      input Promises are settled. The fulfillment value is an Array with one object
      per input Promise â€“ either one of:

      -  ``{ status: 'fulfilled', value: Â«fulfillment valueÂ» }``
      -  ``{ status: 'rejected', reason: Â«rejection valueÂ» }``

   -  `globalThis <#globalThis>`__ provides a way
      to access the global object that works both on browsers and server-side
      platforms such as Node.js and Deno.

   -  ``for-in`` mechanics: This feature is beyond the scope of this book. For more
      information on it, see `its
      proposal <https://github.com/tc39/proposal-for-in-order>`__.

   -  `Namespace re-exporting <#re-exporting>`__:

      .. code:: javascript

         export * as ns from './internal.mjs';



.. _new-in-es2019:

6.6â€ƒNew in ECMAScript 2019
---------------------------

   -  Array method `.flatMap() <#Array.prototype.flatMap>`__
      works like ``.map()`` but lets the callback return Arrays of zero or more
      values instead of single values. The returned Arrays are then concatenated
      and become the result of ``.flatMap()``. Use cases include:

      -  Filtering and mapping at the same time
      -  Mapping single input values to multiple output values

   -  Array method `.flat() <#qref-Array.prototype.flat>`__
      converts nested Arrays into flat Arrays. Optionally, we can tell it at which
      depth of nesting it should stop flattening.

   -  `Object.fromEntries() <#Object.fromEntries>`__ creates an
      object from an iterable over *entries*. Each entry is a two-element Array
      with a property key and a property value.

   -  String methods:
      `.trimStart() <#qref-String.prototype.trimStart>`__ and
      `.trimEnd() <#qref-String.prototype.trimEnd>`__ work like
      ``.trim()`` but remove whitespace only at the start or only at the end of a
      string.

   -  `Optional ``catch``
      binding <#omitting-catch-binding>`__: We can now
      omit the parameter of a ``catch`` clause if we donâ€™t use it.

   -  `Symbol.prototype.description <#symbol-descriptions>`__ is
      a getter for reading the description of a symbol. Previously, the description
      was included in the result of ``.toString()`` but couldnâ€™t be accessed
      individually.

   -  ``.sort()`` for Arrays and Typed Arrays is now guaranteed to be *stable*: If
      elements are considered equal by sorting, then sorting does not change the
      order of those elements (relative to each other).

   These ES2019 features are beyond the scope of this book:

   -  JSON superset: See `2ality blog
      post <https://2ality.com/2019/01/json-superset.html>`__.
   -  Well-formed ``JSON.stringify()``: See `2ality blog
      post <https://2ality.com/2019/01/well-formed-stringify.html>`__.
   -  ``Function.prototype.toString()`` revision: See `2ality blog
      post <https://2ality.com/2016/08/function-prototype-tostring.html>`__.



.. _new-in-es2018:

6.7â€ƒNew in ECMAScript 2018
---------------------------

   -  `Asynchronous iteration <#ch_async-iteration>`__ is
      the asynchronous version of synchronous iteration. It is based on Promises:

      -  With synchronous iterables, we can immediately access each item. With
         asynchronous iterables, we have to ``await`` before we can access an item.
      -  With synchronous iterables, we use ``for-of`` loops. With asynchronous
         iterables, we use ``for-await-of`` loops.

   -  `Spreading into object
      literals <#spreading-into-object-literals>`__: By using
      spreading (``...``) inside an object literal, we can copy the properties of
      another object into the current one. One use case is to create a shallow copy
      of an object ``obj``:

      .. code:: javascript

         const shallowCopy = {...obj};

   -  `Rest properties (destructuring) <#rest-properties>`__:
      When object-destructuring a value, we can now use rest syntax (``...``) to
      get all previously unmentioned properties in an object.

      .. code:: javascript

         const {a, ...remaining} = {a: 1, b: 2, c: 3};
         assert.deepEqual(remaining, {b: 2, c: 3});

   -  `Promise.prototype.finally() <#Promise.prototype.finally>`__
      is related to the ``finally`` clause of a try-catch-finally statement â€“
      similarly to how the Promise method ``.then()`` is related to the ``try``
      clause and ``.catch()`` is related to the ``catch`` clause.

      On other words: The callback of ``.finally()`` is executed regardless of
      whether a Promise is fulfilled or rejected.

   -  New Regular expression features:

      -  `RegExp`` named capture
         groups <#named-capture-groups>`__: In addition to accessing
         groups by number, we can now name them and access them by name:

         .. code:: javascript

            const matchObj = '---756---'.match(/(?<digits>[0-9]+)/)
            assert.equal(matchObj.groups.digits, '756');

      -  `RegExp`` lookbehind
         assertions <#regexp-lookbehind-assertions>`__ complement
         lookahead assertions:

         -  Positive lookbehind: ``(?<=X)`` matches if the current location is
            preceded by ``'X'``.
         -  Negative lookbehind: ``(?<!X)`` matches if the current location is not
            preceded by ``'(?<!X)'``.

      -  `s`` (``dotAll``) flag for regular
         expressions <#regexp-dot-all-flag>`__. If this flag is
         active, the dot matches line terminators (by default, it doesnâ€™t).

      -  `RegExp`` Unicode property
         escapes <#unicode-character-property-escapes>`__ give us
         more power when matching sets of Unicode code points â€“ for example:

         .. code:: javascript
            :name: language-node-repl

            > /^\p{Lowercase_Letter}+$/u.test('aÃ¼Ï€')
            true
            > /^\p{White_Space}+$/u.test('\n \t')
            true
            > /^\p{Script=Greek}+$/u.test('Î©Î”Î¨')
            true

   -  `Template literal revision <#template-strings-cooked-vs-raw>`__ allows
      text with backslashes in tagged templates that is illegal in string literals
      â€“ for example:

      ::

         windowsPath`C:\uuu\xxx\111`
         latex`\unicode`



.. _new-in-es2017:

6.8â€ƒNew in ECMAScript 2017
---------------------------

   -  `Async functions
      (``async/await``) <#ch_async-functions>`__ let us use
      synchronous-looking syntax to write asynchronous code.

   -  `Object.values() <#Object.values>`__ returns an Array with
      the values of all enumerable string-keyed properties of a given object.

   -  `Object.entries() <#Object.entries>`__ returns an Array
      with the key-value pairs of all enumerable string-keyed properties of a given
      object. Each pair is encoded as a two-element Array.

   -  String padding: The string methods
      `.padStart() <#qref-String.prototype.padStart>`__ and
      `.padEnd() <#qref-String.prototype.padEnd>`__ insert
      padding text until the receivers are long enough:

      .. code:: javascript
         :name: language-node-repl

         > '7'.padStart(3, '0')
         '007'
         > 'yes'.padEnd(6, '!')
         'yes!!!'

   -  `Trailing commas in function parameter lists and
      calls <#trailing-commas-parameters>`__: Trailing commas have
      been allowed in Arrays literals since ES3 and in Object literals since ES5.
      They are now also allowed in function calls and method calls.

   -  `Object.getOwnPropertyDescriptors() <#qref-Object.getOwnPropertyDescriptors>`__
      lets us define properties via an object with property descriptors:

   -  The feature â€œShared memory and atomicsâ€ is beyond the scope of this book. For
      more information on it, see:

      -  The documentation on
         `SharedArrayBuffer <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer>`__
         and
         `Atomics <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics>`__
         on MDN Web Docs
      -  `The ECMAScript proposal â€œShared memory and
         atomicsâ€ <https://github.com/tc39/proposal-ecmascript-sharedmem>`__



.. _new-in-es2016:

6.9â€ƒNew in ECMAScript 2016
---------------------------

   -  `Array.prototype.includes() <#qref-Array.prototype.includes>`__
      checks if an Array contains a given value.

   -  `Exponentiation operator
      (``**``) <#binary-arithmetic-operators>`__:

      .. code:: javascript
         :name: language-node-repl

         > 4 ** 2
         16

6.10â€ƒSource of this chapter
----------------------------

   ECMAScript feature lists were taken from `the TC39 page on finished
   proposals <https://github.com/tc39/proposals/blob/main/finished-proposals.md>`__.

   `Comments <https://github.com/rauschma/exploring-js/issues/52>`__


.. _ch_faq-language:

7â€ƒFAQ: JavaScript
==================

   #. `7.1â€ƒWhat are good references for JavaScript? <#what-are-good-references-for-javascript>`__
   #. `7.2â€ƒHow do I find out what JavaScript features are supported where? <#how-do-i-find-out-what-javascript-features-are-supported-where>`__
   #. `7.3â€ƒWhere can I look up what features are planned for JavaScript? <#where-can-i-look-up-what-features-are-planned-for-javascript>`__
   #. `7.4â€ƒWhy does JavaScript fail silently so often? <#why-does-javascript-fail-silently-so-often>`__
   #. `7.5â€ƒWhy canâ€™t we clean up JavaScript, by removing quirks and outdated features? <#why-can-t-we-clean-up-javascript-by-removing-quirks-and-outdated-features>`__
   #. `7.6â€ƒHow can I quickly try out a piece of JavaScript code? <#how-can-i-quickly-try-out-a-piece-of-javascript-code>`__

7.1â€ƒWhat are good references for JavaScript?
---------------------------------------------

   Please see `â€œJavaScript referencesâ€ (Â§8.3) <#javascript-references>`__.

7.2â€ƒHow do I find out what JavaScript features are supported where?
--------------------------------------------------------------------

   This book usually mentions if a feature is part of ECMAScript 5 (as required by
   older browsers) or a newer version. For more detailed information (including
   pre-ES5 versions), there are several good compatibility tables available online:

   -  Mozillaâ€™s `MDN web docs <https://developer.mozilla.org/en-US/docs/Web/JavaScript>`__ 
      have tables for each feature that describe relevant ECMAScript versions 
      and browser support.
   -  `â€œCan I useâ€¦â€ <https://caniuse.com/>`__ documents what features (including
      JavaScript language features) are supported by web browsers.
   -  `ECMAScript compatibility tables for various
      engines <https://compat-table.github.io/compat-table/es6/>`__
   -  `Node.js compatibility tables <https://node.green>`__

7.3â€ƒWhere can I look up what features are planned for JavaScript?
------------------------------------------------------------------

   Please see the following sources:

   -  `â€œThe TC39 process for proposed ECMAScript featuresâ€
      (Â§5.5) <#tc39-process>`__
   -  `â€œFAQ: ECMAScript and TC39â€ (Â§5.7) <#faq-ecmascript-tc39>`__

7.4â€ƒWhy does JavaScript fail silently so often?
------------------------------------------------

   JavaScript often fails silently. Letâ€™s look at two examples.

   First example: If the operands of an operator donâ€™t have the appropriate types,
   they are converted as necessary.

   .. code:: javascript
      :name: language-node-repl

      > '3' * '5'
      15

   Second example: If an arithmetic computation fails, you get an error value, not
   an exception.

   .. code:: javascript
      :name: language-node-repl

      > 1 / 0
      Infinity

   The reason for the silent failures is historical: JavaScript did not have
   exceptions until ECMAScript 3. Since then, its designers have tried to avoid
   silent failures.



.. _why-can-t-we-clean-up-javascript-by-removing-quirks-and-outdated-features:

7.5â€ƒWhy canâ€™t we clean up JavaScript, by removing quirks and outdated features?
--------------------------------------------------------------------------------

   This question is answered in `â€œHow to not break the web while changing
   JavaScriptâ€ (Â§5.6) <#backward-compatibility>`__.

7.6â€ƒHow can I quickly try out a piece of JavaScript code?
----------------------------------------------------------

   `â€œTrying out JavaScript codeâ€ (Â§10.1) <#trying-out-code>`__
   explains how to do that.

   `Comments <https://github.com/rauschma/exploring-js/issues/24>`__



.. _ch_big-picture:

8â€ƒUsing JavaScript: the big picture
====================================

   #. `8.1â€ƒWhat are you learning in this book? <#what-are-you-learning-in-this-book>`__
   #. `8.2â€ƒThe structure of browsers and Node.js <#the-structure-of-browsers-and-node-js>`__
   #. `8.3â€ƒJavaScript references <#javascript-references>`__
   #. `8.4â€ƒFurther reading <#further-reading>`__

   In this chapter, Iâ€™d like to paint the big picture: what are you learning in
   this book, and how does it fit into the overall landscape of web development?

8.1â€ƒWhat are you learning in this book?
----------------------------------------

   This book teaches the JavaScript language. It focuses on just the language, but
   offers occasional glimpses at two platforms where JavaScript can be used:

   -  Web browser
   -  Node.js

   Node.js is important for web development in three ways:

   -  You can use it to write server-side software in JavaScript.
   -  You can also use it to write software for the command line (think Unix shell,
      Windows PowerShell, etc.). Many JavaScript-related tools are based on (and
      executed via) Node.js.
   -  Nodeâ€™s software registry, npm, has become the dominant way of installing
      tools (such as compilers and build tools) and libraries â€“ even for
      client-side development.



.. _the-structure-of-browsers-and-node-js:

8.2â€ƒThe structure of browsers and Node.js
------------------------------------------

   .. figure:: https://exploringjs.com/js/book/img-book/big-picture/javascript-platforms.svg
      name: fig:javascript-platforms
      :width: 257px
      :height: 97px

      Figure 8.1: The structure of the two JavaScript platforms *web browser* and
      *Node.js*. The APIs â€œstandard libraryâ€ and â€œplatform APIâ€ are hosted on top
      of a foundational layer with a JavaScript engine and a platform-specific
      â€œcoreâ€.

   The structures of the two JavaScript platforms *web browser* and *Node.js* are
   similar (`figure 8.1 <#fig:javascript-platforms>`__):

   -  The foundational layer consists of the JavaScript engine and
      platform-specific â€œcoreâ€ functionality.
   -  Two APIs are hosted on top of this foundation:

      -  The JavaScript standard library is part of JavaScript proper and runs on
         top of the engine.
      -  The platform API are also available from JavaScript â€“ it provides access
         to platform-specific functionality. For example:

         -  In browsers, you need to use the platform-specific API if you want to
            do anything related to the user interface: react to mouse clicks, play
            sounds, etc.
         -  In Node.js, the platform-specific API lets you read and write files,
            download data via HTTP, etc.

8.3â€ƒJavaScript references
--------------------------

   If you have a question about JavaScript, I can recommend the following online
   resources:

   -  `MDN Web Docs <https://developer.mozilla.org/en-US/>`__: cover various web
      technologies such as CSS, HTML, JavaScript, and more. An excellent reference.
   -  `Node.js Docs <https://nodejs.org/docs/latest/api/>`__: document the Node.js
      API.
   -  `ExploringJS.com <https://exploringjs.com>`__: My other books cover various
      aspects of web development:

      -  `â€œDeep JavaScript: Theory and
         techniquesâ€ <https://exploringjs.com/deep-js/>`__ describes JavaScript at
         a level of detail that is beyond the scope of â€œExploring JavaScriptâ€.
      -  `â€œTackling TypeScript: Upgrading from
         JavaScriptâ€ <https://exploringjs.com/tackling-ts/>`__
      -  `â€œShell scripting with
         Node.jsâ€ <https://exploringjs.com/nodejs-shell-scripting/>`__

8.4â€ƒFurther reading
--------------------

   -  `â€œNext steps: overview of web developmentâ€ (Â§48) <#ch_next-steps>`__ 
      provides a more comprehensive look at web development.

   `Comments <https://github.com/rauschma/exploring-js/issues/32>`__


.. _ch_syntax:

9â€ƒSyntax
=========

   #. `9.1â€ƒAn overview of JavaScriptâ€™s syntax <#an-overview-of-javascript-s-syntax>`__

      #. `9.1.1â€ƒBasic constructs <#basic-constructs>`__
      #. `9.1.2â€ƒModules <#modules>`__
      #. `9.1.3â€ƒClasses <#classes>`__
      #. `9.1.4â€ƒException handling <#exception-handling>`__
      #. `9.1.5â€ƒLegal variable and property names <#legal-variable-and-property-names>`__
      #. `9.1.6â€ƒCasing styles <#casing-styles>`__
      #. `9.1.7â€ƒCapitalization of names <#capitalization-of-names>`__
      #. `9.1.8â€ƒMore naming conventions <#more-naming-conventions>`__
      #. `9.1.9â€ƒWhere to put semicolons? <#where-to-put-semicolons>`__

   #. `9.2â€ƒ(Advanced) <#advanced>`__
   #. `9.3â€ƒHashbang lines (Unix shell scripts) <#hashbang-lines>`__
   #. `9.4â€ƒIdentifiers <#identifiers>`__

      #. `9.4.1â€ƒValid identifiers (variable names, etc.) <#valid-identifiers-variable-names-etc>`__
      #. `9.4.2â€ƒReserved words <#reserved-words>`__

   #. `9.5â€ƒStatement vs. expression <#statement-vs-expression>`__

      #. `9.5.1â€ƒStatements <#statements>`__
      #. `9.5.2â€ƒExpressions <#expressions>`__
      #. `9.5.3â€ƒWhat is allowed where? <#what-is-allowed-where>`__

   #. `9.6â€ƒAmbiguous syntax <#ambiguous-syntax>`__

      #. `9.6.1â€ƒSame syntax: function declaration and function expression <#same-syntax-function-declaration-and-function-expression>`__
      #. `9.6.2â€ƒSame syntax: object literal and block <#same-syntax-object-literal-and-block>`__
      #. `9.6.3â€ƒDisambiguation <#disambiguation>`__

   #. `9.7â€ƒSemicolons <#semicolons>`__

      #. `9.7.1â€ƒRule of thumb for semicolons <#rule-of-thumb-for-semicolons>`__
      #. `9.7.2â€ƒSemicolons: control statements <#semicolons-control-statements>`__

   #. `9.8â€ƒAutomatic semicolon insertion (ASI) <#automatic-semicolon-insertion-asi>`__

      #. `9.8.1â€ƒASI triggered unexpectedly <#asi-triggered-unexpectedly>`__
      #. `9.8.2â€ƒASI unexpectedly not triggered <#asi-unexpectedly-not-triggered>`__

   #. `9.9â€ƒSemicolons: best practices <#semicolons-best-practices>`__
   #. `9.10â€ƒStrict mode vs. sloppy mode <#strict-mode>`__

      #. `9.10.1â€ƒSwitching on strict mode <#switching-on-strict-mode>`__
      #. `9.10.2â€ƒImprovements in strict mode <#improvements-in-strict-mode>`__



.. _an-overview-of-javascript-s-syntax:

9.1â€ƒAn overview of JavaScriptâ€™s syntax
---------------------------------------

   This is a very first look at JavaScriptâ€™s syntax. Donâ€™t worry if some things
   donâ€™t make sense, yet. They will all be explained in more detail later in this
   book.

   This overview is not exhaustive, either. It focuses on the essentials.

9.1.1â€ƒBasic constructs
~~~~~~~~~~~~~~~~~~~~~~~

9.1.1.1â€ƒComments
'''''''''''''''''

   .. code:: javascript

      // single-line comment

      /*
      Comment with
      multiple lines
      */

9.1.1.2â€ƒPrimitive (atomic) values
''''''''''''''''''''''''''''''''''

   **Booleans:**

   .. code:: javascript

      true
      false

   **Numbers:**

   .. code:: javascript

      1.141
      -123

   The basic number type is used for both floating point numbers (doubles) and
   integers.

   **Bigints:**

   .. code:: javascript

      17n
      -49n

   The basic number type can only properly represent integers within a range of 53
   bits plus sign. Bigints can grow arbitrarily large in size.

   **Strings:**

   .. code:: javascript

      'abc'
      "abc"
      `String with interpolated values: ${256} and ${true}`

   JavaScript has no extra type for characters. It uses strings to represent them.

9.1.1.3â€ƒAssertions
'''''''''''''''''''

   An *assertion* describes what the result of a computation is expected to look
   like and throws an exception if those expectations arenâ€™t correct. For example,
   the following assertion states that the result of the computation 7 plus 1 must
   be 8:

   .. code:: javascript

      assert.equal(7 + 1, 8);

   ``assert.equal()`` is a method call (the object is ``assert``, the method is
   ``.equal()``) with two arguments: the actual result and the expected result. It
   is part of a Node.js assertion API that is explained `later in this
   book <#ch_assertion-api>`__.

   There is also ``assert.deepEqual()`` that compares objects deeply.

9.1.1.4â€ƒLogging to the console
'''''''''''''''''''''''''''''''

   Logging to `the console <#browser-consoles>`__ of a browser or
   Node.js:

   .. code:: javascript

      // Printing a value to standard out (another method call)
      console.log('Hello!');

      // Printing error information to standard error
      console.error('Something went wrong!');

9.1.1.5â€ƒOperators
''''''''''''''''''

   .. code:: javascript

      // Operators for booleans
      assert.equal(true && false, false); // And
      assert.equal(true || false, true); // Or

      // Operators for numbers
      assert.equal(3 + 4, 7);
      assert.equal(5 - 1, 4);
      assert.equal(3 * 4, 12);
      assert.equal(10 / 4, 2.5);

      // Operators for bigints
      assert.equal(3n + 4n, 7n);
      assert.equal(5n - 1n, 4n);
      assert.equal(3n * 4n, 12n);
      assert.equal(10n / 4n, 2n);

      // Operators for strings
      assert.equal('a' + 'b', 'ab');
      assert.equal('I see ' + 3 + ' monkeys', 'I see 3 monkeys');

      // Comparison operators
      assert.equal(3 < 4, true);
      assert.equal(3 <= 4, true);
      assert.equal('abc' === 'abc', true);
      assert.equal('abc' !== 'def', true);

   JavaScript also has a ``==`` comparison operator. I recommend to avoid it â€“ why
   is explained in `â€œRecommendation: always use strict equalityâ€
   (Â§15.4.3) <#recommendation-always-strict-equality>`__.

9.1.1.6â€ƒDeclaring variables
''''''''''''''''''''''''''''

   ``const`` creates *immutable variable bindings*: Each variable must be
   initialized immediately and we canâ€™t assign a different value later. However,
   the value itself may be mutable and we may be able to change its contents. In
   other words: ``const`` does not make values immutable.

   .. code:: javascript

      // Declaring and initializing x (immutable binding):
      const x = 8;

      // Would cause a TypeError:
      // x = 9;

   ``let`` creates *mutable variable bindings*:

   .. code:: javascript

      // Declaring y (mutable binding):
      let y;

      // We can assign a different value to y:
      y = 3 * 5;

      // Declaring and initializing z:
      let z = 3 * 5;

9.1.1.7â€ƒOrdinary function declarations
'''''''''''''''''''''''''''''''''''''''

   .. code:: javascript

      // add1() has the parameters a and b
      function add1(a, b) {
      return a + b;
      }
      // Calling function add1()
      assert.equal(add1(5, 2), 7);

9.1.1.8â€ƒArrow function expressions
'''''''''''''''''''''''''''''''''''

   Arrow function expressions are used especially as arguments of function calls
   and method calls:

   .. code:: javascript

      const add2 = (a, b) => { return a + b };
      // Calling function add2()
      assert.equal(add2(5, 2), 7);

      // Equivalent to add2:
      const add3 = (a, b) => a + b;

   The previous code contains the following two arrow functions (the terms
   *expression* and *statement* are explained `later in this
   chapter <#statement-vs-expression>`__):

   .. code:: javascript

      // An arrow function whose body is a code block
      (a, b) => { return a + b }

      // An arrow function whose body is an expression
      (a, b) => a + b

9.1.1.9â€ƒPlain objects
''''''''''''''''''''''

   .. code:: javascript

      // Creating a plain object via an object literal
      const obj = {
      first: 'Jane', // property
      last: 'Doe', // property
      getFullName() { // property (method)
         return this.first + ' ' + this.last;
      },
      };

      // Getting a property value
      assert.equal(obj.first, 'Jane');
      // Setting a property value
      obj.first = 'Janey';

      // Calling the method
      assert.equal(obj.getFullName(), 'Janey Doe');

9.1.1.10â€ƒArrays
''''''''''''''''

   .. code:: javascript

      // Creating an Array via an Array literal
      const arr = ['a', 'b', 'c'];
      assert.equal(arr.length, 3);

      // Getting an Array element
      assert.equal(arr[1], 'b');
      // Setting an Array element
      arr[1] = 'Î²';

      // Adding an element to an Array:
      arr.push('d');

      assert.deepEqual(
      arr, ['a', 'Î²', 'c', 'd']);

9.1.1.11â€ƒControl flow statements
'''''''''''''''''''''''''''''''''

   Conditional statement:

   .. code:: javascript

      if (x < 0) {
      x = -x;
      }

   ``for-of`` loop:

   .. code:: javascript

      const arr = ['a', 'b'];
      for (const element of arr) {
      console.log(element);
      }

   Output:

   ::

      a
      b

9.1.2â€ƒModules
~~~~~~~~~~~~~~

   Each module is a single file. Consider, for example, the following two files
   with modules in them:

   .. code:: language-txt

      file-tools.mjs
      main.mjs

   The module in ``file-tools.mjs`` exports its function ``isTextFilePath()``:

   .. code:: javascript

      export function isTextFilePath(filePath) {
      return filePath.endsWith('.txt');
      }

   The module in ``main.mjs`` imports the whole module ``path`` and the function
   ``isTextFilePath()``:

   .. code:: javascript

      // Import whole module as namespace object `path`
      import * as path from 'node:path';
      // Import a single export of module file-tools.mjs
      import {isTextFilePath} from './file-tools.mjs';

9.1.3â€ƒClasses
~~~~~~~~~~~~~~

   .. code:: javascript

      class Person {
      constructor(name) {
         this.name = name;
      }
      describe() {
         return `Person named ${this.name}`;
      }
      static logNames(persons) {
         for (const person of persons) {
            console.log(person.name);
         }
      }
      }

      class Employee extends Person {
      constructor(name, title) {
         super(name);
         this.title = title;
      }
      describe() {
         return super.describe() +
            ` (${this.title})`;
      }
      }

      const jane = new Employee('Jane', 'CTO');
      assert.equal(
      jane.describe(),
      'Person named Jane (CTO)');

9.1.4â€ƒException handling
~~~~~~~~~~~~~~~~~~~~~~~~~

   .. code:: javascript

      function throwsException() {
      throw new Error('Problem!');
      }

      function catchesException() {
      try {
         throwsException();
      } catch (err) {
         assert.ok(err instanceof Error);
         assert.equal(err.message, 'Problem!');
      }
      }

   Note:

   -  ``try-finally`` and ``try-catch-finally`` are also supported.
   -  We can throw any value, but features such as stack traces are only supported
      by ``Error`` and its subclasses.

9.1.5â€ƒLegal variable and property names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The grammatical category of variable names and property names is called
   *identifier*.

   Identifiers are allowed to have the following characters:

   -  Unicode letters: ``A``â€“``Z``, ``a``â€“``z`` (etc.)
   -  ``$``, ``_``
   -  Unicode digits: ``0``â€“``9`` (etc.)

      -  Variable names canâ€™t start with a digit

   Some words have special meaning in JavaScript and are called *reserved*.
   Examples include: ``if``, ``true``, ``const``.

   Reserved words canâ€™t be used as variable names:

   .. code:: javascript

      const if = 123;
      // SyntaxError: Unexpected token if

   But they are allowed as names of properties:

   .. code:: javascript
      :name: language-node-repl

      > const obj = { if: 123 };
      > obj.if
      123

9.1.6â€ƒCasing styles
~~~~~~~~~~~~~~~~~~~~

   Common casing styles for concatenating words are:

   -  Camel case: ``threeConcatenatedWords``
   -  Underscore case (also called *snake case*): ``three_concatenated_words``
   -  Dash case (also called *kebab case*): ``three-concatenated-words``

9.1.7â€ƒCapitalization of names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In general, JavaScript uses camel case, except for constants.

   Lowercase:

   -  Functions, variables: ``myFunction``

   -  Methods: ``obj.myMethod``

   -  CSS:

      -  CSS names: ``my-utility-class`` (dash case)
      -  Corresponding JavaScript names: ``myUtilityClass``

   -  Module file names are usually dash-cased:

      .. code:: javascript

         import * as theSpecialLibrary from './the-special-library.mjs';

   Uppercase:

   -  Classes: ``MyClass``

   All-caps:

   -  Constants (as shared between modules etc.): ``MY_CONSTANT`` (underscore case)

9.1.8â€ƒMore naming conventions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following naming conventions are popular in JavaScript.

   If the name of a parameter starts with an underscore (or is an underscore) it
   means that this parameter is not used â€“ for example:

   .. code:: javascript

      arr.map((_x, i) => i)

   If the name of a property of an object starts with an underscore then that
   property is considered private:

   .. code:: javascript

      class ValueWrapper {
      constructor(value) {
         this._value = value;
      }
      }

9.1.9â€ƒWhere to put semicolons?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   At the end of a statement:

   .. code:: javascript

      const x = 123;
      func();

   But not if that statement ends with a curly brace:

   .. code:: javascript

      while (false) {
      // Â·Â·Â·
      } // no semicolon

      function func() {
      // Â·Â·Â·
      } // no semicolon

   However, adding a semicolon after such a statement is not a syntax error â€“ it is
   interpreted as an empty statement:

   .. code:: javascript

      // Function declaration followed by empty statement:
      function func() {
      // Â·Â·Â·
      };

9.2â€ƒ(Advanced)
---------------

   All remaining sections of this chapter are advanced.



.. _hashbang-lines:

9.3â€ƒHashbang lines (Unix shell scripts)
----------------------------------------

   In a Unix shell script, we can add a first line that starts with ``#!`` to tell
   Unix which executable should be used to run the script. These two characters
   have several names, including *hashbang*, *sharp-exclamation*, *sha-bang* (â€œshaâ€
   as in â€œsharpâ€) and *shebang*. Otherwise, hashbang lines are treated as comments
   by most shell scripting languages and JavaScript does so, too. This is a common
   hashbang line for Node.js:

   ::

      #!/usr/bin/env node

   If we want to pass arguments to ``node``, we have to use the ``env`` option
   ``-S`` (to be safe, some Unixes donâ€™t need it):

   ::

      #!/usr/bin/env -S node --enable-source-maps --no-warnings=ExperimentalWarning

9.4â€ƒIdentifiers
----------------



.. _valid-identifiers-variable-names-etc:

9.4.1â€ƒValid identifiers (variable names, etc.)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   First character:

   -  Unicode letter (including accented characters such as ``Ã©`` and ``Ã¼`` and
      characters from non-latin alphabets, such as ``Î±``)
   -  ``$``
   -  ``_``

   Subsequent characters:

   -  Legal first characters
   -  Unicode digits (including Eastern Arabic numerals)
   -  Some other Unicode marks and punctuations

   Examples:

   .. code:: javascript

      const Îµ = 0.0001;
      const ÑÑ‚Ñ€Ğ¾ĞºĞ° = '';
      let _tmp = 0;
      const $foo2 = true;

9.4.2â€ƒReserved words
~~~~~~~~~~~~~~~~~~~~~

   Reserved words canâ€™t be variable names, but they can be property names.

   All JavaScript *keywords* are reserved words:

      ``await`` ``break`` ``case`` ``catch`` ``class`` ``const`` ``continue``
      ``debugger`` ``default`` ``delete`` ``do`` ``else`` ``export`` ``extends``
      ``finally`` ``for`` ``function`` ``if`` ``import`` ``in`` ``instanceof``
      ``let`` ``new`` ``return`` ``static`` ``super`` ``switch`` ``this`` ``throw``
      ``try`` ``typeof`` ``var`` ``void`` ``while`` ``with`` ``yield``

   The following tokens are also keywords, but currently not used in the language:

      ``enum`` ``implements`` ``package`` ``protected`` ``interface`` ``private``
      ``public``

   The following literals are reserved words:

      ``true`` ``false`` ``null``

   Technically, these words are not reserved, but you should avoid them, too,
   because they effectively are keywords:

      ``Infinity`` ``NaN`` ``undefined`` ``async``

   You shouldnâ€™t use the names of global variables (``String``, ``Math``, etc.) for
   your own variables and parameters, either.



.. _statement-vs-expression:

9.5â€ƒStatement vs. expression
-----------------------------

   In this section, we explore how JavaScript distinguishes two kinds of syntactic
   constructs: *statements* and *expressions*. Afterward, weâ€™ll see that that can
   cause problems because the same syntax can mean different things, depending on
   where it is used.

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**We pretend there are only statements and expressions**

      .. container:: boxout-vspace

      For the sake of simplicity, we pretend that there are only statements and
      expressions in JavaScript.

9.5.1â€ƒStatements
~~~~~~~~~~~~~~~~~

   A *statement* is a piece of code that can be executed and performs some kind of
   action. For example, ``if`` is a statement:

   .. code:: javascript

      let myStr;
      if (myBool) {
      myStr = 'Yes';
      } else {
      myStr = 'No';
      }

   One more example of a statement: a function declaration.

   .. code:: javascript

      function twice(x) {
      return x + x;
      }

9.5.2â€ƒExpressions
~~~~~~~~~~~~~~~~~~

   An *expression* is a piece of code that can be *evaluated* to produce a value.
   For example, the code between the parentheses is an expression:

   .. code:: javascript

      let myStr = (myBool ? 'Yes' : 'No');

   The operator ``_?_:_`` used between the parentheses is called the *ternary
   operator*. It is the expression version of the ``if`` statement.

   Letâ€™s look at more examples of expressions. We enter expressions and the REPL
   evaluates them for us:

   .. code:: javascript
      :name: language-node-repl

      > 'ab' + 'cd'
      'abcd'
      > Number('123')
      123
      > true || false
      true

9.5.3â€ƒWhat is allowed where?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The current location within JavaScript source code determines which kind of
   syntactic constructs you are allowed to use:

   -  The body of a function must be a sequence of statements:

      .. code:: javascript

         function max(x, y) {
         if (x > y) {
            return x;
         } else {
            return y;
         }
         }

   -  The arguments of a function call or a method call must be expressions:

      .. code:: javascript

         console.log('ab' + 'cd', Number('123'));

   However, expressions can be used as statements. Then they are called *expression
   statements*. The opposite is not true: when the context requires an expression,
   you canâ€™t use a statement.

   The following code demonstrates that any expression ``bar()`` can be either
   expression or statement â€“ it depends on the context:

   .. code:: javascript

      function f() {
      console.log(bar()); // bar() is expression
      bar(); // bar(); is (expression) statement  
      }

9.6â€ƒAmbiguous syntax
---------------------

   JavaScript has several programming constructs that are syntactically ambiguous:
   the same syntax is interpreted differently, depending on whether it is used in
   statement context or in expression context. This section explores the phenomenon
   and the pitfalls it causes.

9.6.1â€ƒSame syntax: function declaration and function expression
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A *function declaration* is a statement:

   .. code:: javascript

      function id(x) {
      return x;
      }

   A *function expression* is an expression (right-hand side of ``=``):

   .. code:: javascript

      const id = function me(x) {
      return x;
      };

9.6.2â€ƒSame syntax: object literal and block
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In the following code, ``{}`` is an *object literal*: an expression that creates
   an empty object.

   .. code:: javascript

      const obj = {};

   This is an empty code block (a statement):

   .. code:: javascript

      {
      }

9.6.3â€ƒDisambiguation
~~~~~~~~~~~~~~~~~~~~~

   The ambiguities are only a problem in statement context: If the JavaScript
   parser encounters ambiguous syntax, it doesnâ€™t know if itâ€™s a plain statement or
   an expression statement. For example:

   -  If a statement starts with ``function``: Is it a function declaration or a
      function expression?
   -  If a statement starts with ``{``: Is it an object literal or a code block?

   To resolve the ambiguity, statements starting with ``function`` or ``{`` are
   never interpreted as expressions. If you want an expression statement to start
   with either one of these tokens, you must wrap it in parentheses:

   .. code:: javascript

      (function (x) { console.log(x) })('abc');

   Output:

   ::

      abc

   In this code:

   #. We first create a function via a function expression:

      .. code:: javascript

         function (x) { console.log(x) }

   #. Then we invoke that function: ``('abc')``

   The code fragment shown in (1) is only interpreted as an expression because we
   wrap it in parentheses. If we didnâ€™t, we would get a syntax error because then
   JavaScript expects a function declaration and complains about the missing
   function name. Additionally, you canâ€™t put a function call immediately after a
   function declaration.

   Later in this book, weâ€™ll see more examples of pitfalls caused by syntactic
   ambiguity:

   -  `Assigning via object
      destructuring <#assigning-via-object-destructuring>`__
   -  `Returning an object literal from an arrow
      function <#returning-object-literal-from-arrow-function>`__

9.7â€ƒSemicolons
---------------

9.7.1â€ƒRule of thumb for semicolons
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Each statement is terminated by a semicolon:

   .. code:: javascript

      const x = 3;
      someFunction('abc');
      i++;

   except statements ending with blocks:

   .. code:: javascript

      function foo() {
      // Â·Â·Â·
      }
      if (y > 0) {
      // Â·Â·Â·
      }

   The following case is slightly tricky:

   .. code:: javascript

      const func = () => {}; // semicolon!

   The whole ``const`` declaration (a statement) ends with a semicolon, but inside
   it, there is an arrow function expression. That is, itâ€™s not the statement per
   se that ends with a curly brace; itâ€™s the embedded arrow function expression.
   Thatâ€™s why there is a semicolon at the end.

9.7.2â€ƒSemicolons: control statements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The body of a control statement is itself a statement. For example, this is the
   syntax of the ``while`` loop:

   .. code:: javascript

      while (condition)
      statement

   The body can be a single statement:

   .. code:: javascript

      while (a > 0) a--;

   But blocks are also statements and therefore legal bodies of control statements:

   .. code:: javascript

      while (a > 0) {
      a--;
      }

   If you want a loop to have an empty body, your first option is an empty
   statement (which is just a semicolon):

   .. code:: javascript

      while (processNextItem() > 0);

   Your second option is an empty block:

   .. code:: javascript

      while (processNextItem() > 0) {}

9.8â€ƒAutomatic semicolon insertion (ASI)
----------------------------------------

   While I recommend to always write semicolons, most of them are optional in
   JavaScript. The mechanism that makes this possible is called *automatic
   semicolon insertion* (ASI). In a way, it corrects syntax errors.

   ASI works as follows. Parsing of a statement continues until there is either:

   -  A semicolon
   -  A line terminator followed by an illegal token

   In other words, ASI can be seen as inserting semicolons at line breaks. The next
   subsections cover the pitfalls of ASI.

9.8.1â€ƒASI triggered unexpectedly
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The good news about ASI is that â€“ if you donâ€™t rely on it and always write
   semicolons â€“ there is only one pitfall that you need to be aware of. It is that
   JavaScript forbids line breaks after some tokens. If you do insert a line break,
   a semicolon will be inserted, too.

   The token where this is most practically relevant is ``return``. Consider, for
   example, the following code:

   .. code:: javascript

      return
      {
      first: 'jane'
      };

   This code is parsed as:

   .. code:: javascript

      return;
      {
      first: 'jane';
      }
      ;

   That is:

   -  Return statement without operand: ``return;``
   -  Start of code block: ``{``
   -  Expression statement ``'jane';`` with `label <#labels>`__
      ``first:``
   -  End of code block: ``}``
   -  Empty statement: ``;``

   Why does JavaScript do this? It protects against accidentally returning a value
   in a line after a ``return``.

9.8.2â€ƒASI unexpectedly not triggered
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In some cases, ASI is *not* triggered when you think it should be. That makes
   life more complicated for people who donâ€™t like semicolons because they need to
   be aware of those cases. The following are three examples. There are more.

   **Example 1:** Unintended function call.

   .. code:: javascript

      a = b + c
      (d + e).print()

   Parsed as:

   .. code:: javascript

      a = b + c(d + e).print();

   **Example 2:** Unintended division.

   .. code:: javascript

      a = b
      /hi/g.exec(c).map(d)

   Parsed as:

   .. code:: javascript

      a = b / hi / g.exec(c).map(d);

   **Example 3:** Unintended property access.

   .. code:: javascript

      someFunction()
      ['ul', 'ol'].map(x => x + x)

   Executed as:

   .. code:: javascript

      const propKey = ('ul','ol'); // comma operator
      assert.equal(propKey, 'ol');

      someFunction()[propKey].map(x => x + x);

9.9â€ƒSemicolons: best practices
-------------------------------

   I recommend that you always write semicolons:

   -  I like the visual structure it gives code â€“ you clearly see where a statement
      ends.
   -  There are less rules to keep in mind.
   -  The majority of JavaScript programmers use semicolons.

   However, there are also many people who donâ€™t like the added visual clutter of
   semicolons. If you are one of them: Code without them *is* legal. I recommend
   that you use tools to help you avoid mistakes. The following are two examples:

   -  The automatic code formatter `Prettier <https://prettier.io>`__ can be
      configured to not use semicolons. It then automatically fixes problems. For
      example, if it encounters a line that starts with a square bracket, it
      prefixes that line with a semicolon.
   -  The static checker `ESLint <https://eslint.org>`__ has `a
      rule <https://eslint.org/docs/rules/semi>`__ that you tell your preferred
      style (always semicolons or as few semicolons as possible) and that warns you
      about critical issues.



.. _strict-mode:

9.10â€ƒStrict mode vs. sloppy mode
---------------------------------

   Starting with ECMAScript 5, JavaScript has two *modes* in which JavaScript can
   be executed:

   -  Normal â€œsloppyâ€ mode is the default in scripts (code fragments that are a
      precursor to modules and supported by browsers).
   -  Strict mode is the default in modules and classes, and can be switched on in
      scripts (how is explained later). In this mode, several pitfalls of normal
      mode are removed and more exceptions are thrown.

   Youâ€™ll rarely encounter sloppy mode in modern JavaScript code, which is almost
   always located in modules. In this book, I assume that strict mode is always
   switched on.

9.10.1â€ƒSwitching on strict mode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In script files and CommonJS modules, you switch on strict mode for a complete
   file, by putting the following code in the first line:

   .. code:: javascript

      'use strict';

   The neat thing about this â€œdirectiveâ€ is that ECMAScript versions before 5
   simply ignore it: itâ€™s an expression statement that does nothing.

   You can also switch on strict mode for just a single function:

   .. code:: javascript

      function functionInStrictMode() {
      'use strict';
      }

9.10.2â€ƒImprovements in strict mode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Letâ€™s look at three things that strict mode does better than sloppy mode. Just
   in this one section, all code fragments are executed in sloppy mode.

9.10.2.1â€ƒSloppy mode pitfall: changing an undeclared variable creates a global variable
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   In non-strict mode, changing an undeclared variable creates a global variable.

   .. code:: javascript

      function sloppyFunc() {
      undeclaredVar1 = 123;
      }
      sloppyFunc();
      // Created global variable `undeclaredVar1`:
      assert.equal(undeclaredVar1, 123);

   Strict mode does it better and throws a ``ReferenceError``. That makes it easier
   to detect typos.

   .. code:: javascript

      function strictFunc() {
      'use strict';
      undeclaredVar2 = 123;
      }
      assert.throws(
      () => strictFunc(),
      {
         name: 'ReferenceError',
         message: 'undeclaredVar2 is not defined',
      });

   The ``assert.throws()`` states that its first argument, a function, throws a
   ``ReferenceError`` when it is called.

9.10.2.2â€ƒFunction declarations are block-scoped in strict mode, function-scoped in sloppy mode
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   In strict mode, a variable created via a function declaration only exists within
   the innermost enclosing block:

   .. code:: javascript

      function strictFunc() {
      'use strict';
      {
         function foo() { return 123 }
      }
      return foo(); // ReferenceError
      }
      assert.throws(
      () => strictFunc(),
      {
         name: 'ReferenceError',
         message: 'foo is not defined',
      });

   In sloppy mode, function declarations are function-scoped:

   .. code:: javascript

      function sloppyFunc() {
      {
         function foo() { return 123 }
      }
      return foo(); // works
      }
      assert.equal(sloppyFunc(), 123);



.. _sloppy-mode-doesn-t-throw-exceptions-when-changing-immutable-data:

9.10.2.3â€ƒSloppy mode doesnâ€™t throw exceptions when changing immutable data
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   In strict mode, you get an exception if you try to change immutable data:

   .. code:: javascript

      function strictFunc() {
      'use strict';
      true.prop = 1; // TypeError
      }
      assert.throws(
      () => strictFunc(),
      {
         name: 'TypeError',
         message: "Cannot create property 'prop' on boolean 'true'",
      });

   In sloppy mode, the assignment fails silently:

   .. code:: javascript

      function sloppyFunc() {
      true.prop = 1; // fails silently
      return true.prop;
      }
      assert.equal(sloppyFunc(), undefined);

   .. container:: boxout

      |Icon â€œexternalâ€|â€‚**Further reading: sloppy mode**

      .. container:: boxout-vspace

      For more information on how sloppy mode differs from strict mode, see
      `MDN <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode>`__.

   `Comments <https://github.com/rauschma/exploring-js/issues/5>`__



.. _ch_console:

10â€ƒConsoles: interactive JavaScript command lines
==================================================

   #. `10.1â€ƒTrying out JavaScript code <#trying-out-code>`__

      #. `10.1.1â€ƒBrowser consoles <#browser-consoles>`__
      #. `10.1.2â€ƒThe Node.js REPL <#the-node-js-repl>`__
      #. `10.1.3â€ƒOther options <#other-options>`__

   #. `10.2â€ƒThe console.* API: printing data and more <#the-console-api-printing-data-and-more>`__

      #. `10.2.1â€ƒPrinting values: console.log() (stdout) <#printing-values-console-log-stdout>`__
      #. `10.2.2â€ƒPrinting error information: console.error() (stderr) <#printing-error-information-console-error-stderr>`__
      #. `10.2.3â€ƒPrinting nested objects via JSON.stringify() <#printing-nested-objects-via-json-stringify>`__



.. _trying-out-code:

10.1â€ƒTrying out JavaScript code
--------------------------------

   You have many options for quickly running pieces of JavaScript code. The
   following subsections describe a few of them.

10.1.1â€ƒBrowser consoles
~~~~~~~~~~~~~~~~~~~~~~~~

   Web browsers have so-called *consoles*: interactive command lines to which you
   can print text via ``console.log()`` and where you can run pieces of code. How
   to open the console differs from browser to browser. `Figure
   10.1 <#fig:chrome-console>`__ shows the console of Google Chrome.

   To find out how to open the console in your web browser, you can do a web search
   for â€œconsole Â«name-of-your-browserÂ»â€. These are pages for a few commonly used
   web browsers:

   -  `Apple Safari <https://developer.apple.com/safari/tools/>`__
   -  `Google Chrome <https://developer.chrome.com/docs/devtools/console/>`__
   -  `Microsoft
      Edge <https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/console/>`__
   -  `Mozilla
      Firefox <https://firefox-source-docs.mozilla.org/devtools-user/web_console/>`__

   .. figure:: https://exploringjs.com/js/book/img-book/big-picture/chrome-console.png
      name: fig:chrome-console
      :width: 417px
      :height: 337px

      Figure 10.1: The console of the web browser â€œGoogle Chromeâ€ is open (in the
      bottom half of window) while visiting a web page.



.. _the-node-js-repl:

10.1.2â€ƒThe Node.js REPL
~~~~~~~~~~~~~~~~~~~~~~~~

   *REPL* stands for *read-eval-print loop* and basically means *command line*. To
   use it, you must first start Node.js from an operating system command line, via
   the command ``node``. Then an interaction with it looks as depicted in `figure
   10.2 <#fig:nodejs-repl>`__: The text after ``>`` is input from the user;
   everything else is output from Node.js.

   .. figure:: https://exploringjs.com/js/book/img-book/big-picture/nodejs-repl.png
      name: fig:nodejs-repl
      :width: 271px
      :height: 156px

      Figure 10.2: Starting and using the Node.js REPL (interactive command line).

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**Reading: REPL interactions**

      .. container:: boxout-vspace

      I occasionally demonstrate JavaScript via REPL interactions. Then I also use
      greater-than symbols (``>``) to mark input â€“ for example:

      .. code:: javascript
         :name: language-node-repl

         > 3 + 5
         8

10.1.3â€ƒOther options
~~~~~~~~~~~~~~~~~~~~~

   Other options include:

   -  There are many web apps that let you experiment with JavaScript in web
      browsers â€“ for example, `Babelâ€™s REPL <https://babeljs.io/repl>`__.

   -  There are also native apps and IDE plugins for running JavaScript.

   .. container:: boxout

      |Icon â€œwarningâ€|â€‚**Consoles often run in non-strict mode**

      .. container:: boxout-vspace

      In modern JavaScript, most code (e.g., modules) is executed in `strict
      mode <#strict-mode>`__. However, consoles often run in
      non-strict mode. Therefore, you may occasionally get slightly different
      results when using a console to execute code from this book.



.. _the-console-api-printing-data-and-more:

10.2â€ƒThe ``console.*`` API: printing data and more
---------------------------------------------------

   In browsers, the console is something you can bring up that is normally hidden.
   For Node.js, the console is the terminal that Node.js is currently running in.

   The full ``console.*`` API is documented `on MDN web
   docs <https://developer.mozilla.org/en-US/docs/Web/API/console>`__ and `on the
   Node.js website <https://nodejs.org/api/console.html>`__. It is not part of the
   JavaScript language standard, but much functionality is supported by both
   browsers and Node.js.

   In this chapter, we only look at the following two methods for printing data
   (â€œprintingâ€ means displaying in the console):

   -  ``console.log()``
   -  ``console.error()``



.. _printing-values-console-log-stdout:

10.2.1â€ƒPrinting values: ``console.log()`` (stdout)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   There are two variants of this operation:

   .. code:: javascript
      :name: language-ts

      console.log(...values: Array<any>): void
      console.log(pattern: string, ...values: Array<any>): void

10.2.1.1â€ƒPrinting multiple values
''''''''''''''''''''''''''''''''''

   The first variant prints (text representations of) values on the console:

   .. code:: javascript

      console.log('abc', 123, true);

   Output:

   .. code:: language-txt

      abc 123 true

   At the end, ``console.log()`` always prints a newline. Therefore, if you call it
   with zero arguments, it just prints a newline.

10.2.1.2â€ƒPrinting a string with substitutions
''''''''''''''''''''''''''''''''''''''''''''''

   The second variant performs string substitution:

   .. code:: javascript

      console.log('Test: %s %j', 123, 'abc');

   Output:

   .. code:: language-txt

      Test: 123 "abc"

   These are some of the directives you can use for substitutions:

   -  ``%s`` converts the corresponding value to a string and inserts it.

      .. code:: javascript

         console.log('%s %s', 'abc', 123);

      Output:

      .. code:: language-txt

         abc 123

   -  ``%o`` inserts a string representation of an object.

      .. code:: javascript

         console.log('%o', {foo: 123, bar: 'abc'});

      Output:

      .. code:: language-txt

         { foo: 123, bar: 'abc' }

   -  ``%j`` converts a value to a JSON string and inserts it.

      .. code:: javascript

         console.log('%j', {foo: 123, bar: 'abc'});

      Output:

      .. code:: language-txt

         {"foo":123,"bar":"abc"}

   -  ``%%`` inserts a single ``%``.

      .. code:: javascript

         console.log('%s%%', 99);

      Output:

      .. code:: language-txt

         99%



.. _printing-error-information-console-error-stderr:

10.2.2â€ƒPrinting error information: ``console.error()`` (stderr)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``console.error()`` works the same as ``console.log()``, but what it logs is
   considered error information. For Node.js, that means that the output goes to
   stderr instead of stdout on Unix.



.. _printing-nested-objects-via-json-stringify:

10.2.3â€ƒPrinting nested objects via ``JSON.stringify()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `JSON.stringify() <#JSON.stringify>`__ is occasionally useful
   for printing nested objects:

   .. code:: javascript

      console.log(JSON.stringify({first: 'Jane', last: 'Doe'}, null, 2));

   Output:

   .. code:: language-txt

      {
      "first": "Jane",
      "last": "Doe"
      }

   `Comments <https://github.com/rauschma/exploring-js/issues/48>`__



.. _ch_assertion-api:

11â€ƒAssertion API
=================

   #. `11.1â€ƒAssertions in software development <#assertions-in-software-development>`__
   #. `11.2â€ƒHow assertions are used in this book <#how-assertions-are-used-in-this-book>`__

      #. `11.2.1â€ƒDocumenting results in code examples via assertions <#documenting-results-in-code-examples-via-assertions>`__
      #. `11.2.2â€ƒImplementing test-driven exercises via assertions <#implementing-test-driven-exercises-via-assertions>`__

   #. `11.3â€ƒNormal comparison vs. deep comparison <#normal-comparison-vs-deep-comparison>`__
   #. `11.4â€ƒQuick reference: module assert <#quick-reference-module-assert>`__

      #. `11.4.1â€ƒNormal equality: assert.equal() <#normal-equality-assert-equal>`__
      #. `11.4.2â€ƒDeep equality: assert.deepEqual() <#deep-equality-assert-deepequal>`__
      #. `11.4.3â€ƒExpecting exceptions: assert.throws() <#assert.throws>`__
      #. `11.4.4â€ƒAlways fail: assert.fail() <#always-fail-assert-fail>`__

11.1â€ƒAssertions in software development
----------------------------------------

   In software development, *assertions* state facts about values or pieces of code
   that must be true. If they arenâ€™t, an exception is thrown. Node.js supports
   assertions via its built-in module ``assert`` â€“ for example:

   .. code:: javascript

      import assert from 'node:assert/strict';
      assert.equal(3 + 5, 8);

   This assertion states that the expected result of 3 plus 5 is 8. The import
   statement uses `the recommended strict version <https://nodejs.org/api/assert.html#assert_strict_mode>`__ 
   of ``assert``.

11.2â€ƒHow assertions are used in this book
------------------------------------------

   In this book, assertions are used in two ways: to document results in code
   examples and to implement test-driven exercises.

11.2.1â€ƒDocumenting results in code examples via assertions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In code examples, assertions express expected results. Take, for example, the
   following function:

   .. code:: javascript

      function id(x) {
      return x;
      }

   ``id()`` returns its parameter. We can show it in action via an assertion:

   .. code:: javascript

      assert.equal(id('abc'), 'abc');

   In the examples, I usually omit the statement for importing ``assert``.

   The motivation behind using assertions is:

   -  We can specify precisely what is expected.
   -  Code examples can be tested automatically, which ensures that they really
      work.

11.2.2â€ƒImplementing test-driven exercises via assertions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The exercises for this book are test-driven, via the test framework Mocha.
   Checks inside the tests are made via methods of ``assert``.

   The following is an example of such a test:

   .. code:: javascript

      // For the exercise, we must implement the function hello().
      // The test checks if we have done it properly.
      test('First exercise', () => {
      assert.equal(hello('world'), 'Hello world!');
      assert.equal(hello('Jane'), 'Hello Jane!');
      assert.equal(hello('John'), 'Hello John!');
      assert.equal(hello(''), 'Hello !');
      });

   For more information, see `â€œGetting started with exercisesâ€ (Â§12) <#ch_exercises>`__.



.. _normal-comparison-vs-deep-comparison:

11.3â€ƒNormal comparison vs. deep comparison
-------------------------------------------

   The strict ``equal()`` uses ``===`` to compare values. Therefore, an object is
   only equal to itself â€“ even if another object has the same content (because
   ``===`` does not compare the contents of objects, only their identities):

   .. code:: javascript

      assert.notEqual({foo: 1}, {foo: 1});

   ``deepEqual()`` is a better choice for comparing objects:

   .. code:: javascript

      assert.deepEqual({foo: 1}, {foo: 1});

   This method works for Arrays, too:

   .. code:: javascript

      assert.notEqual(['a', 'b', 'c'], ['a', 'b', 'c']);
      assert.deepEqual(['a', 'b', 'c'], ['a', 'b', 'c']);

11.4â€ƒQuick reference: module ``assert``
----------------------------------------

   For the full documentation, see `the Node.js docs <https://nodejs.org/api/assert.html>`__.



.. _normal-equality-assert-equal:

11.4.1â€ƒNormal equality: ``assert.equal()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``assert.equal(actual, expected, message?)``

      ``actual === expected`` must be ``true``. If not, an ``AssertionError`` is
      thrown.

      .. code:: javascript

         assert.equal(3+3, 6);

   -  ``assert.notEqual(actual, expected, message?)``

      ``actual !== expected`` must be ``true``. If not, an ``AssertionError`` is
      thrown.

      .. code:: javascript

         assert.notEqual(3+3, 22);

   The optional last parameter ``message`` can be used to explain what is asserted.
   If the assertion fails, the message is used to set up the ``AssertionError``
   that is thrown.

   .. code:: javascript

      let e;
      try {
      const x = 3;
      assert.equal(x, 8, 'x must be equal to 8')
      } catch (err) {
      assert.equal(
         String(err),
         'AssertionError [ERR_ASSERTION]: x must be equal to 8');
      }



.. _deep-equality-assert-deepequal:

11.4.2â€ƒDeep equality: ``assert.deepEqual()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``assert.deepEqual(actual, expected, message?)``

      ``actual`` must be deeply equal to ``expected``. If not, an
      ``AssertionError`` is thrown.

      .. code:: javascript

         assert.deepEqual([1,2,3], [1,2,3]);
         assert.deepEqual([], []);

         // To .equal(), an object is only equal to itself:
         assert.notEqual([], []);

   -  ``assert.notDeepEqual(actual, expected, message?)``

      ``actual`` must not be deeply equal to ``expected``. If it is, an
      ``AssertionError`` is thrown.

      .. code:: javascript

         assert.notDeepEqual([1,2,3], [1,2]);



.. _assert.throws:

11.4.3â€ƒExpecting exceptions: ``assert.throws()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If we want to (or expect to) receive an exception, we need ``assert.throws()``:
   This function calls its first parameter, the function ``callback``, and only
   succeeds if it throws an exception. Additional parameters can be used to specify
   what that exception must look like.

   -  ``assert.throws(callback, message?): void``

      .. code:: javascript

         assert.throws(
         () => {
            null.prop;
         }
         );

   -  ``assert.throws(callback, errorClass, message?): void``

      .. code:: javascript

         assert.throws(
         () => {
            null.prop;
         },
         TypeError
         );

   -  ``assert.throws(callback, errorRegExp, message?): void``

      .. code:: javascript

         assert.throws(
         () => {
            null.prop;
         },
         /^TypeError: Cannot read properties of null \(reading 'prop'\)$/
         );

   -  ``assert.throws(callback, errorObject, message?): void``

      .. code:: javascript

         assert.throws(
         () => {
            null.prop;
         },
         {
            name: 'TypeError',
            message: "Cannot read properties of null (reading 'prop')",
         }
         );



.. _always-fail-assert-fail:

11.4.4â€ƒAlways fail: ``assert.fail()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``assert.fail(messageOrError?)``

      By default, it throws an ``AssertionError`` when it is called. That is
      occasionally useful for unit testing. ``messageOrError`` can be:

      -  A string. That enables to override the default error message.
      -  An instance of ``Error`` (or a subclass). That enables us to throw a
         different value.

      .. code:: javascript

         try {
         functionThatShouldThrow();
         assert.fail();
         } catch (_) {
         // Success
         }

   `Comments <https://github.com/rauschma/exploring-js/issues/3>`__


.. _ch_exercises:

12â€ƒGetting started with exercises
==================================

   #. `12.1â€ƒExercises <#exercises>`__

      #. `12.1.1â€ƒInstalling the exercises <#installing-the-exercises>`__
      #. `12.1.2â€ƒRunning exercises <#running-exercises>`__

   #. `12.2â€ƒUnit tests in JavaScript <#unit-tests-in-javascript>`__

      #. `12.2.1â€ƒA typical test <#a-typical-test>`__
      #. `12.2.2â€ƒAsynchronous tests in Mocha <#async-tests-mocha>`__

   Throughout most chapters, there are boxes that point to exercises. These are a
   paid feature, but a comprehensive preview is available. This chapter explains
   how to get started with them.

12.1â€ƒExercises
---------------

12.1.1â€ƒInstalling the exercises
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To install the exercises:

   -  Download and unzip ``exploring-js-code.zip``
   -  Follow the instructions in ``README.txt``

12.1.2â€ƒRunning exercises
~~~~~~~~~~~~~~~~~~~~~~~~~

   -  Exercises are referred to by path in this book.

      -  For example: ``exercises/exercises/first_module_test.mjs``

   -  Within each file:

      -  The first line contains the command for running the exercise.
      -  The following lines describe what you have to do.

12.2â€ƒUnit tests in JavaScript
------------------------------

   All exercises in this book are tests that are run via the test framework
   `Mocha <https://mochajs.org>`__. This section gives a brief introduction.

12.2.1â€ƒA typical test
~~~~~~~~~~~~~~~~~~~~~~

   Typical test code is split into two parts:

   -  Part 1: the code to be tested.
   -  Part 2: the tests for the code.

   Take, for example, the following two files:

   -  ``id.mjs`` (code to be tested)
   -  ``id_test.mjs`` (tests)

12.2.1.1â€ƒPart 1: the code
''''''''''''''''''''''''''

   The code itself resides in ``id.mjs``:

   .. code:: javascript

      export function id(x) {
      return x;
      }

   The key thing here is: everything we want to test must be exported. Otherwise,
   the test code canâ€™t access it.

12.2.1.2â€ƒPart 2: the tests
'''''''''''''''''''''''''''

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**Donâ€™t worry about the exact details of tests**

      .. container:: boxout-vspace

      You donâ€™t need to worry about the exact details of tests: They are always
      implemented for you. Therefore, you only need to read them, but not write
      them.

   The tests for the code reside in ``id_test.mjs``:

   .. code:: javascript

      // npm t demos/exercises/id_test.mjs
      suite('id_test.mjs');

      import assert from 'node:assert/strict'; // (A)
      import {id} from './id.mjs'; // (B)

      test('My test', () => { // (C)
      assert.equal(id('abc'), 'abc'); // (D)
      });

   The core of this test file is line D â€“ `an
   assertion <#ch_assertion-api>`__: ``assert.equal()``
   specifies that the expected result of ``id('abc')`` is ``'abc'``.

   As for the other lines:

   -  The comment at the very beginning shows the shell command for running the
      test.
   -  Line A: We import the Node.js assertion library (in *strict assertion mode*).
   -  Line B: We import the function to test.
   -  Line C: We define a test. This is done by calling the function ``test()``:

      -  First parameter: the name of the test.
      -  Second parameter: the test code, which is provided via an arrow function.
         The parameter ``t`` gives us access to AVAâ€™s testing API (assertions,
         etc.).

   To run the test, we execute the following in a command line:

   .. code:: language-txt

      npm t demos/exercises/id_test.mjs

   The ``t`` is an abbreviation for ``test``. That is, the long version of this
   command is:

   .. code:: language-txt

      npm test demos/exercises/id_test.mjs

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Your first exercise**

      .. container:: boxout-vspace

      The following exercise gives you a first taste of what exercises are like:

      -  ``exercises/exercises/first_module_test.mjs``



.. _async-tests-mocha:

12.2.2â€ƒAsynchronous tests in Mocha
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**Reading**

      .. container:: boxout-vspace

      You may want to postpone reading this section until you get to the chapters
      on asynchronous programming.

   Writing tests for asynchronous code requires extra work: The test receives its
   results later and has to signal to Mocha that it isnâ€™t finished yet when it
   returns. The following subsections examine three ways of doing so.

12.2.2.1â€ƒAsynchronicity via callbacks
''''''''''''''''''''''''''''''''''''''

   If the callback we pass to ``test()`` has a parameter (e.g., ``done``), Mocha
   switches to callback-based asynchronicity. When we are done with our
   asynchronous work, we have to call ``done``:

   .. code:: javascript

      test('divideCallback', (done) => {
      divideCallback(8, 4, (error, result) => {
         if (error) {
            done(error);
         } else {
            assert.strictEqual(result, 2);
            done();
         }
      });
      });

   This is what ``divideCallback()`` looks like:

   .. code:: javascript

      function divideCallback(x, y, callback) {
      if (y === 0) {
         callback(new Error('Division by zero'));
      } else {
         callback(null, x / y);
      }
      }

12.2.2.2â€ƒAsynchronicity via Promises
'''''''''''''''''''''''''''''''''''''

   If a test returns a Promise, Mocha switches to Promise-based asynchronicity. A
   test is considered successful if the Promise is fulfilled and failed if the
   Promise is rejected or if a settlement takes longer than a timeout.

   .. code:: javascript

      test('dividePromise 1', () => {
      return dividePromise(8, 4)
      .then(result => {
         assert.strictEqual(result, 2);
      });
      });

   ``dividePromise()`` is implemented as follows:

   .. code:: javascript

      function dividePromise(x, y) {
      return new Promise((resolve, reject) => {
         if (y === 0) {
            reject(new Error('Division by zero'));
         } else {
            resolve(x / y);
         }
      });
      }

12.2.2.3â€ƒAsync functions as test â€œbodiesâ€
''''''''''''''''''''''''''''''''''''''''''

   Async functions always return Promises. Therefore, an async function is a
   convenient way of implementing an asynchronous test. The following code is
   equivalent to the previous example.

   .. code:: javascript

      test('dividePromise 2', async () => {
      const result = await dividePromise(8, 4);
      assert.strictEqual(result, 2);
      // No explicit return necessary!
      });

   We donâ€™t need to explicitly return anything: The implicitly returned
   ``undefined`` is used to fulfill the Promise returned by this async function.
   And if the test code throws an exception, then the async function takes care of
   rejecting the returned Promise.

   `Comments <https://github.com/rauschma/exploring-js/issues/2>`__




.. _ch_variables-assignment:

13â€ƒVariables and assignment
============================

   #. `13.1â€ƒlet <#let>`__
   #. `13.2â€ƒconst <#const>`__

      #. `13.2.1â€ƒconst and immutability <#const-and-immutability>`__
      #. `13.2.2â€ƒconst and loops <#const-and-loops>`__

   #. `13.3â€ƒDeciding between const and let <#deciding-between-const-and-let>`__
   #. `13.4â€ƒThe scope of a variable <#the-scope-of-a-variable>`__

      #. `13.4.1â€ƒShadowing variables <#shadowing-variables>`__

   #. `13.5â€ƒ(Advanced) <#advanced-1>`__
   #. `13.6â€ƒTerminology: static vs. dynamic <#terminology-static-vs-dynamic>`__

      #. `13.6.1â€ƒStatic phenomenon: scopes of variables <#static-phenomenon-scopes-of-variables>`__
      #. `13.6.2â€ƒDynamic phenomenon: function calls <#dynamic-phenomenon-function-calls>`__

   #. `13.7â€ƒGlobal variables and the global object <#global-variables-and-the-global-object>`__

      #. `13.7.1â€ƒglobalThis [ES2020] <#globalThis>`__

   #. `13.8â€ƒDeclarations: scope and activation <#declarations-scope-activation>`__

      #. `13.8.1â€ƒconst and let: temporal dead zone <#const-and-let-temporal-dead-zone>`__
      #. `13.8.2â€ƒFunction declarations and early activation <#function-declarations-and-early-activation>`__
      #. `13.8.3â€ƒClass declarations are not activated early <#class-declarations-are-not-activated-early>`__
      #. `13.8.4â€ƒvar: hoisting (partial early activation) <#var-hoisting-partial-early-activation>`__

   #. `13.9â€ƒClosures <#closures>`__

      #. `13.9.1â€ƒBound variables vs. free variables <#bound-variables-vs-free-variables>`__
      #. `13.9.2â€ƒWhat is a closure? <#what-is-a-closure>`__
      #. `13.9.3â€ƒExample: A factory for incrementors <#example-a-factory-for-incrementors>`__
      #. `13.9.4â€ƒUse cases for closures <#use-cases-for-closures>`__

   These are JavaScriptâ€™s main ways of declaring variables:

   -  ``let`` declares mutable variables.
   -  ``const`` declares *constants* (immutable variables).

   Before ES6, there was also ``var``. But it has several quirks, so itâ€™s best to
   avoid it in modern JavaScript. You can read more about it in `Speaking
   JavaScript <http://exploringjs.com/es5/ch16.html>`__.

13.1â€ƒ``let``
-------------

   Variables declared via ``let`` are mutable:

   .. code:: javascript

      let i;
      i = 0;
      i = i + 1;
      assert.equal(i, 1);

   You can also declare and assign at the same time:

   .. code:: javascript

      let i = 0;

13.2â€ƒ``const``
---------------

   Variables declared via ``const`` are immutable. You must always initialize
   immediately:

   .. code:: javascript

      const i = 0; // must initialize

      assert.throws(
      () => { i = i + 1 },
      {
         name: 'TypeError',
         message: 'Assignment to constant variable.',
      }
      );

13.2.1â€ƒ``const`` and immutability
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In JavaScript, ``const`` only means that the *binding* (the association between
   variable name and variable value) is immutable. The value itself may be mutable,
   like ``obj`` in the following example.

   .. code:: javascript

      const obj = { prop: 0 };

      // Allowed: changing properties of `obj`
      obj.prop = obj.prop + 1;
      assert.equal(obj.prop, 1);

      // Not allowed: assigning to `obj`
      assert.throws(
      () => { obj = {} },
      {
         name: 'TypeError',
         message: 'Assignment to constant variable.',
      }
      );

13.2.2â€ƒ``const`` and loops
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   You can use ``const`` with ``for-of`` loops, where a fresh binding is created
   for each iteration:

   .. code:: javascript

      const arr = ['hello', 'world'];
      for (const elem of arr) {
      console.log(elem);
      }

   Output:

   ::

      hello
      world

   In plain ``for`` loops, you must use ``let``, however:

   .. code:: javascript

      const arr = ['hello', 'world'];
      for (let i=0; i<arr.length; i++) {
      const elem = arr[i];
      console.log(elem);
      }

13.3â€ƒDeciding between ``const`` and ``let``
--------------------------------------------

   I recommend the following rules to decide between ``const`` and ``let``:

   -  ``const`` indicates an immutable binding and that a variable never changes
      its value. Prefer it.
   -  ``let`` indicates that the value of a variable changes. Use it only when you
      canâ€™t use ``const``.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: ``const``**

      .. container:: boxout-vspace

      ``exercises/variables-assignment/const_exrc.mjs``

13.4â€ƒThe scope of a variable
-----------------------------

   The *scope* of a variable is the region of a program where it can be accessed.
   Consider the following code.

   .. code:: javascript

      { // // Scope A. Accessible: x
      const x = 0;
      assert.equal(x, 0);
      { // Scope B. Accessible: x, y
         const y = 1;
         assert.equal(x, 0);
         assert.equal(y, 1);
         { // Scope C. Accessible: x, y, z
            const z = 2;
            assert.equal(x, 0);
            assert.equal(y, 1);
            assert.equal(z, 2);
         }
      }
      }
      // Outside. Not accessible: x, y, z
      assert.throws(
      () => console.log(x),
      {
         name: 'ReferenceError',
         message: 'x is not defined',
      }
      );

   -  Scope A is the *(direct) scope* of ``x``.
   -  Scopes B and C are *inner scopes* of scope A.
   -  Scope A is an *outer scope* of scope B and scope C.

   Each variable is accessible in its direct scope and all scopes nested within
   that scope.

   The variables declared via ``const`` and ``let`` are called *block-scoped*
   because their scopes are always the innermost surrounding blocks.

13.4.1â€ƒShadowing variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   You canâ€™t declare the same variable twice at the same level:

   .. code:: javascript

      assert.throws(
      () => {
         eval('let x = 1; let x = 2;');
      },
      {
         name: 'SyntaxError',
         message: "Identifier 'x' has already been declared",
      });

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Why ``eval()``?**

      .. container:: boxout-vspace

      `eval() <#eval>`__ delays parsing (and
      therefore the ``SyntaxError``), until the callback of ``assert.throws()`` is
      executed. If we didnâ€™t use it, weâ€™d already get an error when this code is
      parsed and ``assert.throws()`` wouldnâ€™t even be executed.

   You can, however, nest a block and use the same variable name ``x`` that you
   used outside the block:

   .. code:: javascript

      const x = 1;
      assert.equal(x, 1);
      {
      const x = 2;
      assert.equal(x, 2);
      }
      assert.equal(x, 1);

   Inside the block, the inner ``x`` is the only accessible variable with that
   name. The inner ``x`` is said to *shadow* the outer ``x``. Once you leave the
   block, you can access the old value again.



.. _advanced-1:

13.5â€ƒ(Advanced)
----------------

   All remaining sections are advanced.



.. _terminology-static-vs-dynamic:

13.6â€ƒTerminology: static vs. dynamic
-------------------------------------

   These two adjectives describe phenomena in programming languages:

   -  *Static* means that something is related to source code and can be determined
      without executing code.
   -  *Dynamic* means at runtime.

   Letâ€™s look at examples for these two terms.

13.6.1â€ƒStatic phenomenon: scopes of variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Variable scopes are a static phenomenon. Consider the following code:

   .. code:: javascript

      function f() {
      const x = 3;
      // Â·Â·Â·
      }

   ``x`` is *statically* (or *lexically*) *scoped*. That is, its scope is fixed and
   doesnâ€™t change at runtime.

   Variable scopes form a static tree (via static nesting).

13.6.2â€ƒDynamic phenomenon: function calls
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Function calls are a dynamic phenomenon. Consider the following code:

   .. code:: javascript

      function g(x) {}
      function h(y) {
      if (Math.random()) g(y); // (A)
      }

   Whether or not the function call in line A happens, can only be decided at
   runtime.

   Function calls form a dynamic tree (via dynamic calls).

13.7â€ƒGlobal variables and the global object
--------------------------------------------

   JavaScriptâ€™s variable scopes are nested. They form a tree:

   -  The outermost scope is the root of the tree.
   -  The scopes directly contained in that scope are the children of the root.
   -  And so on.

   The root is also called the *global scope*. In web browsers, the only location
   where one is directly in that scope is at the top level of a script. The
   variables of the global scope are called *global variables* and accessible
   everywhere. There are two kinds of global variables:

   -  *Global declarative variables* are normal variables.

      -  They can only be created while at the top level of a script, via
         ``const``, ``let``, and class declarations.

   -  *Global object variables* are stored in properties of the so-called *global
      object*.

      -  They are created in the top level of a script, via ``var`` and function
         declarations.
      -  The global object can be accessed via the global variable ``globalThis``.
         It can be used to create, read, and delete global object variables.
      -  Other than that, global object variables work like normal variables.

   The following HTML fragment demonstrates ``globalThis`` and the two kinds of
   global variables.

   .. code:: language-html

      <script>
      const declarativeVariable = 'd';
      var objectVariable = 'o';
      </script>
      <script>
      // All scripts share the same top-level scope:
      console.log(declarativeVariable); // 'd'
      console.log(objectVariable); // 'o'
      
      // Not all declarations create properties of the global object:
      console.log(globalThis.declarativeVariable); // undefined
      console.log(globalThis.objectVariable); // 'o'
      </script>

   Each ECMAScript module has its own scope. Therefore, variables that exist at the
   top level of a module are not global. `Figure 13.1 <#fig:global-scope>`__
   illustrates how the various scopes are related.

   .. figure:: https://exploringjs.com/js/book/img-book/variables-assignment/global-scope.svg
      name: fig:global-scope
      :width: 415px
      :height: 233px

      Figure 13.1: The global scope is JavaScriptâ€™s outermost scope. It has two
      kinds of variables: *object variables* (managed via the *global object*) and
      normal *declarative variables*. Each ECMAScript module has its own scope
      which is contained in the global scope.



.. _globalThis:

13.7.1â€ƒ``globalThis`` [ES2020]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The global variable ``globalThis`` is the new standard way of accessing the
   global object. It got its name from the fact that it has the same value as
   ``this`` in global scope (script scope, not module scope).

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**``globalThis`` does not always directly point to the
      global object**

      .. container:: boxout-vspace

      For example, in browsers, `there is an
      indirection <https://exploringjs.com/deep-js/ch_global-scope.html#window-proxy>`__.
      That indirection is normally not noticable, but it is there and can be
      observed.

13.7.1.1â€ƒAlternatives to ``globalThis``
''''''''''''''''''''''''''''''''''''''''

   The following global variables let us access the global object on *some*
   platforms:

   -  ``window``: The classic way of referring to the global object. But it doesnâ€™t
      work in Node.js and in Web Workers.
   -  ``self``: Available in Web Workers and browsers in general. But it isnâ€™t
      supported by Node.js.
   -  ``global``: Only available in Node.js.

   ============= ===================== ============= ============
   |             |Main browser thread  |Web Workers  |Node.js
   |globalThis   |âœ”                    |âœ”            |âœ”
   |window       |âœ”                    |             |
   |self         |âœ”                    |âœ”            |
   |global       |                     |             |âœ”
   ============= ===================== ============= ============


13.7.1.2â€ƒUse cases for ``globalThis``
''''''''''''''''''''''''''''''''''''''

   The global object is now considered a mistake that JavaScript canâ€™t get rid of,
   due to backward compatibility. It affects performance negatively and is
   generally confusing.

   ECMAScript 6 introduced several features that make it easier to avoid the global
   object â€“ for example:

   -  ``const``, ``let``, and class declarations donâ€™t create global object
      properties when used in global scope.
   -  Each ECMAScript module has its own local scope.

   It is usually better to access global object variables via variables and not via
   properties of ``globalThis``. The former has always worked the same on all
   JavaScript platforms.

   Tutorials on the web occasionally access global variables ``globVar`` via
   ``window.globVar``. But the prefix â€œ\ ``window.``\ â€ is not necessary and I
   recommend to omit it:

   .. code:: javascript

      window.encodeURIComponent(str); // no
      encodeURIComponent(str); // yes

   Therefore, there are relatively few use cases for ``globalThis`` â€“ for example:

   -  `Polyfills <#polyfills>`__ that add new features to old
      JavaScript engines.
   -  Feature detection, to find out what features a JavaScript engine supports.



.. _declarations-scope-activation:

13.8â€ƒDeclarations: scope and activation
----------------------------------------

   These are two key aspects of declarations:

   -  Scope: Where can a declared entity be seen? This is a static trait.
   -  Activation: When can I access an entity? This is a dynamic trait. Some
      entities can be accessed as soon as we enter their scopes. For others, we
      have to wait until execution reaches their declarations.

   `Table 13.1 <#tbl:aspects-of-declarations>`__ summarizes how various
   declarations handle these aspects.

   ========= ========== ================= =========== ===============
   \         Scope      Activation        Duplicates   Global prop.
   const     Block      decl. (TDZ)       âœ˜            âœ˜
   let       Block      decl. (TDZ)       âœ˜            âœ˜
   function  Block (*)  start             âœ”            âœ”
   class     Block      decl. (TDZ)       âœ˜            âœ˜
   import    Module     same as export    âœ˜            âœ˜
   var       Function   start, partially  âœ”            âœ”
   ========= ========== ================= =========== ===============

   Table 13.1: Aspects of declarations:

   -  â€œDuplicatesâ€ describes if a declaration can be used twice with the same name
      (per scope).
   -  â€œGlobal prop.â€ describes if a declaration adds a property to the global
      object, when it is executed in the global scope of a script.
   -  *TDZ* means *temporal dead zone* (which is explained later).

   (\*) Function declarations are normally block-scoped, but function-scoped in
   `sloppy mode <#strict-mode>`__.

   ``import`` is described in `â€œECMAScript modulesâ€
   (Â§29.5) <#ecmascript-modules>`__. The following sections describe
   the other constructs in more detail.

13.8.1â€ƒ``const`` and ``let``: temporal dead zone
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   For JavaScript, TC39 needed to decide what happens if you access a constant in
   its direct scope, before its declaration:

   .. code:: javascript

      {
      console.log(x); // What happens here?
      const x;
      }

   Some possible approaches are:

   #. The name is resolved in the scope surrounding the current scope.
   #. You get ``undefined``.
   #. There is an error.

   Approach 1 was rejected because there is no precedent in the language for this
   approach. It would therefore not be intuitive to JavaScript programmers.

   Approach 2 was rejected because then ``x`` wouldnâ€™t be a constant â€“ it would
   have different values before and after its declaration.

   ``let`` uses the same approach 3 as ``const``, so that both work similarly and
   itâ€™s easy to switch between them.

   The time between entering the scope of a variable and executing its declaration
   is called the *temporal dead zone* (TDZ) of that variable:

   -  During this time, the variable is considered to be uninitialized (as if that
      were a special value it has).
   -  If you access an uninitialized variable, you get a ``ReferenceError``.
   -  Once you reach a variable declaration, the variable is set to either the
      value of the initializer (specified via the assignment symbol) or
      ``undefined`` â€“ if there is no initializer.

   The following code illustrates the temporal dead zone:

   .. code:: javascript

      if (true) { // entering scope of `tmp`, TDZ starts
      // `tmp` is uninitialized:
      assert.throws(() => (tmp = 'abc'), ReferenceError);
      assert.throws(() => console.log(tmp), ReferenceError);

      let tmp; // TDZ ends
      assert.equal(tmp, undefined);
      }

   The next example shows that the temporal dead zone is truly *temporal* (related
   to time):

   .. code:: javascript

      if (true) { // entering scope of `myVar`, TDZ starts
      const func = () => {
         console.log(myVar); // executed later
      };

      // We are within the TDZ:
      // Accessing `myVar` causes `ReferenceError`

      let myVar = 3; // TDZ ends
      func(); // OK, called outside TDZ
      }

   Even though ``func()`` is located before the declaration of ``myVar`` and uses
   that variable, we can call ``func()``. But we have to wait until the temporal
   dead zone of ``myVar`` is over.

13.8.2â€ƒFunction declarations and early activation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**More information on functions**

      .. container:: boxout-vspace

      In this section, we are using functions â€“ before we had a chance to learn
      them properly. Hopefully, everything still makes sense. Whenever it doesnâ€™t,
      please see `â€œCallable valuesâ€ (Â§27) <#ch_callables>`__.

   A function declaration is always executed when entering its scope, regardless of
   where it is located within that scope. That enables you to call a function
   ``foo()`` before it is declared:

   .. code:: javascript

      assert.equal(foo(), 123); // OK
      function foo() { return 123; }

   The early activation of ``foo()`` means that the previous code is equivalent to:

   .. code:: javascript

      function foo() { return 123; }
      assert.equal(foo(), 123);

   If you declare a function via ``const`` or ``let``, then it is not activated
   early. In the following example, you can only use ``bar()`` after its
   declaration.

   .. code:: javascript

      assert.throws(
      () => bar(), // before declaration
      ReferenceError);

      const bar = () => { return 123; };

      assert.equal(bar(), 123); // after declaration 

13.8.2.1â€ƒCalling ahead without early activation
''''''''''''''''''''''''''''''''''''''''''''''''

   Even if a function ``g()`` is not activated early, it can be called by a
   preceding function ``f()`` (in the same scope) if we adhere to the following
   rule: ``f()`` must be invoked after the declaration of ``g()``.

   .. code:: javascript

      const f = () => g();
      const g = () => 123;

      // We call f() after g() was declared:
      assert.equal(f(), 123);

   The functions of a module are usually invoked after its complete body is
   executed. Therefore, in modules, you rarely need to worry about the order of
   functions.

   Lastly, note how early activation automatically keeps the aforementioned rule:
   when entering a scope, all function declarations are executed first, before any
   calls are made.

13.8.2.2â€ƒA pitfall of early activation
'''''''''''''''''''''''''''''''''''''''

   If you rely on early activation to call a function before its declaration, then
   you need to be careful that it doesnâ€™t access data that isnâ€™t activated early.

   .. code:: javascript

      funcDecl();

      const MY_STR = 'abc';
      function funcDecl() {
      assert.throws(
         () => MY_STR,
         ReferenceError);
      }

   The problem goes away if you make the call to ``funcDecl()`` after the
   declaration of ``MY_STR``.

13.8.2.3â€ƒThe pros and cons of early activation
'''''''''''''''''''''''''''''''''''''''''''''''

   We have seen that early activation has a pitfall and that you can get most of
   its benefits without using it. Therefore, it is better to avoid early
   activation. But I donâ€™t feel strongly about this and, as mentioned before, often
   use function declarations because I like their syntax.

13.8.3â€ƒClass declarations are not activated early
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Even though they are similar to function declarations in some ways, `class
   declarations <#classes>`__ are not activated early:

   .. code:: javascript

      assert.throws(
      () => new MyClass(),
      ReferenceError);

      class MyClass {}

      assert.equal(new MyClass() instanceof MyClass, true);

   Why is that? Consider the following class declaration:

   .. code:: javascript

      class MyClass extends Object {}

   The operand of ``extends`` is an expression. Therefore, you can do things like
   this:

   .. code:: javascript

      const identity = x => x;
      class MyClass extends identity(Object) {}

   Evaluating such an expression must be done at the location where it is
   mentioned. Anything else would be confusing. That explains why class
   declarations are not activated early.

13.8.4â€ƒ``var``: hoisting (partial early activation)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``var`` is an older way of declaring variables that predates ``const`` and
   ``let`` (which are preferred now). Consider the following ``var`` declaration.

   .. code:: javascript

      var x = 123;

   This declaration has two parts:

   -  Declaration ``var x``: The scope of a ``var``-declared variable is the
      innermost surrounding function and not the innermost surrounding block, as
      for most other declarations. Such a variable is already active at the
      beginning of its scope and initialized with ``undefined``.
   -  Assignment ``x = 123``: The assignment is always executed in place.

   The following code demonstrates the effects of ``var``:

   .. code:: javascript

      function f() {
      // Partial early activation:
      assert.equal(x, undefined);
      if (true) {
         var x = 123;
         // The assignment is executed in place:
         assert.equal(x, 123);
      }
      // Scope is function, not block:
      assert.equal(x, 123);
      }

13.9â€ƒClosures
--------------

   Before we can explore closures, we need to learn about bound variables and free
   variables.



.. _bound-variables-vs-free-variables:

13.9.1â€ƒBound variables vs. free variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Per scope, there is a set of variables that are mentioned. Among these variables
   we distinguish:

   -  *Bound variables* are declared within the scope. They are parameters and
      local variables.
   -  *Free variables* are declared externally. They are also called *non-local
      variables*.

   Consider the following code:

   .. code:: javascript

      function func(x) {
      const y = 123;
      console.log(z);
      }

   In the body of ``func()``, ``x`` and ``y`` are bound variables. ``z`` is a free
   variable.

13.9.2â€ƒWhat is a closure?
~~~~~~~~~~~~~~~~~~~~~~~~~~

   What is a closure then?

      A *closure* is a function plus a connection to the variables that exist at
      its â€œbirth placeâ€.

   What is the point of keeping this connection? It provides the values for the
   free variables of the function â€“ for example:

   .. code:: javascript

      function funcFactory(value) {
      return () => {
         return value;
      };
      }

      const func = funcFactory('abc');
      assert.equal(func(), 'abc'); // (A)

   ``funcFactory`` returns a closure that is assigned to ``func``. Because ``func``
   has the connection to the variables at its birth place, it can still access the
   free variable ``value`` when it is called in line A (even though it â€œescapedâ€
   its scope).

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**All functions in JavaScript are closures**

      .. container:: boxout-vspace

      Static scoping is supported via closures in JavaScript. Therefore, every
      function is a closure.

13.9.3â€ƒExample: A factory for incrementors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following function returns *incrementors* (a name that I just made up). An
   incrementor is a function that internally stores a number. When it is called, it
   updates that number by adding the argument to it and returns the new value.

   .. code:: javascript

      function createInc(startValue) {
      return (step) => { // (A)
         startValue += step;
         return startValue;
      };
      }
      const inc = createInc(5);
      assert.equal(inc(2), 7);

   We can see that the function created in line A keeps its internal number in the
   free variable ``startValue``. This time, we donâ€™t just read from the birth
   scope, we use it to store data that we change and that persists across function
   calls.

   We can create more storage slots in the birth scope, via local variables:

   .. code:: javascript

      function createInc(startValue) {
      let index = -1;
      return (step) => {
         startValue += step;
         index++;
         return [index, startValue];
      };
      }
      const inc = createInc(5);
      assert.deepEqual(inc(2), [0, 7]);
      assert.deepEqual(inc(2), [1, 9]);
      assert.deepEqual(inc(2), [2, 11]);

13.9.4â€ƒUse cases for closures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   What are closures good for?

   -  For starters, they are simply an implementation of static scoping. As such,
      they provide context data for callbacks.

   -  They can also be used by functions to store state that persists across
      function calls. ``createInc()`` is an example of that.

   -  And they can provide private data for objects (produced via literals or
      classes). The details of how that works are explained in `Exploring
      ES6 <https://exploringjs.com/es6/ch_classes.html#_private-data-via-constructor-environments>`__.

   `Comments <https://github.com/rauschma/exploring-js/issues/6>`__



.. _ch_values:

14â€ƒValues
==========

   #. `14.1â€ƒWhatâ€™s a type? <#what-s-a-type>`__
   #. `14.2â€ƒJavaScriptâ€™s type hierarchy <#javascript-s-type-hierarchy>`__
   #. `14.3â€ƒThe types of the language specification <#the-types-of-the-language-specification>`__
   #. `14.4â€ƒPrimitive values vs. objects <#primitive-values-vs-objects>`__

      #. `14.4.1â€ƒPrimitive values (short: primitives) <#primitive-values-short-primitives>`__
      #. `14.4.2â€ƒObjects <#objects>`__

   #. `14.5â€ƒThe operators typeof and instanceof: whatâ€™s the type of a value? <#the-operators-typeof-and-instanceof-what-s-the-type-of-a-value>`__

      #. `14.5.1â€ƒtypeof <#typeof>`__
      #. `14.5.2â€ƒinstanceof <#instanceof>`__

   #. `14.6â€ƒClasses and constructor functions <#classes-and-constructor-functions>`__

      #. `14.6.1â€ƒConstructor functions associated with primitive types <#constructor-functions-associated-with-primitive-types>`__

   #. `14.7â€ƒConverting between types <#converting-between-types>`__

      #. `14.7.1â€ƒExplicit conversion between types <#explicit-conversion-between-types>`__
      #. `14.7.2â€ƒCoercion (automatic conversion between types) <#coercion-automatic-conversion-between-types>`__

   In this chapter, weâ€™ll examine what kinds of values JavaScript has.

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**Supporting tool: ``===``**

      .. container:: boxout-vspace

      In this chapter, weâ€™ll occasionally use the strict equality operator.
      ``a === b`` evaluates to ``true`` if ``a`` and ``b`` are equal. What exactly
      that means is explained in `â€œStrict equality (``===`` and ``!==``)â€
      (Â§15.4.2) <#strict-equality>`__.



.. _what-s-a-type:

14.1â€ƒWhatâ€™s a type?
--------------------

   For this chapter, I consider types to be sets of values â€“ for example, the type
   ``boolean`` is the set { ``false``, ``true`` }.



.. _javascript-s-type-hierarchy:

14.2â€ƒJavaScriptâ€™s type hierarchy
---------------------------------

   .. code::

                              â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                              â”‚       (any)       â”‚
                              â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                        â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
               â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
               â”‚ (primitive value) â”‚         â”‚      (object)     â”‚
               â•°â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â•¯
                        â”‚                          â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®
                        â”‚                          â”‚ Object â”‚
                        â”‚                          â•°â”€â”€â”€â”€â”¬â”€â”€â”€â•¯
         â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   
         â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â”‚  â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚   
         â”‚ â”‚ boolean â”‚   â”‚ symbol  â”‚   â”‚  â”‚ â”‚        Function         â”‚ â”‚   
         â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â”‚  â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚   
         â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚  â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®  â”‚   
         â”‚ â”‚ number  â”‚   â”‚ undefined â”‚ â”‚  â”‚  â”‚ BigInt â”‚     â”‚  Set   â”‚  â”‚   
         â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚  â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯  â”‚   
         â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®   â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚  â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®  â”‚   
         â”‚ â”‚ string  â”‚   â”‚   null    â”‚ â”‚  â”‚  â”‚ Array  â”‚     â”‚  Date  â”‚  â”‚   
         â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚  â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯  â”‚   
         â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯  â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®     â•­â”€â”€â”€â”€â”€â”€â”€â”€â•®  â”‚   
                                          â”‚  â”‚  Map   â”‚     â”‚ RegExp â”‚  â”‚   
                                          â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â•°â”€â”€â”€â”€â”€â”€â”€â”€â•¯  â”‚   
                                          â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯   

   .. figure:: https://exploringjs.com/js/book/img-book/values/type_hierarchy.svg
      name: fig:type_hierarchy
      :width: 429px
      :height: 259px

      Figure 14.1: A partial hierarchy of JavaScriptâ€™s types. Missing are the
      classes for errors, the classes associated with primitive types, and more.
      The diagram hints at the fact that not all objects are instances of
      ``Object``.

   `Figure 14.1 <#fig:type_hierarchy>`__ shows JavaScriptâ€™s type hierarchy. What do
   we learn from that diagram?

   -  JavaScript distinguishes two kinds of values: primitive values and objects.
      Weâ€™ll see soon what the difference is.
   -  The diagram differentiates objects and instances of class ``Object``. Each
      instance of ``Object`` is also an object, but not vice versa. However,
      virtually all objects that youâ€™ll encounter in practice are instances of
      ``Object`` â€“ for example, objects created via object literals. More details
      on this topic are explained in `â€œNot all objects are instances of
      ``Object``\ â€ (Â§31.7.3) <#non-instances-of-object>`__.

14.3â€ƒThe types of the language specification
---------------------------------------------

   The ECMAScript specification only knows a total of eight types. The names of
   those types are (Iâ€™m using TypeScriptâ€™s names, not the specâ€™s names):

   -  ``undefined`` with the only element ``undefined``
   -  ``null`` with the only element ``null``
   -  ``boolean`` with the elements ``false`` and ``true``
   -  ``number`` the type of all numbers (e.g., ``-123``, ``3.141``)
   -  ``bigint`` the type of all big integers (e.g., ``-123n``)
   -  ``string`` the type of all strings (e.g., ``'abc'``)
   -  ``symbol`` the type of all symbols (e.g., ``Symbol('My Symbol')``)
   -  ``object`` the type of all objects (different from ``Object``, the type of
      all instances of class ``Object`` and its subclasses)



.. _primitive-values-vs-objects:

14.4â€ƒPrimitive values vs. objects
----------------------------------

   The specification makes an important distinction between values:

   -  *Primitive values* are the elements of the types ``undefined``, ``null``,
      ``boolean``, ``number``, ``bigint``, ``string``, ``symbol``.
   -  All other values are *objects*.

   In contrast to Java (that inspired JavaScript here), primitive values are not
   second-class citizens. The difference between them and objects is more subtle.
   In a nutshell:

   -  Primitive values: are atomic building blocks of data in JavaScript.

      -  They are *passed by value*: when primitive values are assigned to
         variables or passed to functions, their contents are copied.
      -  They are *compared by value*: when comparing two primitive values, their
         contents are compared.

   -  Objects: are compound pieces of data.

      -  They are *passed by identity* (my term): when objects are assigned to
         variables or passed to functions, their *identities* (think pointers) are
         copied.
      -  They are *compared by identity* (my term): when comparing two objects,
         their identities are compared.

   Other than that, primitive values and objects are quite similar: they both have
   *properties* (key-value entries) and can be used in the same locations.

   Next, weâ€™ll look at primitive values and objects in more depth.

14.4.1â€ƒPrimitive values (short: primitives)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

14.4.1.1â€ƒPrimitives are immutable
''''''''''''''''''''''''''''''''''

   You canâ€™t change, add, or remove properties of primitives:

   .. code:: javascript

      const str = 'abc';
      assert.equal(str.length, 3);
      assert.throws(
      () => { str.length = 1 },
      /^TypeError: Cannot assign to read only property 'length'/
      );

14.4.1.2â€ƒPrimitives are passed by value
''''''''''''''''''''''''''''''''''''''''

   Primitives are *passed by value*: variables (including parameters) store the
   contents of the primitives. When assigning a primitive value to a variable or
   passing it as an argument to a function, its content is copied.

   .. code:: javascript

      const x = 123;
      const y = x;
      // `y` is the same as any other number 123
      assert.equal(y, 123);

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Observing the difference between passing by value and
      passing by reference**

      .. container:: boxout-vspace

      Due to primitive values being immutable and compared by value (see next
      subsection), there is no way to observe the difference between passing by
      value and passing by identity (as used for objects in JavaScript).

14.4.1.3â€ƒPrimitives are compared by value
''''''''''''''''''''''''''''''''''''''''''

   Primitives are *compared by value*: when comparing two primitive values, we
   compare their contents.

   .. code:: javascript

      assert.equal(123 === 123, true);
      assert.equal('abc' === 'abc', true);

   To see whatâ€™s so special about this way of comparing, read on and find out how
   objects are compared.

14.4.2â€ƒObjects
~~~~~~~~~~~~~~~

   Objects are covered in detail in `â€œObjectsâ€
   (Â§30) <#ch_objects>`__ and the following chapter. Here, we mainly
   focus on how they differ from primitive values.

   Letâ€™s first explore two common ways of creating objects:

   -  Object literal:

      .. code:: javascript

         const obj = {
         first: 'Jane',
         last: 'Doe',
         };

      The object literal starts and ends with curly braces ``{}``. It creates an
      object with two properties. The first property has the key ``'first'`` (a
      string) and the value ``'Jane'``. The second property has the key ``'last'``
      and the value ``'Doe'``. For more information on object literals, consult
      `â€œObject literals: propertiesâ€
      (Â§30.3.1) <#object-literals>`__.

   -  Array literal:

      .. code:: javascript

         const fruits = ['strawberry', 'apple'];

      The Array literal starts and ends with square brackets ``[]``. It creates an
      Array with two *elements*: ``'strawberry'`` and ``'apple'``. For more
      information on Array literals, consult `â€œCreating, reading, writing Arraysâ€
      (Â§33.3.1) <#array-literals>`__.

14.4.2.1â€ƒObjects are mutable by default
''''''''''''''''''''''''''''''''''''''''

   By default, you can freely change, add, and remove the properties of objects:

   .. code:: javascript

      const obj = {};

      obj.count = 2; // add a property
      assert.equal(obj.count, 2);

      obj.count = 3; // change a property
      assert.equal(obj.count, 3);

14.4.2.2â€ƒObjects are passed by identity
''''''''''''''''''''''''''''''''''''''''

   Objects are *passed by identity* (my term): variables (including parameters)
   store the *identities* of objects.

   The identity of an object is like a pointer (or a transparent reference) to the
   objectâ€™s actual data on the *heap* (think shared main memory of a JavaScript
   engine).

   When assigning an object to a variable or passing it as an argument to a
   function, its identity is copied. Each object literal creates a fresh object on
   the heap and returns its identity.

   .. code:: javascript

      const a = {}; // fresh empty object
      // Pass the identity in `a` to `b`:
      const b = a;

      // Now `a` and `b` point to the same object
      // (they â€œshareâ€ that object):
      assert.equal(a === b, true);

      // Changing `a` also changes `b`:
      a.name = 'Tessa';
      assert.equal(b.name, 'Tessa');

   JavaScript uses *garbage collection* to automatically manage memory:

   .. code:: javascript

      let obj = { prop: 'value' };
      obj = {};

   Now the old value ``{ prop: 'value' }`` of ``obj`` is *garbage* (not used
   anymore). JavaScript will automatically *garbage-collect* it (remove it from
   memory), at some point in time (possibly never if there is enough free memory).

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Details: passing by identity**

      .. container:: boxout-vspace

      â€œPassing by identityâ€ means that the identity of an object (a transparent
      reference) is passed by value. This approach is also called `â€œpassing by
      sharingâ€ <https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing>`__.

14.4.2.3â€ƒObjects are compared by identity
''''''''''''''''''''''''''''''''''''''''''

   Objects are *compared by identity* (my term): two variables are only equal if
   they contain the same object identity. They are not equal if they refer to
   different objects with the same content.

   .. code:: javascript

      const obj = {}; // fresh empty object
      assert.equal(obj === obj, true); // same identity
      assert.equal({} === {}, false); // different identities, same content



.. _the-operators-typeof-and-instanceof-what-s-the-type-of-a-value:

14.5â€ƒThe operators ``typeof`` and ``instanceof``: whatâ€™s the type of a value?
------------------------------------------------------------------------------

   The two operators ``typeof`` and ``instanceof`` let you determine what type a
   given value ``x`` has:

   .. code:: javascript

      if (typeof x === 'string') Â·Â·Â·
      if (x instanceof Array) Â·Â·Â·

   How do they differ?

   -  ``typeof`` distinguishes the 7 types of the specification (minus one
      omission, plus one addition).
   -  ``instanceof`` tests which class created a given value.

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Rule of thumb: ``typeof`` is for primitive values;
      ``instanceof`` is for objects**

      .. container:: boxout-vspace

14.5.1â€ƒ``typeof``
~~~~~~~~~~~~~~~~~~

   ================== =====================
   x                  typeof x
   undefined          'undefined'
   null               'object'
   Boolean            'boolean'
   Number             'number'
   Bigint             'bigint'
   String             'string'
   Symbol             'symbol'
   Function           'function'
   All other objects  'object'
   ================== =====================

   Table 14.1: The results of the ``typeof`` operator.

   `Table 14.1 <#tbl:typeof-results>`__ lists all results of ``typeof``. They
   roughly correspond to the 7 types of the language specification. Alas, there are
   two differences, and they are language quirks:

   -  ``typeof null`` returns ``'object'`` and not ``'null'``. Thatâ€™s a bug.
      Unfortunately, it canâ€™t be fixed. TC39 tried to do that, but it broke too
      much code on the web.
   -  ``typeof`` of a function should be ``'object'`` (functions are objects).
      Introducing a separate category for functions is confusing.

   These are a few examples of using ``typeof``:

   .. code:: javascript
      :name: language-node-repl

      > typeof undefined
      'undefined'
      > typeof 123n
      'bigint'
      > typeof 'abc'
      'string'
      > typeof {}
      'object'

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercises: Two exercises on ``typeof``**

      .. container:: boxout-vspace

      -  ``exercises/values/typeof_exrc.mjs``
      -  Bonus: ``exercises/values/is_object_test.mjs``

14.5.2â€ƒ``instanceof``
~~~~~~~~~~~~~~~~~~~~~~

   This operator answers the question: has a value ``x`` been created by a class
   ``C``?

   .. code:: javascript

      x instanceof C

   For example:

   .. code:: javascript
      :name: language-node-repl

      > (function() {}) instanceof Function
      true
      > ({}) instanceof Object
      true
      > [] instanceof Array
      true

   Primitive values are not instances of anything:

   .. code:: javascript
      :name: language-node-repl

      > 123 instanceof Number
      false
      > '' instanceof String
      false
      > '' instanceof Object
      false

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: ``instanceof``**

      .. container:: boxout-vspace

      ``exercises/values/instanceof_exrc.mjs``

14.6â€ƒClasses and constructor functions
---------------------------------------

   JavaScriptâ€™s original factories for objects are *constructor functions*:
   ordinary functions that return â€œinstancesâ€ of themselves if you invoke them via
   the ``new`` operator.

   ES6 introduced *classes*, which are mainly better syntax for constructor
   functions.

   In this book, Iâ€™m using the terms *constructor function* and *class*
   interchangeably.

   Classes can be seen as partitioning the single type ``object`` of the
   specification into subtypes â€“ they give us more types than the limited 7 ones of
   the specification. Each class is the type of the objects that were created by
   it.

14.6.1â€ƒConstructor functions associated with primitive types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Each primitive type (except for the spec-internal types for ``undefined`` and
   ``null``) has an associated *constructor function* (think class):

   -  The constructor function ``Boolean`` is associated with booleans.
   -  The constructor function ``Number`` is associated with numbers.
   -  The constructor function ``String`` is associated with strings.
   -  The constructor function ``Symbol`` is associated with symbols.

   Each of these functions plays several roles â€“ for example, ``Number``:

   -  You can use it as a function and convert values to numbers:

      .. code:: javascript

         assert.equal(Number('123'), 123);

   -  ``Number.prototype`` provides the properties for numbers â€“ for example,
      method ``.toString()``:

      .. code:: javascript

         assert.equal((123).toString, Number.prototype.toString);

   -  ``Number`` is a namespace/container object for tool functions for numbers â€“
      for example:

      .. code:: javascript

         assert.equal(Number.isInteger(123), true);

   -  Lastly, you can also use ``Number`` as a class and create number objects.
      These objects are different from real numbers and should be avoided.

      .. code:: javascript

         assert.notEqual(new Number(123), 123);
         assert.equal(new Number(123).valueOf(), 123);

14.6.1.1â€ƒWrapping primitive values
'''''''''''''''''''''''''''''''''''

   The constructor functions related to primitive types are also called *wrapper
   types* because they provide the canonical way of converting primitive values to
   objects. In the process, primitive values are â€œwrappedâ€ in objects.

   .. code:: javascript

      const prim = true;
      assert.equal(typeof prim, 'boolean');
      assert.equal(prim instanceof Boolean, false);

      const wrapped = Object(prim);
      assert.equal(typeof wrapped, 'object');
      assert.equal(wrapped instanceof Boolean, true);

      assert.equal(wrapped.valueOf(), prim); // unwrap

   Wrapping rarely matters in practice, but it is used internally in the language
   specification, to give primitives properties.

14.7â€ƒConverting between types
------------------------------

   There are two ways in which values are converted to other types in JavaScript:

   -  Explicit conversion: via functions such as ``String()``.
   -  *Coercion* (automatic conversion): happens when an operation receives
      operands/parameters that it canâ€™t work with.

14.7.1â€ƒExplicit conversion between types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The function associated with a primitive type explicitly converts values to that
   type:

   .. code:: javascript
      :name: language-node-repl

      > Boolean(0)
      false
      > Number('123')
      123
      > String(123)
      '123'

   You can also use ``Object()`` to convert values to objects:

   .. code:: javascript
      :name: language-node-repl

      > typeof Object(123)
      'object'

   The following table describes in more detail how this conversion works:

   =========== ============================================
   x           Object(x)
   undefined   {}
   null        {}
   boolean     new Boolean(x)
   number      new Number(x)
   bigint      An instance of BigInt (new throws TypeError)
   string      new String(x)
   symbol      An instance of Symbol (new throws TypeError)
   object      x
   =========== ============================================

14.7.2â€ƒCoercion (automatic conversion between types)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   For many operations, JavaScript automatically converts the operands/parameters
   if their types donâ€™t fit. This kind of automatic conversion is called
   *coercion*.

   For example, the multiplication operator coerces its operands to numbers:

   .. code:: javascript
      :name: language-node-repl

      > '7' * '3'
      21

   Many built-in functions coerce, too. For example, ``Number.parseInt()`` coerces
   its parameter to a string before parsing it. That explains the following result:

   .. code:: javascript
      :name: language-node-repl

      > Number.parseInt(123.45)
      123

   The number ``123.45`` is converted to the string ``'123.45'`` before it is
   parsed. Parsing stops before the first non-digit character, which is why the
   result is ``123``.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Converting values to primitives**

      .. container:: boxout-vspace

      ``exercises/values/conversion_exrc.mjs``

   `Comments <https://github.com/rauschma/exploring-js/issues/7>`__



.. _ch_operators:

15â€ƒOperators
=============

   #. `15.1â€ƒMaking sense of operators <#making-sense-of-operators>`__

      #. `15.1.1â€ƒOperators coerce their operands to appropriate types <#operators-coerce-their-operands-to-appropriate-types>`__
      #. `15.1.2â€ƒMost operators only work with primitive values <#most-operators-only-work-with-primitive-values>`__

   #. `15.2â€ƒThe plus operator (+) <#the-plus-operator>`__
   #. `15.3â€ƒAssignment operators <#assignment-operators>`__

      #. `15.3.1â€ƒThe plain assignment operator <#the-plain-assignment-operator>`__
      #. `15.3.2â€ƒCompound assignment operators <#compound-assignment-operators>`__

   #. `15.4â€ƒEquality: == vs. === <#equality-vs>`__

      #. `15.4.1â€ƒLoose equality (== and !=) <#loose-equality-and>`__
      #. `15.4.2â€ƒStrict equality (=== and !==) <#strict-equality>`__
      #. `15.4.3â€ƒRecommendation: always use strict equality <#recommendation-always-strict-equality>`__
      #. `15.4.4â€ƒEven stricter than ===: Object.is() <#Object.is>`__

   #. `15.5â€ƒOrdering operators <#ordering-operators>`__
   #. `15.6â€ƒVarious other operators <#various-other-operators>`__

      #. `15.6.1â€ƒComma operator <#comma-operator>`__
      #. `15.6.2â€ƒvoid operator <#void-operator>`__

15.1â€ƒMaking sense of operators
-------------------------------

   JavaScriptâ€™s operators may seem quirky. With the following two rules, they are
   easier to understand:

   -  Operators coerce their operands to appropriate types
   -  Most operators only work with primitive values

15.1.1â€ƒOperators coerce their operands to appropriate types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If an operator gets operands that donâ€™t have the proper types, it rarely throws
   an exception. Instead, it *coerces* (automatically converts) the operands so
   that it can work with them. Letâ€™s look at two examples.

   First, the multiplication operator can only work with numbers. Therefore, it
   converts strings to numbers before computing its result.

   .. code:: javascript
      :name: language-node-repl

      > '7' * '3'
      21

   Second, the square brackets operator (``[ ]``) for accessing the properties of
   an object can only handle strings and symbols. All other values are coerced to
   string:

   .. code:: javascript

      const obj = {};
      obj['true'] = 123;

      // Coerce true to the string 'true'
      assert.equal(obj[true], 123);

15.1.2â€ƒMost operators only work with primitive values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   As mentioned before, most operators only work with primitive values. If an
   operand is an object, it is usually coerced to a primitive value â€“ for example:

   .. code:: javascript
      :name: language-node-repl

      > [1,2,3] + [4,5,6]
      '1,2,34,5,6'

   Why? The plus operator first coerces its operands to primitive values:

   .. code:: javascript
      :name: language-node-repl

      > String([1,2,3])
      '1,2,3'
      > String([4,5,6])
      '4,5,6'

   Next, it concatenates the two strings:

   .. code:: javascript
      :name: language-node-repl

      > '1,2,3' + '4,5,6'
      '1,2,34,5,6'

15.2â€ƒThe plus operator (``+``)
-------------------------------

   The plus operator works as follows in JavaScript:

   -  First, it converts both operands to primitive values. Then it switches to one
      of two modes:

      -  String mode: If one of the two primitive values is a string, then it
         converts the other one to a string, concatenates both strings, and returns
         the result.
      -  Number mode: Otherwise, It converts both operands to numbers, adds them,
         and returns the result.

   String mode lets us use ``+`` to assemble strings:

   .. code:: javascript
      :name: language-node-repl

      > 'There are ' + 3 + ' items'
      'There are 3 items'

   Number mode means that if neither operand is a string (or an object that becomes
   a string) then everything is coerced to numbers:

   .. code:: javascript
      :name: language-node-repl

      > 4 + true
      5

   ``Number(true)`` is ``1``.

15.3â€ƒAssignment operators
--------------------------

15.3.1â€ƒThe plain assignment operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The plain assignment operator is used to change storage locations:

   .. code:: javascript

      x = value; // assign to a previously declared variable
      obj.propKey = value; // assign to a property
      arr[index] = value; // assign to an Array element

   Initializers in variable declarations can also be viewed as a form of
   assignment:

   .. code:: javascript

      const x = value;
      let y = value;

15.3.2â€ƒCompound assignment operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScript supports the following assignment operators:

   -  Arithmetic assignment operators: ``+= -= *= /= %=`` :sup:`[ES1]`

      -  ``+=`` can also be used for string concatenation
      -  Introduced later: ``**=`` :sup:`[ES2016]`

   -  Bitwise assignment operators: ``&= ^= |=`` :sup:`[ES1]`
   -  Bitwise shift assignment operators: ``<<= >>= >>>=`` :sup:`[ES1]`
   -  Logical assignment operators: ``||= &&= ??=`` :sup:`[ES2021]`



.. _logical-assignment-operators:

15.3.2.1â€ƒLogical assignment operators [ES2021]
'''''''''''''''''''''''''''''''''''''''''''''''

   Logical assignment operators work differently from other compound assignment
   operators:
   ===================  ================  =======================
   Assignment operator  Equivalent to     Only assigns if a is
   ``a ||= b``          ``a || (a = b)``  Falsy
   ``a &&= b``          ``a && (a = b)``  Truthy
   ``a ??= b``          ``a ?? (a = b)``  Nullish
   ===================  ================  =======================

   Why is ``a ||= b`` equivalent to the following expression?

      ``a || (a = b)``

   Why not to this expression?

      ``a = a || b``

   The former expression has the benefit of
   `short-circuiting <#short-circuiting>`__: The assignment is only
   evaluated if ``a`` evaluates to ``false``. Therefore, the assignment is only
   performed if itâ€™s necessary. In contrast, the latter expression always performs
   an assignment.

   For more on ``??=``, see `â€œThe nullish coalescing assignment operator (``??=``)â€
   (Â§16.4.5) <#nullish-coalescing-assignment-operator>`__.

15.3.2.2â€ƒThe remaining compound assignment operators
'''''''''''''''''''''''''''''''''''''''''''''''''''''

   For operators ``op`` other than ``|| && ??``, the following two ways of
   assigning are equivalent:

   .. code:: language-txt

      myvar op= value
      myvar = myvar op value

   If, for example, ``op`` is ``+``, then we get the operator ``+=`` that works as
   follows.

   .. code:: javascript

      let str = '';
      str += '<b>';
      str += 'Hello!';
      str += '</b>';

      assert.equal(str, '<b>Hello!</b>');



.. _equality-vs:

15.4â€ƒEquality: ``==`` vs. ``===``
----------------------------------

   JavaScript has two kinds of equality operators: loose equality (``==``) and
   strict equality (``===``). The recommendation is to always use the latter.

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Other names for ``==`` and ``===``**

      .. container:: boxout-vspace

      -  ``==`` is also called *double equals*. Its official name in the language
         specification is `abstract equality
         comparison <https://tc39.es/ecma262/#sec-abstract-equality-comparison>`__.
      -  ``===`` is also called *triple equals*.

15.4.1â€ƒLoose equality (``==`` and ``!=``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Loose equality is one of JavaScriptâ€™s quirks. It often coerces operands. Some of
   those coercions make sense:

   .. code:: javascript
      :name: language-node-repl

      > '123' == 123
      true
      > false == 0
      true

   Others less so:

   .. code:: javascript
      :name: language-node-repl

      > '' == 0
      true

   Objects are coerced to primitives if (and only if!) the other operand is
   primitive:

   .. code:: javascript
      :name: language-node-repl

      > [1, 2, 3] == '1,2,3'
      true
      > ['1', '2', '3'] == '1,2,3'
      true

   If both operands are objects, they are only equal if they are the same object:

   .. code:: javascript
      :name: language-node-repl

      > [1, 2, 3] == ['1', '2', '3']
      false
      > [1, 2, 3] == [1, 2, 3]
      false

      > const arr = [1, 2, 3];
      > arr == arr
      true

   Lastly, ``==`` considers ``undefined`` and ``null`` to be equal:

   .. code:: javascript
      :name: language-node-repl

      > undefined == null
      true



.. _strict-equality:

15.4.2â€ƒStrict equality (``===`` and ``!==``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Strict equality never coerces. Two values are only equal if they have the same
   type. Letâ€™s revisit our previous interaction with the ``==`` operator and see
   what the ``===`` operator does:

   .. code:: javascript
      :name: language-node-repl

      > false === 0
      false
      > '123' === 123
      false

   An object is only equal to another value if that value is the same object:

   .. code:: javascript
      :name: language-node-repl

      > [1, 2, 3] === '1,2,3'
      false
      > ['1', '2', '3'] === '1,2,3'
      false

      > [1, 2, 3] === ['1', '2', '3']
      false
      > [1, 2, 3] === [1, 2, 3]
      false

      > const arr = [1, 2, 3];
      > arr === arr
      true

   The ``===`` operator does not consider ``undefined`` and ``null`` to be equal:

   .. code:: javascript
      :name: language-node-repl

      > undefined === null
      false



.. _recommendation-always-strict-equality:

15.4.3â€ƒRecommendation: always use strict equality
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   I recommend to always use ``===``. It makes your code easier to understand and
   spares you from having to think about the quirks of ``==``.

   Letâ€™s look at two use cases for ``==`` and what I recommend to do instead.

15.4.3.1â€ƒUse case for ``==``: comparing with a number or a string
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   ``==`` lets you check if a value ``x`` is a number or that number as a string â€“
   with a single comparison:

   .. code:: javascript

      if (x == 123) {
      // x is either 123 or '123'
      }

   I prefer either of the following two alternatives:

   .. code:: javascript

      if (x === 123 || x === '123') Â·Â·Â·
      if (Number(x) === 123) Â·Â·Â·

   You can also convert ``x`` to a number when you first encounter it.

15.4.3.2â€ƒUse case for ``==``: comparing with ``undefined`` or ``null``
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Another use case for ``==`` is to check if a value ``x`` is either ``undefined``
   or ``null``:

   .. code:: javascript

      if (x == null) {
      // x is either null or undefined
      }

   The problem with this code is that you canâ€™t be sure if someone meant to write
   it that way or if they made a typo and meant ``=== null``.

   I prefer either of the following two alternatives:

   .. code:: javascript

      if (x === undefined || x === null) Â·Â·Â·
      if (!x) Â·Â·Â·

   A downside of the second alternative is that it accepts values other than
   ``undefined`` and ``null``, but it is a well-established pattern in JavaScript
   (to be explained in detail in `â€œTruthiness-based existence checksâ€
   (Â§17.3) <#truthiness-existence-checks>`__).

   The following three conditions are also roughly equivalent:

   .. code:: javascript

      if (x != null) Â·Â·Â·
      if (x !== undefined && x !== null) Â·Â·Â·
      if (x) Â·Â·Â·



.. _Object.is:

15.4.4â€ƒEven stricter than ``===``: ``Object.is()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Method ``Object.is()`` compares two values:

   .. code:: javascript
      :name: language-node-repl

      > Object.is(123, 123)
      true
      > Object.is(123, '123')
      false

   It is even stricter than ``===``. For example, it considers ``NaN``, `the error
   value for computations involving numbers <#nan>`__, to be equal
   to itself:

   .. code:: javascript
      :name: language-node-repl

      > Object.is(NaN, NaN)
      true
      > NaN === NaN
      false

   That is occasionally useful. For example, you can use it to implement an
   improved version of the Array method ``.indexOf()``:

   .. code:: javascript

      const myIndexOf = (arr, elem) => {
      return arr.findIndex(x => Object.is(x, elem));
      };

   ``myIndexOf()`` finds ``NaN`` in an Array, while ``.indexOf()`` doesnâ€™t:

   .. code:: javascript
      :name: language-node-repl

      > myIndexOf([0,NaN,2], NaN)
      1
      > [0,NaN,2].indexOf(NaN)
      -1

   The result ``-1`` means that ``.indexOf()`` couldnâ€™t find its argument in the
   Array.

15.5â€ƒOrdering operators
------------------------

   ================  ==========================
   Operator          name
   <                 less than
   <=                Less than or equal
   >                 Greater than
   >=                Greater than or equal
   ================  ==========================

   Table 15.1: JavaScriptâ€™s ordering operators.

   JavaScriptâ€™s ordering operators (`table 15.1 <#tbl:ordering_operators>`__) work
   for both numbers and strings:

   .. code:: javascript
      :name: language-node-repl

      > 5 >= 2
      true
      > 'bar' < 'foo'
      true

   ``<=`` and ``>=`` are based on strict equality.

   .. container:: boxout

      |Icon â€œwarningâ€|â€‚**The ordering operators donâ€™t work well for human
      languages**

      .. container:: boxout-vspace

      The ordering operators donâ€™t work well for comparing text in a human
      language, e.g., when capitalization or accents are involved. The details are
      explained in `â€œComparing stringsâ€ (Â§22.6) <#comparing-strings>`__.

15.6â€ƒVarious other operators
-----------------------------

   The following operators are covered elsewhere in this book:

   -  Operators for `booleans <#ch_booleans>`__,
      `numbers <#ch_numbers>`__,
      `strings <#ch_strings>`__,
      `objects <#ch_objects>`__
   -  `The nullish coalescing operator (``??``) for default
      values <#nullish-coalescing-operator>`__

   The next two subsections discuss two operators that are rarely used.

15.6.1â€ƒComma operator
~~~~~~~~~~~~~~~~~~~~~~

   The comma operator has two operands, evaluates both of them and returns the
   second one:

   .. code:: javascript
      :name: language-node-repl

      > 'a', 'b'
      'b'

   For more information on this operator, see `Speaking
   JavaScript <http://exploringjs.com/es5/ch09.html#comma_operator>`__.

15.6.2â€ƒ``void`` operator
~~~~~~~~~~~~~~~~~~~~~~~~~

   The ``void`` operator evaluates its operand and returns ``undefined``:

   .. code:: javascript
      :name: language-node-repl

      > void (3 + 2)
      undefined

   For more information on this operator, see `Speaking
   JavaScript <http://exploringjs.com/es5/ch09.html#void_operator>`__.

   `Comments <https://github.com/rauschma/exploring-js/issues/8>`__




.. _ch_undefined-null:

16â€ƒThe non-values ``undefined`` and ``null``
=============================================

   #. `16.1â€ƒundefined vs. null <#undefined-vs-null>`__
   #. `16.2â€ƒOccurrences of undefined and null <#occurrences-of-undefined-and-null>`__

      #. `16.2.1â€ƒOccurrences of undefined <#occurrences-of-undefined>`__
      #. `16.2.2â€ƒOccurrences of null <#occurrences-of-null>`__

   #. `16.3â€ƒChecking for undefined or null <#checking-for-undefined-or-null>`__
   #. `16.4â€ƒThe nullish coalescing operator (??) for default values [ES2020] <#nullish-coalescing-operator>`__

      #. `16.4.1â€ƒExample: counting matches <#example-counting-matches>`__
      #. `16.4.2â€ƒExample: specifying a default value for a property <#example-specifying-a-default-value-for-a-property>`__
      #. `16.4.3â€ƒUsing destructuring for default values <#using-destructuring-for-default-values>`__
      #. `16.4.4â€ƒLegacy approach: using logical Or (||) for default values <#legacy-approach-using-logical-or-for-default-values>`__
      #. `16.4.5â€ƒThe nullish coalescing assignment operator (??=) [ES2021] <#nullish-coalescing-assignment-operator>`__

   #. `16.5â€ƒundefined and null donâ€™t have properties <#undefined-and-null-don-t-have-properties>`__
   #. `16.6â€ƒThe history of undefined and null <#the-history-of-undefined-and-null>`__

   Many programming languages have one â€œnon-valueâ€ called ``null``. It indicates
   that a variable does not currently point to an object â€“ for example, when it
   hasnâ€™t been initialized yet.

   In contrast, JavaScript has two of them: ``undefined`` and ``null``.



.. _undefined-vs-null:

16.1â€ƒ``undefined`` vs. ``null``
--------------------------------

   Both values are very similar and often used interchangeably. How they differ is
   therefore subtle. The language itself makes the following distinction:

   -  ``undefined`` means â€œnot initializedâ€ (e.g., a variable) or â€œnot existingâ€
      (e.g., a property of an object).
   -  ``null`` means â€œthe intentional absence of any object valueâ€ (a quote from
      `the language specification <https://tc39.es/ecma262/#sec-null-value>`__).

   Programmers may make the following distinction:

   -  ``undefined`` is the non-value used by the language (when something is
      uninitialized, etc.).
   -  ``null`` means â€œexplicitly switched offâ€. That is, it helps implement a type
      that comprises both meaningful values and a meta-value that stands for â€œno
      meaningful valueâ€. Such a type is called `option type or maybe
      type <https://en.wikipedia.org/wiki/Option_type>`__ in functional
      programming.

16.2â€ƒOccurrences of ``undefined`` and ``null``
-----------------------------------------------

   The following subsections describe where ``undefined`` and ``null`` appear in
   the language. Weâ€™ll encounter several mechanisms that are explained in more
   detail later in this book.

16.2.1â€ƒOccurrences of ``undefined``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Uninitialized variable ``myVar``:

   .. code:: javascript

      let myVar;
      assert.equal(myVar, undefined);

   Parameter ``x`` is not provided:

   .. code:: javascript

      function func(x) {
      return x;
      }
      assert.equal(func(), undefined);

   Property ``.unknownProp`` is missing:

   .. code:: javascript

      const obj = {};
      assert.equal(obj.unknownProp, undefined);

   If we donâ€™t explicitly specify the result of a function via a ``return``
   statement, JavaScript returns ``undefined`` for us:

   .. code:: javascript

      function func() {}
      assert.equal(func(), undefined);

16.2.2â€ƒOccurrences of ``null``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The prototype of an object is either an object or, at the end of a chain of
   prototypes, ``null``. ``Object.prototype`` does not have a prototype:

   .. code:: javascript
      :name: language-node-repl

      > Object.getPrototypeOf(Object.prototype)
      null

   If we match a regular expression (such as ``/a/``) against a string (such as
   ``'x'``), we either get an object with matching data (if matching was
   successful) or ``null`` (if matching failed):

   .. code:: javascript
      :name: language-node-repl

      > /a/.exec('x')
      null

   The `JSON data format <#ch_json>`__ does not support ``undefined``,
   only ``null``:

   .. code:: javascript
      :name: language-node-repl

      > JSON.stringify({a: undefined, b: null})
      '{"b":null}'

16.3â€ƒChecking for ``undefined`` or ``null``
--------------------------------------------

   Checking for either:

   .. code:: javascript

      if (x === null) Â·Â·Â·
      if (x === undefined) Â·Â·Â·

   Does ``x`` have a value?

   .. code:: javascript

      if (x !== undefined && x !== null) {
      // Â·Â·Â·
      }
      if (x) { // truthy?
      // x is neither: undefined, null, false, 0, NaN, 0n, ''
      }

   Is ``x`` either ``undefined`` or ``null``?

   .. code:: javascript

      if (x === undefined || x === null) {
      // Â·Â·Â·
      }
      if (!x) { // falsy?
      // x is: undefined, null, false, 0, NaN, 0n, ''
      }

   *Truthy* means â€œis ``true`` if coerced to booleanâ€. *Falsy* means â€œis ``false``
   if coerced to booleanâ€. Both concepts are explained properly in `â€œFalsy and
   truthy valuesâ€ (Â§17.2) <#falsiness-truthiness>`__.



.. _nullish-coalescing-operator:

16.4â€ƒThe nullish coalescing operator (``??``) for default values [ES2020]
--------------------------------------------------------------------------

   Sometimes we receive a value and only want to use it if it isnâ€™t either ``null``
   or ``undefined``. Otherwise, weâ€™d like to use a default value, as a fallback. We
   can do that via the *nullish coalescing operator* (``??``):

   .. code:: javascript

      const valueToUse = receivedValue ?? defaultValue;

   The following two expressions are equivalent:

   .. code:: javascript

      a ?? b
      a !== undefined && a !== null ? a : b

16.4.1â€ƒExample: counting matches
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following code shows a real-world example:

   .. code:: javascript

      function countMatches(regex, str) {
      const matchResult = str.match(regex); // null or Array
      return (matchResult ?? []).length;
      }

      assert.equal(
      countMatches(/a/g, 'ababa'), 3);
      assert.equal(
      countMatches(/b/g, 'ababa'), 2);
      assert.equal(
      countMatches(/x/g, 'ababa'), 0);

   If there are one or more matches for ``regex`` inside ``str``, then ``.match()``
   returns an Array. If there are no matches, it unfortunately returns ``null``
   (and not the empty Array). We fix that via the ``??`` operator.

   We also could have used `optional
   chaining <#optional-chaining>`__:

   .. code:: javascript

      return matchResult?.length ?? 0;

16.4.2â€ƒExample: specifying a default value for a property
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. code:: javascript

      function getTitle(fileDesc) {
      return fileDesc.title ?? '(Untitled)';
      }

      const files = [
      {path: 'index.html', title: 'Home'},
      {path: 'tmp.html'},
      ];
      assert.deepEqual(
      files.map(f => getTitle(f)),
      ['Home', '(Untitled)']);

16.4.3â€ƒUsing destructuring for default values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In some cases, destructuring can also be used for default values â€“ for example:

   .. code:: javascript

      function getTitle(fileDesc) {
      const {title = '(Untitled)'} = fileDesc;
      return title;
      }

16.4.4â€ƒLegacy approach: using logical Or (``||``) for default values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Before ECMAScript 2020 and the nullish coalescing operator, logical Or was used
   for default values. That has a downside.

   ``||`` works as expected for ``undefined`` and ``null``:

   .. code:: javascript
      :name: language-node-repl

      > undefined || 'default'
      'default'
      > null || 'default'
      'default'

   But it also returns the default for all other falsy values â€“ for example:

   .. code:: javascript
      :name: language-node-repl

      > false || 'default'
      'default'
      > 0 || 'default'
      'default'
      > 0n || 'default'
      'default'
      > '' || 'default'
      'default'

   Compare that to how ``??`` works:

   .. code:: javascript
      :name: language-node-repl

      > undefined ?? 'default'
      'default'
      > null ?? 'default'
      'default'

      > false ?? 'default'
      false
      > 0 ?? 'default'
      0
      > 0n ?? 'default'
      0n
      > '' ?? 'default'
      ''



.. _nullish-coalescing-assignment-operator:

16.4.5â€ƒThe nullish coalescing assignment operator (``??=``) [ES2021]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``??=`` is a `logical assignment
   operator <#logical-assignment-operators>`__. The following two
   expressions are roughly equivalent:

   .. code:: javascript

      a ??= b
      a ?? (a = b)

   That means that ``??=`` is
   `short-circuiting <#short-circuiting>`__: The assignment is only
   made if ``a`` is ``undefined`` or ``null``.

16.4.5.1â€ƒExample: using ``??=`` to add missing properties
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   .. code:: javascript

      const books = [
      {
         isbn: '123',
      },
      {
         title: 'ECMAScript Language Specification',
         isbn: '456',
      },
      ];

      // Add property .title where itâ€™s missing
      for (const book of books) {
      book.title ??= '(Untitled)';
      }

      assert.deepEqual(
      books,
      [
         {
            isbn: '123',
            title: '(Untitled)',
         },
         {
            title: 'ECMAScript Language Specification',
            isbn: '456',
         },
      ]);



.. _undefined-and-null-don-t-have-properties:

16.5â€ƒ``undefined`` and ``null`` donâ€™t have properties
------------------------------------------------------

   ``undefined`` and ``null`` are the only two JavaScript values where we get an
   exception if we try to read a property. To explore this phenomenon, letâ€™s use
   the following function, which reads (â€œgetsâ€) property ``.foo`` and returns the
   result.

   .. code:: javascript

      function getFoo(x) {
      return x.foo;
      }

   If we apply ``getFoo()`` to various values, we can see that it only fails for
   ``undefined`` and ``null``:

   .. code:: javascript
      :name: language-node-repl

      > getFoo(undefined)
      TypeError: Cannot read properties of undefined (reading 'foo')
      > getFoo(null)
      TypeError: Cannot read properties of null (reading 'foo')

      > getFoo(true)
      undefined
      > getFoo({})
      undefined

16.6â€ƒThe history of ``undefined`` and ``null``
-----------------------------------------------

   In Java (which inspired many aspects of JavaScript), initialization values
   depend on the static type of a variable:

   -  Variables with object types are initialized with ``null``.
   -  Each primitive type has its own initialization value. For example, ``int``
      variables are initialized with ``0``.

   In JavaScript, each variable can hold both object values and primitive values.
   Therefore, if ``null`` means â€œnot an objectâ€, JavaScript also needs an
   initialization value that means â€œneither an object nor a primitive valueâ€. That
   initialization value is ``undefined``.

   `Comments <https://github.com/rauschma/exploring-js/issues/9>`__


.. _ch_booleans:

17â€ƒBooleans
============

   #. `17.1â€ƒConverting to boolean <#converting-to-boolean>`__
   #. `17.2â€ƒFalsy and truthy values <#falsiness-truthiness>`__

      #. `17.2.1â€ƒChecking for truthiness or falsiness <#checking-for-truthiness-or-falsiness>`__

   #. `17.3â€ƒTruthiness-based existence checks <#truthiness-existence-checks>`__

      #. `17.3.1â€ƒPitfall: truthiness-based existence checks are imprecise <#pitfall-truthiness-based-existence-checks-are-imprecise>`__
      #. `17.3.2â€ƒUse case: was a parameter provided? <#use-case-was-a-parameter-provided>`__
      #. `17.3.3â€ƒUse case: does a property exist? <#use-case-does-a-property-exist>`__

   #. `17.4â€ƒConditional operator (? :) <#conditional-operator>`__
   #. `17.5â€ƒBinary logical operators: And (x && y), Or (x || y) <#binary-logical-operators-and-x-y-or-x-y>`__

      #. `17.5.1â€ƒValue-preservation <#value-preservation>`__
      #. `17.5.2â€ƒShort-circuiting <#short-circuiting>`__
      #. `17.5.3â€ƒLogical And (x && y) <#logical-and-x-y>`__
      #. `17.5.4â€ƒLogical Or (||) <#logical-or>`__

   #. `17.6â€ƒLogical Not (!) <#logical-not>`__

   The primitive type *boolean* comprises two values â€“ ``false`` and ``true``:

   .. code:: javascript
      :name: language-node-repl

      > typeof false
      'boolean'
      > typeof true
      'boolean'

17.1â€ƒConverting to boolean
---------------------------

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**The meaning of â€œconverting to [type]â€**

      .. container:: boxout-vspace

      â€œConverting to [type]â€ is short for â€œConverting arbitrary values to values of
      type [type]â€.

   These are three ways in which you can convert an arbitrary value ``x`` to a
   boolean.

   -  | ``Boolean(x)``
      | Most descriptive; recommended.

   -  | ``x ? true : false``
      | Uses the conditional operator (explained `later in this
      chapter <#conditional-operator>`__).

   -  | ``!!x``
      | Uses `the logical Not operator (``!``) <#logical-not>`__. This operator
      coerces its operand to boolean. It is applied a second time to get a
      non-negated result.

   `Table 17.1 <#tbl:converting_to_boolean>`__ describes how various values are
   converted to boolean.

   ================ ============================
   x                Boolean(x)
   undefined        false
   null             false
   boolean          x (no change)
   number           0 â†’ false, NaN â†’ false
                    Other numbers â†’ true
   bigint           0 â†’ false
                    Other numbers â†’ true
   string           '' â†’ false
                    Other strings â†’ true
   symbol           true
   object           Always true
   ================ ============================

   Table 17.1: Converting values to booleans.



.. _falsiness-truthiness:

17.2â€ƒFalsy and truthy values
-----------------------------

   When checking the condition of an ``if`` statement, a ``while`` loop, or a
   ``do-while`` loop, JavaScript works differently than you may expect. Take, for
   example, the following condition:

   .. code:: javascript

      if (value) {}

   In many programming languages, this condition is equivalent to:

   .. code:: javascript

      if (value === true) {}

   However, in JavaScript, it is equivalent to:

   .. code:: javascript

      if (Boolean(value) === true) {}

   That is, JavaScript checks if ``value`` is ``true`` when converted to boolean.
   This kind of check is so common that the following names were introduced:

   -  A value is called *truthy* if it is ``true`` when converted to boolean.
   -  A value is called *falsy* if it is ``false`` when converted to boolean.

   Each value is either truthy or falsy. Consulting `table
   17.1 <#tbl:converting_to_boolean>`__, we can make an exhaustive list of falsy
   values:

   -  ``undefined``
   -  ``null``
   -  Boolean: ``false``
   -  Numbers: ``0``, ``NaN``
   -  Bigint: ``0n``
   -  String: ``''``

   All other values (including all objects) are truthy:

   .. code:: javascript
      :name: language-node-repl

      > Boolean('abc')
      true
      > Boolean([])
      true
      > Boolean({})
      true

17.2.1â€ƒChecking for truthiness or falsiness
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. code:: javascript

      if (x) {
      // x is truthy
      }

      if (!x) {
      // x is falsy
      }

      if (x) {
      // x is truthy
      } else {
      // x is falsy
      }

      const result = x ? 'truthy' : 'falsy';

   The conditional operator that is used in the last line, is explained `later in
   this chapter <#conditional-operator>`__.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Truthiness**

      .. container:: boxout-vspace

      ``exercises/booleans/truthiness_exrc.mjs``



.. _truthiness-existence-checks:

17.3â€ƒTruthiness-based existence checks
---------------------------------------

   In JavaScript, if you read something that doesnâ€™t exist (e.g., a missing
   parameter or a missing property), you usually get ``undefined`` as a result. In
   these cases, an existence check amounts to comparing a value with ``undefined``.
   For example, the following code checks if object ``obj`` has the property
   ``.prop``:

   .. code:: javascript

      if (obj.prop !== undefined) {
      // obj has property .prop
      }

   Due to ``undefined`` being falsy, we can shorten this check to:

   .. code:: javascript

      if (obj.prop) {
      // obj has property .prop
      }

17.3.1â€ƒPitfall: truthiness-based existence checks are imprecise
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Truthiness-based existence checks have one pitfall: they are not very precise.
   Consider this previous example:

   .. code:: javascript

      if (obj.prop) {
      // obj has property .prop
      }

   The body of the ``if`` statement is skipped if:

   -  ``obj.prop`` is missing (in which case, JavaScript returns ``undefined``).

   However, it is also skipped if:

   -  ``obj.prop`` is ``undefined``.
   -  ``obj.prop`` is any other falsy value (``null``, ``0``, ``''``, etc.).

   In practice, this rarely causes problems, but you have to be aware of this
   pitfall.

17.3.2â€ƒUse case: was a parameter provided?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A truthiness check is often used to determine if the caller of a function
   provided a parameter:

   .. code:: javascript

      function func(x) {
      if (!x) {
         throw new Error('Missing parameter x');
      }
      // Â·Â·Â·
      }

   On the plus side, this pattern is established and short. It correctly throws
   errors for ``undefined`` and ``null``.

   On the minus side, there is the previously mentioned pitfall: the code also
   throws errors for all other falsy values.

   An alternative is to check for ``undefined``:

   .. code:: javascript

      if (x === undefined) {
      throw new Error('Missing parameter x');
      }

17.3.3â€ƒUse case: does a property exist?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Truthiness checks are also often used to determine if a property exists:

   .. code:: javascript

      function readFile(fileDesc) {
      if (!fileDesc.path) {
         throw new Error('Missing property: .path');
      }
      // Â·Â·Â·
      }
      readFile({ path: 'foo.txt' }); // no error

   This pattern is also established and has the usual caveat: it not only throws if
   the property is missing, but also if it exists and has any of the falsy values.

   If you truly want to check if the property exists, you have to use `the ``in``
   operator <#in-operator>`__:

   .. code:: javascript

      if (! ('path' in fileDesc)) {
      throw new Error('Missing property: .path');
      }

17.4â€ƒConditional operator (``? :``)
------------------------------------

   The conditional operator is the expression version of the ``if`` statement. Its
   syntax is:

   .. code:: language-txt

      Â«conditionÂ» ? Â«thenExpressionÂ» : Â«elseExpressionÂ»

   It is evaluated as follows:

   -  If ``condition`` is truthy, evaluate and return ``thenExpression``.
   -  Otherwise, evaluate and return ``elseExpression``.

   The conditional operator is also called *ternary operator* because it has three
   operands.

   Examples:

   .. code:: javascript
      :name: language-node-repl

      > true ? 'yes' : 'no'
      'yes'
      > false ? 'yes' : 'no'
      'no'
      > '' ? 'yes' : 'no'
      'no'

   The following code demonstrates that whichever of the two branches â€œthenâ€ and
   â€œelseâ€ is chosen via the condition, only that branch is evaluated. The other
   branch isnâ€™t.

   .. code:: javascript

      const x = (true ? console.log('then') : console.log('else'));

   Output:

   ::

      then

17.5â€ƒBinary logical operators: And (``x && y``), Or (``x || y``)
-----------------------------------------------------------------

   The binary logical operators ``&&`` and ``||`` are *value-preserving* and
   *short-circuiting*.

17.5.1â€ƒValue-preservation
~~~~~~~~~~~~~~~~~~~~~~~~~~

   *Value-preservation* means that operands are interpreted as booleans but
   returned unchanged:

   .. code:: javascript
      :name: language-node-repl

      > 12 || 'hello'
      12
      > 0 || 'hello'
      'hello'

17.5.2â€ƒShort-circuiting
~~~~~~~~~~~~~~~~~~~~~~~~

   *Short-circuiting* means if the first operand already determines the result,
   then the second operand is not evaluated. The only other operator that delays
   evaluating its operands is the conditional operator. Usually, all operands are
   evaluated before performing an operation.

   For example, logical And (``&&``) does not evaluate its second operand if the
   first one is falsy:

   .. code:: javascript

      const x = false && console.log('hello');
      // No output

   If the first operand is truthy, ``console.log()`` is executed:

   .. code:: javascript

      const x = true && console.log('hello');

   Output:

   ::

      hello

17.5.3â€ƒLogical And (``x && y``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The expression ``a && b`` (â€œ\ ``a`` And ``b``\ â€) is evaluated as follows:

   #. Evaluate ``a``.
   #. Is the result falsy? Return it.
   #. Otherwise, evaluate ``b`` and return the result.

   In other words, the following two expressions are roughly equivalent:

   .. code:: javascript

      a && b
      !a ? a : b

   Examples:

   .. code:: javascript
      :name: language-node-repl

      > false && true
      false
      > false && 'abc'
      false

      > true && false
      false
      > true && 'abc'
      'abc'

      > '' && 'abc'
      ''

17.5.4â€ƒLogical Or (``||``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The expression ``a || b`` (â€œ\ ``a`` Or ``b``\ â€) is evaluated as follows:

   #. Evaluate ``a``.
   #. Is the result truthy? Return it.
   #. Otherwise, evaluate ``b`` and return the result.

   In other words, the following two expressions are roughly equivalent:

   .. code:: javascript

      a ||Â b
      a ? a : b

   Examples:

   .. code:: javascript
      :name: language-node-repl

      > true || false
      true
      > true || 'abc'
      true

      > false || true
      true
      > false || 'abc'
      'abc'

      > 'abc' || 'def'
      'abc'

17.5.4.1â€ƒLegacy use case for logical Or (``||``): providing default values
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   ECMAScript 2020 introduced the nullish coalescing operator (``??``) for default
   values. Before that, logical Or was used for this purpose:

   .. code:: javascript

      const valueToUse = receivedValue || defaultValue;

   See `â€œThe nullish coalescing operator (``??``) for default valuesâ€
   (Â§16.4) <#nullish-coalescing-operator>`__ for more
   information on ``??`` and the downsides of ``||`` in this case.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Legacy exercise: Default values via the Or operator
      (``||``)**

      .. container:: boxout-vspace

      ``exercises/booleans/default_via_or_exrc.mjs``

17.6â€ƒLogical Not (``!``)
-------------------------

   The expression ``!x`` (â€œNot ``x``\ â€) is evaluated as follows:

   #. Evaluate ``x``.
   #. Is it truthy? Return ``false``.
   #. Otherwise, return ``true``.

   Examples:

   .. code:: javascript
      :name: language-node-repl

      > !false
      true
      > !true
      false

      > !0
      true
      > !123
      false

      > !''
      true
      > !'abc'
      false

   `Comments <https://github.com/rauschma/exploring-js/issues/10>`__



.. _ch_numbers:

18â€ƒNumbers
===========

   #. `18.1â€ƒNumbers are used for both floating point numbers and integers <#numbers-are-used-for-both-floating-point-numbers-and-integers>`__
   #. `18.2â€ƒNumber literals <#number-literals>`__

      #. `18.2.1â€ƒInteger literals <#integer-literals>`__
      #. `18.2.2â€ƒFloating point literals <#floating-point-literals>`__
      #. `18.2.3â€ƒSyntactic pitfall: properties of integer literals <#syntactic-pitfall-properties-of-integer-literals>`__
      #. `18.2.4â€ƒUnderscores (_) as separators in number literals [ES2021] <#numeric-separator-number-literals>`__

   #. `18.3â€ƒArithmetic operators <#arithmetic-operators>`__

      #. `18.3.1â€ƒBinary arithmetic operators <#binary-arithmetic-operators>`__
      #. `18.3.2â€ƒUnary plus (+) and negation (-) <#unary-plus-and-negation>`__
      #. `18.3.3â€ƒIncrementing (++) and decrementing (--) <#incrementing-and-decrementing>`__

   #. `18.4â€ƒConverting to number <#converting-to-number>`__
   #. `18.5â€ƒError values <#error-values>`__

      #. `18.5.1â€ƒError value: NaN <#nan>`__
      #. `18.5.2â€ƒError value: Infinity <#error-value-infinity>`__

   #. `18.6â€ƒThe precision of numbers: careful with decimal fractions <#the-precision-of-numbers-careful-with-decimal-fractions>`__
   #. `18.7â€ƒ(Advanced) <#advanced-2>`__
   #. `18.8â€ƒBackground: floating point precision <#floating-point-precision>`__

      #. `18.8.1â€ƒA simplified representation of floating point numbers <#a-simplified-representation-of-floating-point-numbers>`__

   #. `18.9â€ƒInteger numbers in JavaScript <#integer-numbers-in-javascript>`__

      #. `18.9.1â€ƒConverting to integer <#converting-to-integer>`__
      #. `18.9.2â€ƒRanges of integer numbers in JavaScript <#ranges-of-integer-numbers-in-javascript>`__
      #. `18.9.3â€ƒSafe integers <#safe-integers>`__

   #. `18.10â€ƒBitwise operators <#bitwise-operators>`__

      #. `18.10.1â€ƒInternally, bitwise operators work with 32-bit integers <#internally-bitwise-operators-work-with-32-bit-integers>`__
      #. `18.10.2â€ƒBitwise Not <#bitwise-not>`__
      #. `18.10.3â€ƒBinary bitwise operators <#binary-bitwise-operators>`__
      #. `18.10.4â€ƒBitwise shift operators <#bitwise-shift-operators>`__
      #. `18.10.5â€ƒb32(): displaying unsigned 32-bit integers in binary notation <#b32>`__

   #. `18.11â€ƒQuick reference: numbers <#quick-reference-numbers>`__

      #. `18.11.1â€ƒGlobal functions for numbers <#global-functions-for-numbers>`__
      #. `18.11.2â€ƒNumber.*: data properties <#number-data-properties>`__
      #. `18.11.3â€ƒNumber.*: methods <#number-methods>`__
      #. `18.11.4â€ƒNumber.prototype.* <#number-prototype>`__
      #. `18.11.5â€ƒSources <#sources>`__

   JavaScript has two kinds of numeric values:

   -  *Numbers* are 64-bit floating point numbers and are also used for smaller
      integers (within a range of plus/minus 53 bits).
   -  *Bigints* represent integers with an arbitrary precision.

   This chapter covers numbers. Bigints are covered `later in this
   book <#ch_bigints>`__.

18.1â€ƒNumbers are used for both floating point numbers and integers
-------------------------------------------------------------------

   The type ``number`` is used for both integers and floating point numbers in
   JavaScript:

   .. code:: javascript

      98
      123.45

   However, all numbers are *doubles*, 64-bit floating point numbers implemented
   according to the *IEEE Standard for Floating-Point Arithmetic* (IEEE 754).

   Integer numbers are simply floating point numbers without a decimal fraction:

   .. code:: javascript
      :name: language-node-repl

      > 98 === 98.0
      true

   Note that, under the hood, most JavaScript engines are often able to use real
   integers, with all associated performance and storage size benefits.

18.2â€ƒNumber literals
---------------------

   Letâ€™s examine literals for numbers.

18.2.1â€ƒInteger literals
~~~~~~~~~~~~~~~~~~~~~~~~

   Several *integer literals* let us express integers with various bases:

   .. code:: javascript

      // Binary (base 2)
      assert.equal(0b11, 3); // ES6

      // Octal (base 8)
      assert.equal(0o10, 8); // ES6

      // Decimal (base 10)
      assert.equal(35, 35);

      // Hexadecimal (base 16)
      assert.equal(0xE7, 231);

18.2.2â€ƒFloating point literals
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Floating point numbers can only be expressed in base 10.

   Fractions:

   .. code:: javascript
      :name: language-node-repl

      > 35.0
      35

   Exponent: ``eN`` means Ã—10\ :sup:`N`

   .. code:: javascript
      :name: language-node-repl

      > 3e2
      300
      > 3e-2
      0.03
      > 0.3e2
      30

18.2.3â€ƒSyntactic pitfall: properties of integer literals
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Accessing a property of an integer literal entails a pitfall: If the integer
   literal is immediately followed by a dot, then that dot is interpreted as a
   decimal dot:

   .. code:: language-txt

      7.toString(); // syntax error

   There are four ways to work around this pitfall:

   .. code:: javascript

      7.0.toString()
      (7).toString()
      7..toString()
      7 .toString()  // space before dot



.. _numeric-separator-number-literals:

18.2.4â€ƒUnderscores (``_``) as separators in number literals [ES2021]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Grouping digits to make long numbers more readable has a long tradition. For
   example:

   -  In 1825, London had 1,335,000 inhabitants.
   -  The distance between Earth and Sun is 149,600,000 km.

   Since ES2021, we can use underscores as separators in number literals:

   .. code:: javascript

      const inhabitantsOfLondon = 1_335_000;
      const distanceEarthSunInKm = 149_600_000;

   With other bases, grouping is important, too:

   .. code:: javascript

      const fileSystemPermission = 0b111_111_000;
      const bytes = 0b1111_10101011_11110000_00001101;
      const words = 0xFAB_F00D;

   We can also use the separator in fractions and exponents:

   .. code:: javascript

      const massOfElectronInKg = 9.109_383_56e-31;
      const trillionInShortScale = 1e1_2;

18.2.4.1â€ƒWhere can we put separators?
''''''''''''''''''''''''''''''''''''''

   The locations of separators are restricted in two ways:

   -  We can only put underscores between two digits. Therefore, all of the
      following number literals are illegal:

      .. code:: javascript

         3_.141
         3._141

         1_e12
         1e_12

         _1464301  // valid variable name!
         1464301_

         0_b111111000
         0b_111111000

   -  We canâ€™t use more than one underscore in a row:

      .. code:: javascript

         123__456 // two underscores â€“ not allowed

   The motivation behind these restrictions is to keep parsing simple and to avoid
   strange edge cases.

18.2.4.2â€ƒParsing numbers with separators
'''''''''''''''''''''''''''''''''''''''''

   The following functions for parsing numbers do not support separators:

   -  ``Number()``
   -  ``Number.parseInt()``
   -  ``Number.parseFloat()``

   For example:

   .. code:: javascript
      :name: language-node-repl

      > Number('123_456')
      NaN
      > Number.parseInt('123_456')
      123

   The rationale is that numeric separators are for code. Other kinds of input
   should be processed differently.

18.3â€ƒArithmetic operators
--------------------------

18.3.1â€ƒBinary arithmetic operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `Table 18.1 <#tbl:binary-arithmetic-operators>`__ lists JavaScriptâ€™s binary
   arithmetic operators.

   ========  ======================  =========  ==================
   Operator  Name                               Example
   n + m     Addition                ES1        3 + 4 â†’ 7
   n - m     Subtraction             ES1        9 - 1 â†’ 8
   n * m     Multiplication          ES1        3 * 2.25 â†’ 6.75
   n / m     Division                ES1        5.625 / 5 â†’ 1.125
   n % m     Remainder               ES1        8 % 5 â†’ 3
   \                                            -8 % 5 â†’ -3
   n ** m    Exponentiation          ES2016     4 ** 2 â†’ 16
   ========  ======================  =========  ==================

   Table 18.1: Binary arithmetic operators.

18.3.1.1â€ƒ``%`` is a remainder operator
'''''''''''''''''''''''''''''''''''''''

   ``%`` is a remainder operator, not a modulo operator. Its result has the sign of
   the first operand:

   .. code:: javascript
      :name: language-node-repl

      > 5 % 3
      2
      > -5 % 3
      -2

   For more information on the difference between remainder and modulo, see the
   blog post `â€œRemainder operator vs. modulo operator (with JavaScript
   code)â€ <https://2ality.com/2019/08/remainder-vs-modulo.html>`__ on 2ality.



.. _unary-plus-and-negation:

18.3.2â€ƒUnary plus (``+``) and negation (``-``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `Table 18.2 <#tbl:unary-plus-negation>`__ summarizes the two operators *unary
   plus* (``+``) and *negation* (``-``).

   ========= =============== ======= ===================
   Operator  Name                    Example
   +n        Unary plus      ES1     +(-7) â†’ -7
   -n        Unary negation  ES1     -(-7) â†’ 7
   ========= =============== ======= ===================

   Table 18.2: The operators unary plus (``+``) and negation (``-``).

   Both operators coerce their operands to numbers:

   .. code:: javascript
      :name: language-node-repl

      > +'5'
      5
      > +'-12'
      -12
      > -'9'
      -9

   Thus, unary plus lets us convert arbitrary values to numbers.



.. _incrementing-and-decrementing:

18.3.3â€ƒIncrementing (``++``) and decrementing (``--``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The incrementation operator ``++`` exists in a prefix version and a suffix
   version. In both versions, it destructively adds one to its operand. Therefore,
   its operand must be a storage location that can be changed.

   The decrementation operator ``--`` works the same, but subtracts one from its
   operand. The next two examples explain the difference between the prefix and the
   suffix version.

   `Table 18.3 <#tbl:incrementing-decrementing>`__ summarizes the incrementation
   and decrementation operators.

   ========= ========== ======= ============================
   Operator  Name                Example
   v++       Increment  ES1      let v=0; [v++, v] â†’ [0, 1]
   ++v       Increment  ES1      let v=0; [++v, v] â†’ [1, 1]
   v--       Decrement  ES1      let v=1; [v--, v] â†’ [1, 0]
   --v       Decrement  ES1      let v=1; [--v, v] â†’ [0, 0]
   ========= ========== ======= ============================

   Table 18.3: Incrementation operators and decrementation operators.

   Next, weâ€™ll look at examples of these operators in use.

   Prefix ``++`` and prefix ``--`` change their operands and then return them.

   .. code:: javascript

      let foo = 3;
      assert.equal(++foo, 4);
      assert.equal(foo, 4);

      let bar = 3;
      assert.equal(--bar, 2);
      assert.equal(bar, 2);

   Suffix ``++`` and suffix ``--`` return their operands and then change them.

   .. code:: javascript

      let foo = 3;
      assert.equal(foo++, 3);
      assert.equal(foo, 4);

      let bar = 3;
      assert.equal(bar--, 3);
      assert.equal(bar, 2);

18.3.3.1â€ƒOperands: not just variables
''''''''''''''''''''''''''''''''''''''

   We can also apply these operators to property values:

   .. code:: javascript

      const obj = { a: 1 };
      ++obj.a;
      assert.equal(obj.a, 2);

   And to Array elements:

   .. code:: javascript

      const arr = [ 4 ];
      arr[0]++;
      assert.deepEqual(arr, [5]);

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Number operators**

      .. container:: boxout-vspace

      ``exercises/numbers-math/is_odd_test.mjs``

18.4â€ƒConverting to number
--------------------------

   These are three ways of converting values to numbers:

   -  ``Number(value)``
   -  ``+value``
   -  ``parseFloat(value)`` (avoid; different than the other two!)

   Recommendation: use the descriptive ``Number()``. `Table
   18.4 <#tbl:converting-values-to-numbers>`__ summarizes how it works.

   ============ ===========================================================
   x            Number(x)
   undefined    NaN
   null         0
   boolean      false â†’ 0, true â†’ 1
   number       x (no change)
   bigint       -1n â†’ -1, 1n â†’ 1, etc.
   string       '' â†’ 0
                Other â†’ parsed number, ignoring leading/trailing whitespace
   symbol       Throws TypeError
   object       Configurable (e.g. via .valueOf())
   ============ ===========================================================

   Table 18.4: Converting values to numbers.

   Examples:

   .. code:: javascript

      assert.equal(Number(123.45), 123.45);

      assert.equal(Number(''), 0);
      assert.equal(Number('\n 123.45 \t'), 123.45);
      assert.equal(Number('xyz'), NaN);

      assert.equal(Number(-123n), -123);

   How objects are converted to numbers can be configured â€“ for example, by
   overriding ``.valueOf()``:

   .. code:: javascript
      :name: language-node-repl

      > Number({ valueOf() { return 123 } })
      123

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Converting to number**

      .. container:: boxout-vspace

      ``exercises/numbers-math/parse_number_test.mjs``

18.5â€ƒError values
------------------

   Two number values are returned when errors happen:

   -  ``NaN``
   -  ``Infinity``



.. _nan:

18.5.1â€ƒError value: ``NaN``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``NaN`` is an abbreviation of â€œnot a numberâ€. Ironically, JavaScript considers
   it to be a number:

   .. code:: javascript
      :name: language-node-repl

      > typeof NaN
      'number'

   When is ``NaN`` returned?

   ``NaN`` is returned if a number canâ€™t be parsed:

   .. code:: javascript
      :name: language-node-repl

      > Number('$$$')
      NaN
      > Number(undefined)
      NaN

   ``NaN`` is returned if an operation canâ€™t be performed:

   .. code:: javascript
      :name: language-node-repl

      > Math.log(-1)
      NaN
      > Math.sqrt(-1)
      NaN

   ``NaN`` is returned if an operand or argument is ``NaN`` (to propagate errors):

   .. code:: javascript
      :name: language-node-repl

      > NaN - 3
      NaN
      > 7 ** NaN
      NaN

18.5.1.1â€ƒChecking for ``NaN``
''''''''''''''''''''''''''''''

   ``NaN`` is the only JavaScript value that is not strictly equal to itself:

   .. code:: javascript

      const n = NaN;
      assert.equal(n === n, false);

   These are several ways of checking if a value ``x`` is ``NaN``:

   .. code:: javascript

      const x = NaN;

      assert.equal(Number.isNaN(x), true); // preferred
      assert.equal(Object.is(x, NaN), true);
      assert.equal(x !== x, true);

   In the last line, we use the comparison quirk to detect ``NaN``.

18.5.1.2â€ƒFinding ``NaN`` in Arrays
'''''''''''''''''''''''''''''''''''

   Some Array methods canâ€™t find ``NaN``:

   .. code:: javascript
      :name: language-node-repl

      > [NaN].indexOf(NaN)
      -1

   Others can:

   .. code:: javascript
      :name: language-node-repl

      > [NaN].includes(NaN)
      true
      > [NaN].findIndex(x => Number.isNaN(x))
      0
      > [NaN].find(x => Number.isNaN(x))
      NaN

   Alas, there is no simple rule of thumb. We have to check for each method how it
   handles ``NaN``.

18.5.2â€ƒError value: ``Infinity``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   When is the error value ``Infinity`` returned?

   Infinity is returned if a number is too large:

   .. code:: javascript
      :name: language-node-repl

      > Math.pow(2, 1023)
      8.98846567431158e+307
      > Math.pow(2, 1024)
      Infinity

   Infinity is returned if there is a division by zero:

   .. code:: javascript
      :name: language-node-repl

      > 5 / 0
      Infinity
      > -5 / 0
      -Infinity

18.5.2.1â€ƒ``Infinity`` as a default value
'''''''''''''''''''''''''''''''''''''''''

   ``Infinity`` is larger than all other numbers (except ``NaN``), making it a good
   default value:

   .. code:: javascript

      function findMinimum(numbers) {
      let min = Infinity;
      for (const n of numbers) {
         if (n < min) min = n;
      }
      return min;
      }

      assert.equal(findMinimum([5, -1, 2]), -1);
      assert.equal(findMinimum([]), Infinity);

18.5.2.2â€ƒChecking for ``Infinity``
'''''''''''''''''''''''''''''''''''

   These are two common ways of checking if a value ``x`` is ``Infinity``:

   .. code:: javascript

      const x = Infinity;

      assert.equal(x === Infinity, true);
      assert.equal(Number.isFinite(x), false);

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Comparing numbers**

      .. container:: boxout-vspace

      ``exercises/numbers-math/find_max_test.mjs``

18.6â€ƒThe precision of numbers: careful with decimal fractions
--------------------------------------------------------------

   Internally, JavaScript floating point numbers are represented with base 2
   (according to the IEEE 754 standard). That means that decimal fractions (base
   10) canâ€™t always be represented precisely:

   .. code:: javascript
      :name: language-node-repl

      > 0.1 + 0.2
      0.30000000000000004
      > 1.3 * 3
      3.9000000000000004
      > 1.4 * 100000000000000
      139999999999999.98

   We therefore need to take rounding errors into consideration when performing
   arithmetic in JavaScript.

   Read on for an explanation of this phenomenon.



.. _advanced-2:

18.7â€ƒ(Advanced)
----------------

   All remaining sections of this chapter are advanced.



.. _floating-point-precision:

18.8â€ƒBackground: floating point precision
------------------------------------------

   In JavaScript, computations with numbers donâ€™t always produce correct results â€“
   for example:

   .. code:: javascript
      :name: language-node-repl

      > 0.1 + 0.2
      0.30000000000000004

   To understand why, we need to explore how JavaScript represents floating point
   numbers internally. It uses three integers to do so, which take up a total of 64
   bits of storage (double precision):

   ================ =============== ==================
   Component        Size            Integer range
   Sign             1 bit           [0, 1]
   Fraction         52 bits         [0, 252âˆ’1]
   Exponent         11 bits         [âˆ’1023, 1024]
   ================ =============== ==================

   The floating point number represented by these integers is computed as follows:

      (â€“1)\ :sup:`sign` Ã— 0b1.fraction Ã— 2\ :sup:`exponent`

   This representation canâ€™t encode a zero because its second component (involving
   the fraction) always has a leading 1. Therefore, a zero is encoded via the
   special exponent âˆ’1023 and a fraction 0.

18.8.1â€ƒA simplified representation of floating point numbers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To make further discussions easier, we simplify the previous representation:

   -  Instead of base 2 (binary), we use base 10 (decimal) because thatâ€™s what most
      people are more familiar with.
   -  The *fraction* is a natural number that is interpreted as a fraction (digits
      after a point). We switch to a *mantissa*, an integer that is interpreted as
      itself. As a consequence, the exponent is used differently, but its
      fundamental role doesnâ€™t change.
   -  As the mantissa is an integer (with its own sign), we donâ€™t need a separate
      sign, anymore.

   The new representation works like this:

      mantissa Ã— 10\ :sup:`exponent`

   Letâ€™s try out this representation for a few floating point numbers.

   -  To encode the integer 123, we use the mantissa 123 and multiply it with 1
      (10\ :sup:`0`):

      .. code:: javascript
         :name: language-node-repl

         > 123 * (10 ** 0)
         123

   -  To encode the integer âˆ’45, we use the mantissa âˆ’45 and, again, the exponent
      zero:

      .. code:: javascript
         :name: language-node-repl

         > -45 * (10 ** 0)
         -45

   -  For the number 1.5, we imagine there being a point after the mantissa. We use
      the negative exponent âˆ’1 to move that point one digit to the left:

      .. code:: javascript
         :name: language-node-repl

         > 15 * (10 ** -1)
         1.5

   -  For the number 0.25, we move the point two digits to the left:

      .. code:: javascript
         :name: language-node-repl

         > 25 * (10 ** -2)
         0.25

   In other words: As soon as we have decimal digits, the exponent becomes
   negative. We can also write such a number as a fraction:

   -  Numerator (above the horizontal fraction bar): the mantissa
   -  Denominator (below the horizontal fraction bar): a 10 with a positive
      exponent â‰¥ 1.

   For example:

   .. code:: javascript
      :name: language-node-repl

      > 15 * (10 ** -1) === 15 / (10 ** 1)
      true
      > 25 * (10 ** -2) === 25 / (10 ** 2)
      true

   These fractions help with understanding why there are numbers that our encoding
   cannot represent:

   -  ``1/10`` can be represented. It already has the required format: a power of
      10 in the denominator.

   -  ``1/2`` can be represented as ``5/10``. We turned the 2 in the denominator
      into a power of 10 by multiplying the numerator and denominator by 5.

   -  ``1/4`` can be represented as ``25/100``. We turned the 4 in the denominator
      into a power of 10 by multiplying the numerator and denominator by 25.

   -  ``1/3`` cannot be represented. There is no way to turn the denominator into a
      power of 10. (The prime factors of 10 are 2 and 5. Therefore, any denominator
      that only has these prime factors can be converted to a power of 10, by
      multiplying both the numerator and denominator by enough twos and fives. If a
      denominator has a different prime factor, then thereâ€™s nothing we can do.)

   To conclude our excursion, we switch back to base 2:

   -  ``0.5 = 1/2`` can be represented with base 2 because the denominator is
      already a power of 2.
   -  ``0.25 = 1/4`` can be represented with base 2 because the denominator is
      already a power of 2.
   -  ``0.1 = 1/10`` cannot be represented because the denominator cannot be
      converted to a power of 2.
   -  ``0.2 = 2/10`` cannot be represented because the denominator cannot be
      converted to a power of 2.

   Now we can see why ``0.1 + 0.2`` doesnâ€™t produce a correct result: internally,
   neither of the two operands can be represented precisely.

   The only way to compute precisely with decimal fractions is by internally
   switching to base 10. For many programming languages, base 2 is the default and
   base 10 an option. For example:

   -  Java has the class
      `BigDecimal <https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html>`__.
   -  Python has the module
      `decimal <https://docs.python.org/3/library/decimal.html>`__.

   There are plans to add something similar to JavaScript: `the ECMAScript proposal
   â€œDecimalâ€ <https://github.com/tc39/proposal-decimal>`__. Until that happens, we
   can use libraries such as `big.js <https://github.com/MikeMcl/big.js/>`__.

18.9â€ƒInteger numbers in JavaScript
-----------------------------------

   Integer numbers are normal (floating point) numbers without decimal fractions:

   .. code:: javascript
      :name: language-node-repl

      > 1 === 1.0
      true
      > Number.isInteger(1.0)
      true

   In this section, weâ€™ll look at a few tools for working with these
   pseudo-integers. JavaScript also supports
   `bigints <#ch_bigints>`__, which are real integers.

18.9.1â€ƒConverting to integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The recommended way of converting numbers to integers is to use one of the
   rounding methods of the ``Math`` object:

   -  ``Math.floor(n)``: returns the largest integer ``i`` â‰¤ ``n``

      .. code:: javascript
         :name: language-node-repl

         > Math.floor(2.1)
         2
         > Math.floor(2.9)
         2

   -  ``Math.ceil(n)``: returns the smallest integer ``i`` â‰¥ ``n``

      .. code:: javascript
         :name: language-node-repl

         > Math.ceil(2.1)
         3
         > Math.ceil(2.9)
         3

   -  ``Math.round(n)``: returns the integer that is â€œclosestâ€ to ``n`` with
      ``__.5`` being rounded up â€“ for example:

      .. code:: javascript
         :name: language-node-repl

         > Math.round(2.4)
         2
         > Math.round(2.5)
         3

   -  ``Math.trunc(n)``: removes any decimal fraction (after the point) that ``n``
      has, therefore turning it into an integer.

      .. code:: javascript
         :name: language-node-repl

         > Math.trunc(2.1)
         2
         > Math.trunc(2.9)
         2

   For more information on rounding, consult `â€œRoundingâ€
   (Â§19.3) <#math-rounding>`__.

18.9.2â€ƒRanges of integer numbers in JavaScript
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   These are important ranges of integer numbers in JavaScript:

   -  **Safe integers:** can be represented â€œsafelyâ€ by JavaScript (more on what
      that means in the next subsection)

      -  Precision: 53 bits plus sign
      -  Range: (âˆ’2\ :sup:`53`, 2\ :sup:`53`)

   -  **Array indices**

      -  Precision: 32 bits, unsigned
      -  Range: [0, 2\ :sup:`32`\ âˆ’1) (excluding the maximum length)
      -  Typed Arrays have a larger range of 53 bits (safe and unsigned)

   -  **Bitwise operators** (bitwise Or, etc.)

      -  Precision: 32 bits
      -  Range of unsigned right shift (``>>>``): unsigned, [0, 2\ :sup:`32`)
      -  Range of all other bitwise operators: signed, [âˆ’2\ :sup:`31`,
         2\ :sup:`31`)

18.9.3â€ƒSafe integers
~~~~~~~~~~~~~~~~~~~~~

   This is the range of integer numbers that are *safe* in JavaScript (53 bits plus
   a sign):

      [â€“(2\ :sup:`53`)+1, 2\ :sup:`53`â€“1]

   An integer is *safe* if it is represented by exactly one JavaScript number.
   Given that JavaScript numbers are encoded as a fraction multiplied by 2 to the
   power of an exponent, higher integers can also be represented, but then there
   are gaps between them.

   For example (18014398509481984 is 2\ :sup:`54`):

   .. code:: javascript
      :name: language-node-repl

      > 18014398509481984
      18014398509481984
      > 18014398509481985
      18014398509481984
      > 18014398509481986
      18014398509481984
      > 18014398509481987
      18014398509481988

   The following properties of ``Number`` help determine if an integer is safe:

   .. code:: javascript

      assert.equal(Number.MAX_SAFE_INTEGER, (2 ** 53) - 1);
      assert.equal(Number.MIN_SAFE_INTEGER, -Number.MAX_SAFE_INTEGER);

      assert.equal(Number.isSafeInteger(5), true);
      assert.equal(Number.isSafeInteger('5'), false);
      assert.equal(Number.isSafeInteger(5.1), false);
      assert.equal(Number.isSafeInteger(Number.MAX_SAFE_INTEGER), true);
      assert.equal(Number.isSafeInteger(Number.MAX_SAFE_INTEGER+1), false);

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Detecting safe integers**

      .. container:: boxout-vspace

      ``exercises/numbers-math/is_safe_integer_test.mjs``

18.9.3.1â€ƒSafe computations
'''''''''''''''''''''''''''

   Letâ€™s look at computations involving unsafe integers.

   The following result is incorrect and unsafe, even though both of its operands
   are safe:

   .. code:: javascript
      :name: language-node-repl

      > 9007199254740990 + 3
      9007199254740992

   The following result is safe, but incorrect. The first operand is unsafe; the
   second operand is safe:

   .. code:: javascript
      :name: language-node-repl

      > 9007199254740995 - 10
      9007199254740986

   Therefore, the result of an expression ``a op b`` is correct if and only if:

   .. code:: javascript

      isSafeInteger(a) && isSafeInteger(b) && isSafeInteger(a op b)

   That is, both operands and the result must be safe.

18.10â€ƒBitwise operators
------------------------

18.10.1â€ƒInternally, bitwise operators work with 32-bit integers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Internally, JavaScriptâ€™s bitwise operators work with 32-bit integers. They
   produce their results in the following steps:

   -  Input (JavaScript numbers): The 1â€“2 operands are first converted to
      JavaScript numbers (64-bit floating point numbers) and then to 32-bit
      integers.
   -  Computation (32-bit integers): The actual operation processes 32-bit integers
      and produces a 32-bit integer.
   -  Output (JavaScript number): Before returning the result, it is converted back
      to a JavaScript number.

18.10.1.1â€ƒThe types of operands and results
''''''''''''''''''''''''''''''''''''''''''''

   For each bitwise operator, this book mentions the types of its operands and its
   result. Each type is always one of the following two:

   ========= ======================== ==================== ==============
   Type      Description              Size                 Range
   Int32     signed 32-bit integer    32 bits incl. sign   [âˆ’231, 231)
   Uint32    unsigned 32-bit integer  32 bits              [0, 232)
   ========= ======================== ==================== ==============

   Considering the previously mentioned steps, I recommend to pretend that bitwise
   operators internally work with unsigned 32-bit integers (step â€œcomputationâ€) and
   that Int32 and Uint32 only affect how JavaScript numbers are converted to and
   from integers (steps â€œinputâ€ and â€œoutputâ€).

18.10.1.2â€ƒDisplaying JavaScript numbers as unsigned 32-bit integers
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   While exploring the bitwise operators, it occasionally helps to display
   JavaScript numbers as unsigned 32-bit integers in binary notation. Thatâ€™s what
   ``b32()`` does (whose implementation is shown later):

   .. code:: javascript

      assert.equal(
      b32(-1),
      '11111111111111111111111111111111');
      assert.equal(
      b32(1),
      '00000000000000000000000000000001');
      assert.equal(
      b32(2 ** 31),
      '10000000000000000000000000000000');

18.10.2â€ƒBitwise Not
~~~~~~~~~~~~~~~~~~~~

   ========== ============================== ============== =====
   Operation  Name                           Type signature  
   ~num       Bitwise Not, onesâ€™ complement  Int32 â†’ Int32   ES1
   ========== ============================== ============== =====

   Table 18.5: The bitwise Not operator.

   The bitwise Not operator (`table 18.5 <#tbl:bitwise-not>`__) inverts each binary
   digit of its operand:

   .. code:: javascript
      :name: language-node-repl

      > b32(~0b100)
      '11111111111111111111111111111011'

   This so-called *onesâ€™ complement* is similar to a negative for some arithmetic
   operations. For example, adding an integer to its onesâ€™ complement is always
   ``-1``:

   .. code:: javascript
      :name: language-node-repl

      > 4 + ~4
      -1
      > -11 + ~-11
      -1

18.10.3â€ƒBinary bitwise operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   ============= ============ ===================== =====
   Operation     Name         Type signature         
   num1 & num2   Bitwise And  Int32 Ã— Int32 â†’ Int32  ES1
   num1 Â¦ num2   Bitwise Or   Int32 Ã— Int32 â†’ Int32  ES1
   num1 ^ num2   Bitwise Xor  Int32 Ã— Int32 â†’ Int32  ES1
   ============= ============ ===================== =====

   Table 18.6: Binary bitwise operators.

   The binary bitwise operators (`table 18.6 <#tbl:binary-bitwise-operators>`__)
   combine the bits of their operands to produce their results:

   .. code:: javascript
      :name: language-node-repl

      > (0b1010 & 0b0011).toString(2).padStart(4, '0')
      '0010'
      > (0b1010 | 0b0011).toString(2).padStart(4, '0')
      '1011'
      > (0b1010 ^ 0b0011).toString(2).padStart(4, '0')
      '1001'

18.10.4â€ƒBitwise shift operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ============== ===================== ========================= ====
   Operation      Name                  Type signature            
   num << count   Left shift            Int32 Ã— Uint32 â†’ Int32    ES1
   num >> count   Signed right shift    Int32 Ã— Uint32 â†’ Int32    ES1
   num >>> count  Unsigned right shift  Uint32 Ã— Uint32 â†’ Uint32  ES1
   ============== ===================== ========================= ====

   Table 18.7: Bitwise shift operators.

   The shift operators (`table 18.7 <#tbl:bitwise-shift-operators-short>`__) move
   binary digits to the left or to the right:

   .. code:: javascript
      :name: language-node-repl

      > (0b10 << 1).toString(2)
      '100'

   ``>>`` preserves highest bit, ``>>>`` doesnâ€™t:

   .. code:: javascript
      :name: language-node-repl

      > b32(0b10000000000000000000000000000010 >> 1)
      '11000000000000000000000000000001'
      > b32(0b10000000000000000000000000000010 >>> 1)
      '01000000000000000000000000000001'



.. _b32:

18.10.5â€ƒ``b32()``: displaying unsigned 32-bit integers in binary notation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We have now used ``b32()`` a few times. The following code is an implementation
   of it:

   .. code:: javascript

      /**
      * Return a string representing n as a 32-bit unsigned integer,
      * in binary notation.
      */
      function b32(n) {
      // >>> ensures highest bit isnâ€™t interpreted as a sign
      return (n >>> 0).toString(2).padStart(32, '0');
      }
      assert.equal(
      b32(6),
      '00000000000000000000000000000110');

   ``n >>> 0`` means that we are shifting ``n`` zero bits to the right. Therefore,
   in principle, the ``>>>`` operator does nothing, but it still coerces ``n`` to
   an unsigned 32-bit integer:

   .. code:: javascript
      :name: language-node-repl

      > 12 >>> 0
      12
      > -12 >>> 0
      4294967284
      > (2**32 + 1) >>> 0
      1

18.11â€ƒQuick reference: numbers
-------------------------------

18.11.1â€ƒGlobal functions for numbers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScript has the following four global functions for numbers:

   -  ``isFinite()``
   -  ``isNaN()``
   -  ``parseFloat()``
   -  ``parseInt()``

   However, it is better to use the corresponding methods of ``Number``
   (``Number.isFinite()``, etc.), which have fewer pitfalls. They were introduced
   with ES6 and are discussed below.



.. _number-data-properties:

18.11.2â€ƒ``Number.*``: data properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Number.EPSILON`` :sup:`[ES6]`

      The difference between 1 and the next representable floating point number. In
      general, `a machine
      epsilon <https://en.wikipedia.org/wiki/Machine_epsilon>`__ provides an upper
      bound for rounding errors in floating point arithmetic.

      -  Approximately: 2.2204460492503130808472633361816 Ã— 10\ :sup:`-16`

   -  ``Number.MAX_SAFE_INTEGER`` :sup:`[ES6]`

      The largest integer that JavaScript can represent unambiguously
      (2\ :sup:`53`\ âˆ’1).

   -  ``Number.MAX_VALUE`` :sup:`[ES1]`

      The largest positive finite JavaScript number.

      -  Approximately: 1.7976931348623157 Ã— 10\ :sup:`308`

   -  ``Number.MIN_SAFE_INTEGER`` :sup:`[ES6]`

      The smallest integer that JavaScript can represent unambiguously
      (âˆ’2\ :sup:`53`\ +1).

   -  ``Number.MIN_VALUE`` :sup:`[ES1]`

      The smallest positive JavaScript number. Approximately 5 Ã— 10\ :sup:`âˆ’324`.

   -  ``Number.NaN`` :sup:`[ES1]`

      The same as the global variable ``NaN``.

   -  ``Number.NEGATIVE_INFINITY`` :sup:`[ES1]`

      The same as ``-Number.POSITIVE_INFINITY``.

   -  ``Number.POSITIVE_INFINITY`` :sup:`[ES1]`

      The same as the global variable ``Infinity``.



.. _number-methods:

18.11.3â€ƒ``Number.*``: methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Number.isFinite(num)`` :sup:`[ES6]`

      Returns ``true`` if ``num`` is an actual number (neither ``Infinity`` nor
      ``-Infinity`` nor ``NaN``).

      .. code:: javascript
         :name: language-node-repl

         > Number.isFinite(Infinity)
         false
         > Number.isFinite(-Infinity)
         false
         > Number.isFinite(NaN)
         false
         > Number.isFinite(123)
         true

   -  ``Number.isInteger(num)`` :sup:`[ES6]`

      Returns ``true`` if ``num`` is a number and does not have a decimal fraction.

      .. code:: javascript
         :name: language-node-repl

         > Number.isInteger(-17)
         true
         > Number.isInteger(33)
         true
         > Number.isInteger(33.1)
         false
         > Number.isInteger('33')
         false
         > Number.isInteger(NaN)
         false
         > Number.isInteger(Infinity)
         false

   -  ``Number.isNaN(num)`` :sup:`[ES6]`

      Returns ``true`` if ``num`` is the value ``NaN``:

      .. code:: javascript
         :name: language-node-repl

         > Number.isNaN(NaN)
         true
         > Number.isNaN(123)
         false
         > Number.isNaN('abc')
         false

   -  ``Number.isSafeInteger(num)`` :sup:`[ES6]`

      Returns ``true`` if ``num`` is a number and unambiguously represents an
      integer.

   -  ``Number.parseFloat(str)`` :sup:`[ES6]`

      Coerces its parameter to string and parses it as a floating point number. For
      converting strings to numbers, ``Number()`` (which ignores leading and
      trailing whitespace) is usually a better choice than ``Number.parseFloat()``
      (which ignores leading whitespace and illegal trailing characters and can
      hide problems).

      .. code:: javascript
         :name: language-node-repl

         > Number.parseFloat(' 123.4#')
         123.4
         > Number(' 123.4#')
         NaN

   -  ``Number.parseInt(str, radix=10)`` :sup:`[ES6]`

      Coerces its parameter to string and parses it as an integer, ignoring leading
      whitespace and illegal trailing characters:

      .. code:: javascript
         :name: language-node-repl

         > Number.parseInt('  123#')
         123

      The parameter ``radix`` specifies the base of the number to be parsed:

      .. code:: javascript
         :name: language-node-repl

         > Number.parseInt('101', 2)
         5
         > Number.parseInt('FF', 16)
         255

      Do not use this method to convert numbers to integers: coercing to string is
      inefficient. And stopping before the first non-digit is not a good algorithm
      for removing the fraction of a number. Here is an example where it goes
      wrong:

      .. code:: javascript
         :name: language-node-repl

         > Number.parseInt(1e21, 10) // wrong
         1

      It is better to use one of the rounding functions of ``Math`` to convert a
      number to an integer:

      .. code:: javascript
         :name: language-node-repl

         > Math.trunc(1e21) // correct
         1e+21



.. _number-prototype:

18.11.4â€ƒ``Number.prototype.*``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   (``Number.prototype`` is where the methods of numbers are stored.)

   -  ``Number.prototype.toExponential(fractionDigits?)`` :sup:`[ES3]`

      -  Returns a string that represents the number via exponential notation.
      -  With ``fractionDigits``, we can specify, how many digits should be shown
         of the number that is multiplied with the exponent.

         -  The default is to show as many digits as necessary.

      Example: number too small to get a positive exponent via ``.toString()``.

      .. code:: javascript
         :name: language-node-repl

         > 1234..toString()
         '1234'

         > 1234..toExponential() // 3 fraction digits
         '1.234e+3'
         > 1234..toExponential(5)
         '1.23400e+3'
         > 1234..toExponential(1)
         '1.2e+3'

      Example: fraction not small enough to get a negative exponent via
      ``.toString()``.

      .. code:: javascript
         :name: language-node-repl

         > 0.003.toString()
         '0.003'
         > 0.003.toExponential()
         '3e-3'

   -  ``Number.prototype.toFixed(fractionDigits=0)`` :sup:`[ES3]`

      Returns an exponent-free string representation of the number, rounded to
      ``fractionDigits`` digits.

      .. code:: javascript
         :name: language-node-repl

         > 0.00000012.toString() // with exponent
         '1.2e-7'

         > 0.00000012.toFixed(10) // no exponent
         '0.0000001200'
         > 0.00000012.toFixed()
         '0'

      If the number is 10\ :sup:`21` or greater, even ``.toFixed()`` uses an
      exponent:

      .. code:: javascript
         :name: language-node-repl

         > (10 ** 21).toFixed()
         '1e+21'

   -  ``Number.prototype.toPrecision(precision?)`` :sup:`[ES3]`

      -  Works like ``.toString()``, but ``precision`` specifies how many digits
         should be shown overall.
      -  If ``precision`` is missing, ``.toString()`` is used.

      .. code:: javascript
         :name: language-node-repl

         > 1234..toPrecision(3)  // requires exponential notation
         '1.23e+3'

         > 1234..toPrecision(4)
         '1234'

         > 1234..toPrecision(5)
         '1234.0'

         > 1.234.toPrecision(3)
         '1.23'

   -  ``Number.prototype.toString(radix=10)`` :sup:`[ES1]`

      Returns a string representation of the number.

      By default, we get a base 10 numeral as a result:

      .. code:: javascript
         :name: language-node-repl

         > 123.456.toString()
         '123.456'

      If we want the numeral to have a different base, we can specify it via
      ``radix``:

      .. code:: javascript
         :name: language-node-repl

         > 4..toString(2) // binary (base 2)
         '100'
         > 4.5.toString(2)
         '100.1'

         > 255..toString(16) // hexadecimal (base 16)
         'ff'
         > 255.66796875.toString(16)
         'ff.ab'

         > 1234567890..toString(36)
         'kf12oi'

      ``Number.parseInt()`` provides the inverse operation: it converts a string
      that contains an integer (no fraction!) numeral with a given base, to a
      number.

      .. code:: javascript
         :name: language-node-repl

         > Number.parseInt('kf12oi', 36)
         1234567890

18.11.5â€ƒSources
~~~~~~~~~~~~~~~~

   -  Wikipedia
   -  `TypeScriptâ€™s built-in
      typings <https://github.com/microsoft/TypeScript/tree/main/src/lib/>`__
   -  `MDN web docs for
      JavaScript <https://developer.mozilla.org/en-US/docs/Web/JavaScript>`__
   -  `ECMAScript language specification <https://tc39.es/ecma262/>`__

   `Comments <https://github.com/rauschma/exploring-js/issues/11>`__



.. _ch_math:

19â€ƒ``Math``
============

   #. `19.1â€ƒData properties <#data-properties>`__
   #. `19.2â€ƒExponents, roots, logarithms <#exponents-roots-logarithms>`__
   #. `19.3â€ƒRounding <#math-rounding>`__
   #. `19.4â€ƒTrigonometric Functions <#trigonometric-functions>`__
   #. `19.5â€ƒVarious other functions <#various-other-functions>`__
   #. `19.6â€ƒSources <#sources-1>`__

   ``Math`` is an object with data properties and methods for processing numbers.
   You can see it as a poor manâ€™s module: It was created long before JavaScript had
   modules.

19.1â€ƒData properties
---------------------

   -  ``Math.E: number`` :sup:`[ES1]`

      Eulerâ€™s number, base of the natural logarithms, approximately
      2.7182818284590452354.

   -  ``Math.LN10: number`` :sup:`[ES1]`

      The natural logarithm of 10, approximately 2.302585092994046.

   -  ``Math.LN2: number`` :sup:`[ES1]`

      The natural logarithm of 2, approximately 0.6931471805599453.

   -  ``Math.LOG10E: number`` :sup:`[ES1]`

      The logarithm of *e* to base 10, approximately 0.4342944819032518.

   -  ``Math.LOG2E: number`` :sup:`[ES1]`

      The logarithm of *e* to base 2, approximately 1.4426950408889634.

   -  ``Math.PI: number`` :sup:`[ES1]`

      The mathematical constant Ï€, ratio of a circleâ€™s circumference to its
      diameter, approximately 3.1415926535897932.

   -  ``Math.SQRT1_2: number`` :sup:`[ES1]`

      The square root of 1/2, approximately 0.7071067811865476.

   -  ``Math.SQRT2: number`` :sup:`[ES1]`

      The square root of 2, approximately 1.4142135623730951.

19.2â€ƒExponents, roots, logarithms
----------------------------------

   -  ``Math.cbrt(x: number): number`` :sup:`[ES6]`

      Returns the cube root of ``x``.

      .. code:: javascript
         :name: language-node-repl

         > Math.cbrt(8)
         2

   -  ``Math.exp(x: number): number`` :sup:`[ES1]`

      Returns *e*\ :sup:`x` (*e* being Eulerâ€™s number). The inverse of
      ``Math.log()``.

      .. code:: javascript
         :name: language-node-repl

         > Math.exp(0)
         1
         > Math.exp(1) === Math.E
         true

   -  ``Math.expm1(x: number): number`` :sup:`[ES6]`

      Returns ``Math.exp(x)-1``. The inverse of ``Math.log1p()``. Very small
      numbers (fractions close to 0) are represented with a higher precision.
      Therefore, this function returns more precise values whenever ``.exp()``
      returns values close to 1.

   -  ``Math.log(x: number): number`` :sup:`[ES1]`

      Returns the natural logarithm of ``x`` (to base *e*, Eulerâ€™s number). The
      inverse of ``Math.exp()``.

      .. code:: javascript
         :name: language-node-repl

         > Math.log(1)
         0
         > Math.log(Math.E)
         1
         > Math.log(Math.E ** 2)
         2

   -  ``Math.log1p(x: number): number`` :sup:`[ES6]`

      Returns ``Math.log(1 + x)``. The inverse of ``Math.expm1()``. Very small
      numbers (fractions close to 0) are represented with a higher precision.
      Therefore, you can provide this function with a more precise argument
      whenever the argument for ``.log()`` is close to 1.

   -  ``Math.log10(x: number): number`` :sup:`[ES6]`

      Returns the logarithm of ``x`` to base 10. The inverse of ``10 ** x``.

      .. code:: javascript
         :name: language-node-repl

         > Math.log10(1)
         0
         > Math.log10(10)
         1
         > Math.log10(100)
         2

   -  ``Math.log2(x: number): number`` :sup:`[ES6]`

      Returns the logarithm of ``x`` to base 2. The inverse of ``2 ** x``.

      .. code:: javascript
         :name: language-node-repl

         > Math.log2(1)
         0
         > Math.log2(2)
         1
         > Math.log2(4)
         2

   -  ``Math.pow(x: number, y: number): number`` :sup:`[ES1]`

      Returns ``x``\ :sup:`y`, ``x`` to the power of ``y``. The same as
      ``x ** y``.

      .. code:: javascript
         :name: language-node-repl

         > Math.pow(2, 3)
         8
         > Math.pow(25, 0.5)
         5

   -  ``Math.sqrt(x: number): number`` :sup:`[ES1]`

      Returns the square root of ``x``. The inverse of ``x ** 2``.

      .. code:: javascript
         :name: language-node-repl

         > Math.sqrt(9)
         3



.. _math-rounding:

19.3â€ƒRounding
--------------

   Rounding means converting an arbitrary number to an integer (a number without a
   decimal fraction). The following functions implement different approaches to
   rounding.

   -  ``Math.ceil(x: number): number`` :sup:`[ES1]`

      Returns the smallest (closest to âˆ’âˆ) integer ``i`` with ``x`` â‰¤ ``i``.

      .. code:: javascript
         :name: language-node-repl

         > Math.ceil(2.1)
         3
         > Math.ceil(2.9)
         3

   -  ``Math.floor(x: number): number`` :sup:`[ES1]`

      Returns the largest (closest to +âˆ) integer ``i`` with ``i`` â‰¤ ``x``.

      .. code:: javascript
         :name: language-node-repl

         > Math.floor(2.1)
         2
         > Math.floor(2.9)
         2

   -  ``Math.round(x: number): number`` :sup:`[ES1]`

      Returns the integer that is closest to ``x``. If the decimal fraction of
      ``x`` is ``.5`` then ``.round()`` rounds up (to the integer closer to
      positive infinity):

      .. code:: javascript
         :name: language-node-repl

         > Math.round(2.4)
         2
         > Math.round(2.5)
         3

   -  ``Math.trunc(x: number): number`` :sup:`[ES6]`

      Removes the decimal fraction of ``x`` and returns the resulting integer.

      .. code:: javascript
         :name: language-node-repl

         > Math.trunc(2.1)
         2
         > Math.trunc(2.9)
         2

   `Table 19.1 <#tbl:math-rounding-functions>`__ shows the results of the rounding
   functions for a few representative inputs.

   ============ ====== ====== ====== ===== ===== =======
   \            -2.9   -2.5   -2.1   2.1   2.5   2.9
   Math.floor   -3     -3     -3     2     2     2
   Math.ceil    -2     -2     -2     3     3     3
   Math.round   -3     -2     -2     2     3     3
   Math.trunc   -2     -2     -2     2     2     2
   ============ ====== ====== ====== ===== ===== =======

   Table 19.1: Rounding functions of ``Math``. Note how things change with negative
   numbers because â€œlargerâ€ always means â€œcloser to positive infinityâ€.

19.4â€ƒTrigonometric Functions
-----------------------------

   All angles are specified in radians. Use the following two functions to convert
   between degrees and radians.

   .. code:: javascript

      function degreesToRadians(degrees) {
      return degrees / 180 * Math.PI;
      }
      assert.equal(degreesToRadians(90), Math.PI/2);

      function radiansToDegrees(radians) {
      return radians / Math.PI * 180;
      }
      assert.equal(radiansToDegrees(Math.PI), 180);

   -  ``Math.acos(x: number): number`` :sup:`[ES1]`

      Returns the arc cosine (inverse cosine) of ``x``.

      .. code:: javascript
         :name: language-node-repl

         > Math.acos(0)
         1.5707963267948966
         > Math.acos(1)
         0

   -  ``Math.acosh(x: number): number`` :sup:`[ES6]`

      Returns the inverse hyperbolic cosine of ``x``.

   -  ``Math.asin(x: number): number`` :sup:`[ES1]`

      Returns the arc sine (inverse sine) of ``x``.

      .. code:: javascript
         :name: language-node-repl

         > Math.asin(0)
         0
         > Math.asin(1)
         1.5707963267948966

   -  ``Math.asinh(x: number): number`` :sup:`[ES6]`

      Returns the inverse hyperbolic sine of ``x``.

   -  ``Math.atan(x: number): number`` :sup:`[ES1]`

      Returns the arc tangent (inverse tangent) of ``x``.

   -  ``Math.atanh(x: number): number`` :sup:`[ES6]`

      Returns the inverse hyperbolic tangent of ``x``.

   -  ``Math.atan2(y: number, x: number): number`` :sup:`[ES1]`

      Returns the arc tangent of the quotient y/x.

   -  ``Math.cos(x: number): number`` :sup:`[ES1]`

      Returns the cosine of ``x``.

      .. code:: javascript
         :name: language-node-repl

         > Math.cos(0)
         1
         > Math.cos(Math.PI)
         -1

   -  ``Math.cosh(x: number): number`` :sup:`[ES6]`

      Returns the hyperbolic cosine of ``x``.

   -  ``Math.hypot(...values: Array<number>): number`` :sup:`[ES6]`

      Returns the square root of the sum of the squares of ``values`` (Pythagorasâ€™
      theorem):

      .. code:: javascript
         :name: language-node-repl

         > Math.hypot(3, 4)
         5

   -  ``Math.sin(x: number): number`` :sup:`[ES1]`

      Returns the sine of ``x``.

      .. code:: javascript
         :name: language-node-repl

         > Math.sin(0)
         0
         > Math.sin(Math.PI / 2)
         1

   -  ``Math.sinh(x: number): number`` :sup:`[ES6]`

      Returns the hyperbolic sine of ``x``.

   -  ``Math.tan(x: number): number`` :sup:`[ES1]`

      Returns the tangent of ``x``.

      .. code:: javascript
         :name: language-node-repl

         > Math.tan(0)
         0
         > Math.tan(1)
         1.5574077246549023

   -  ``Math.tanh(x: number): number;`` :sup:`[ES6]`

      Returns the hyperbolic tangent of ``x``.

19.5â€ƒVarious other functions
-----------------------------

   -  ``Math.abs(x: number): number`` :sup:`[ES1]`

      Returns the absolute value of ``x``.

      .. code:: javascript
         :name: language-node-repl

         > Math.abs(3)
         3
         > Math.abs(-3)
         3
         > Math.abs(0)
         0

   -  ``Math.clz32(x: number): number`` :sup:`[ES6]`

      Counts the leading zero bits in the 32-bit integer ``x``. Used in DSP
      algorithms.

      .. code:: javascript
         :name: language-node-repl

         > Math.clz32(0b01000000000000000000000000000000)
         1
         > Math.clz32(0b00100000000000000000000000000000)
         2
         > Math.clz32(2)
         30
         > Math.clz32(1)
         31

   -  ``Math.max(...values: Array<number>): number`` :sup:`[ES1]`

      Converts ``values`` to numbers and returns the largest one.

      .. code:: javascript
         :name: language-node-repl

         > Math.max(3, -5, 24)
         24

   -  ``Math.min(...values: Array<number>): number`` :sup:`[ES1]`

      Converts ``values`` to numbers and returns the smallest one.

      .. code:: javascript
         :name: language-node-repl

         > Math.min(3, -5, 24)
         -5

   -  ``Math.random(): number`` :sup:`[ES1]`

      Returns a pseudo-random number ``n`` where 0 â‰¤ ``n < 1.

      .. code:: javascript

         /** Returns a random integer i with 0 <= i < max */
         function getRandomInteger(max) {
         return Math.floor(Math.random() * max);
         }

   -  ``Math.sign(x: number): number`` :sup:`[ES6]`

      Returns the sign of a number:

      .. code:: javascript
         :name: language-node-repl

         > Math.sign(-8)
         -1
         > Math.sign(0)
         0
         > Math.sign(3)
         1



.. _sources-1:

19.6â€ƒSources
-------------

   -  Wikipedia
   -  `TypeScriptâ€™s built-in
      typings <https://github.com/microsoft/TypeScript/tree/main/src/lib/>`__
   -  `MDN web docs for
      JavaScript <https://developer.mozilla.org/en-US/docs/Web/JavaScript>`__
   -  `ECMAScript language specification <https://tc39.es/ecma262/>`__

   `Comments <https://github.com/rauschma/exploring-js/issues/12>`__


.. _ch_bigints:

20â€ƒBigints â€“ arbitrary-precision integers [ES2020] (advanced)
==============================================================

   #. `20.1â€ƒWhy bigints? <#why-bigints>`__
   #. `20.2â€ƒBigints <#bigints>`__

      #. `20.2.1â€ƒGoing beyond 53 bits for integers <#going-beyond-53-bits-for-integers>`__
      #. `20.2.2â€ƒExample: using bigints <#example-using-bigints>`__

   #. `20.3â€ƒBigint literals <#bigint-literals>`__

      #. `20.3.1â€ƒUnderscores (_) as separators in bigint literals [ES2021] <#numeric-separator-bigint-literals>`__

   #. `20.4â€ƒReusing number operators for bigints (overloading) <#reusing-number-operators-for-bigints-overloading>`__

      #. `20.4.1â€ƒArithmetic operators <#arithmetic-operators-1>`__
      #. `20.4.2â€ƒOrdering operators <#ordering-operators-1>`__
      #. `20.4.3â€ƒBitwise operators <#bitwise-operators-1>`__
      #. `20.4.4â€ƒLoose equality (==) and inequality (!=) <#loose-equality-and-inequality>`__
      #. `20.4.5â€ƒStrict equality (===) and inequality (!==) <#strict-equality-and-inequality>`__

   #. `20.5â€ƒThe wrapper constructor BigInt <#the-wrapper-constructor-bigint>`__

      #. `20.5.1â€ƒBigInt as a constructor and as a function <#bigint-as-a-constructor-and-as-a-function>`__
      #. `20.5.2â€ƒBigInt.prototype.* methods <#bigint-prototype-methods>`__
      #. `20.5.3â€ƒBigInt.* methods <#bigint-methods>`__
      #. `20.5.4â€ƒCasting and 64-bit integers <#casting-and-64-bit-integers>`__

   #. `20.6â€ƒCoercing bigints to other primitive types <#coercing-bigints-to-other-primitive-types>`__
   #. `20.7â€ƒTypedArrays and DataView operations for 64-bit values <#typedarrays-and-dataview-operations-for-64-bit-values>`__
   #. `20.8â€ƒBigints and JSON <#bigints-and-json>`__

      #. `20.8.1â€ƒStringifying bigints <#stringifying-bigints>`__
      #. `20.8.2â€ƒParsing bigints <#parsing-bigints>`__

   #. `20.9â€ƒFAQ: Bigints <#faq-bigints>`__

      #. `20.9.1â€ƒHow do I decide when to use numbers and when to use bigints? <#how-do-i-decide-when-to-use-numbers-and-when-to-use-bigints>`__
      #. `20.9.2â€ƒWhy not just increase the precision of numbers in the same manner as is done for bigints? <#why-not-just-increase-the-precision-of-numbers-in-the-same-manner-as-is-done-for-bigints>`__

   In this chapter, we take a look at *bigints*, JavaScriptâ€™s integers whose
   storage space grows and shrinks as needed.

20.1â€ƒWhy bigints?
------------------

   Before ECMAScript 2020, JavaScript handled integers as follows:

   -  There only was a single type for floating point numbers and integers: 64-bit
      floating point numbers (IEEE 754 double precision).

   -  Under the hood, most JavaScript engines transparently supported integers: If
      a number has no decimal digits and is within a certain range, it can
      internally be stored as a genuine integer. This representation is called
      *small integer* and usually fits into 32 bits. For example, the range of
      small integers on the 64-bit version of the V8 engine is from âˆ’2\ :sup:`31`
      to 2\ :sup:`31`\ âˆ’1
      (`source <https://medium.com/fhinkel/v8-internals-how-small-is-a-small-integer-e0badc18b6da>`__).

   -  JavaScript numbers could also represent integers beyond the small integer
      range, as floating point numbers. Here, the safe range is plus/minus 53 bits.
      For more information on this topic, see `â€œSafe integersâ€
      (Â§18.9.3) <#safe-integers>`__.

   Sometimes, we need more than signed 53 bits â€“ for example:

   -  X (formerly Twitter) uses 64-bit integers as IDs for posts
      (`source <https://developer.x.com/en/docs/twitter-ids>`__). In JavaScript,
      these IDs had to be stored in strings.
   -  Financial technology uses so-called *big integers* (integers with arbitrary
      precision) to represent amounts of money. Internally, the amounts are
      multiplied so that the decimal numbers disappear. For example, USD amounts
      are multiplied by 100 so that the cents disappear.

20.2â€ƒBigints
-------------

   *Bigint* is a new primitive data type for integers. Bigints donâ€™t have a fixed
   storage size in bits; their sizes adapt to the integers they represent:

   -  Small integers are represented with fewer bits than large integers.
   -  There is no negative lower limit or positive upper limit for the integers
      that can be represented.

   A bigint literal is a sequence of one or more digits, suffixed with an ``n`` â€“
   for example:

   .. code:: javascript

      123n

   Operators such as ``-`` and ``*`` are overloaded and work with bigints:

   .. code:: javascript
      :name: language-node-repl

      > 123n * 456n
      56088n

   Bigints are primitive values. ``typeof`` returns a new result for them:

   .. code:: javascript
      :name: language-node-repl

      > typeof 123n
      'bigint'

20.2.1â€ƒGoing beyond 53 bits for integers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScript numbers are internally represented as a fraction multiplied by an
   exponent (see `â€œBackground: floating point precisionâ€
   (Â§18.8) <#floating-point-precision>`__ for details). As a
   consequence, if we go beyond the highest `safe
   integer <#safe-integers>`__ 2\ :sup:`53`\ âˆ’1, there are still
   *some* integers that can be represented, but with gaps between them:

   .. code:: javascript
      :name: language-node-repl

      > 2**53 - 2 // safe
      9007199254740990
      > 2**53 - 1 // safe
      9007199254740991

      > 2**53 // unsafe, same as next integer
      9007199254740992
      > 2**53 + 1
      9007199254740992
      > 2**53 + 2
      9007199254740994
      > 2**53 + 3
      9007199254740996
      > 2**53 + 4
      9007199254740996
      > 2**53 + 5
      9007199254740996

   Bigints enable us to go beyond 53 bits:

   .. code:: javascript
      :name: language-node-repl

      > 2n**53n
      9007199254740992n
      > 2n**53n + 1n
      9007199254740993n
      > 2n**53n + 2n
      9007199254740994n

20.2.2â€ƒExample: using bigints
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is what using bigints looks like (code based on an example in the
   proposal):

   .. code:: javascript

      /**
      * Takes a bigint as an argument and returns a bigint
      */
      function nthPrime(nth) {
      if (typeof nth !== 'bigint') {
         throw new TypeError();
      }
      function isPrime(p) {
         for (let i = 2n; i < p; i++) {
            if (p % i === 0n) return false;
         }
         return true;
      }
      for (let i = 2n; ; i++) {
         if (isPrime(i)) {
            if (--nth === 0n) return i;
         }
      }
      }

      assert.deepEqual(
      [1n, 2n, 3n, 4n, 5n].map(nth => nthPrime(nth)),
      [2n, 3n, 5n, 7n, 11n]
      );

20.3â€ƒBigint literals
---------------------

   Like number literals, bigint literals support several bases:

   -  Decimal: ``123n``
   -  Hexadecimal: ``0xFFn``
   -  Binary: ``0b1101n``
   -  Octal: ``0o777n``

   Negative bigints are produced by prefixing the unary minus operator: ``-0123n``



.. _numeric-separator-bigint-literals:

20.3.1â€ƒUnderscores (``_``) as separators in bigint literals [ES2021]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `Just like in number
   literals <#numeric-separator-number-literals>`__, we can use
   underscores (``_``) as separators in bigint literals:

   .. code:: javascript

      const massOfEarthInKg = 6_000_000_000_000_000_000_000_000n;

   Bigints are often used to represent money in the financial technical sector.
   Separators can help here, too:

   .. code:: javascript

      const priceInCents = 123_000_00n; // 123 thousand dollars

   As with number literals, two restrictions apply:

   -  We can only put an underscore between two digits.
   -  We can use at most one underscore in a row.

20.4â€ƒReusing number operators for bigints (overloading)
--------------------------------------------------------

   With most operators, we are not allowed to mix bigints and numbers. If we do,
   exceptions are thrown:

   .. code:: javascript
      :name: language-node-repl

      > 2n + 1
      TypeError: Cannot mix BigInt and other types, use explicit conversions

   The reason for this rule is that there is no general way of coercing a number
   and a bigint to a common type: numbers canâ€™t represent bigints beyond 53 bits,
   bigints canâ€™t represent fractions. Therefore, the exceptions warn us about typos
   that may lead to unexpected results.

   For example, should the result of the following expression be
   ``9007199254740993n`` or ``9007199254740992``?

   .. code:: javascript

      2**53 + 1n

   It is also not clear what the result of the following expression should be:

   .. code:: javascript

      2n**53n * 3.3



.. _arithmetic-operators-1:

20.4.1â€ƒArithmetic operators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Binary ``+``, binary ``-``, ``*``, ``**`` work as expected:

   .. code:: javascript
      :name: language-node-repl

      > 7n * 3n
      21n

   It is OK to mix bigints and strings:

   .. code:: javascript
      :name: language-node-repl

      > 6n + ' apples'
      '6 apples'

   ``/``, ``%`` round towards zero (like ``Math.trunc()``):

   .. code:: javascript
      :name: language-node-repl

      > 1n / 2n
      0n

   Unary ``-`` works as expected:

   .. code:: javascript
      :name: language-node-repl

      > -(-64n)
      64n

   Unary ``+`` is not supported for bigints because much code relies on it coercing
   its operand to number:

   .. code:: javascript
      :name: language-node-repl

      > +23n
      TypeError: Cannot convert a BigInt value to a number



.. _ordering-operators-1:

20.4.2â€ƒOrdering operators
~~~~~~~~~~~~~~~~~~~~~~~~~~

   Ordering operators ``<``, ``>``, ``>=``, ``<=`` work as expected:

   .. code:: javascript
      :name: language-node-repl

      > 17n <= 17n
      true
      > 3n > -1n
      true

   Comparing bigints and numbers does not pose any risks. Therefore, we can mix
   bigints and numbers:

   .. code:: javascript
      :name: language-node-repl

      > 3n > -1
      true



.. _bitwise-operators-1:

20.4.3â€ƒBitwise operators
~~~~~~~~~~~~~~~~~~~~~~~~~

20.4.3.1â€ƒBitwise operators for numbers
'''''''''''''''''''''''''''''''''''''''

   Bitwise operators interpret numbers as 32-bit integers. These integers are
   either unsigned or signed. If they are signed, the negative of an integer is its
   *twoâ€™s complement* (adding an integer to its twoâ€™s complement â€“ while ignoring
   overflow â€“ produces zero):

   .. code:: javascript
      :name: language-node-repl

      > 2**32-1 >> 0
      -1

   Due to these integers having a fixed size, their highest bits indicate their
   signs:

   .. code:: javascript
      :name: language-node-repl

      > 2**31 >> 0 // highest bit is 1
      -2147483648
      > 2**31 - 1 >> 0 // highest bit is 0
      2147483647

20.4.3.2â€ƒBitwise operators for bigints
'''''''''''''''''''''''''''''''''''''''

   For bigints, bitwise operators interpret a negative sign as an infinite twoâ€™s
   complement â€“ for example:

   -  ``-1`` is ``Â·Â·Â·111111`` (ones extend infinitely to the left)
   -  ``-2`` is ``Â·Â·Â·111110``
   -  ``-3`` is ``Â·Â·Â·111101``
   -  ``-4`` is ``Â·Â·Â·111100``

   That is, a negative sign is more of an external flag and not represented as an
   actual bit.

20.4.3.3â€ƒBitwise Not (``~``)
'''''''''''''''''''''''''''''

   Bitwise Not (``~``) inverts all bits:

   .. code:: javascript
      :name: language-node-repl

      > ~0b10n
      -3n
      > ~0n
      -1n
      > ~-2n
      1n



.. _binary-bitwise-operators-1:

20.4.3.4â€ƒBinary bitwise operators (``&``, ``|``, ``^``)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Applying binary bitwise operators to bigints works analogously to applying them
   to numbers:

   .. code:: javascript
      :name: language-node-repl

      > (0b1010n |  0b0111n).toString(2)
      '1111'
      > (0b1010n &  0b0111n).toString(2)
      '10'

      > (0b1010n | -1n).toString(2)
      '-1'
      > (0b1010n & -1n).toString(2)
      '1010'

20.4.3.5â€ƒBitwise signed shift operators (``<<`` and ``>>``)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The signed shift operators for bigints preserve the sign of a number:

   .. code:: javascript
      :name: language-node-repl

      > 2n << 1n
      4n
      > -2n << 1n
      -4n

      > 2n >> 1n
      1n
      > -2n >> 1n
      -1n

   Recall that ``-1n`` is a sequence of ones that extends infinitely to the left.
   Thatâ€™s why shifting it left doesnâ€™t change it:

   .. code:: javascript
      :name: language-node-repl

      > -1n >> 20n
      -1n

20.4.3.6â€ƒBitwise unsigned right shift operator (``>>>``)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   There is no unsigned right shift operator for bigints:

   .. code:: javascript
      :name: language-node-repl

      > 2n >>> 1n
      TypeError: BigInts have no unsigned right shift, use >> instead

   Why? The idea behind unsigned right shifting is that a zero is shifted in â€œfrom
   the leftâ€. In other words, the assumption is that there is a finite amount of
   binary digits.

   However, with bigints, there is no â€œleftâ€, their binary digits extend
   infinitely. This is especially important with negative numbers.

   Signed right shift works even with an infinite number of digits because the
   highest digit is preserved. Therefore, it can be adapted to bigints.

20.4.4â€ƒLoose equality (``==``) and inequality (``!=``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Loose equality (``==``) and inequality (``!=``) coerce values:

   .. code:: javascript
      :name: language-node-repl

      > 0n == false
      true
      > 1n == true
      true

      > 123n == 123
      true

      > 123n == '123'
      true

20.4.5â€ƒStrict equality (``===``) and inequality (``!==``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Strict equality (``===``) and inequality (``!==``) only consider values to be
   equal if they have the same type:

   .. code:: javascript
      :name: language-node-repl

      > 123n === 123
      false
      > 123n === 123n
      true

20.5â€ƒThe wrapper constructor ``BigInt``
----------------------------------------

   Analogously to numbers, bigints have the associated wrapper constructor
   ``BigInt``.

20.5.1â€ƒ``BigInt`` as a constructor and as a function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``new BigInt()``: throws a ``TypeError``.

   -  ``BigInt(x)`` converts arbitrary values ``x`` to bigint. This works similarly
      to ``Number()``, with several differences which are summarized in `table
      20.1 <#tbl:converting-values-to-bigints>`__ and explained in more detail in
      the following subsections.

   =============== =====================================
   x               `BigInt(x)`
   undefined       Throws `TypeError`
   null            Throws `TypeError`
   boolean         false â†’ 0n, true â†’ 1n
   number          Example: 123 â†’ 123n
   \               Non-integer â†’ throws RangeError
   bigint          x (no change)
   string          Example: '123' â†’ 123n
   \               Unparsable â†’ throws SyntaxError
   symbol          Throws `TypeError`
   object          Configurable (e.g. via .valueOf())
   =============== =====================================
   
   Table 20.1: Converting values to bigints.

20.5.1.1â€ƒConverting ``undefined`` and ``null``
'''''''''''''''''''''''''''''''''''''''''''''''

   A ``TypeError`` is thrown if ``x`` is either ``undefined`` or ``null``:

   .. code:: javascript
      :name: language-node-repl

      > BigInt(undefined)
      TypeError: Cannot convert undefined to a BigInt
      > BigInt(null)
      TypeError: Cannot convert null to a BigInt

20.5.1.2â€ƒConverting strings
''''''''''''''''''''''''''''

   If a string does not represent an integer, ``BigInt()`` throws a ``SyntaxError``
   (whereas ``Number()`` returns the error value ``NaN``):

   .. code:: javascript
      :name: language-node-repl

      > BigInt('abc')
      SyntaxError: Cannot convert abc to a BigInt

   The suffix ``'n'`` is not allowed:

   .. code:: javascript
      :name: language-node-repl

      > BigInt('123n')
      SyntaxError: Cannot convert 123n to a BigInt

   All bases of bigint literals are allowed:

   .. code:: javascript
      :name: language-node-repl

      > BigInt('123')
      123n
      > BigInt('0xFF')
      255n
      > BigInt('0b1101')
      13n
      > BigInt('0o777')
      511n

20.5.1.3â€ƒNon-integer numbers produce exceptions
''''''''''''''''''''''''''''''''''''''''''''''''

   .. code:: javascript
      :name: language-node-repl

      > BigInt(123.45)
      RangeError: The number 123.45 cannot be converted to a BigInt because
      it is not an integer
      > BigInt(123)
      123n

20.5.1.4â€ƒConverting objects
''''''''''''''''''''''''''''

   How objects are converted to bigints can be configured â€“ for example, by
   overriding ``.valueOf()``:

   .. code:: javascript
      :name: language-node-repl

      > BigInt({valueOf() {return 123n}})
      123n



.. _bigint-prototype-methods:

20.5.2â€ƒ``BigInt.prototype.*`` methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``BigInt.prototype`` holds the methods â€œinheritedâ€ by primitive bigints:

   -  ``BigInt.prototype.toLocaleString(locales?, options?)``
   -  ``BigInt.prototype.toString(radix?)``
   -  ``BigInt.prototype.valueOf()``



.. _bigint-methods:

20.5.3â€ƒ``BigInt.*`` methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``BigInt.asIntN(width, theInt)``

   Casts ``theInt`` to ``width`` bits (signed). This influences how the value is
   represented internally.

   -  ``BigInt.asUintN(width, theInt)``

   Casts ``theInt`` to ``width`` bits (unsigned).

20.5.4â€ƒCasting and 64-bit integers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Casting allows us to create integer values with a specific number of bits. If we
   want to restrict ourselves to just 64-bit integers, we have to always cast:

   .. code:: javascript

      const uint64a = BigInt.asUintN(64, 12345n);
      const uint64b = BigInt.asUintN(64, 67890n);
      const result = BigInt.asUintN(64, uint64a * uint64b);

20.6â€ƒCoercing bigints to other primitive types
-----------------------------------------------

   This table show what happens if we convert bigints to other primitive types:

   =========== ============================ ===============================
   Convert to  Explicit conversion          Coercion (implicit conversion)
   boolean     Boolean(0n) â†’ false          !0n â†’ true
   \           Boolean(int) â†’ true          !int â†’ false
   number      Number(7n) â†’ 7 (example)     +int â†’ TypeError (1)
   string      String(7n) â†’ '7' (example)   ''+7n â†’ '7' (example)
   =========== ============================ ===============================

   Footnote:

   -  (1) Unary ``+`` is not supported for bigints, because much code relies on it
      coercing its operand to number.

20.7â€ƒTypedArrays and DataView operations for 64-bit values
-----------------------------------------------------------

   Thanks to bigints, Typed Arrays and DataViews can support 64-bit values:

   -  Typed Array constructors:

      -  ``BigInt64Array``
      -  ``BigUint64Array``

   -  DataView methods:

      -  ``DataView.prototype.getBigInt64()``
      -  ``DataView.prototype.setBigInt64()``
      -  ``DataView.prototype.getBigUint64()``
      -  ``DataView.prototype.setBigUint64()``

20.8â€ƒBigints and JSON
----------------------

   The JSON standard is fixed and wonâ€™t change. The upside is that old JSON parsing
   code will never be outdated. The downside is that JSON canâ€™t be extended to
   contain bigints.

   Stringifying bigints throws exceptions:

   .. code:: javascript
      :name: language-node-repl

      > JSON.stringify(123n)
      TypeError: Do not know how to serialize a BigInt
      > JSON.stringify([123n])
      TypeError: Do not know how to serialize a BigInt

20.8.1â€ƒStringifying bigints
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Therefore, our best option is to store bigints in strings:

   .. code:: javascript

      const bigintPrefix = '[[bigint]]';

      function bigintReplacer(_key, value) {
      if (typeof value === 'bigint') {
         return bigintPrefix + value;
      }
      return value;
      }

      const data = { value: 9007199254740993n };
      assert.equal(
      JSON.stringify(data, bigintReplacer),
      '{"value":"[[bigint]]9007199254740993"}'
      );

20.8.2â€ƒParsing bigints
~~~~~~~~~~~~~~~~~~~~~~~

   The following code shows how to parse strings such as the one that we have
   produced in the previous example.

   .. code:: javascript

      function bigintReviver(_key, value) {
      if (typeof value === 'string' && value.startsWith(bigintPrefix)) {
         return BigInt(value.slice(bigintPrefix.length));
      }
      return value;
      }

      const str = '{"value":"[[bigint]]9007199254740993"}';
      assert.deepEqual(
      JSON.parse(str, bigintReviver),
      { value: 9007199254740993n }
      );

20.9â€ƒFAQ: Bigints
------------------

20.9.1â€ƒHow do I decide when to use numbers and when to use bigints?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   My recommendations:

   -  Use numbers for up to 53 bits and for Array indices. Rationale: They already
      appear everywhere and are handled efficiently by most engines (especially if
      they fit into 31 bits). Appearances include:

      -  ``Array.prototype.forEach()``
      -  ``Array.prototype.entries()``

   -  Use bigints for large numeric values: If your fraction-less values donâ€™t fit
      into 53 bits, you have no choice but to move to bigints.

   All existing web APIs return and accept only numbers and will only upgrade to
   bigint on a case-by-case basis.

20.9.2â€ƒWhy not just increase the precision of numbers in the same manner as is done for bigints?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   One could conceivably split ``number`` into ``integer`` and ``double``, but that
   would add many new complexities to the language (several integer-only operators
   etc.). Iâ€™ve sketched the consequences in `a Gist <https://gist.github.com/rauschma/13d48d1c49615ce2396ce7c9e45d4cd1>`__.
 
   --------------

   **Acknowledgements:**

   -  Thanks to Daniel Ehrenberg for reviewing an earlier version of this content.
   -  Thanks to Dan Callahan for reviewing an earlier version of this content.

   `Comments <https://github.com/rauschma/exploring-js/issues/50>`__


.. _ch_unicode:

21â€ƒUnicode â€“ a brief introduction (advanced)
=============================================

   #. `21.1â€ƒCode points vs. code units <#code-points-vs-code-units>`__

      #. `21.1.1â€ƒCode points <#code-points>`__
      #. `21.1.2â€ƒEncoding Unicode code points: UTF-32, UTF-16, UTF-8 <#encoding-unicode-code-points-utf-32-utf-16-utf-8>`__

   #. `21.2â€ƒEncodings used in web development: UTF-16 and UTF-8 <#encodings-used-in-web-development-utf-16-and-utf-8>`__

      #. `21.2.1â€ƒSource code internally: UTF-16 <#source-code-internally-utf-16>`__
      #. `21.2.2â€ƒStrings: UTF-16 <#strings-utf-16>`__
      #. `21.2.3â€ƒSource code in files: UTF-8 <#source-code-in-files-utf-8>`__

   #. `21.3â€ƒGrapheme clusters â€“ the real characters <#grapheme-clusters>`__

      #. `21.3.1â€ƒGrapheme clusters vs. glyphs <#grapheme-clusters-vs-glyphs>`__

   Unicode is a standard for representing and managing text in most of the worldâ€™s
   writing systems. Virtually all modern software that works with text, supports
   Unicode. The standard is maintained by the Unicode Consortium. A new version of
   the standard is published every year (with new emojis, etc.). Unicode version
   1.0.0 was published in October 1991.



.. _code-points-vs-code-units:

21.1â€ƒCode points vs. code units
--------------------------------

   Two concepts are crucial for understanding Unicode:

   -  *Code points* are numbers that represent the atomic parts of Unicode text.
      Most of them represent visible symbols but they can also have other meanings
      such as specifying an aspect of a symbol (the accent of a letter, the skin
      tone of an emoji, etc.).
   -  *Code units* are numbers that encode code points, to store or transmit
      Unicode text. One or more code units encode a single code point. Each code
      unit has the same size, which depends on the *encoding format* that is used.
      The most popular format, UTF-8, has 8-bit code units.

21.1.1â€ƒCode points
~~~~~~~~~~~~~~~~~~~

   The first version of Unicode had 16-bit code points. Since then, the number of
   characters has grown considerably and the size of code points was extended to 21
   bits. These 21 bits are partitioned in 17 planes, with 16 bits each:

   -  Plane 0: **Basic Multilingual Plane (BMP)**, 0x0000â€“0xFFFF

      -  Contains characters for almost all modern languages (Latin characters,
         Asian characters, etc.) and many symbols.

   -  Plane 1: Supplementary Multilingual Plane (SMP), 0x10000â€“0x1FFFF

      -  Supports historic writing systems (e.g., Egyptian hieroglyphs and
         cuneiform) and additional modern writing systems.
      -  Supports emojis and many other symbols.

   -  Plane 2: Supplementary Ideographic Plane (SIP), 0x20000â€“0x2FFFF

      -  Contains additional CJK (Chinese, Japanese, Korean) ideographs.

   -  Plane 3â€“13: Unassigned
   -  Plane 14: Supplementary Special-Purpose Plane (SSP), 0xE0000â€“0xEFFFF

      -  Contains non-graphical characters such as tag characters and glyph
         variation selectors.

   -  Plane 15â€“16: Supplementary Private Use Area (S PUA A/B), 0x0F0000â€“0x10FFFF

      -  Available for character assignment by parties outside the ISO and the
         Unicode Consortium. Not standardized.

   Planes 1-16 are called supplementary planes or **astral planes**.

   Letâ€™s check the code points of a few characters:

   .. code:: javascript
      :name: language-node-repl

      > 'A'.codePointAt(0).toString(16)
      '41'
      > 'Ã¼'.codePointAt(0).toString(16)
      'fc'
      > 'Ï€'.codePointAt(0).toString(16)
      '3c0'
      > 'ğŸ™‚'.codePointAt(0).toString(16)
      '1f642'

   The hexadecimal numbers of the code points tell us that the first three
   characters reside in plane 0 (within 16 bits), while the emoji resides in plane
   1.

21.1.2â€ƒEncoding Unicode code points: UTF-32, UTF-16, UTF-8
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The main ways of encoding code points are three *Unicode Transformation Formats*
   (UTFs): UTF-32, UTF-16, UTF-8. The number at the end of each format indicates
   the size (in bits) of its code units.

21.1.2.1â€ƒUTF-32 (Unicode Transformation Format 32)
'''''''''''''''''''''''''''''''''''''''''''''''''''

   UTF-32 uses 32 bits to store code units, resulting in one code unit per code
   point. This format is the only one with *fixed-length encoding*; all others use
   a varying number of code units to encode a single code point.



.. _utf-16:

21.1.2.2â€ƒUTF-16 (Unicode Transformation Format 16)
'''''''''''''''''''''''''''''''''''''''''''''''''''

   UTF-16 uses 16-bit code units. It encodes code points as follows:

   -  The BMP (first 16 bits of Unicode) is stored in single code units.

   -  Astral planes: The BMP comprises 0x10_000 code points. Given that Unicode has
      a total of 0x110_000 code points, we still need to encode the remaining
      0x100_000 code points (20 bits). The BMP has two ranges of unassigned code
      points that provide the necessary storage:

      -  Most significant 10 bits (*leading surrogate*, *high surrogate*):
         0xD800-0xDBFF
      -  Least significant 10 bits (*trailing surrogate*, *low surrogate*):
         0xDC00-0xDFFF

   As a consequence, each UTF-16 code unit is either:

   -  A BMP code point (a *scalar*)
   -  A leading surrogate
   -  A trailing surrogate

   If a surrogate appears on its own, without its partner, it is called a *lone
   surrogate*.

   This is how the bits of the code points are distributed among the surrogates:

   ::

      0bhhhhhhhhhhllllllllll // code point - 0x10000
      0b110110hhhhhhhhhh     // 0xD800 + 0bhhhhhhhhhh
      0b110111llllllllll     // 0xDC00 + 0bllllllllll

   As an example, consider code point 0x1F642 (ğŸ™‚) that is represented by two
   UTF-16 code units â€“ 0xD83D and 0xDE42:

   .. code:: javascript
      :name: language-node-repl

      > 'ğŸ™‚'.codePointAt(0).toString(16)
      '1f642'
      > 'ğŸ™‚'.length
      2
      > 'ğŸ™‚'.split('')
      [ '\uD83D', '\uDE42' ]

   Letâ€™s derive the code units from the code point:

   .. code:: javascript
      :name: language-node-repl

      > (0x1F642 - 0x10000).toString(2).padStart(20, '0')
      '00001111011001000010'
      > (0xD800 + 0b0000111101).toString(16)
      'd83d'
      > (0xDC00 + 0b1001000010).toString(16)
      'de42'

   In contrast, code point 0x03C0 (Ï€) is part of the BMP and therefore represented
   by a single UTF-16 code unit â€“ 0x03C0:

   .. code:: javascript
      :name: language-node-repl

      > 'Ï€'.length
      1

21.1.2.3â€ƒUTF-8 (Unicode Transformation Format 8)
'''''''''''''''''''''''''''''''''''''''''''''''''

   UTF-8 has 8-bit code units. It uses 1â€“4 code units to encode a code point:

   ================= ======================================================
   Code points       Code units
   0000â€“007F         0bbbbbbb (7 bits)
   0080â€“07FF         110bbbbb, 10bbbbbb (5+6 bits)
   0800â€“FFFF         1110bbbb, 10bbbbbb, 10bbbbbb (4+6+6 bits)
   10000â€“1FFFFF      11110bbb, 10bbbbbb, 10bbbbbb, 10bbbbbb (3+6+6+6 bits)
   ================= ======================================================

   Notes:

   -  The bit prefix of each code unit tells us:

      -  Is it first in a series of code units? If yes, how many code units will
         follow?
      -  Is it second or later in a series of code units?

   -  The character mappings in the 0000â€“007F range are the same as ASCII, which
      leads to a degree of backward compatibility with older software.

   Three examples:

   ============ ============= ========================================
   Character    Code point    Code units 
   A            0x0041        01000001
   Ï€            0x03C0        11001111, 10000000
   ``ğŸ™‚``        0x1F642       11110000, 10011111, 10011001, 10000010
   ============ ============= ========================================

21.2â€ƒEncodings used in web development: UTF-16 and UTF-8
---------------------------------------------------------

   The Unicode encoding formats that are used in web development are: UTF-16 and
   UTF-8.

21.2.1â€ƒSource code internally: UTF-16
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The ECMAScript specification internally represents source code as UTF-16.

21.2.2â€ƒStrings: UTF-16
~~~~~~~~~~~~~~~~~~~~~~~

   The characters in JavaScript strings are based on UTF-16 code units:

   .. code:: javascript
      :name: language-node-repl

      > const smiley = 'ğŸ™‚';
      > smiley.length
      2
      > smiley === '\uD83D\uDE42' // code units
      true

   For more information on Unicode and strings, consult `â€œAtoms of text: code
   points, JavaScript characters, grapheme clustersâ€
   (Â§22.7) <#atoms-of-text>`__.

21.2.3â€ƒSource code in files: UTF-8
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   HTML and JavaScript are almost always encoded as UTF-8 these days.

   For example, this is how HTML files usually start now:

   .. code:: language-html

      <!doctype html>
      <html>
      <head>
      <meta charset="UTF-8">
      Â·Â·Â·

   For HTML modules loaded in web browsers, the `standard
   encoding <https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script>`__
   is also UTF-8.



.. _grapheme-clusters:

21.3â€ƒGrapheme clusters â€“ the real characters
---------------------------------------------

   The concept of a character becomes remarkably complex once we consider the
   various writing systems of the world. Thatâ€™s why there are several different
   Unicode terms that all mean â€œcharacterâ€ in some way: *code point*, *grapheme
   cluster*, *glyph*, etc.

   In Unicode, a *code point* is an atomic part of text.

   However, a *grapheme cluster* corresponds most closely to a symbol displayed on
   screen or paper. It is defined as â€œa horizontally segmentable unit of textâ€.
   Therefore, `official Unicode
   documents <https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries>`__
   also call it a *user-perceived character*. One or more code points are needed to
   encode a grapheme cluster.

   For example, the Devanagari *kshi* is encoded by 4 code points. We use
   ``Array.from()`` to split a string into an Array with code points (for details,
   consult `â€œWorking with code pointsâ€
   (Â§22.7.1) <#working-with-code-points>`__):

      |Splitting the grapheme cluster for the Devanagari \_kshi\_ into code
      points.|

   Flag emojis are also grapheme clusters and composed of two code points â€“ for
   example, the flag of Japan:

      |Splitting a flag emoji into code points.|



.. _grapheme-clusters-vs-glyphs:

21.3.1â€ƒGrapheme clusters vs. glyphs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A symbol is an abstract concept and part of written language:

   -  It is represented in computer memory by a *grapheme cluster* â€“ a sequence of
      one or more numbers (code points).
   -  It is drawn on screen via *glyphs*. A glyph is an image and usually stored in
      a font. More than one glyph may be used to draw a single symbol â€“ for
      example, the symbol â€œÃ©â€ may be drawn by combining the glyph â€œeâ€ with the
      glyph â€œÂ´â€.

   The distinction between a concept and its representation is subtle and can blur
   when talking about Unicode.

   .. container:: boxout

      |Icon â€œexternalâ€|â€‚**More information on grapheme clusters**

      .. container:: boxout-vspace

      For more information, consult `â€œLetâ€™s Stop Ascribing Meaning to Code
      Pointsâ€ <https://manishearth.github.io/blog/2017/01/14/stop-ascribing-meaning-to-unicode-code-points/>`__
      by Manish Goregaokar.

   `Comments <https://github.com/rauschma/exploring-js/issues/41>`__

   .. |Splitting the grapheme cluster for the Devanagari \_kshi\_ into code points.| image:: https://exploringjs.com/js/book/img-book/unicode/devanagari-kshi.png
      :width: 154px
      :height: 55px
   .. |Splitting a flag emoji into code points.| image:: https://exploringjs.com/js/book/img-book/unicode/emoji-flag-japan.png
      :width: 119px
      :height: 54px


.. _ch_strings:

22â€ƒStrings
===========

   #. `22.1â€ƒCheat sheet: strings <#cheat-sheet-strings>`__

      #. `22.1.1â€ƒWorking with strings <#working-with-strings>`__
      #. `22.1.2â€ƒJavaScript characters vs. code points vs. grapheme clusters <#javascript-characters-vs-code-points-vs-grapheme-clusters>`__
      #. `22.1.3â€ƒString methods <#string-methods>`__

   #. `22.2â€ƒPlain string literals <#plain-string-literals>`__

      #. `22.2.1â€ƒEscaping <#escaping>`__

   #. `22.3â€ƒAccessing JavaScript characters <#accessing-javascript-characters>`__
   #. `22.4â€ƒString concatenation <#string-concatenation>`__

      #. `22.4.1â€ƒString concatenation via + <#string-concatenation-via-plus>`__
      #. `22.4.2â€ƒConcatenating via Arrays (.push() and .join()) <#string-concatenation-via-arrays>`__

   #. `22.5â€ƒConverting to string <#converting-to-string>`__

      #. `22.5.1â€ƒStringifying objects <#stringifying-objects>`__
      #. `22.5.2â€ƒCustomizing the stringification of objects <#customizing-the-stringification-of-objects>`__
      #. `22.5.3â€ƒAn alternate way of stringifying values <#an-alternate-way-of-stringifying-values>`__

   #. `22.6â€ƒComparing strings <#comparing-strings>`__
   #. `22.7â€ƒAtoms of text: code points, JavaScript characters, grapheme clusters <#atoms-of-text>`__

      #. `22.7.1â€ƒWorking with code points <#working-with-code-points>`__
      #. `22.7.2â€ƒWorking with code units (char codes) <#working-with-code-units-char-codes>`__
      #. `22.7.3â€ƒASCII escapes <#ascii-escapes>`__
      #. `22.7.4â€ƒCaveat: grapheme clusters <#caveat-grapheme-clusters>`__

   #. `22.8â€ƒQuick reference: Strings <#quickref-string>`__

      #. `22.8.1â€ƒConverting to string <#converting-to-string-1>`__
      #. `22.8.2â€ƒNumeric values of text atoms <#numeric-values-of-text-atoms>`__
      #. `22.8.3â€ƒString.prototype.*: finding and matching <#string-prototype-finding-and-matching>`__
      #. `22.8.4â€ƒString.prototype.*: extracting <#string-api-extracting>`__
      #. `22.8.5â€ƒString.prototype.*: combining <#string-prototype-combining>`__
      #. `22.8.6â€ƒString.prototype.*: transforming <#string-prototype-transforming>`__
      #. `22.8.7â€ƒSources of this quick reference <#sources-of-this-quick-reference>`__

22.1â€ƒCheat sheet: strings
--------------------------

   Strings are primitive values in JavaScript and immutable. That is,
   string-related operations always produce new strings and never change existing
   strings.

22.1.1â€ƒWorking with strings
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Literals for strings:

   .. code:: javascript

      const str1 = 'Don\'t say "goodbye"'; // string literal
      const str2 = "Don't say \"goodbye\""; // string literals
      assert.equal(
      `As easy as ${123}!`, // template literal
      'As easy as 123!',
      );

   Backslashes are used to:

   -  Escape literal delimiters (first 2 lines of previous example)
   -  Represent special characters:

      -  ``\\`` represents a backslash
      -  ``\n`` represents a newline
      -  ``\r`` represents a carriage return
      -  ``\t`` represents a tab

   Inside a ``String.raw`` tagged template (line A), backslashes are treated as
   normal characters:

   .. code:: javascript

      assert.equal(
      String.raw`\ \n\t`, // (A)
      '\\ \\n\\t',
      );

   Convertings values to strings:

   .. code:: javascript
      :name: language-node-repl

      > String(undefined)
      'undefined'
      > String(null)
      'null'
      > String(123.45)
      '123.45'
      > String(true)
      'true'

   Copying parts of a string

   .. code:: javascript

      // There is no type for characters;
      // reading characters produces strings:
      const str3 = 'abc';
      assert.equal(
      str3[2], 'c' // no negative indices allowed
      );
      assert.equal(
      str3.at(-1), 'c' // negative indices allowed
      );

      // Copying more than one character:
      assert.equal(
      'abc'.slice(0, 2), 'ab'
      );

   Concatenating strings:

   .. code:: javascript

      assert.equal(
      'I bought ' + 3 + ' apples',
      'I bought 3 apples',
      );

      let str = '';
      str += 'I bought ';
      str += 3;
      str += ' apples';
      assert.equal(
      str, 'I bought 3 apples',
      );



.. _javascript-characters-vs-code-points-vs-grapheme-clusters:

22.1.2â€ƒJavaScript characters vs. code points vs. grapheme clusters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   **JavaScript characters** are 16 bits in size. They are what is indexed in
   strings and what ``.length`` counts.

   **Code points** are the atomic parts of Unicode text. Most of them fit into one
   JavaScript character, some of them occupy two (especially emojis):

   .. code:: javascript

      assert.equal(
      'A'.length, 1
      );
      assert.equal(
      'ğŸ™‚'.length, 2
      );

   **Grapheme clusters** (*user-perceived characters*) represent written symbols.
   Each one comprises one or more code points.

   Due to these facts, we shouldnâ€™t split text into JavaScript characters, we
   should split it into grapheme clusters. For more information on how to handle
   text, see `â€œAtoms of text: code points, JavaScript characters, grapheme
   clustersâ€ (Â§22.7) <#atoms-of-text>`__.

22.1.3â€ƒString methods
~~~~~~~~~~~~~~~~~~~~~~

   This subsection gives a brief overview of the string API. There is `a more
   comprehensive quick reference <#quickref-string>`__ at the end of this chapter.

   Finding substrings:

   .. code:: javascript
      :name: language-node-repl

      > 'abca'.includes('a')
      true
      > 'abca'.startsWith('ab')
      true
      > 'abca'.endsWith('ca')
      true

      > 'abca'.indexOf('a')
      0
      > 'abca'.lastIndexOf('a')
      3

   Splitting and joining:

   .. code:: javascript

      assert.deepEqual(
      'a, b,c'.split(/, ?/),
      ['a', 'b', 'c']
      );
      assert.equal(
      ['a', 'b', 'c'].join(', '),
      'a, b, c'
      );

   Padding and trimming:

   .. code:: javascript
      :name: language-node-repl

      > '7'.padStart(3, '0')
      '007'
      > 'yes'.padEnd(6, '!')
      'yes!!!'

      > '\t abc\n '.trim()
      'abc'
      > '\t abc\n '.trimStart()
      'abc\n '
      > '\t abc\n '.trimEnd()
      '\t abc'

   Repeating and changing case:

   .. code:: javascript
      :name: language-node-repl

      > '*'.repeat(5)
      '*****'
      > '= b2b ='.toUpperCase()
      '= B2B ='
      > 'Î‘Î’Î“'.toLowerCase()
      'Î±Î²Î³'

22.2â€ƒPlain string literals
---------------------------

   Plain string literals are delimited by either single quotes or double quotes:

   .. code:: javascript

      const str1 = 'abc';
      const str2 = "abc";
      assert.equal(str1, str2);

   Single quotes are used more often because it makes it easier to mention HTML,
   where double quotes are preferred.

   `The next chapter <#ch_template-literals>`__ covers
   *template literals*, which give us:

   -  String interpolation
   -  Multiple lines
   -  Raw string literals (backslash has no special meaning)

22.2.1â€ƒEscaping
~~~~~~~~~~~~~~~~

   The backslash lets us create special characters:

   -  Unix line break: ``'\n'``
   -  Windows line break: ``'\r\n'``
   -  Tab: ``'\t'``
   -  Backslash: ``'\\'``

   The backslash also lets us use the delimiter of a string literal inside that
   literal:

   .. code:: javascript

      assert.equal(
      'She said: "Let\'s go!"',
      "She said: \"Let's go!\"");

22.3â€ƒAccessing JavaScript characters
-------------------------------------

   JavaScript has no extra data type for characters â€“ characters are always
   represented as strings.

   .. code:: javascript

      const str = 'abc';

      // Reading a JavaScript character at a given index
      assert.equal(str[1], 'b');

      // Counting the JavaScript characters in a string:
      assert.equal(str.length, 3);

   The characters we see on screen are called *grapheme clusters*. Most of them are
   represented by single JavaScript characters. However, there are also grapheme
   clusters (especially emojis) that are represented by multiple JavaScript
   characters:

   .. code:: javascript
      :name: language-node-repl

      > 'ğŸ™‚'.length
      2

   How that works is explained in `â€œAtoms of text: code points, JavaScript
   characters, grapheme clustersâ€ (Â§22.7) <#atoms-of-text>`__.

22.4â€ƒString concatenation
--------------------------



.. _string-concatenation-via-plus:

22.4.1â€ƒString concatenation via ``+``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If at least one operand is a string, the plus operator (``+``) converts any
   non-strings to strings and concatenates the result:

   .. code:: javascript

      assert.equal(3 + ' times ' + 4, '3 times 4');

   The assignment operator ``+=`` is useful if we want to assemble a string, piece
   by piece:

   .. code:: javascript

      let str = ''; // must be `let`!
      str += 'Say it';
      str += ' one more';
      str += ' time';

      assert.equal(str, 'Say it one more time');

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Concatenating via ``+`` is efficient**

      .. container:: boxout-vspace

      Using ``+`` to assemble strings is quite efficient because most JavaScript
      engines internally optimize it.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Concatenating strings**

      .. container:: boxout-vspace

      ``exercises/strings/concat_string_array_test.mjs``



.. _string-concatenation-via-arrays:

22.4.2â€ƒConcatenating via Arrays (``.push()`` and ``.join()``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Occasionally, taking a detour via an Array can be useful for concatenating
   strings â€“ especially if there is to be a separator between them (such as
   ``', '`` in line A):

   .. code:: javascript

      function getPackingList(isAbroad = false, days = 1) {
      const items = [];
      items.push('tooth brush');
      if (isAbroad) {
         items.push('passport');
      }
      if (days > 3) {
         items.push('water bottle');
      }
      return items.join(', '); // (A)
      }
      assert.equal(
      getPackingList(),
      'tooth brush'
      );
      assert.equal(
      getPackingList(true, 7),
      'tooth brush, passport, water bottle'
      );

22.5â€ƒConverting to string
--------------------------

   These are three ways of converting a value ``x`` to a string:

   -  ``String(x)``
   -  ``''+x``
   -  ``x.toString()`` (does not work for ``undefined`` and ``null``)

   Recommendation: use the descriptive and safe ``String()``.

   Examples:

   .. code:: javascript

      assert.equal(String(undefined), 'undefined');
      assert.equal(String(null), 'null');

      assert.equal(String(false), 'false');
      assert.equal(String(true), 'true');

      assert.equal(String(123.45), '123.45');

   Pitfall for booleans: If we convert a boolean to a string via ``String()``, we
   generally canâ€™t convert it back via ``Boolean()``:

   .. code:: javascript
      :name: language-node-repl

      > String(false)
      'false'
      > Boolean('false')
      true

   The only string for which ``Boolean()`` returns ``false``, is the empty string.

22.5.1â€ƒStringifying objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Plain objects have a default string representation that is not very useful:

   .. code:: javascript
      :name: language-node-repl

      > String({a: 1})
      '[object Object]'

   Arrays have a better string representation, but it still hides much information:

   .. code:: javascript
      :name: language-node-repl

      > String(['a', 'b'])
      'a,b'
      > String(['a', ['b']])
      'a,b'

      > String([1, 2])
      '1,2'
      > String(['1', '2'])
      '1,2'

      > String([true])
      'true'
      > String(['true'])
      'true'
      > String(true)
      'true'

   Stringifying functions, returns their source code:

   .. code:: javascript
      :name: language-node-repl

      > String(function f() {return 4})
      'function f() {return 4}'

22.5.2â€ƒCustomizing the stringification of objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We can override the built-in way of stringifying objects by implementing the
   method ``toString()``:

   .. code:: javascript

      const obj = {
      toString() {
         return 'hello';
      }
      };

      assert.equal(String(obj), 'hello');

22.5.3â€ƒAn alternate way of stringifying values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The JSON data format is a text representation of JavaScript values. Therefore,
   `JSON.stringify() <#JSON.stringify>`__ can also be used to
   convert values to strings:

   .. code:: javascript
      :name: language-node-repl

      > JSON.stringify({a: 1})
      '{"a":1}'
      > JSON.stringify(['a', ['b']])
      '["a",["b"]]'

   The caveat is that JSON only supports ``null``, booleans, numbers, strings,
   Arrays, and objects (which it always treats as if they were created by object
   literals).

   Tip: The third parameter lets us switch on multiline output and specify how much
   to indent â€“ for example:

   .. code:: javascript

      console.log(JSON.stringify({first: 'Jane', last: 'Doe'}, null, 2));

   This statement produces the following output:

   .. code:: language-txt

      {
      "first": "Jane",
      "last": "Doe"
      }

22.6â€ƒComparing strings
-----------------------

   Strings can be compared via the following operators:

   .. code:: language-txt

      < <= > >=

   There is one important caveat to consider: These operators compare based on the
   numeric values of JavaScript characters. That means that the order that
   JavaScript uses for strings is different from the one used in dictionaries and
   phone books:

   .. code:: javascript
      :name: language-node-repl

      > 'A' < 'B' // ok
      true
      > 'a' < 'B' // not ok
      false
      > 'Ã¤' < 'b' // not ok
      false

   Properly comparing text is beyond the scope of this book. It is supported via
   `the ECMAScript Internationalization API
   (``Intl``) <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl>`__.



.. _atoms-of-text:

22.7â€ƒAtoms of text: code points, JavaScript characters, grapheme clusters
--------------------------------------------------------------------------

   Quick recap of `â€œUnicode â€“ a brief introductionâ€
   (Â§21) <#ch_unicode>`__:

   -  *Code points* are the atomic parts of Unicode text. Each code point is 21
      bits in size.

   -  JavaScript strings implement Unicode via the encoding format UTF-16. It uses
      one or two 16-bit *code units* to encode a single code point.

      -  Each JavaScript character (as indexed in strings) is a code unit. In the
         JavaScript standard library, code units are also called *char codes*.

   -  *Grapheme clusters* (*user-perceived characters*) represent written symbols,
      as displayed on screen or paper. One or more code points are needed to encode
      a single grapheme cluster.

   The following code demonstrates that a single code point comprises one or two
   JavaScript characters. We count the latter via ``.length``:

   .. code:: javascript

      // 3 code points, 3 JavaScript characters:
      assert.equal('abc'.length, 3);

      // 1 code point, 2 JavaScript characters:
      assert.equal('ğŸ™‚'.length, 2);

   The following table summarizes the concepts we have just explored:

   Entity

   Size

   Encoded via

   JavaScript character (UTF-16 code unit)

   16 bits

   â€“

   Unicode code point

   21 bits

   1â€“2 code units

   Unicode grapheme cluster

   1+ code points

22.7.1â€ƒWorking with code points
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Letâ€™s explore JavaScriptâ€™s tools for working with code points.

   A *Unicode code point escape* lets us specify a code point hexadecimally (1â€“5
   digits). It produces one or two JavaScript characters.

   .. code:: javascript
      :name: language-node-repl

      > '\u{1F642}'
      'ğŸ™‚'

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Unicode escape sequences**

      .. container:: boxout-vspace

      In the ECMAScript language specification, *Unicode code point escapes* and
      *Unicode code unit escapes* (which weâ€™ll encounter later) are called *Unicode
      escape sequences*.

   ``String.fromCodePoint()`` converts a single code point to 1â€“2 JavaScript
   characters:

   .. code:: javascript
      :name: language-node-repl

      > String.fromCodePoint(0x1F642)
      'ğŸ™‚'

   ``.codePointAt()`` converts 1â€“2 JavaScript characters to a single code point:

   .. code:: javascript
      :name: language-node-repl

      > 'ğŸ™‚'.codePointAt(0).toString(16)
      '1f642'

   We can *iterate* over a string, which visits code points (not JavaScript
   characters). Iteration is described `later in this
   book <#ch_sync-iteration>`__. One way of iterating is via
   a ``for-of`` loop:

   .. code:: javascript

      const str = 'ğŸ™‚a';
      assert.equal(str.length, 3);

      for (const codePointChar of str) {
      console.log(codePointChar);
      }

   Output:

   ::

      ğŸ™‚
      a

   `Array.from() <#Array.from>`__ is also based on iteration and
   visits code points:

   .. code:: javascript
      :name: language-node-repl

      > Array.from('ğŸ™‚a')
      [ 'ğŸ™‚', 'a' ]

   That makes it a good tool for counting code points:

   .. code:: javascript
      :name: language-node-repl

      > Array.from('ğŸ™‚a').length
      2
      > 'ğŸ™‚a'.length
      3

22.7.2â€ƒWorking with code units (char codes)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Indices and lengths of strings are based on JavaScript characters (as
   represented by UTF-16 code units).

   To specify a code unit hexadecimally, we can use a *Unicode code unit escape*
   with exactly four hexadecimal digits:

   .. code:: javascript
      :name: language-node-repl

      > '\uD83D\uDE42'
      'ğŸ™‚'

   And we can use ``String.fromCharCode()``. *Char code* is the standard libraryâ€™s
   name for *code unit*:

   .. code:: javascript
      :name: language-node-repl

      > String.fromCharCode(0xD83D) + String.fromCharCode(0xDE42)
      'ğŸ™‚'

   To get the char code of a character, use ``.charCodeAt()``:

   .. code:: javascript
      :name: language-node-repl

      > 'ğŸ™‚'.charCodeAt(0).toString(16)
      'd83d'

22.7.3â€ƒASCII escapes
~~~~~~~~~~~~~~~~~~~~~

   If the code point of a character is below 256, we can refer to it via a *ASCII
   escape* with exactly two hexadecimal digits:

   .. code:: javascript
      :name: language-node-repl

      > 'He\x6C\x6Co'
      'Hello'

   (The official name of ASCII escapes is *Hexadecimal escape sequences* â€“ it was
   the first escape that used hexadecimal numbers.)

22.7.4â€ƒCaveat: grapheme clusters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   When working with text that may be written in any human language, itâ€™s best to
   split at the boundaries of grapheme clusters, not at the boundaries of code
   points.

   TC39 is working on
   `Intl.Segmenter <https://github.com/tc39/proposal-intl-segmenter>`__, a
   proposal for the ECMAScript Internationalization API to support Unicode
   segmentation (along grapheme cluster boundaries, word boundaries, sentence
   boundaries, etc.).

   Until that proposal becomes a standard, we can use one of several libraries that
   are available (do a web search for â€œJavaScript graphemeâ€).



.. _quickref-string:

22.8â€ƒQuick reference: Strings
------------------------------



.. _converting-to-string-1:

22.8.1â€ƒConverting to string
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `Table 22.1 <#tbl:converting-to-string>`__ describes how various values are
   converted to strings.

   ============ ==========================================
   x            String(x)
   undefined    'undefined'
   null         'null'
   boolean      false â†’ 'false', true â†’ 'true'
   number       Example: 123 â†’ '123'
   bigint       Example: 123n â†’ '123'
   string       x (input, unchanged)
   symbol       Example: Symbol('abc') â†’ 'Symbol(abc)'
   object       Configurable via, e.g., toString()
   ============ ==========================================

   Table 22.1: Converting values to strings.

22.8.2â€ƒNumeric values of text atoms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  **Char code**: number representing a JavaScript character. JavaScriptâ€™s name
      for *Unicode code unit*.

      -  Size: 16 bits, unsigned
      -  Convert number to string: ``String.fromCharCode()`` :sup:`[ES1]`
      -  Convert string to number: string method ``.charCodeAt()`` :sup:`[ES1]`

   -  **Code point**: number representing an atomic part of Unicode text.

      -  Size: 21 bits, unsigned (17 planes, 16 bits each)
      -  Convert number to string: ``String.fromCodePoint()`` :sup:`[ES6]`
      -  Convert string to number: string method ``.codePointAt()`` :sup:`[ES6]`



.. _string-prototype-finding-and-matching:

22.8.3â€ƒ``String.prototype.*``: finding and matching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``String.prototype.startsWith(searchString, startPos=0)`` :sup:`[ES6]`

      Returns ``true`` if ``searchString`` occurs in the string at index
      ``startPos``. Returns ``false`` otherwise.

      .. code:: javascript
         :name: language-node-repl

         > '.gitignore'.startsWith('.')
         true
         > 'abcde'.startsWith('bc', 1)
         true

   -  ``String.prototype.endsWith(searchString, endPos=this.length)`` :sup:`[ES6]`

      Returns ``true`` if the string would end with ``searchString`` if its length
      were ``endPos``. Returns ``false`` otherwise.

      .. code:: javascript
         :name: language-node-repl

         > 'poem.txt'.endsWith('.txt')
         true
         > 'abcde'.endsWith('cd', 4)
         true

   -  ``String.prototype.includes(searchString, startPos=0)`` :sup:`[ES6]`

      Returns ``true`` if the string contains the ``searchString`` and ``false``
      otherwise. The search starts at ``startPos``.

      .. code:: javascript
         :name: language-node-repl

         > 'abc'.includes('b')
         true
         > 'abc'.includes('b', 2)
         false

   -  ``String.prototype.indexOf(searchString, minIndex=0)`` :sup:`[ES1]`

      Returns the lowest index at which ``searchString`` appears within the string
      or ``-1``, otherwise. Any returned index will be ``minIndex`` or higher.

      .. code:: javascript
         :name: language-node-repl

         > 'abab'.indexOf('a')
         0
         > 'abab'.indexOf('a', 1)
         2
         > 'abab'.indexOf('c')
         -1

   -  ``String.prototype.lastIndexOf(searchString, maxIndex=Infinity)``
      :sup:`[ES1]`

      Returns the highest index at which ``searchString`` appears within the string
      or ``-1``, otherwise. Any returned index will be ``maxIndex`` or lower.

      .. code:: javascript
         :name: language-node-repl

         > 'abab'.lastIndexOf('ab', 2)
         2
         > 'abab'.lastIndexOf('ab', 1)
         0
         > 'abab'.lastIndexOf('ab')
         2

   -  ``String.prototype.match(regExpOrString)`` :sup:`[ES3]`

      -  (1 of 2) ``regExpOrString`` is RegExp without ``/g`` or string.

         .. code:: javascript
            :name: language-ts

            match(
            regExpOrString: string | RegExp
            ): null | RegExpMatchArray

         If ``regExpOrString`` is a regular expression with flag ``/g`` not set,
         then ``.match()`` returns the first match for ``regExpOrString`` within
         the string. Or ``null`` if there is no match.

         If ``regExpOrString`` is a string, it is used to create a regular
         expression (think parameter of ``new RegExp()``) before performing the
         previously mentioned steps.

         The result has the following type:

         .. code:: javascript
            :name: language-ts

            interface RegExpMatchArray extends Array<string> {
            index: number;
            input: string;
            groups: undefined | {
               [key: string]: string
            };
            }

         Numbered capture groups become Array indices (which is why this type
         extends ``Array``). Named capture groups](#named-capture-groups) (ES2018)
         become properties of ``.groups``. In this mode, ``.match()`` works like
         [``RegExp.prototype.exec()``.

         Examples:

         .. code:: javascript
            :name: language-node-repl

            > 'ababb'.match(/a(b+)/)
            { 0: 'ab', 1: 'b', index: 0, input: 'ababb', groups: undefined }
            > 'ababb'.match(/a(?<foo>b+)/)
            { 0: 'ab', 1: 'b', index: 0, input: 'ababb', groups: { foo: 'b' } }
            > 'abab'.match(/x/)
            null

      -  (2 of 2) ``regExpOrString`` is RegExp with ``/g``.

         .. code:: javascript
            :name: language-ts

            match(
            regExpOrString: RegExp
            ): null | Array<string>

         If flag ``/g`` of ``regExpOrString`` is set, ``.match()`` returns either
         an Array with all matches or ``null`` if there was no match.

         .. code:: javascript
            :name: language-node-repl

            > 'ababb'.match(/a(b+)/g)
            [ 'ab', 'abb' ]
            > 'ababb'.match(/a(?<foo>b+)/g)
            [ 'ab', 'abb' ]
            > 'abab'.match(/x/g)
            null

   -  ``String.prototype.search(regExpOrString)`` :sup:`[ES3]`

      Returns the index at which ``regExpOrString`` occurs within the string. If
      ``regExpOrString`` is a string, it is used to create a regular expression
      (think parameter of ``new RegExp()``).

      .. code:: javascript
         :name: language-node-repl

         > 'a2b'.search(/[0-9]/)
         1
         > 'a2b'.search('[0-9]')
         1



.. _string-api-extracting:

22.8.4â€ƒ``String.prototype.*``: extracting
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``String.prototype.slice(start=0, end=this.length)`` :sup:`[ES3]`

      Returns the substring of the string that starts at (including) index
      ``start`` and ends at (excluding) index ``end``. If an index is negative, it
      is added to ``.length`` before it is used (``-1`` becomes ``this.length-1``,
      etc.).

      .. code:: javascript
         :name: language-node-repl

         > 'abc'.slice(1, 3)
         'bc'
         > 'abc'.slice(1)
         'bc'
         > 'abc'.slice(-2)
         'bc'

   -  ``String.prototype.at(index: number)`` :sup:`[ES2022]`

      -  Returns the JavaScript character at ``index`` as a string.
      -  If the index is out of bounds, it returns ``undefined``.
      -  If ``index`` is negative, it is added to ``.length`` before it is used
         (``-1`` becomes ``this.length-1``, etc.).

      .. code:: javascript
         :name: language-node-repl

         > 'abc'.at(0)
         'a'
         > 'abc'.at(-1)
         'c'

   -  ``String.prototype.split(separator, limit?)`` :sup:`[ES3]`

      Splits the string into an Array of substrings â€“ the strings that occur
      between the separators.

      The separator can be a string:

      .. code:: javascript
         :name: language-node-repl

         > 'a : b : c'.split(':')
         [ 'a ', ' b ', ' c' ]

      It can also be a regular expression:

      .. code:: javascript
         :name: language-node-repl

         > 'a : b : c'.split(/ *: */)
         [ 'a', 'b', 'c' ]
         > 'a : b : c'.split(/( *):( *)/)
         [ 'a', ' ', ' ', 'b', ' ', ' ', 'c' ]

      The last invocation demonstrates that captures made by groups in the regular
      expression become elements of the returned Array.

      If we want the separators to be part of the returned string fragments, we can
      use a regular expression with `a lookbehind
      assertion <#regexp-lookbehind-assertions>`__:

      .. code:: javascript
         :name: language-node-repl

         > 'a : b : c'.split(/(?<=:)/)
         [ 'a :', ' b :', ' c' ]

      Thanks to the lookbehind assertion, the regular expression used for splitting
      matches but doesnâ€™t capture any characters (which would be taken away from
      the output fragments).

      **Warning about ``.split('')``:** Using the method this way splits a string
      into JavaScript characters. That doesnâ€™t work well when dealing with astral
      code points (which are encoded as two JavaScript characters). For example,
      emojis are astral:

      .. code:: javascript
         :name: language-node-repl

         > 'ğŸ™‚XğŸ™‚'.split('')
         [ '\uD83D', '\uDE42', 'X', '\uD83D', '\uDE42' ]

      Instead, it is better to use ``Array.from()`` (or spreading):

      .. code:: javascript
         :name: language-node-repl

         > Array.from('ğŸ™‚XğŸ™‚')
         [ 'ğŸ™‚', 'X', 'ğŸ™‚' ]

   -  ``String.prototype.substring(start, end=this.length)`` :sup:`[ES1]`

      Use ``.slice()`` instead of this method. ``.substring()`` wasnâ€™t implemented
      consistently in older engines and doesnâ€™t support negative indices.



.. _string-prototype-combining:

22.8.5â€ƒ``String.prototype.*``: combining
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``String.prototype.concat(...strings)`` :sup:`[ES3]`

      Returns the concatenation of the string and ``strings``. ``'a'.concat('b')``
      is equivalent to ``'a'+'b'``. The latter is much more popular.

      .. code:: javascript
         :name: language-node-repl

         > 'ab'.concat('cd', 'ef', 'gh')
         'abcdefgh'

   -  ``String.prototype.padEnd(len, fillString=' ')`` :sup:`[ES2017]`

      Appends (fragments of) ``fillString`` to the string until it has the desired
      length ``len``. If it already has or exceeds ``len``, then it is returned
      without any changes.

      .. code:: javascript
         :name: language-node-repl

         > '#'.padEnd(2)
         '# '
         > 'abc'.padEnd(2)
         'abc'
         > '#'.padEnd(5, 'abc')
         '#abca'

   -  ``String.prototype.padStart(len, fillString=' ')`` :sup:`[ES2017]`

      Prepends (fragments of) ``fillString`` to the string until it has the desired
      length ``len``. If it already has or exceeds ``len``, then it is returned
      without any changes.

      .. code:: javascript
         :name: language-node-repl

         > '#'.padStart(2)
         ' #'
         > 'abc'.padStart(2)
         'abc'
         > '#'.padStart(5, 'abc')
         'abca#'

   -  ``String.prototype.repeat(count=0)`` :sup:`[ES6]`

      Returns the string, concatenated ``count`` times.

      .. code:: javascript
         :name: language-node-repl

         > '*'.repeat()
         ''
         > '*'.repeat(3)
         '***'



.. _string-prototype-transforming:

22.8.6â€ƒ``String.prototype.*``: transforming
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``String.prototype.replaceAll(searchValue, replaceValue)`` :sup:`[ES2021]`

      .. container:: boxout

         |Icon â€œtipâ€|â€‚**What to do if you canâ€™t use ``.replaceAll()``**

         .. container:: boxout-vspace

         If ``.replaceAll()`` isnâ€™t available on your targeted platform, you can
         use ``.replace()`` instead. How is explained in
         `â€œ\ ``str.replace(searchValue, replacementValue)`` [ES3]\ â€
         (Â§45.13.8.1) <#String.prototype.replace>`__.

      -  (1 of 2) ``replaceValue`` is string.

         .. code:: javascript
            :name: language-ts

            replaceAll(
            searchValue: string | RegExp,
            replaceValue: string
            ): string

         Replaces all matches of ``searchValue`` with ``replaceValue``. If
         ``searchValue`` is a regular expression without flag ``/g``, a
         ``TypeError`` is thrown.

         .. code:: javascript
            :name: language-node-repl

            > 'x.x.'.replaceAll('.', '#') // interpreted literally
            'x#x#'
            > 'x.x.'.replaceAll(/./g, '#')
            '####'
            > 'x.x.'.replaceAll(/./, '#')
            TypeError: String.prototype.replaceAll called with
            a non-global RegExp argument

         Special characters in ``replaceValue`` are:

         -  ``$$``: becomes ``$``
         -  ``$n``: becomes the capture of numbered group ``n`` (alas, ``$0``
            stands for the string ``'$0'``, it does not refer to the complete
            match)
         -  ``$&``: becomes the complete match
         -  :literal:`$\``: becomes everything before the match
         -  ``$'``: becomes everything after the match

         Examples:

         .. code:: javascript
            :name: language-node-repl

            > 'a 1995-12 b'.replaceAll(/([0-9]{4})-([0-9]{2})/g, '|$2|')
            'a |12| b'
            > 'a 1995-12 b'.replaceAll(/([0-9]{4})-([0-9]{2})/g, '|$&|')
            'a |1995-12| b'
            > 'a 1995-12 b'.replaceAll(/([0-9]{4})-([0-9]{2})/g, '|$`|')
            'a |a | b'

         `Named capture groups <#named-capture-groups>`__ (ES2018)
         are supported, too:

         -  ``$<name>`` becomes the capture of named group ``name``

         Example:

         .. code:: javascript

            assert.equal(
            'a 1995-12 b'.replaceAll(
               /(?<year>[0-9]{4})-(?<month>[0-9]{2})/g, '|$<month>|'),
            'a |12| b');

      -  (2 of 2) ``replaceValue`` is function.

         .. code:: javascript
            :name: language-ts

            replaceAll(
            searchValue: string | RegExp,
            replaceValue: (...args: Array<any>) => string
            ): string

         If the second parameter is a function, occurrences are replaced with the
         strings it returns. Its parameters ``args`` are:

         -  ``matched: string``. The complete match
         -  ``g1: string|undefined``. The capture of numbered group 1
         -  ``g2: string|undefined``. The capture of numbered group 2
         -  (Etc.)
         -  ``offset: number``. Where was the match found in the input string?
         -  ``input: string``. The whole input string

         .. code:: javascript

            const regexp = /([0-9]{4})-([0-9]{2})/g;
            const replacer = (all, year, month) => '|' + all + '|';
            assert.equal(
            'a 1995-12 b'.replaceAll(regexp, replacer),
            'a |1995-12| b');

         `Named capture groups <#named-capture-groups>`__ (ES2018)
         are supported, too. If there are any, an argument is added at the end with
         an object whose properties contain the captures:

         .. code:: javascript

            const regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})/g;
            const replacer = (...args) => {
            const groups=args.pop();
            return '|' + groups.month + '|';
            };
            assert.equal(
            'a 1995-12 b'.replaceAll(regexp, replacer),
            'a |12| b');

   -  ``String.prototype.replace(searchValue, replaceValue)`` :sup:`[ES3]`

      For more information on this method, see
      `â€œ\ ``str.replace(searchValue, replacementValue)`` [ES3]\ â€
      (Â§45.13.8.1) <#String.prototype.replace>`__.

      -  (1 of 2) ``replaceValue`` is string or RegExp without ``/g``.

         .. code:: javascript
            :name: language-ts

            replace(
            searchValue: string | RegExp,
            replaceValue: string
            ): string

         Works similarly to ``.replaceAll()``, but only replaces the first
         occurrence:

         .. code:: javascript
            :name: language-node-repl

            > 'x.x.'.replace('.', '#') // interpreted literally
            'x#x.'
            > 'x.x.'.replace(/./, '#')
            '#.x.'

      -  (1 of 2) ``replaceValue`` is RegExp with ``/g``.

         .. code:: javascript
            :name: language-ts

            replace(
            searchValue: string | RegExp,
            replaceValue: (...args: Array<any>) => string
            ): string

         Works exactly like ``.replaceAll()``.

   -  ``String.prototype.toUpperCase()`` :sup:`[ES1]`

      Returns a copy of the string in which all lowercase alphabetic characters are
      converted to uppercase. How well that works for various alphabets, depends on
      the JavaScript engine.

      .. code:: javascript
         :name: language-node-repl

         > '-a2b-'.toUpperCase()
         '-A2B-'
         > 'Î±Î²Î³'.toUpperCase()
         'Î‘Î’Î“'

   -  ``String.prototype.toLowerCase()`` :sup:`[ES1]`

      Returns a copy of the string in which all uppercase alphabetic characters are
      converted to lowercase. How well that works for various alphabets, depends on
      the JavaScript engine.

      .. code:: javascript
         :name: language-node-repl

         > '-A2B-'.toLowerCase()
         '-a2b-'
         > 'Î‘Î’Î“'.toLowerCase()
         'Î±Î²Î³'

   -  ``String.prototype.trim()`` :sup:`[ES5]`

      Returns a copy of the string in which all leading and trailing whitespace
      (spaces, tabs, line terminators, etc.) is gone.

      .. code:: javascript
         :name: language-node-repl

         > '\r\n#\t  '.trim()
         '#'
         > '  abc  '.trim()
         'abc'

   -  ``String.prototype.trimStart()`` :sup:`[ES2019]`

      Similar to ``.trim()`` but only the beginning of the string is trimmed:

      .. code:: javascript
         :name: language-node-repl

         > '  abc  '.trimStart()
         'abc  '

   -  ``String.prototype.trimEnd()`` :sup:`[ES2019]`

      Similar to ``.trim()`` but only the end of the string is trimmed:

      .. code:: javascript
         :name: language-node-repl

         > '  abc  '.trimEnd()
         '  abc'

   -  ``String.prototype.normalize(form = 'NFC')`` :sup:`[ES6]`

      -  Normalizes the string according to `the Unicode Normalization
         Forms <https://unicode.org/reports/tr15/>`__.
      -  Values of ``form``: ``'NFC', 'NFD', 'NFKC', 'NFKD'``

   -  ``String.prototype.isWellFormed()`` :sup:`[ES2024]`

      Returns ``true`` if a string is ill-formed and contains *lone surrogates*
      (see `.toWellFormed() <#qref-String.prototype.toWellFormed>`__ for more
      information). Otherwise, it returns ``false``.

      .. code:: javascript
         :name: language-node-repl

         > 'ğŸ™‚'.split('') // split into code units
         [ '\uD83D', '\uDE42' ]
         > '\uD83D\uDE42'.isWellFormed()
         true
         > '\uD83D\uDE42\uD83D'.isWellFormed() // lone surrogate 0xD83D
         false

   -  ``String.prototype.toWellFormed()`` :sup:`[ES2024]`

      Each JavaScript string character is a `UTF-16 code
      unit <#utf-16>`__. One code point is encoded as either one
      UTF-16 code unit or two UTF-16 code unit. In the latter case, the two code
      units are called *leading surrogate* and *trailing surrogate*. A surrogate
      without its partner is called a *lone surrogate*. A string with one or more
      lone surrogates is *ill-formed*.

      ``.toWellFormed()`` converts an ill-formed string to a well-formed one by
      replacing each lone surrogate with code point 0xFFFD (â€œreplacement
      characterâ€). That character is often displayed as a ï¿½ (a black rhombus with a
      white question mark). It is located in the *Specials* Unicode block of
      characters, at the very end of the *Basic Multilingual Plane*. `This is what
      Wikipedia says about the replacement character <https://en.wikipedia.org/wiki/Specials_%28Unicode_block%29#Replacement_character>`__:
      â€œIt is used to indicate problems when a system is unable to render a stream
      of data to correct symbols.â€

      .. code:: javascript

         assert.deepEqual(
         'ğŸ™‚'.split(''), // split into code units
         ['\uD83D', '\uDE42']
         );
         assert.deepEqual(
            // 0xD83D is a lone surrogate
         '\uD83D\uDE42\uD83D'.toWellFormed().split(''),
         ['\uD83D', '\uDE42', '\uFFFD']
         );

22.8.7â€ƒSources of this quick reference
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `ECMAScript language specification <https://tc39.es/ecma262/>`__
   -  `TypeScriptâ€™s built-in typings <https://github.com/microsoft/TypeScript/tree/main/src/lib/>`__
   -  `MDN web docs for JavaScript <https://developer.mozilla.org/en-US/docs/Web/JavaScript>`__

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Using string methods**

      .. container:: boxout-vspace

      ``exercises/strings/remove_extension_test.mjs``

   `Comments <https://github.com/rauschma/exploring-js/issues/13>`__



.. _ch_template-literals:

23â€ƒUsing template literals and tagged templates [ES6]
======================================================

   #. `23.1â€ƒDisambiguation: â€œtemplateâ€ <#disambiguation-template>`__
   #. `23.2â€ƒTemplate literals <#template-literals>`__
   #. `23.3â€ƒTagged templates <#tagged-templates>`__

      #. `23.3.1â€ƒCooked vs. raw template strings (advanced) <#template-strings-cooked-vs-raw>`__

   #. `23.4â€ƒExamples of tagged templates (as provided via libraries) <#examples-of-tagged-templates-as-provided-via-libraries>`__

      #. `23.4.1â€ƒTag function library: lit-html <#tag-function-library-lit-html>`__
      #. `23.4.2â€ƒTag function library: regex <#regex-library>`__
      #. `23.4.3â€ƒTag function library: graphql-tag <#tag-function-library-graphql-tag>`__

   #. `23.5â€ƒRaw string literals <#raw-string-literals>`__
   #. `23.6â€ƒ(Advanced) <#advanced-3>`__
   #. `23.7â€ƒMultiline template literals and indentation <#multiline-template-literals-and-indentation>`__

      #. `23.7.1â€ƒFix: template tag for dedenting <#fix-template-tag-for-dedenting>`__
      #. `23.7.2â€ƒFix: .trim() <#fix-trim>`__

   #. `23.8â€ƒSimple templating via template literals <#simple-templating-via-template-literals>`__

      #. `23.8.1â€ƒA more complex example <#a-more-complex-example>`__
      #. `23.8.2â€ƒSimple HTML-escaping <#simple-html-escaping>`__

   Before we dig into the two features *template literal* and *tagged template*,
   letâ€™s first examine the multiple meanings of the term *template*.

23.1â€ƒDisambiguation: â€œtemplateâ€
--------------------------------

   The following three things are significantly different despite all having
   *template* in their names and despite all of them looking similar:

   -  A *text template* is a function from data to text. It is frequently used in
      web development and often defined via text files. For example, the following
      text defines a template for the library `Handlebars <https://handlebarsjs.com>`__:

      .. code:: language-html

         <div class="entry">
         <h1>{{title}}</h1>
         <div class="body">
            {{body}}
         </div>
         </div>

      This template has two blanks to be filled in: ``title`` and ``body``. It is
      used like this:

      .. code:: javascript

         // First step: retrieve the template text, e.g. from a text file.
         const tmplFunc = Handlebars.compile(TMPL_TEXT); // compile string
         const data = {title: 'My page', body: 'Welcome to my page!'};
         const html = tmplFunc(data);

   -  A *template literal* is similar to a string literal, but has additional
      features â€“ for example, interpolation. It is delimited by backticks:

      .. code:: javascript

         const num = 5;
         assert.equal(`Count: ${num}!`, 'Count: 5!');

   -  Syntactically, a *tagged template* is a template literal that follows a
      function (or rather, an expression that evaluates to a function). That leads
      to the function being called. Its arguments are derived from the contents of
      the template literal.

      .. code:: javascript

         const getArgs = (...args) => args;
         assert.deepEqual(
         getArgs`Count: ${5}!`,
         [['Count: ', '!'], 5] );

      Note that ``getArgs()`` receives both the text of the literal and the data
      interpolated via ``${}``.

23.2â€ƒTemplate literals
-----------------------

   A template literal has two new features compared to a normal string literal.

   First, it supports *string interpolation*: if we put a dynamically computed
   value inside a ``${}``, it is converted to a string and inserted into the string
   returned by the literal.

   .. code:: javascript

      const MAX = 100;
      function doSomeWork(x) {
      if (x > MAX) {
         throw new Error(`At most ${MAX} allowed: ${x}!`);
      }
      // Â·Â·Â·
      }
      assert.throws(
      () => doSomeWork(101),
      {message: 'At most 100 allowed: 101!'});

   Second, template literals can span multiple lines:

   .. code:: javascript

      const str = `this is
      a text with
      multiple lines`;

   Template literals always produce strings.

23.3â€ƒTagged templates
----------------------

   The expression in line A is a *tagged template*. It is equivalent to invoking
   ``tagFunc()`` with the arguments listed in the Array in line B.

   .. code:: javascript

      function tagFunc(...args) {
      return args;
      }

      const setting = 'dark mode';
      const value = true;

      assert.deepEqual(
      tagFunc`Setting ${setting} is ${value}!`, // (A)
      [['Setting ', ' is ', '!'], 'dark mode', true] // (B)
      );

   The function ``tagFunc`` before the first backtick is called a *tag function*.
   Its arguments are:

   -  *Template strings* (first argument): an Array with the text fragments
      surrounding the interpolations ``${}``.

      -  In the example: ``['Setting ', ' is ', '!']``

   -  *Substitutions* (remaining arguments): the interpolated values.

      -  In the example: ``'dark mode'`` and ``true``

   The static (fixed) parts of the literal (the template strings) are kept separate
   from the dynamic parts (the substitutions).

   A tag function can return arbitrary values.



.. _template-strings-cooked-vs-raw:

23.3.1â€ƒCooked vs. raw template strings (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   So far, we have only seen the *cooked interpretation* of template strings. But
   tag functions actually get two interpretations:

   -  A *cooked interpretation* where backslashes have special meaning. For
      example, ``\t`` produces a tab character. This interpretation of the template
      strings is stored as an Array in the first argument.

   -  A *raw interpretation* where backslashes do not have special meaning. For
      example, ``\t`` produces two characters â€“ a backslash and a ``t``. This
      interpretation of the template strings is stored in property ``.raw`` of the
      first argument (an Array).

   The raw interpretation enables raw string literals via ``String.raw``
   `(described later) <#raw-string-literals>`__ and similar applications.

   The following tag function ``cookedRaw`` uses both interpretations:

   .. code:: javascript

      function cookedRaw(templateStrings, ...substitutions) {
      return {
         cooked: Array.from(templateStrings), // copy only Array elements
         raw: templateStrings.raw,
         substitutions,
      };
      }
      assert.deepEqual(
      cookedRaw`\tab${'subst'}\newline\\`,
      {
         cooked: ['\tab', '\newline\\'],
         raw:    ['\\tab', '\\newline\\\\'],
         substitutions: ['subst'],
      });

   We can also use Unicode code point escapes (``\u{1F642}``), Unicode code unit
   escapes (``\u03A9``), and ASCII escapes (``\x52``) in tagged templates:

   .. code:: javascript

      assert.deepEqual(
      cookedRaw`\u{54}\u0065\x78t`,
      {
         cooked: ['Text'],
         raw:    ['\\u{54}\\u0065\\x78t'],
         substitutions: [],
      });

   If the syntax of one of these escapes isnâ€™t correct, the corresponding cooked
   template string is ``undefined``, while the raw version is still verbatim:

   .. code:: javascript

      assert.deepEqual(
      cookedRaw`\uu\xx ${1} after`,
      {
         cooked: [undefined, ' after'],
         raw:    ['\\uu\\xx ', ' after'],
         substitutions: [1],
      });

   Incorrect escapes produce syntax errors in template literals and string
   literals. Before ES2018, they even produced errors in tagged templates. Why was
   that changed? We can now use tagged templates for text that was previously
   illegal â€“ for example:

   .. code:: language-txt

      windowsPath`C:\uuu\xxx\111`
      latex`\unicode`

23.4â€ƒExamples of tagged templates (as provided via libraries)
--------------------------------------------------------------

   Tagged templates are great for supporting small embedded languages (so-called
   *domain-specific languages*). Weâ€™ll continue with a few examples.

23.4.1â€ƒTag function library: lit-html
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `Lit <https://lit.dev>`__ is a library for building web components that uses
   tagged templates for HTML templating:

   .. code:: javascript

      @customElement('my-element')
      class MyElement extends LitElement {

      // Â·Â·Â·

      render() {
         return html`
            <ul>
            ${repeat(
               this.items,
               (item) => item.id,
               (item, index) => html`<li>${index}: ${item.name}</li>`
            )}
            </ul>
         `;
      }
      }

   ``repeat()`` is a custom function for looping. Its second parameter produces
   unique keys for the values returned by the third parameter. Note the nested
   tagged template used by that parameter.



.. _regex-library:

23.4.2â€ƒTag function library: regex
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `The library â€œregexâ€ <https://github.com/slevithan/regex>`__ by Steven Levithan
   provides template tags that help with creating regular expressions and enable
   advanced features. The following example demonstrates how it works:

   .. code:: javascript

      import {regex, partial} from 'regex';

      const RE_YEAR = partial`(?<year>[0-9]{4})`;
      const RE_MONTH = partial`(?<month>[0-9]{2})`;
      const RE_DAY = partial`(?<day>[0-9]{2})`;
      const RE_DATE = regex('g')`
      ${RE_YEAR} # 4 digits
      -
      ${RE_MONTH} # 2 digits
      -
      ${RE_DAY} # 2 digits
      `;

      const match = RE_DATE.exec('2017-01-27');
      assert.equal(match.groups.year, '2017');

   The following flags are switched on by default:

   -  Flag ``/v``
   -  Flag ``/x`` (emulated) enables insignificant whitespace and line comments via
      ``#``.
   -  Flag ``/n`` (emulated) enables *named capture only mode*, which prevents the
      grouping metacharacters ``(Â·Â·Â·)`` from capturing.

23.4.3â€ƒTag function library: graphql-tag
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `The library graphql-tag <https://github.com/apollographql/graphql-tag>`__ lets
   us create GraphQL queries via tagged templates:

   .. code:: javascript

      import gql from 'graphql-tag';

      const query = gql`
      {
         user(id: 5) {
            firstName
            lastName
         }
      }
      `;

   Additionally, there are plugins for pre-compiling such queries in Babel,
   TypeScript, etc.

23.5â€ƒRaw string literals
-------------------------

   Raw string literals are implemented via the tag function ``String.raw``. They
   are string literals where backslashes donâ€™t do anything special (such as
   escaping characters, etc.):

   .. code:: javascript

      assert.equal(String.raw`\back`, '\\back');

   This helps whenever data contains backslashes â€“ for example, strings with
   regular expressions:

   .. code:: javascript

      const regex1 = /^\./;
      const regex2 = new RegExp('^\\.');
      const regex3 = new RegExp(String.raw`^\.`);

   All three regular expressions are equivalent. With a normal string literal, we
   have to write the backslash twice, to escape it for that literal. With a raw
   string literal, we donâ€™t have to do that.

   Raw string literals are also useful for specifying Windows filename paths:

   .. code:: javascript

      const WIN_PATH = String.raw`C:\foo\bar`;
      assert.equal(WIN_PATH, 'C:\\foo\\bar');



.. _advanced-3:

23.6â€ƒ(Advanced)
----------------

   All remaining sections are advanced

23.7â€ƒMultiline template literals and indentation
-------------------------------------------------

   If we put multiline text in template literals, two goals are in conflict: On one
   hand, the template literal should be indented to fit inside the source code. On
   the other hand, the lines of its content should start in the leftmost column.

   For example:

   .. code:: javascript

      function div(text) {
      return `
         <div>
            ${text}
         </div>
      `;
      }
      console.log('Output:');
      console.log(
      div('Hello!')
      // Replace spaces with mid-dots:
      .replace(/ /g, 'Â·')
      // Replace \n with #\n:
      .replace(/\n/g, '#\n')
      );

   Due to the indentation, the template literal fits well into the source code.
   Alas, the output is also indented. And we donâ€™t want the return at the beginning
   and the return plus two spaces at the end.

   .. code:: language-html

      Output:
      #
      Â·Â·Â·Â·<div>#
      Â·Â·Â·Â·Â·Â·Hello!#
      Â·Â·Â·Â·</div>#
      Â·Â·

   There are two ways to fix this: via a tagged template or by trimming the result
   of the template literal.

23.7.1â€ƒFix: template tag for dedenting
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The first fix is to use a custom template tag that removes the unwanted
   whitespace. It uses the first line after the initial line break to determine in
   which column the text starts and shortens the indentation everywhere. It also
   removes the line break at the very beginning and the indentation at the very
   end. One such template tag is `dedent`` by Desmond
   Brand <https://github.com/dmnd/dedent>`__:

   .. code:: javascript

      import dedent from 'dedent';
      function divDedented(text) {
      return dedent`
         <div>
            ${text}
         </div>
      `.replace(/\n/g, '#\n');
      }
      console.log('Output:');
      console.log(divDedented('Hello!'));

   This time, the output is not indented:

   .. code:: language-html

      Output:
      <div>#
      Hello!#
      </div>



.. _fix-trim:

23.7.2â€ƒFix: ``.trim()``
~~~~~~~~~~~~~~~~~~~~~~~~

   The second fix is quicker, but also dirtier:

   .. code:: javascript

      function divDedented(text) {
      return `
      <div>
      ${text}
      </div>
      `.trim().replace(/\n/g, '#\n');
      }
      console.log('Output:');
      console.log(divDedented('Hello!'));

   The string method ``.trim()`` removes the superfluous whitespace at the
   beginning and at the end, but the content itself must start in the leftmost
   column. The advantage of this solution is that we donâ€™t need a custom tag
   function. The downside is that it looks ugly.

   The output is the same as with ``dedent``:

   .. code:: language-html

      Output:
      <div>#
      Hello!#
      </div>

23.8â€ƒSimple templating via template literals
---------------------------------------------

   While template literals look like text templates, it is not immediately obvious
   how to use them for (text) templating: A text template gets its data from an
   object, while a template literal gets its data from variables. The solution is
   to use a template literal in the body of a function whose parameter receives the
   templating data â€“ for example:

   .. code:: javascript

      const tmpl = (data) => `Hello ${data.name}!`;
      assert.equal(tmpl({name: 'Jane'}), 'Hello Jane!');

23.8.1â€ƒA more complex example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   As a more complex example, weâ€™d like to take an Array of addresses and produce
   an HTML table. This is the Array:

   .. code:: javascript

      const addresses = [
      { first: '<Jane>', last: 'Bond' },
      { first: 'Lars', last: '<Croft>' },
      ];

   The function ``tmpl()`` that produces the HTML table looks as follows:

   .. code:: javascript
      :number-lines:

      const tmpl = (addrs) => `
      <table>
      ${addrs.map(
         (addr) => `
            <tr>
            <td>${escapeHtml(addr.first)}</td>
            <td>${escapeHtml(addr.last)}</td>
            </tr>
            `.trim()
      ).join('')}
      </table>
      `.trim();

   This code contains two templating functions:

   -  The first one (line 1) takes ``addrs``, an Array with addresses, and returns
      a string with a table.
   -  The second one (line 4) takes ``addr``, an object containing an address, and
      returns a string with a table row. Note the ``.trim()`` at the end, which
      removes unnecessary whitespace.

   The first templating function produces its result by wrapping a table element
   around an Array that it joins into a string (line 10). That Array is produced by
   mapping the second templating function to each element of ``addrs`` (line 3). It
   therefore contains strings with table rows.

   The helper function ``escapeHtml()`` is used to escape special HTML characters
   (line 6 and line 7). Its implementation is shown in the next subsection.

   Let us call ``tmpl()`` with the addresses and log the result:

   .. code:: javascript

      console.log(tmpl(addresses));

   The output is:

   .. code:: language-html

      <table>
      <tr>
            <td>&lt;Jane&gt;</td>
            <td>Bond</td>
            </tr><tr>
            <td>Lars</td>
            <td>&lt;Croft&gt;</td>
            </tr>
      </table>

23.8.2â€ƒSimple HTML-escaping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following function escapes plain text so that it is displayed verbatim in
   HTML:

   .. code:: javascript

      function escapeHtml(str) {
      return str
         .replace(/&/g, '&amp;') // first!
         .replace(/>/g, '&gt;')
         .replace(/</g, '&lt;')
         .replace(/"/g, '&quot;')
         .replace(/'/g, '&#39;')
         .replace(/`/g, '&#96;')
         ;
      }
      assert.equal(
      escapeHtml('Rock & Roll'), 'Rock &amp; Roll');
      assert.equal(
      escapeHtml('<blank>'), '&lt;blank&gt;');

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: HTML templating**

      .. container:: boxout-vspace

      Exercise with bonus challenge:
      ``exercises/template-literals/templating_test.mjs``

   `Comments <https://github.com/rauschma/exploring-js/issues/14>`__



.. _ch_symbols:

24â€ƒSymbols [ES6]
=================

   #. `24.1â€ƒSymbols are primitives that are also like objects <#symbols-are-primitives-that-are-also-like-objects>`__

      #. `24.1.1â€ƒSymbols are primitive values <#symbols-are-primitive-values>`__
      #. `24.1.2â€ƒSymbols are also like objects <#symbols-are-also-like-objects>`__

   #. `24.2â€ƒThe descriptions of symbols <#symbol-descriptions>`__
   #. `24.3â€ƒUse cases for symbols <#use-cases-for-symbols>`__

      #. `24.3.1â€ƒSymbols as values for constants <#symbols-as-values-for-constants>`__
      #. `24.3.2â€ƒSymbols as unique property keys <#symbols-as-unique-property-keys>`__

   #. `24.4â€ƒPublicly known symbols <#publicly-known-symbols>`__
   #. `24.5â€ƒConverting symbols <#converting-symbols>`__

24.1â€ƒSymbols are primitives that are also like objects
-------------------------------------------------------

   Symbols are primitive values that are created via the factory function
   ``Symbol()``:

   .. code:: javascript

      const mySymbol = Symbol('mySymbol');

   The parameter is optional and provides a description, which is mainly useful for
   debugging.

24.1.1â€ƒSymbols are primitive values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Symbols are primitive values:

   -  They have to be categorized via ``typeof``:

      .. code:: javascript

         const sym = Symbol();
         assert.equal(typeof sym, 'symbol');

   -  They can be property keys in objects:

      .. code:: javascript

         const obj = {
         [sym]: 123,
         };

24.1.2â€ƒSymbols are also like objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Even though symbols are primitives, they are also like objects in that each
   value created by ``Symbol()`` is unique and not compared by value:

   .. code:: javascript
      :name: language-node-repl

      > Symbol() === Symbol()
      false

   Prior to symbols, objects were the best choice if we needed values that were
   unique (only equal to themselves):

   .. code:: javascript

      const string1 = 'abc';
      const string2 = 'abc';
      assert.equal(
      string1 === string2, true); // not unique

      const object1 = {};
      const object2 = {};
      assert.equal(
      object1 === object2, false); // unique

      const symbol1 = Symbol();
      const symbol2 = Symbol();
      assert.equal(
      symbol1 === symbol2, false); // unique



.. _symbol-descriptions:

24.2â€ƒThe descriptions of symbols
---------------------------------

   The parameter we pass to the symbol factory function provides a description for
   the created symbol:

   .. code:: javascript

      const mySymbol = Symbol('mySymbol');

   The description can be accessed in two ways.

   First, it is part of the string returned by ``.toString()``:

   .. code:: javascript

      assert.equal(mySymbol.toString(), 'Symbol(mySymbol)');

   Second, since ES2019, we can retrieve the description via the property
   ``.description``:

   .. code:: javascript

      assert.equal(mySymbol.description, 'mySymbol');

24.3â€ƒUse cases for symbols
---------------------------

   The main use cases for symbols, are:

   -  Values for constants
   -  Unique property keys

24.3.1â€ƒSymbols as values for constants
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Letâ€™s assume you want to create constants representing the colors red, orange,
   yellow, green, blue, and violet. One simple way of doing so would be to use
   strings:

   .. code:: javascript

      const COLOR_BLUE = 'Blue';

   On the plus side, logging that constant produces helpful output. On the minus
   side, there is a risk of mistaking an unrelated value for a color because two
   strings with the same content are considered equal:

   .. code:: javascript

      const MOOD_BLUE = 'Blue';
      assert.equal(COLOR_BLUE, MOOD_BLUE);

   We can fix that problem via symbols:

   .. code:: javascript

      const COLOR_BLUE = Symbol('Blue');
      const MOOD_BLUE = Symbol('Blue');

      assert.notEqual(COLOR_BLUE, MOOD_BLUE);

   Letâ€™s use symbol-valued constants to implement a function:

   .. code:: javascript

      const COLOR_RED    = Symbol('Red');
      const COLOR_ORANGE = Symbol('Orange');
      const COLOR_YELLOW = Symbol('Yellow');
      const COLOR_GREEN  = Symbol('Green');
      const COLOR_BLUE   = Symbol('Blue');
      const COLOR_VIOLET = Symbol('Violet');

      function getComplement(color) {
      switch (color) {
         case COLOR_RED:
            return COLOR_GREEN;
         case COLOR_ORANGE:
            return COLOR_BLUE;
         case COLOR_YELLOW:
            return COLOR_VIOLET;
         case COLOR_GREEN:
            return COLOR_RED;
         case COLOR_BLUE:
            return COLOR_ORANGE;
         case COLOR_VIOLET:
            return COLOR_YELLOW;
         default:
            throw new Exception('Unknown color: '+color);
      }
      }
      assert.equal(getComplement(COLOR_YELLOW), COLOR_VIOLET);

24.3.2â€ƒSymbols as unique property keys
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The keys of properties (fields) in objects are used at two levels:

   -  The program operates at a *base level*. The keys at that level reflect the
      *problem domain* â€“ the area in which a program solves a problem â€“ for
      example:

      -  If a program manages employees, the property keys may be about job titles,
         salary categories, department IDs, etc.
      -  If the program is a chess app, the property keys may be about chess
         pieces, chess boards, player colors, etc.

   -  ECMAScript and many libraries operate at a *meta-level*. They manage data and
      provide services that are not part of the problem domain â€“ for example:

      -  The standard method ``.toString()`` is used by ECMAScript when creating a
         string representation of an object (line A):

         .. code:: javascript

            const point = {
            x: 7,
            y: 4,
            toString() {
               return `(${this.x}, ${this.y})`;
            },
            };
            assert.equal(
            String(point), '(7, 4)'); // (A)

         ``.x`` and ``.y`` are base-level properties â€“ they are used to solve the
         problem of computing with points. ``.toString()`` is a meta-level property
         â€“ it doesnâ€™t have anything to do with the problem domain.

      -  The standard ECMAScript method ``.toJSON()``

         .. code:: javascript

            const point = {
            x: 7,
            y: 4,
            toJSON() {
               return [this.x, this.y];
            },
            };
            assert.equal(
            JSON.stringify(point), '[7,4]');

         ``.x`` and ``.y`` are base-level properties, ``.toJSON()`` is a meta-level
         property.

   The base level and the meta-level of a program must be independent: Base-level
   property keys should not be in conflict with meta-level property keys.

   If we use names (strings) as property keys, we are facing two challenges:

   -  When a language is first created, it can use any meta-level names it wants.
      Base-level code is forced to avoid those names. Later, however, when much
      base-level code already exists, meta-level names canâ€™t be chosen freely,
      anymore.

   -  We could introduce naming rules to separate base level and meta-level. For
      example, Python brackets meta-level names with two underscores: ``__init__``,
      ``__iter__``, ``__hash__``, etc. However, the meta-level names of the
      language and the meta-level names of libraries would still exist in the same
      namespace and can clash.

   These are two examples of where the latter was an issue for JavaScript:

   -  In May 2018, the Array method ``.flatten()`` had to be renamed to ``.flat()``
      because the former name was already used by libraries
      (`source <https://github.com/tc39/proposal-flatMap/commit/093eacc7fe0906e70f7626bf6c7d6e9dfc53cce9>`__).

   -  In November 2020, the Array method ``.item()`` had to be renamed to ``.at()``
      because the former name was already used by library
      (`source <https://github.com/tc39/proposal-relative-indexing-method#web-incompatibility-history>`__).

   Symbols, used as property keys, help us here: Each symbol is unique and a symbol
   key never clashes with any other string or symbol key.

24.3.2.1â€ƒExample: a library with a meta-level method
'''''''''''''''''''''''''''''''''''''''''''''''''''''

   As an example, letâ€™s assume we are writing a library that treats objects
   differently if they implement a special method. This is what defining a property
   key for such a method and implementing it for an object would look like:

   .. code:: javascript

      const specialMethod = Symbol('specialMethod');
      const obj = {
      _id: 'kf12oi',
      [specialMethod]() { // (A)
         return this._id;
      }
      };
      assert.equal(obj[specialMethod](), 'kf12oi');

   The square brackets in line A enable us to specify that the method must have the
   key ``specialMethod``. More details are explained in `â€œComputed keys in object
   literalsâ€ (Â§30.7.2) <#object-literals-computed-keys>`__.

24.4â€ƒPublicly known symbols
----------------------------

   Symbols that play special roles within ECMAScript are called *publicly known
   symbols*. Examples include:

   -  ``Symbol.iterator``: makes an object *iterable*. Itâ€™s the key of a method
      that returns an iterator. For more information on this topic, see
      `â€œSynchronous iterationâ€ (Â§32) <#ch_sync-iteration>`__.

   -  ``Symbol.hasInstance``: customizes how ``instanceof`` works. If an object
      implements a method with that key, it can be used at the right-hand side of
      that operator. For example:

      .. code:: javascript

         const PrimitiveNull = {
         [Symbol.hasInstance](x) {
            return x === null;
         }
         };
         assert.equal(null instanceof PrimitiveNull, true);

   -  ``Symbol.toStringTag``: influences the default ``.toString()`` method.

      .. code:: javascript
         :name: language-node-repl

         > String({})
         '[object Object]'
         > String({ [Symbol.toStringTag]: 'is no money' })
         '[object is no money]'

      Note: Itâ€™s usually better to override ``.toString()``.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercises: Publicly known symbols**

      .. container:: boxout-vspace

      -  ``Symbol.toStringTag``: ``exercises/symbols/to_string_tag_test.mjs``
      -  ``Symbol.hasInstance``: ``exercises/symbols/has_instance_test.mjs``

24.5â€ƒConverting symbols
------------------------

   What happens if we convert a symbol ``sym`` to another primitive type? 
   `Table 24.1 <#tbl:converting-to-symbol>`__ has the answers.

   ============ =========================== ===========================
   Convert to   Explicit conversion         Coercion (implicit conv.)
   boolean      Boolean(sym) â†’ OK           !sym â†’ OK
   number       Number(sym) â†’ TypeError     sym*2 â†’ TypeError
   string       String(sym) â†’ OK            ''+sym â†’ TypeError
   \            sym.toString() â†’ OK         `${sym}` â†’ TypeError
   ============ =========================== ===========================

   Table 24.1: The results of converting symbols to other primitive types.

   One key pitfall with symbols is how often exceptions are thrown when converting
   them to something else. What is the thinking behind that? First, conversion to
   number never makes sense and should be warned about. Second, converting a symbol
   to a string is indeed useful for diagnostic output. But it also makes sense to
   warn about accidentally turning a symbol into a string (which is a different
   kind of property key):

   .. code:: javascript

      const obj = {};
      const sym = Symbol();
      assert.throws(
      () => { obj['__'+sym+'__'] = true },
      { message: 'Cannot convert a Symbol value to a string' });

   The downside is that the exceptions make working with symbols more complicated.
   You have to explicitly convert symbols when assembling strings via the plus
   operator:

   .. code:: javascript
      :name: language-node-repl

      > const mySymbol = Symbol('mySymbol');
      > 'Symbol I used: ' + mySymbol
      TypeError: Cannot convert a Symbol value to a string
      > 'Symbol I used: ' + String(mySymbol)
      'Symbol I used: Symbol(mySymbol)'

   `Comments <https://github.com/rauschma/exploring-js/issues/15>`__




.. _ch_control-flow:

25â€ƒControl flow statements
===========================

   #. `25.1â€ƒControlling loops: break and continue <#controlling-loops-break-and-continue>`__

      #. `25.1.1â€ƒbreak <#break>`__
      #. `25.1.2â€ƒbreak plus label: leaving any labeled statement <#labels>`__
      #. `25.1.3â€ƒcontinue <#continue>`__

   #. `25.2â€ƒConditions of control flow statements <#conditions-of-control-flow-statements>`__
   #. `25.3â€ƒif statements [ES1] <#if>`__

      #. `25.3.1â€ƒThe syntax of if statements <#the-syntax-of-if-statements>`__

   #. `25.4â€ƒswitch statements [ES3] <#switch>`__

      #. `25.4.1â€ƒA first example of a switch statement <#a-first-example-of-a-switch-statement>`__
      #. `25.4.2â€ƒDonâ€™t forget to return or break! <#don-t-forget-to-return-or-break>`__
      #. `25.4.3â€ƒEmpty case clauses <#empty-case-clauses>`__
      #. `25.4.4â€ƒChecking for illegal values via a default clause <#checking-for-illegal-values-via-a-default-clause>`__

   #. `25.5â€ƒwhile loops [ES1] <#while>`__

      #. `25.5.1â€ƒExamples of while loops <#examples-of-while-loops>`__

   #. `25.6â€ƒdo-while loops [ES3] <#do-while>`__
   #. `25.7â€ƒfor loops [ES1] <#for>`__

      #. `25.7.1â€ƒExamples of for loops <#examples-of-for-loops>`__

   #. `25.8â€ƒfor-of loops [ES6] <#for-of>`__

      #. `25.8.1â€ƒconst: for-of vs. for <#const-for-of-vs-for>`__
      #. `25.8.2â€ƒIterating over iterables <#iterating-over-iterables>`__
      #. `25.8.3â€ƒIterating over [index, element] pairs of Arrays <#for-of-iterating-index-element>`__

   #. `25.9â€ƒfor-await-of loops [ES2018] <#for-await-of-loops>`__
   #. `25.10â€ƒfor-in loops (avoid) [ES1] <#for-in>`__
   #. `25.11â€ƒRecomendations for looping <#recomendations-for-looping>`__

   This chapter covers the following control flow statements:

   -  ``if`` statement :sup:`[ES1]`
   -  ``switch`` statement :sup:`[ES3]`
   -  ``while`` loop :sup:`[ES1]`
   -  ``do-while`` loop :sup:`[ES3]`
   -  ``for`` loop :sup:`[ES1]`
   -  ``for-of`` loop :sup:`[ES6]`
   -  ``for-await-of`` loop :sup:`[ES2018]`
   -  ``for-in`` loop :sup:`[ES1]`

25.1â€ƒControlling loops: ``break`` and ``continue``
---------------------------------------------------

   The two operators ``break`` and ``continue`` can be used to control loops and
   other statements while we are inside them.

25.1.1â€ƒ``break``
~~~~~~~~~~~~~~~~~

   There are two versions of ``break``: one with an operand and one without an
   operand. The latter version works inside the following statements: ``while``,
   ``do-while``, ``for``, ``for-of``, ``for-await-of``, ``for-in`` and ``switch``.
   It immediately leaves the current statement:

   .. code:: javascript

      for (const x of ['a', 'b', 'c']) {
      console.log(x);
      if (x === 'b') break;
      console.log('---')
      }

   Output:

   ::

      a
      ---
      b



.. _labels:

25.1.2â€ƒ``break`` plus label: leaving any labeled statement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``break`` with an operand works everywhere. Its operand is a *label*. Labels can
   be put in front of any statement, including blocks. ``break my_label`` leaves
   the statement whose label is ``my_label``:

   .. code:: javascript

      my_label: { // label
      if (condition) break my_label; // labeled break
      // Â·Â·Â·
      }

   In the following example, the search can either:

   -  Fail: The loop finishes without finding a ``result``. That is handled
      directly after the loop (line B).
   -  Succeed: While looping, we find a ``result``. Then we use ``break`` plus
      label (line A) to skip the code that handles failure.

   .. code:: javascript

      function findSuffix(stringArray, suffix) {
      let result;
      search_block: {
         for (const str of stringArray) {
            if (str.endsWith(suffix)) {
            // Success:
            result = str;
            break search_block; // (A)
            }
         } // for
         // Failure:
         result = '(Untitled)'; // (B)
      } // search_block

      return { suffix, result };
         // Same as: {suffix: suffix, result: result}
      }
      assert.deepEqual(
      findSuffix(['notes.txt', 'index.html'], '.html'),
      { suffix: '.html', result: 'index.html' }
      );
      assert.deepEqual(
      findSuffix(['notes.txt', 'index.html'], '.mjs'),
      { suffix: '.mjs', result: '(Untitled)' }
      );

25.1.3â€ƒ``continue``
~~~~~~~~~~~~~~~~~~~~

   ``continue`` only works inside ``while``, ``do-while``, ``for``, ``for-of``,
   ``for-await-of``, and ``for-in``. It immediately leaves the current loop
   iteration and continues with the next one â€“ for example:

   .. code:: javascript

      const lines = [
      'Normal line',
      '# Comment',
      'Another normal line',
      ];
      for (const line of lines) {
      if (line.startsWith('#')) continue;
      console.log(line);
      }

   Output:

   ::

      Normal line
      Another normal line

25.2â€ƒConditions of control flow statements
-------------------------------------------

   ``if``, ``while``, and ``do-while`` have conditions that are, in principle,
   boolean. However, a condition only has to be *truthy* (``true`` if coerced to
   boolean) in order to be accepted. In other words, the following two control flow
   statements are equivalent:

   .. code:: javascript

      if (value) {}
      if (Boolean(value) === true) {}

   This is a list of all *falsy* values:

   -  ``undefined``, ``null``
   -  ``false``
   -  ``0``, ``NaN``
   -  ``0n``
   -  ``''``

   All other values are truthy. For more information, see `â€œFalsy and truthy
   valuesâ€ (Â§17.2) <#falsiness-truthiness>`__.



.. _if:

25.3â€ƒ``if`` statements [ES1]
-----------------------------

   These are two simple ``if`` statements: one with just a â€œthenâ€ branch and one
   with both a â€œthenâ€ branch and an â€œelseâ€ branch:

   .. code:: javascript

      if (cond) {
      // then branch
      }

      if (cond) {
      // then branch
      } else {
      // else branch
      }

   Instead of the block, ``else`` can also be followed by another ``if`` statement:

   .. code:: javascript

      if (cond1) {
      // Â·Â·Â·
      } else if (cond2) {
      // Â·Â·Â·
      }

      if (cond1) {
      // Â·Â·Â·
      } else if (cond2) {
      // Â·Â·Â·
      } else {
      // Â·Â·Â·
      }

   You can continue this chain with more ``else if``\ s.

25.3.1â€ƒThe syntax of ``if`` statements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The general syntax of ``if`` statements is:

   .. code:: javascript

      if (Â«condÂ») Â«then_statementÂ»
      else Â«else_statementÂ»

   So far, the ``then_statement`` has always been a block, but we can use any
   statement. That statement must be terminated with a semicolon:

   .. code:: javascript

      if (true) console.log('Yes'); else console.log('No');

   That means that ``else if`` is not its own construct; itâ€™s simply an ``if``
   statement whose ``else_statement`` is another ``if`` statement.



.. _switch:

25.4â€ƒ``switch`` statements [ES3]
---------------------------------

   A ``switch`` statement looks as follows:

   .. code:: language-txt

      switch (Â«switch_expressionÂ») {
      Â«switch_bodyÂ»
      }

   The body of ``switch`` consists of zero or more case clauses:

   .. code:: language-txt

      case Â«case_expressionÂ»:
      Â«statementsÂ»

   And, optionally, a default clause:

   .. code:: language-txt

      default:
      Â«statementsÂ»

   A ``switch`` is executed as follows:

   -  It evaluates the switch expression.
   -  It jumps to the first case clause whose expression has the same result as the
      switch expression.
   -  Otherwise, if there is no such clause, it jumps to the default clause.
   -  Otherwise, if there is no default clause, it does nothing.

25.4.1â€ƒA first example of a ``switch`` statement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Letâ€™s look at an example: The following function converts a number from 1â€“7 to
   the name of a weekday.

   .. code:: javascript

      function dayOfTheWeek(num) {
      switch (num) {
         case 1:
            return 'Monday';
         case 2:
            return 'Tuesday';
         case 3:
            return 'Wednesday';
         case 4:
            return 'Thursday';
         case 5:
            return 'Friday';
         case 6:
            return 'Saturday';
         case 7:
            return 'Sunday';
      }
      }
      assert.equal(dayOfTheWeek(5), 'Friday');



.. _don-t-forget-to-return-or-break:

25.4.2â€ƒDonâ€™t forget to ``return`` or ``break``!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   At the end of a case clause, execution continues with the next case clause,
   unless we ``return`` or ``break`` â€“ for example:

   .. code:: javascript

      function englishToFrench(english) {
      let french;
      switch (english) {
         case 'hello':
            french = 'bonjour';
         case 'goodbye':
            french = 'au revoir';
      }
      return french;
      }
      // The result should be 'bonjour'!
      assert.equal(englishToFrench('hello'), 'au revoir');

   That is, our implementation of ``dayOfTheWeek()`` only worked because we used
   ``return``. We can fix ``englishToFrench()`` by using ``break``:

   .. code:: javascript

      function englishToFrench(english) {
      let french;
      switch (english) {
         case 'hello':
            french = 'bonjour';
            break;
         case 'goodbye':
            french = 'au revoir';
            break;
      }
      return french;
      }
      assert.equal(englishToFrench('hello'), 'bonjour'); // ok

25.4.3â€ƒEmpty case clauses
~~~~~~~~~~~~~~~~~~~~~~~~~~

   The statements of a case clause can be omitted, which effectively gives us
   multiple case expressions per case clause:

   .. code:: javascript

      function isWeekDay(name) {
      switch (name) {
         case 'Monday':
         case 'Tuesday':
         case 'Wednesday':
         case 'Thursday':
         case 'Friday':
            return true;
         case 'Saturday':
         case 'Sunday':
            return false;
      }
      }
      assert.equal(isWeekDay('Wednesday'), true);
      assert.equal(isWeekDay('Sunday'), false);

25.4.4â€ƒChecking for illegal values via a ``default`` clause
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A ``default`` clause is jumped to if the ``switch`` expression has no other
   match. That makes it useful for error checking:

   .. code:: javascript

      function isWeekDay(name) {
      switch (name) {
         case 'Monday':
         case 'Tuesday':
         case 'Wednesday':
         case 'Thursday':
         case 'Friday':
            return true;
         case 'Saturday':
         case 'Sunday':
            return false;
         default:
            throw new Error('Illegal value: '+name);
      }
      }
      assert.throws(
      () => isWeekDay('January'),
      {message: 'Illegal value: January'});

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercises: ``switch``**

      .. container:: boxout-vspace

      -  ``exercises/control-flow/number_to_month_test.mjs``
      -  Bonus: ``exercises/control-flow/is_object_via_switch_test.mjs``



.. _while:

25.5â€ƒ``while`` loops [ES1]
---------------------------

   A ``while`` loop has the following syntax:

   .. code:: language-txt

      while (Â«conditionÂ») {
      Â«statementsÂ»
      }

   Before each loop iteration, ``while`` evaluates ``condition``:

   -  If the result is falsy, the loop is finished.
   -  If the result is truthy, the ``while`` body is executed one more time.

25.5.1â€ƒExamples of ``while`` loops
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following code uses a ``while`` loop. In each loop iteration, it removes the
   first element of ``arr`` via ``.shift()`` and logs it.

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      while (arr.length > 0) {
      const elem = arr.shift(); // remove first element
      console.log(elem);
      }

   Output:

   ::

      a
      b
      c

   If the condition always evaluates to ``true``, then ``while`` is an infinite
   loop:

   .. code:: javascript

      while (true) {
      if (Math.random() === 0) break;
      }



.. _do-while:

25.6â€ƒ``do-while`` loops [ES3]
------------------------------

   The ``do-while`` loop works much like ``while``, but it checks its condition
   *after* each loop iteration, not before.

   .. code:: javascript

      let input;
      do {
      input = prompt('Enter text:');
      console.log(input);
      } while (input !== ':q');

   ``do-while`` can also be viewed as a ``while`` loop that runs at least once.

   `prompt() <https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt>`__
   is a global function that is available in web browsers. It prompts the user to
   input text and returns it.



.. _for:

25.7â€ƒ``for`` loops [ES1]
-------------------------

   A ``for`` loop has the following syntax:

   .. code:: language-txt

      for (Â«initializationÂ»; Â«conditionÂ»; Â«post_iterationÂ») {
      Â«statementsÂ»
      }

   The first line is the *head* of the loop and controls how often the *body* (the
   remainder of the loop) is executed. It has three parts and each of them is
   optional:

   -  ``initialization``: sets up variables, etc. for the loop. Variables declared
      here via ``let`` or ``const`` only exist inside the loop.
   -  ``condition``: This condition is checked before each loop iteration. If it is
      falsy, the loop stops.
   -  ``post_iteration``: This code is executed after each loop iteration.

   A ``for`` loop is therefore roughly equivalent to the following ``while`` loop:

   .. code:: language-txt

      Â«initializationÂ»
      while (Â«conditionÂ») {
      Â«statementsÂ»
      Â«post_iterationÂ»
      }

25.7.1â€ƒExamples of ``for`` loops
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   As an example, this is how to count from zero to two via a ``for`` loop:

   .. code:: javascript

      for (let i=0; i<3; i++) {
      console.log(i);
      }

   Output:

   ::

      0
      1
      2

   This is how to log the contents of an Array via a ``for`` loop:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      for (let i=0; i<arr.length; i++) {
      console.log(arr[i]);
      }

   Output:

   ::

      a
      b
      c

   If we omit all three parts of the head, we get an infinite loop:

   .. code:: javascript

      for (;;) {
      if (Math.random() === 0) break;
      }



.. _for-of:

25.8â€ƒ``for-of`` loops [ES6]
----------------------------

   A ``for-of`` loop iterates over any *iterable* â€“ a data container that supports
   `the iteration protocol <#ch_sync-iteration>`__. Each
   iterated value is stored in a variable, as specified in the head:

   .. code:: language-txt

      for (Â«iteration_variableÂ» of Â«iterableÂ») {
      Â«statementsÂ»
      }

   The iteration variable is usually created via a variable declaration:

   .. code:: javascript

      const iterable = ['hello', 'world'];
      for (const elem of iterable) {
      console.log(elem);
      }

   Output:

   ::

      hello
      world

   But we can also use a (mutable) variable that already exists:

   .. code:: javascript

      const iterable = ['hello', 'world'];
      let elem;
      for (elem of iterable) {
      console.log(elem);
      }



.. _const-for-of-vs-for:

25.8.1â€ƒ``const``: ``for-of`` vs. ``for``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Note that in ``for-of`` loops we can use ``const``. The iteration variable can
   still be different for each iteration (it just canâ€™t change during the
   iteration). Think of it as a new ``const`` declaration being executed each time
   in a fresh scope.

   In contrast, in ``for`` loops we must declare variables via ``let`` or ``var``
   if their values change.

25.8.2â€ƒIterating over iterables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   As mentioned before, ``for-of`` works with any iterable object, not just with
   Arrays â€“ for example, with Sets:

   .. code:: javascript

      const set = new Set(['hello', 'world']);
      for (const elem of set) {
      console.log(elem);
      }



.. _for-of-iterating-index-element:

25.8.3â€ƒIterating over [index, element] pairs of Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Lastly, we can also use ``for-of`` to iterate over the [index, element] entries
   of Arrays:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      for (const [index, element] of arr.entries()) {
      console.log(`${index} -> ${element}`);
      }

   Output:

   ::

      0 -> a
      1 -> b
      2 -> c

   With ``[index, element]``, we are using
   `destructuring <#ch_destructuring>`__ to access Array
   elements.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: ``for-of``**

      .. container:: boxout-vspace

      ``exercises/control-flow/array_to_string_test.mjs``



.. _for-await-of-loops:

25.9â€ƒ``for-await-of`` loops [ES2018]
-------------------------------------

   ``for-await-of`` is like ``for-of``, but it works with asynchronous iterables
   instead of synchronous ones. And it can only be used inside async functions and
   async generators.

   .. code:: javascript

      for await (const item of asyncIterable) {
      // Â·Â·Â·
      }

   ``for-await-of`` is described in detail `in the chapter on asynchronous
   iteration <#for-await-of>`__.



.. _for-in:

25.10â€ƒ``for-in`` loops (avoid) [ES1]
-------------------------------------

   The ``for-in`` loop visits all (own and inherited) enumerable property keys of
   an object. When looping over an Array, it is rarely a good choice:

   -  It visits property keys, not values.
   -  As property keys, the indices of Array elements are strings, not numbers
      (`more information on how Array elements
      work <#array-indices>`__).
   -  It visits all enumerable property keys (both own and inherited ones), not
      just those of Array elements.

   The following code demonstrates these points:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      arr.propKey = 'property value';

      for (const key in arr) {
      console.log(key);
      }

   Output:

   ::

      0
      1
      2
      propKey

25.11â€ƒRecomendations for looping
---------------------------------

   -  If you want to loop over an `asynchronous
      iterable <#ch_async-iteration>`__ (in ES2018+), you
      must use ``for-await-of``.
   -  For looping over a synchronous iterable (in ES6+), you must use ``for-of``.
      Note that Arrays are iterables.
   -  For looping over an Array in ES5+, you can use `the Array method
      ``.forEach() <#qref-Array.prototype.forEach>`__.
   -  Before ES5, you can use a plain ``for`` loop to loop over an Array.
   -  Donâ€™t use ``for-in`` to loop over an Array.

   `Comments <https://github.com/rauschma/exploring-js/issues/16>`__



.. _ch_exception-handling:

26â€ƒException handling
======================

   #. `26.1â€ƒMotivation: throwing and catching exceptions <#motivation-throwing-and-catching-exceptions>`__
   #. `26.2â€ƒthrow <#throw>`__

      #. `26.2.1â€ƒWhat values should we throw? <#what-values-should-we-throw>`__

   #. `26.3â€ƒThe try statement <#the-try-statement>`__

      #. `26.3.1â€ƒThe try block <#the-try-block>`__
      #. `26.3.2â€ƒThe catch clause <#the-catch-clause>`__
      #. `26.3.3â€ƒThe finally clause <#the-finally-clause>`__

   #. `26.4â€ƒError and its subclasses <#error-classes>`__

      #. `26.4.1â€ƒClass Error <#class-Error>`__
      #. `26.4.2â€ƒThe built-in subclasses of Error <#error-subclasses>`__
      #. `26.4.3â€ƒSubclassing Error <#subclassing-error>`__

   #. `26.5â€ƒChaining errors <#chaining-errors>`__

      #. `26.5.1â€ƒWhy would we want to chain errors? <#why-would-we-want-to-chain-errors>`__
      #. `26.5.2â€ƒChaining errors via error.cause [ES2022] <#error.cause>`__
      #. `26.5.3â€ƒAn alternative to .cause: a custom error class <#an-alternative-to-cause-a-custom-error-class>`__

   This chapter covers how JavaScript handles exceptions.

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Why doesnâ€™t JavaScript throw exceptions more often?**

      .. container:: boxout-vspace

      JavaScript didnâ€™t support exceptions until ES3. That explains why they are
      used sparingly by the language and its standard library.

26.1â€ƒMotivation: throwing and catching exceptions
--------------------------------------------------

   Consider the following code. It reads profiles stored in files into an Array
   with instances of class ``Profile``:

   .. code:: javascript

      function readProfiles(filePaths) {
      const profiles = [];
      for (const filePath of filePaths) {
         try {
            const profile = readOneProfile(filePath);
            profiles.push(profile);
         } catch (err) { // (A)
            console.log('Error in: '+filePath, err);
         }
      }
      }
      function readOneProfile(filePath) {
      const profile = new Profile();
      const file = openFile(filePath);
      // Â·Â·Â· (Read the data in `file` into `profile`)
      return profile;
      }
      function openFile(filePath) {
      if (!fs.existsSync(filePath)) {
         throw new Error('Could not find file '+filePath); // (B)
      }
      // Â·Â·Â· (Open the file whose path is `filePath`)
      }

   Letâ€™s examine what happens in line B: An error occurred, but the best place to
   handle the problem is not the current location, itâ€™s line A. There, we can skip
   the current file and move on to the next one.

   Therefore:

   -  In line B, we use a ``throw`` statement to indicate that there was a problem.
   -  In line A, we use a ``try-catch`` statement to handle the problem.

   When we throw, the following constructs are active:

   .. code:: language-txt

      readProfiles(Â·Â·Â·)
      for (const filePath of filePaths)
         try
            readOneProfile(Â·Â·Â·)
            openFile(Â·Â·Â·)
               if (!fs.existsSync(filePath))
                  throw

   One by one, ``throw`` exits the nested constructs, until it encounters a ``try``
   statement. Execution continues in the ``catch`` clause of that ``try``
   statement.

26.2â€ƒ``throw``
---------------

   This is the syntax of the ``throw`` statement:

   .. code:: javascript

      throw Â«valueÂ»;

26.2.1â€ƒWhat values should we throw?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Any value can be thrown in JavaScript. However, itâ€™s best to use instances of
   ``Error`` or a subclass because they support additional features such as stack
   traces and error chaining (see `â€œ\ ``Error`` and its subclassesâ€
   (Â§26.4) <#error-classes>`__).

   That leaves us with the following options:

   -  Using class ``Error`` directly. That is less limiting in JavaScript than in a
      more static language because we can add our own properties to instances:

      .. code:: javascript

         const err = new Error('Could not find the file');
         err.filePath = filePath;
         throw err;

   -  Using one of `the subclasses of ``Error <#error-subclasses>`__.

   -  Subclassing ``Error`` (more details are explained
      `later <#subclassing-error>`__):

      .. code:: javascript

         class MyError extends Error {
         }
         function func() {
         throw new MyError('Problem!');
         }
         assert.throws(
         () => func(),
         MyError);

26.3â€ƒThe ``try`` statement
---------------------------

   The maximal version of the ``try`` statement looks as follows:

   .. code:: javascript

      try {
      Â«try_statementsÂ»
      } catch (error) {
      Â«catch_statementsÂ»
      } finally {
      Â«finally_statementsÂ»
      }

   We can combine these clauses as follows:

   -  ``try-catch``
   -  ``try-finally``
   -  ``try-catch-finally``

26.3.1â€ƒThe ``try`` block
~~~~~~~~~~~~~~~~~~~~~~~~~

   The ``try`` block can be considered the body of the statement. This is where we
   execute the regular code.

26.3.2â€ƒThe ``catch`` clause
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If an exception reaches the ``try`` block, then it is assigned to the parameter
   of the ``catch`` clause and the code in that clause is executed. Next, execution
   normally continues after the ``try`` statement. That may change if:

   -  There is a ``return``, ``break``, or ``throw`` inside the ``catch`` block.
   -  There is a ``finally`` clause (which is always executed before the ``try``
      statement ends).

   The following code demonstrates that the value that is thrown in line A is
   indeed caught in line B.

   .. code:: javascript

      const errorObject = new Error();
      function func() {
      throw errorObject; // (A)
      }

      try {
      func();
      } catch (err) { // (B)
      assert.equal(err, errorObject);
      }



.. _omitting-catch-binding:

26.3.2.1â€ƒOmitting the ``catch`` binding [ES2019]
'''''''''''''''''''''''''''''''''''''''''''''''''

   We can omit the ``catch`` parameter if we are not interested in the value that
   was thrown:

   .. code:: javascript

      try {
      // Â·Â·Â·
      } catch {
      // Â·Â·Â·
      }

   That may occasionally be useful. For example, Node.js has the API function
   `assert.throws(func) <https://nodejs.org/api/assert.html#assert_assert_throws_fn_error_message>`__
   that checks whether an error is thrown inside ``func``. It could be implemented
   as follows.

   .. code:: javascript

      function throws(func) {
      try {
         func();
      } catch {
         return; // everything OK
      }
      throw new Error('Function didnâ€™t throw an exception!');
      }

   However, a more complete implementation of this function would have a ``catch``
   parameter and would, for example, check that its type is as expected.

26.3.3â€ƒThe ``finally`` clause
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The code inside the ``finally`` clause is always executed at the end of a
   ``try`` statement â€“ no matter what happens in the ``try`` block or the ``catch``
   clause.

   Letâ€™s look at a common use case for ``finally``: We have created a resource and
   want to always destroy it when we are done with it, no matter what happens while
   working with it. We would implement that as follows:

   .. code:: javascript

      const resource = createResource();
      try {
      // Work with `resource`. Errors may be thrown.
      } finally {
      resource.destroy();
      }

26.3.3.1â€ƒ``finally`` is always executed
''''''''''''''''''''''''''''''''''''''''

   The ``finally`` clause is always executed, even if an error is thrown (line A):

   .. code:: javascript

      let finallyWasExecuted = false;
      assert.throws(
      () => {
         try {
            throw new Error(); // (A)
         } finally {
            finallyWasExecuted = true;
         }
      },
      Error
      );
      assert.equal(finallyWasExecuted, true);

   And even if there is a ``return`` statement (line A):

   .. code:: javascript

      let finallyWasExecuted = false;
      function func() {
      try {
         return; // (A)
      } finally {
         finallyWasExecuted = true;
      }
      }
      func();
      assert.equal(finallyWasExecuted, true);



.. _error-classes:

26.4â€ƒ``Error`` and its subclasses
----------------------------------

   ``Error`` is the common superclass of all built-in error classes.



.. _class-Error:

26.4.1â€ƒClass ``Error``
~~~~~~~~~~~~~~~~~~~~~~~

   This is what ``Error``\ â€™s instance properties and constructor look like:

   .. code:: javascript
      :name: language-ts

      class Error {
      // Instance properties
      message: string;
      cause?: any; // ES2022
      stack: string; // non-standard but widely supported

      constructor(
         message: string = '',
         options?: ErrorOptions // ES2022
      );
      }
      interface ErrorOptions {
      cause?: any; // ES2022
      }

   The constructor has two parameters:

   -  ``message`` specifies an error message.
   -  ``options`` was introduced in ECMAScript 2022. It contains an object where
      one property is currently supported:

      -  ``.cause`` specifies which exception (if any) caused the current error.

   The subsections after the next one explain the instance properties ``.message``,
   ``.cause`` and ``.stack`` in more detail.



.. _error-prototype-name:

26.4.1.1â€ƒ``Error.prototype.name``
''''''''''''''''''''''''''''''''''

   Each built-in error class ``E`` has a property ``E.prototype.name``:

   .. code:: javascript
      :name: language-node-repl

      > Error.prototype.name
      'Error'
      > RangeError.prototype.name
      'RangeError'

   Therefore, there are two ways to get the name of the class of a built-in error
   object:

   .. code:: javascript
      :name: language-node-repl

      > new RangeError().name
      'RangeError'
      > new RangeError().constructor.name
      'RangeError'



.. _error.message:

26.4.1.2â€ƒError instance property ``.message``
''''''''''''''''''''''''''''''''''''''''''''''

   ``.message`` contains just the error message:

   .. code:: javascript

      const err = new Error('Hello!');
      assert.equal(String(err), 'Error: Hello!');
      assert.equal(err.message, 'Hello!');

   If we omit the message then the empty string is used as a default value
   (inherited from ``Error.prototype.message``):

   If we omit the message, it is the empty string:

   .. code:: javascript

      assert.equal(new Error().message, '');



.. _error-stack:

26.4.1.3â€ƒError instance property ``.stack``
''''''''''''''''''''''''''''''''''''''''''''

   The instance property ``.stack`` is not an ECMAScript feature, but it is widely
   supported by JavaScript engines. It is usually a string, but its exact structure
   is not standardized and varies between engines.

   This is what it looks like on the JavaScript engine V8:

   .. code:: javascript

      const err = new Error('Hello!');
      assert.equal(
      err.stack,
      `
      Error: Hello!
         at main.mjs:1:13
      `.trim());



.. _error-instance-property-cause:

26.4.1.4â€ƒError instance property ``.cause`` [ES2022]
'''''''''''''''''''''''''''''''''''''''''''''''''''''

   The instance property ``.cause`` is created via the options object in the second
   parameter of ``new Error()``. It specifies which other error caused the current
   one.

   .. code:: javascript

      const err = new Error('msg', {cause: 'the cause'});
      assert.equal(err.cause, 'the cause');

   For information on how to use this property see `â€œChaining errorsâ€
   (Â§26.5) <#chaining-errors>`__.



.. _error-subclasses:

26.4.2â€ƒThe built-in subclasses of ``Error``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``Error`` has the following subclasses â€“ quoting `the ECMAScript
   specification <https://tc39.es/ecma262/#sec-native-error-types-used-in-this-standard>`__:

   -  `AggregateError <#AggregateError>`__ :sup:`[ES2021]`
      represents multiple errors at once. In the standard library, only
      ``Promise.any()`` uses it.
   -  ``RangeError`` indicates a value that is not in the set or range of allowable
      values.
   -  ``ReferenceError`` indicates that an invalid reference value has been
      detected.
   -  ``SyntaxError`` indicates that a parsing error has occurred.
   -  ``TypeError`` is used to indicate an unsuccessful operation when none of the
      other *NativeError* objects are an appropriate indication of the failure
      cause.
   -  ``URIError`` indicates that one of the global URI handling functions was used
      in a way that is incompatible with its definition.

26.4.3â€ƒSubclassing ``Error``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Since ECMAScript 2022, the ``Error`` constructor accepts two parameters (see
   previous subsection). Therefore, we have two choices when subclassing it: We can
   either omit the constructor in our subclass or we can invoke ``super()`` like
   this:

   .. code:: javascript

      class MyCustomError extends Error {
      constructor(message, options) {
         super(message, options);
         // Â·Â·Â·
      }
      }

26.5â€ƒChaining errors
---------------------

26.5.1â€ƒWhy would we want to chain errors?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sometimes, we catch errors that are thrown during a more deeply nested function
   call and would like to attach more information to it:

   .. code:: javascript

      function readFiles(filePaths) {
      return filePaths.map(
         (filePath) => {
            try {
            const text = readText(filePath);
            const json = JSON.parse(text);
            return processJson(json);
            } catch (error) {
            // (A)
            }
         });
      }

   The statements inside the ``try`` clause may throw all kinds of errors. In most
   cases, an error wonâ€™t be aware of the path of the file that caused it. Thatâ€™s
   why we would like to attach that information in line A.



.. _error.cause:

26.5.2â€ƒChaining errors via ``error.cause`` [ES2022]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Since ECMAScript 2022, ``new Error()`` lets us specify what caused it:

   .. code:: javascript

      function readFiles(filePaths) {
      return filePaths.map(
         (filePath) => {
            try {
            // Â·Â·Â·
            } catch (error) {
            throw new Error(
               `While processing ${filePath}`,
               {cause: error}
            );
            }
         });
      }



.. _an-alternative-to-cause-a-custom-error-class:

26.5.3â€ƒAn alternative to ``.cause``: a custom error class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following custom error class supports chaining. It is forward compatible
   with ``.cause``.

   .. code:: javascript

      /**
      * An error class that supports error chaining.
      * If there is built-in support for .cause, it uses it.
      * Otherwise, it creates this property itself.
      */
      class CausedError extends Error {
      constructor(message, options) {
         super(message, options);
         if (
            (isObject(options) && 'cause' in options)
            && !('cause' in this)
         ) {
            // .cause was specified but the superconstructor
            // did not create an instance property.
            const cause = options.cause;
            this.cause = cause;
            if ('stack' in cause) {
            this.stack = this.stack + '\nCAUSE: ' + cause.stack;
            }
         }
      }
      }

      function isObject(value) {
      return value !== null && typeof value === 'object';
      }

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Exception handling**

      .. container:: boxout-vspace

      ``exercises/exception-handling/call_function_test.mjs``

   `Comments <https://github.com/rauschma/exploring-js/issues/42>`__



.. _ch_callables:

27â€ƒCallable values
===================

   #. `27.1â€ƒKinds of functions <#kinds-of-functions>`__
   #. `27.2â€ƒOrdinary functions <#ordinary-functions>`__

      #. `27.2.1â€ƒNamed function expressions (advanced) <#named-function-expressions>`__
      #. `27.2.2â€ƒTerminology: function definitions and function expressions <#terminology-function-definitions-and-function-expressions>`__
      #. `27.2.3â€ƒParts of a function declaration <#parts-of-a-function-declaration>`__
      #. `27.2.4â€ƒRoles played by ordinary functions <#roles-of-ordinary-functions>`__
      #. `27.2.5â€ƒTerminology: entity vs. syntax vs. role (advanced) <#terminology-entity-vs-syntax-vs-role>`__

   #. `27.3â€ƒSpecialized functions [ES6] <#specialized-functions>`__

      #. `27.3.1â€ƒSpecialized functions are still functions <#specialized-functions-are-still-functions>`__
      #. `27.3.2â€ƒArrow functions <#arrow-functions>`__
      #. `27.3.3â€ƒThe special variable this in methods, ordinary functions and arrow functions <#this-in-callables>`__
      #. `27.3.4â€ƒRecommendation: prefer specialized functions over ordinary functions <#prefer-specialized-functions>`__

   #. `27.4â€ƒSummary: kinds of callable values <#summary-kinds-of-callable-values>`__
   #. `27.5â€ƒReturning values from functions and methods <#returning-values-from-functions-and-methods>`__
   #. `27.6â€ƒParameter handling <#parameter-handling>`__

      #. `27.6.1â€ƒTerminology: parameters vs. arguments <#terminology-parameters-vs-arguments>`__
      #. `27.6.2â€ƒTerminology: callback <#callback-function>`__
      #. `27.6.3â€ƒToo many or not enough arguments <#too-many-or-not-enough-arguments>`__
      #. `27.6.4â€ƒParameter default values [ES6] <#parameter-default-values>`__
      #. `27.6.5â€ƒRest parameters [ES6] <#rest-parameters>`__
      #. `27.6.6â€ƒNamed parameters <#named-parameters>`__
      #. `27.6.7â€ƒSimulating named parameters <#simulating-named-parameters>`__
      #. `27.6.8â€ƒSpreading (...) into function calls [ES6] <#spread-arguments>`__

   #. `27.7â€ƒMethods of functions: .call(), .apply(), .bind() <#methods-of-functions>`__

      #. `27.7.1â€ƒThe function method .call() <#Function.prototype.call>`__
      #. `27.7.2â€ƒThe function method .apply() <#Function.prototype.apply>`__
      #. `27.7.3â€ƒThe function method .bind() <#Function.prototype.bind>`__

   In this chapter, we look at JavaScript values that can be invoked: functions,
   methods, and classes.

27.1â€ƒKinds of functions
------------------------

   JavaScript has two categories of functions:

   -  An *ordinary function* can play several roles:

      -  Real function
      -  Method
      -  Constructor function

   -  A *specialized function* can only play one of those roles â€“ for example:

      -  An *arrow function* can only be a real function.
      -  A *method* can only be a method.
      -  A *class* can only be a constructor function.

      Specialized functions were added to the language in ECMAScript 6.

   Read on to find out what all of those things mean.

27.2â€ƒOrdinary functions
------------------------

   The following code shows two ways of doing (roughly) the same thing: creating an
   ordinary function.

   .. code:: javascript

      // Function declaration (a statement)
      function ordinary1(a, b, c) {
      // Â·Â·Â·
      }

      // const plus anonymous (nameless) function expression
      const ordinary2 = function (a, b, c) {
      // Â·Â·Â·
      };

   Inside a scope, function declarations are activated early (see `â€œDeclarations:
   scope and activationâ€
   (Â§13.8) <#declarations-scope-activation>`__) and can
   be called before they are declared. That is occasionally useful.

   Variable declarations, such as the one for ``ordinary2``, are not activated
   early.



.. _named-function-expressions:

27.2.1â€ƒNamed function expressions (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   So far, we have only seen anonymous function expressions â€“ which donâ€™t have
   names:

   .. code:: javascript

      const anonFuncExpr = function (a, b, c) {
      // Â·Â·Â·
      };

   But there are also *named function expressions*:

   .. code:: javascript

      const namedFuncExpr = function myName(a, b, c) {
      // `myName` is only accessible in here
      };

   ``myName`` is only accessible inside the body of the function. The function can
   use it to refer to itself (for self-recursion, etc.) â€“ independently of which
   variable it is assigned to:

   .. code:: javascript

      const func = function funcExpr() { return funcExpr };
      assert.equal(func(), func);

      // The name `funcExpr` only exists inside the function body:
      assert.throws(() => funcExpr(), ReferenceError);

   Even if they are not assigned to variables, named function expressions have
   names (line A):

   .. code:: javascript

      function getNameOfCallback(callback) {
      return callback.name;
      }

      assert.equal(
      getNameOfCallback(function () {}), ''); // anonymous

      assert.equal(
      getNameOfCallback(function named() {}), 'named'); // (A)

   Note that functions created via function declarations or variable declarations
   always have names:

   .. code:: javascript

      function funcDecl() {}
      assert.equal(
      getNameOfCallback(funcDecl), 'funcDecl');

      const funcExpr = function () {};
      assert.equal(
      getNameOfCallback(funcExpr), 'funcExpr');

   One benefit of functions having names is that those names show up in `error
   stack traces <#error-stack>`__.

27.2.2â€ƒTerminology: function definitions and function expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A *function definition* is syntax that creates functions:

   -  A function declaration (a statement)
   -  A function expression

   Function declarations always produce ordinary functions. Function expressions
   produce either ordinary functions or specialized functions:

   -  Ordinary function expressions (which we have already encountered):

      -  Anonymous function expressions
      -  Named function expressions

   -  Specialized function expressions (which weâ€™ll look at later):

      -  Arrow functions (which are always expressions)

   While function declarations are still popular in JavaScript, function
   expressions are almost always arrow functions in modern code.

27.2.3â€ƒParts of a function declaration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Letâ€™s examine the parts of a function declaration via the following example.
   Most of the terms also apply to function expressions.

   .. code:: javascript

      function add(x, y) {
      return x + y;
      }

   -  ``add`` is the *name* of the function declaration.
   -  ``add(x, y)`` is the *head* of the function declaration.
   -  ``x`` and ``y`` are the *parameters*.
   -  The curly braces (``{`` and ``}``) and everything between them are the *body*
      of the function declaration.
   -  The ``return`` statement explicitly returns a value from the function.



.. _trailing-commas-parameters:

27.2.3.1â€ƒTrailing commas in parameter lists [ES2017]
'''''''''''''''''''''''''''''''''''''''''''''''''''''

   JavaScript has always allowed and ignored trailing commas in Array literals.
   Since ES5, they are also allowed in object literals. Since ES2017, we can add
   trailing commas to parameter lists (declarations and invocations):

   .. code:: javascript

      // Declaration
      function retrieveData(
      contentText,
      keyword,
      {unique, ignoreCase, pageSize}, // trailing comma
      ) {
      // Â·Â·Â·
      }

      // Invocation
      retrieveData(
      '',
      null,
      {ignoreCase: true, pageSize: 10}, // trailing comma
      );



.. _roles-of-ordinary-functions:

27.2.4â€ƒRoles played by ordinary functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Consider the following function declaration from the previous section:

   .. code:: javascript

      function add(x, y) {
      return x + y;
      }

   This function declaration creates an ordinary function whose name is ``add``. As
   an ordinary function, ``add()`` can play three roles:

   -  Real function: invoked via a function call.

      .. code:: javascript

         assert.equal(add(2, 1), 3);

   -  Method: stored in a property, invoked via a method call.

      .. code:: javascript

         const obj = { addAsMethod: add };
         assert.equal(obj.addAsMethod(2, 4), 6); // (A)

      In line A, ``obj`` is called the *receiver* of the method call.

   -  Constructor function: invoked via ``new``.

      .. code:: javascript

         const inst = new add();
         assert.equal(inst instanceof add, true);

      As an aside, the names of constructor functions (incl. classes) normally
      start with capital letters.



.. _terminology-entity-vs-syntax-vs-role:

27.2.5â€ƒTerminology: entity vs. syntax vs. role (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The distinction between the concepts *syntax*, *entity*, and *role* is subtle
   and often doesnâ€™t matter. But Iâ€™d like to sharpen your eye for it:

   -  An *entity* is a JavaScript feature as it â€œlivesâ€ in RAM. An ordinary
      function is an entity.

      -  Entities include: ordinary functions, arrow functions, methods, and
         classes.

   -  *Syntax* is the code that we use to create entities. Function declarations
      and anonymous function expressions are syntax. They both create entities that
      are called ordinary functions.

      -  Syntax includes: function declarations and anonymous function expressions.
         The syntax that produces arrow functions is also called *arrow functions*.
         The same is true for methods and classes.

   -  A *role* describes how we use entities. The entity *ordinary function* can
      play the role *real function*, or the role *method*, or the role *class*. The
      entity *arrow function* can also play the role *real function*.

      -  The roles of functions are: real function, method, and constructor
         function.

   Many other programming languages only have a single entity that plays the role
   *real function*. Then they can use the name *function* for both role and entity.



.. _specialized-functions:

27.3â€ƒSpecialized functions [ES6]
---------------------------------

   Specialized functions are single-purpose versions of ordinary functions. Each
   one of them specializes in a single role:

   -  The purpose of an *arrow function* is to be a real function:

      .. code:: javascript

         const arrow = () => {
         return 123;
         };
         assert.equal(arrow(), 123);

   -  The purpose of a *method* is to be a method:

      .. code:: javascript

         const obj = {
         myMethod() {
            return 'abc';
         }
         };
         assert.equal(obj.myMethod(), 'abc');

   -  The purpose of a *class* is to be a constructor function:

      .. code:: javascript

         class MyClass {
         /* Â·Â·Â· */
         }
         const inst = new MyClass();

   Apart from nicer syntax, each kind of specialized function also supports new
   features, making them better at their jobs than ordinary functions.

   -  Arrow functions are explained soon.
   -  Methods are explained `in the chapter on
      objects <#methods-and-this>`__.
   -  Classes are explained `in the chapter on
      classes <#classes>`__.

   `Table 27.1 <#tbl:capabilities-of-functions>`__ lists the capabilities of
   ordinary and specialized functions.

   ================= ====================== ================= =================
   \                 Function call          Method call       Constructor call
   Ordinary function (this === undefined)   âœ”                 âœ”
   Arrow function    âœ”                      (lexical this)    âœ˜
   Method            (this === undefined)   âœ”                 âœ˜
   Class             âœ˜                      âœ˜                 âœ”
   ================= ====================== ================= =================

   Table 27.1: Capabilities of four kinds of functions. If a cell value is in
   parentheses, that implies some kind of limitation. The special variable ``this``
   is explained in `â€œThe special variable ``this`` in methods, ordinary functions
   and arrow functionsâ€ (Â§27.3.3) <#this-in-callables>`__.

27.3.1â€ƒSpecialized functions are still functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Itâ€™s important to note that arrow functions, methods, and classes are still
   categorized as functions:

   .. code:: javascript
      :name: language-node-repl

      > (() => {}) instanceof Function
      true
      > ({ method() {} }.method) instanceof Function
      true
      > (class SomeClass {}) instanceof Function
      true

27.3.2â€ƒArrow functions
~~~~~~~~~~~~~~~~~~~~~~~

   Arrow functions were added to JavaScript for two reasons:

   #. To provide a more concise way for creating functions.
   #. They work better as real functions inside methods: Methods can refer to the
      object that received a method call via the special variable ``this``. Arrow
      functions can access the ``this`` of a surrounding method, ordinary functions
      canâ€™t (because they have their own ``this``).

   Weâ€™ll first examine the syntax of arrow functions and then how ``this`` works in
   various functions.

27.3.2.1â€ƒThe syntax of arrow functions
'''''''''''''''''''''''''''''''''''''''

   Letâ€™s review the syntax of an anonymous function expression:

   .. code:: javascript

      const f = function (x, y, z) { return 123 };

   The (roughly) equivalent arrow function looks as follows. Arrow functions are
   expressions.

   .. code:: javascript

      const f = (x, y, z) => { return 123 };

   Here, the body of the arrow function is a block. But it can also be an
   expression. The following arrow function works exactly like the previous one.

   .. code:: javascript

      const f = (x, y, z) => 123;

   If an arrow function has only a single parameter and that parameter is an
   identifier (not `a destructuring
   pattern <#ch_destructuring>`__) then you can omit the
   parentheses around the parameter:

   .. code:: javascript

      const id = x => x;

   That is convenient when passing arrow functions as parameters to other functions
   or methods:

   .. code:: javascript
      :name: language-node-repl

      > [1,2,3].map(x => x+1)
      [ 2, 3, 4 ]

   This previous example demonstrates one benefit of arrow functions â€“ conciseness.
   If we perform the same task with a function expression, our code is more
   verbose:

   .. code:: javascript

      [1,2,3].map(function (x) { return x+1 });



.. _returning-object-literal-from-arrow-function:

27.3.2.2â€ƒSyntax pitfall: returning an object literal from an arrow function
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   If you want the expression body of an arrow function to be an object literal,
   you must put the literal in parentheses:

   .. code:: javascript

      const func1 = () => ({a: 1});
      assert.deepEqual(func1(), { a: 1 });

   If you donâ€™t, JavaScript thinks, the arrow function has a block body (that
   doesnâ€™t return anything):

   .. code:: javascript

      const func2 = () => {a: 1};
      assert.deepEqual(func2(), undefined);

   ``{a: 1}`` is interpreted as a block with `the label
   ``a: <#labels>`__ and the expression statement ``1``.
   Without an explicit ``return`` statement, the block body returns ``undefined``.

   This pitfall is caused by `syntactic
   ambiguity <#ambiguous-syntax>`__: object literals and code blocks
   have the same syntax. We use the parentheses to tell JavaScript that the body is
   an expression (an object literal) and not a statement (a block).



.. _this-in-callables:

27.3.3â€ƒThe special variable ``this`` in methods, ordinary functions and arrow functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**The special variable ``this`` is an object-oriented
      feature**

      .. container:: boxout-vspace

      We are taking a quick look at the special variable ``this`` here, in order to
      understand why arrow functions are better real functions than ordinary
      functions.

      But this feature only matters in object-oriented programming and is covered
      in more depth in `â€œMethods and the special variable ``this``\ â€
      (Â§30.5) <#methods-and-this>`__. Therefore, donâ€™t worry if you
      donâ€™t fully understand it yet.

   Inside methods, the special variable ``this`` lets us access the *receiver* â€“
   the object which received the method call:

   .. code:: javascript

      const obj = {
      myMethod() {
         assert.equal(this, obj);
      }
      };
      obj.myMethod();

   Ordinary functions can be methods and therefore also have the implicit parameter
   ``this``:

   .. code:: javascript

      const obj = {
      myMethod: function () {
         assert.equal(this, obj);
      }
      };
      obj.myMethod();

   ``this`` is even an implicit parameter when we use an ordinary function as a
   real function. Then its value is ``undefined`` (if `strict
   mode <#strict-mode>`__ is active, which it almost always is):

   .. code:: javascript

      function ordinaryFunc() {
      assert.equal(this, undefined);
      }
      ordinaryFunc();

   That means that an ordinary function, used as a real function, canâ€™t access the
   ``this`` of a surrounding method (line A). In contrast, arrow functions donâ€™t
   have ``this`` as an implicit parameter. They treat it like any other variable
   and can therefore access the ``this`` of a surrounding method (line B):

   .. code:: javascript

      const jill = {
      name: 'Jill',
      someMethod() {
         function ordinaryFunc() {
            assert.throws(
            () => this.name, // (A)
            /^TypeError: Cannot read properties of undefined \(reading 'name'\)$/);
         }
         ordinaryFunc();

         const arrowFunc = () => {
            assert.equal(this.name, 'Jill'); // (B)
         };
         arrowFunc();
      },
      };
      jill.someMethod();

   In this code, we can observe two ways of handling ``this``:

   -  Dynamic ``this``: In line A, we try to access the ``this`` of
      ``.someMethod()`` from an ordinary function. There, it is *shadowed* by the
      functionâ€™s own ``this``, which is ``undefined`` (as filled in by the function
      call). Given that ordinary functions receive their ``this`` via (dynamic)
      function or method calls, their ``this`` is called *dynamic*.

   -  Lexical ``this``: In line B, we again try to access the ``this`` of
      ``.someMethod()``. This time, we succeed because the arrow function does not
      have its own ``this``. ``this`` is resolved *lexically*, just like any other
      variable. Thatâ€™s why the ``this`` of arrow functions is called *lexical*.



.. _prefer-specialized-functions:

27.3.4â€ƒRecommendation: prefer specialized functions over ordinary functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Normally, you should prefer specialized functions over ordinary functions,
   especially classes and methods.

   When it comes to real functions, the choice between an arrow function and an
   ordinary function is less clear-cut, though:

   -  For anonymous inline function expressions, arrow functions are clear winners,
      due to their compact syntax and them not having ``this`` as an implicit
      parameter:

      .. code:: javascript

         const twiceOrdinary = [1, 2, 3].map(function (x) {return x * 2});
         const twiceArrow = [1, 2, 3].map(x => x * 2);

   -  For stand-alone named function declarations, arrow functions still benefit
      from lexical ``this``. But function declarations (which produce ordinary
      functions) have nice syntax and early activation is also occasionally useful
      (see `â€œDeclarations: scope and activationâ€
      (Â§13.8) <#declarations-scope-activation>`__). If
      ``this`` doesnâ€™t appear in the body of an ordinary function, there is no
      downside to using it as a real function. The static checking tool ESLint can
      warn us during development when we do this wrong via `a built-in
      rule <https://eslint.org/docs/rules/no-invalid-this>`__.

      .. code:: javascript

         function timesOrdinary(x, y) {
         return x * y;
         }
         const timesArrow = (x, y) => {
         return x * y;
         };

27.4â€ƒSummary: kinds of callable values
---------------------------------------

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**This section refers to upcoming content**

      .. container:: boxout-vspace

      This section mainly serves as a reference for the current and upcoming
      chapters. Donâ€™t worry if you donâ€™t understand everything.

   So far, all (real) functions and methods, that we have seen, were:

   -  Single-result
   -  Synchronous

   Later chapters will cover other modes of programming:

   -  *Iteration* treats objects as containers of data (so-called *iterables*) and
      provides a standardized way for retrieving what is inside them. If a function
      or a method returns an iterable, it returns multiple values.
   -  *Asynchronous programming* deals with handling a long-running computation.
      You are notified when the computation is finished and can do something else
      in between. The standard pattern for asynchronously delivering single results
      is called *Promise*.

   These modes can be combined â€“ for example, there are synchronous iterables and
   asynchronous iterables.

   Several new kinds of functions and methods help with some of the mode
   combinations:

   -  *Async functions* help implement functions that return Promises. There are
      also *async methods*.
   -  *Synchronous generator functions* help implement functions that return
      synchronous iterables. There are also *synchronous generator methods*.
   -  *Asynchronous generator functions* help implement functions that return
      asynchronous iterables. There are also *asynchronous generator methods*.

   That leaves us with 4 kinds (2 Ã— 2) of functions and methods:

   -  Synchronous vs. asynchronous
   -  Generator vs. single-result

   `Table 27.2 <#tbl:syntax-functions-methods>`__ gives an overview of the syntax
   for creating these 4 kinds of functions and methods.

   ============================  =====================  ===============  ====
   \                                                    Result           #
   **Sync function**             **Sync method**        
   function f() {}               { m() {} }             value            1
   f = function () {}            
   f = () => {}                  
   **Sync generator function**   **Sync gen. method**   
   function* f() {}              { * m() {} }           iterable         0+
   f = function* () {}           
   **Async function**            **Async method**       
   async function f() {}         { async m() {} }       Promise          1
   f = async function () {}      
   f = async () => {}            
   **Async generator function**  **Async gen. method**  
   async function* f() {}        { async * m() {} }     async iterable   0+
   f = async function* () {}     
   ============================  =====================  ===============  ====

   Table 27.2: Syntax for creating functions and methods. The last column specifies
   how many values are produced by an entity.

27.5â€ƒReturning values from functions and methods
-------------------------------------------------

   (Everything mentioned in this section applies to both functions and methods.)

   The ``return`` statement explicitly returns a value from a function:

   .. code:: javascript

      function func() {
      return 123;
      }
      assert.equal(func(), 123);

   Another example:

   .. code:: javascript

      function boolToYesNo(bool) {
      if (bool) {
         return 'Yes';
      } else {
         return 'No';
      }
      }
      assert.equal(boolToYesNo(true), 'Yes');
      assert.equal(boolToYesNo(false), 'No');

   If, at the end of a function, you havenâ€™t returned anything explicitly,
   JavaScript returns ``undefined`` for you:

   .. code:: javascript

      function noReturn() {
      // No explicit return
      }
      assert.equal(noReturn(), undefined);

27.6â€ƒParameter handling
------------------------

   Once again, I am only mentioning functions in this section, but everything also
   applies to methods.



.. _terminology-parameters-vs-arguments:

27.6.1â€ƒTerminology: parameters vs. arguments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The term *parameter* and the term *argument* basically mean the same thing. If
   you want to, you can make the following distinction:

   -  *Parameters* are part of a function definition. They are also called *formal
      parameters* and *formal arguments*.

   -  *Arguments* are part of a function call. They are also called *actual
      parameters* and *actual arguments*.



.. _callback-function:

27.6.2â€ƒTerminology: callback
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A *callback* or *callback function* is a function that is an argument of a
   function or method call.

   The following is an example of a callback:

   .. code:: javascript

      const myArray = ['a', 'b'];
      const callback = (x) => console.log(x);
      myArray.forEach(callback);

   Output:

   ::

      a
      b

27.6.3â€ƒToo many or not enough arguments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScript does not complain if a function call provides a different number of
   arguments than expected by the function definition:

   -  Extra arguments are ignored.
   -  Missing parameters are set to ``undefined``.

   For example:

   .. code:: javascript

      function foo(x, y) {
      return [x, y];
      }

      // Too many arguments:
      assert.deepEqual(foo('a', 'b', 'c'), ['a', 'b']);

      // The expected number of arguments:
      assert.deepEqual(foo('a', 'b'), ['a', 'b']);

      // Not enough arguments:
      assert.deepEqual(foo('a'), ['a', undefined]);



.. _parameter-default-values:

27.6.4â€ƒParameter default values [ES6]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Parameter default values specify the value to use if a parameter has not been
   provided â€“ for example:

   .. code:: javascript

      function f(x, y=0) {
      return [x, y];
      }

      assert.deepEqual(f(1), [1, 0]);
      assert.deepEqual(f(), [undefined, 0]);

   ``undefined`` also triggers the default value:

   .. code:: javascript

      assert.deepEqual(
      f(undefined, undefined),
      [undefined, 0]);



.. _rest-parameters:

27.6.5â€ƒRest parameters [ES6]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A rest parameter is declared by prefixing an identifier with three dots
   (``...``). During a function or method call, it receives an Array with all
   remaining arguments. If there are no extra arguments at the end, it is an empty
   Array â€“ for example:

   .. code:: javascript

      function f(x, ...y) {
      return [x, y];
      }
      assert.deepEqual(
      f('a', 'b', 'c'), ['a', ['b', 'c']]
      );
      assert.deepEqual(
      f(), [undefined, []]
      );

   There are two restrictions related to how we can use rest parameters:

   -  We cannot use more than one rest parameter per function definition.

      .. code:: javascript

         assert.throws(
         () => eval('function f(...x, ...y) {}'),
         /^SyntaxError: Rest parameter must be last formal parameter$/
         );

   -  A rest parameter must always come last. As a consequence, we canâ€™t access the
      last parameter like this:

      .. code:: javascript

         assert.throws(
         () => eval('function f(...restParams, lastParam) {}'),
         /^SyntaxError: Rest parameter must be last formal parameter$/
         );

27.6.5.1â€ƒEnforcing a certain number of arguments via a rest parameter
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   You can use a rest parameter to enforce a certain number of arguments. Take, for
   example, the following function:

   .. code:: javascript

      function createPoint(x, y) {
      return {x, y};
         // same as {x: x, y: y}
      }

   This is how we force callers to always provide two arguments:

   .. code:: javascript

      function createPoint(...args) {
      if (args.length !== 2) {
         throw new Error('Please provide exactly 2 arguments!');
      }
      const [x, y] = args; // (A)
      return {x, y};
      }

   In line A, we access the elements of ``args`` via
   `destructuring <#ch_destructuring>`__.

27.6.6â€ƒNamed parameters
~~~~~~~~~~~~~~~~~~~~~~~~

   When someone calls a function, the arguments provided by the caller are assigned
   to the parameters received by the callee. Two common ways of performing the
   mapping are:

   #. Positional parameters: An argument is assigned to a parameter if they have
      the same position. A function call with only positional arguments looks as
      follows.

      .. code:: javascript

         selectEntries(3, 20, 2)

   #. Named parameters: An argument is assigned to a parameter if they have the
      same name. JavaScript doesnâ€™t have named parameters, but you can simulate
      them. For example, this is a function call with only (simulated) named
      arguments:

      .. code:: javascript

         selectEntries({start: 3, end: 20, step: 2})

   Named parameters have several benefits:

   -  They lead to more self-explanatory code because each argument has a
      descriptive label. Just compare the two versions of ``selectEntries()``: with
      the second one, it is much easier to see what happens.

   -  The order of the arguments doesnâ€™t matter (as long as the names are correct).

   -  Handling more than one optional parameter is more convenient: callers can
      easily provide any subset of all optional parameters and donâ€™t have to be
      aware of the ones they omit (with positional parameters, you have to fill in
      preceding optional parameters, with ``undefined``).

27.6.7â€ƒSimulating named parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScript doesnâ€™t have real named parameters. The official way of simulating
   them is via object literals:

   .. code:: javascript

      function selectEntries({start=0, end=-1, step=1}) {
      return {start, end, step};
      }

   This function uses `destructuring <#ch_destructuring>`__ to
   access the properties of its single parameter. The pattern it uses is an
   abbreviation for the following pattern:

   .. code:: javascript

      {start: start=0, end: end=-1, step: step=1}

   This destructuring pattern works for empty object literals:

   .. code:: javascript
      :name: language-node-repl

      > selectEntries({})
      { start: 0, end: -1, step: 1 }

   But it does not work if you call the function without any parameters:

   .. code:: javascript
      :name: language-node-repl

      > selectEntries()
      TypeError: Cannot read properties of undefined (reading 'start')

   You can fix this by providing a default value for the whole pattern. This
   default value works the same as default values for simpler parameter
   definitions: if the parameter is missing, the default is used.

   .. code:: javascript

      function selectEntries({start=0, end=-1, step=1} = {}) {
      return {start, end, step};
      }
      assert.deepEqual(
      selectEntries(),
      { start: 0, end: -1, step: 1 });



.. _spread-arguments:

27.6.8â€ƒSpreading (``...``) into function calls [ES6]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If you put three dots (``...``) in front of the argument of a function call,
   then you *spread* it. That means that the argument must be `an iterable
   object <#ch_sync-iteration>`__ and the iterated values all
   become arguments. In other words, a single argument is expanded into multiple
   arguments â€“ for example:

   .. code:: javascript

      function func(x, y) {
      console.log(x);
      console.log(y);
      }
      const someIterable = ['a', 'b'];
      func(...someIterable);
      // same as func('a', 'b')

   Output:

   ::

      a
      b

   Spreading and rest parameters use the same syntax (``...``), but they serve
   opposite purposes:

   -  Rest parameters are used when defining functions or methods. They collect
      arguments into Arrays.
   -  Spread arguments are used when calling functions or methods. They turn
      iterable objects into arguments.



.. _example-spreading-into-math-max:

27.6.8.1â€ƒExample: spreading into ``Math.max()``
''''''''''''''''''''''''''''''''''''''''''''''''

   ``Math.max()`` returns the largest one of its zero or more arguments. Alas, it
   canâ€™t be used for Arrays, but spreading gives us a way out:

   .. code:: javascript
      :name: language-node-repl

      > Math.max(-1, 5, 11, 3)
      11
      > Math.max(...[-1, 5, 11, 3])
      11
      > Math.max(-1, ...[-5, 11], 3)
      11



.. _example-spreading-into-array-prototype-push:

27.6.8.2â€ƒExample: spreading into ``Array.prototype.push()``
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Similarly, the Array method ``.push()`` destructively adds its zero or more
   parameters to the end of its Array. JavaScript has no method for destructively
   appending an Array to another one. Once again, we are saved by spreading:

   .. code:: javascript

      const arr1 = ['a', 'b'];
      const arr2 = ['c', 'd'];

      arr1.push(...arr2);
      assert.deepEqual(arr1, ['a', 'b', 'c', 'd']);

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercises: Parameter handling**

      .. container:: boxout-vspace

      -  Positional parameters:
         ``exercises/callables/positional_parameters_test.mjs``
      -  Named parameters: ``exercises/callables/named_parameters_test.mjs``



.. _methods-of-functions:

27.7â€ƒMethods of functions: ``.call()``, ``.apply()``, ``.bind()``
------------------------------------------------------------------

   Functions are objects and have methods. In this section, we look at three of
   those methods: ``.call()``, ``.apply()``, and ``.bind()``.



.. _Function.prototype.call:

27.7.1â€ƒThe function method ``.call()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Each function ``someFunc`` has the following method:

   .. code:: javascript

      someFunc.call(thisValue, arg1, arg2, arg3);

   This method invocation is loosely equivalent to the following function call:

   .. code:: javascript

      someFunc(arg1, arg2, arg3);

   However, with ``.call()``, we can also specify a value for `the implicit
   parameter ``this <#this-in-callables>`__. In other words: ``.call()`` makes
   the implicit parameter ``this`` explicit.

   The following code demonstrates the use of ``.call()``:

   .. code:: javascript

      function func(x, y) {
      return [this, x, y];
      }

      assert.deepEqual(
      func.call('hello', 'a', 'b'),
      ['hello', 'a', 'b']);

   As we have seen before, if we function-call an ordinary function, its ``this``
   is ``undefined``:

   .. code:: javascript

      assert.deepEqual(
      func('a', 'b'),
      [undefined, 'a', 'b']);

   Therefore, the previous function call is equivalent to:

   .. code:: javascript

      assert.deepEqual(
      func.call(undefined, 'a', 'b'),
      [undefined, 'a', 'b']);

   In arrow functions, the value for ``this`` provided via ``.call()`` (or other
   means) is ignored.



.. _Function.prototype.apply:

27.7.2â€ƒThe function method ``.apply()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Each function ``someFunc`` has the following method:

   .. code:: javascript

      someFunc.apply(thisValue, [arg1, arg2, arg3]);

   This method invocation is loosely equivalent to the following function call
   (which uses `spreading <#spread-arguments>`__):

   .. code:: javascript

      someFunc(...[arg1, arg2, arg3]);

   However, with ``.apply()``, we can also specify a value for `the implicit
   parameter ``this <#this-in-callables>`__.

   The following code demonstrates the use of ``.apply()``:

   .. code:: javascript

      function func(x, y) {
      return [this, x, y];
      }

      const args = ['a', 'b'];
      assert.deepEqual(
      func.apply('hello', args),
      ['hello', 'a', 'b']);



.. _Function.prototype.bind:

27.7.3â€ƒThe function method ``.bind()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.bind()`` is another method of function objects. This method is invoked as
   follows:

   .. code:: javascript

      const boundFunc = someFunc.bind(thisValue, arg1, arg2);

   ``.bind()`` returns a new function ``boundFunc()``. Calling that function
   invokes ``someFunc()`` with ``this`` set to ``thisValue`` and these parameters:
   ``arg1``, ``arg2``, followed by the parameters of ``boundFunc()``.

   That is, the following two function calls are equivalent:

   .. code:: javascript

      boundFunc('a', 'b')
      someFunc.call(thisValue, arg1, arg2, 'a', 'b')



.. _an-alternative-to-bind:

27.7.3.1â€ƒAn alternative to ``.bind()``
'''''''''''''''''''''''''''''''''''''''

   Another way of pre-filling ``this`` and parameters is via an arrow function:

   .. code:: javascript

      const boundFunc2 = (...args) =>
      someFunc.call(thisValue, arg1, arg2, ...args);



.. _an-implementation-of-bind:

27.7.3.2â€ƒAn implementation of ``.bind()``
''''''''''''''''''''''''''''''''''''''''''

   Considering the previous section, ``.bind()`` can be implemented as a real
   function as follows:

   .. code:: javascript

      function bind(func, thisValue, ...boundArgs) {
      return (...args) =>
         func.call(thisValue, ...boundArgs, ...args);
      }

27.7.3.3â€ƒExample: binding a real function
''''''''''''''''''''''''''''''''''''''''''

   Using ``.bind()`` for real functions is somewhat unintuitive because we have to
   provide a value for ``this``. Given that it is ``undefined`` during function
   calls, it is usually set to ``undefined`` or ``null``.

   In the following example, we create ``add8()``, a function that has one
   parameter, by binding the first parameter of ``add()`` to ``8``.

   .. code:: javascript

      function add(x, y) {
      return x + y;
      }

      const add8 = add.bind(undefined, 8);
      assert.equal(add8(1), 9);

   `Comments <https://github.com/rauschma/exploring-js/issues/17>`__



.. _ch_dynamic-code-evaluation:

28â€ƒEvaluating code dynamically: ``eval()``, ``new Function()`` (advanced)
==========================================================================

   #. `28.1â€ƒeval() <#eval>`__
   #. `28.2â€ƒnew Function() <#new-function>`__
   #. `28.3â€ƒRecommendations <#recommendations>`__

   In this chapter, weâ€™ll look at two ways of evaluating code dynamically:
   ``eval()`` and ``new Function()``.

28.1â€ƒ``eval()``
----------------

   Given a string ``str`` with JavaScript code, ``eval(str)`` evaluates that code
   and returns the result:

   .. code:: javascript
      :name: language-node-repl

      > eval('2 ** 4')
      16

   There are two ways of invoking ``eval()``:

   -  *Directly*, via a function call. Then the code in its argument is evaluated
      inside the current scope.
   -  *Indirectly*, not via a function call. Then it evaluates its code in global
      scope.

   â€œNot via a function callâ€ means â€œanything that looks different than
   ``eval(Â·Â·Â·)``\ â€:

   -  ``eval.call(undefined, 'Â·Â·Â·')`` (uses `method ``.call()`` of
      functions <#Function.prototype.call>`__)
   -  ``eval?.()`` () (uses `optional
      chaining <#optional-chaining>`__)
   -  ``(0, eval)('Â·Â·Â·')`` (uses `the comma
      operator <#comma-operator>`__)
   -  ``globalThis.eval('Â·Â·Â·')``
   -  ``const e = eval; e('Â·Â·Â·')``
   -  Etc.

   The following code illustrates the difference:

   .. code:: javascript

      globalThis.myVariable = 'global';
      function func() {
      const myVariable = 'local';
      
      // Direct eval
      assert.equal(eval('myVariable'), 'local');
      
      // Indirect eval
      assert.equal(eval.call(undefined, 'myVariable'), 'global');
      }

   Evaluating code in global context is safer because the code has access to fewer
   internals.

28.2â€ƒ``new Function()``
------------------------

   ``new Function()`` creates a function object and is invoked as follows:

   .. code:: javascript

      const func = new Function('Â«param_1Â»', Â·Â·Â·, 'Â«param_nÂ»', 'Â«func_bodyÂ»');

   The previous statement is equivalent to the next statement. Note that
   ``Â«param_1Â»``, etc., are not inside string literals, anymore.

   .. code:: javascript

      const func = function (Â«param_1Â», Â·Â·Â·, Â«param_nÂ») {
      Â«func_bodyÂ»
      };

   In the next example, we create the same function twice, first via
   ``new Function()``, then via a function expression:

   .. code:: javascript

      const times1 = new Function('a', 'b', 'return a * b');
      const times2 = function (a, b) { return a * b };

   .. container:: boxout

      |Icon â€œwarningâ€|â€‚**``new Function()`` creates non-strict mode functions**

      .. container:: boxout-vspace

      By default, functions created via ``new Function()`` are
      `sloppy <#strict-mode>`__. If we want the function body to be
      in strict mode, we have to `switch it on
      manually <#switching-on-strict-mode>`__.

28.3â€ƒRecommendations
---------------------

   Avoid dynamic evaluation of code as much as you can:

   -  Itâ€™s a security risk because it may enable an attacker to execute arbitrary
      code with the privileges of your code.
   -  It may be switched off â€“ for example, in browsers, via `a Content Security
      Policy <https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP>`__.

   Very often, JavaScript is dynamic enough so that you donâ€™t need ``eval()`` or
   similar. In the following example, what we are doing with ``eval()`` (line A)
   can be achieved just as well without it (line B).

   .. code:: javascript

      const obj = {a: 1, b: 2};
      const propKey = 'b';

      assert.equal(eval('obj.' + propKey), 2); // (A)
      assert.equal(obj[propKey], 2); // (B)

   If you have to dynamically evaluate code:

   -  Prefer ``new Function()`` over ``eval()``: it always executes its code in
      global context and a function provides a clean interface to the evaluated
      code.
   -  Prefer indirect ``eval`` over direct ``eval``: evaluating code in global
      context is safer.

   `Comments <https://github.com/rauschma/exploring-js/issues/51>`__




.. _ch_modules:

29â€ƒModules [ES6]
=================

   #. `29.1â€ƒCheat sheet: modules <#cheat-sheet-modules>`__

      #. `29.1.1â€ƒNamed exports, named imports, namespace imports <#named-exports-named-imports-namespace-imports>`__
      #. `29.1.2â€ƒDynamic imports <#dynamic-imports>`__
      #. `29.1.3â€ƒDefault exports and imports <#default-exports-and-imports>`__
      #. `29.1.4â€ƒKinds of module specifiers <#kinds-of-module-specifiers>`__

   #. `29.2â€ƒJavaScript source code formats <#javascript-source-code-formats>`__

      #. `29.2.1â€ƒCode before built-in modules was written in ECMAScript 5 <#code-before-built-in-modules-was-written-in-ecmascript-5>`__

   #. `29.3â€ƒBefore we had modules, we had scripts <#scripts>`__
   #. `29.4â€ƒModule systems created prior to ES6 <#module-systems-created-prior-to-es6>`__

      #. `29.4.1â€ƒServer side: CommonJS modules <#server-side-commonjs-modules>`__
      #. `29.4.2â€ƒClient side: AMD (Asynchronous Module Definition) modules <#client-side-amd-asynchronous-module-definition-modules>`__
      #. `29.4.3â€ƒCharacteristics of JavaScript modules <#characteristics-of-javascript-modules>`__

   #. `29.5â€ƒECMAScript modules <#ecmascript-modules>`__

      #. `29.5.1â€ƒES modules: syntax, semantics, loader API <#es-modules-syntax-semantics-loader-api>`__

   #. `29.6â€ƒNamed exports and imports <#named-exports-and-imports>`__

      #. `29.6.1â€ƒNamed exports <#named-exports>`__
      #. `29.6.2â€ƒNamed imports <#named-imports>`__
      #. `29.6.3â€ƒNamespace imports <#namespace-imports>`__
      #. `29.6.4â€ƒNamed exporting styles: inline versus clause (advanced) <#named-exporting-styles-inline-versus-clause>`__

   #. `29.7â€ƒDefault exports and imports <#default-exports-and-imports-1>`__

      #. `29.7.1â€ƒThe two styles of default-exporting <#the-two-styles-of-default-exporting>`__
      #. `29.7.2â€ƒThe default export as a named export (advanced) <#the-default-export-as-a-named-export>`__

   #. `29.8â€ƒRe-exporting <#re-exporting>`__
   #. `29.9â€ƒMore details on exporting and importing <#more-details-on-exporting-and-importing>`__

      #. `29.9.1â€ƒImports are read-only views on exports <#imports-are-read-only-views-on-exports>`__
      #. `29.9.2â€ƒESMâ€™s transparent support for cyclic imports (advanced) <#esm-s-transparent-support-for-cyclic-imports>`__

   #. `29.10â€ƒnpm packages <#npm-packages>`__

      #. `29.10.1â€ƒPackages are installed inside a directory node_modules/ <#packages-are-installed-inside-a-directory-node-modules>`__
      #. `29.10.2â€ƒWhy can npm be used to install frontend libraries? <#why-can-npm-be-used-to-install-frontend-libraries>`__

   #. `29.11â€ƒNaming modules <#naming-modules>`__
   #. `29.12â€ƒModule specifiers <#module-specifiers>`__

      #. `29.12.1â€ƒCategories of module specifiers <#categories-of-module-specifiers>`__
      #. `29.12.2â€ƒES module specifiers in browsers <#es-module-specifiers-in-browsers>`__
      #. `29.12.3â€ƒES module specifiers on Node.js <#es-module-specifiers-on-node-js>`__

   #. `29.13â€ƒimport.meta â€“ metadata for the current module [ES2020] <#import.meta>`__

      #. `29.13.1â€ƒimport.meta.url <#import.meta.url>`__
      #. `29.13.2â€ƒimport.meta.url and class URL <#import-meta-url-and-class-url>`__
      #. `29.13.3â€ƒimport.meta.url on Node.js <#import-meta-url-on-node-js>`__

   #. `29.14â€ƒLoading modules dynamically via import() [ES2020] (advanced) <#dynamic-imports>`__

      #. `29.14.1â€ƒThe limitations of static import statements <#the-limitations-of-static-import-statements>`__
      #. `29.14.2â€ƒDynamic imports via the import() operator <#dynamic-imports-via-the-import-operator>`__
      #. `29.14.3â€ƒUse cases for import() <#use-cases-for-import>`__

   #. `29.15â€ƒTop-level await in modules [ES2022] (advanced) <#top-level-await>`__

      #. `29.15.1â€ƒUse cases for top-level await <#use-cases-for-top-level-await>`__
      #. `29.15.2â€ƒHow does top-level await work under the hood? <#how-does-top-level-await-work-under-the-hood>`__
      #. `29.15.3â€ƒThe pros and cons of top-level await <#the-pros-and-cons-of-top-level-await>`__

   #. `29.16â€ƒPolyfills: emulating native web platform features (advanced) <#polyfills>`__

      #. `29.16.1â€ƒSources of this section <#sources-of-this-section>`__

29.1â€ƒCheat sheet: modules
--------------------------

29.1.1â€ƒNamed exports, named imports, namespace imports
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If we put ``export`` in front of a named entity inside a module, it becomes a
   *named export* of that module. All other entities are private to the module.

   .. code:: javascript

      //===== lib1.mjs =====
      // Named exports
      export const one = 1, two = 2;
      export function myFunc() {
      return 3;
      }

   .. code:: javascript

      //===== main1a.mjs =====
      // Named imports
      import {one, myFunc as f} from './lib1.mjs';
      assert.equal(one, 1);
      assert.equal(f(), 3);

      // Namespace import
      import * as lib1 from './lib1.mjs';
      assert.equal(lib1.one, 1);
      assert.equal(lib1.myFunc(), 3);

   The string after ``from`` is called a *module specifier*. It identifies from
   which module we want to import.

29.1.2â€ƒDynamic imports
~~~~~~~~~~~~~~~~~~~~~~~

   So far, all imports we have seen were *static*, with the following constraints:

   -  They have to appear at the top level of a module.
   -  The module specifier is fixed.

   Dynamic imports via ``import()`` :sup:`[ES2020]` donâ€™t have those constraints:

   .. code:: javascript

      //===== main1b.mjs =====
      function importLibrary(moduleSpecifier) {
      return import(moduleSpecifier)
      .then((lib1) => {
         assert.equal(lib1.one, 1);
         assert.equal(lib1.myFunc(), 3);
      });
      }
      await importLibrary('./lib1.mjs');

29.1.3â€ƒDefault exports and imports
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   A *default export* is mainly used when a module only contains a single entity
   (even though it can be combined with named exports).

   .. code:: javascript

      //===== lib2a.mjs =====
      export default function getHello() {
      return 'hello';
      }

   A default export is the exception to the rule that function declarations always
   have names: In the previous example, we can omit the name ``getHello``.

   .. code:: javascript

      //===== lib2b.mjs =====
      export default 123; // (A) instead of `const`

   There can be at most one default export. Thatâ€™s why ``const`` or ``let`` canâ€™t
   be default-exported (line A).

   .. code:: javascript

      //===== main2.mjs =====
      import lib2a from './lib2a.mjs';
      assert.equal(lib2a(), 'hello');

      import lib2b from './lib2b.mjs';
      assert.equal(lib2b, 123);

29.1.4â€ƒKinds of module specifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   There are three kinds of module specifiers:

   -  *Absolute specifiers* are full URLs â€“Â for example:

      .. code:: javascript

         'https://www.unpkg.com/browse/yargs@17.3.1/browser.mjs'
         'file:///opt/nodejs/config.mjs'

      Absolute specifiers are mostly used to access libraries that are directly
      hosted on the web.

   -  *Relative specifiers* are relative URLs (starting with ``'/'``, ``'./'`` or
      ``'../'``) â€“ for example:

      .. code:: javascript

         './sibling-module.js'
         '../module-in-parent-dir.mjs'
         '../../dir/other-module.js'

      Relative specifiers are mostly used to access other modules within the same
      code base.

   -  *Bare specifiers* are paths (without protocol and domain) that start with
      neither slashes nor dots. They begin with the names of *packages* (as
      installed via a package manager such *npm*). Those names can optionally be
      followed by *subpaths*:

      .. code:: javascript

         'some-package'
         'some-package/sync'
         'some-package/util/files/path-tools.js'

      Bare specifiers can also refer to packages with scoped names:

      .. code:: javascript

         '@some-scope/scoped-name'
         '@some-scope/scoped-name/async'
         '@some-scope/scoped-name/dir/some-module.mjs'

      Each bare specifier refers to exactly one module inside a package; if it has
      no subpath, it refers to the designated â€œmainâ€ module of its package.

29.2â€ƒJavaScript source code formats
------------------------------------

   The current landscape of JavaScript modules is quite diverse: ES6 brought
   built-in modules, but the source code formats that came before them, are still
   around, too. Understanding the latter helps understand the former, so letâ€™s
   investigate. The next sections describe the following ways of delivering
   JavaScript source code:

   -  *Scripts* are code fragments that browsers run in global scope. They are
      precursors of modules.
   -  *CommonJS modules* are a module format that is mainly used on servers (e.g.,
      via Node.js).
   -  *AMD modules* are a module format that is mainly used in browsers.
   -  *ECMAScript modules* are JavaScriptâ€™s built-in module format. It supersedes
      all previous formats.

   `Table 29.1 <#tbl:source-code-formats>`__ gives an overview of these code
   formats. Note that for CommonJS modules and ECMAScript modules, two filename
   extensions are commonly used. Which one is appropriate depends on how we want to
   use a file. Details are given later in this chapter.

   =================  ====================  ======  ================
   \                  Runs on               Loaded  Filename ext.
   Script             browsers              async   ``.js``
   CommonJS module    servers               sync    ``.js`` ``.cjs``
   AMD module         browsers              async   ``.js``
   ECMAScript module  browsers and servers  async   ``.js`` ``.mjs``
   =================  ====================  ======  ================

   Table 29.1: Ways of delivering JavaScript source code.

29.2.1â€ƒCode before built-in modules was written in ECMAScript 5
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Before we get to built-in modules (which were introduced with ES6), all code
   that weâ€™ll see, will be written in ES5. Among other things:

   -  ES5 did not have ``const`` and ``let``, only ``var``.
   -  ES5 did not have arrow functions, only function expressions.



.. _scripts:

29.3â€ƒBefore we had modules, we had scripts
-------------------------------------------

   Initially, browsers only had *scripts* â€“ pieces of code that were executed in
   global scope. As an example, consider an HTML file that loads script files via
   the following HTML:

   .. code:: language-html

      <script src="other-module1.js"></script>
      <script src="other-module2.js"></script>
      <script src="my-module.js"></script>

   The main file is ``my-module.js``, where we simulate a module:

   .. code:: javascript

      var myModule = (function () { // Open IIFE
      // Imports (via global variables)
      var importedFunc1 = otherModule1.importedFunc1;
      var importedFunc2 = otherModule2.importedFunc2;

      // Body
      function internalFunc() {
         // Â·Â·Â·
      }
      function exportedFunc() {
         importedFunc1();
         importedFunc2();
         internalFunc();
      }

      // Exports (assigned to global variable `myModule`)
      return {
         exportedFunc: exportedFunc,
      };
      })(); // Close IIFE

   ``myModule`` is a global variable that is assigned the result of immediately
   invoking a function expression. The function expression starts in the first
   line. It is invoked in the last line.

   This way of wrapping a code fragment is called *immediately invoked function
   expression* (IIFE, coined by Ben Alman). What do we gain from an IIFE? ``var``
   is not block-scoped (like ``const`` and ``let``), it is function-scoped: the
   only way to create new scopes for ``var``-declared variables is via functions or
   methods (with ``const`` and ``let``, we can use either functions, methods, or
   blocks ``{}``). Therefore, the IIFE in the example hides all of the following
   variables from global scope and minimizes name clashes: ``importedFunc1``,
   ``importedFunc2``, ``internalFunc``, ``exportedFunc``.

   Note that we are using an IIFE in a particular manner: at the end, we pick what
   we want to export and return it via an object literal. That is called the
   *revealing module pattern* (coined by Christian Heilmann).

   This way of simulating modules, has several issues:

   -  Libraries in script files export and import functionality via global
      variables, which risks name clashes.
   -  Dependencies are not stated explicitly, and there is no built-in way for a
      script to load the scripts it depends on. Therefore, the web page has to load
      not just the scripts that are needed by the page but also the dependencies of
      those scripts, the dependenciesâ€™ dependencies, etc. And it has to do so in
      the right order!

29.4â€ƒModule systems created prior to ES6
-----------------------------------------

   Prior to ECMAScript 6, JavaScript did not have built-in modules. Therefore, the
   flexible syntax of the language was used to implement custom module systems
   *within* the language. Two popular ones are:

   -  CommonJS (targeting the server side)
   -  AMD (Asynchronous Module Definition, targeting the client side)

29.4.1â€ƒServer side: CommonJS modules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The original CommonJS standard for modules was created for server and desktop
   platforms. It was the foundation of the original Node.js module system, where it
   achieved enormous popularity. Contributing to that popularity were the npm
   package manager for Node and tools that enabled using Node modules on the client
   side (browserify, webpack, and others).

   From now on, *CommonJS module* means the Node.js version of this standard (which
   has a few additional features). This is an example of a CommonJS module:

   .. code:: javascript

      // Imports
      var importedFunc1 = require('./other-module1.js').importedFunc1;
      var importedFunc2 = require('./other-module2.js').importedFunc2;

      // Body
      function internalFunc() {
      // Â·Â·Â·
      }
      function exportedFunc() {
      importedFunc1();
      importedFunc2();
      internalFunc();
      }

      // Exports
      module.exports = {
      exportedFunc: exportedFunc,
      };

   CommonJS can be characterized as follows:

   -  Designed for servers.
   -  Modules are meant to be loaded *synchronously* (the importer waits while the
      imported module is loaded and executed).
   -  Compact syntax.

29.4.2â€ƒClient side: AMD (Asynchronous Module Definition) modules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The AMD module format was created to be easier to use in browsers than the
   CommonJS format. Its most popular implementation is
   `RequireJS <https://requirejs.org>`__. The following is an example of an AMD
   module.

   .. code:: javascript

      define(['./other-module1.js', './other-module2.js'],
      function (otherModule1, otherModule2) {
         var importedFunc1 = otherModule1.importedFunc1;
         var importedFunc2 = otherModule2.importedFunc2;

         function internalFunc() {
            // Â·Â·Â·
         }
         function exportedFunc() {
            importedFunc1();
            importedFunc2();
            internalFunc();
         }
         
         return {
            exportedFunc: exportedFunc,
         };
      });

   AMD can be characterized as follows:

   -  Designed for browsers.
   -  Modules are meant to be loaded *asynchronously*. Thatâ€™s a crucial requirement
      for browsers, where code canâ€™t wait until a module has finished downloading.
      It has to be notified once the module is available.
   -  The syntax is slightly more complicated.

   On the plus side, AMD modules can be executed directly. In contrast, CommonJS
   modules must either be compiled before deployment or custom source code must be
   generated and evaluated dynamically `(think
   ``eval()``) <#eval>`__. That isnâ€™t always
   permitted on the web.

29.4.3â€ƒCharacteristics of JavaScript modules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Looking at CommonJS and AMD, similarities between JavaScript module systems
   emerge:

   -  There is one module per file.
   -  Such a file is basically a piece of code that is executed:

      -  Local scope: The code is executed in a local â€œmodule scopeâ€. Therefore, by
         default, all of the variables, functions, and classes declared in it are
         internal and not global.
      -  Exports: If we want any declared entity to be exported, we must explicitly
         mark it as an export.
      -  Imports: Each module can import exported entities from other modules.
         Those other modules are identified via *module specifiers* (usually paths,
         occasionally full URLs).

   -  Modules are *singletons*: Even if a module is imported multiple times, only a
      single â€œinstanceâ€ of it exists.
   -  No global variables are used. Instead, module specifiers serve as global IDs.

29.5â€ƒECMAScript modules
------------------------

   *ECMAScript modules* (*ES modules* or *ESM*) were introduced with ES6. They
   continue the tradition of JavaScript modules and have all of their
   aforementioned characteristics. Additionally:

   -  With CommonJS, ES modules share the compact syntax and support for cyclic
      dependencies.
   -  With AMD, ES modules share being designed for asynchronous loading.

   ES modules also have new benefits:

   -  The syntax is even more compact than CommonJSâ€™s.
   -  Modules have *static* structures (which canâ€™t be changed at runtime). That
      helps with static checking, optimized access of imports, dead code
      elimination, and more.
   -  Support for cyclic imports is completely transparent.

   This is an example of ES module syntax:

   .. code:: javascript

      import {importedFunc1} from './other-module1.mjs';
      import {importedFunc2} from './other-module2.mjs';

      function internalFunc() {
      Â·Â·Â·
      }

      export function exportedFunc() {
      importedFunc1();
      importedFunc2();
      internalFunc();
      }

   From now on, â€œmoduleâ€ means â€œECMAScript moduleâ€.

29.5.1â€ƒES modules: syntax, semantics, loader API
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The full standard of ES modules comprises the following parts:

   #. Syntax (how code is written): What is a module? How are imports and exports
      declared? Etc.
   #. Semantics (how code is executed): How are variable bindings exported? How are
      imports connected with exports? Etc.
   #. A programmatic loader API for configuring module loading.

   Parts 1 and 2 were introduced with ES6. Work on part 3 is ongoing.

29.6â€ƒNamed exports and imports
-------------------------------

29.6.1â€ƒNamed exports
~~~~~~~~~~~~~~~~~~~~~

   Each module can have zero or more *named exports*.

   As an example, consider the following two files:

   .. code:: language-txt

      lib/my-math.mjs
      main.mjs

   Module ``my-math.mjs`` has two named exports: ``square`` and ``LIGHTSPEED``.

   .. code:: javascript

      // Not exported, private to module
      function times(a, b) {
      return a * b;
      }
      export function square(x) {
      return times(x, x);
      }
      export const LIGHTSPEED = 299792458;

   To export something, we put the keyword ``export`` in front of a declaration.
   Entities that are not exported are private to a module and canâ€™t be accessed
   from outside.

29.6.2â€ƒNamed imports
~~~~~~~~~~~~~~~~~~~~~

   Module ``main.mjs`` has a single named import, ``square``:

   .. code:: javascript

      import {square} from './lib/my-math.mjs';
      assert.equal(square(3), 9);

   It can also rename its import:

   .. code:: javascript

      import {square as sq} from './lib/my-math.mjs';
      assert.equal(sq(3), 9);

29.6.2.1â€ƒSyntactic pitfall: named importing is not destructuring
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Both named importing and destructuring look similar:

   .. code:: javascript

      import {foo} from './bar.mjs'; // import
      const {foo} = require('./bar.mjs'); // destructuring

   But they are quite different:

   -  Imports remain connected with their exports.

   -  We can destructure again inside a destructuring pattern, but the ``{}`` in an
      import statement canâ€™t be nested.

   -  The syntax for renaming is different:

      .. code:: javascript

         import {foo as f} from './bar.mjs'; // importing
         const {foo: f} = require('./bar.mjs'); // destructuring

      Rationale: Destructuring is reminiscent of an object literal (including
      nesting), while importing evokes the idea of renaming.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Named exports**

      .. container:: boxout-vspace

      ``exercises/modules/export_named_test.mjs``

29.6.3â€ƒNamespace imports
~~~~~~~~~~~~~~~~~~~~~~~~~

   *Namespace imports* are an alternative to named imports. If we namespace-import
   a module, it becomes an object whose properties are the named exports. This is
   what ``main.mjs`` looks like if we use a namespace import:

   .. code:: javascript

      import * as myMath from './lib/my-math.mjs';
      assert.equal(myMath.square(3), 9);

      assert.deepEqual(
      Object.keys(myMath), ['LIGHTSPEED', 'square']);



.. _named-exporting-styles-inline-versus-clause:

29.6.4â€ƒNamed exporting styles: inline versus clause (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The named export style we have seen so far was *inline*: We exported entities by
   prefixing them with the keyword ``export``.

   But we can also use separate *export clauses*. For example, this is what
   ``lib/my-math.mjs`` looks like with an export clause:

   .. code:: javascript

      function times(a, b) {
      return a * b;
      }
      function square(x) {
      return times(x, x);
      }
      const LIGHTSPEED = 299792458;

      export { square, LIGHTSPEED }; // semicolon!

   With an export clause, we can rename before exporting and use different names
   internally:

   .. code:: javascript

      function times(a, b) {
      return a * b;
      }
      function sq(x) {
      return times(x, x);
      }
      const LS = 299792458;

      export {
      sq as square,
      LS as LIGHTSPEED, // trailing comma is optional
      };



.. _default-exports-and-imports-1:

29.7â€ƒDefault exports and imports
---------------------------------

   Each module can have at most one *default export*. The idea is that the module
   *is* the default-exported value.

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Avoid mixing named exports and default exports**

      .. container:: boxout-vspace

      A module can have both named exports and a default export, but itâ€™s usually
      better to stick to one export style per module.

   As an example for default exports, consider the following two files:

   .. code:: language-txt

      my-func.mjs
      main.mjs

   Module ``my-func.mjs`` has a default export:

   .. code:: javascript

      const GREETING = 'Hello!';
      export default function () {
      return GREETING;
      }

   Module ``main.mjs`` default-imports the exported function:

   .. code:: javascript

      import myFunc from './my-func.mjs';
      assert.equal(myFunc(), 'Hello!');

   Note the syntactic difference: the curly braces around named imports indicate
   that we are reaching *into* the module, while a default import *is* the module.

   .. container:: boxout

      |Icon â€œquestionâ€|â€‚**What are use cases for default exports?**

      .. container:: boxout-vspace

      The most common use case for a default export is a module that contains a
      single function or a single class.

29.7.1â€ƒThe two styles of default-exporting
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   There are two styles of doing default exports.

   First, we can label existing declarations with ``export default``:

   .. code:: javascript

      export default function myFunc() {} // no semicolon!
      export default class MyClass {} // no semicolon!

   Second, we can directly default-export values. This style of ``export default``
   is much like a declaration.

   .. code:: javascript

      export default myFunc; // defined elsewhere
      export default MyClass; // defined previously
      export default Math.sqrt(2); // result of invocation is default-exported
      export default 'abc' + 'def';
      export default { no: false, yes: true };

29.7.1.1â€ƒWhy are there two default export styles?
''''''''''''''''''''''''''''''''''''''''''''''''''

   The reason is that ``export default`` canâ€™t be used to label ``const``:
   ``const`` may define multiple values, but ``export default`` needs exactly one
   value. Consider the following hypothetical code:

   .. code:: javascript

      // Not legal JavaScript!
      export default const foo = 1, bar = 2, baz = 3;

   With this code, we donâ€™t know which one of the three values is the default
   export.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Default exports**

      .. container:: boxout-vspace

      ``exercises/modules/export_default_test.mjs``



.. _the-default-export-as-a-named-export:

29.7.2â€ƒThe default export as a named export (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Internally, a default export is simply a named export whose name is ``default``.
   As an example, consider the previous module ``my-func.mjs`` with a default
   export:

   .. code:: javascript

      const GREETING = 'Hello!';
      export default function () {
      return GREETING;
      }

   The following module ``my-func2.mjs`` is equivalent to that module:

   .. code:: javascript

      const GREETING = 'Hello!';
      function greet() {
      return GREETING;
      }

      export {
      greet as default,
      };

   For importing, we can use a normal default import:

   .. code:: javascript

      import myFunc from './my-func2.mjs';
      assert.equal(myFunc(), 'Hello!');

   Or we can use a named import:

   .. code:: javascript

      import {default as myFunc} from './my-func2.mjs';
      assert.equal(myFunc(), 'Hello!');

   The default export is also available via property ``.default`` of namespace
   imports:

   .. code:: javascript

      import * as mf from './my-func2.mjs';
      assert.equal(mf.default(), 'Hello!');

   .. container:: boxout

      |Icon â€œquestionâ€|â€‚**Isnâ€™t ``default`` illegal as a variable name?**

      .. container:: boxout-vspace

      ``default`` canâ€™t be a variable name, but it can be an export name and it can
      be a property name:

      .. code:: javascript

         const obj = {
         default: 123,
         };
         assert.equal(obj.default, 123);

29.8â€ƒRe-exporting
------------------

   A module ``library.mjs`` can export one or more exports of another module
   ``internal.mjs`` as if it had made them itself. That is called *re-exporting*.

   .. code:: javascript

      //===== internal.mjs =====
      export function internalFunc() {}
      export const INTERNAL_DEF = 'hello';
      export default 123;

   .. code:: javascript

      //===== library.mjs =====
      // Named re-export [ES6]
      export {internalFunc as func, INTERNAL_DEF as DEF} from './internal.mjs';
      // Wildcard re-export [ES6]
      export * from './internal.mjs';
      // Namespace re-export [ES2020]
      export * as ns from './internal.mjs';

   -  The wildcard re-export turns all exports of module ``internal.mjs`` into
      exports of ``library.mjs``, except the default export.
   -  The namespace re-export turns all exports of module ``internal.mjs`` into an
      object that becomes the named export ``ns`` of ``library.mjs``. Because
      ``internal.mjs`` has a default export, ``ns`` has a property ``.default``.

   The following code demonstrates the two bullet points above:

   .. code:: javascript

      //===== main.mjs =====
      import * as library from './library.mjs';

      assert.deepEqual(
      Object.keys(library),
      ['DEF', 'INTERNAL_DEF', 'func', 'internalFunc', 'ns']
      );
      assert.deepEqual(
      Object.keys(library.ns),
      ['INTERNAL_DEF', 'default', 'internalFunc']
      );

29.9â€ƒMore details on exporting and importing
---------------------------------------------

29.9.1â€ƒImports are read-only views on exports
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   So far, we have used imports and exports intuitively, and everything seems to
   have worked as expected. But now it is time to take a closer look at how imports
   and exports are really related.

   Consider the following two modules:

   .. code:: language-txt

      counter.mjs
      main.mjs

   ``counter.mjs`` exports a (mutable!) variable and a function:

   .. code:: javascript

      export let counter = 3;
      export function incCounter() {
      counter++;
      }

   ``main.mjs`` name-imports both exports. When we use ``incCounter()``, we
   discover that the connection to ``counter`` is live â€“ we can always access the
   live state of that variable:

   .. code:: javascript

      import { counter, incCounter } from './counter.mjs';

      // The imported value `counter` is live
      assert.equal(counter, 3);
      incCounter();
      assert.equal(counter, 4);

   Note that while the connection is live and we can read ``counter``, we cannot
   change this variable (e.g., via ``counter++``).

   There are two benefits to handling imports this way:

   -  It is easier to split modules because previously shared variables can become
      exports.
   -  This behavior is crucial for supporting transparent cyclic imports. Read on
      for more information.



.. _esm-s-transparent-support-for-cyclic-imports:

29.9.2â€ƒESMâ€™s transparent support for cyclic imports (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ESM supports cyclic imports transparently. To understand how that is achieved,
   consider the following example: `figure 29.1 <#fig:module-imports>`__ shows a
   directed graph of modules importing other modules. P importing M is the cycle in
   this case.

   .. figure:: https://exploringjs.com/js/book/img-book/modules/module-imports.svg
      name: fig:module-imports
      :width: 174px
      :height: 140px

      Figure 29.1: A directed graph of modules importing modules: M imports N and
      O, N imports P and Q, etc.

   After parsing, these modules are set up in two phases:

   -  Instantiation: Every module is visited and its imports are connected to its
      exports. Before a parent can be instantiated, all of its children must be
      instantiated.
   -  Evaluation: The bodies of the modules are executed. Once again, children are
      evaluated before parents.

   This approach handles cyclic imports correctly, due to two features of ES
   modules:

   -  Due to the static structure of ES modules, the exports are already known
      after parsing. That makes it possible to instantiate P before its child M: P
      can already look up Mâ€™s exports.

   -  When P is evaluated, M hasnâ€™t been evaluated, yet. However, entities in P can
      already mention imports from M. They just canâ€™t use them, yet, because the
      imported values are filled in later. For example, a function in P can access
      an import from M. The only limitation is that we must wait until after the
      evaluation of M, before calling that function.

      Imports being filled in later is enabled by them being â€œlive immutable viewsâ€
      on exports.

29.10â€ƒnpm packages
-------------------

   The *npm software registry* is the dominant way of distributing JavaScript
   libraries and apps for Node.js and web browsers. It is managed via the *npm
   package manager* (short: *npm*). Software is distributed as so-called
   *packages*. A package is a directory containing arbitrary files and a file
   ``package.json`` at the top level that describes the package. For example, when
   npm creates an empty package inside a directory ``my-package/``, we get this
   ``package.json``:

   .. code:: javascripton

      {
      "name": "my-package",
      "version": "1.0.0",
      "description": "",
      "main": "index.js",
      "scripts": {
         "test": "echo \"Error: no test specified\" && exit 1"
      },
      "keywords": [],
      "author": "",
      "license": "ISC"
      }

   Some of these properties contain simple metadata:

   -  ``name`` specifies the name of this package. Once it is uploaded to the npm
      registry, it can be installed via ``npm install my-package``.
   -  ``version`` is used for version management and follows `semantic
      versioning <https://semver.org>`__, with three numbers:

      -  Major version: is incremented when incompatible API changes are made.
      -  Minor version: is incremented when functionality is added in a backward
         compatible manner.
      -  Patch version: is incremented when backward compatible changes are made.

   -  ``description``, ``keywords``, ``author`` make it easier to find packages.
   -  ``license`` clarifies how we can use this package.

   Other properties enable advanced configuration:

   -  ``main``: specifies the module that â€œisâ€ the package (explained later in this
      chapter).
   -  ``scripts``: are commands that we can execute via ``npm run``. For example,
      the script ``test`` can be executed via ``npm run test``.

   For more information on ``package.json``, consult `the npm
   documentation <https://docs.npmjs.com/cli/v10/configuring-npm/package-json>`__.



.. _packages-are-installed-inside-a-directory-node-modules:

29.10.1â€ƒPackages are installed inside a directory ``node_modules/``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   npm always installs packages inside a directory ``node_modules``. There are
   usually many of these directories. Which one npm uses, depends on the directory
   where one currently is. For example, if we are inside a directory ``/tmp/a/b/``,
   npm tries to find a ``node_modules`` in the current directory, its parent
   directory, the parent directory of the parent, etc. In other words, it searches
   the following *chain* of locations:

   -  ``/tmp/a/b/node_modules``
   -  ``/tmp/a/node_modules``
   -  ``/tmp/node_modules``

   When installing a package ``some-pkg``, npm uses the closest ``node_modules``.
   If, for example, we are inside ``/tmp/a/b/`` and there is a ``node_modules`` in
   that directory, then npm puts the package inside the directory:

   .. code:: language-txt

      /tmp/a/b/node_modules/some-pkg/

   When importing a module, we can use a special module specifier to tell Node.js
   that we want to import it from an installed package. How exactly that works, is
   explained later. For now, consider the following example:

   .. code:: javascript

      // /home/jane/proj/main.mjs
      import * as theModule from 'the-package/the-module.mjs';

   To find ``the-module.mjs`` (Node.js prefers the filename extension ``.mjs`` for
   ES modules), Node.js walks up the ``node_module`` chain and searches the
   following locations:

   -  ``/home/jane/proj/node_modules/the-package/the-module.mjs``
   -  ``/home/jane/node_modules/the-package/the-module.mjs``
   -  ``/home/node_modules/the-package/the-module.mjs``

29.10.2â€ƒWhy can npm be used to install frontend libraries?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Finding installed modules in ``node_modules`` directories is only supported on
   Node.js. So why can we also use npm to install libraries for browsers?

   That is enabled via `bundling tools <#bundler>`__, such as
   webpack, that compile and optimize code before it is deployed online. During
   this compilation process, the code in npm packages is adapted so that it works
   in browsers.

29.11â€ƒNaming modules
---------------------

   There are no established best practices for naming module files and the
   variables they are imported into.

   In this chapter, Iâ€™m using the following naming style:

   -  The names of module files are dash-cased and start with lowercase letters:

      .. code:: language-txt

         ./my-module.mjs
         ./some-func.mjs

   -  The names of namespace imports are lowercased and camel-cased:

      .. code:: javascript

         import * as myModule from './my-module.mjs';

   -  The names of default imports are lowercased and camel-cased:

      .. code:: javascript

         import someFunc from './some-func.mjs';

   What are the rationales behind this style?

   -  npm doesnâ€™t allow uppercase letters in package names
      (`source <https://docs.npmjs.com/cli/v10/configuring-npm/package-json#name>`__).
      Thus, we avoid camel case, so that â€œlocalâ€ files have names that are
      consistent with those of npm packages. Using only lowercase letters also
      minimizes conflicts between file systems that are case-sensitive and file
      systems that arenâ€™t: the former distinguish files whose names have the same
      letters, but with different cases; the latter donâ€™t.

   -  There are clear rules for translating dash-cased file names to camel-cased
      JavaScript variable names. Due to how we name namespace imports, these rules
      work for both namespace imports and default imports.

   I also like underscore-cased module file names because we can directly use these
   names for namespace imports (without any translation):

   .. code:: javascript

      import * as my_module from './my_module.mjs';

   But that style does not work for default imports: I like underscore-casing for
   namespace objects, but it is not a good choice for functions, etc.

29.12â€ƒModule specifiers
------------------------

   *Module specifiers* are the strings that identify modules. They work slightly
   differently in browsers and Node.js. Before we can look at the differences, we
   need to learn about the different categories of module specifiers.

29.12.1â€ƒCategories of module specifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In ES modules, we distinguish the following categories of specifiers. These
   categories originated with CommonJS modules.

   -  Relative path: starts with a dot. Examples:

      .. code:: language-txt

         './some/other/module.mjs'
         '../../lib/counter.mjs'

   -  Absolute path: starts with a slash. Example:

      .. code:: language-txt

         '/home/jane/file-tools.mjs'

   -  URL: includes a protocol (technically, paths are URLs, too). Examples:

      .. code:: language-txt

         'https://example.com/some-module.mjs'
         'file:///home/john/tmp/main.mjs'

   -  Bare path: does not start with a dot, a slash or a protocol, and consists of
      a single filename without an extension. Examples:

      .. code:: language-txt

         'lodash'
         'the-package'

   -  Deep import path: starts with a bare path and has at least one slash.
      Example:

      .. code:: language-txt

         'the-package/dist/the-module.mjs'

29.12.2â€ƒES module specifiers in browsers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Browsers handle module specifiers as follows:

   -  Relative paths, absolute paths, and URLs work as expected. They all must
      point to real files (in contrast to CommonJS, which lets us omit filename
      extensions and more).
   -  The file name extensions of modules donâ€™t matter, as long as they are served
      with the content type ``text/javascript``.
   -  How bare paths will end up being handled is not yet clear. We will probably
      eventually be able to map them to other specifiers via lookup tables.

   Note that `bundling tools <#bundler>`__ such as webpack, which
   combine modules into fewer files, are often less strict with specifiers than
   browsers. Thatâ€™s because they operate at build/compile time (not at runtime) and
   can search for files by traversing the file system.



.. _es-module-specifiers-on-node-js:

29.12.3â€ƒES module specifiers on Node.js
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Node.js handles module specifiers as follows:

   -  Relative paths are resolved as they are in web browsers â€“ relative to the
      path of the current module.

   -  Absolute paths are currently not supported. As a workaround, we can use URLs
      that start with ``file:///``. We can create such URLs via
      `url.pathToFileURL() <#converting-urls-paths>`__.

   -  Only ``file:`` is supported as a protocol for URL specifiers.

   -  A bare path is interpreted as a package name and resolved relative to the
      closest ``node_modules`` directory. What module should be loaded, is
      determined by looking at property ``"main"`` of the packageâ€™s
      ``package.json`` (similarly to CommonJS).

   -  Deep import paths are also resolved relatively to the closest
      ``node_modules`` directory. They contain file names, so it is always clear
      which module is meant.

   All specifiers, except bare paths, must refer to actual files. That is, ESM does
   not support the following CommonJS features:

   -  CommonJS automatically adds missing filename extensions.

   -  CommonJS can import a directory ``dir`` if there is a ``dir/package.json``
      with a ``"main"`` property.

   -  CommonJS can import a directory ``dir`` if there is a module
      ``dir/index.js``.

   All built-in Node.js modules are available via bare paths and have named ESM
   exports â€“ for example:

   .. code:: javascript

      import assert from 'node:assert/strict';
      import * as path from 'node:path';

      assert.equal(
      path.join('a/b/c', '../d'), 'a/b/d');



.. _filename-extensions-on-node-js:

29.12.3.1â€ƒFilename extensions on Node.js
'''''''''''''''''''''''''''''''''''''''''

   Node.js supports the following default filename extensions:

   -  ``.mjs`` for ES modules
   -  ``.cjs`` for CommonJS modules

   The filename extension ``.js`` stands for either ESM or CommonJS. Which one it
   is is configured via the â€œclosestâ€ ``package.json`` (in the current directory,
   the parent directory, etc.). Using ``package.json`` in this manner is
   independent of packages.

   In that ``package.json``, there is a property ``"type"``, which has two
   settings:

   -  ``"commonjs"`` (the default): files with the extension ``.js`` or without an
      extension are interpreted as CommonJS modules.

   -  ``"module"``: files with the extension ``.js`` or without an extension are
      interpreted as ESM modules.

29.12.3.2â€ƒInterpreting non-file source code as either CommonJS or ESM
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Not all source code executed by Node.js comes from files. We can also send it
   code via stdin, ``--eval``, and ``--print``. The command line option
   ``--input-type`` lets us specify how such code is interpreted:

   -  As CommonJS (the default): ``--input-type=commonjs``
   -  As ESM: ``--input-type=module``



.. _import.meta:

29.13â€ƒ``import.meta`` â€“ metadata for the current module [ES2020]
-----------------------------------------------------------------

   The object ``import.meta`` holds metadata for the current module.

29.13.1â€ƒ``import.meta.url``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The most important property of ``import.meta`` is ``.url`` which contains a
   string with the URL of the current moduleâ€™s file â€“ for example:

   .. code:: language-txt

      'https://example.com/code/main.mjs'



.. _import-meta-url-and-class-url:

29.13.2â€ƒ``import.meta.url`` and class ``URL``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Class ``URL`` is available via a global variable in browsers and on Node.js. We
   can look up its full functionality in `the Node.js
   documentation <https://nodejs.org/api/url.html#url_class_url>`__. When working
   with ``import.meta.url``, its constructor is especially useful:

   .. code:: javascript
      :name: language-ts

      new URL(input: string, base?: string|URL)

   Parameter ``input`` contains the URL to be parsed. It can be relative if the
   second parameter, ``base``, is provided.

   In other words, this constructor lets us resolve a relative path against a base
   URL:

   .. code:: javascript
      :name: language-node-repl

      > new URL('other.mjs', 'https://example.com/code/main.mjs').href
      'https://example.com/code/other.mjs'
      > new URL('../other.mjs', 'https://example.com/code/main.mjs').href
      'https://example.com/other.mjs'

   This is how we get a ``URL`` instance that points to a file ``data.txt`` that
   sits next to the current module:

   .. code:: javascript

      const urlOfData = new URL('data.txt', import.meta.url);



.. _import-meta-url-on-node-js:

29.13.3â€ƒ``import.meta.url`` on Node.js
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   On Node.js, ``import.meta.url`` is always a string with a ``file:`` URL â€“ for
   example:

   .. code:: language-txt

      'file:///Users/rauschma/my-module.mjs'

29.13.3.1â€ƒExample: reading a sibling file of a module
''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Many Node.js file system operations accept either strings with paths or
   instances of ``URL``. That enables us to read a sibling file ``data.txt`` of the
   current module:

   .. code:: javascript

      import * as fs from 'node:fs';
      function readData() {
      // data.txt sits next to current module
      const urlOfData = new URL('data.txt', import.meta.url);
      return fs.readFileSync(urlOfData, {encoding: 'UTF-8'});
      }

29.13.3.2â€ƒModule ``fs`` and URLs
'''''''''''''''''''''''''''''''''

   For most functions of the module ``fs``, we can refer to files via:

   -  Paths â€“ in strings or instances of ``Buffer``.
   -  URLs â€“ in instances of ``URL`` (with the protocol ``file:``)

   For more information on this topic, see `the Node.js API
   documentation <https://nodejs.org/api/fs.html#fs_file_paths>`__.



.. _converting-urls-paths:

29.13.3.3â€ƒConverting between ``file:`` URLs and paths
''''''''''''''''''''''''''''''''''''''''''''''''''''''

   `The Node.js module ``url <https://nodejs.org/api/url.html>`__ has two
   functions for converting between ``file:`` URLs and paths:

   -  ``fileURLToPath(url: URL|string): string``
      Converts a ``file:`` URL to a path.
   -  ``pathToFileURL(path: string): URL``
      Converts a path to a ``file:`` URL.

   If we need a path that can be used in the local file system, then property
   ``.pathname`` of ``URL`` instances does not always work:

   .. code:: javascript

      assert.equal(
      new URL('file:///tmp/with%20space.txt').pathname,
      '/tmp/with%20space.txt');

   Therefore, it is better to use ``fileURLToPath()``:

   .. code:: javascript

      import * as url from 'node:url';
      assert.equal(
      url.fileURLToPath('file:///tmp/with%20space.txt'),
      '/tmp/with space.txt'); // result on Unix

   Similarly, ``pathToFileURL()`` does more than just prepend ``'file://'`` to an
   absolute path.



.. _dynamic-imports:

29.14â€ƒLoading modules dynamically via ``import()`` [ES2020] (advanced)
-----------------------------------------------------------------------

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**The ``import()`` operator uses Promises**

      .. container:: boxout-vspace

      Promises are a technique for handling results that are computed
      asynchronously (i.e., not immediately). They are explained in `â€œPromises for
      asynchronous programmingâ€ (Â§42) <#ch_promises>`__. It may
      make sense to postpone reading this section until you understand them.

29.14.1â€ƒThe limitations of static ``import`` statements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   So far, the only way to import a module has been via an ``import`` statement.
   That statement has several limitations:

   -  We must use it at the top level of a module. That is, we canâ€™t, for example,
      import something when we are inside a function or inside an ``if`` statement.
   -  The module specifier is always fixed. That is, we canâ€™t change what we import
      depending on a condition. And we canâ€™t assemble a specifier dynamically.

29.14.2â€ƒDynamic imports via the ``import()`` operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The ``import()`` operator doesnâ€™t have the limitations of ``import`` statements.
   It looks like this:

   .. code:: javascript

      import(moduleSpecifierStr)
      .then((namespaceObject) => {
      console.log(namespaceObject.namedExport);
      });

   This operator is used like a function, receives a string with a module specifier
   and returns a Promise that resolves to a namespace object. The properties of
   that object are the exports of the imported module.

   ``import()`` is even more convenient to use via
   `await <#ch_async-functions>`__:

   .. code:: javascript

      const namespaceObject = await import(moduleSpecifierStr);
      console.log(namespaceObject.namedExport);

   Note that ``await`` can be used at the top levels of modules (see `next
   section <#top-level-await>`__).

   Letâ€™s look at an example of using ``import()``.

29.14.2.1â€ƒExample: loading a module dynamically
''''''''''''''''''''''''''''''''''''''''''''''''

   Consider the following files:

   .. code:: language-txt

      lib/my-math.mjs
      main1.mjs
      main2.mjs

   We have already seen module ``my-math.mjs``:

   .. code:: javascript

      // Not exported, private to module
      function times(a, b) {
      return a * b;
      }
      export function square(x) {
      return times(x, x);
      }
      export const LIGHTSPEED = 299792458;

   We can use ``import()`` to load this module on demand:

   .. code:: javascript

      // main1.mjs
      const moduleSpecifier = './lib/my-math.mjs';

      function mathOnDemand() {
      return import(moduleSpecifier)
      .then(myMath => {
         const result = myMath.LIGHTSPEED;
         assert.equal(result, 299792458);
         return result;
      });
      }

      await mathOnDemand()
      .then((result) => {
      assert.equal(result, 299792458);
      });

   Two things in this code canâ€™t be done with ``import`` statements:

   -  We are importing inside a function (not at the top level).
   -  The module specifier comes from a variable.

   Next, weâ€™ll implement the same functionality as in ``main1.mjs`` but via a
   feature called `async function or
   async/await <#ch_async-functions>`__ which provides nicer
   syntax for Promises.

   .. code:: javascript

      // main2.mjs
      const moduleSpecifier = './lib/my-math.mjs';

      async function mathOnDemand() {
      const myMath = await import(moduleSpecifier);
      const result = myMath.LIGHTSPEED;
      assert.equal(result, 299792458);
      return result;
      }

   .. container:: boxout

      |Icon â€œquestionâ€|â€‚**Why is ``import()`` an operator and not a function?**

      .. container:: boxout-vspace

      ``import()`` looks like a function but couldnâ€™t be implemented as a function:

      -  It needs to know the URL of the current module in order to resolve
         relative module specifiers.
      -  If ``import()`` were a function, weâ€™d have to explicitly pass this
         information to it (e.g. via an parameter).
      -  In contrast, an operator is a core language construct and has implicit
         access to more data, including the URL of the current module.

29.14.3â€ƒUse cases for ``import()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

29.14.3.1â€ƒLoading code on demand
'''''''''''''''''''''''''''''''''

   Some functionality of web apps doesnâ€™t have to be present when they start, it
   can be loaded on demand. Then ``import()`` helps because we can put such
   functionality into modules â€“ for example:

   .. code:: javascript

      button.addEventListener('click', event => {
      import('./dialogBox.mjs')
         .then(dialogBox => {
            dialogBox.open();
         })
         .catch(error => {
            /* Error handling */
         })
      });

29.14.3.2â€ƒConditional loading of modules
'''''''''''''''''''''''''''''''''''''''''

   We may want to load a module depending on whether a condition is true. For
   example, a module with `a polyfill <#polyfills>`__ that makes a new feature
   available on legacy platforms:

   .. code:: javascript

      if (isLegacyPlatform()) {
      import('./my-polyfill.mjs')
         .then(Â·Â·Â·);
      }

29.14.3.3â€ƒComputed module specifiers
'''''''''''''''''''''''''''''''''''''

   For applications such as internationalization, it helps if we can dynamically
   compute module specifiers:

   .. code:: javascript

      import(`messages_${getLocale()}.mjs`)
      .then(Â·Â·Â·);



.. _top-level-await:

29.15â€ƒTop-level ``await`` in modules [ES2022] (advanced)
---------------------------------------------------------

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**``await`` is a feature of async functions**

      .. container:: boxout-vspace

      ``await`` is explained in `â€œAsync functionsâ€
      (Â§43) <#ch_async-functions>`__. It may make sense to
      postpone reading this section until you understand async functions.

   We can use the ``await`` operator at the top level of a module. If we do that,
   the module becomes asynchronous and works differently. Thankfully, we donâ€™t
   usually see that as programmers because it is handled transparently by the
   language.

29.15.1â€ƒUse cases for top-level ``await``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Why would we want to use the ``await`` operator at the top level of a module? It
   lets us initialize a module with asynchronously loaded data. The next three
   subsections show three examples of where that is useful.

29.15.1.1â€ƒLoading modules dynamically
''''''''''''''''''''''''''''''''''''''

   .. code:: javascript

      const params = new URLSearchParams(location.search);
      const language = params.get('lang');
      const messages = await import(`./messages-${language}.mjs`); // (A)

      console.log(messages.welcome);

   In line A, we `dynamically import <#dynamic-imports>`__ a module. Thanks to
   top-level ``await``, that is almost as convenient as using a normal, static
   import.

29.15.1.2â€ƒUsing a fallback if module loading fails
'''''''''''''''''''''''''''''''''''''''''''''''''''

   .. code:: javascript

      let mylib;
      try {
      mylib = await import('https://primary.example.com/mylib');
      } catch {
      mylib = await import('https://secondary.example.com/mylib');
      }

29.15.1.3â€ƒUsing whichever resource loads fastest
'''''''''''''''''''''''''''''''''''''''''''''''''

   .. code:: javascript

      const resource = await Promise.any([
      fetch('http://example.com/first.txt')
         .then(response => response.text()),
      fetch('http://example.com/second.txt')
         .then(response => response.text()),
      ]);

   Due to `Promise.any() <#Promise.any>`__, variable
   ``resource`` is initialized via whichever download finishes first.

29.15.2â€ƒHow does top-level ``await`` work under the hood?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Consider the following two files.

   ``first.mjs``:

   .. code:: javascript

      const response = await fetch('http://example.com/first.txt');
      export const first = await response.text();

   ``main.mjs``:

   .. code:: javascript

      import {first} from './first.mjs';
      import {second} from './second.mjs';
      assert.equal(first, 'First!');
      assert.equal(second, 'Second!');

   Both are roughly equivalent to the following code:

   ``first.mjs``:

   .. code:: javascript

      export let first;
      export const promise = (async () => { // (A)
      const response = await fetch('http://example.com/first.txt');
      first = await response.text();
      })();

   ``main.mjs``:

   .. code:: javascript

      import {promise as firstPromise, first} from './first.mjs';
      import {promise as secondPromise, second} from './second.mjs';
      export const promise = (async () => { // (B)
      await Promise.all([firstPromise, secondPromise]); // (C)
      assert.equal(first, 'First!');
      assert.equal(second, 'Second!');
      })();

   A module becomes asynchronous if:

   #. It directly uses top-level ``await`` (``first.mjs``).
   #. It imports one or more asynchronous modules (``main.mjs``).

   Each asynchronous module exports a Promise (line A and line B) that is fulfilled
   after its body was executed. At that point, it is safe to access the exports of
   that module.

   In case (2), the importing module waits until the Promises of all imported
   asynchronous modules are fulfilled, before it enters its body (line C).
   Synchronous modules are handled as usually.

   Awaited rejections and synchronous exceptions are managed as in async functions.

29.15.3â€ƒThe pros and cons of top-level ``await``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The two most important benefits of top-level ``await`` are:

   -  It ensures that modules donâ€™t access asynchronous imports before they are
      fully initialized.
   -  It handles asynchronicity transparently: Importers do not need to know if an
      imported module is asynchronous or not.

   On the downside, top-level ``await`` delays the initialization of importing
   modules. Therefore, itâ€™s best used sparingly. Asynchronous tasks that take
   longer are better performed later, on demand.

   However, even modules without top-level ``await`` can block importers (e.g. via
   an infinite loop at the top level), so blocking per se is not an argument
   against it.



.. _polyfills:

29.16â€ƒPolyfills: emulating native web platform features (advanced)
-------------------------------------------------------------------

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Backends have polyfills, too**

      .. container:: boxout-vspace

      This section is about frontend development and web browsers, but similar
      ideas apply to backend development.

   *Polyfills* help with a conflict that we are facing when developing a web
   application in JavaScript:

   -  On one hand, we want to use modern web platform features that make the app
      better and/or development easier.
   -  On the other hand, the app should run on as many browsers as possible.

   Given a web platform feature X:

   -  A *polyfill* for X is a piece of code. If it is executed on a platform that
      already has built-in support for X, it does nothing. Otherwise, it makes the
      feature available on the platform. In the latter case, the polyfilled feature
      is (mostly) indistinguishable from a native implementation. In order to
      achieve that, the polyfill usually makes global changes. For example, it may
      modify global data or configure a global module loader. Polyfills are often
      packaged as modules.

      -  The term
         `polyfill <https://remysharp.com/2010/10/08/what-is-a-polyfill>`__ was
         coined by Remy Sharp.

   -  A *speculative polyfill* is a polyfill for a proposed web platform feature
      (that is not standardized, yet).

      -  Alternative term: *prollyfill*

   -  A *replica* of X is a library that reproduces the API and functionality of X
      locally. Such a library exists independently of a native (and global)
      implementation of X.

      -  *Replica* is a new term introduced in this section. Alternative term:
         *ponyfill*

   -  There is also the term *shim*, but it doesnâ€™t have a universally agreed upon
      definition. It often means roughly the same as *polyfill*.

   Every time our web applications starts, it must first execute all polyfills for
   features that may not be available everywhere. Afterwards, we can be sure that
   those features are available natively.

29.16.1â€ƒSources of this section
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `â€œWhat is a
      Polyfill?â€ <https://remysharp.com/2010/10/08/what-is-a-polyfill>`__ by Remy
      Sharp
   -  Inspiration for the term *replica*: `The Eiffel Tower in Las
      Vegas <https://en.wikipedia.org/wiki/Paris_Las_Vegas>`__
   -  Useful clarification of â€œpolyfillâ€ and related terms: `â€œPolyfills and the
      evolution of the Webâ€ <https://www.w3.org/2001/tag/doc/polyfills/>`__. Edited
      by Andrew Betts.

   `Comments <https://github.com/rauschma/exploring-js/issues/20>`__



.. _ch_objects:

30â€ƒObjects
===========

   #. `30.1â€ƒCheat sheet: objects <#cheat-sheet-objects>`__

      #. `30.1.1â€ƒCheat sheet: single objects <#cheat-sheet-single-objects>`__
      #. `30.1.2â€ƒCheat sheet: prototype chains <#cheat-sheet-prototype-chains>`__

   #. `30.2â€ƒWhat is an object? <#what-is-an-object>`__

      #. `30.2.1â€ƒThe two ways of using objects <#ways-of-using-objects>`__

   #. `30.3â€ƒFixed-layout objects <#fixed-layout-objects>`__

      #. `30.3.1â€ƒObject literals: properties <#object-literals>`__
      #. `30.3.2â€ƒObject literals: property value shorthands <#object-literals-property-value-shorthands>`__
      #. `30.3.3â€ƒGetting properties <#getting-properties>`__
      #. `30.3.4â€ƒSetting properties <#setting-properties>`__
      #. `30.3.5â€ƒObject literals: methods <#object-literals-methods>`__
      #. `30.3.6â€ƒObject literals: accessors <#object-literal-accessors>`__

   #. `30.4â€ƒSpreading into object literals (...) [ES2018] <#spreading-into-object-literals>`__

      #. `30.4.1â€ƒUse case for spreading: copying objects <#use-case-for-spreading-copying-objects>`__
      #. `30.4.2â€ƒUse case for spreading: default values for missing properties <#use-case-for-spreading-default-values-for-missing-properties>`__
      #. `30.4.3â€ƒUse case for spreading: non-destructively changing properties <#use-case-for-spreading-non-destructively-changing-properties>`__
      #. `30.4.4â€ƒâ€œDestructive spreadingâ€: Object.assign() [ES6] <#Object.assign>`__

   #. `30.5â€ƒMethods and the special variable this <#methods-and-this>`__

      #. `30.5.1â€ƒMethods are properties whose values are functions <#methods-are-properties-whose-values-are-functions>`__
      #. `30.5.2â€ƒThe special variable this <#the-special-variable-this>`__
      #. `30.5.3â€ƒMethods and .call() <#methods-call>`__
      #. `30.5.4â€ƒMethods and .bind() <#methods-bind>`__
      #. `30.5.5â€ƒthis pitfall: extracting methods <#extracting-methods>`__
      #. `30.5.6â€ƒthis pitfall: accidentally shadowing this <#shadowing-this>`__
      #. `30.5.7â€ƒThe value of this in various contexts (advanced) <#the-value-of-this-in-various-contexts>`__

   #. `30.6â€ƒOptional chaining for property getting and method calls [ES2020] (advanced) <#optional-chaining>`__

      #. `30.6.1â€ƒExample: optional fixed property getting <#example-optional-fixed-property-getting>`__
      #. `30.6.2â€ƒThe operators in more detail (advanced) <#the-operators-in-more-detail>`__
      #. `30.6.3â€ƒShort-circuiting with optional property getting <#short-circuiting-with-optional-property-getting>`__
      #. `30.6.4â€ƒOptional chaining: downsides and alternatives <#optional-chaining-downsides-and-alternatives>`__
      #. `30.6.5â€ƒFrequently asked questions <#frequently-asked-questions>`__

   #. `30.7â€ƒDictionary objects (advanced) <#dictionary-objects>`__

      #. `30.7.1â€ƒQuoted keys in object literals <#object-literals-quoted-keys>`__
      #. `30.7.2â€ƒComputed keys in object literals <#object-literals-computed-keys>`__
      #. `30.7.3â€ƒThe in operator: is there a property with a given key? <#in-operator>`__
      #. `30.7.4â€ƒDeleting properties <#deleting-properties>`__
      #. `30.7.5â€ƒEnumerability <#enumerability>`__
      #. `30.7.6â€ƒListing property keys via Object.keys() etc. <#listing-property-keys-via-object-keys-etc>`__
      #. `30.7.7â€ƒListing property values via Object.values() <#Object.values>`__
      #. `30.7.8â€ƒListing property entries via Object.entries() [ES2017] <#Object.entries>`__
      #. `30.7.9â€ƒProperties are listed deterministically <#order-of-properties>`__
      #. `30.7.10â€ƒAssembling objects via Object.fromEntries() [ES2019] <#Object.fromEntries>`__
      #. `30.7.11â€ƒThe pitfalls of using an object as a dictionary <#the-pitfalls-of-using-an-object-as-a-dictionary>`__

   #. `30.8â€ƒProperty attributes and property descriptors [ES5] (advanced) <#property-attributes-property-descriptors>`__
   #. `30.9â€ƒProtecting objects from being changed [ES5] (advanced) <#protecting-objects>`__
   #. `30.10â€ƒPrototype chains <#prototype-chains>`__

      #. `30.10.1â€ƒJavaScriptâ€™s operations: all properties vs. own properties <#javascript-s-operations-all-properties-vs-own-properties>`__
      #. `30.10.2â€ƒPitfall: only the first member of a prototype chain is mutated <#pitfall-only-the-first-member-of-a-prototype-chain-is-mutated>`__
      #. `30.10.3â€ƒTips for working with prototypes (advanced) <#tips-for-working-with-prototypes>`__
      #. `30.10.4â€ƒObject.hasOwn(): Is a given property own (non-inherited)? [ES2022] <#Object.hasOwn>`__
      #. `30.10.5â€ƒSharing data via prototypes <#sharing-data-via-prototypes>`__

   #. `30.11â€ƒFAQ: objects <#faq-objects>`__

      #. `30.11.1â€ƒWhy do objects preserve the insertion order of properties? <#why-do-objects-preserve-the-insertion-order-of-properties>`__

   #. `30.12â€ƒQuick reference: Object <#quickref-object-api>`__

      #. `30.12.1â€ƒObject.*: creating objects, handling prototypes <#object-creating-objects-handling-prototypes>`__
      #. `30.12.2â€ƒObject.*: property attributes <#object-property-attributes>`__
      #. `30.12.3â€ƒObject.*: property keys, values, entries <#object-property-keys-values-entries>`__
      #. `30.12.4â€ƒObject.*: protecting objects <#object-protecting-objects>`__
      #. `30.12.5â€ƒObject.*: miscellaneous <#object-miscellaneous>`__
      #. `30.12.6â€ƒObject.prototype.* <#object-prototype>`__

   #. `30.13â€ƒQuick reference: Reflect <#quickref-reflect>`__

      #. `30.13.1â€ƒReflect.* vs. Object.* <#reflect-vs-object>`__

   In this book, JavaScriptâ€™s style of object-oriented programming (OOP) is
   introduced in four steps. This chapter covers step 1 and 2; `the next
   chapter <#ch_classes>`__ covers step 3 and 4. The steps are
   (`figure 30.1 <#fig:oop_steps_1_2>`__):

   #. **Single objects (this chapter):** How do *objects*, JavaScriptâ€™s basic OOP
      building blocks, work in isolation?
   #. **Prototype chains (this chapter):** Each object has a chain of zero or more
      *prototype objects*. Prototypes are JavaScriptâ€™s core inheritance mechanism.
   #. **Classes (next chapter):** JavaScriptâ€™s *classes* are factories for objects.
      The relationship between a class and its instances is based on prototypal
      inheritance (step 2).
   #. **Subclassing (next chapter):** The relationship between a *subclass* and its
      *superclass* is also based on prototypal inheritance.

   .. figure:: https://exploringjs.com/js/book/img-book/objects/oop_steps_1_2.svg
      name: fig:oop_steps_1_2
      :width: 364px
      :height: 162px

      Figure 30.1: This book introduces object-oriented programming in JavaScript
      in four steps.

30.1â€ƒCheat sheet: objects
--------------------------

30.1.1â€ƒCheat sheet: single objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Creating an object via an *object literal* (starts and ends with a curly brace):

   .. code:: javascript

      const myObject = { // object literal
      myProperty: 1,
      myMethod() {
         return 2;
      }, // comma!
      get myAccessor() {
         return this.myProperty;
      }, // comma!
      set myAccessor(value) {
         this.myProperty = value;
      }, // last comma is optional
      };

      assert.equal(
      myObject.myProperty, 1
      );
      assert.equal(
      myObject.myMethod(), 2
      );
      assert.equal(
      myObject.myAccessor, 1
      );
      myObject.myAccessor = 3;
      assert.equal(
      myObject.myProperty, 3
      );

   Being able to create objects directly (without classes) is one of the highlights
   of JavaScript.

   Spreading into objects:

   .. code:: javascript

      const original = {
      a: 1,
      b: {
         c: 3,
      },
      };

      // Spreading (...) copies one object â€œintoâ€ another one:
      const modifiedCopy = {
      ...original, // spreading
      d: 4,
      };

      assert.deepEqual(
      modifiedCopy,
      {
         a: 1,
         b: {
            c: 3,
         },
         d: 4,
      }
      );

      // Caveat: spreading copies shallowly (property values are shared)
      modifiedCopy.a = 5; // does not affect `original`
      modifiedCopy.b.c = 6; // affects `original`
      assert.deepEqual(
      original,
      {
         a: 1, // unchanged
         b: {
            c: 6, // changed
         },
      },
      );

   We can also use spreading to make an unmodified (shallow) copy of an object:

   .. code:: javascript

      const exactCopy = {...obj};

30.1.2â€ƒCheat sheet: prototype chains
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Prototypes are JavaScriptâ€™s fundamental inheritance mechanism. Even classes are
   based on it. Each object has ``null`` or an object as its prototype. The latter
   object can also have a prototype, etc. In general, we get *chains* of
   prototypes.

   Prototypes are managed like this:

   .. code:: javascript

      // `obj1` has no prototype (its prototype is `null`)
      const obj1 = Object.create(null); // (A)
      assert.equal(
      Object.getPrototypeOf(obj1), null // (B)
      );

      // `obj2` has the prototype `proto`
      const proto = {
      protoProp: 'protoProp',
      };
      const obj2 = {
      __proto__: proto, // (C)
      objProp: 'objProp',
      }
      assert.equal(
      Object.getPrototypeOf(obj2), proto
      );

   Notes:

   -  Setting an objectâ€™s prototype while creating the object: line A, line C
   -  Retrieving the prototype of an object: line B

   Each object inherits all the properties of its prototype:

   .. code:: javascript

      // `obj2` inherits .protoProp from `proto`
      assert.equal(
      obj2.protoProp, 'protoProp'
      );
      assert.deepEqual(
      Reflect.ownKeys(obj2),
      ['objProp'] // own properties of `obj2`
      );

   The non-inherited properties of an object are called its *own* properties.

   The most important use case for prototypes is that several objects can share
   methods by inheriting them from a common prototype.

30.2â€ƒWhat is an object?
------------------------

   Objects in JavaScript:

   -  An object is a set of *slots* (key-value entries).
   -  Public slots are called *properties*:

      -  A property key can only be a string or a symbol.

   -  Private slots can only be created via classes and are explained in `â€œPublic
      slots (properties) vs. private slotsâ€
      (Â§31.2.4) <#private-slots>`__.



.. _ways-of-using-objects:

30.2.1â€ƒThe two ways of using objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   There are two ways of using objects in JavaScript:

   -  Fixed-layout objects: Used this way, objects work like records in databases.
      They have a fixed number of properties, whose keys are known at development
      time. Their values generally have different types.

      .. code:: javascript

         const fixedLayoutObject = {
         product: 'carrot',
         quantity: 4,
         };

   -  Dictionary objects: Used this way, objects work like lookup tables or maps.
      They have a variable number of properties, whose keys are not known at
      development time. All of their values have the same type.

      .. code:: javascript

         const dictionaryObject = {
         ['one']: 1,
         ['two']: 2,
         };

   Note that the two ways can also be mixed: Some objects are both fixed-layout
   objects and dictionary objects.

   The ways of using objects influence how they are explained in this chapter:

   -  `First, weâ€™ll explore fixed-layout objects. <#fixed-layout-objects>`__ Even
      though property keys are strings or symbols under the hood, they will appear
      as fixed identifiers to us.
   -  `Later, weâ€™ll explore dictionary objects. <#dictionary-objects>`__ Note that
      `Maps <#ch_maps>`__ are usually better dictionaries than objects.
      However, some of the operations that weâ€™ll encounter are also useful for
      fixed-layout objects.

30.3â€ƒFixed-layout objects
--------------------------

   Letâ€™s first explore *fixed-layout objects*.



.. _object-literals:

30.3.1â€ƒObject literals: properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   *Object literals* are one way of creating fixed-layout objects. They are a
   stand-out feature of JavaScript: we can directly create objects â€“ no need for
   classes! This is an example:

   .. code:: javascript

      const jane = {
      first: 'Jane',
      last: 'Doe', // optional trailing comma
      };

   In the example, we created an object via an object literal, which starts and
   ends with curly braces ``{}``. Inside it, we defined two *properties* (key-value
   entries):

   -  The first property has the key ``first`` and the value ``'Jane'``.
   -  The second property has the key ``last`` and the value ``'Doe'``.

   Since ES5, trailing commas are allowed in object literals.

   We will later see other ways of specifying property keys, but with this way of
   specifying them, they must follow the rules of JavaScript variable names. For
   example, we can use ``first_name`` as a property key, but not ``first-name``).
   However, reserved words are allowed:

   .. code:: javascript

      const obj = {
      if: true,
      const: true,
      };

   In order to check the effects of various operations on objects, weâ€™ll
   occasionally use ``Object.keys()`` in this part of the chapter. It lists
   property keys:

   .. code:: javascript
      :name: language-node-repl

      > Object.keys({a:1, b:2})
      [ 'a', 'b' ]

30.3.2â€ƒObject literals: property value shorthands
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Whenever the value of a property is defined via a variable that has the same
   name as the key, we can omit the key.

   .. code:: javascript

      function createPoint(x, y) {
      return {x, y}; // Same as: {x: x, y: y}
      }
      assert.deepEqual(
      createPoint(9, 2),
      { x: 9, y: 2 }
      );

30.3.3â€ƒGetting properties
~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is how we *get* (read) a property (line A):

   .. code:: javascript

      const jane = {
      first: 'Jane',
      last: 'Doe',
      };

      // Get property .first
      assert.equal(jane.first, 'Jane'); // (A)

   Getting an unknown property produces ``undefined``:

   .. code:: javascript

      assert.equal(jane.unknownProperty, undefined);

30.3.4â€ƒSetting properties
~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is how we *set* (write to) a property (line A):

   .. code:: javascript

      const obj = {
      prop: 1,
      };
      assert.equal(obj.prop, 1);
      obj.prop = 2; // (A)
      assert.equal(obj.prop, 2);

   We just changed an existing property via setting. If we set an unknown property,
   we create a new entry:

   .. code:: javascript

      const obj = {}; // empty object
      assert.deepEqual(
      Object.keys(obj), []);

      obj.unknownProperty = 'abc';
      assert.deepEqual(
      Object.keys(obj), ['unknownProperty']);

30.3.5â€ƒObject literals: methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following code shows how to create the method ``.says()`` via an object
   literal:

   .. code:: javascript

      const jane = {
      first: 'Jane', // value property
      says(text) {   // method
         return `${this.first} says â€œ${text}â€`; // (A)
      }, // comma as separator (optional at end)
      };
      assert.equal(jane.says('hello'), 'Jane says â€œhelloâ€');

   During the method call ``jane.says('hello')``, ``jane`` is called the *receiver*
   of the method call and assigned to the special variable ``this`` (more on
   ``this`` in `â€œMethods and the special variable ``this``\ â€
   (Â§30.5) <#methods-and-this>`__). That enables method ``.says()`` to access the
   sibling property ``.first`` in line A.



.. _object-literal-accessors:

30.3.6â€ƒObject literals: accessors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An *accessor* is defined via syntax inside an object literal that looks like
   methods: a *getter* and/or a *setter* (i.e., each accessor has one or both of
   them).

   Invoking an accessor looks like accessing a value property:

   -  Reading the property invokes the getter.
   -  Writing to the property invokes the setter.

30.3.6.1â€ƒGetters
'''''''''''''''''

   A getter is created by prefixing a method definition with the modifier ``get``:

   .. code:: javascript

      const jane = {
      first: 'Jane',
      last: 'Doe',
      get full() {
         return `${this.first} ${this.last}`;
      },
      };

      assert.equal(jane.full, 'Jane Doe');
      jane.first = 'John';
      assert.equal(jane.full, 'John Doe');

30.3.6.2â€ƒSetters
'''''''''''''''''

   A setter is created by prefixing a method definition with the modifier ``set``:

   .. code:: javascript

      const jane = {
      first: 'Jane',
      last: 'Doe',
      set full(fullName) {
         const parts = fullName.split(' ');
         this.first = parts[0];
         this.last = parts[1];
      },
      };

      jane.full = 'Richard Roe';
      assert.equal(jane.first, 'Richard');
      assert.equal(jane.last, 'Roe');

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Creating an object via an object literal**

      .. container:: boxout-vspace

      ``exercises/objects/color_point_object_test.mjs``



.. _spreading-into-object-literals:

30.4â€ƒSpreading into object literals (``...``) [ES2018]
-------------------------------------------------------

   Inside an object literal, a *spread property* adds the properties of another
   object to the current one:

   .. code:: javascript
      :name: language-node-repl

      > const obj = {one: 1, two: 2};
      > {...obj, three: 3}
      { one: 1, two: 2, three: 3 }

   .. code:: javascript

      const obj1 = {one: 1, two: 2};
      const obj2 = {three: 3};
      assert.deepEqual(
      {...obj1, ...obj2, four: 4},
      {one: 1, two: 2, three: 3,  four: 4}
      );

   If property keys clash, the property that is mentioned last â€œwinsâ€:

   .. code:: javascript
      :name: language-node-repl

      > const obj = {one: 1, two: 2, three: 3};
      > {...obj, one: true}
      { one: true, two: 2, three: 3 }
      > {one: true, ...obj}
      { one: 1, two: 2, three: 3 }

   All values are spreadable, even ``undefined`` and ``null``:

   .. code:: javascript
      :name: language-node-repl

      > {...undefined}
      {}
      > {...null}
      {}
      > {...123}
      {}
      > {...'abc'}
      { '0': 'a', '1': 'b', '2': 'c' }
      > {...['a', 'b']}
      { '0': 'a', '1': 'b' }

   Property ``.length`` of strings and Arrays is hidden from this kind of operation
   (it is not *enumerable*; see `â€œProperty attributes and property descriptorsâ€
   (Â§30.8) <#property-attributes-property-descriptors>`__ for more information).

   Spreading includes properties whose keys are symbols (which are ignored by
   ``Object.keys()``, ``Object.values()`` and ``Object.entries()``):

   .. code:: javascript

      const symbolKey = Symbol('symbolKey');
      const obj = {
      stringKey: 1,
      [symbolKey]: 2,
      };
      assert.deepEqual(
      {...obj, anotherStringKey: 3},
      {
         stringKey: 1,
         [symbolKey]: 2,
         anotherStringKey: 3,
      }
      );

30.4.1â€ƒUse case for spreading: copying objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We can use spreading to create a copy of an object ``original``:

   .. code:: javascript

      const copy = {...original};

   Caveat â€“ copying is *shallow*: ``copy`` is a fresh object with duplicates of all
   properties (key-value entries) of ``original``. But if property values are
   objects, then those are not copied themselves; they are shared between
   ``original`` and ``copy``. Letâ€™s look at an example:

   .. code:: javascript

      const original = { a: 1, b: {prop: true} };
      const copy = {...original};

   The first level of ``copy`` is really a copy: If we change any properties at
   that level, it does not affect the original:

   .. code:: javascript

      copy.a = 2;
      assert.deepEqual(
      original, { a: 1, b: {prop: true} }); // no change

   However, deeper levels are not copied. For example, the value of ``.b`` is
   shared between original and copy. Changing ``.b`` in the copy also changes it in
   the original.

   .. code:: javascript

      copy.b.prop = false;
      assert.deepEqual(
      original, { a: 1, b: {prop: false} });

   .. container:: boxout

      |Icon â€œwarningâ€|â€‚**JavaScript doesnâ€™t have built-in support for deep
      copying**

      .. container:: boxout-vspace

      JavaScript does not have a built-in operation for deeply copying objects.
      Options:

      -  Implement it ourselves.
      -  The global function ``structuredClone()`` is supported by most JavaScript
         platforms now â€“ even though it is not part of ECMAScript. Alas, this
         function has `a number of
         limitations <https://2ality.com/2022/01/structured-clone.html>`__ â€“ e.g.,
         if we copy an instance of a class we created, the copy is not an instance
         of that class.
      -  The Lodash library has the functions
         `_.cloneDeep() <https://lodash.com/docs/4.17.15#cloneDeep>`__ and
         `_.cloneDeepWith() <https://lodash.com/docs/4.17.15#cloneDeepWith>`__
         that can help. They have fewer limitations than ``structuredClone()``.

30.4.2â€ƒUse case for spreading: default values for missing properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If one of the inputs of our code is an object with data, we can make properties
   optional by specifying default values that are used if those properties are
   missing. One technique for doing so is via an object whose properties contain
   the default values. In the following example, that object is ``DEFAULTS``:

   .. code:: javascript

      const DEFAULTS = {alpha: 'a', beta: 'b'};
      const providedData = {alpha: 1};

      const allData = {...DEFAULTS, ...providedData};
      assert.deepEqual(allData, {alpha: 1, beta: 'b'});

   The result, the object ``allData``, is created by copying ``DEFAULTS`` and
   overriding its properties with those of ``providedData``.

   But we donâ€™t need an object to specify the default values; we can also specify
   them inside the object literal, individually:

   .. code:: javascript

      const providedData = {alpha: 1};

      const allData = {alpha: 'a', beta: 'b', ...providedData};
      assert.deepEqual(allData, {alpha: 1, beta: 'b'});

30.4.3â€ƒUse case for spreading: non-destructively changing properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   So far, we have encountered one way of changing a property ``.alpha`` of an
   object: We *set* it (line A) and mutate the object. That is, this way of
   changing a property is destructive.

   .. code:: javascript

      const obj = {alpha: 'a', beta: 'b'};
      obj.alpha = 1; // (A)
      assert.deepEqual(obj, {alpha: 1, beta: 'b'});

   With spreading, we can change ``.alpha`` non-destructively â€“ we make a copy of
   ``obj`` where ``.alpha`` has a different value:

   .. code:: javascript

      const obj = {alpha: 'a', beta: 'b'};
      const updatedObj = {...obj, alpha: 1};
      assert.deepEqual(updatedObj, {alpha: 1, beta: 'b'});

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Non-destructively updating a property via
      spreading (fixed key)**

      .. container:: boxout-vspace

      ``exercises/objects/update_name_test.mjs``



.. _Object.assign:

30.4.4â€ƒâ€œDestructive spreadingâ€: ``Object.assign()`` [ES6]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``Object.assign()`` is a tool method:

   .. code:: javascript

      Object.assign(target, source_1, source_2, Â·Â·Â·)

   This expression assigns all properties of ``source_1`` to ``target``, then all
   properties of ``source_2``, etc. At the end, it returns ``target`` â€“ for
   example:

   .. code:: javascript

      const target = { a: 1 };

      const result = Object.assign(
      target,
      {b: 2},
      {c: 3, b: true});

      assert.deepEqual(
      result, { a: 1, b: true, c: 3 });
      // target was modified and returned:
      assert.equal(result, target);

   The use cases for ``Object.assign()`` are similar to those for spread
   properties. In a way, it spreads destructively.



.. _methods-and-this:

30.5â€ƒMethods and the special variable ``this``
-----------------------------------------------

30.5.1â€ƒMethods are properties whose values are functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Letâ€™s revisit the example that was used to introduce methods:

   .. code:: javascript

      const jane = {
      first: 'Jane',
      says(text) {
         return `${this.first} says â€œ${text}â€`;
      },
      };

   Somewhat surprisingly, methods are functions:

   .. code:: javascript

      assert.equal(typeof jane.says, 'function');

   Why is that? We learned `in the chapter on callable
   values <#roles-of-ordinary-functions>`__ that ordinary
   functions play several roles. *Method* is one of those roles. Therefore,
   internally, ``jane`` roughly looks as follows.

   .. code:: javascript

      const jane = {
      first: 'Jane',
      says: function (text) {
         return `${this.first} says â€œ${text}â€`;
      },
      };

30.5.2â€ƒThe special variable ``this``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Consider the following code:

   .. code:: javascript

      const obj = {
      someMethod(x, y) {
         assert.equal(this, obj); // (A)
         assert.equal(x, 'a');
         assert.equal(y, 'b');
      }
      };
      obj.someMethod('a', 'b'); // (B)

   In line B, ``obj`` is the *receiver* of a method call. It is passed to the
   function stored in ``obj.someMethod`` via an implicit (hidden) parameter whose
   name is ``this`` (line A).

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**How to understand ``this``**

      .. container:: boxout-vspace

      The best way to understand ``this`` is as an implicit parameter of ordinary
      functions (and therefore methods, too).



.. _methods-call:

30.5.3â€ƒMethods and ``.call()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Methods are functions and functions have methods themselves. One of those
   methods is `.call() <#Function.prototype.call>`__. Letâ€™s
   look at an example to understand how this method works.

   In the previous section, there was this method invocation:

   .. code:: javascript

      obj.someMethod('a', 'b')

   This invocation is equivalent to:

   .. code:: javascript

      obj.someMethod.call(obj, 'a', 'b');

   Which is also equivalent to:

   .. code:: javascript

      const func = obj.someMethod;
      func.call(obj, 'a', 'b');

   ``.call()`` makes the normally implicit parameter ``this`` explicit: When
   invoking a function via ``.call()``, the first parameter is ``this``, followed
   by the regular (explicit) function parameters.

   As an aside, this means that there are actually two different dot operators:

   #. One for accessing properties: ``obj.prop``
   #. Another one for calling methods: ``obj.prop()``

   They are different in that (2) is not just (1) followed by the function call
   operator ``()``. Instead, (2) additionally provides a value for ``this``.



.. _methods-bind:

30.5.4â€ƒMethods and ``.bind()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `.bind() <#Function.prototype.bind>`__ is another method of
   function objects. In the following code, we use ``.bind()`` to turn method
   ``.says()`` into the stand-alone function ``func()``:

   .. code:: javascript

      const jane = {
      first: 'Jane',
      says(text) {
         return `${this.first} says â€œ${text}â€`; // (A)
      },
      };

      const func = jane.says.bind(jane, 'hello');
      assert.equal(func(), 'Jane says â€œhelloâ€');

   Setting ``this`` to ``jane`` via ``.bind()`` is crucial here. Otherwise,
   ``func()`` wouldnâ€™t work properly because ``this`` is used in line A. In the
   next section, weâ€™ll explore why that is.



.. _extracting-methods:

30.5.5â€ƒ``this`` pitfall: extracting methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We now know quite a bit about functions and methods and are ready to take a look
   at the biggest pitfall involving methods and ``this``: function-calling a method
   extracted from an object can fail if we are not careful.

   In the following example, we fail when we extract method ``jane.says()``, store
   it in the variable ``func``, and function-call ``func``.

   .. code:: javascript

      const jane = {
      first: 'Jane',
      says(text) {
         return `${this.first} says â€œ${text}â€`;
      },
      };
      const func = jane.says; // extract the method
      assert.throws(
      () => func('hello'), // (A)
      {
         name: 'TypeError',
         message: "Cannot read properties of undefined (reading 'first')",
      });

   In line A, we are making a normal function call. And in normal function calls,
   ``this`` is ``undefined`` (if `strict mode <#strict-mode>`__ is
   active, which it almost always is). Line A is therefore equivalent to:

   .. code:: javascript

      assert.throws(
      () => jane.says.call(undefined, 'hello'), // `this` is undefined!
      {
         name: 'TypeError',
         message: "Cannot read properties of undefined (reading 'first')",
      }
      );

   How do we fix this? We need to use ``.bind()`` to extract method ``.says()``:

   .. code:: javascript

      const func2 = jane.says.bind(jane);
      assert.equal(func2('hello'), 'Jane says â€œhelloâ€');

   The ``.bind()`` ensures that ``this`` is always ``jane`` when we call
   ``func()``.

   We can also use arrow functions to extract methods:

   .. code:: javascript

      const func3 = text => jane.says(text);
      assert.equal(func3('hello'), 'Jane says â€œhelloâ€');

30.5.5.1â€ƒExample: extracting a method
''''''''''''''''''''''''''''''''''''''

   The following is a simplified version of code that we may see in actual web
   development:

   .. code:: javascript

      class ClickHandler {
      constructor(id, elem) {
         this.id = id;
         elem.addEventListener('click', this.handleClick); // (A)
      }
      handleClick(event) {
         alert('Clicked ' + this.id);
      }
      }

   In line A, we donâ€™t extract the method ``.handleClick()`` properly. Instead, we
   should do:

   .. code:: javascript

      const listener = this.handleClick.bind(this);
      elem.addEventListener('click', listener);

      // Later, possibly:
      elem.removeEventListener('click', listener);

   Each invocation of ``.bind()`` creates a new function. Thatâ€™s why we need to
   store the result somewhere if we want to remove it later on.

30.5.5.2â€ƒHow to avoid the pitfall of extracting methods
''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Alas, there is no simple way around the pitfall of extracting methods: Whenever
   we extract a method, we have to be careful and do it properly â€“ for example, by
   binding ``this`` or by using an arrow function.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Extracting a method**

      .. container:: boxout-vspace

      ``exercises/objects/method_extraction_exrc.mjs``



.. _shadowing-this:

30.5.6â€ƒ``this`` pitfall: accidentally shadowing ``this``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Accidentally shadowing ``this`` is only an issue with ordinary
      functions**

      .. container:: boxout-vspace

      Arrow functions donâ€™t shadow ``this``.

   Consider the following problem: when we are inside an ordinary function, we
   canâ€™t access the ``this`` of the surrounding scope because the ordinary function
   has its own ``this``. In other words, a variable in an inner scope hides a
   variable in an outer scope. That is called
   `shadowing <#shadowing-variables>`__. The following
   code is an example:

   .. code:: javascript

      const prefixer = {
      prefix: '==> ',
      prefixStringArray(stringArray) {
         return stringArray.map(
            function (x) {
            return this.prefix + x; // (A)
            });
      },
      };
      assert.throws(
      () => prefixer.prefixStringArray(['a', 'b']),
      {
         name: 'TypeError',
         message: "Cannot read properties of undefined (reading 'prefix')",
      }
      );

   In line A, we want to access the ``this`` of ``.prefixStringArray()``. But we
   canâ€™t since the surrounding ordinary function has its own ``this`` that
   *shadows* (and blocks access to) the ``this`` of the method. The value of the
   former ``this`` is ``undefined`` due to the callback being function-called. That
   explains the error message.

   The simplest way to fix this problem is via an arrow function, which doesnâ€™t
   have its own ``this`` and therefore doesnâ€™t shadow anything:

   .. code:: javascript

      const prefixer = {
      prefix: '==> ',
      prefixStringArray(stringArray) {
         return stringArray.map(
            (x) => {
            return this.prefix + x;
            });
      },
      };
      assert.deepEqual(
      prefixer.prefixStringArray(['a', 'b']),
      ['==> a', '==> b']);

   We can also store ``this`` in a different variable (line A), so that it doesnâ€™t
   get shadowed:

   .. code:: javascript

      prefixStringArray(stringArray) {
      const that = this; // (A)
      return stringArray.map(
         function (x) {
            return that.prefix + x;
         });
      },

   Another option is to specify a fixed ``this`` for the callback via ``.bind()``
   (line A):

   .. code:: javascript

      prefixStringArray(stringArray) {
      return stringArray.map(
         function (x) {
            return this.prefix + x;
         }.bind(this)); // (A)
      },

   Lastly, ``.map()`` lets us specify a value for ``this`` (line A) that it uses
   when invoking the callback:

   .. code:: javascript

      prefixStringArray(stringArray) {
      return stringArray.map(
         function (x) {
            return this.prefix + x;
         },
         this); // (A)
      },

30.5.6.1â€ƒAvoiding the pitfall of accidentally shadowing ``this``
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   If we follow the advice in `â€œRecommendation: prefer specialized functions over
   ordinary functionsâ€
   (Â§27.3.4) <#prefer-specialized-functions>`__, we can avoid the
   pitfall of accidentally shadowing ``this``. This is a summary:

   -  Use arrow functions as anonymous inline functions. They donâ€™t have ``this``
      as an implicit parameter and donâ€™t shadow it.

   -  For named stand-alone function declarations we can either use arrow functions
      or function declarations. If we do the latter, we have to make sure ``this``
      isnâ€™t mentioned in their bodies.



.. _the-value-of-this-in-various-contexts:

30.5.7â€ƒThe value of ``this`` in various contexts (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   What is the value of ``this`` in various contexts?

   Inside a callable entity, the value of ``this`` depends on how the callable
   entity is invoked and what kind of callable entity it is:

   -  Function call:

      -  Ordinary functions: ``this === undefined`` (in `strict
         mode <#strict-mode>`__)
      -  Arrow functions: ``this`` is same as in surrounding scope (lexical
         ``this``)

   -  Method call: ``this`` is receiver of call
   -  ``new``: ``this`` refers to the newly created instance

   We can also access ``this`` in all common top-level scopes:

   -  ``<script>`` element: ``this === globalThis``
   -  ECMAScript modules: ``this === undefined``
   -  CommonJS modules: ``this === module.exports``

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Tip: pretend that ``this`` doesnâ€™t exist in top-level scopes**

      .. container:: boxout-vspace

      I like to do that because top-level ``this`` is confusing and there are
      better alternatives for its (few) use cases.



.. _optional-chaining:

30.6â€ƒOptional chaining for property getting and method calls [ES2020] (advanced)
---------------------------------------------------------------------------------

   The following kinds of optional chaining operations exist:

   .. code:: javascript

      obj?.prop     // optional fixed property getting
      obj?.[Â«exprÂ»] // optional dynamic property getting
      func?.(Â«arg0Â», Â«arg1Â») // optional function or method call

   The rough idea is:

   -  If the value before the question mark is neither ``undefined`` nor ``null``,
      then perform the operation after the question mark.
   -  Otherwise, return ``undefined``.

   Each of the three syntaxes is covered in more detail later. These are a few
   first examples:

   .. code:: javascript
      :name: language-node-repl

      > null?.prop
      undefined
      > {prop: 1}?.prop
      1

      > null?.(123)
      undefined
      > String?.(123)
      '123'

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Mnemonic for the optional chaining operator (``?.``)**

      .. container:: boxout-vspace

      Are you occasionally unsure if the optional chaining operator starts with a
      dot (``.?``) or a question mark (``?.``)? Then this mnemonic may help you:

      -  **If** (``?``) the left-hand side is not nullish
      -  **then** (``.``) access a property.

30.6.1â€ƒExample: optional fixed property getting
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Consider the following data:

   .. code:: javascript

      const persons = [
      {
         surname: 'Zoe',
         address: {
            street: {
            name: 'Sesame Street',
            number: '123',
            },
         },
      },
      {
         surname: 'Mariner',
      },
      {
         surname: 'Carmen',
         address: {
         },
      },
      ];

   We can use optional chaining to safely extract street names:

   .. code:: javascript

      const streetNames = persons.map(
      p => p.address?.street?.name);
      assert.deepEqual(
      streetNames, ['Sesame Street', undefined, undefined]
      );

30.6.1.1â€ƒHandling defaults via nullish coalescing
''''''''''''''''''''''''''''''''''''''''''''''''''

   The `nullish coalescing
   operator <#nullish-coalescing-operator>`__ allows us to
   use the default value ``'(no name)'`` instead of ``undefined``:

   .. code:: javascript

      const streetNames = persons.map(
      p => p.address?.street?.name ?? '(no name)');
      assert.deepEqual(
      streetNames, ['Sesame Street', '(no name)', '(no name)']
      );



.. _the-operators-in-more-detail:

30.6.2â€ƒThe operators in more detail (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

30.6.2.1â€ƒOptional fixed property getting
'''''''''''''''''''''''''''''''''''''''''

   The following two expressions are equivalent:

   .. code:: javascript

      o?.prop
      (o !== undefined && o !== null) ? o.prop : undefined

   Examples:

   .. code:: javascript

      assert.equal(undefined?.prop, undefined);
      assert.equal(null?.prop,      undefined);
      assert.equal({prop:1}?.prop,  1);

30.6.2.2â€ƒOptional dynamic property getting
'''''''''''''''''''''''''''''''''''''''''''

   The following two expressions are equivalent:

   .. code:: javascript

      o?.[Â«exprÂ»]
      (o !== undefined && o !== null) ? o[Â«exprÂ»] : undefined

   Examples:

   .. code:: javascript

      const key = 'prop';
      assert.equal(undefined?.[key], undefined);
      assert.equal(null?.[key], undefined);
      assert.equal({prop:1}?.[key], 1);

30.6.2.3â€ƒOptional function or method call
''''''''''''''''''''''''''''''''''''''''''

   The following two expressions are equivalent:

   .. code:: javascript

      f?.(arg0, arg1)
      (f !== undefined && f !== null) ? f(arg0, arg1) : undefined

   Examples:

   .. code:: javascript

      assert.equal(undefined?.(123), undefined);
      assert.equal(null?.(123), undefined);
      assert.equal(String?.(123), '123');

   Note that this operator produces an error if its left-hand side is not callable:

   .. code:: javascript

      assert.throws(
      () => true?.(123),
      TypeError);

   Why? The idea is that the operator only tolerates deliberate omissions. An
   uncallable value (other than ``undefined`` and ``null``) is probably an error
   and should be reported, rather than worked around.

30.6.3â€ƒShort-circuiting with optional property getting
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In a chain of property gettings and method invocations, evaluation stops once
   the first optional operator encounters ``undefined`` or ``null`` at its
   left-hand side:

   .. code:: javascript

      function invokeM(value) {
      return value?.a.b.m(); // (A)
      }

      const obj = {
      a: {
         b: {
            m() { return 'result' }
         }
      }
      };
      assert.equal(
      invokeM(obj), 'result'
      );
      assert.equal(
      invokeM(undefined), undefined // (B)
      );

   Consider ``invokeM(undefined)`` in line B: ``undefined?.a`` is ``undefined``.
   Therefore weâ€™d expect ``.b`` to fail in line A. But it doesnâ€™t: The ``?.``
   operator encounters the value ``undefined`` and the evaluation of the whole
   expression immediately returns ``undefined``.

   This behavior differs from a normal operator where JavaScript always evaluates
   all operands before evaluating the operator. It is called *short-circuiting*.
   Other short-circuiting operators are:

   -  ``(a && b)``: ``b`` is only evaluated if ``a`` is truthy.
   -  ``(a || b)``: ``b`` is only evaluated if ``a`` is falsy.
   -  ``(c ? t : e)``: If ``c`` is truthy, ``t`` is evaluated. Otherwise, ``e`` is
      evaluated.

30.6.4â€ƒOptional chaining: downsides and alternatives
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Optional chaining also has downsides:

   -  Deeply nested structures are more difficult to manage. For example,
      refactoring is harder if there are many sequences of property names: Each one
      enforces the structure of multiple objects.
   -  Being so forgiving when accessing data hides problems that will surface much
      later and are then harder to debug. For example, a typo early in a sequence
      of optional property names has more negative effects than a normal typo.

   An alternative to optional chaining is to extract the information once, in a
   single location:

   -  We can either write a helper function that extracts the data.
   -  Or we can write a function whose input is deeply nested data and whose output
      is simpler, normalized data.

   With either approach, it is possible to perform checks and to fail early if
   there are problems.

   Further reading:

   -  â€œ\ `Overly defensive
      programming <https://blog.vcarl.com/overly-defensive-programming/>`__\ â€ by
      Carl Vitullo

30.6.5â€ƒFrequently asked questions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. _why-are-there-dots-in-o-x-and-f:

30.6.5.1â€ƒWhy are there dots in ``o?.[x]`` and ``f?.()``?
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The syntaxes of the following two optional operator are not ideal:

   .. code:: javascript

      obj?.[Â«exprÂ»]          // better: obj?[Â«exprÂ»]
      func?.(Â«arg0Â», Â«arg1Â») // better: func?(Â«arg0Â», Â«arg1Â»)

   Alas, the less elegant syntax is necessary because distinguishing the ideal
   syntax (first expression) from the conditional operator (second expression) is
   too complicated:

   .. code:: javascript

      obj?['a', 'b', 'c'].map(x => x+x)
      obj ? ['a', 'b', 'c'].map(x => x+x) : []



.. _why-does-null-prop-evaluate-to-undefined-and-not-null:

30.6.5.2â€ƒWhy does ``null?.prop`` evaluate to ``undefined`` and not ``null``?
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The operator ``?.`` is mainly about its right-hand side: Does property ``.prop``
   exist? If not, stop early. Therefore, keeping information about its left-hand
   side is rarely useful. However, only having a single â€œearly terminationâ€ value
   does simplify things.



.. _dictionary-objects:

30.7â€ƒDictionary objects (advanced)
-----------------------------------

   Objects work best as fixed-layout objects. But before ES6, JavaScript did not
   have a data structure for dictionaries (ES6 brought
   `Maps <#ch_maps>`__). Therefore, objects had to be used as
   dictionaries, which imposed a signficant constraint: Dictionary keys had to be
   strings (symbols were also introduced with ES6).

   We first look at features of objects that are related to dictionaries but also
   useful for fixed-layout objects. This section concludes with tips for actually
   using objects as dictionaries. (Spoiler: If possible, itâ€™s better to use Maps.)



.. _object-literals-quoted-keys:

30.7.1â€ƒQuoted keys in object literals
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   So far, we have always used fixed-layout objects. Property keys were fixed
   tokens that had to be valid identifiers and internally became strings:

   .. code:: javascript

      const obj = {
      mustBeAnIdentifier: 123,
      };

      // Get property
      assert.equal(obj.mustBeAnIdentifier, 123);

      // Set property
      obj.mustBeAnIdentifier = 'abc';
      assert.equal(obj.mustBeAnIdentifier, 'abc');

   As a next step, weâ€™ll go beyond this limitation for property keys: In this
   subsection, weâ€™ll use arbitrary fixed strings as keys. In the next subsection,
   weâ€™ll dynamically compute keys.

   Two syntaxes enable us to use arbitrary strings as property keys.

   First, when creating property keys via object literals, we can quote property
   keys (with single or double quotes):

   .. code:: javascript

      const obj = {
      'Can be any string!': 123,
      };

   Second, when getting or setting properties, we can use square brackets with
   strings inside them:

   .. code:: javascript

      // Get property
      assert.equal(obj['Can be any string!'], 123);

      // Set property
      obj['Can be any string!'] = 'abc';
      assert.equal(obj['Can be any string!'], 'abc');

   We can also use these syntaxes for methods:

   .. code:: javascript

      const obj = {
      'A nice method'() {
         return 'Yes!';
      },
      };

      assert.equal(obj['A nice method'](), 'Yes!');



.. _object-literals-computed-keys:

30.7.2â€ƒComputed keys in object literals
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In the previous subsection, property keys were specified via fixed strings
   inside object literals. In this section we learn how to dynamically compute
   property keys. That enables us to use either arbitrary strings or symbols.

   The syntax of dynamically computed property keys in object literals is inspired
   by dynamically accessing properties. That is, we can use square brackets to wrap
   expressions:

   .. code:: javascript

      const obj = {
      ['Hello world!']: true,
      ['p'+'r'+'o'+'p']: 123,
      [Symbol.toStringTag]: 'Goodbye', // (A)
      };

      assert.equal(obj['Hello world!'], true);
      assert.equal(obj.prop, 123);
      assert.equal(obj[Symbol.toStringTag], 'Goodbye');

   The main use case for computed keys is having symbols as property keys (line A).

   Note that the square brackets operator for getting and setting properties works
   with arbitrary expressions:

   .. code:: javascript

      assert.equal(obj['p'+'r'+'o'+'p'], 123);
      assert.equal(obj['==> prop'.slice(4)], 123);

   Methods can have computed property keys, too:

   .. code:: javascript

      const methodKey = Symbol();
      const obj = {
      [methodKey]() {
         return 'Yes!';
      },
      };

      assert.equal(obj[methodKey](), 'Yes!');

   For the remainder of this chapter, weâ€™ll mostly use fixed property keys again
   (because they are syntactically more convenient). But all features are also
   available for arbitrary strings and symbols.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Non-destructively updating a property via
      spreading (computed key)**

      .. container:: boxout-vspace

      ``exercises/objects/update_property_test.mjs``



.. _in-operator:

30.7.3â€ƒThe ``in`` operator: is there a property with a given key?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The ``in`` operator checks if an object has a property with a given key:

   .. code:: javascript

      const obj = {
      alpha: 'abc',
      beta: false,
      };

      assert.equal('alpha' in obj, true);
      assert.equal('beta' in obj, true);
      assert.equal('unknownKey' in obj, false);

30.7.3.1â€ƒChecking if a property exists via truthiness
''''''''''''''''''''''''''''''''''''''''''''''''''''''

   We can also use a truthiness check to determine if a property exists:

   .. code:: javascript

      assert.equal(
      obj.alpha ? 'exists' : 'does not exist',
      'exists');
      assert.equal(
      obj.unknownKey ? 'exists' : 'does not exist',
      'does not exist');

   The previous checks work because ``obj.alpha`` is truthy and because reading a
   missing property returns ``undefined`` (which is falsy).

   There is, however, one important caveat: truthiness checks fail if the property
   exists, but has a falsy value (``undefined``, ``null``, ``false``, ``0``,
   ``""``, etc.):

   .. code:: javascript

      assert.equal(
      obj.beta ? 'exists' : 'does not exist',
      'does not exist'); // should be: 'exists'

30.7.4â€ƒDeleting properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We can delete properties via the ``delete`` operator:

   .. code:: javascript

      const obj = {
      myProp: 123,
      };

      assert.deepEqual(Object.keys(obj), ['myProp']);
      delete obj.myProp;
      assert.deepEqual(Object.keys(obj), []);

30.7.5â€ƒEnumerability
~~~~~~~~~~~~~~~~~~~~~

   *Enumerability* is an `attribute <#property-attributes-property-descriptors>`__
   of a property. Non-enumerable properties are ignored by some operations â€“ for
   example, by ``Object.keys()`` and when spreading properties. By default, most
   properties are enumerable. The next example shows how to change that and how it
   affects spreading.

   .. code:: javascript

      const enumerableSymbolKey = Symbol('enumerableSymbolKey');
      const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');

      // We create enumerable properties via an object literal
      const obj = {
      enumerableStringKey: 1,
      [enumerableSymbolKey]: 2,
      }

      // For non-enumerable properties, we need a more powerful tool
      Object.defineProperties(obj, {
      nonEnumStringKey: {
         value: 3,
         enumerable: false,
      },
      [nonEnumSymbolKey]: {
         value: 4,
         enumerable: false,
      },
      });

      // Non-enumerable properties are ignored by spreading:
      assert.deepEqual(
      {...obj},
      {
         enumerableStringKey: 1,
         [enumerableSymbolKey]: 2,
      }
      );

   ``Object.defineProperties()`` is explained `later in this
   chapter <#property-attributes-property-descriptors>`__. The next subsection
   shows how these operations are affected by enumerability:



.. _listing-property-keys-via-object-keys-etc:

30.7.6â€ƒListing property keys via ``Object.keys()`` etc.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   ==============================  ==========  ======  =======  =========
                                   enumerable  non-e.  string   symbol
   Object.keys()                   âœ”                    âœ”
   Object.getOwnPropertyNames()    âœ”           âœ”       âœ”        
   Object.getOwnPropertySymbols()  âœ”           âœ”                 âœ”
   Reflect.ownKeys()               âœ”           âœ”       âœ”        âœ”
   ==============================  ==========  ======  =======  =========

   Table 30.1: Standard library methods for listing *own* (non-inherited) property
   keys. All of them return Arrays with strings and/or symbols.

   Each of the methods in `table 30.1 <#tbl:listing-property-keys>`__ returns an
   Array with the own property keys of the parameter. In the names of the methods,
   we can see that the following distinction is made:

   -  A *property key* can be either a string or a symbol. (``Object.keys()`` is
      older and does not yet follow this convention.)
   -  A *property name* is a property key whose value is a string.
   -  A *property symbol* is a property key whose value is a symbol.

   To demonstrate the four operations, we revisit the example from the previous
   subsection:

   .. code:: javascript

      const enumerableSymbolKey = Symbol('enumerableSymbolKey');
      const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');

      const obj = {
      enumerableStringKey: 1,
      [enumerableSymbolKey]: 2,
      }
      Object.defineProperties(obj, {
      nonEnumStringKey: {
         value: 3,
         enumerable: false,
      },
      [nonEnumSymbolKey]: {
         value: 4,
         enumerable: false,
      },
      });

      assert.deepEqual(
      Object.keys(obj),
      ['enumerableStringKey']
      );
      assert.deepEqual(
      Object.getOwnPropertyNames(obj),
      ['enumerableStringKey', 'nonEnumStringKey']
      );
      assert.deepEqual(
      Object.getOwnPropertySymbols(obj),
      [enumerableSymbolKey, nonEnumSymbolKey]
      );
      assert.deepEqual(
      Reflect.ownKeys(obj),
      [
         'enumerableStringKey', 'nonEnumStringKey',
         enumerableSymbolKey, nonEnumSymbolKey,
      ]
      );



.. _Object.values:

30.7.7â€ƒListing property values via ``Object.values()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``Object.values()`` lists the values of all own enumerable string-keyed
   properties of an object:

   .. code:: javascript

      const firstName = Symbol('firstName');
      const obj = {
      [firstName]: 'Jane',
      lastName: 'Doe',
      };
      assert.deepEqual(
      Object.values(obj),
      ['Doe']);



.. _Object.entries:

30.7.8â€ƒListing property entries via ``Object.entries()`` [ES2017]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``Object.entries(obj)`` returns an Array with one key-value pair for each of its
   properties:

   -  Each pair is encoded as a two-element Array.
   -  Only own enumerable properties with string keys are included.

   .. code:: javascript

      const firstName = Symbol('firstName');
      const obj = {
      [firstName]: 'Jane',
      lastName: 'Doe',
      };
      Object.defineProperty(
      obj, 'city', {value: 'Metropolis', enumerable: false}
      );
      assert.deepEqual(
      Object.entries(obj),
      [
         ['lastName', 'Doe'],
      ]);



.. _a-simple-implementation-of-object-entries:

30.7.8.1â€ƒA simple implementation of ``Object.entries()``
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The following function is a simplified version of ``Object.entries()``:

   .. code:: javascript

      function entries(obj) {
      return Object.keys(obj)
      .map(key => [key, obj[key]]);
      }

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: ``Object.entries()``**

      .. container:: boxout-vspace

      ``exercises/objects/find_key_test.mjs``



.. _order-of-properties:

30.7.9â€ƒProperties are listed deterministically
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Own (non-inherited) properties of objects are always listed in the following
   order:

   #. Properties with string keys that contain integer indices (that includes
      `Array indices <#array-indices>`__):
      In ascending numeric order
   #. Remaining properties with string keys:
      In the order in which they were added
   #. Properties with symbol keys:
      In the order in which they were added

   The following example demonstrates that property keys are sorted according to
   these rules:

   .. code:: javascript
      :name: language-node-repl

      > Object.keys({b:'',a:'', 10:'',2:''})
      [ '2', '10', 'b', 'a' ]

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**The order of properties**

      .. container:: boxout-vspace

      `The ECMAScript
      specification <https://tc39.es/ecma262/#sec-ordinaryownpropertykeys>`__
      describes in more detail how properties are ordered.



.. _Object.fromEntries:

30.7.10â€ƒAssembling objects via ``Object.fromEntries()`` [ES2019]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Given an iterable over [key, value] pairs, ``Object.fromEntries()`` creates an
   object:

   .. code:: javascript

      const symbolKey = Symbol('symbolKey');
      assert.deepEqual(
      Object.fromEntries(
         [
            ['stringKey', 1],
            [symbolKey, 2],
         ]
      ),
      {
         stringKey: 1,
         [symbolKey]: 2,
      }
      );

   ``Object.fromEntries()`` does the opposite of
   `Object.entries() <#Object.entries>`__. However, while ``Object.entries()``
   ignores symbol-keyed properties, ``Object.fromEntries()`` doesnâ€™t (see previous
   example).

   To demonstrate both, weâ€™ll use them to implement two tool functions from the
   library `Underscore <https://underscorejs.org>`__ in the next subsubsections.



.. _underscore-pick:

30.7.10.1â€ƒExample: ``pick()``
''''''''''''''''''''''''''''''

   `The Underscore function ``pick() <https://underscorejs.org/#pick>`__ has the
   following signature:

   .. code:: javascript

      pick(object, ...keys)

   It returns a copy of ``object`` that has only those properties whose keys are
   mentioned in the trailing arguments:

   .. code:: javascript

      const address = {
      street: 'Evergreen Terrace',
      number: '742',
      city: 'Springfield',
      state: 'NT',
      zip: '49007',
      };
      assert.deepEqual(
      pick(address, 'street', 'number'),
      {
         street: 'Evergreen Terrace',
         number: '742',
      }
      );

   We can implement ``pick()`` as follows:

   .. code:: javascript

      function pick(object, ...keys) {
      const filteredEntries = Object.entries(object)
         .filter(([key, _value]) => keys.includes(key));
      return Object.fromEntries(filteredEntries);
      }



.. _underscore-invert:

30.7.10.2â€ƒExample: ``invert()``
''''''''''''''''''''''''''''''''

   `The Underscore function ``invert() <https://underscorejs.org/#invert>`__ has
   the following signature:

   .. code:: javascript

      invert(object)

   It returns a copy of ``object`` where the keys and values of all properties are
   swapped:

   .. code:: javascript

      assert.deepEqual(
      invert({a: 1, b: 2, c: 3}),
      {1: 'a', 2: 'b', 3: 'c'}
      );

   We can implement ``invert()`` like this:

   .. code:: javascript

      function invert(object) {
      const reversedEntries = Object.entries(object)
         .map(([key, value]) => [value, key]);
      return Object.fromEntries(reversedEntries);
      }



.. _a-simple-implementation-of-object-fromentries:

30.7.10.3â€ƒA simple implementation of ``Object.fromEntries()``
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The following function is a simplified version of ``Object.fromEntries()``:

   .. code:: javascript

      function fromEntries(iterable) {
      const result = {};
      for (const [key, value] of iterable) {
         let coercedKey;
         if (typeof key === 'string' || typeof key === 'symbol') {
            coercedKey = key;
         } else {
            coercedKey = String(key);
         }
         result[coercedKey] = value;
      }
      return result;
      }

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Using ``Object.entries()`` and
      ``Object.fromEntries()``**

      .. container:: boxout-vspace

      ``exercises/objects/omit_properties_test.mjs``

30.7.11â€ƒThe pitfalls of using an object as a dictionary
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If we use plain objects (created via object literals) as dictionaries, we have
   to look out for two pitfalls.

   The first pitfall is that the ``in`` operator also finds inherited properties:

   .. code:: javascript

      const dict = {};
      assert.equal('toString' in dict, true);

   We want ``dict`` to be treated as empty, but the ``in`` operator detects the
   properties it inherits from its prototype, ``Object.prototype``.

   The second pitfall is that we canâ€™t use the property key ``__proto__`` because
   it has special powers (it sets the prototype of the object):

   .. code:: javascript

      const dict = {};

      dict['__proto__'] = 123;
      // No property was added to dict:
      assert.deepEqual(Object.keys(dict), []);

30.7.11.1â€ƒSafely using objects as dictionaries
'''''''''''''''''''''''''''''''''''''''''''''''

   So how do we avoid the two pitfalls?

   -  If we can, we use Maps. They are the best solution for dictionaries.
   -  If we canâ€™t, we use a library for objects-as-dictionaries that protects us
      from making mistakes.
   -  If thatâ€™s not possible or desired, we use an object without a prototype.

   The following code demonstrates using prototype-less objects as dictionaries:

   .. code:: javascript

      const dict = Object.create(null); // prototype is `null`

      assert.equal('toString' in dict, false); // (A)

      dict['__proto__'] = 123;
      assert.deepEqual(Object.keys(dict), ['__proto__']);

   We avoided both pitfalls:

   -  First, a property without a prototype does not inherit any properties (line
      A).
   -  Second, in modern JavaScript, ``__proto__`` is implemented via
      ``Object.prototype``. That means that it is switched off if
      ``Object.prototype`` is not in the prototype chain.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Using an object as a dictionary**

      .. container:: boxout-vspace

      ``exercises/objects/simple_dict_test.mjs``



.. _property-attributes-property-descriptors:

30.8â€ƒProperty attributes and property descriptors [ES5] (advanced)
-------------------------------------------------------------------

   Just as objects are composed of properties, properties are composed of
   *attributes*. There are two kinds of properties and they are characterized by
   their attributes:

   -  A *data property* stores data. Its attribute ``value`` holds any JavaScript
      value.

      -  Methods are data properties whose values are functions.

   -  An *accessor property* consists of a getter function and/or a setter
      function. The former is stored in the attribute ``get``, the latter in the
      attribute ``set``.

   Additionally, there are attributes that both kinds of properties have. The
   following table lists all attributes and their default values.

   =================  ================================  =============
   Kind of property   Name and type of attribute        Default value
   All properties     configurable: boolean             false
   \                  enumerable: boolean               false
   Data property      value: any                        undefined
   \                  writable: boolean                 false
   Accessor property  get: (this: any) => any           undefined
   \                  set: (this: any, v: any) => void  undefined
   =================  ================================  =============

   We have already encountered the attributes ``value``, ``get``, and ``set``. The
   other attributes work as follows:

   -  ``writable`` determines if the value of a data property can be changed.
   -  ``configurable`` determines if the attributes of a property can be changed.
      If it is ``false``, then:

      -  We cannot delete the property.
      -  We cannot change a property from a data property to an accessor property
         or vice versa.
      -  We cannot change any attribute other than ``value``.
      -  However, one more attribute change is allowed: We can change ``writable``
         from ``true`` to ``false``. The rationale behind this anomaly is
         `historical <https://stackoverflow.com/questions/9829817/why-can-i-set-enumerability-and-writability-of-unconfigurable-property-descrip/9843191#9843191>`__:
         Property ``.length`` of Arrays has always been writable and
         non-configurable. Allowing its ``writable`` attribute to be changed
         enables us to freeze Arrays.

   -  ``enumerable`` influences some operations (such as ``Object.keys()``). If it
      is ``false``, then those operations ignore the property. Enumerability is
      covered in greater detail `earlier in this chapter <#enumerability>`__.

   When we are using one of the operations for handling property attributes,
   attributes are specified via *property descriptors*: objects where each property
   represents one attribute. For example, this is how we read the attributes of a
   property ``obj.myProp``:

   .. code:: javascript

      const obj = { myProp: 123 };
      assert.deepEqual(
      Object.getOwnPropertyDescriptor(obj, 'myProp'),
      {
         value: 123,
         writable: true,
         enumerable: true,
         configurable: true,
      });

   And this is how we change the attributes of ``obj.myProp``:

   .. code:: javascript

      assert.deepEqual(Object.keys(obj), ['myProp']);

      // Hide property `myProp` from Object.keys()
      // by making it non-enumerable
      Object.defineProperty(obj, 'myProp', {
      enumerable: false,
      });

      assert.deepEqual(Object.keys(obj), []);

   Lastly, letâ€™s see what methods and getters look like:

   .. code:: javascript

      const obj = {
      myMethod() {},
      get myGetter() {},
      };
      const propDescs = Object.getOwnPropertyDescriptors(obj);
      propDescs.myMethod.value = typeof propDescs.myMethod.value;
      propDescs.myGetter.get = typeof propDescs.myGetter.get;
      assert.deepEqual(
      propDescs,
      {
         myMethod: {
            value: 'function',
            writable: true,
            enumerable: true,
            configurable: true
         },
         myGetter: {
            get: 'function',
            set: undefined,
            enumerable: true,
            configurable: true
         }
      }
      );

   .. container:: boxout

      |Icon â€œexternalâ€|â€‚**Further reading**

      .. container:: boxout-vspace

      For more information on property attributes and property descriptors, see
      `Deep
      JavaScript <https://exploringjs.com/deep-js/ch_property-attributes-intro.html>`__.



.. _protecting-objects:

30.9â€ƒProtecting objects from being changed [ES5] (advanced)
------------------------------------------------------------

   JavaScript has three levels of protecting objects:

   -  *Preventing extensions* makes it impossible to add new properties to an
      object and to change its prototype. We can still delete and change
      properties, though.

      -  Apply: ``Object.preventExtensions(obj)``
      -  Check: ``Object.isExtensible(obj)``

   -  *Sealing* prevents extensions and makes all properties *unconfigurable*
      (roughly: we canâ€™t change how a property works anymore).

      -  Apply: ``Object.seal(obj)``
      -  Check: ``Object.isSealed(obj)``

   -  *Freezing* seals an object after making all of its properties non-writable.
      That is, the object is not extensible, all properties are read-only and there
      is no way to change that.

      -  Apply: ``Object.freeze(obj)``
      -  Check: ``Object.isFrozen(obj)``

   .. container:: boxout

      |Icon â€œwarningâ€|â€‚**Caveat: Objects are only protected shallowly**

      .. container:: boxout-vspace

      All three of the aforementioned ``Object.*`` methods only affect the top
      level of an object, not objects nested inside it.

   This is what using ``Object.freeze()`` looks like:

   .. code:: javascript

      const frozen = Object.freeze({ x: 2, y: 5 });
      assert.throws(
      () => frozen.x = 7,
      {
         name: 'TypeError',
         message: /^Cannot assign to read only property 'x'/,
      }
      );

   Changing frozen properties only causes an exception in `strict
   mode <#strict-mode>`__. In sloppy mode, it fails silently.

   .. container:: boxout

      |Icon â€œexternalâ€|â€‚**Further reading**

      .. container:: boxout-vspace

      For more information on freezing and other ways of locking down objects, see
      `Deep
      JavaScript <https://exploringjs.com/deep-js/ch_protecting-objects.html>`__.

30.10â€ƒPrototype chains
-----------------------

   Prototypes are JavaScriptâ€™s only inheritance mechanism: Each object has a
   prototype that is either ``null`` or an object. In the latter case, the object
   inherits all of the prototypeâ€™s properties.

   In an object literal, we can set the prototype via the special property
   ``__proto__``:

   .. code:: javascript

      const proto = {
      protoProp: 'a',
      };
      const obj = {
      __proto__: proto,
      objProp: 'b',
      };

      // obj inherits .protoProp:
      assert.equal(obj.protoProp, 'a');
      assert.equal('protoProp' in obj, true);

   Given that a prototype object can have a prototype itself, we get a chain of
   objects â€“ the so-called *prototype chain*. Inheritance gives us the impression
   that we are dealing with single objects, but we are actually dealing with chains
   of objects.

   `Figure 30.2 <#fig:oo_proto_chain>`__ shows what the prototype chain of ``obj``
   looks like.

   .. figure:: https://exploringjs.com/js/book/img-book/objects/oo_proto_chain.svg
      name: fig:oo_proto_chain
      :width: 119px
      :height: 198px

      Figure 30.2: ``obj`` starts a chain of objects that continues with ``proto``
      and other objects.

   Non-inherited properties are called *own properties*. ``obj`` has one own
   property, ``.objProp``.



.. _javascript-s-operations-all-properties-vs-own-properties:

30.10.1â€ƒJavaScriptâ€™s operations: all properties vs. own properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Some operations consider all properties (own and inherited) â€“ for example,
   getting properties:

   .. code:: javascript
      :name: language-node-repl

      > const obj = { one: 1 };
      > typeof obj.one // own
      'number'
      > typeof obj.toString // inherited
      'function'

   Other operations only consider own properties â€“ for example, ``Object.keys()``:

   .. code:: javascript
      :name: language-node-repl

      > Object.keys(obj)
      [ 'one' ]

   Read on for another operation that also only considers own properties: setting
   properties.

30.10.2â€ƒPitfall: only the first member of a prototype chain is mutated
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Given an object ``obj`` with a chain of prototype objects, it makes sense that
   setting an own property of ``obj`` only changes ``obj``. However, setting an
   inherited property via ``obj`` also only changes ``obj``. It creates a new own
   property in ``obj`` that overrides the inherited property. Letâ€™s explore how
   that works with the following object:

   .. code:: javascript

      const proto = {
      protoProp: 'a',
      };
      const obj = {
      __proto__: proto,
      objProp: 'b',
      };

   In the next code snippet, we set the inherited property ``obj.protoProp`` (line
   A). That â€œchangesâ€ it by creating an own property: When reading
   ``obj.protoProp``, the own property is found first and its value *overrides* the
   value of the inherited property.

   .. code:: javascript

      // In the beginning, obj has one own property
      assert.deepEqual(Object.keys(obj), ['objProp']);

      obj.protoProp = 'x'; // (A)

      // We created a new own property:
      assert.deepEqual(Object.keys(obj), ['objProp', 'protoProp']);

      // The inherited property itself is unchanged:
      assert.equal(proto.protoProp, 'a');

      // The own property overrides the inherited property:
      assert.equal(obj.protoProp, 'x');

   The prototype chain of ``obj`` is depicted in `figure
   30.3 <#fig:oo_overriding>`__.

   .. figure:: https://exploringjs.com/js/book/img-book/objects/oo_overriding.svg
      name: fig:oo_overriding
      :width: 119px
      :height: 221px

      Figure 30.3: The own property ``.protoProp`` of ``obj`` overrides the
      property inherited from ``proto``.



.. _tips-for-working-with-prototypes:

30.10.3â€ƒTips for working with prototypes (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. _get-set-prototype:

30.10.3.1â€ƒGetting and setting prototypes
'''''''''''''''''''''''''''''''''''''''''

   Recommendations for ``__proto__``:

   -  Donâ€™t use ``__proto__`` as a pseudo-property (a setter of all instances of
      ``Object``):

      -  It canâ€™t be used with all objects (e.g. objects that are not instances of
         ``Object``).
      -  The language specification has deprecated it.

      For more information on this feature see `â€œ\ ``Object.prototype.__proto__``
      (accessor)â€ (Â§31.8.8) <#Object.prototype.__proto__>`__.

   -  Using ``__proto__`` in object literals to set prototypes is different: Itâ€™s a
      feature of object literals that has no pitfalls.

   The recommended ways of getting and setting prototypes are:

   -  Getting the prototype of an object:

      .. code:: javascript
         :name: language-ts

         Object.getPrototypeOf(obj: Object) : Object

   -  The best time to set the prototype of an object is when we are creating it.
      We can do so via ``__proto__`` in an object literal or via:

      .. code:: javascript
         :name: language-ts

         Object.create(proto: Object) : Object

      If we have to, we can use ``Object.setPrototypeOf()`` to change the prototype
      of an existing object. But that may affect performance negatively.

   This is how these features are used:

   .. code:: javascript

      const proto1 = {};
      const proto2a = {};
      const proto2b = {};

      const obj1 = {
      __proto__: proto1,
      };
      assert.equal(Object.getPrototypeOf(obj1), proto1);

      const obj2 = Object.create(proto2a);
      assert.equal(Object.getPrototypeOf(obj2), proto2a);

      Object.setPrototypeOf(obj2, proto2b);
      assert.equal(Object.getPrototypeOf(obj2), proto2b);



.. _check-if-object-in-prototype-chain:

30.10.3.2â€ƒChecking if an object is in the prototype chain of another object
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   So far, â€œ\ ``proto`` is a prototype of ``obj``\ â€ always meant â€œ\ ``proto`` is a
   *direct* prototype of ``obj``\ â€. But it can also be used more loosely and mean
   that ``proto`` is in the prototype chain of ``obj``. That looser relationship
   can be checked via ``.isPrototypeOf()``:

   For example:

   .. code:: javascript

      const a = {};
      const b = {__proto__: a};
      const c = {__proto__: b};

      assert.equal(a.isPrototypeOf(b), true);
      assert.equal(a.isPrototypeOf(c), true);

      assert.equal(c.isPrototypeOf(a), false);
      assert.equal(a.isPrototypeOf(a), false);

   For more information on this method see
   `â€œ\ ``Object.prototype.isPrototypeOf()``\ â€
   (Â§31.8.6) <#Object.prototype.isPrototypeOf>`__.



.. _Object.hasOwn:

30.10.4â€ƒ``Object.hasOwn()``: Is a given property own (non-inherited)? [ES2022]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The ``in`` operator (line A) checks if an object has a given property. In
   contrast, ``Object.hasOwn()`` (lines B and C) checks if a property is own.

   .. code:: javascript

      const proto = {
      protoProp: 'protoProp',
      };
      const obj = {
      __proto__: proto,
      objProp: 'objProp',
      }
      assert.equal('protoProp' in obj, true); // (A)
      assert.equal(Object.hasOwn(obj, 'protoProp'), false); // (B)
      assert.equal(Object.hasOwn(proto, 'protoProp'), true); // (C)

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Alternative before ES2022: ``.hasOwnProperty()``**

      .. container:: boxout-vspace

      Before ES2022, we can use another feature:
      `â€œ\ ``Object.prototype.hasOwnProperty()``\ â€
      (Â§31.8.9) <#Object.prototype.hasOwnProperty>`__. This feature
      has pitfalls, but the referenced section explains how to work around them.

30.10.5â€ƒSharing data via prototypes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Consider the following code:

   .. code:: javascript

      const jane = {
      firstName: 'Jane',
      describe() {
         return 'Person named '+this.firstName;
      },
      };
      const tarzan = {
      firstName: 'Tarzan',
      describe() {
         return 'Person named '+this.firstName;
      },
      };

      assert.equal(jane.describe(), 'Person named Jane');
      assert.equal(tarzan.describe(), 'Person named Tarzan');

   We have two objects that are very similar. Both have two properties whose names
   are ``.firstName`` and ``.describe``. Additionally, method ``.describe()`` is
   the same. How can we avoid duplicating that method?

   We can move it to an object ``PersonProto`` and make that object a prototype of
   both ``jane`` and ``tarzan``:

   .. code:: javascript

      const PersonProto = {
      describe() {
         return 'Person named ' + this.firstName;
      },
      };
      const jane = {
      __proto__: PersonProto,
      firstName: 'Jane',
      };
      const tarzan = {
      __proto__: PersonProto,
      firstName: 'Tarzan',
      };

   The name of the prototype reflects that both ``jane`` and ``tarzan`` are
   persons.

   .. figure:: https://exploringjs.com/js/book/img-book/objects/oo_person_shared.svg
      name: fig:oo_person_shared
      :width: 328px
      :height: 139px

      Figure 30.4: Objects ``jane`` and ``tarzan`` share method ``.describe()``,
      via their common prototype ``PersonProto``.

   `Figure 30.4 <#fig:oo_person_shared>`__ illustrates how the three objects are
   connected: The objects at the bottom now contain the properties that are
   specific to ``jane`` and ``tarzan``. The object at the top contains the
   properties that are shared between them.

   When we make the method call ``jane.describe()``, ``this`` points to the
   receiver of that method call, ``jane`` (in the bottom-left corner of the
   diagram). Thatâ€™s why the method still works. ``tarzan.describe()`` works
   similarly.

   .. code:: javascript

      assert.equal(jane.describe(), 'Person named Jane');
      assert.equal(tarzan.describe(), 'Person named Tarzan');

   Looking ahead to the next chapter on classes â€“ this is how classes are organized
   internally:

   -  All instances share a common prototype with methods.
   -  Instance-specific data is stored in own properties in each instance.

   `â€œThe internals of classesâ€ (Â§31.3) <#internals-of-classes>`__
   explains this in more detail.

30.11â€ƒFAQ: objects
-------------------

30.11.1â€ƒWhy do objects preserve the insertion order of properties?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In principle, objects are unordered. The main reason for ordering properties is
   so that operations that list entries, keys, or values are deterministic. That
   helps, e.g., with testing.



.. _quickref-object-api:

30.12â€ƒQuick reference: ``Object``
----------------------------------



.. _object-creating-objects-handling-prototypes:

30.12.1â€ƒ``Object.*``: creating objects, handling prototypes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Object.create(proto, propDescObj?)`` :sup:`[ES5]`

      -  Returns a new object whose prototype is ``proto``.
      -  The optional ``propDescObj`` is an object with `property
         descriptors <#property-attributes-property-descriptors>`__ that is used to
         define properties in the new object.

      .. code:: javascript
         :name: language-node-repl

         > const obj = Object.create(null);
         > Object.getPrototypeOf(obj)
         null

      In the following example, we define own properties via the second parameter:

      .. code:: javascript

         const obj = Object.create(
         null,
         {
            color: {
               value: 'green',
               writable: true,
               enumerable: true,
               configurable: true,
            },
         }
         );
         assert.deepEqual(
         obj,
         {
            __proto__: null,
            color: 'green',
         }
         );

   -  ``Object.getPrototypeOf(obj)`` :sup:`[ES5]`

      Return the prototype of ``obj`` â€“ which is either an object or ``null``.

      .. code:: javascript

         assert.equal(
         Object.getPrototypeOf({__proto__: null}), null
         );
         assert.equal(
         Object.getPrototypeOf({}), Object.prototype
         );
         assert.equal(
         Object.getPrototypeOf(Object.prototype), null
         );

   -  ``Object.setPrototypeOf(obj, proto)`` :sup:`[ES6]`

      Sets the prototype of ``obj`` to ``proto`` (which must be ``null`` or an
      object) and returns the former.

      .. code:: javascript

         const obj = {};
         assert.equal(
         Object.getPrototypeOf(obj), Object.prototype
         );
         Object.setPrototypeOf(obj, null);
         assert.equal(
         Object.getPrototypeOf(obj), null
         );



.. _object-property-attributes:

30.12.2â€ƒ``Object.*``: property attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Object.defineProperty(obj, propKey, propDesc)`` :sup:`[ES5]`

      -  Defines one property in ``obj``, as specified by the property key
         ``propKey`` and the `property
         descriptor <#property-attributes-property-descriptors>`__ ``propDesc``.
      -  Returns ``obj``.

      .. code:: javascript

         const obj = {};
         Object.defineProperty(
         obj, 'color',
         {
            value: 'green',
            writable: true,
            enumerable: true,
            configurable: true,
         }
         );
         assert.deepEqual(
         obj,
         {
            color: 'green',
         }
         );

   -  ``Object.defineProperties(obj, propDescObj)`` :sup:`[ES5]`

      -  Defines properties in ``obj``, as specified by the object ``propDescObj``
         with `property descriptors <#property-attributes-property-descriptors>`__.
      -  Returns ``obj``.

      .. code:: javascript

         const obj = {};
         Object.defineProperties(
         obj,
         {
            color: {
               value: 'green',
               writable: true,
               enumerable: true,
               configurable: true,
            },
         }
         );
         assert.deepEqual(
         obj,
         {
            color: 'green',
         }
         );

   -  ``Object.getOwnPropertyDescriptor(obj, propKey)`` :sup:`[ES5]`

      -  Returns a property descriptor for the own property of ``obj`` whose key is
         ``propKey``. If no such property exists, it returns ``undefined``.
      -  More information on property descriptors: `â€œProperty attributes and
         property descriptorsâ€
         (Â§30.8) <#property-attributes-property-descriptors>`__

      .. code:: javascript
         :name: language-node-repl

         > Object.getOwnPropertyDescriptor({a: 1, b: 2}, 'a')
         { value: 1, writable: true, enumerable: true, configurable: true }
         > Object.getOwnPropertyDescriptor({a: 1, b: 2}, 'x')
         undefined

   -  ``Object.getOwnPropertyDescriptors(obj)`` :sup:`[ES2017]`

      -  Returns an object with property descriptors, one for each own property of
         ``obj``.
      -  More information on property descriptors: `â€œProperty attributes and
         property descriptorsâ€
         (Â§30.8) <#property-attributes-property-descriptors>`__

      .. code:: javascript
         :name: language-node-repl

         > Object.getOwnPropertyDescriptors({a: 1, b: 2})
         {
         a: { value: 1, writable: true, enumerable: true, configurable: true },
         b: { value: 2, writable: true, enumerable: true, configurable: true },
         }



.. _object-property-keys-values-entries:

30.12.3â€ƒ``Object.*``: property keys, values, entries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Object.keys(obj)`` :sup:`[ES5]`

      Returns an Array with all own enumerable property keys that are strings.

      .. code:: javascript

         const enumSymbolKey = Symbol('enumSymbolKey');
         const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');

         const obj = Object.defineProperties(
         {},
         {
            enumStringKey: {
               value: 1, enumerable: true,
            },
            [enumSymbolKey]: {
               value: 2, enumerable: true,
            },
            nonEnumStringKey: {
               value: 3, enumerable: false,
            },
            [nonEnumSymbolKey]: {
               value: 4, enumerable: false,
            },
         }
         );
         assert.deepEqual(
         Object.keys(obj),
         ['enumStringKey']
         );

   -  ``Object.getOwnPropertyNames(obj)`` :sup:`[ES5]`

      Returns an Array with all own property keys that are strings (enumerable and
      non-enumerable ones).

      .. code:: javascript

         const enumSymbolKey = Symbol('enumSymbolKey');
         const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');

         const obj = Object.defineProperties(
         {},
         {
            enumStringKey: {
               value: 1, enumerable: true,
            },
            [enumSymbolKey]: {
               value: 2, enumerable: true,
            },
            nonEnumStringKey: {
               value: 3, enumerable: false,
            },
            [nonEnumSymbolKey]: {
               value: 4, enumerable: false,
            },
         }
         );
         assert.deepEqual(
         Object.getOwnPropertyNames(obj),
         ['enumStringKey', 'nonEnumStringKey']
         );

   -  ``Object.getOwnPropertySymbols(obj)`` :sup:`[ES6]`

      Returns an Array with all own property keys that are symbols (enumerable and
      non-enumerable ones).

      .. code:: javascript

         const enumSymbolKey = Symbol('enumSymbolKey');
         const nonEnumSymbolKey = Symbol('nonEnumSymbolKey');

         const obj = Object.defineProperties(
         {},
         {
            enumStringKey: {
               value: 1, enumerable: true,
            },
            [enumSymbolKey]: {
               value: 2, enumerable: true,
            },
            nonEnumStringKey: {
               value: 3, enumerable: false,
            },
            [nonEnumSymbolKey]: {
               value: 4, enumerable: false,
            },
         }
         );
         assert.deepEqual(
         Object.getOwnPropertySymbols(obj),
         [enumSymbolKey, nonEnumSymbolKey]
         );

   -  ``Object.values(obj)`` :sup:`[ES2017]`

      Returns an Array with the values of all enumerable own string-keyed
      properties.

      .. code:: javascript
         :name: language-node-repl

         > Object.values({a: 1, b: 2})
         [ 1, 2 ]

   -  ``Object.entries(obj)`` :sup:`[ES2017]`

      -  Returns an Array with one key-value pair (encoded as a two-element Array)
         per property of ``obj``.
      -  Only own enumerable properties with string keys are included.
      -  Inverse operation: `Object.fromEntries() <#qref-Object.fromEntries>`__

      .. code:: javascript

         const obj = {
         a: 1,
         b: 2,
         [Symbol('myKey')]: 3,
         };
         assert.deepEqual(
         Object.entries(obj),
         [
            ['a', 1],
            ['b', 2],
            // Property with symbol key is ignored
         ]
         );

   -  ``Object.fromEntries(keyValueIterable)`` :sup:`[ES2019]`

      -  Creates an object whose own properties are specified by
         ``keyValueIterable``.
      -  Inverse operation: `Object.entries() <#qref-Object.entries>`__

      .. code:: javascript
         :name: language-node-repl

         > Object.fromEntries([['a', 1], ['b', 2]])
         { a: 1, b: 2 }

   -  ``Object.hasOwn(obj, key)`` :sup:`[ES2022]`

      -  Returns ``true`` if ``obj`` has an own property whose key is ``key``. If
         not, it returns ``false``.

      .. code:: javascript
         :name: language-node-repl

         > Object.hasOwn({a: 1, b: 2}, 'a')
         true
         > Object.hasOwn({a: 1, b: 2}, 'x')
         false



.. _object-protecting-objects:

30.12.4â€ƒ``Object.*``: protecting objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   More information: `â€œProtecting objects from being changedâ€
   (Â§30.9) <#protecting-objects>`__

   -  ``Object.preventExtensions(obj)`` :sup:`[ES5]`

      -  Makes ``obj`` non-extensible and returns it.
      -  Effect:

         -  ``obj`` is non-extensible: We canâ€™t add properties or change its
            prototype.

      -  Only the top level of ``obj`` is changed (shallow change). Nested objects
         are not affected.
      -  Related: `Object.isExtensible() <#qref-Object.isExtensible>`__

   -  ``Object.isExtensible(obj)`` :sup:`[ES5]`

      -  Returns ``true`` if ``obj`` is extensible and ``false`` if it isnâ€™t.
      -  Related:
         `Object.preventExtensions() <#qref-Object.preventExtensions>`__

   -  ``Object.seal(obj)`` :sup:`[ES5]`

      -  Seals ``obj`` and returns it.
      -  Effect:

         -  ``obj`` is non-extensible: We canâ€™t add properties or change its
            prototype.
         -  ``obj`` is sealed: Additionally, all of its properties are
            unconfigurable.

      -  Only the top level of ``obj`` is changed (shallow change). Nested objects
         are not affected.
      -  Related: `Object.isSealed() <#qref-Object.isSealed>`__

   -  ``Object.isSealed(obj)`` :sup:`[ES5]`

      -  Returns ``true`` if ``obj`` is sealed and ``false`` if it isnâ€™t.
      -  Related: `Object.seal() <#qref-Object.seal>`__

   -  ``Object.freeze(obj)`` :sup:`[ES5]`

      -  Freezes ``obj`` and returns it.
      -  Effect:

         -  ``obj`` is non-extensible: We canâ€™t add properties or change its
            prototype.
         -  ``obj`` is sealed: Additionally, all of its properties are
            unconfigurable.
         -  ``obj`` is frozen: Additionally, all of its properties are
            non-writable.

      -  Only the top level of ``obj`` is changed (shallow change). Nested objects
         are not affected.
      -  Related: `Object.isFrozen() <#qref-Object.isFrozen>`__

      .. code:: javascript

         const frozen = Object.freeze({ x: 2, y: 5 });
         assert.equal(
         Object.isFrozen(frozen), true
         );
         assert.throws(
         () => frozen.x = 7,
         {
            name: 'TypeError',
            message: /^Cannot assign to read only property 'x'/,
         }
         );

   -  ``Object.isFrozen(obj)`` :sup:`[ES5]`

      -  Returns ``true`` if ``obj`` is frozen.
      -  Related: `Object.freeze() <#qref-Object.freeze>`__



.. _object-miscellaneous:

30.12.5â€ƒ``Object.*``: miscellaneous
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Object.assign(target, ...sources)`` :sup:`[ES6]`

      Assigns all enumerable own string-keyed properties of each of the ``sources``
      to ``target`` and returns ``target``.

      .. code:: javascript
         :name: language-node-repl

         > const obj = {a: 1, b: 1};
         > Object.assign(obj, {b: 2, c: 2}, {d: 3})
         { a: 1, b: 2, c: 2, d: 3 }
         > obj
         { a: 1, b: 2, c: 2, d: 3 }

   -  ``Object.groupBy(items, computeGroupKey)`` :sup:`[ES2024]`

      .. code:: javascript
         :name: language-ts

         Object.groupBy<K extends PropertyKey, T>(
         items: Iterable<T>,
         computeGroupKey: (item: T, index: number) => K,
         ): {[key: K]: Array<T>}

      -  The callback ``computeGroupKey`` returns a *group key* for each of the
         ``items``.
      -  The result of ``Object.groupBy()`` is an object where:

         -  The key of each property is a group key and
         -  its value is an Array with all items that have that group key.

      .. code:: javascript

         assert.deepEqual(
         Object.groupBy(
            ['orange', 'apricot', 'banana', 'apple', 'blueberry'],
            (str) => str[0] // compute group key
         ),
         {
            __proto__: null,
            'o': ['orange'],
            'a': ['apricot', 'apple'],
            'b': ['banana', 'blueberry'],
         }
         );

   -  ``Object.is(value1, value2)`` :sup:`[ES6]`

      Is mostly equivalent to ``value1 === value2``Â â€“ with two exceptions:

      .. code:: javascript
         :name: language-node-repl

         > NaN === NaN
         false
         > Object.is(NaN, NaN)
         true

         > -0 === 0
         true
         > Object.is(-0, 0)
         false

      -  Considering all ``NaN`` values to be equal can be useful â€“ e.g., when
         searching for a value in an Array.
      -  The value ``-0`` is rare and itâ€™s usually best to pretend it is the same
         as ``0``.



.. _object-prototype:

30.12.6â€ƒ``Object.prototype.*``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``Object.prototype`` has the following properties:

   -  ``Object.prototype.__proto__`` (getter and setter)
   -  ``Object.prototype.hasOwnProperty()``
   -  ``Object.prototype.isPrototypeOf()``
   -  ``Object.prototype.propertyIsEnumerable()``
   -  ``Object.prototype.toLocaleString()``
   -  ``Object.prototype.toString()``
   -  ``Object.prototype.valueOf()``

   These methods are explained in detail in `â€œQuick reference:
   ``Object.prototype.*``\ â€
   (Â§31.8.1) <#quickref-object-prototype>`__.



.. _quickref-reflect:

30.13â€ƒQuick reference: ``Reflect``
-----------------------------------

   ``Reflect`` provides functionality for `JavaScript
   proxies <https://exploringjs.com/deep-js/ch_proxies.html>`__ that is also
   occasionally useful elsewhere:

   -  ``Reflect.apply(target, thisArgument, argumentsList)``

      -  Invokes ``target`` with the arguments provided by ``argumentsList`` and
         ``this`` set to ``thisArgument``.
      -  Equivalent to ``target.apply(thisArgument, argumentsList)``

   -  ``Reflect.construct(target, argumentsList, newTarget=target)``

      -  The ``new`` operator as a function.
      -  ``target`` is the constructor to invoke.
      -  The optional parameter ``newTarget`` points to the constructor that
         started the current chain of constructor calls.

   -  ``Reflect.defineProperty(target, propertyKey, propDesc)``

      -  Similar to ``Object.defineProperty()``.
      -  Returns a boolean indicating whether or not the operation succeeded.

   -  ``Reflect.deleteProperty(target, propertyKey)``

      The ``delete`` operator as a function. It works slightly differently, though:

      -  It returns ``true`` if it successfully deleted the property or if the
         property never existed.
      -  It returns ``false`` if the property could not be deleted and still
         exists.

      In sloppy mode, the ``delete`` operator returns the same results as this
      method. But in strict mode, it throws a ``TypeError`` instead of returning
      ``false``.

      The only way to protect properties from deletion is by making them
      non-configurable.

   -  ``Reflect.get(target, propertyKey, receiver=target)``

      A function that gets properties. The optional parameter ``receiver`` is
      needed if ``get`` reaches a getter (somewhere in the prototype chain). Then
      it provides the value for ``this``.

   -  ``Reflect.getOwnPropertyDescriptor(target, propertyKey)``

      Same as ``Object.getOwnPropertyDescriptor()``.

   -  ``Reflect.getPrototypeOf(target)``

      Same as ``Object.getPrototypeOf()``.

   -  ``Reflect.has(target, propertyKey)``

      The ``in`` operator as a function.

   -  ``Reflect.isExtensible(target)``

      Same as ``Object.isExtensible()``.

   -  ``Reflect.ownKeys(target)``

      Returns all own property keys (strings and symbols) in an Array.

   -  ``Reflect.preventExtensions(target)``

      -  Similar to ``Object.preventExtensions()``.
      -  Returns a boolean indicating whether or not the operation succeeded.

   -  ``Reflect.set(target, propertyKey, value, receiver=target)``

      -  Sets properties.
      -  Returns a boolean indicating whether or not the operation succeeded.

   -  ``Reflect.setPrototypeOf(target, proto)``

      -  Same as ``Object.setPrototypeOf()``.
      -  Returns a boolean indicating whether or not the operation succeeded.



.. _reflect-vs-object:

30.13.1â€ƒ``Reflect.*`` vs. ``Object.*``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   General recommendations:

   -  Use ``Object.*`` whenever you can.
   -  Use ``Reflect.*`` when working with `ECMAScript
      proxies <https://exploringjs.com/deep-js/ch_proxies.html>`__. Its methods are
      well adapted to ECMAScriptâ€™s meta-object protocol (MOP) which also return
      boolean error flags instead of exceptions.

   What are use cases for ``Reflect`` beyond proxies?

   -  ``Reflect.ownKeys()`` lists all own property keys â€“ functionality that isnâ€™t
      provided anywhere else.

   -  Same functionality as ``Object`` but different return values: ``Reflect``
      duplicates the following methods of ``Object``, but its methods return
      booleans indicating whether the operation succeeded (where the ``Object``
      methods return the object that was modified).

      -  ``Object.defineProperty(obj, propKey, propDesc)``
      -  ``Object.preventExtensions(obj)``
      -  ``Object.setPrototypeOf(obj, proto)``

   -  Operators as functions: The following ``Reflect`` methods implement
      functionality that is otherwise only available via operators:

      -  ``Reflect.construct(target, argumentsList, newTarget=target)``
      -  ``Reflect.deleteProperty(target, propertyKey)``
      -  ``Reflect.get(target, propertyKey, receiver=target)``
      -  ``Reflect.has(target, propertyKey)``
      -  ``Reflect.set(target, propertyKey, value, receiver=target)``

   -  Shorter version of ``apply()``: If we want to be completely safe about
      invoking the method ``apply()`` on a function, we canâ€™t do so via dynamic
      dispatch, because the function may have an own property with the key
      ``'apply'``:

      .. code:: javascript

         func.apply(thisArg, argArray) // not safe
         Function.prototype.apply.call(func, thisArg, argArray) // safe

      Using ``Reflect.apply()`` is shorter:

      .. code:: javascript

         Reflect.apply(func, thisArg, argArray)

   -  No exceptions when deleting properties: the ``delete`` operator throws in
      strict mode if we try to delete a non-configurable own property.
      ``Reflect.deleteProperty()`` returns ``false`` in that case.

   `Comments <https://github.com/rauschma/exploring-js/issues/18>`__



.. _ch_classes:

31â€ƒClasses [ES6]
=================

   #. `31.1â€ƒCheat sheet: classes <#cheat-sheet-classes>`__
   #. `31.2â€ƒThe essentials of classes <#classes>`__

      #. `31.2.1â€ƒA class for persons <#a-class-for-persons>`__
      #. `31.2.2â€ƒClass expressions <#class-expressions>`__
      #. `31.2.3â€ƒThe instanceof operator <#the-instanceof-operator>`__
      #. `31.2.4â€ƒPublic slots (properties) vs. private slots <#private-slots>`__
      #. `31.2.5â€ƒPrivate slots in more detail [ES2022] (advanced) <#private-slots-in-more-detail>`__
      #. `31.2.6â€ƒThe pros and cons of classes in JavaScript <#the-pros-and-cons-of-classes-in-javascript>`__
      #. `31.2.7â€ƒTips for using classes <#tips-for-using-classes>`__

   #. `31.3â€ƒThe internals of classes <#internals-of-classes>`__

      #. `31.3.1â€ƒA class is actually two connected objects <#a-class-is-actually-two-connected-objects>`__
      #. `31.3.2â€ƒClasses set up the prototype chains of their instances <#classes-set-up-the-prototype-chains-of-their-instances>`__
      #. `31.3.3â€ƒ.__proto__ vs. .prototype <#proto-vs-prototype>`__
      #. `31.3.4â€ƒPerson.prototype.constructor (advanced) <#person-prototype-constructor>`__
      #. `31.3.5â€ƒDispatched vs. direct method calls (advanced) <#method-calls-dispatched-direct>`__
      #. `31.3.6â€ƒClasses evolved from ordinary functions (advanced) <#classes-evolved-from-ordinary-functions>`__

   #. `31.4â€ƒPrototype members of classes <#prototype-members-of-classes>`__

      #. `31.4.1â€ƒPublic prototype methods and accessors <#public-prototype-methods-and-accessors>`__
      #. `31.4.2â€ƒPrivate methods and accessors [ES2022] <#private-methods-accessors>`__

   #. `31.5â€ƒInstance members of classes [ES2022] <#instance-members-of-classes>`__

      #. `31.5.1â€ƒInstance public fields <#instance-public-fields>`__
      #. `31.5.2â€ƒInstance private fields <#instance-private-fields>`__
      #. `31.5.3â€ƒPrivate instance data before ES2022 (advanced) <#private-instance-data-before-es2022>`__
      #. `31.5.4â€ƒSimulating protected visibility and friend visibility via WeakMaps (advanced) <#instance-protected-fields>`__

   #. `31.6â€ƒStatic members of classes <#static-members-of-classes>`__

      #. `31.6.1â€ƒStatic public methods and accessors <#static-public-methods-and-accessors>`__
      #. `31.6.2â€ƒStatic public fields [ES2022] <#static-public-fields>`__
      #. `31.6.3â€ƒStatic private methods, accessors, and fields [ES2022] <#static-private-methods-accessors-fields>`__
      #. `31.6.4â€ƒStatic initialization blocks in classes [ES2022] <#class-static-initialization-blocks>`__
      #. `31.6.5â€ƒPitfall: Using this to access static private fields <#this-and-static-private-fields>`__
      #. `31.6.6â€ƒAll members (static, prototype, instance) can access all private members <#all-members-static-prototype-instance-can-access-all-private-members>`__
      #. `31.6.7â€ƒStatic private methods and data before ES2022 <#static-private-methods-and-data-before-es2022>`__
      #. `31.6.8â€ƒStatic factory methods <#static-factory-methods>`__

   #. `31.7â€ƒSubclassing <#subclassing>`__

      #. `31.7.1â€ƒThe internals of subclassing (advanced) <#the-internals-of-subclassing>`__
      #. `31.7.2â€ƒinstanceof and subclassing (advanced) <#instanceof-operator>`__
      #. `31.7.3â€ƒNot all objects are instances of Object (advanced) <#non-instances-of-object>`__
      #. `31.7.4â€ƒPrototype chains of built-in objects (advanced) <#prototype-chains-of-built-ins>`__
      #. `31.7.5â€ƒMixin classes (advanced) <#mixin-classes>`__

   #. `31.8â€ƒThe methods and accessors of Object.prototype (advanced) <#the-methods-and-accessors-of-object-prototype>`__

      #. `31.8.1â€ƒQuick reference: Object.prototype.* <#quickref-object-prototype>`__
      #. `31.8.2â€ƒUsing Object.prototype methods safely <#using-object-methods-safely>`__
      #. `31.8.3â€ƒObject.prototype.toString() <#Object.prototype.toString>`__
      #. `31.8.4â€ƒObject.prototype.toLocaleString() <#Object.prototype.toLocaleString>`__
      #. `31.8.5â€ƒObject.prototype.valueOf() <#Object.prototype.valueOf>`__
      #. `31.8.6â€ƒObject.prototype.isPrototypeOf() <#Object.prototype.isPrototypeOf>`__
      #. `31.8.7â€ƒObject.prototype.propertyIsEnumerable() <#Object.prototype.propertyIsEnumerable>`__
      #. `31.8.8â€ƒObject.prototype.__proto__ (accessor) <#Object.prototype.__proto__>`__
      #. `31.8.9â€ƒObject.prototype.hasOwnProperty() <#Object.prototype.hasOwnProperty>`__

   #. `31.9â€ƒFAQ: classes <#faq-classes>`__

      #. `31.9.1â€ƒWhy are they called â€œinstance private fieldsâ€ in this book and not â€œprivate instance fieldsâ€? <#why-are-they-called-instance-private-fields-in-this-book-and-not-private-instance-fields>`__
      #. `31.9.2â€ƒWhy the identifier prefix #? Why not declare private fields via private? <#why-the-identifier-prefix-why-not-declare-private-fields-via-private>`__

   In this book, JavaScriptâ€™s style of object-oriented programming (OOP) is
   introduced in four steps. This chapter covers step 3 and 4, `the previous
   chapter <#ch_objects>`__ covers step 1 and 2. The steps are
   (`figure 31.1 <#fig:oop_steps_3_4>`__):

   #. **Single objects (previous chapter):** How do *objects*, JavaScriptâ€™s basic
      OOP building blocks, work in isolation?
   #. **Prototype chains (previous chapter):** Each object has a chain of zero or
      more *prototype objects*. Prototypes are JavaScriptâ€™s core inheritance
      mechanism.
   #. **Classes (this chapter):** JavaScriptâ€™s *classes* are factories for objects.
      The relationship between a class and its instances is based on prototypal
      inheritance (step 2).
   #. **Subclassing (this chapter):** The relationship between a *subclass* and its
      *superclass* is also based on prototypal inheritance.

   .. figure:: https://exploringjs.com/js/book/img-book/classes/oop_steps_3_4.svg
      name: fig:oop_steps_3_4
      :width: 364px
      :height: 154px

      Figure 31.1: This book introduces object-oriented programming in JavaScript
      in four steps.

31.1â€ƒCheat sheet: classes
--------------------------

   A JavaScript class:

   .. code:: javascript

      class Person {
      constructor(firstName) { // (A)
         this.firstName = firstName; // (B)
      }
      describe() { // (C)
         return 'Person named ' + this.firstName;
      }
      }
      const tarzan = new Person('Tarzan');
      assert.equal(
      tarzan.firstName, 'Tarzan'
      );
      assert.equal(
      tarzan.describe(),
      'Person named Tarzan'
      );
      // One property (public slot)
      assert.deepEqual(
      Reflect.ownKeys(tarzan), ['firstName']
      );

   Explanations:

   -  Inside a class, ``this`` refers to the current instance
   -  Line A: constructor of the class
   -  Line B: Property ``.firstName`` (a public slot) is created (no prior
      declaration necessary).
   -  Line C: method ``.describe()``

   Public instance data such as ``.firstName`` is relatively common in JavaScript.

   The same class ``Person``, but with private instance data:

   .. code:: javascript

      class Person {
      #firstName; // (A)
      constructor(firstName) {
         this.#firstName = firstName; // (B)
      }
      describe() {
         return 'Person named ' + this.#firstName;
      }
      }
      const tarzan = new Person('Tarzan');
      assert.equal(
      tarzan.describe(),
      'Person named Tarzan'
      );
      // No properties, only a private field
      assert.deepEqual(
      Reflect.ownKeys(tarzan), []
      );

   Explanations:

   -  Line A: private field ``.#firstName``. In contrast to properties, private
      fields must be declared (line A) before they can be used (line B). A private
      field can only be accessed inside the class that declares it. It canâ€™t even
      be accessed by subclasses.

   Class ``Employee`` is a subclass of ``Person``:

   .. code:: javascript

      class Employee extends Person {
      #title;

      constructor(firstName, title) {
         super(firstName); // (A)
         this.#title = title;
      }
      describe() {
         return `${super.describe()} (${this.#title})`; // (B)
      }
      }

      const jane = new Employee('Jane', 'CTO');
      assert.equal(
      jane.describe(),
      'Person named Jane (CTO)'
      );

   -  Line A: In subclasses, we can omit the constructor. If we donâ€™t, we have to
      call ``super()``.
   -  Line B: We can refer to overridden methods via ``super``.

   The next class demonstrates how to create properties via *public fields* (line
   A):

   .. code:: javascript

      class StringBuilderClass {
      string = ''; // (A)
      add(str) {
         this.string += str;
         return this;
      }
      }

      const sb = new StringBuilderClass();
      sb.add('Hello').add(' everyone').add('!');
      assert.equal(
      sb.string, 'Hello everyone!'
      );

   JavaScript also supports ``static`` members, but external functions and
   variables are often preferred.



.. _classes:

31.2â€ƒThe essentials of classes
-------------------------------

   Classes are basically a compact syntax for setting up prototype chains (which
   are explained in `the previous chapter <#prototype-chains>`__).
   Under the hood, JavaScriptâ€™s classes are unconventional. But that is something
   we rarely see when working with them. They should normally feel familiar to
   people who have used other object-oriented programming languages.

   Note that we donâ€™t need classes to create objects. We can also do so via `object
   literals <#object-literals>`__. Thatâ€™s why the singleton pattern
   isnâ€™t needed in JavaScript and classes are used less than in many other
   languages that have them.

31.2.1â€ƒA class for persons
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `We have previously worked with ``jane`` and ``tarzan``, single objects
   representing persons <#sharing-data-via-prototypes>`__. Letâ€™s use
   a *class declaration* to implement a factory for such objects:

   .. code:: javascript

      class Person {
      #firstName; // (A)
      constructor(firstName) {
         this.#firstName = firstName; // (B)
      }
      describe() {
         return `Person named ${this.#firstName}`;
      }
      static extractNames(persons) {
         return persons.map(person => person.#firstName);
      }
      }

   ``jane`` and ``tarzan`` can now be created via ``new Person()``:

   .. code:: javascript

      const jane = new Person('Jane');
      const tarzan = new Person('Tarzan');

   Letâ€™s examine whatâ€™s inside the body of class ``Person``.

   -  ``.constructor()`` is a special method that is called after the creation of a
      new instance. Inside it, ``this`` refers to that instance.

   -  ``.#firstName`` :sup:`[ES2022]` is an *instance private field*: Such fields
      are stored in instances. They are accessed similarly to properties, but their
      names are separate â€“ they always start with hash symbols (``#``). And they
      are invisible to the world outside the class:

      .. code:: javascript

         assert.deepEqual(
         Reflect.ownKeys(jane),
         []
         );

      Before we can initialize ``.#firstName`` in the constructor (line B), we need
      to declare it by mentioning it in the class body (line A).

   -  ``.describe()`` is a method. If we invoke it via ``obj.describe()`` then
      ``this`` refers to ``obj`` inside the body of ``.describe()``.

      .. code:: javascript

         assert.equal(
         jane.describe(), 'Person named Jane'
         );
         assert.equal(
         tarzan.describe(), 'Person named Tarzan'
         );

   -  ``.extractName()`` is a *static* method. â€œStaticâ€ means that it belongs to
      the class, not to instances:

      .. code:: javascript

         assert.deepEqual(
         Person.extractNames([jane, tarzan]),
         ['Jane', 'Tarzan']
         );

   We can also create instance properties (public fields) in constructors:

   .. code:: javascript

      class Container {
      constructor(value) {
         this.value = value;
      }
      }
      const abcContainer = new Container('abc');
      assert.equal(
      abcContainer.value, 'abc'
      );

   In contrast to instance private fields, instance properties donâ€™t have to be
   declared in class bodies.

31.2.2â€ƒClass expressions
~~~~~~~~~~~~~~~~~~~~~~~~~

   There are two kinds of *class definitions* (ways of defining classes):

   -  *Class declarations*, which we have seen in the previous section.
   -  *Class expressions*, which weâ€™ll see next.

   Class expressions can be anonymous and named:

   .. code:: javascript

      // Anonymous class expression
      const Person = class { Â·Â·Â· };

      // Named class expression
      const Person = class MyClass { Â·Â·Â· };

   The name of a named class expression works similarly to `the name of a named
   function expression <#named-function-expressions>`__: It can
   only be accessed inside the body of a class and stays the same, regardless of
   what the class is assigned to.

31.2.3â€ƒThe ``instanceof`` operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The ``instanceof`` operator tells us if a value is an instance of a given class:

   .. code:: javascript
      :name: language-node-repl

      > new Person('Jane') instanceof Person
      true
      > {} instanceof Person
      false
      > {} instanceof Object
      true
      > [] instanceof Array
      true

   Weâ€™ll explore the ``instanceof`` operator in more detail
   `later <#instanceof-operator>`__, after we have looked at subclassing.



.. _private-slots:

31.2.4â€ƒPublic slots (properties) vs. private slots
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In the JavaScript language, objects can have two kinds of â€œslotsâ€.

   -  *Public slots* (which are are also called *properties*). For example, methods
      are public slots.
   -  *Private slots* :sup:`[ES2022]`. For example, private fields are private
      slots.

   These are the most important rules we need to know about properties and private
   slots:

   -  In classes, we can use public and private versions of fields, methods,
      getters and setters. All of them are slots in objects. Which objects they are
      placed in depends on whether the keyword ``static`` is used and other
      factors.
   -  A getter and a setter that have the same key create a single *accessor* slot.
      An Accessor can also have only a getter or only a setter.
   -  Properties and private slots are very different â€“ for example:

      -  They are stored separately.
      -  Their keys are different. The keys of private slots canâ€™t even be accessed
         directly (see `â€œEach private slot has a unique key (a private name)â€
         (Â§31.2.5.2) <#private-names>`__ later in this chapter).
      -  Properties are inherited from prototypes, private slots arenâ€™t.
      -  Private slots can only be created via classes.

   The following class demonstrates the two kinds of slots. Each of its instances
   has one private field and one property:

   .. code:: javascript

      class MyClass {
      #instancePrivateField = 1;
      instanceProperty = 2;
      getInstanceValues() {
         return [
            this.#instancePrivateField,
            this.instanceProperty,
         ];
      }
      }
      const inst = new MyClass();
      assert.deepEqual(
      inst.getInstanceValues(), [1, 2]
      );

   As expected, outside ``MyClass``, we can only see the property:

   .. code:: javascript

      assert.deepEqual(
      Reflect.ownKeys(inst),
      ['instanceProperty']
      );

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**More information on properties**

      .. container:: boxout-vspace

      This chapter doesnâ€™t cover all details of properties (just the essentials).
      If you want to dig deeper, you can do so in `â€œProperty attributes and
      property descriptorsâ€
      (Â§30.8) <#property-attributes-property-descriptors>`__

   Next, weâ€™ll look at some of the details of private slots.



.. _private-slots-in-more-detail:

31.2.5â€ƒPrivate slots in more detail [ES2022] (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. _private-slots-can-t-be-accessed-in-subclasses:

31.2.5.1â€ƒPrivate slots canâ€™t be accessed in subclasses
'''''''''''''''''''''''''''''''''''''''''''''''''''''''

   A private slot really can only be accessed inside the class that declares it. We
   canâ€™t even access it from a subclass:

   .. code:: javascript

      class SuperClass {
      #superProp = 'superProp';
      }
      class SubClass extends SuperClass {
      getSuperProp() {
         return this.#superProp;
      }
      }
      // SyntaxError: Private field '#superProp'
      // must be declared in an enclosing class

   `Subclassing via ``extends <#subclassing>`__ is explained later in this
   chapter. How to work around this limitation is explained in `â€œSimulating
   protected visibility and friend visibility via WeakMapsâ€
   (Â§31.5.4) <#instance-protected-fields>`__.



.. _private-names:

31.2.5.2â€ƒEach private slot has a unique key (a private name)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Private slots have unique keys that are similar to
   `symbols <#ch_symbols>`__. Consider the following class from
   earlier:

   .. code:: javascript

      class MyClass {
      #instancePrivateField = 1;
      instanceProperty = 2;
      getInstanceValues() {
         return [
            this.#instancePrivateField,
            this.instanceProperty,
         ];
      }
      }

   Internally, the private field of ``MyClass`` is handled roughly like this:

   .. code:: javascript

      let MyClass;
      { // Scope of the body of the class
      const instancePrivateFieldKey = Symbol();
      MyClass = class {
         __PrivateElements__ = new Map([
            [instancePrivateFieldKey, 1],
         ]);
         instanceProperty = 2;
         getInstanceValues() {
            return [
            this.__PrivateElements__.get(instancePrivateFieldKey),
            this.instanceProperty,
            ];
         }
      }
      }

   The value of ``instancePrivateFieldKey`` is called a *private name*. We canâ€™t
   use private names directly in JavaScript, we can only use them indirectly, via
   the fixed identifiers of private fields, private methods, and private accessors.
   Where the fixed identifiers of public slots (such as ``getInstanceValues``) are
   interpreted as string keys, the fixed identifiers of private slots (such as
   ``#instancePrivateField``) refer to private names (similarly to how variable
   names refer to values).

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Private slots in the ECMAScript language specification**

      .. container:: boxout-vspace

      Section `â€œObject Internal Methods and Internal
      Slotsâ€ <https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots>`__
      in the ECMAScript language specification explains how private slots work.
      Search for â€œ\ ``[[PrivateElements]]``\ â€.

31.2.5.3â€ƒPrivate names are statically scoped (like variables)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   A callable entity can only access the name of a private slot if it was born
   inside the scope where the name was declared. However, it doesnâ€™t lose this
   ability if it moves somewhere else later on:

   .. code:: javascript

      class MyClass {
      #privateData = 'hello';
      static createGetter() {
         return (obj) => obj.#privateData; // (A)
      }
      }

      const myInstance = new MyClass();
      const getter = MyClass.createGetter();
      assert.equal(
      getter(myInstance), 'hello' // (B)
      );

   The arrow function ``getter`` was born inside ``MyClass`` (line A), but it can
   still access the private name ``#privateData`` after it left its birth scope
   (line B).

31.2.5.4â€ƒThe same private identifier refers to different private names in different classes
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Because the identifiers of private slots arenâ€™t used as keys, using the same
   identifier in different classes produces different slots (line A and line C):

   .. code:: javascript

      class Color {
      #name; // (A)
      constructor(name) {
         this.#name = name; // (B)
      }
      static getName(obj) {
         return obj.#name;
      }
      }
      class Person {
      #name; // (C)
      constructor(name) {
         this.#name = name;
      }
      }

      assert.equal(
      Color.getName(new Color('green')), 'green'
      );

      // We canâ€™t access the private slot #name of a Person in line B:
      assert.throws(
      () => Color.getName(new Person('Jane')),
      {
         name: 'TypeError',
         message: 'Cannot read private member #name from'
            + ' an object whose class did not declare it',
      }
      );

31.2.5.5â€ƒThe names of private fields never clash
'''''''''''''''''''''''''''''''''''''''''''''''''

   Even if a subclass uses the same name for a private field, the two names never
   clash because they refer to private names (which are always unique). In the
   following example, ``.#privateField`` in ``SuperClass`` does not clash with
   ``.#privateField`` in ``SubClass``, even though both slots are stored directly
   in ``inst``:

   .. code:: javascript

      class SuperClass {
      #privateField = 'super';
      getSuperPrivateField() {
         return this.#privateField;
      }
      }
      class SubClass extends SuperClass {
      #privateField = 'sub';
      getSubPrivateField() {
         return this.#privateField;
      }
      }
      const inst = new SubClass();
      assert.equal(
      inst.getSuperPrivateField(), 'super'
      );
      assert.equal(
      inst.getSubPrivateField(), 'sub'
      );

   `Subclassing via ``extends <#subclassing>`__ is explained later in this
   chapter.



.. _private-slot-checks:

31.2.5.6â€ƒUsing ``in`` to check if an object has a given private slot
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The ``in`` operator can be used to check if a private slot exists (line A):

   .. code:: javascript

      class Color {
      #name;
      constructor(name) {
         this.#name = name;
      }
      static check(obj) {
         return #name in obj; // (A)
      }
      }

   Letâ€™s look at more examples of ``in`` applied to private slots.

   **Private methods.** The following code shows that private methods create
   private slots in instances:

   .. code:: javascript

      class C1 {
      #priv() {}
      static check(obj) {
         return #priv in obj;
      }
      }
      assert.equal(C1.check(new C1()), true);

   **Static private fields.** We can also use ``in`` for a static private field:

   .. code:: javascript

      class C2 {
      static #priv = 1;
      static check(obj) {
         return #priv in obj;
      }
      }
      assert.equal(C2.check(C2), true);
      assert.equal(C2.check(new C2()), false);

   **Static private methods.** And we can check for the slot of a static private
   method:

   .. code:: javascript

      class C3 {
      static #priv() {}
      static check(obj) {
         return #priv in obj;
      }
      }
      assert.equal(C3.check(C3), true);

   **Using the same private identifier in different classes.** In the next example,
   the two classes ``Color`` and ``Person`` both have a slot whose identifier is
   ``#name``. The ``in`` operator distinguishes them correctly:

   .. code:: javascript

      class Color {
      #name;
      constructor(name) {
         this.#name = name;
      }
      static check(obj) {
         return #name in obj;
      }
      }
      class Person {
      #name;
      constructor(name) {
         this.#name = name;
      }
      static check(obj) {
         return #name in obj;
      }
      }

      // Detecting Colorâ€™s #name
      assert.equal(
      Color.check(new Color()), true
      );
      assert.equal(
      Color.check(new Person()), false
      );

      // Detecting Personâ€™s #name
      assert.equal(
      Person.check(new Person()), true
      );
      assert.equal(
      Person.check(new Color()), false
      );

31.2.6â€ƒThe pros and cons of classes in JavaScript
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   I recommend using classes for the following reasons:

   -  Classes are a common standard for object creation and inheritance that is now
      widely supported across libraries and frameworks. This is an improvement
      compared to how things were before, when almost every framework had its own
      inheritance library.

   -  They help tools such as IDEs and type checkers with their work and enable new
      features there.

   -  If you come from another language to JavaScript and are used to classes, then
      you can get started more quickly.

   -  JavaScript engines optimize them. That is, code that uses classes is almost
      always faster than code that uses a custom inheritance library.

   -  We can subclass built-in constructor functions such as ``Error``.

   That doesnâ€™t mean that classes are perfect:

   -  There is a risk of overdoing inheritance.

   -  There is a risk of putting too much functionality in classes (when some of it
      is often better put in functions).

   -  Classes look familiar to programmers coming from other languages, but they
      work differently and are used differently (see next subsection). Therefore,
      there is a risk of those programmers writing code that doesnâ€™t feel like
      JavaScript.

   -  How classes seem to work superficially is quite different from how they
      actually work. In other words, there is a disconnect between syntax and
      semantics. Two examples are:

      -  A method definition inside a class ``C`` creates a method in the object
         ``C.prototype``.
      -  Classes are functions.

      The motivation for the disconnect is backward compatibility. Thankfully, the
      disconnect causes few problems in practice; we are usually OK if we go along
      with what classes pretend to be.

   This was a first look at classes. Weâ€™ll explore more features soon.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Writing a class**

      .. container:: boxout-vspace

      ``exercises/classes/point_class_test.mjs``

31.2.7â€ƒTips for using classes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  Use inheritance sparingly â€“ it tends to make code more complicated and spread
      out related functionality across multiple locations.
   -  Instead of static members, it is often better to use external functions and
      variables. We can even make those private to a module, simply by not
      exporting them. Two important exceptions to this rule are:

      -  Operations that need access to private slots
      -  `Static factory methods <#static-factory-methods>`__

   -  Only put core functionality in prototype methods. Other functionality is
      better implemented via functions â€“ especially algorithms that involve
      instances of multiple classes.



.. _internals-of-classes:

31.3â€ƒThe internals of classes
------------------------------

31.3.1â€ƒA class is actually two connected objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Under the hood, a class becomes two connected objects. Letâ€™s revisit class
   ``Person`` to see how that works:

   .. code:: javascript

      class Person {
      #firstName;
      constructor(firstName) {
         this.#firstName = firstName;
      }
      describe() {
         return `Person named ${this.#firstName}`;
      }
      static extractNames(persons) {
         return persons.map(person => person.#firstName);
      }
      }

   The first object created by the class is stored in ``Person``. It has four
   properties:

   .. code:: javascript

      assert.deepEqual(
      Reflect.ownKeys(Person),
      ['length', 'name', 'prototype', 'extractNames']
      );

      // The number of parameters of the constructor
      assert.equal(
      Person.length, 1
      );

      // The name of the class
      assert.equal(
      Person.name, 'Person'
      );

   The two remaining properties are:

   -  ``Person.extractNames`` is the static method that we have already seen in
      action.
   -  ``Person.prototype`` points to the second object that is created by a class
      definition.

   These are the contents of ``Person.prototype``:

   .. code:: javascript

      assert.deepEqual(
      Reflect.ownKeys(Person.prototype),
      ['constructor', 'describe']
      );

   There are two properties:

   -  ``Person.prototype.constructor`` points to the constructor.
   -  ``Person.prototype.describe`` is the method that we have already used.

31.3.2â€ƒClasses set up the prototype chains of their instances
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The object ``Person.prototype`` is the prototype of all instances:

   .. code:: javascript

      const jane = new Person('Jane');
      assert.equal(
      Object.getPrototypeOf(jane), Person.prototype
      );

      const tarzan = new Person('Tarzan');
      assert.equal(
      Object.getPrototypeOf(tarzan), Person.prototype
      );

   That explains how the instances get their methods: They inherit them from the
   object ``Person.prototype``.

   `Figure 31.2 <#fig:oo_person_class>`__ visualizes how everything is connected.

   .. figure:: https://exploringjs.com/js/book/img-book/classes/oo_person_class.svg
      name: fig:oo_person_class
      :width: 449px
      :height: 217px

      Figure 31.2: The class ``Person`` has the property ``.prototype`` that points
      to an object that is the prototype of all instances of ``Person``. The
      objects ``jane`` and ``tarzan`` are two such instances.



.. _proto-vs-prototype:

31.3.3â€ƒ``.__proto__`` vs. ``.prototype``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   It is easy to confuse ``.__proto__`` and ``.prototype``. Hopefully, `figure
   31.2 <#fig:oo_person_class>`__ makes it clear how they differ:

   -  `Object.prototype.__proto__ <#Object.prototype.__proto__>`__ is an
      accessor that most objects inherit that gets and sets the prototype of the
      receiver. Therefore the following two expressions are equivalent:

      .. code:: javascript

         someObj.__proto__
         Object.getPrototypeOf(someObj)

      As are the following two expressions:

      .. code:: javascript

         someObj.__proto__ = anotherObj
         Object.setPrototypeOf(someObj, anotherObj)

   -  ``SomeClass.prototype`` holds the object that becomes the prototype of all
      instances of ``SomeClass``. A better name for ``.prototype`` would be
      ``.instancePrototype``. This property is only special because the ``new``
      operator uses it to set up instances of ``SomeClass``.

      .. code:: javascript

         class SomeClass {}
         const inst = new SomeClass();
         assert.equal(
         Object.getPrototypeOf(inst), SomeClass.prototype
         );



.. _person-prototype-constructor:

31.3.4â€ƒ``Person.prototype.constructor`` (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   There is one detail in `figure 31.2 <#fig:oo_person_class>`__ that we havenâ€™t
   looked at, yet: ``Person.prototype.constructor`` points back to ``Person``:

   .. code:: javascript
      :name: language-node-repl

      > Person.prototype.constructor === Person
      true

   This setup exists due to backward compatibility. But it has two additional
   benefits.

   First, each instance of a class inherits property ``.constructor``. Therefore,
   given an instance, we can make â€œsimilarâ€ objects via it:

   .. code:: javascript

      const jane = new Person('Jane');

      const cheeta = new jane.constructor('Cheeta');
      // cheeta is also an instance of Person
      assert.equal(cheeta instanceof Person, true);

   Second, we can get the name of the class that created a given instance:

   .. code:: javascript

      const tarzan = new Person('Tarzan');
      assert.equal(tarzan.constructor.name, 'Person');



.. _method-calls-dispatched-direct:

31.3.5â€ƒDispatched vs. direct method calls (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In this subsection, we learn about two different ways of invoking methods:

   -  Dispatched method calls
   -  Direct method calls

   Understanding both of them will give us important insights into how methods
   work.

   Weâ€™ll also need the second way `later <#using-object-methods-safely>`__ in this
   chapter: It will allow us to borrow useful methods from ``Object.prototype``.

31.3.5.1â€ƒDispatched method calls
'''''''''''''''''''''''''''''''''

   Letâ€™s examine how method calls work with classes. We are revisiting ``jane``
   from earlier:

   .. code:: javascript

      class Person {
      #firstName;
      constructor(firstName) {
         this.#firstName = firstName;
      }
      describe() {
         return 'Person named '+this.#firstName;
      }
      }
      const jane = new Person('Jane');

   `Figure 31.3 <#fig:jane_proto_chain>`__ has a diagram with ``jane``\ â€™s
   prototype chain.

   .. figure:: https://exploringjs.com/js/book/img-book/classes/jane_proto_chain.svg
      name: fig:jane_proto_chain
      :width: 171px
      :height: 198px

      Figure 31.3: The prototype chain of ``jane`` starts with ``jane`` and
      continues with ``Person.prototype``.

   Normal method calls are *dispatched* â€“ the method call

   .. code:: javascript

      jane.describe()

   happens in two steps:

   -  Dispatch: JavaScript traverses the prototype chain starting with ``jane`` to
      find the first object that has an own property with the key ``'describe'``:
      It first looks at ``jane`` and doesnâ€™t find an own property ``.describe``. It
      continues with ``jane``\ â€™s prototype, ``Person.prototype`` and finds an own
      property ``describe`` whose value it returns.

      .. code:: javascript

         const func = jane.describe;

   -  Invocation: Method-invoking a value is different from function-invoking a
      value in that it not only calls what comes before the parentheses with the
      arguments inside the parentheses but also sets ``this`` to the receiver of
      the method call (in this case, ``jane``):

      .. code:: javascript

         func.call(jane);

   This way of dynamically looking for a method and invoking it is called *dynamic
   dispatch*.

31.3.5.2â€ƒDirect method calls
'''''''''''''''''''''''''''''

   We can also make method calls *directly*, without dispatching:

   .. code:: javascript

      Person.prototype.describe.call(jane)

   This time, we directly point to the method via ``Person.prototype.describe`` and
   donâ€™t search for it in the prototype chain. We also specify ``this`` differently
   â€“ via ``.call()``.

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**``this`` always points to the instance**

      .. container:: boxout-vspace

      No matter where in the prototype chain of an instance a method is located,
      ``this`` always points to the instance (the beginning of the prototype
      chain). That enables ``.describe()`` to access ``.#firstName`` in the
      example.

   When are direct method calls useful? Whenever we want to borrow a method from
   elsewhere that a given object doesnâ€™t have â€“ for example:

   .. code:: javascript

      const obj = Object.create(null);

      // `obj` is not an instance of Object and doesnâ€™t inherit
      // its prototype method .toString()
      assert.throws(
      () => obj.toString(),
      /^TypeError: obj.toString is not a function$/
      );
      assert.equal(
      Object.prototype.toString.call(obj),
      '[object Object]'
      );



.. _classes-evolved-from-ordinary-functions:

31.3.6â€ƒClasses evolved from ordinary functions (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Before ECMAScript 6, JavaScript didnâ€™t have classes. Instead, `ordinary
   functions <#ordinary-functions>`__ were used as *constructor
   functions*:

   .. code:: javascript

      function StringBuilderConstr(initialString) {
      this.string = initialString;
      }
      StringBuilderConstr.prototype.add = function (str) {
      this.string += str;
      return this;
      };

      const sb = new StringBuilderConstr('Â¡');
      sb.add('Hola').add('!');
      assert.equal(
      sb.string, 'Â¡Hola!'
      );

   Classes provide better syntax for this approach:

   .. code:: javascript

      class StringBuilderClass {
      constructor(initialString) {
         this.string = initialString;
      }
      add(str) {
         this.string += str;
         return this;
      }
      }
      const sb = new StringBuilderClass('Â¡');
      sb.add('Hola').add('!');
      assert.equal(
      sb.string, 'Â¡Hola!'
      );

   Subclassing is especially tricky with constructor functions. Classes also offer
   benefits that go beyond more convenient syntax:

   -  Built-in constructor functions such as ``Error`` can be subclassed.
   -  We can access overridden properties via ``super``.
   -  Classes canâ€™t be function-called.
   -  Methods canâ€™t be ``new``-called and donâ€™t have the property ``.prototype``.
   -  Support for private instance data.
   -  And more.

   Classes are so compatible with constructor functions that they can even extend
   them:

   .. code:: javascript

      function SuperConstructor() {}
      class SubClass extends SuperConstructor {}

      assert.equal(
      new SubClass() instanceof SuperConstructor, true
      );

   ``extends`` and subclassing are explained `later in this
   chapter <#subclassing>`__.

31.3.6.1â€ƒA class is the constructor
''''''''''''''''''''''''''''''''''''

   This brings us to an interesting insight. On one hand, ``StringBuilderClass``
   refers to its constructor via ``StringBuilderClass.prototype.constructor``.

   On the other hand, the class *is* the constructor (a function):

   .. code:: javascript
      :name: language-node-repl

      > StringBuilderClass.prototype.constructor === StringBuilderClass
      true
      > typeof StringBuilderClass
      'function'

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Constructor (functions) vs. classes**

      .. container:: boxout-vspace

      Due to how similar they are, I use the terms *constructor (function)* and
      *class* interchangeably.

31.4â€ƒPrototype members of classes
----------------------------------

31.4.1â€ƒPublic prototype methods and accessors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   All members in the body of the following class declaration create properties of
   ``PublicProtoClass.prototype``.

   .. code:: javascript

      class PublicProtoClass {
      constructor(args) {
         // (Do something with `args` here.)
      }
      publicProtoMethod() {
         return 'publicProtoMethod';
      }
      get publicProtoAccessor() {
         return 'publicProtoGetter';
      }
      set publicProtoAccessor(value) {
         assert.equal(value, 'publicProtoSetter');
      }
      }

      assert.deepEqual(
      Reflect.ownKeys(PublicProtoClass.prototype),
      ['constructor', 'publicProtoMethod', 'publicProtoAccessor']
      );

      const inst = new PublicProtoClass('arg1', 'arg2');
      assert.equal(
      inst.publicProtoMethod(), 'publicProtoMethod'
      );
      assert.equal(
      inst.publicProtoAccessor, 'publicProtoGetter'
      );
      inst.publicProtoAccessor = 'publicProtoSetter';



.. _all-kinds-of-public-prototype-methods-and-accessors:

31.4.1.1â€ƒAll kinds of public prototype methods and accessors (advanced)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   .. code:: javascript

      const accessorKey = Symbol('accessorKey');
      const syncMethodKey = Symbol('syncMethodKey');
      const syncGenMethodKey = Symbol('syncGenMethodKey');
      const asyncMethodKey = Symbol('asyncMethodKey');
      const asyncGenMethodKey = Symbol('asyncGenMethodKey');

      class PublicProtoClass2 {
      // Identifier keys
      get accessor() {}
      set accessor(value) {}
      syncMethod() {}
      * syncGeneratorMethod() {}
      async asyncMethod() {}
      async * asyncGeneratorMethod() {}

      // Quoted keys
      get 'an accessor'() {}
      set 'an accessor'(value) {}
      'sync method'() {}
      * 'sync generator method'() {}
      async 'async method'() {}
      async * 'async generator method'() {}

      // Computed keys
      get [accessorKey]() {}
      set [accessorKey](value) {}
      [syncMethodKey]() {}
      * [syncGenMethodKey]() {}
      async [asyncMethodKey]() {}
      async * [asyncGenMethodKey]() {}
      }

      // Quoted and computed keys are accessed via square brackets:
      const inst = new PublicProtoClass2();
      inst['sync method']();
      inst[syncMethodKey]();

   Quoted and computed keys can also be used in object literals:

   -  `â€œQuoted keys in object literalsâ€
      (Â§30.7.1) <#object-literals-quoted-keys>`__
   -  `â€œComputed keys in object literalsâ€
      (Â§30.7.2) <#object-literals-computed-keys>`__

   More information on accessors (defined via getters and/or setters), generators,
   async methods, and async generator methods:

   -  `â€œObject literals: accessorsâ€
      (Â§30.3.6) <#object-literal-accessors>`__
   -  `â€œSynchronous generatorsâ€
      (Â§40) <#ch_sync-generators>`__
   -  `â€œAsync functionsâ€ (Â§43) <#ch_async-functions>`__
   -  `â€œAsynchronous generatorsâ€
      (Â§44.2) <#async-generators>`__



.. _private-methods-accessors:

31.4.2â€ƒPrivate methods and accessors [ES2022]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Private methods (and accessors) are an interesting mix of prototype members and
   instance members.

   On one hand, private methods are stored in slots in instances (line A):

   .. code:: javascript

      class MyClass {
      #privateMethod() {}
      static check() {
         const inst = new MyClass();
         assert.equal(
            #privateMethod in inst, true // (A)
         );
         assert.equal(
            #privateMethod in MyClass.prototype, false
         );
         assert.equal(
            #privateMethod in MyClass, false
         );
      }
      }
      MyClass.check();

   Why are they not stored in ``.prototype`` objects? Private slots are not
   inherited, only properties are.

   On the other hand, private methods are shared between instances â€“ like prototype
   public methods:

   .. code:: javascript

      class MyClass {
      #privateMethod() {}
      static check() {
         const inst1 = new MyClass();
         const inst2 = new MyClass();
         assert.equal(
            inst1.#privateMethod,
            inst2.#privateMethod
         );
      }
      }

   Due to that and due to their syntax being similar to prototype public methods,
   they are covered here.

   The following code demonstrates how private methods and accessors work:

   .. code:: javascript

      class PrivateMethodClass {
      #privateMethod() {
         return 'privateMethod';
      }
      get #privateAccessor() {
         return 'privateGetter';
      }
      set #privateAccessor(value) {
         assert.equal(value, 'privateSetter');
      }
      callPrivateMembers() {
         assert.equal(this.#privateMethod(), 'privateMethod');
         assert.equal(this.#privateAccessor, 'privateGetter');
         this.#privateAccessor = 'privateSetter';
      }
      }
      assert.deepEqual(
      Reflect.ownKeys(new PrivateMethodClass()), []
      );



.. _all-kinds-of-private-methods-and-accessors:

31.4.2.1â€ƒAll kinds of private methods and accessors (advanced)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   With private slots, the keys are always identifiers:

   .. code:: javascript

      class PrivateMethodClass2 {
      get #accessor() {}
      set #accessor(value) {}
      #syncMethod() {}
      * #syncGeneratorMethod() {}
      async #asyncMethod() {}
      async * #asyncGeneratorMethod() {}
      }

   More information on accessors (defined via getters and/or setters), generators,
   async methods, and async generator methods:

   -  `â€œObject literals: accessorsâ€
      (Â§30.3.6) <#object-literal-accessors>`__
   -  `â€œSynchronous generatorsâ€
      (Â§40) <#ch_sync-generators>`__
   -  `â€œAsync functionsâ€ (Â§43) <#ch_async-functions>`__
   -  `â€œAsynchronous generatorsâ€
      (Â§44.2) <#async-generators>`__



.. _instance-members-of-classes:

31.5â€ƒInstance members of classes [ES2022]
------------------------------------------

31.5.1â€ƒInstance public fields
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Instances of the following class have two instance properties (created in line A
   and line B):

   .. code:: javascript

      class InstPublicClass {
      // Instance public field
      instancePublicField = 0; // (A)

      constructor(value) {
         // We donâ€™t need to mention .property elsewhere!
         this.property = value; // (B)
      }
      }

      const inst = new InstPublicClass('constrArg');
      assert.deepEqual(
      Reflect.ownKeys(inst),
      ['instancePublicField', 'property']
      );
      assert.equal(
      inst.instancePublicField, 0
      );
      assert.equal(
      inst.property, 'constrArg'
      );

   If we create an instance property inside the constructor (line B), we donâ€™t need
   to â€œdeclareâ€ it elsewhere. As we have already seen, that is different for
   instance private fields.

   Note that instance properties are relatively common in JavaScript; much more so
   than in, e.g., Java, where most instance state is private.



.. _instance-public-fields-quoted-keys-computed-keys:

31.5.1.1â€ƒInstance public fields with quoted and computed keys (advanced)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   .. code:: javascript

      const computedFieldKey = Symbol('computedFieldKey');
      class InstPublicClass2 {
      'quoted field key' = 1;
      [computedFieldKey] = 2;
      }
      const inst = new InstPublicClass2();
      assert.equal(inst['quoted field key'], 1);
      assert.equal(inst[computedFieldKey], 2);



.. _what-is-the-value-of-this-in-instance-public-fields:

31.5.1.2â€ƒWhat is the value of ``this`` in instance public fields? (advanced)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   In the initializer of a instance public field, ``this`` refers to the newly
   created instance:

   .. code:: javascript

      class MyClass {
      instancePublicField = this;
      }
      const inst = new MyClass();
      assert.equal(
      inst.instancePublicField, inst
      );



.. _when-are-instance-public-fields-executed:

31.5.1.3â€ƒWhen are instance public fields executed? (advanced)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The execution of instance public fields roughly follows these two rules:

   -  In base classes (classes without superclasses), instance public fields are
      executed immediately before the constructor.
   -  In derived classes (classes with superclasses):

      -  The superclass sets up its instance slots when ``super()`` is called.
      -  Instance public fields are executed immediately after ``super()``.

   The following example demonstrates these rules:

   .. code:: javascript

      class SuperClass {
      superProp = console.log('superProp');
      constructor() {
         console.log('super-constructor');
      }
      }
      class SubClass extends SuperClass {
      subProp = console.log('subProp');
      constructor() {
         console.log('BEFORE super()');
         super();
         console.log('AFTER super()');
      }
      }
      new SubClass();

   Output:

   ::

      BEFORE super()
      superProp
      super-constructor
      subProp
      AFTER super()

   ``extends`` and subclassing are explained `later in this
   chapter <#subclassing>`__.

31.5.2â€ƒInstance private fields
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following class contains two instance private fields (line A and line B):

   .. code:: javascript

      class InstPrivateClass {
      #privateField1 = 'private field 1'; // (A)
      #privateField2; // (B) required!
      constructor(value) {
         this.#privateField2 = value; // (C)
      }
      /**
         * Private fields are not accessible outside the class body.
         */
      checkPrivateValues() {
         assert.equal(
            this.#privateField1, 'private field 1'
         );
         assert.equal(
            this.#privateField2, 'constructor argument'
         );
      }
      }

      const inst = new InstPrivateClass('constructor argument');
      inst.checkPrivateValues();

      // No instance properties were created
      assert.deepEqual(
      Reflect.ownKeys(inst),
      []
      );

   Note that we can only use ``.#privateField2`` in line C if we declare it in the
   class body.



.. _private-instance-data-before-es2022:

31.5.3â€ƒPrivate instance data before ES2022 (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In this section, we look at two techniques for keeping instance data private.
   Because they donâ€™t rely on classes, we can also use them for objects that were
   created in other ways â€“ e.g., via object literals.

31.5.3.1â€ƒBefore ES6: private members via naming conventions
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The first technique makes a property private by prefixing its name with an
   underscore. This doesnâ€™t protect the property in any way; it merely signals to
   the outside: â€œYou donâ€™t need to know about this property.â€

   In the following code, the properties ``._counter`` and ``._action`` are
   private.

   .. code:: javascript

      class Countdown {
      constructor(counter, action) {
         this._counter = counter;
         this._action = action;
      }
      dec() {
         this._counter--;
         if (this._counter === 0) {
            this._action();
         }
      }
      }

      // The two properties arenâ€™t really private:
      assert.deepEqual(
      Object.keys(new Countdown()),
      ['_counter', '_action']);

   With this technique, we donâ€™t get any protection and private names can clash. On
   the plus side, it is easy to use.

   Private methods work similarly: They are normal methods whose names start with
   underscores.

31.5.3.2â€ƒES6 and later: private instance data via WeakMaps
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   We can also manage private instance data via WeakMaps:

   .. code:: javascript

      const _counter = new WeakMap();
      const _action = new WeakMap();

      class Countdown {
      constructor(counter, action) {
         _counter.set(this, counter);
         _action.set(this, action);
      }
      dec() {
         let counter = _counter.get(this);
         counter--;
         _counter.set(this, counter);
         if (counter === 0) {
            _action.get(this)();
         }
      }
      }

      // The two pseudo-properties are truly private:
      assert.deepEqual(
      Object.keys(new Countdown()),
      []);

   How exactly that works is explained `in the chapter on
   WeakMaps <#private-data-in-weakmaps>`__.

   This technique offers us considerable protection from outside access and there
   canâ€™t be any name clashes. But it is also more complicated to use.

   We control the visibility of the pseudo-property ``_superProp`` by controlling
   who has access to it â€“ for example: If the variable exists inside a module and
   isnâ€™t exported, everyone inside the module and no one outside the module can
   access it. In other words: The scope of privacy isnâ€™t the class in this case,
   itâ€™s the module. We could narrow the scope, though:

   .. code:: javascript

      let Countdown;
      { // class scope
      const _counter = new WeakMap();
      const _action = new WeakMap();

      Countdown = class {
         // Â·Â·Â·
      }
      }

   This technique doesnâ€™t really support private methods. But module-local
   functions that have access to ``_superProp`` are the next best thing:

   .. code:: javascript

      const _counter = new WeakMap();
      const _action = new WeakMap();

      class Countdown {
      constructor(counter, action) {
         _counter.set(this, counter);
         _action.set(this, action);
      }
      dec() {
         privateDec(this);
      }
      }

      function privateDec(_this) { // (A)
      let counter = _counter.get(_this);
      counter--;
      _counter.set(_this, counter);
      if (counter === 0) {
         _action.get(_this)();
      }
      }

   Note that ``this`` becomes the explicit function parameter ``_this`` (line A).



.. _instance-protected-fields:

31.5.4â€ƒSimulating protected visibility and friend visibility via WeakMaps (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   As previously discussed, instance private fields are only visible inside their
   classes and not even in subclasses. Thus, there is no built-in way to get:

   -  Protected visibility: A class and all of its subclasses can access a piece
      instance data.
   -  Friend visibility: A class and its â€œfriendsâ€ (designated functions, objects,
      or classes) can access a piece of instance data.

   In the previous subsection, we simulated â€œmodule visibilityâ€ (everyone inside a
   module has access to a piece of instance data) via WeakMaps. Therefore:

   -  If we put a class and its subclasses into the same module, we get protected
      visibility.
   -  If we put a class and its friends into the same module, we get friend
      visibility.

   The next example demonstrates protected visibility:

   .. code:: javascript

      const _superProp = new WeakMap();
      class SuperClass {
      constructor() {
         _superProp.set(this, 'superProp');
      }
      }
      class SubClass extends SuperClass {
      getSuperProp() {
         return _superProp.get(this);
      }
      }
      assert.equal(
      new SubClass().getSuperProp(),
      'superProp'
      );

   `Subclassing via ``extends <#subclassing>`__ is explained later in this
   chapter.

31.6â€ƒStatic members of classes
-------------------------------

31.6.1â€ƒStatic public methods and accessors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   All members in the body of the following class declaration create so-called
   *static* properties â€“ properties of ``StaticClass`` itself.

   .. code:: javascript

      class StaticPublicMethodsClass {
      static staticMethod() {
         return 'staticMethod';
      }
      static get staticAccessor() {
         return 'staticGetter';
      }
      static set staticAccessor(value) {
         assert.equal(value, 'staticSetter');
      }
      }
      assert.equal(
      StaticPublicMethodsClass.staticMethod(), 'staticMethod'
      );
      assert.equal(
      StaticPublicMethodsClass.staticAccessor, 'staticGetter'
      );
      StaticPublicMethodsClass.staticAccessor = 'staticSetter';



.. _all-kinds-of-static-public-methods-and-accessors:

31.6.1.1â€ƒAll kinds of static public methods and accessors (advanced)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   .. code:: javascript

      const accessorKey = Symbol('accessorKey');
      const syncMethodKey = Symbol('syncMethodKey');
      const syncGenMethodKey = Symbol('syncGenMethodKey');
      const asyncMethodKey = Symbol('asyncMethodKey');
      const asyncGenMethodKey = Symbol('asyncGenMethodKey');

      class StaticPublicMethodsClass2 {
      // Identifier keys
      static get accessor() {}
      static set accessor(value) {}
      static syncMethod() {}
      static * syncGeneratorMethod() {}
      static async asyncMethod() {}
      static async * asyncGeneratorMethod() {}

      // Quoted keys
      static get 'an accessor'() {}
      static set 'an accessor'(value) {}
      static 'sync method'() {}
      static * 'sync generator method'() {}
      static async 'async method'() {}
      static async * 'async generator method'() {}

      // Computed keys
      static get [accessorKey]() {}
      static set [accessorKey](value) {}
      static [syncMethodKey]() {}
      static * [syncGenMethodKey]() {}
      static async [asyncMethodKey]() {}
      static async * [asyncGenMethodKey]() {}
      }

      // Quoted and computed keys are accessed via square brackets:
      StaticPublicMethodsClass2['sync method']();
      StaticPublicMethodsClass2[syncMethodKey]();

   Quoted and computed keys can also be used in object literals:

   -  `â€œQuoted keys in object literalsâ€
      (Â§30.7.1) <#object-literals-quoted-keys>`__
   -  `â€œComputed keys in object literalsâ€
      (Â§30.7.2) <#object-literals-computed-keys>`__

   More information on accessors (defined via getters and/or setters), generators,
   async methods, and async generator methods:

   -  `â€œObject literals: accessorsâ€
      (Â§30.3.6) <#object-literal-accessors>`__
   -  `â€œSynchronous generatorsâ€
      (Â§40) <#ch_sync-generators>`__
   -  `â€œAsync functionsâ€ (Â§43) <#ch_async-functions>`__
   -  `â€œAsynchronous generatorsâ€
      (Â§44.2) <#async-generators>`__



.. _static-public-fields:

31.6.2â€ƒStatic public fields [ES2022]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following code demonstrates static public fields. ``StaticPublicFieldClass``
   has three of them:

   .. code:: javascript

      const computedFieldKey = Symbol('computedFieldKey');
      class StaticPublicFieldClass {
      static identifierFieldKey = 1;
      static 'quoted field key' = 2;
      static [computedFieldKey] = 3;
      }

      assert.deepEqual(
      Reflect.ownKeys(StaticPublicFieldClass),
      [
         'length', // number of constructor parameters
         'name', // 'StaticPublicFieldClass'
         'prototype',
         'identifierFieldKey',
         'quoted field key',
         computedFieldKey,
      ],
      );

      assert.equal(StaticPublicFieldClass.identifierFieldKey, 1);
      assert.equal(StaticPublicFieldClass['quoted field key'], 2);
      assert.equal(StaticPublicFieldClass[computedFieldKey], 3);



.. _static-private-methods-accessors-fields:

31.6.3â€ƒStatic private methods, accessors, and fields [ES2022]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following class has two static private slots (line A and line B):

   .. code:: javascript

      class StaticPrivateClass {
      // Declare and initialize
      static #staticPrivateField = 'hello'; // (A)
      static #twice() { // (B)
         const str = StaticPrivateClass.#staticPrivateField;
         return str + ' ' + str;
      }
      static getResultOfTwice() {
         return StaticPrivateClass.#twice();
      }
      }

      assert.deepEqual(
      Reflect.ownKeys(StaticPrivateClass),
      [
         'length', // number of constructor parameters
         'name', // 'StaticPublicFieldClass'
         'prototype',
         'getResultOfTwice',
      ],
      );

      assert.equal(
      StaticPrivateClass.getResultOfTwice(),
      'hello hello'
      );

   This is a complete list of all kinds of static private slots:

   .. code:: javascript

      class MyClass {
      static #staticPrivateMethod() {}
      static * #staticPrivateGeneratorMethod() {}

      static async #staticPrivateAsyncMethod() {}
      static async * #staticPrivateAsyncGeneratorMethod() {}
      
      static get #staticPrivateAccessor() {}
      static set #staticPrivateAccessor(value) {}
      }



.. _class-static-initialization-blocks:

31.6.4â€ƒStatic initialization blocks in classes [ES2022]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To set up instance data via classes, we have two constructs:

   -  *Fields*, to create and optionally initialize instance data
   -  *Constructors*, blocks of code that are executed every time a new instance is
      created

   For static data, we have:

   -  *Static fields*
   -  *Static blocks* that are executed when a class is created

   The following code demonstrates static blocks (line A):

   .. code:: javascript

      class Translator {
      static translations = {
         yes: 'ja',
         no: 'nein',
         maybe: 'vielleicht',
      };
      static englishWords = [];
      static germanWords = [];
      static { // (A)
         for (const [english, german] of Object.entries(this.translations)) {
            this.englishWords.push(english);
            this.germanWords.push(german);
         }
      }
      }

   We could also execute the code inside the static block after the class (at the
   top level). However, using a static block has two benefits:

   -  All class-related code is inside the class.
   -  The code in a static block has access to private slots.

31.6.4.1â€ƒRules for static initialization blocks
''''''''''''''''''''''''''''''''''''''''''''''''

   The rules for how static initialization blocks work, are relatively simple:

   -  There can be more than one static block per class.
   -  The execution of static blocks is interleaved with the execution of static
      field initializers.
   -  The static members of a superclass are executed before the static members of
      a subclass.

   The following code demonstrates these rules:

   .. code:: javascript

      class SuperClass {
      static superField1 = console.log('superField1');
      static {
         assert.equal(this, SuperClass);
         console.log('static block 1 SuperClass');
      }
      static superField2 = console.log('superField2');
      static {
         console.log('static block 2 SuperClass');
      }
      }

      class SubClass extends SuperClass {
      static subField1 = console.log('subField1');
      static {
         assert.equal(this, SubClass);
         console.log('static block 1 SubClass');
      }
      static subField2 = console.log('subField2');
      static {
         console.log('static block 2 SubClass');
      }
      }

   Output:

   ::

      superField1
      static block 1 SuperClass
      superField2
      static block 2 SuperClass
      subField1
      static block 1 SubClass
      subField2
      static block 2 SubClass

   `Subclassing via ``extends <#subclassing>`__ is explained later in this
   chapter.



.. _this-and-static-private-fields:

31.6.5â€ƒPitfall: Using ``this`` to access static private fields
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In static public members, we can access static public slots via ``this``. Alas,
   we should not use it to access static private slots.

31.6.5.1â€ƒ``this`` and static public fields
'''''''''''''''''''''''''''''''''''''''''''

   Consider the following code:

   .. code:: javascript

      class SuperClass {
      static publicData = 1;
      
      static getPublicViaThis() {
         return this.publicData;
      }
      }
      class SubClass extends SuperClass {
      }

   `Subclassing via ``extends <#subclassing>`__ is explained later in this
   chapter.

   Static public fields are properties. If we make the method call

   .. code:: javascript

      assert.equal(SuperClass.getPublicViaThis(), 1);

   then ``this`` points to ``SuperClass`` and everything works as expected. We can
   also invoke ``.getPublicViaThis()`` via the subclass:

   .. code:: javascript

      assert.equal(SubClass.getPublicViaThis(), 1);

   ``SubClass`` inherits ``.getPublicViaThis()`` from its prototype ``SuperClass``.
   ``this`` points to ``SubClass`` and things continue to work, because
   ``SubClass`` also inherits the property ``.publicData``.

   As an aside, if we assigned to ``this.publicData`` in ``getPublicViaThis()`` and
   invoked it via ``SubClass.getPublicViaThis()``, then we would create a new own
   poperty of ``SubClass`` that (non-destructively) overrides the property
   inherited from ``SuperClass``.

31.6.5.2â€ƒ``this`` and static private fields
''''''''''''''''''''''''''''''''''''''''''''

   Consider the following code:

   .. code:: javascript

      class SuperClass {
      static #privateData = 2;
      static getPrivateDataViaThis() {
         return this.#privateData;
      }
      static getPrivateDataViaClassName() {
         return SuperClass.#privateData;
      }
      }
      class SubClass extends SuperClass {
      }

   Invoking ``.getPrivateDataViaThis()`` via ``SuperClass`` works, because ``this``
   points to ``SuperClass``:

   .. code:: javascript

      assert.equal(SuperClass.getPrivateDataViaThis(), 2);

   However, invoking ``.getPrivateDataViaThis()`` via ``SubClass`` does not work,
   because ``this`` now points to ``SubClass`` and ``SubClass`` has no static
   private field ``.#privateData`` (private slots in prototype chains are not
   inherited):

   .. code:: javascript

      assert.throws(
      () => SubClass.getPrivateDataViaThis(),
      {
         name: 'TypeError',
         message: 'Cannot read private member #privateData from'
            + ' an object whose class did not declare it',
      }
      );

   The workaround is to accesss ``.#privateData`` directly, via ``SuperClass``:

   .. code:: javascript

      assert.equal(SubClass.getPrivateDataViaClassName(), 2);

   With static private methods, we are facing the same issue.

31.6.6â€ƒAll members (static, prototype, instance) can access all private members
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Every member inside a class can access all other members inside that class â€“
   both public and private ones:

   .. code:: javascript

      class DemoClass {
      static #staticPrivateField = 1;
      #instPrivField = 2;

      static staticMethod(inst) {
         // A static method can access static private fields
         // and instance private fields
         assert.equal(DemoClass.#staticPrivateField, 1);
         assert.equal(inst.#instPrivField, 2);
      }

      protoMethod() {
         // A prototype method can access instance private fields
         // and static private fields
         assert.equal(this.#instPrivField, 2);
         assert.equal(DemoClass.#staticPrivateField, 1);
      }
      }

   In contrast, no one outside can access the private members:

   .. code:: javascript

      // Accessing private fields outside their classes triggers
      // syntax errors (before the code is even executed).
      assert.throws(
      () => eval('DemoClass.#staticPrivateField'),
      {
         name: 'SyntaxError',
         message: "Private field '#staticPrivateField' must"
            + " be declared in an enclosing class",
      }
      );
      // Accessing private fields outside their classes triggers
      // syntax errors (before the code is even executed).
      assert.throws(
      () => eval('new DemoClass().#instPrivField'),
      {
         name: 'SyntaxError',
         message: "Private field '#instPrivField' must"
            + " be declared in an enclosing class",
      }
      );

31.6.7â€ƒStatic private methods and data before ES2022
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following code only works in ES2022 â€“ due to every line that has a hash
   symbol (``#``) in it:

   .. code:: javascript

      class StaticClass {
      static #secret = 'Rumpelstiltskin';
      static #getSecretInParens() {
         return `(${StaticClass.#secret})`;
      }
      static callStaticPrivateMethod() {
         return StaticClass.#getSecretInParens();
      }
      }

   Since private slots only exist once per class, we can move ``#secret`` and
   ``#getSecretInParens`` to the scope surrounding the class and use a module to
   hide them from the world outside the module.

   .. code:: javascript

      const secret = 'Rumpelstiltskin';
      function getSecretInParens() {
      return `(${secret})`;
      }

      // Only the class is accessible outside the module
      export class StaticClass {
      static callStaticPrivateMethod() {
         return getSecretInParens();
      }
      }

31.6.8â€ƒStatic factory methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sometimes there are multiple ways in which a class can be instantiated. Then we
   can implement *static factory methods* such as ``Point.fromPolar()``:

   .. code:: javascript

      class Point {
      static fromPolar(radius, angle) {
         const x = radius * Math.cos(angle);
         const y = radius * Math.sin(angle);
         return new Point(x, y);
      }
      constructor(x=0, y=0) {
         this.x = x;
         this.y = y;
      }
      }

      assert.deepEqual(
      Point.fromPolar(13, 0.39479111969976155),
      new Point(12, 5)
      );

   I like how descriptive static factory methods are: ``fromPolar`` describes how
   an instance is created. JavaScriptâ€™s standard library also has such factory
   methods â€“ for example:

   -  ``Array.from()``
   -  ``Object.create()``

   I prefer to either have no static factory methods or *only* static factory
   methods. Things to consider in the latter case:

   -  One factory method will probably directly call the constructor (but have a
      descriptive name).
   -  We need to find a way to prevent the constructor being called from outside.

   In the following code, we use a secret token (line A) to prevent the constructor
   being called from outside the current module.

   .. code:: javascript

      // Only accessible inside the current module
      const secretToken = Symbol('secretToken'); // (A)

      export class Point {
      static create(x=0, y=0) {
         return new Point(secretToken, x, y);
      }
      static fromPolar(radius, angle) {
         const x = radius * Math.cos(angle);
         const y = radius * Math.sin(angle);
         return new Point(secretToken, x, y);
      }
      constructor(token, x, y) {
         if (token !== secretToken) {
            throw new TypeError('Must use static factory method');
         }
         this.x = x;
         this.y = y;
      }
      }
      Point.create(3, 4); // OK
      assert.throws(
      () => new Point(3, 4),
      TypeError
      );

31.7â€ƒSubclassing
-----------------

   Classes can also extend existing classes. For example, the following class
   ``Employee`` extends ``Person``:

   .. code:: javascript

      class Person {
      #firstName;
      constructor(firstName) {
         this.#firstName = firstName;
      }
      describe() {
         return `Person named ${this.#firstName}`;
      }
      static extractNames(persons) {
         return persons.map(person => person.#firstName);
      }
      }

      class Employee extends Person {
      constructor(firstName, title) {
         super(firstName);
         this.title = title;
      }
      describe() {
         return super.describe() +
            ` (${this.title})`;
      }
      }

      const jane = new Employee('Jane', 'CTO');
      assert.equal(
      jane.title,
      'CTO'
      );
      assert.equal(
      jane.describe(),
      'Person named Jane (CTO)'
      );

   Terminology related to extending:

   -  Another word for *extending* is *subclassing*.
   -  ``Person`` is the superclass of ``Employee``.
   -  ``Employee`` is the subclass of ``Person``.
   -  A *base class* is a class that has no superclasses.
   -  A *derived class* is a class that has a superclass.

   Inside the ``.constructor()`` of a derived class, we must call the
   super-constructor via ``super()`` before we can access ``this``. Why is that?

   Letâ€™s consider a chain of classes:

   -  Base class ``A``
   -  Class ``B`` extends ``A``.
   -  Class ``C`` extends ``B``.

   If we invoke ``new C()``, ``C``\ â€™s constructor super-calls ``B``\ â€™s
   constructor which super-calls ``A``\ â€™s constructor. Instances are always
   created in base classes, before the constructors of subclasses add their slots.
   Therefore, the instance doesnâ€™t exist before we call ``super()`` and we canâ€™t
   access it via ``this``, yet.

   Note that static public slots are inherited. For example, ``Employee`` inherits
   the static method ``.extractNames()``:

   .. code:: javascript
      :name: language-node-repl

      > 'extractNames' in Employee
      true

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Subclassing**

      .. container:: boxout-vspace

      ``exercises/classes/color_point_class_test.mjs``



.. _the-internals-of-subclassing:

31.7.1â€ƒThe internals of subclassing (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. figure:: https://exploringjs.com/js/book/img-book/classes/oo_subclassing.svg
      name: fig:oo_subclassing
      :width: 377px
      :height: 234px

      Figure 31.4: These are the objects that make up class ``Person`` and its
      subclass, ``Employee``. The left column is about classes. The right column is
      about the ``Employee`` instance ``jane`` and its prototype chain.

   The classes ``Person`` and ``Employee`` from the previous section are made up of
   several objects (`figure 31.4 <#fig:oo_subclassing>`__). One key insight for
   understanding how these objects are related is that there are two prototype
   chains:

   -  The instance prototype chain, on the right.
   -  The class prototype chain, on the left.

31.7.1.1â€ƒThe instance prototype chain (right column)
'''''''''''''''''''''''''''''''''''''''''''''''''''''

   The instance prototype chain starts with ``jane`` and continues with
   ``Employee.prototype`` and ``Person.prototype``. In principle, the prototype
   chain ends at this point, but we get one more object: ``Object.prototype``. This
   prototype provides services to virtually all objects, which is why it is
   included here, too:

   .. code:: javascript
      :name: language-node-repl

      > Object.getPrototypeOf(Person.prototype) === Object.prototype
      true

31.7.1.2â€ƒThe class prototype chain (left column)
'''''''''''''''''''''''''''''''''''''''''''''''''

   In the class prototype chain, ``Employee`` comes first, ``Person`` next.
   Afterward, the chain continues with ``Function.prototype``, which is only there
   because ``Person`` is a function and functions need the services of
   ``Function.prototype``.

   .. code:: javascript
      :name: language-node-repl

      > Object.getPrototypeOf(Person) === Function.prototype
      true



.. _instanceof-operator:

31.7.2â€ƒ``instanceof`` and subclassing (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We have not yet learned how ``instanceof`` really works. How does ``instanceof``
   determine if a value ``x`` is an instance of a class ``C`` (it can be a direct
   instance of ``C`` or a direct instance of a subclass of ``C``)? It checks if
   ``C.prototype`` is in the prototype chain of ``x``. That is, the following two
   expressions are equivalent:

   .. code:: javascript

      x instanceof C
      C.prototype.isPrototypeOf(x)

   If we go back to `figure 31.4 <#fig:oo_subclassing>`__, we can confirm that the
   prototype chain does lead us to the following correct answers:

   .. code:: javascript
      :name: language-node-repl

      > jane instanceof Employee
      true
      > jane instanceof Person
      true
      > jane instanceof Object
      true

   Note that ``instanceof`` always returns ``false`` if its self-hand side is a
   primitive value:

   .. code:: javascript
      :name: language-node-repl

      > 'abc' instanceof String
      false
      > 123 instanceof Number
      false



.. _non-instances-of-object:

31.7.3â€ƒNot all objects are instances of ``Object`` (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   An object (a non-primitive value) is only an instance of ``Object`` if
   ``Object.prototype`` is in its prototype chain `(see previous
   subsection) <#instanceof-operator>`__. Virtually all objects are instances of
   ``Object`` â€“ for example:

   .. code:: javascript

      assert.equal(
      {a: 1} instanceof Object, true
      );
      assert.equal(
      ['a'] instanceof Object, true
      );
      assert.equal(
      /abc/g instanceof Object, true
      );
      assert.equal(
      new Map() instanceof Object, true
      );

      class C {}
      assert.equal(
      new C() instanceof Object, true
      );

   In the next example, ``obj1`` and ``obj2`` are both objects (line A and line C),
   but they are not instances of ``Object`` (line B and line D):
   ``Object.prototype`` is not in their prototype chains because they donâ€™t have
   any prototypes.

   .. code:: javascript

      const obj1 = {__proto__: null};
      assert.equal(
      typeof obj1, 'object' // (A)
      );
      assert.equal(
      obj1 instanceof Object, false // (B)
      );

      const obj2 = Object.create(null);
      assert.equal(
      typeof obj2, 'object' // (C)
      );
      assert.equal(
      obj2 instanceof Object, false // (D)
      );

   ``Object.prototype`` is the object that ends most prototype chains. Its
   prototype is ``null``, which means it isnâ€™t an instance of ``Object`` either:

   .. code:: javascript
      :name: language-node-repl

      > typeof Object.prototype
      'object'
      > Object.getPrototypeOf(Object.prototype)
      null
      > Object.prototype instanceof Object
      false



.. _prototype-chains-of-built-ins:

31.7.4â€ƒPrototype chains of built-in objects (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Next, weâ€™ll use our knowledge of subclassing to understand the prototype chains
   of a few built-in objects. The following tool function ``p()`` helps us with our
   explorations.

   .. code:: javascript

      const p = Object.getPrototypeOf.bind(Object);

   We extracted method ``.getPrototypeOf()`` of ``Object`` and assigned it to
   ``p``.

31.7.4.1â€ƒThe prototype chain of ``{}``
'''''''''''''''''''''''''''''''''''''''

   Letâ€™s start by examining plain objects:

   .. code:: javascript
      :name: language-node-repl

      > p({}) === Object.prototype
      true
      > p(p({})) === null
      true

   .. figure:: https://exploringjs.com/js/book/img-book/classes/proto_chain_object.svg
      name: fig:proto_chain_object
      :width: 152px
      :height: 158px

      Figure 31.5: The prototype chain of an object created via an object literal
      starts with that object, continues with ``Object.prototype``, and ends with
      ``null``.

   `Figure 31.5 <#fig:proto_chain_object>`__ shows a diagram for this prototype
   chain. We can see that ``{}`` really is an instance of ``Object`` â€“
   ``Object.prototype`` is in its prototype chain.



.. _the-prototype-chain-of-1:

31.7.4.2â€ƒThe prototype chain of ``[]``
'''''''''''''''''''''''''''''''''''''''

   What does the prototype chain of an Array look like?

   .. code:: javascript
      :name: language-node-repl

      > p([]) === Array.prototype
      true
      > p(p([])) === Object.prototype
      true
      > p(p(p([]))) === null
      true

   .. figure:: https://exploringjs.com/js/book/img-book/classes/proto_chain_array.svg
      name: fig:proto_chain_array
      :width: 152px
      :height: 233px

      Figure 31.6: The prototype chain of an Array has these members: the Array
      instance, ``Array.prototype``, ``Object.prototype``, ``null``.

   This prototype chain (visualized in `figure 31.6 <#fig:proto_chain_array>`__)
   tells us that an Array object is an instance of ``Array`` and of ``Object``.

31.7.4.3â€ƒThe prototype chain of ``function () {}``
'''''''''''''''''''''''''''''''''''''''''''''''''''

   Lastly, the prototype chain of an ordinary function tells us that all functions
   are objects:

   .. code:: javascript
      :name: language-node-repl

      > p(function () {}) === Function.prototype
      true
      > p(p(function () {})) === Object.prototype
      true

31.7.4.4â€ƒThe prototype chains of built-in classes
''''''''''''''''''''''''''''''''''''''''''''''''''

   The prototype of a base class is ``Function.prototype`` which means that it is a
   function (an instance of ``Function``):

   .. code:: javascript

      class A {}
      assert.equal(
      Object.getPrototypeOf(A),
      Function.prototype
      );

      assert.equal(
      Object.getPrototypeOf(class {}),
      Function.prototype
      );

   The prototype of a derived class is its superclass:

   .. code:: javascript

      class B extends A {}
      assert.equal(
      Object.getPrototypeOf(B),
      A
      );

      assert.equal(
      Object.getPrototypeOf(class extends Object {}),
      Object
      );

   Interestingly, ``Object``, ``Array``, and ``Function`` are all base classes:

   .. code:: javascript
      :name: language-node-repl

      > Object.getPrototypeOf(Object) === Function.prototype
      true
      > Object.getPrototypeOf(Array) === Function.prototype
      true
      > Object.getPrototypeOf(Function) === Function.prototype
      true

   However, as we have seen, even the instances of base classes have
   ``Object.prototype`` in their prototype chains because it provides services that
   all objects need.

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Why are ``Array`` and ``Function`` base classes?**

      .. container:: boxout-vspace

      Base classes are where instances are actually created. Both ``Array`` and
      ``Function`` need to create their own instances because they have so-called
      â€œinternal slotsâ€ which canâ€™t be added later to instances created by
      ``Object``.



.. _mixin-classes:

31.7.5â€ƒMixin classes (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScriptâ€™s class system only supports *single inheritance*. That is, each
   class can have at most one superclass. One way around this limitation is via a
   technique called *mixin classes* (short: *mixins*).

   The idea is as follows: Letâ€™s say we want a class ``C`` to inherit from two
   superclasses ``S1`` and ``S2``. That would be *multiple inheritance*, which
   JavaScript doesnâ€™t support.

   Our workaround is to turn ``S1`` and ``S2`` into *mixins*, factories for
   subclasses:

   .. code:: javascript

      const S1 = (Sup) => class extends Sup { /*Â·Â·Â·*/ };
      const S2 = (Sup) => class extends Sup { /*Â·Â·Â·*/ };

   Each of these two functions returns a class that extends a given superclass
   ``Sup``. We create class ``C`` as follows:

   .. code:: javascript

      class C extends S2(S1(Object)) {
      /*Â·Â·Â·*/
      }

   We now have a class ``C`` that extends the class returned by ``S2()`` which
   extends the class returned by ``S1()`` which extends ``Object``.

31.7.5.1â€ƒExample: a mixin for name management
''''''''''''''''''''''''''''''''''''''''''''''

   We implement a mixin ``Named`` adds a property ``.name`` and a method
   ``.toString()`` to its superclass:

   .. code:: javascript

      const Named = (Sup) => class extends Sup {
      name = '(Unnamed)';
      toString() {
         const className = this.constructor.name;
         return `${className} named ${this.name}`;
      }
      };

   We use this mixin to implement a class ``City`` that has a name:

   .. code:: javascript

      class City extends Named(Object) {
      constructor(name) {
         super();
         this.name = name;
      }
      }

   The following code confirms that the mixin works:

   .. code:: javascript

      const paris = new City('Paris');
      assert.equal(
      paris.name, 'Paris'
      );
      assert.equal(
      paris.toString(), 'City named Paris'
      );

31.7.5.2â€ƒThe benefits of mixins
''''''''''''''''''''''''''''''''

   Mixins free us from the constraints of single inheritance:

   -  The same class can extend a single superclass and zero or more mixins.
   -  The same mixin can be used by multiple classes.



.. _the-methods-and-accessors-of-object-prototype:

31.8â€ƒThe methods and accessors of ``Object.prototype`` (advanced)
------------------------------------------------------------------



.. _quickref-object-prototype:

31.8.1â€ƒQuick reference: ``Object.prototype.*``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   As we have seen in `â€œNot all objects are instances of ``Object``\ â€
   (Â§31.7.3) <#non-instances-of-object>`__, almost all objects are instances of
   ``Object``. This class provides useful functionality to its instances:

   -  Configuring how objects are converted to primitive values (e.g. by the ``+``
      operator): The following methods have default implementations but are often
      overridden in subclasses or instances.

      -  `.toString() <#Object.prototype.toString>`__: Configures how an object
         is converted to a string.
      -  `.toLocaleString() <#Object.prototype.toLocaleString>`__: A version of
         ``.toString()`` that can be configured in various ways via arguments
         (language, region, etc.).
      -  `.valueOf() <#Object.prototype.valueOf>`__: Configures how an object
         is converted to a non-string primitive value (often a number).

   -  Useful methods (with pitfalls â€“ see next subsection):

      -  `.isPrototypeOf() <#Object.prototype.isPrototypeOf>`__: Is the
         receiver in the prototype chain of a given object?
      -  `.propertyIsEnumerable() <#Object.prototype.propertyIsEnumerable>`__:
         Does the receiver have an enumerable own property with the given key?

   -  Avoid these features (there are better alternatives):

      -  `.__proto__ <#Object.prototype.__proto__>`__: Get and set the
         prototype of the receiver.

         -  Using this accessor is not recommended. Alternatives:

            -  ``Object.getPrototypeOf()``
            -  ``Object.setPrototypeOf()``

      -  `.hasOwnProperty() <#Object.prototype.hasOwnProperty>`__: Does the
         receiver have an own property with a given key?

         -  Using this method is not recommended. Alternative in ES2022 and later:
            ``Object.hasOwn()``.

   Before we take a closer look at each of these features, weâ€™ll learn about an
   important pitfall (and how to work around it): We canâ€™t use the features of
   ``Object.prototype`` with all objects.



.. _using-object-methods-safely:

31.8.2â€ƒUsing ``Object.prototype`` methods safely
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Invoking one of the methods of ``Object.prototype`` on an arbitrary object
   doesnâ€™t always work. To illustrate why, we use method
   ``Object.prototype.hasOwnProperty``, which returns ``true`` if an object has an
   own property with a given key:

   .. code:: javascript
      :name: language-node-repl

      > {ownProp: true}.hasOwnProperty('ownProp')
      true
      > {ownProp: true}.hasOwnProperty('abc')
      false

   Invoking ``.hasOwnProperty()`` on an arbitrary object can fail in two ways. On
   one hand, this method isnâ€™t available if an object is not an instance of
   ``Object`` (see `â€œNot all objects are instances of ``Object``\ â€
   (Â§31.7.3) <#non-instances-of-object>`__):

   .. code:: javascript

      const obj = Object.create(null);
      assert.equal(obj instanceof Object, false);
      assert.throws(
      () => obj.hasOwnProperty('prop'),
      {
         name: 'TypeError',
         message: 'obj.hasOwnProperty is not a function',
      }
      );

   On the other hand, we canâ€™t use ``.hasOwnProperty()`` if an object overrides it
   with an own property (line A):

   .. code:: javascript

      const obj = {
      hasOwnProperty: 'yes' // (A)
      };
      assert.throws(
      () => obj.hasOwnProperty('prop'),
      {
         name: 'TypeError',
         message: 'obj.hasOwnProperty is not a function',
      }
      );

   There is, however, a safe way to use ``.hasOwnProperty()``:

   .. code:: javascript

      function hasOwnProp(obj, propName) {
      return Object.prototype.hasOwnProperty.call(obj, propName); // (A)
      }
      assert.equal(
      hasOwnProp(Object.create(null), 'prop'), false
      );
      assert.equal(
      hasOwnProp({hasOwnProperty: 'yes'}, 'prop'), false
      );
      assert.equal(
      hasOwnProp({hasOwnProperty: 'yes'}, 'hasOwnProperty'), true
      );

   The method invocation in line A is explained in `â€œDispatched vs. direct method
   callsâ€ (Â§31.3.5) <#method-calls-dispatched-direct>`__.

   We can also use `.bind() <#methods-bind>`__ to implement
   ``hasOwnProp()``:

   .. code:: javascript

      const hasOwnProp = Function.prototype.call
      .bind(Object.prototype.hasOwnProperty);

   How does this code work? In line A in the example before the code above, we used
   the function method ``.call()`` to turn the function ``hasOwnProperty`` with one
   implicit parameter (``this``) and one explicit parameter (``propName``) into a
   function that has two explicit parameters (``obj`` and ``propName``).

   In other words â€“ method ``.call()`` invokes the function ``f`` referred to by
   its receiver (``this``):

   -  The first (explicit) parameter of ``.call()`` becomes the ``this`` of ``f``.
   -  The second (explicit) parameter of ``.call()`` becomes the first argument of
      ``f``.
   -  Etc.

   We use ``.bind()`` to create a version ``.call()`` whose ``this`` always refers
   to ``Object.prototype.hasOwnProperty``. That new version invokes
   ``.hasOwnProperty()`` in the same manner as we did in line AÂ â€“ which is what we
   want.

   .. container:: boxout

      |Icon â€œquestionâ€|â€‚**Is it never OK to use ``Object.prototype`` methods via
      dynamic dispatch?**

      .. container:: boxout-vspace

      In some cases we can be lazy and call ``Object.prototype`` methods like
      normal methods: If we know the receivers and they are fixed-layout objects.

      If, on the other hand, we donâ€™t know their receivers and/or they are
      dictionary objects, then we need to take precautions.



.. _Object.prototype.toString:

31.8.3â€ƒ``Object.prototype.toString()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   By overriding ``.toString()`` (in a subclass or an instance), we can configure
   how objects are converted to strings:

   .. code:: javascript
      :name: language-node-repl

      > String({toString() { return 'Hello!' }})
      'Hello!'
      > String({})
      '[object Object]'

   For converting objects to strings itâ€™s better to use ``String()`` because that
   also works with ``undefined`` and ``null``:

   .. code:: javascript
      :name: language-node-repl

      > undefined.toString()
      TypeError: Cannot read properties of undefined (reading 'toString')
      > null.toString()
      TypeError: Cannot read properties of null (reading 'toString')
      > String(undefined)
      'undefined'
      > String(null)
      'null'



.. _Object.prototype.toLocaleString:

31.8.4â€ƒ``Object.prototype.toLocaleString()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.toLocaleString()`` is a version of ``.toString()`` that can be configured via
   a locale and often additional options. Any class or instance can implement this
   method. In the standard library, the following classes do:

   -  ``Array.prototype.toLocaleString()``
   -  ``Number.prototype.toLocaleString()``
   -  ``Date.prototype.toLocaleString()``
   -  ``TypedArray.prototype.toLocaleString()``
   -  ``BigInt.prototype.toLocaleString()``

   As an example, this is how numbers with decimal fractions are converted to
   string differently, depending on locale (``'fr'`` is French, ``'en'`` is
   English):

   .. code:: javascript
      :name: language-node-repl

      > 123.45.toLocaleString('fr')
      '123,45'
      > 123.45.toLocaleString('en')
      '123.45'



.. _Object.prototype.valueOf:

31.8.5â€ƒ``Object.prototype.valueOf()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   By overriding ``.valueOf()`` (in a subclass or an instance), we can configure
   how objects are converted to non-string values (often numbers):

   .. code:: javascript
      :name: language-node-repl

      > Number({valueOf() { return 123 }})
      123
      > Number({})
      NaN



.. _Object.prototype.isPrototypeOf:

31.8.6â€ƒ``Object.prototype.isPrototypeOf()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``proto.isPrototypeOf(obj)`` returns ``true`` if ``proto`` is in the prototype
   chain of ``obj`` and ``false`` otherwise.

   .. code:: javascript

      const a = {};
      const b = {__proto__: a};
      const c = {__proto__: b};

      assert.equal(a.isPrototypeOf(b), true);
      assert.equal(a.isPrototypeOf(c), true);

      assert.equal(a.isPrototypeOf(a), false);
      assert.equal(c.isPrototypeOf(a), false);

   This is how to use this method safely (for details see `â€œUsing
   ``Object.prototype`` methods safelyâ€
   (Â§31.8.2) <#using-object-methods-safely>`__):

   .. code:: javascript

      const obj = {
      // Overrides Object.prototype.isPrototypeOf
      isPrototypeOf: true,
      };
      // Doesnâ€™t work in this case:
      assert.throws(
      () => obj.isPrototypeOf(Object.prototype),
      {
         name: 'TypeError',
         message: 'obj.isPrototypeOf is not a function',
      }
      );
      // Safe way of using .isPrototypeOf():
      assert.equal(
      Object.prototype.isPrototypeOf.call(obj, Object.prototype), false
      );



.. _Object.prototype.propertyIsEnumerable:

31.8.7â€ƒ``Object.prototype.propertyIsEnumerable()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``obj.propertyIsEnumerable(propKey)`` returns ``true`` if ``obj`` has an own
   enumerable property whose key is ``propKey`` and ``false`` otherwise.

   .. code:: javascript

      const proto = {
      enumerableProtoProp: true,
      };
      const obj = {
      __proto__: proto,
      enumerableObjProp: true,
      nonEnumObjProp: true,
      };
      Object.defineProperty(
      obj, 'nonEnumObjProp',
      {
         enumerable: false,
      }
      );

      assert.equal(
      obj.propertyIsEnumerable('enumerableProtoProp'),
      false // not an own property
      );
      assert.equal(
      obj.propertyIsEnumerable('enumerableObjProp'),
      true
      );
      assert.equal(
      obj.propertyIsEnumerable('nonEnumObjProp'),
      false // not enumerable
      );
      assert.equal(
      obj.propertyIsEnumerable('unknownProp'),
      false // not a property
      );

   This is how to use this method safely (for details see `â€œUsing
   ``Object.prototype`` methods safelyâ€
   (Â§31.8.2) <#using-object-methods-safely>`__):

   .. code:: javascript

      const obj = {
      // Overrides Object.prototype.propertyIsEnumerable
      propertyIsEnumerable: true,
      enumerableProp: 'yes',
      };
      // Doesnâ€™t work in this case:
      assert.throws(
      () => obj.propertyIsEnumerable('enumerableProp'),
      {
         name: 'TypeError',
         message: 'obj.propertyIsEnumerable is not a function',
      }
      );
      // Safe way of using .propertyIsEnumerable():
      assert.equal(
      Object.prototype.propertyIsEnumerable.call(obj, 'enumerableProp'),
      true
      );

   Another safe alternative is to use `property
   descriptors <#property-attributes-property-descriptors>`__:

   .. code:: javascript

      assert.deepEqual(
      Object.getOwnPropertyDescriptor(obj, 'enumerableProp'),
      {
         value: 'yes',
         writable: true,
         enumerable: true,
         configurable: true,
      }
      );



.. _Object.prototype.__proto__:

31.8.8â€ƒ``Object.prototype.__proto__`` (accessor)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Property ``__proto__`` exists in two versions:

   -  An accessor that all instances of ``Object`` have.
   -  A property of object literals that sets the prototypes of the objects created
      by them.

   I recommend to avoid the former feature:

   -  As explained in `â€œUsing ``Object.prototype`` methods safelyâ€
      (Â§31.8.2) <#using-object-methods-safely>`__, it doesnâ€™t work with all
      objects.
   -  The ECMAScript specification has deprecated it and calls it `â€œoptionalâ€ and
      â€œlegacyâ€ <https://tc39.es/ecma262/#sec-object.prototype.__proto__>`__.

   In contrast, ``__proto__`` in object literals always works and is not
   deprecated.

   Read on if you are interested in how the accessor ``__proto__`` works.

   ``__proto__`` is an accessor of ``Object.prototype`` that is inherited by all
   instances of ``Object``. Implementing it via a class would look like this:

   .. code:: javascript

      class Object {
      get __proto__() {
         return Object.getPrototypeOf(this);
      }
      set __proto__(other) {
         Object.setPrototypeOf(this, other);
      }
      // Â·Â·Â·
      }

   Since ``__proto__`` is inherited from ``Object.prototype``, we can remove this
   feature by creating an object that doesnâ€™t have ``Object.prototype`` in its
   prototype chain (see `â€œNot all objects are instances of ``Object``\ â€
   (Â§31.7.3) <#non-instances-of-object>`__):

   .. code:: javascript
      :name: language-node-repl

      > '__proto__' in {}
      true
      > '__proto__' in Object.create(null)
      false



.. _Object.prototype.hasOwnProperty:

31.8.9â€ƒ``Object.prototype.hasOwnProperty()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. container:: boxout

      |Icon â€œwarningâ€|â€‚**Better alternative to ``.hasOwnProperty()``:
      ``Object.hasOwn()`` [ES2022]**

      .. container:: boxout-vspace

      See `â€œ\ ``Object.hasOwn()``: Is a given property own (non-inherited)?â€
      (Â§30.10.4) <#Object.hasOwn>`__.

   ``obj.hasOwnProperty(propKey)`` returns ``true`` if ``obj`` has an own
   (non-inherited) property whose key is ``propKey`` and ``false`` otherwise.

   .. code:: javascript

      const obj = { ownProp: true };
      assert.equal(
      obj.hasOwnProperty('ownProp'), true // own
      );
      assert.equal(
      'toString' in obj, true // inherited
      );
      assert.equal(
      obj.hasOwnProperty('toString'), false
      );

   This is how to use this method safely (for details see `â€œUsing
   ``Object.prototype`` methods safelyâ€
   (Â§31.8.2) <#using-object-methods-safely>`__):

   .. code:: javascript

      const obj = {
      // Overrides Object.prototype.hasOwnProperty
      hasOwnProperty: true,
      };
      // Doesnâ€™t work in this case:
      assert.throws(
      () => obj.hasOwnProperty('anyPropKey'),
      {
         name: 'TypeError',
         message: 'obj.hasOwnProperty is not a function',
      }
      );
      // Safe way of using .hasOwnProperty():
      assert.equal(
      Object.prototype.hasOwnProperty.call(obj, 'anyPropKey'), false
      );

31.9â€ƒFAQ: classes
------------------

31.9.1â€ƒWhy are they called â€œinstance private fieldsâ€ in this book and not â€œprivate instance fieldsâ€?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   That is done to highlight how different properties (public slots) and private
   slots are: By changing the order of the adjectives, the words â€œpublicâ€ and
   â€œfieldâ€ and the words â€œprivateâ€ and â€œfieldâ€ are always mentioned together.

31.9.2â€ƒWhy the identifier prefix ``#``? Why not declare private fields via ``private``?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Could private fields be declared via ``private`` and use normal identifiers?
   Letâ€™s examine what would happen if that were possible:

   .. code:: javascript

      class MyClass {
      private value; // (A)
      compare(other) {
         return this.value === other.value;
      }
      }

   Whenever an expression such as ``other.value`` appears in the body of
   ``MyClass``, JavaScript has to decide:

   -  Is ``.value`` a property?
   -  Is ``.value`` a private field?

   At compile time, JavaScript doesnâ€™t know if the declaration in line A applies to
   ``other`` (due to it being an instance of ``MyClass``) or not. That leaves two
   options for making the decision:

   #. ``.value`` is always interpreted as a private field.
   #. JavaScript decides at runtime:

      -  If ``other`` is an instance of ``MyClass``, then ``.value`` is interpreted
         as a private field.
      -  Otherwise ``.value`` is interpreted as a property.

   Both options have downsides:

   -  With option (1), we canâ€™t use ``.value`` as a property, anymore â€“ for any
      object.
   -  With option (2), performance is affected negatively.

   Thatâ€™s why the name prefix ``#`` was introduced. The decision is now easy: If we
   use ``#``, we want to access a private field. If we donâ€™t, we want to access a
   property.

   ``private`` works for statically typed languages (such as TypeScript) because
   they know at compile time if ``other`` is an instance of ``MyClass`` and can
   then treat ``.value`` as private or public.

   `Comments <https://github.com/rauschma/exploring-js/issues/19>`__




.. _ch_sync-iteration:

32â€ƒSynchronous iteration [ES6]
===============================

   #. `32.1â€ƒWhat is synchronous iteration about? <#what-is-synchronous-iteration-about>`__
   #. `32.2â€ƒCore iteration constructs: iterables and iterators <#iterable-iterator-iteratorresult>`__
   #. `32.3â€ƒIterating manually <#iterating-manually>`__

      #. `32.3.1â€ƒIterating over an iterable via while <#iterating-over-an-iterable-via-while>`__

   #. `32.4â€ƒIteration in practice <#iteration-in-practice>`__

      #. `32.4.1â€ƒIterating over Arrays <#iterating-over-arrays>`__
      #. `32.4.2â€ƒIterating over Sets <#iterating-over-sets>`__

   #. `32.5â€ƒGrouping iterables [ES2024] <#grouping-sync-iterables>`__

      #. `32.5.1â€ƒChoosing between Map.groupBy() and Object.groupBy() <#choosing-between-map-groupby-and-object-groupby>`__
      #. `32.5.2â€ƒExample: handling cases <#example-handling-cases>`__

   #. `32.6â€ƒExample: grouping by property value <#example-grouping-by-property-value>`__
   #. `32.7â€ƒQuick reference: synchronous iteration <#quickref-sync-iteration>`__

      #. `32.7.1â€ƒIterable data structures <#iterable-data-structures>`__
      #. `32.7.2â€ƒSynchronously iterating language constructs <#sync-iterating-constructs>`__

32.1â€ƒWhat is synchronous iteration about?
------------------------------------------

   Synchronous iteration is a *protocol* (interfaces plus rules for using them)
   that connects two groups of entities in JavaScript:

   -  **Data sources:** On one hand, data comes in all shapes and sizes. In
      JavaScriptâ€™s standard library, we have the linear data structure Array, the
      ordered collection Set (elements are ordered by time of addition), the
      ordered dictionary Map (entries are ordered by time of addition), and more.
      In libraries, we may find tree-shaped data structures and more.

   -  **Data consumers:** On the other hand, we have a whole class of constructs
      and algorithms that only need to access their input *sequentially*: one value
      at a time, until all values were visited. Examples include the ``for-of``
      loop and spreading into function calls (via ``...``).

   The iteration protocol connects these two groups via the interface ``Iterable``:
   data sources deliver their contents sequentially â€œthrough itâ€; data consumers
   get their input via it.

   .. figure:: https://exploringjs.com/js/book/img-book/sync-iteration/iterable-implementers-clients.svg
      name: fig:iterable-implementers-clients
      :width: 321px
      :height: 108px

      Figure 32.1: Data consumers such as the ``for-of`` loop use the interface
      ``Iterable``. Data sources such as ``Arrays`` implement that interface.

   `Figure 32.1 <#fig:iterable-implementers-clients>`__ illustrates how iteration
   works: data consumers use the interface ``Iterable``; data sources implement it.

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**The JavaScript way of implementing interfaces**

      .. container:: boxout-vspace

      In JavaScript, an object *implements* an interface if it has all the methods
      that it describes. The interfaces mentioned in this chapter only exist in the
      ECMAScript specification.

   Both sources and consumers of data profit from this arrangement:

   -  If we develop a new data structure, we only need to implement ``Iterable``
      and a raft of tools can immediately be applied to it.

   -  If we write code that uses iteration, it automatically works with many
      sources of data.



.. _iterable-iterator-iteratorresult:

32.2â€ƒCore iteration constructs: iterables and iterators
--------------------------------------------------------

   Two roles (described by interfaces) form the core of iteration (`figure
   32.2 <#fig:iteration-protocol>`__):

   -  An *iterable* is an object whose contents can be traversed sequentially.
   -  An *iterator* is the pointer used for the traversal.

   .. figure:: https://exploringjs.com/js/book/img-book/sync-iteration/iteration-protocol.svg
      name: fig:iteration-protocol
      :width: 413px
      :height: 83px

      Figure 32.2: Iteration has two main interfaces: ``Iterable`` and
      ``Iterator``. The former has a method that returns the latter.

   These are type definitions (in TypeScriptâ€™s notation) for the interfaces of the
   iteration protocol:

   .. code:: javascript
      :name: language-ts

      interface Iterable<T> {
      [Symbol.iterator]() : Iterator<T>;
      }

      interface Iterator<T> {
      next() : IteratorResult<T>;
      }

      interface IteratorResult<T> {
      value: T;
      done: boolean;
      }

   The interfaces are used as follows:

   -  We ask an ``Iterable`` for an iterator via the method whose key is
      ``Symbol.iterator``.
   -  The ``Iterator`` returns the iterated values via its method ``.next()``.
   -  The values are not returned directly, but wrapped in objects with two
      properties:

      -  ``.value`` is the iterated value.
      -  ``.done`` indicates if the end of the iteration has been reached yet. It
         is ``true`` after the last iterated value and ``false`` beforehand.

32.3â€ƒIterating manually
------------------------

   This is an example of using the iteration protocol:

   .. code:: javascript

      const iterable = ['a', 'b'];

      // The iterable is a factory for iterators:
      const iterator = iterable[Symbol.iterator]();

      // Call .next() until .done is true:
      assert.deepEqual(
      iterator.next(), { value: 'a', done: false });
      assert.deepEqual(
      iterator.next(), { value: 'b', done: false });
      assert.deepEqual(
      iterator.next(), { value: undefined, done: true });

32.3.1â€ƒIterating over an iterable via ``while``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following code demonstrates how to use a ``while`` loop to iterate over an
   iterable:

   .. code:: javascript

      function logAll(iterable) {
      const iterator = iterable[Symbol.iterator]();
      while (true) {
         const {value, done} = iterator.next();
         if (done) break;
         console.log(value);
      }
      }

      logAll(['a', 'b']);

   Output:

   ::

      a
      b

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Using sync iteration manually**

      .. container:: boxout-vspace

      ``exercises/sync-iteration-use/sync_iteration_manually_exrc.mjs``

32.4â€ƒIteration in practice
---------------------------

   We have seen how to use the iteration protocol manually, and it is relatively
   cumbersome. But the protocol is not meant to be used directly â€“ it is meant to
   be used via higher-level language constructs built on top of it. This section
   shows what that looks like.

32.4.1â€ƒIterating over Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScriptâ€™s Arrays are iterable. That enables us to use the ``for-of`` loop:

   .. code:: javascript

      const myArray = ['a', 'b', 'c'];

      for (const x of myArray) {
      console.log(x);
      }

   Output:

   ::

      a
      b
      c

   Destructuring via Array patterns (explained later) also uses iteration under the
   hood:

   .. code:: javascript

      const [first, second] = myArray;
      assert.equal(first, 'a');
      assert.equal(second, 'b');

32.4.2â€ƒIterating over Sets
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScriptâ€™s Set data structure is iterable. That means ``for-of`` works:

   .. code:: javascript

      const mySet = new Set().add('a').add('b').add('c');

      for (const x of mySet) {
      console.log(x);
      }

   Output:

   ::

      a
      b
      c

   As does Array-destructuring:

   .. code:: javascript

      const [first, second] = mySet;
      assert.equal(first, 'a');
      assert.equal(second, 'b');



.. _grouping-sync-iterables:

32.5â€ƒGrouping iterables [ES2024]
---------------------------------

   ``Map.groupBy()`` groups the items of an iterable into Map entries whose keys
   are provided by a callback:

   .. code:: javascript

      assert.deepEqual(
      Map.groupBy([0, -5, 3, -4, 8, 9], x => Math.sign(x)),
      new Map().set(0, [0]).set(-1, [-5,-4]).set(1, [3,8,9])
      );

   The items to be grouped can come from any iterable:

   .. code:: javascript

      function* generateNumbers() {
      yield 2;
      yield -7;
      yield 4;
      }
      assert.deepEqual(
      Map.groupBy(generateNumbers(), x => Math.sign(x)),
      new Map().set(1, [2,4]).set(-1, [-7])
      );

   There is also ``Object.groupBy()`` which produces an object instead of a Map:

   .. code:: javascript

      assert.deepEqual(
      Object.groupBy([0, -5, 3, -4, 8, 9], x => Math.sign(x)),
      {'0': [0], '-1': [-5,-4], '1': [3,8,9], __proto__: null}
      );



.. _choosing-between-map-groupby-and-object-groupby:

32.5.1â€ƒChoosing between ``Map.groupBy()`` and ``Object.groupBy()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  Do you want group keys other than strings and symbols?

      -  Then you need a Map. Objects can only have strings and symbols as keys.

   -  Do you want to destructure the result of ``.groupBy()`` (see example later in
      this section)?

      -  Then you need an object.

   -  Otherwise, you are free to choose what you prefer.

32.5.2â€ƒExample: handling cases
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The Promise combinator
   `Promise.allSettled() <#Promise.allSettled>`__ returns
   Arrays such as the following one:

   .. code:: javascript

      const settled = [
      { status: 'rejected', reason: 'Jhon' },
      { status: 'fulfilled', value: 'Jane' },
      { status: 'fulfilled', value: 'John' },
      { status: 'rejected', reason: 'Jaen' },
      { status: 'rejected', reason: 'Jnoh' },
      ];

   We can group the Array elements as follows:

   .. code:: javascript

      const {fulfilled, rejected} = Object.groupBy(settled, x => x.status); // (A)

      // Handle fulfilled results
      assert.deepEqual(
      fulfilled,
      [
         { status: 'fulfilled', value: 'Jane' },
         { status: 'fulfilled', value: 'John' },
      ]
      );

      // Handle rejected results
      assert.deepEqual(
      rejected,
      [
         { status: 'rejected', reason: 'Jhon' },
         { status: 'rejected', reason: 'Jaen' },
         { status: 'rejected', reason: 'Jnoh' },
      ]
      );

   For this use case, ``Object.groupBy()`` works better because we can use
   destructuring (line A).

32.6â€ƒExample: grouping by property value
-----------------------------------------

   In the next example, weâ€™d like to group persons by country:

   .. code:: javascript

      const persons = [
      { name: 'Louise', country: 'France' },
      { name: 'Felix', country: 'Germany' },
      { name: 'Ava', country: 'USA' },
      { name: 'LÃ©o', country: 'France' },
      { name: 'Oliver', country: 'USA' },
      { name: 'Leni', country: 'Germany' },
      ];

      assert.deepEqual(
      Map.groupBy(persons, (person) => person.country),
      new Map([
         [
            'France',
            [
            { name: 'Louise', country: 'France' },
            { name: 'LÃ©o', country: 'France' },
            ]
         ],
         [
            'Germany',
            [
            { name: 'Felix', country: 'Germany' },
            { name: 'Leni', country: 'Germany' },
            ]
         ],
         [
            'USA',
            [
            { name: 'Ava', country: 'USA' },
            { name: 'Oliver', country: 'USA' },
            ]
         ],
      ])
      );

   For this use case, ``Map.groupBy()`` is a better choice because we can use
   arbitrary keys in Maps whereas in objects, keys are limited to strings and
   symbols.



.. _quickref-sync-iteration:

32.7â€ƒQuick reference: synchronous iteration
--------------------------------------------

32.7.1â€ƒIterable data structures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following built-in data structures are iterable:

   -  Arrays
   -  Strings
   -  Maps
   -  Sets
   -  (Browsers: DOM data structures)

   To iterate over the properties of objects, we need helpers such as
   ``Object.keys()`` and ``Object.entries()``. That is necessary because properties
   exist at a different level that is independent of the level of data structures.



.. _sync-iterating-constructs:

32.7.2â€ƒSynchronously iterating language constructs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This section lists constructs that use synchronous iteration.

32.7.2.1â€ƒLanguage constructs that iterate
''''''''''''''''''''''''''''''''''''''''''

   -  Destructuring via an Array pattern:

      .. code:: javascript

         const [x,y] = iterable;

   -  Spreading (via ``...``) into function calls and Array literals:

      .. code:: javascript

         func(...iterable);
         const arr = [...iterable];

   -  The ``for-of`` loop:

      .. code:: javascript

         for (const x of iterable) { /*Â·Â·Â·*/ }

   -  ``yield*``:

      .. code:: javascript

         function* generatorFunction() {
         yield* iterable;
         }

32.7.2.2â€ƒTurning iterables into data structures and Promises
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   -  `Object.fromEntries() <#Object.fromEntries>`__:

      .. code:: javascript

         const obj = Object.fromEntries(iterableOverKeyValuePairs);

   -  `Array.from() <#Array.from>`__:

      .. code:: javascript

         const arr = Array.from(iterable);

   -  `new Map() <#ch_maps>`__ and
      `new WeakMap() <#ch_weakmaps>`__:

      .. code:: javascript

         const m  = new Map(iterableOverKeyValuePairs);
         const wm = new WeakMap(iterableOverKeyValuePairs);

   -  `new Set() <#ch_sets>`__ and
      `new WeakSet() <#ch_weaksets>`__:

      .. code:: javascript

         const s  = new Set(iterableOverElements);
         const ws = new WeakSet(iterableOverElements);

   -  `Promise combinator functions <#promise-combinators>`__:
      ``Promise.all()`` etc.

      .. code:: javascript

         const promise1 = Promise.all(iterableOverPromises);
         const promise2 = Promise.race(iterableOverPromises);
         const promise3 = Promise.any(iterableOverPromises);
         const promise4 = Promise.allSettled(iterableOverPromises);

32.7.2.3â€ƒGrouping an iterable into a Map or an object
''''''''''''''''''''''''''''''''''''''''''''''''''''''

   -  `â€œ\ ``Map.groupBy(items, computeGroupKey)``\ â€ <#qref-Map.groupBy>`__
   -  `â€œ\ ``Object.groupBy(items, computeGroupKey)``\ â€ <#qref-Object.groupBy>`__

   `Comments <https://github.com/rauschma/exploring-js/issues/21>`__



.. _ch_arrays:

33â€ƒArrays (``Array``)
======================

   #. `33.1â€ƒCheat sheet: Arrays <#cheat-sheet-arrays>`__

      #. `33.1.1â€ƒUsing Arrays <#using-arrays>`__
      #. `33.1.2â€ƒThe most commonly used Array methods <#the-most-commonly-used-array-methods>`__

   #. `33.2â€ƒWays of using Arrays: fixed layout vs. sequence <#arrays-fixed-layout-vs-sequence>`__
   #. `33.3â€ƒBasic Array operations <#basic-array-operations>`__

      #. `33.3.1â€ƒCreating, reading, writing Arrays <#array-literals>`__
      #. `33.3.2â€ƒThe .length of an Array <#the-length-of-an-array>`__
      #. `33.3.3â€ƒReferring to elements via negative indices <#referring-to-elements-via-negative-indices>`__
      #. `33.3.4â€ƒClearing Arrays <#clearing-arrays>`__
      #. `33.3.5â€ƒSpreading into Array literals <#spreading-into-array-literals>`__
      #. `33.3.6â€ƒArrays: listing indices and entries <#arrays-listing-indices-and-entries>`__
      #. `33.3.7â€ƒChecking if a value is an Array: Array.isArray() <#checking-if-a-value-is-an-array-array-isarray>`__

   #. `33.4â€ƒfor-of and Arrays <#for-of-and-arrays>`__

      #. `33.4.1â€ƒfor-of: iterating over elements <#for-of-iterating-over-elements>`__
      #. `33.4.2â€ƒfor-of: iterating over indices <#for-of-iterating-over-indices>`__
      #. `33.4.3â€ƒfor-of: iterating over [index, element] pairs <#for-of-iterating-over-index-element-pairs>`__

   #. `33.5â€ƒArray-like objects <#array-like-objects>`__
   #. `33.6â€ƒConverting iterables and Array-like values to Arrays <#converting-to-array>`__

      #. `33.6.1â€ƒConverting iterables to Arrays via spreading (...) <#converting-iterables-to-arrays-via-spreading>`__
      #. `33.6.2â€ƒConverting iterables and Array-like objects to Arrays via Array.from() <#Array.from>`__

   #. `33.7â€ƒCreating and filling Arrays with arbitrary lengths <#filling-arrays>`__

      #. `33.7.1â€ƒCreating an Array and adding elements later <#creating-array-adding-elements-later>`__
      #. `33.7.2â€ƒCreating an Array filled with a primitive value <#creating-array-with-primitives>`__
      #. `33.7.3â€ƒCreating an Array filled with objects <#creating-array-with-objects>`__
      #. `33.7.4â€ƒCreating an Array with a range of integers <#creating-array-with-range-of-integers>`__
      #. `33.7.5â€ƒTyped Arrays work well if the elements are all integers or all floats <#typed-arrays-work-well-if-the-elements-are-all-integers-or-all-floats>`__

   #. `33.8â€ƒMultidimensional Arrays <#multidimensional-arrays>`__
   #. `33.9â€ƒArrays are actually dictionaries (advanced) <#arrays-are-actually-dictionaries>`__

      #. `33.9.1â€ƒArray indices are (slightly special) property keys <#array-indices>`__
      #. `33.9.2â€ƒArrays can have holes <#array-holes>`__

   #. `33.10â€ƒDestructive vs. non-destructive Array operations <#array-operations-destructive-vs-non-destructive>`__

      #. `33.10.1â€ƒHow to make destructive Array methods non-destructive <#how-to-make-destructive-array-methods-non-destructive>`__
      #. `33.10.2â€ƒNon-destructive versions of .reverse(), .sort(), .splice() [ES2023] <#non-destructive-versions-of-reverse-sort-splice>`__

   #. `33.11â€ƒAdding and removing elements at either end of an Array <#adding-and-removing-elements-at-either-end-of-an-array>`__

      #. `33.11.1â€ƒDestructively adding and removing elements at either end of an Array <#destructively-adding-and-removing-elements-at-either-end-of-an-array>`__
      #. `33.11.2â€ƒNon-destructively prepending and appending elements <#non-destructively-prepending-and-appending-elements>`__

   #. `33.12â€ƒArray methods that accept element callbacks <#array-element-callbacks>`__
   #. `33.13â€ƒTransforming with element callbacks: .map(), .filter(), .flatMap() <#transforming-with-element-callbacks-map-filter-flatmap>`__

      #. `33.13.1â€ƒ.map(): Each output element is derived from its input element <#map-each-output-element-is-derived-from-its-input-element>`__
      #. `33.13.2â€ƒ.filter(): Only keep some of the elements <#filter-only-keep-some-of-the-elements>`__
      #. `33.13.3â€ƒ.flatMap(): Replace each input element with zero or more output elements [ES2019] <#Array.prototype.flatMap>`__

   #. `33.14â€ƒ.reduce(): computing a summary for an Array <#Array.prototype.reduce>`__

      #. `33.14.1â€ƒ.reduceRight(): the end-to-start version of .reduce() <#Array.prototype.reduceRight>`__

   #. `33.15â€ƒ.sort(): sorting Arrays <#Array.prototype.sort>`__

      #. `33.15.1â€ƒCustomizing the sort order <#customizing-array-sorting>`__
      #. `33.15.2â€ƒSorting numbers <#sorting-numbers>`__
      #. `33.15.3â€ƒA trick for sorting numbers <#a-trick-for-sorting-numbers>`__
      #. `33.15.4â€ƒSorting human-language strings <#sorting-human-language-strings>`__
      #. `33.15.5â€ƒSorting objects <#sorting-objects>`__

   #. `33.16â€ƒArrays can use operations for iterables <#arrays-can-use-operations-for-iterables>`__
   #. `33.17â€ƒQuick reference: Array <#quickref-Array>`__

      #. `33.17.1â€ƒnew Array() <#new-array>`__
      #. `33.17.2â€ƒArray.* <#array>`__
      #. `33.17.3â€ƒArray.prototype.*: getting, setting and visiting single elements <#array-prototype-getting-setting-and-visiting-single-elements>`__
      #. `33.17.4â€ƒArray.prototype.*: keys and values <#array-prototype-keys-and-values>`__
      #. `33.17.5â€ƒArray.prototype.*: destructively adding or removing elements at either end of an Array <#array-prototype-destructively-adding-or-removing-elements-at-either-end-of-an-array>`__
      #. `33.17.6â€ƒArray.prototype.*: combining, extracting and changing sequences of elements <#array-prototype-combining-extracting-and-changing-sequences-of-elements>`__
      #. `33.17.7â€ƒArray.prototype.*: searching for elements <#array-prototype-searching-for-elements>`__
      #. `33.17.8â€ƒArray.prototype.*: filtering and mapping <#array-prototype-filtering-and-mapping>`__
      #. `33.17.9â€ƒArray.prototype.*: computing summaries <#array-prototype-computing-summaries>`__
      #. `33.17.10â€ƒArray.prototype.*: converting to string <#array-prototype-converting-to-string>`__
      #. `33.17.11â€ƒArray.prototype.*: sorting and reversing <#array-prototype-sorting-and-reversing>`__
      #. `33.17.12â€ƒSources of the quick reference <#sources-of-the-quick-reference>`__

33.1â€ƒCheat sheet: Arrays
-------------------------

   JavaScript Arrays are a very flexible data structure and used as lists, stacks,
   queues, tuples (e.g. pairs), and more.

   Some Array-related operations destructively change Arrays. Others
   non-destructively produce new Arrays with the changes applied to a copy of the
   original content.

33.1.1â€ƒUsing Arrays
~~~~~~~~~~~~~~~~~~~~

   Creating an Array, reading and writing elements:

   .. code:: javascript

      // Creating an Array
      const arr = ['a', 'b', 'c']; // Array literal
      assert.deepEqual(
      arr,
      [ // Array literal
         'a',
         'b',
         'c', // trailing commas are ignored
      ]
      );

      // Reading elements
      assert.equal(
      arr[0], 'a' // negative indices donâ€™t work
      );
      assert.equal(
      arr.at(-1), 'c' // negative indices work
      );

      // Writing an element
      arr[0] = 'x';
      assert.deepEqual(
      arr, ['x', 'b', 'c']
      );

   The length of an Array:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      assert.equal(
      arr.length, 3 // number of elements
      );
      arr.length = 1; // removing elements
      assert.deepEqual(
      arr, ['a']
      );
      arr[arr.length] = 'b'; // adding an element
      assert.deepEqual(
      arr, ['a', 'b']
      );

   Adding elements destructively via ``.push()``:

   .. code:: javascript

      const arr = ['a', 'b'];

      arr.push('c'); // adding an element
      assert.deepEqual(
      arr, ['a', 'b', 'c']
      );

      // Pushing Arrays (used as arguments via spreading (...)):
      arr.push(...['d', 'e']);
      assert.deepEqual(
      arr, ['a', 'b', 'c', 'd', 'e']
      );

   Adding elements non-destructively via spreading (``...``):

   .. code:: javascript

      const arr1 = ['a', 'b'];
      const arr2 = ['c'];
      assert.deepEqual(
      [...arr1, ...arr2, 'd', 'e'],
      ['a', 'b', 'c', 'd', 'e']
      );

   Looping over elements:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      for (const value of arr) {
      console.log(value);
      }

   Output:

   ::

      a
      b
      c

   Looping over index-value pairs:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      for (const [index, value] of arr.entries()) {
      console.log(index, value);
      }

   Output:

   ::

      0 a
      1 b
      2 c

33.1.2â€ƒThe most commonly used Array methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This section demonstrates a few common Array methods. There is `a more
   comprehensive quick reference <#quickref-Array>`__ at the end of this chapter.

   Destructively adding or removing an Array element at the start or the end:

   .. code:: javascript

      // Adding and removing at the start
      const arr1 = ['â– ', 'â—'];
      arr1.unshift('â–²');
      assert.deepEqual(
      arr1, ['â–²', 'â– ', 'â—']
      );
      arr1.shift();
      assert.deepEqual(
      arr1, ['â– ', 'â—']
      );

      // Adding and removing at the end
      const arr2 = ['â– ', 'â—'];
      arr2.push('â–²');
      assert.deepEqual(
      arr2, ['â– ', 'â—', 'â–²']
      );
      arr2.pop();
      assert.deepEqual(
      arr2, ['â– ', 'â—']
      );

   Finding Array elements:

   .. code:: javascript
      :name: language-node-repl

      > ['â– ', 'â—', 'â– '].includes('â– ')
      true
      > ['â– ', 'â—', 'â– '].indexOf('â– ')
      0
      > ['â– ', 'â—', 'â– '].lastIndexOf('â– ')
      2
      > ['â—', '', 'â–²'].find(x => x.length > 0)
      'â—'
      > ['â—', '', 'â–²'].findLast(x => x.length > 0)
      'â–²'
      > ['â—', '', 'â–²'].findIndex(x => x.length > 0)
      0
      > ['â—', '', 'â–²'].findLastIndex(x => x.length > 0)
      2

   Transforming Arrays (creating new ones without changing the originals):

   .. code:: javascript
      :name: language-node-repl

      > ['â–²', 'â—'].map(x => x+x)
      ['â–²â–²', 'â—â—']
      > ['â– ', 'â—', 'â– '].filter(x => x === 'â– ') 
      ['â– ', 'â– ']
      > ['â–²', 'â—'].flatMap(x => [x,x])
      ['â–²', 'â–²', 'â—', 'â—']

   Copying parts of an Array:

   .. code:: javascript
      :name: language-node-repl

      > ['â– ', 'â—', 'â–²'].slice(1, 3)
      ['â—', 'â–²']
      > ['â– ', 'â—', 'â–²'].slice() // complete copy
      ['â– ', 'â—', 'â–²']

   Concatenating the strings in an Array:

   .. code:: javascript
      :name: language-node-repl

      > ['â– ','â—','â–²'].join('-')
      'â– -â—-â–²'
      > ['â– ','â—','â–²'].join('')
      'â– â—â–²'

   ``.sort()`` sorts its receiver and returns it (if we donâ€™t want to change the
   receiver, we can use `.toSorted() <#qref-Array.prototype.toSorted>`__):

   .. code:: javascript

      // By default, string representations of the Array elements
      // are sorted lexicographically:
      const arr = [200, 3, 10];
      arr.sort();
      assert.deepEqual(
      arr, [10, 200, 3]
      );

      // Sorting can be customized via a callback:
      assert.deepEqual(
      [200, 3, 10].sort((a, z) => a - z), // sort numerically
      [3, 10, 200]
      );



.. _arrays-fixed-layout-vs-sequence:

33.2â€ƒWays of using Arrays: fixed layout vs. sequence
-----------------------------------------------------

   There are two ways of using Arrays in JavaScript:

   -  Fixed-layout Arrays: Used this way, Arrays have a fixed number of indexed
      elements. Each of those elements can have a different type.
   -  Sequence Arrays: Used this way, Arrays have a variable number of indexed
      elements. Each of those elements has the same type.

   Normally, an Array is used in either of these ways. But we can also mix the two
   approaches.

   As an example of the difference between the two ways, consider the Array
   returned by ``Object.entries()``:

   .. code:: javascript
      :name: language-node-repl

      > Object.entries({a:1, b:2, c:3})
      [
      [ 'a', 1 ],
      [ 'b', 2 ],
      [ 'c', 3 ],
      ]

   It is a sequence of *pairs* â€“ fixed-layout Arrays with a length of two.

   Note that the difference between fixed layout and sequence may not

   Sequence Arrays are very flexible that we can use them as (traditional) arrays,
   stacks, and queues. Weâ€™ll see how later.

33.3â€ƒBasic Array operations
----------------------------



.. _array-literals:

33.3.1â€ƒCreating, reading, writing Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The best way to create an Array is via an *Array literal*:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];

   The Array literal starts and ends with square brackets ``[]``. It creates an
   Array with three *elements*: ``'a'``, ``'b'``, and ``'c'``.

   Trailing commas are allowed and ignored in Array literals:

   .. code:: javascript

      const arr = [
      'a',
      'b',
      'c',
      ];

   To read an Array element, we put an index in square brackets (indices start at
   zero):

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      assert.equal(arr[0], 'a');

   To change an Array element, we assign to an Array with an index:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      arr[0] = 'x';
      assert.deepEqual(arr, ['x', 'b', 'c']);

   The range of Array indices is 32 bits (excluding the maximum length): [0,
   2\ :sup:`32`\ âˆ’1)



.. _the-length-of-an-array:

33.3.2â€ƒThe ``.length`` of an Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Every Array has a property ``.length`` that can be used to both read and
   change(!) the number of elements in an Array.

   The length of an Array is always the highest index plus one:

   .. code:: javascript
      :name: language-node-repl

      > const arr = ['a', 'b'];
      > arr.length
      2

   If we write to the Array at the index of the length, we append an element:

   .. code:: javascript
      :name: language-node-repl

      > arr[arr.length] = 'c';
      > arr
      [ 'a', 'b', 'c' ]
      > arr.length
      3

   Another way of (destructively) appending an element is via the Array method
   ``.push()``:

   .. code:: javascript
      :name: language-node-repl

      > arr.push('d');
      > arr
      [ 'a', 'b', 'c', 'd' ]

   If we set ``.length``, we are pruning the Array by removing elements:

   .. code:: javascript
      :name: language-node-repl

      > arr.length = 1;
      > arr
      [ 'a' ]

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Removing empty lines via ``.push()``**

      .. container:: boxout-vspace

      ``exercises/arrays/remove_empty_lines_push_test.mjs``

33.3.3â€ƒReferring to elements via negative indices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Most Array methods support negative indices. If an index is negative, it is
   added to the length of an Array to produce a usable index. Therefore, the
   following two invocations of ``.slice()`` are equivalent: They both copy ``arr``
   starting at the last element.

   .. code:: javascript
      :name: language-node-repl

      > const arr = ['a', 'b', 'c'];
      > arr.slice(-1)
      [ 'c' ]
      > arr.slice(arr.length - 1)
      [ 'c' ]



.. _Array.prototype.at:

33.3.3.1â€ƒ``.at()``: reading single elements (supports negative indices) [ES2022]
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The Array method ``.at()`` returns the element at a given index. It supports
   positive and negative indices (``-1`` refers to the last element, ``-2`` refers
   to the second-last element, etc.):

   .. code:: javascript
      :name: language-node-repl

      > ['a', 'b', 'c'].at(0)
      'a'
      > ['a', 'b', 'c'].at(-1)
      'c'

   In contrast, the bracket operator ``[]`` does not support negative indices (and
   canâ€™t be changed because that would break existing code). It interprets them as
   keys of non-element properties:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];

      arr[-1] = 'non-element property';
      // The Array elements didnâ€™t change:
      assert.deepEqual(
      Array.from(arr), // copy just the Array elements
      ['a', 'b', 'c']
      );

      assert.equal(
      arr[-1], 'non-element property'
      );

33.3.4â€ƒClearing Arrays
~~~~~~~~~~~~~~~~~~~~~~~

   To clear (empty) an Array, we can either set its ``.length`` to zero:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      arr.length = 0;
      assert.deepEqual(arr, []);

   or we can assign a new empty Array to the variable storing the Array:

   .. code:: javascript

      let arr = ['a', 'b', 'c'];
      arr = [];
      assert.deepEqual(arr, []);

   The latter approach has the advantage of not affecting other locations that
   point to the same Array. If, however, we do want to reset a shared Array for
   everyone, then we need the former approach.

33.3.5â€ƒSpreading into Array literals
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Inside an Array literal, a *spread element* consists of three dots (``...``)
   followed by an expression. It results in the expression being evaluated and then
   iterated over. Each iterated value becomes an additional Array element â€“ for
   example:

   .. code:: javascript
      :name: language-node-repl

      > const iterable = ['b', 'c'];
      > ['a', ...iterable, 'd']
      [ 'a', 'b', 'c', 'd' ]

   That means that we can use spreading to create a copy of an Array and to convert
   an iterable to an Array:

   .. code:: javascript

      const original = ['a', 'b', 'c'];

      const copy = [...original];

      const iterable = original.keys();
      assert.deepEqual(
      [...iterable], [0, 1, 2]
      );

   However, for both previous use cases, I find ``Array.from()`` more
   self-descriptive and prefer it:

   .. code:: javascript

      const copy2 = Array.from(original);

      assert.deepEqual(
      Array.from(original.keys()), [0, 1, 2]
      );

   Spreading is also convenient for concatenating Arrays (and other iterables) into
   Arrays:

   .. code:: javascript

      const arr1 = ['a', 'b'];
      const arr2 = ['c', 'd'];

      const concatenated = [...arr1, ...arr2, 'e'];
      assert.deepEqual(
      concatenated,
      ['a', 'b', 'c', 'd', 'e']);

   Due to spreading using iteration, it only works if the value is iterable:

   .. code:: javascript
      :name: language-node-repl

      > [...'abc'] // strings are iterable
      [ 'a', 'b', 'c' ]
      > [...123]
      TypeError: 123 is not iterable
      > [...undefined]
      TypeError: undefined is not iterable

   .. container:: boxout

      |Icon â€œwarningâ€|â€‚**Spreading and ``Array.from()`` produce shallow copies**

      .. container:: boxout-vspace

      Copying Arrays via spreading or via ``Array.from()`` is shallow: We get new
      entries in a new Array, but the values are shared with the original Array.
      The consequences of shallow copying are demonstrated in `â€œSpreading into
      object literals (``...``)â€
      (Â§30.4) <#spreading-into-object-literals>`__.

33.3.6â€ƒArrays: listing indices and entries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Method ``.keys()`` lists the indices of an Array:

   .. code:: javascript

      const arr = ['a', 'b'];
      assert.deepEqual(
      Array.from(arr.keys()), // (A)
      [0, 1]);

   ``.keys()`` returns an iterable. In line A, we convert that iterable to an
   Array.

   Listing Array indices is different from listing properties. The former produces
   numbers; the latter produces stringified numbers (in addition to non-index
   property keys):

   .. code:: javascript

      const arr = ['a', 'b'];
      arr.prop = true;

      assert.deepEqual(
      Object.keys(arr),
      ['0', '1', 'prop']);

   Method ``.entries()`` lists the contents of an Array as [index, element] pairs:

   .. code:: javascript

      const arr = ['a', 'b'];
      assert.deepEqual(
      Array.from(arr.entries()),
      [[0, 'a'], [1, 'b']]);



.. _checking-if-a-value-is-an-array-array-isarray:

33.3.7â€ƒChecking if a value is an Array: ``Array.isArray()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``Array.isArray()`` checks if a value is an Array:

   .. code:: javascript
      :name: language-node-repl

      > Array.isArray([])
      true

   We can also use ``instanceof``:

   .. code:: javascript
      :name: language-node-repl

      > [] instanceof Array
      true

   However, ``instanceof`` has one downside: It doesnâ€™t work if a value comes from
   another *realm*. Roughly, a realm is an instance of JavaScriptâ€™s global scope.
   Some realms are isolated from each other (e.g., `Web
   Workers <#web-workers>`__ in browsers), but there are also
   realms between which we can move data â€“ for example, same-origin iframes in
   browsers. ``x instanceof Array`` checks the prototype chain of ``x`` and
   therefore returns ``false`` if ``x`` is an Array from another realm.

   ``typeof`` considers Arrays to be objects:

   .. code:: javascript
      :name: language-node-repl

      > typeof []
      'object'

33.4â€ƒ``for-of`` and Arrays
---------------------------

   We have already encountered the ``for-of`` loop earlier in this book. This
   section briefly recaps how to use it for Arrays.

33.4.1â€ƒ``for-of``: iterating over elements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following ``for-of`` loop iterates over the elements of an Array:

   .. code:: javascript

      for (const element of ['a', 'b']) {
      console.log(element);
      }

   Output:

   ::

      a
      b

33.4.2â€ƒ``for-of``: iterating over indices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This ``for-of`` loop iterates over the indices of an Array:

   .. code:: javascript

      for (const element of ['a', 'b'].keys()) {
      console.log(element);
      }

   Output:

   ::

      0
      1

33.4.3â€ƒ``for-of``: iterating over [index, element] pairs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following ``for-of`` loop iterates over [index, element] pairs.
   Destructuring (described `later <#ch_destructuring>`__),
   gives us convenient syntax for setting up ``index`` and ``element`` in the head
   of ``for-of``.

   .. code:: javascript

      for (const [index, element] of ['a', 'b'].entries()) {
      console.log(index, element);
      }

   Output:

   ::

      0 a
      1 b

33.5â€ƒArray-like objects
------------------------

   Some operations that work with Arrays require only the bare minimum: values must
   only be *Array-like*. An Array-like value is an object with the following
   properties:

   -  ``.length``: holds the length of the Array-like object. If this property is
      missing, the value ``0`` is used.
   -  ``[0]``: holds the element at index 0 (etc.). Note that if we use numbers as
      property names, they are always coerced to strings. Therefore, ``[0]``
      retrieves the value of the property whose key is ``'0'``.

   For example, ``Array.from()`` accepts Array-like objects and converts them to
   Arrays:

   .. code:: javascript

      // .length is implicitly 0 in this case
      assert.deepEqual(
      Array.from({}),
      []
      );

      assert.deepEqual(
      Array.from({length: 2, 0: 'a', 1: 'b'}),
      [ 'a', 'b' ]
      );

   The TypeScript interface for Array-like objects is:

   .. code:: javascript
      :name: language-ts

      interface ArrayLike<T> {
      length: number;
      [n: number]: T;
      }

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Array-like objects are relatively rare in modern
      JavaScript**

      .. container:: boxout-vspace

      Array-like objects used to be more common before ES6; now we donâ€™t see them
      very often.



.. _converting-to-array:

33.6â€ƒConverting iterables and Array-like values to Arrays
----------------------------------------------------------

   There are two common ways of converting iterables and Array-like values to
   Arrays:

   -  Spreading into Arrays
   -  ``Array.from()``

   I prefer the latter â€“ I find it more self-explanatory.



.. _converting-iterables-to-arrays-via-spreading:

33.6.1â€ƒConverting iterables to Arrays via spreading (``...``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Inside an Array literal, spreading via ``...`` converts any iterable object into
   a series of Array elements. For example:

   .. code:: javascript

      // Get an Array-like collection from a web browserâ€™s DOM
      const domCollection = document.querySelectorAll('a');

      // Alas, the collection is missing many Array methods
      assert.equal('slice' in domCollection, false);

      // Solution: convert it to an Array
      const arr = [...domCollection];
      assert.deepEqual(
      arr.map(x => x.href),
      ['https://2ality.com', 'https://exploringjs.com']);

   The conversion works because the DOM collection is iterable.



.. _Array.from:

33.6.2â€ƒConverting iterables and Array-like objects to Arrays via ``Array.from()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``Array.from()`` can be used in two modes.



.. _mode-1-of-array-from-converting:

33.6.2.1â€ƒMode 1 of ``Array.from()``: converting
''''''''''''''''''''''''''''''''''''''''''''''''

   The first mode has the following type signature:

   .. code:: javascript
      :name: language-ts

      .from<T>(iterable: Iterable<T> | ArrayLike<T>): Array<T>

   Interface ``Iterable`` is shown `in the chapter on synchronous
   iteration <#iterable-iterator-iteratorresult>`__.
   Interface ``ArrayLike`` appeared `earlier in this
   chapter <#array-like-objects>`__.

   With a single parameter, ``Array.from()`` converts anything iterable or
   Array-like to an Array:

   .. code:: javascript
      :name: language-node-repl

      > Array.from(new Set(['a', 'b'])) // iterable
      [ 'a', 'b' ]
      > Array.from({length: 2, 0:'a', 1:'b'}) // Array-like
      [ 'a', 'b' ]



.. _mode-2-of-array-from-converting-and-mapping:

33.6.2.2â€ƒMode 2 of ``Array.from()``: converting and mapping
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The second mode of ``Array.from()`` involves two parameters:

   .. code:: javascript
      :name: language-ts

      .from<T, U>(
      iterable: Iterable<T> | ArrayLike<T>,
      mapFunc: (v: T, i: number) => U,
      thisArg?: any)
      : Array<U>

   In this mode, ``Array.from()`` does several things:

   -  It iterates over ``iterable``.
   -  It calls ``mapFunc`` with each iterated value. The optional parameter
      ``thisArg`` specifies a ``this`` for ``mapFunc``.
   -  It applies ``mapFunc`` to each iterated value.
   -  It collects the results in a new Array and returns it.

   In other words: we are going from an iterable with elements of type ``T`` to an
   Array with elements of type ``U``.

   This is an example:

   .. code:: javascript
      :name: language-node-repl

      > Array.from(new Set(['a', 'b']), x => x + x)
      [ 'aa', 'bb' ]



.. _filling-arrays:

33.7â€ƒCreating and filling Arrays with arbitrary lengths
--------------------------------------------------------

   The best way of creating an Array is via an Array literal. However, we canâ€™t
   always use one: The Array may be too large, we may not know its length during
   development, or we may want to keep its length flexible. Then I recommend the
   following techniques for creating, and possibly filling, Arrays.



.. _creating-array-adding-elements-later:

33.7.1â€ƒCreating an Array and adding elements later
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The most common technique for creating an Array and adding elements later, is to
   start with an empty Array and push values into it:

   .. code:: javascript

      const arr = [];
      for (let i=0; i<3; i++) {
      arr.push('*'.repeat(i));
      }
      assert.deepEqual(
      arr, ['', '*', '**']
      );



.. _creating-array-with-primitives:

33.7.2â€ƒCreating an Array filled with a primitive value
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following code creates an Array that is filled with a primitive value:

   .. code:: javascript
      :name: language-node-repl

      > new Array(3).fill(0)
      [ 0, 0, 0 ]

   ``.fill()`` replaces each Array element or hole with a given value. We use it to
   fill an Array that has 3 holes:

   .. code:: javascript
      :name: language-node-repl

      > new Array(3)
      [ , , ,]

   Note that the result has `three holes (empty slots) <#array-holes>`__ â€“ the last
   comma in an Array literal is always ignored.



.. _creating-array-with-objects:

33.7.3â€ƒCreating an Array filled with objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If we use ``.fill()`` with an object, then each Array element will refer to this
   same single object:

   .. code:: javascript

      const arr = new Array(3).fill({});
      arr[0].prop = true;
      assert.deepEqual(
      arr, [
         {prop: true},
         {prop: true},
         {prop: true},
      ]);

   How can we fix this? We can use `Array.from() <#Array.from>`__:

   .. code:: javascript
      :name: language-node-repl

      > Array.from(new Array(3), () => ({}))
      [{}, {}, {}]

   Calling ``Array.from()`` with two arguments:

   -  extracts the elements of the first argument (which must be iterable or
      Array-like),
   -  maps them via the callback in the second argument and
   -  returns the result in an Array.

   In contrast to ``.fill()``, which reuses the same object multiple times, the
   previous code creates a new object for each element.

   Could we have used ``.map()`` in this case? Unfortunately not because ``.map()``
   ignores but preserves holes (whereas ``Array.from()`` treats them as
   ``undefined`` elements):

   .. code:: javascript
      :name: language-node-repl

      > new Array(3).map(() => ({}))
      [ , , ,]

   For large sizes, the temporary Array in the first argument can consume quite a
   bit of memory. The following approach doesnâ€™t have this downside but is less
   self-descriptive:

   .. code:: javascript
      :name: language-node-repl

      > Array.from({length: 3}, () => ({}))
      [{}, {}, {}]

   Instead of a temporary Array, we are using a temporary `Array-like
   object <#array-like-objects>`__.



.. _creating-array-with-range-of-integers:

33.7.4â€ƒCreating an Array with a range of integers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To create an Array with a range of integers, we use ``Array.from()`` similarly
   to how we did in the previous subsection:

   .. code:: javascript

      function createRange(start, end) {
      return Array.from({length: end-start}, (_, i) => i+start);
      }
      assert.deepEqual(
      createRange(2, 5),
      [2, 3, 4]);

   Here is an alternative, slightly hacky technique for creating integer ranges
   that start at zero:

   .. code:: javascript

      /** Returns an iterable */
      function createRange(end) {
      return new Array(end).keys();
      }
      assert.deepEqual(
      Array.from(createRange(4)),
      [0, 1, 2, 3]);

   This works because ``.keys()`` treats `holes <#array-holes>`__ like
   ``undefined`` elements and lists their indices.

33.7.5â€ƒTyped Arrays work well if the elements are all integers or all floats
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   When dealing with Arrays of integers or floats, we should consider `Typed
   Arrays <#ch_typed-arrays>`__, which were created for this
   purpose.

33.8â€ƒMultidimensional Arrays
-----------------------------

   JavaScript does not have real multidimensional Arrays; we need to resort to
   Arrays whose elements are Arrays:

   .. code:: javascript

      function initMultiArray(...dimensions) {
      function initMultiArrayRec(dimIndex) {
         if (dimIndex >= dimensions.length) {
            return 0;
         } else {
            const dim = dimensions[dimIndex];
            const arr = [];
            for (let i=0; i<dim; i++) {
            arr.push(initMultiArrayRec(dimIndex+1));
            }
            return arr;
         }
      }
      return initMultiArrayRec(0);
      }

      const arr = initMultiArray(4, 3, 2);
      arr[3][2][1] = 'X'; // last in each dimension
      assert.deepEqual(arr, [
      [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
      [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
      [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ],
      [ [ 0, 0 ], [ 0, 0 ], [ 0, 'X' ] ],
      ]);



.. _arrays-are-actually-dictionaries:

33.9â€ƒArrays are actually dictionaries (advanced)
-------------------------------------------------

   In this section, we examine how exactly Arrays store their elements: in
   properties. We usually donâ€™t need to know that but it helps with understanding a
   few rarer Array phenomena.



.. _array-indices:

33.9.1â€ƒArray indices are (slightly special) property keys
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Youâ€™d think that Array elements are special because we are accessing them via
   numbers. But the square brackets operator ``[]`` for doing so is the same
   operator that is used for accessing properties. It coerces any non-symbol value
   to a string. Therefore, Array elements are (almost) normal properties (line A)
   and it doesnâ€™t matter if we use numbers or strings as indices (lines B and C):

   .. code:: javascript

      const arr = ['a', 'b'];
      arr.prop = 123;
      assert.deepEqual(
      Object.keys(arr),
      ['0', '1', 'prop']); // (A)

      assert.equal(arr[0], 'a');  // (B)
      assert.equal(arr['0'], 'a'); // (C)

   To make matters even more confusing:

   -  This is only how the language specification defines things (the theory of
      JavaScript, if you will).
   -  Most JavaScript engines optimize under the hood and do use actual integers to
      access Array elements (the practice of JavaScript, if you will).

   Property keys (strings!) that are used for Array elements are called
   `indices <https://tc39.es/ecma262/#integer-index>`__. A string ``str`` is an
   index if converting it to a 32-bit unsigned integer and back results in the
   original value. Written as a formula:

   .. code:: language-txt

      ToString(ToUint32(str)) === str

33.9.1.1â€ƒListing indices
'''''''''''''''''''''''''

   When listing property keys, `indices are treated
   specially <#order-of-properties>`__ â€“ they always come first and
   are sorted like numbers (``'2'`` comes before ``'10'``):

   .. code:: javascript

      const arr = [];
      arr.prop = true;
      arr[1] = 'b';
      arr[0] = 'a';

      assert.deepEqual(
      Object.keys(arr),
      ['0', '1', 'prop']);

   Note that ``.length``, ``.entries()`` and ``.keys()`` treat Array indices as
   numbers and ignore non-index properties:

   .. code:: javascript

      assert.equal(arr.length, 2);
      assert.deepEqual(
      Array.from(arr.keys()), [0, 1]);
      assert.deepEqual(
      Array.from(arr.entries()), [[0, 'a'], [1, 'b']]);

   We used `Array.from() <#Array.from>`__ to convert the iterables returned by
   ``.keys()`` and ``.entries()`` to Arrays.



.. _array-holes:

33.9.2â€ƒArrays can have holes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We distinguish two kinds of Arrays in JavaScript:

   -  An Array ``arr`` is *dense* if all indices ``i``, with 0 â‰¤ ``i <
      ``arr.length``, exist. That is, the indices form a contiguous range.
   -  An Array is *sparse* if the range of indices has *holes* in it. That is, some
      indices are missing.

   Arrays can be sparse in JavaScript because Arrays are actually dictionaries from
   indices to values.

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Recommendation: avoid holes**

      .. container:: boxout-vspace

      So far, we have only seen dense Arrays and itâ€™s indeed recommended to avoid
      holes: They make our code more complicated and are not handled consistently
      by Array methods. Additionally, JavaScript engines optimize dense Arrays,
      making them faster.

33.9.2.1â€ƒCreating holes
''''''''''''''''''''''''

   We can create holes by skipping indices when assigning elements:

   .. code:: javascript

      const arr = [];
      arr[0] = 'a';
      arr[2] = 'c';

      assert.deepEqual(Object.keys(arr), ['0', '2']); // (A)

      assert.equal(0 in arr, true); // element
      assert.equal(1 in arr, false); // hole

   In line A, we are using ``Object.keys()`` because ``arr.keys()`` treats holes as
   if they were ``undefined`` elements and does not reveal them.

   Another way of creating holes is to skip elements in Array literals:

   .. code:: javascript

      const arr = ['a', , 'c'];

      assert.deepEqual(Object.keys(arr), ['0', '2']);

   We can also delete Array elements:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      assert.deepEqual(Object.keys(arr), ['0', '1', '2']);
      delete arr[1];
      assert.deepEqual(Object.keys(arr), ['0', '2']);

33.9.2.2â€ƒHow do Array operations treat holes?
''''''''''''''''''''''''''''''''''''''''''''''

   Alas, there are many different ways in which Array operations treat holes.

   Some Array operations remove holes:

   .. code:: javascript
      :name: language-node-repl

      > ['a',,'b'].filter(x => true)
      [ 'a', 'b' ]

   Some Array operations ignore holes:

   .. code:: javascript
      :name: language-node-repl

      > ['a', ,'a'].every(x => x === 'a')
      true

   Some Array operations ignore but preserve holes:

   .. code:: javascript
      :name: language-node-repl

      > ['a',,'b'].map(x => 'c')
      [ 'c', , 'c' ]

   Some Array operations treat holes as ``undefined`` elements:

   .. code:: javascript
      :name: language-node-repl

      > Array.from(['a',,'b'], x => x)
      [ 'a', undefined, 'b' ]
      > Array.from(['a',,'b'].entries())
      [[0, 'a'], [1, undefined], [2, 'b']]

   ``Object.keys()`` works differently than ``.keys()`` (strings vs. numbers, holes
   donâ€™t have keys):

   .. code:: javascript
      :name: language-node-repl

      > Array.from(['a',,'b'].keys())
      [ 0, 1, 2 ]
      > Object.keys(['a',,'b'])
      [ '0', '2' ]

   There is no rule to remember here. If it ever matters how an Array operation
   treats holes, the best approach is to do a quick test in a console.



.. _array-operations-destructive-vs-non-destructive:

33.10â€ƒDestructive vs. non-destructive Array operations
-------------------------------------------------------

   Some Array operations are *destructive*: They change the Array they operate on â€“
   e.g., setting an element:

   .. code:: javascript
      :name: language-node-repl

      > const arr = ['a', 'b', 'c'];
      > arr[1] = 'x';
      > arr // the original was modified
      [ 'a', 'x', 'c' ]

   Other Array operations are *non-destructive*: They produce new Arrays that
   contain the desired changes and donâ€™t touch the originals â€“ e.g., method
   ``.with()`` is the non-destructive version of setting elements:

   .. code:: javascript
      :name: language-node-repl

      > const arr = ['a', 'b', 'c'];
      > arr.with(1, 'x') // produces copy with changes
      [ 'a', 'x', 'c' ]
      > arr // the original is unchanged
      [ 'a', 'b', 'c' ]

33.10.1â€ƒHow to make destructive Array methods non-destructive
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   These are three common destructive Array methods:

   -  ``.reverse()``
   -  ``.sort()``
   -  ``.splice()``

   Weâ€™ll get to `.sort() <#Array.prototype.sort>`__ and
   `.splice() <#qref-Array.prototype.splice>`__ later in this chapter.
   ``.reverse()`` rearranges an Array so that the order of its elements is
   reversed: The element that was previously last now comes first; the second-last
   element comes second; etc.:

   .. code:: javascript

      const original = ['a', 'b', 'c'];
      const reversed = original.reverse();

      assert.deepEqual(reversed, ['c', 'b', 'a']);
      assert.ok(reversed === original); // .reverse() returned `this`
      assert.deepEqual(original, ['c', 'b', 'a']);

   To prevent a destructive method from changing an Array, we can make a copy
   before using it â€“ e.g.:

   .. code:: javascript

      const reversed1 = original.slice().reverse();
      const reversed2 = [...original].reverse();
      const reversed3 = Array.from(original).reverse();

   Another option is to use the non-destructive version of a destructive method.
   Thatâ€™s what weâ€™ll explore next.



.. _non-destructive-versions-of-reverse-sort-splice:

33.10.2â€ƒNon-destructive versions of ``.reverse()``, ``.sort()``, ``.splice()`` [ES2023]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   These are the non-destructive versions of the destructive Array methods
   ``.reverse()``, ``.sort()`` and ``.splice()``:

   -  ``.toReversed(): Array``
   -  ``.toSorted(compareFn): Array``
   -  ``.toSpliced(start, deleteCount, ...items): Array``

   We have used ``.reverse()`` in the previous subsection. Its non-destructive
   version is used like this:

   .. code:: javascript

      const original = ['a', 'b', 'c'];
      const reversed = original.toReversed();

      assert.deepEqual(reversed, ['c', 'b', 'a']);
      // The original is unchanged
      assert.deepEqual(original, ['a', 'b', 'c']);

33.11â€ƒAdding and removing elements at either end of an Array
-------------------------------------------------------------

33.11.1â€ƒDestructively adding and removing elements at either end of an Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScriptâ€™s ``Array`` is quite flexible and more like a combination of array,
   stack, and queue. Letâ€™s explore ways of destructively adding and removing Array
   elements.

   ``.push()`` adds elements at the end of an Array:

   .. code:: javascript

      const arr1 = ['a', 'b'];
      arr1.push('x', 'y'); // append single elements
      assert.deepEqual(arr1, ['a', 'b', 'x', 'y']);

      const arr2 = ['a', 'b'];
      arr2.push(...['x', 'y']); // (A) append Array
      assert.deepEqual(arr2, ['a', 'b', 'x', 'y']);

   `Spread arguments (``...``) <#spread-arguments>`__ are a
   feature of function calls. In line A, we used it to push an Array.

   ``.pop()`` is the inverse of ``.push()`` and removes elements at the end of an
   Array:

   .. code:: javascript

      const arr2 = ['a', 'b', 'c'];
      assert.equal(arr2.pop(), 'c');
      assert.deepEqual(arr2, ['a', 'b']);

   ``.unshift()`` adds element at the beginning of an Array:

   .. code:: javascript

      const arr1 = ['a', 'b'];
      arr1.unshift('x', 'y'); // prepend single elements
      assert.deepEqual(arr1, ['x', 'y', 'a', 'b']);

      const arr2 = ['a', 'b'];
      arr2.unshift(...['x', 'y']); // prepend Array
      assert.deepEqual(arr2, ['x', 'y', 'a', 'b']);

   ``.shift()`` is the inverse of ``.unshift()`` and removes elements at the
   beginning of an Array:

   .. code:: javascript

      const arr1 = ['a', 'b', 'c'];
      assert.equal(arr1.shift(), 'a');
      assert.deepEqual(arr1, ['b', 'c']);

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Tip: remembering the functionality of ``push``, ``pop``,
      ``shift`` and ``unshift``**

      .. container:: boxout-vspace

      My recommendation is to focus on remembering the following two methods:

      -  ``.push()`` is the most frequently used of the four methods. One common
         use case is to assemble an output Array: We first push the element at
         index 0; then the element at index 1; etc.
      -  ``.shift()`` can be used to consume the elements of an Array: The first
         time we shift, we get the element at index 0; then the element at index 1;
         etc.

      The remaining two methods, ``pop`` and ``unshift``, are inverses of these two
      methods.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Implementing a queue via an Array**

      .. container:: boxout-vspace

      ``exercises/arrays/queue_via_array_test.mjs``

33.11.2â€ƒNon-destructively prepending and appending elements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `Spread elements (``...``) <#spreading-into-array-literals>`__ are a feature of
   Array literals. In this section, weâ€™ll use it to non-destructively prepend and
   append elements to Arrays.

   Non-destructive prepending:

   .. code:: javascript

      const arr1 = ['a', 'b'];
      assert.deepEqual(
      ['x', 'y', ...arr1], // prepend single elements
      ['x', 'y', 'a', 'b']);
      assert.deepEqual(arr1, ['a', 'b']); // unchanged!

      const arr2 = ['a', 'b'];
      assert.deepEqual(
      [...['x', 'y'], ...arr2], // prepend Array
      ['x', 'y', 'a', 'b']);
      assert.deepEqual(arr2, ['a', 'b']); // unchanged!

   Non-destructive appending:

   .. code:: javascript

      const arr1 = ['a', 'b'];
      assert.deepEqual(
      [...arr1, 'x', 'y'], // append single elements
      ['a', 'b', 'x', 'y']);
      assert.deepEqual(arr1, ['a', 'b']); // unchanged!

      const arr2 = ['a', 'b'];
      assert.deepEqual(
      [...arr2, ...['x', 'y']], // append Array
      ['a', 'b', 'x', 'y']);
      assert.deepEqual(arr2, ['a', 'b']); // unchanged!



.. _array-element-callbacks:

33.12â€ƒArray methods that accept element callbacks
--------------------------------------------------

   The following Array methods accept callbacks to which they feed Array elements:

   -  Finding:

      -  ``.find``
      -  ``.findLast``
      -  ``.findIndex``
      -  ``.findLastIndex``

   -  Transforming:

      -  ``.map``
      -  ``.flatMap``
      -  ``.filter``

   -  Computing summaries of Arrays:

      -  ``.every``
      -  ``.some``
      -  ``.reduce``
      -  ``.reduceRight``

   -  Looping over Arrays:

      -  ``.forEach``

   Element callbacks have type signatures that look as follows:

   .. code:: javascript
      :name: language-ts

      callback: (value: T, index: number, array: Array<T>) => boolean

   That is, the callback gets three parameters (it is free to ignore any of them):

   -  ``value`` is the most important one. This parameter holds the Array element
      that is currently being processed.
   -  ``index`` can additionally tell the callback what the index of the element
      is.
   -  ``array`` points to the current Array (the receiver of the method call). Some
      algorithms need to refer to the whole Array â€“ e.g., to search elsewhere
      additional data. This parameter lets us write reusable callbacks for such
      algorithms.

   What the callback is expected to return depends on the method it is passed to.
   Possibilities include:

   -  ``.map()`` fills its result with the values returned by its callback:

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'c'].map(x => x + x)
         [ 'aa', 'bb', 'cc' ]

   -  ``.find()`` returns the first Array element for which its callback returns
      ``true``:

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'bb', 'ccc'].find(str => str.length >= 2)
         'bb'



.. _transforming-with-element-callbacks-map-filter-flatmap:

33.13â€ƒTransforming with element callbacks: ``.map()``, ``.filter()``, ``.flatMap()``
-------------------------------------------------------------------------------------

   In this section, we explore methods that accept `element
   callbacks <#array-element-callbacks>`__ which tell them how to transform an
   input Array into an output Array.

33.13.1â€ƒ``.map()``: Each output element is derived from its input element
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Each element of the output Array is the result of applying the callback to the
   corresponding input element:

   .. code:: javascript
      :name: language-node-repl

      > [1, 2, 3].map(x => x * 3)
      [ 3, 6, 9 ]
      > ['how', 'are', 'you'].map(str => str.toUpperCase())
      [ 'HOW', 'ARE', 'YOU' ]
      > [true, true, true].map((_x, index) => index)
      [ 0, 1, 2 ]

   ``.map()`` can be implemented as follows:

   .. code:: javascript

      function map(arr, mapFunc) {
      const result = [];
      for (const [i, x] of arr.entries()) {
         result.push(mapFunc(x, i, arr));
      }
      return result;
      }

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Numbering lines via ``.map()``**

      .. container:: boxout-vspace

      ``exercises/arrays/number_lines_test.mjs``

33.13.2â€ƒ``.filter()``: Only keep some of the elements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The Array method ``.filter()`` returns an Array collecting all elements for
   which the callback returns a truthy value.

   For example:

   .. code:: javascript
      :name: language-node-repl

      > [-1, 2, 5, -7, 6].filter(x => x >= 0)
      [ 2, 5, 6 ]
      > ['a', 'b', 'c', 'd'].filter((_x,i) => (i%2)===0)
      [ 'a', 'c' ]

   ``.filter()`` can be implemented as follows:

   .. code:: javascript

      function filter(arr, filterFunc) {
      const result = [];
      for (const [i, x] of arr.entries()) {
         if (filterFunc(x, i, arr)) {
            result.push(x);
         }
      }
      return result;
      }

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Removing empty lines via ``.filter()``**

      .. container:: boxout-vspace

      ``exercises/arrays/remove_empty_lines_filter_test.mjs``



.. _Array.prototype.flatMap:

33.13.3â€ƒ``.flatMap()``: Replace each input element with zero or more output elements [ES2019]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The type signature of ``Array<T>.prototype.flatMap()`` is:

   .. code:: javascript
      :name: language-ts

      .flatMap<U>(
      callback: (value: T, index: number, array: Array<T>) => U|Array<U>,
      thisValue?: any
      ): Array<U>

   Both ``.map()`` and ``.flatMap()`` take a function ``callback`` as a parameter
   that controls how an input Array is translated to an output Array:

   -  With ``.map()``, each input Array element is translated to exactly one output
      element. That is, ``callback`` returns a single value.
   -  With ``.flatMap()``, each input Array element is translated to zero or more
      output elements. That is, ``callback`` returns an Array of values (it can
      also return non-Array values, but that is rare).

   This is ``.flatMap()`` in action:

   .. code:: javascript
      :name: language-node-repl

      > ['a', 'b', 'c'].flatMap(x => [x,x])
      [ 'a', 'a', 'b', 'b', 'c', 'c' ]
      > ['a', 'b', 'c'].flatMap(x => [x])
      [ 'a', 'b', 'c' ]
      > ['a', 'b', 'c'].flatMap(x => [])
      []

   Weâ€™ll consider use cases next, before exploring how this method could be
   implemented.

33.13.3.1â€ƒUse case: filtering and mapping at the same time
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The result of the Array method ``.map()`` always has the same length as the
   Array it is invoked on. That is, its callback canâ€™t skip Array elements it isnâ€™t
   interested in. The ability of ``.flatMap()`` to do so is useful in the next
   example.

   We will use the following function ``processArray()`` to create an Array that
   weâ€™ll then filter and map via ``.flatMap()``:

   .. code:: javascript

      function processArray(arr, callback) {
      return arr.map(x => {
         try {
            return { value: callback(x) };
         } catch (e) {
            return { error: e };
         }
      });
      }

   Next, we create an Array ``results`` via ``processArray()``:

   .. code:: javascript

      const results = processArray([1, -5, 6], throwIfNegative);
      assert.deepEqual(results, [
      { value: 1 },
      { error: new Error('Illegal value: -5') },
      { value: 6 },
      ]);

      function throwIfNegative(value) {
      if (value < 0) {
         throw new Error('Illegal value: '+value);
      }
      return value;
      }

   We can now use ``.flatMap()`` to extract just the values or just the errors from
   ``results``:

   .. code:: javascript

      const values = results.flatMap(
      result => result.value ? [result.value] : []);
      assert.deepEqual(values, [1, 6]);
      
      const errors = results.flatMap(
      result => result.error ? [result.error] : []);
      assert.deepEqual(errors, [new Error('Illegal value: -5')]);

33.13.3.2â€ƒUse case: mapping single input values to multiple output values
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The Array method ``.map()`` maps each input Array element to one output element.
   But what if we want to map it to multiple output elements?

   That becomes necessary in the following example:

   .. code:: javascript
      :name: language-node-repl

      > stringsToCodePoints(['many', 'a', 'moon'])
      ['m', 'a', 'n', 'y', 'a', 'm', 'o', 'o', 'n']

   We want to convert an Array of strings to an Array of Unicode characters (code
   points). The following function achieves that via ``.flatMap()``:

   .. code:: javascript

      function stringsToCodePoints(strs) {
      return strs.flatMap(str => Array.from(str));
      }

33.13.3.3â€ƒA simple implementation
''''''''''''''''''''''''''''''''''

   We can implement ``.flatMap()`` as follows. Note: This implementation is simpler
   than the built-in version, which, for example, performs more checks.

   .. code:: javascript

      function flatMap(arr, mapFunc) {
      const result = [];
      for (const [index, elem] of arr.entries()) {
         const x = mapFunc(elem, index, arr);
         // We allow mapFunc() to return non-Arrays
         if (Array.isArray(x)) {
            result.push(...x);
         } else {
            result.push(x);
         }
      }
      return result;
      }

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercises: ``.flatMap()``**

      .. container:: boxout-vspace

      -  ``exercises/arrays/convert_to_numbers_test.mjs``
      -  ``exercises/arrays/replace_objects_test.mjs``



.. _Array.prototype.reduce:

33.14â€ƒ``.reduce()``: computing a summary for an Array
------------------------------------------------------

   Method ``.reduce()`` is a powerful tool for computing a â€œsummaryâ€ of an Array
   ``arr``. A summary can be any kind of value:

   -  A number. For example, the sum of all elements of ``arr``.
   -  An Array. For example, a copy of ``arr``, where each element is twice the
      original element.
   -  Etc.

   ``reduce`` is also known as ``foldl`` (â€œfold leftâ€) in functional programming
   and popular there. One caveat is that it can make code difficult to understand.

   ``.reduce()`` has the following type signature (inside an ``Array<T>``):

   .. code:: javascript
      :name: language-ts

      .reduce<U>(
      callback: (accumulator: U, element: T, index: number, array: Array<T>) => U,
      init?: U)
      : U

   ``T`` is the type of the Array elements, ``U`` is the type of the summary. The
   two may or may not be different. ``accumulator`` is just another name for
   â€œsummaryâ€.

   To compute the summary of an Array ``arr``, ``.reduce()`` feeds all Array
   elements to its callback one at a time:

   .. code:: javascript

      const accumulator_0 = callback(init, arr[0]);
      const accumulator_1 = callback(accumulator_0, arr[1]);
      const accumulator_2 = callback(accumulator_1, arr[2]);
      // Etc.

   ``callback`` combines the previously computed summary (stored in its parameter
   ``accumulator``) with the current Array element and returns the next
   ``accumulator``. The result of ``.reduce()`` is the final accumulator â€“ the last
   result of ``callback`` after it has visited all elements.

   In other words: ``callback`` does most of the work; ``.reduce()`` just invokes
   it in a useful manner.

   We could say that the callback folds Array elements into the accumulator. Thatâ€™s
   why this operation is called â€œfoldâ€ in functional programming.

Example: applying a binary operator to a whole Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Letâ€™s look at an example of ``.reduce()`` in action: function ``addAll()``
   computes the sum of all numbers in an Array ``arr``.

   .. code:: javascript

      function addAll(arr) {
      const startSum = 0;
      const callback = (sum, element) => sum + element;
      return arr.reduce(callback, startSum);
      }
      assert.equal(addAll([1,  2, 3]), 6); // (A)
      assert.equal(addAll([7, -4, 2]), 5);

   In this case, the accumulator holds the sum of all Array elements that
   ``callback`` has already visited.

   How was the result ``6`` derived from the Array in line A? Via the following
   invocations of ``callback``:

   .. code:: language-txt

      callback(0, 1) --> 1
      callback(1, 2) --> 3
      callback(3, 3) --> 6

   Notes:

   -  The first parameters are the current accumulators (starting with parameter
      ``init`` of ``.reduce()``).
   -  The second parameters are the current Array elements.
   -  The results are the next accumulators.
   -  The last result of ``callback`` is also the result of ``.reduce()``.

   Alternatively, we could have implemented ``addAll()`` via a ``for-of`` loop:

   .. code:: javascript

      function addAll(arr) {
      let sum = 0;
      for (const element of arr) {
         sum = sum + element;
      }
      return sum;
      }

   Itâ€™s hard to say which of the two implementations is â€œbetterâ€: the one based on
   ``.reduce()`` is a little more concise, while the one based on ``for-of`` may be
   a little easier to understand â€“ especially if someone is not familiar with
   functional programming.



.. _example-finding-indices-via-reduce:

Example: finding indices via ``.reduce()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following function is an implementation of the Array method ``.indexOf()``.
   It returns the first index at which the given ``searchValue`` appears inside the
   Array ``arr``:

   .. code:: javascript

      const NOT_FOUND = -1;
      function indexOf(arr, searchValue) {
      return arr.reduce(
         (result, elem, index) => {
            if (result !== NOT_FOUND) {
            // We have already found something: donâ€™t change anything
            return result;
            } else if (elem === searchValue) {
            return index;
            } else {
            return NOT_FOUND;
            }
         },
         NOT_FOUND);
      }
      assert.equal(indexOf(['a', 'b', 'c'], 'b'), 1);
      assert.equal(indexOf(['a', 'b', 'c'], 'x'), -1);

   One limitation of ``.reduce()`` is that we canâ€™t finish early. In a ``for-of``
   loop, we can immediately return the result once we have found it.

Example: doubling Array elements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Function ``double(arr)`` returns a copy of ``inArr`` whose elements are all
   multiplied by 2:

   .. code:: javascript

      function double(inArr) {
      return inArr.reduce(
         (outArr, element) => {
            outArr.push(element * 2);
            return outArr;
         },
         []);
      }
      assert.deepEqual(
      double([1, 2, 3]),
      [2, 4, 6]);

   We modify the initial value ``[]`` by pushing into it. A non-destructive, more
   functional version of ``double()`` looks as follows:

   .. code:: javascript

      function double(inArr) {
      return inArr.reduce(
         // Donâ€™t change `outArr`, return a fresh Array
         (outArr, element) => [...outArr, element * 2],
         []);
      }
      assert.deepEqual(
      double([1, 2, 3]),
      [2, 4, 6]);

   This version is more elegant but also slower and uses more memory.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercises: ``.reduce()``**

      .. container:: boxout-vspace

      -  ``map()`` via ``.reduce()``: ``exercises/arrays/map_via_reduce_test.mjs``
      -  ``filter()`` via ``.reduce()``:
         ``exercises/arrays/filter_via_reduce_test.mjs``
      -  ``countMatches()`` via ``.reduce()``:
         ``exercises/arrays/count_matches_via_reduce_test.mjs``



.. _Array.prototype.reduceRight:

33.14.1â€ƒ``.reduceRight()``: the end-to-start version of ``.reduce()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.reduce()`` visits elements from start to end:

   .. code:: javascript
      :name: language-node-repl

      > ['a', 'b', 'c'].reduce((acc, x) => acc + x)
      'abc'

   ``.reduceRight()`` has the same functionality but visits elements from end to
   start:

   .. code:: javascript
      :name: language-node-repl

      > ['a', 'b', 'c'].reduceRight((acc, x) => acc + x)
      'cba'



.. _Array.prototype.sort:

33.15â€ƒ``.sort()``: sorting Arrays
----------------------------------

   ``.sort()`` has the following type definition:

   .. code:: javascript
      :name: language-ts

      sort(compareFunc?: (a: T, b: T) => number): this

   By default, ``.sort()`` sorts string representations of the elements. These
   representations are compared via ``<``. This operator compares code unit values
   (char codes) *lexicographically* (the first characters are most significant).

   ``.sort()`` sorts *in place*; it changes and returns its receiver:

   .. code:: javascript
      :name: language-node-repl

      > const arr = ['a', 'c', 'b'];
      > arr.sort() === arr
      true
      > arr
      [ 'a', 'b', 'c' ]

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**``.sort()`` is stable**

      .. container:: boxout-vspace

      Since ECMAScript 2019, sorting is guaranteed to be *stable*: If elements are
      considered equal by sorting, then sorting does not change the order of those
      elements (relative to each other).



.. _customizing-array-sorting:

33.15.1â€ƒCustomizing the sort order
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We can customize the sort order via the parameter ``compareFunc``, which must
   return a number that is:

   -  negative if ``a`` is less than ``b``
   -  zero if ``a`` is equal to ``b``
   -  positive if ``a`` is greater than ``b``

   Weâ€™ll see an example of a compare function in the next subsection.

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Tip for remembering these rules**

      .. container:: boxout-vspace

      A negative number is *less than* zero (etc.).

33.15.2â€ƒSorting numbers
~~~~~~~~~~~~~~~~~~~~~~~~

   Lexicographical sorting doesnâ€™t work well for numbers:

   .. code:: javascript
      :name: language-node-repl

      > [200, 3, 10].sort()
      [ 10, 200, 3 ]

   We can fix this by writing a compare function:

   .. code:: javascript

      function compareNumbers(a, b) {
      if (a < b) {
         return -1; // any negative number will do
      } else if (a === b) {
         return 0;
      } else {
         return 1; // any positive number will do
      }
      }
      assert.deepEqual(
      [200, 3, 10].sort(compareNumbers),
      [3, 10, 200]
      );

   .. container:: boxout

      |Icon â€œquestionâ€|â€‚**Why doesnâ€™t ``.sort()`` automatically pick the right
      sorting approach for numbers?**

      .. container:: boxout-vspace

      It would have to examine all Array elements and make sure that they are
      numbers before switching from lexicographical sorting to numeric sorting.

33.15.3â€ƒA trick for sorting numbers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following trick uses the fact that (e.g.) the result for â€œless thanâ€ can be
   any negative number:

   .. code:: javascript
      :name: language-node-repl

      > [200, 3, 10].sort((a, z) => a - z)
      [ 3, 10, 200 ]

   -  This time, we call the parameters ``a`` and ``z`` because that enables a
      mnemonic: The callback sorts ascendingly, â€œfrom ``a`` to ``z``\ â€
      (``a - z``).
   -  A downside of this trick is that we might get an arithmetic overflow if a
      large positive and a large negative number are compared.

33.15.4â€ƒSorting human-language strings
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   When sorting human-language strings, we need to be aware that they are compared
   according to their code unit values (char codes):

   .. code:: javascript
      :name: language-node-repl

      > ['pie', 'cookie', 'Ã©clair', 'Pie', 'Cookie', 'Ã‰clair'].sort()
      [ 'Cookie', 'Pie', 'cookie', 'pie', 'Ã‰clair', 'Ã©clair' ]

   All unaccented uppercase letters come before all unaccented lowercase letters,
   which come before all accented letters. We can use ``Intl``, `the JavaScript
   internationalization
   API <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl>`__
   if we want proper sorting for human languages:

   .. code:: javascript

      const arr = ['pie', 'cookie', 'Ã©clair', 'Pie', 'Cookie', 'Ã‰clair'];
      assert.deepEqual(
      arr.sort(new Intl.Collator('en').compare),
      ['cookie', 'Cookie', 'Ã©clair', 'Ã‰clair', 'pie', 'Pie']
      );

33.15.5â€ƒSorting objects
~~~~~~~~~~~~~~~~~~~~~~~~

   We also need to use a compare function if we want to sort objects. As an
   example, the following code shows how to sort objects by age.

   .. code:: javascript

      const arr = [ {age: 200}, {age: 3}, {age: 10} ];
      assert.deepEqual(
      arr.sort((obj1, obj2) => obj1.age - obj2.age),
      [{ age: 3 }, { age: 10 }, { age: 200 }]
      );

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Sorting objects by name**

      .. container:: boxout-vspace

      ``exercises/arrays/sort_objects_test.mjs``

33.16â€ƒArrays can use operations for iterables
----------------------------------------------

   Arrays are iterable and therefore can use operations that accept iterables.
   These are described elsewhere:

   -  `â€œGrouping iterablesâ€
      (Â§32.5) <#grouping-sync-iterables>`__



.. _quickref-Array:

33.17â€ƒQuick reference: ``Array``
---------------------------------

   Legend:

   -  ``R``: method does not change the Array (non-destructive).
   -  ``W``: method changes the Array (destructive).

   **Negative indices:** If a method supports negative indices that means that such
   indices are added to ``.length`` before they are used: ``-1`` becomes
   ``this.length-1``, etc. In other words: ``-1`` refers to the last element,
   ``-2`` to the second-last element, etc. ``.at()`` is one method that supports
   negative indices:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      assert.equal(
      arr.at(-1), 'c'
      );

33.17.1â€ƒ``new Array()``
~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``new Array(len = 0)`` :sup:`[ES1]`

      Creates an Array of length ``len`` that only contains holes:

      .. code:: javascript

         // Trailing commas are always ignored.
         // Therefore: number of commas = number of holes
         assert.deepEqual(new Array(3), [,,,]);



.. _array:

33.17.2â€ƒ``Array.*``
~~~~~~~~~~~~~~~~~~~~

   -  ``Array.from(iterableOrArrayLike, mapFunc?)`` :sup:`[ES6]`

      .. code:: javascript
         :name: language-ts

         Array.from<T>(
         iterableOrArrayLike: Iterable<T> | ArrayLike<T>
         ): Array<T>
         Array.from<T, U>(
         iterableOrArrayLike: Iterable<T> | ArrayLike<T>,
         mapFunc: (v: T, k: number) => U, thisArg?: any
         ): Array<U>

      -  Converts an iterable or `an Array-like object <#array-like-objects>`__ to
         an Array.
      -  Optionally, the input values can be translated via ``mapFunc`` before they
         are added to the output Array.

      Examples:

      .. code:: javascript
         :name: language-node-repl

         > Array.from(new Set(['a', 'b'])) // iterable
         [ 'a', 'b' ]
         > Array.from({length: 2, 0:'a', 1:'b'}) // Array-like object
         [ 'a', 'b' ]

   -  ``Array.of(...items)`` :sup:`[ES6]`

      .. code:: javascript
         :name: language-ts

         Array.of<T>(
         ...items: Array<T>
         ): Array<T>

      This static method is mainly useful for subclasses of ``Array``, where it
      serves as a custom Array literal:

      .. code:: javascript

         class MyArray extends Array {}

         assert.equal(
         MyArray.of('a', 'b') instanceof MyArray, true
         );



.. _array-prototype-getting-setting-and-visiting-single-elements:

33.17.3â€ƒ``Array.prototype.*``: getting, setting and visiting single elements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Array.prototype.at(index)`` :sup:`[R, ES2022]`

      -  Returns the Array element at ``index``. If there is no such element, it
         returns ``undefined``.

      This method is mostly equivalent to getting elements via square brackets:

      .. code:: javascript

         arr[index] === arr.at(index)

      One reason for using ``.at()`` is that it supports `negative
      indices <#negative-array-indices>`__:

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'c'].at(0)
         'a'
         > ['a', 'b', 'c'].at(-1)
         'c'

   -  ``Array.prototype.with(index, value)`` :sup:`[R, ES2023]`

      -  Returns the receiver of the method call, with one different element: At
         ``index``, there is now ``value``.

      This method is the non-destructive version of setting elements via square
      brackets. It supports negative indices:

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'c'].with(2, 'x')
         [ 'a', 'b', 'x' ]
         > ['a', 'b', 'c'].with(-1, 'x')
         [ 'a', 'b', 'x' ]

   -  ``Array.prototype.forEach(callback)`` :sup:`[R, ES5]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.forEach(
         callback: (value: T, index: number, array: Array<T>) => void,
         thisArg?: any
         ): void

      Calls ``callback`` for each element.

      .. code:: javascript

         ['a', 'b'].forEach((x, i) => console.log(x, i))

      Output:

      ::

         a 0
         b 1

      A ``for-of`` loop is usually a better choice: itâ€™s faster, supports ``break``
      and can iterate over arbitrary iterables.



.. _array-prototype-keys-and-values:

33.17.4â€ƒ``Array.prototype.*``: keys and values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Array.prototype.keys()`` :sup:`[R, ES6]`

      Returns an iterable over the keys of the receiver.

      .. code:: javascript
         :name: language-node-repl

         > Array.from(['a', 'b'].keys())
         [ 0, 1 ]

   -  ``Array.prototype.values()`` :sup:`[R, ES6]`

      Returns an iterable over the values of the receiver.

      .. code:: javascript
         :name: language-node-repl

         > Array.from(['a', 'b'].values())
         [ 'a', 'b' ]

   -  ``Array.prototype.entries()`` :sup:`[R, ES6]`

      Returns an iterable over [index, element] pairs.

      .. code:: javascript
         :name: language-node-repl

         > Array.from(['a', 'b'].entries())
         [ [ 0, 'a' ], [ 1, 'b' ] ]



.. _array-prototype-destructively-adding-or-removing-elements-at-either-end-of-an-array:

33.17.5â€ƒ``Array.prototype.*``: destructively adding or removing elements at either end of an Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Array.prototype.pop()`` :sup:`[W, ES3]`

      Removes and returns the last element of the receiver. That is, it treats the
      end of the receiver as a stack. The opposite of ``.push()``.

      .. code:: javascript
         :name: language-node-repl

         > const arr = ['a', 'b', 'c'];
         > arr.pop()
         'c'
         > arr
         [ 'a', 'b' ]

   -  ``Array.prototype.push(...items)`` :sup:`[W, ES3]`

      Adds zero or more ``items`` to the end of the receiver. That is, it treats
      the end of the receiver as a stack. The return value is the length of the
      receiver after the change. The opposite of ``.pop()``.

      .. code:: javascript
         :name: language-node-repl

         > const arr = ['a', 'b'];
         > arr.push('c', 'd')
         4
         > arr
         [ 'a', 'b', 'c', 'd' ]

      We can push an Array by spreading (``...``) it into arguments:

      .. code:: javascript
         :name: language-node-repl

         > const arr = ['x'];
         > arr.push(...['y', 'z'])
         3
         > arr
         [ 'x', 'y', 'z' ]  

   -  ``Array.prototype.shift()`` :sup:`[W, ES3]`

      Removes and returns the first element of the receiver. The inverse of
      ``.unshift()``.

      .. code:: javascript
         :name: language-node-repl

         > const arr = ['a', 'b', 'c'];
         > arr.shift()
         'a'
         > arr
         [ 'b', 'c' ]

   -  ``Array.prototype.unshift(...items)`` :sup:`[W, ES3]`

      Inserts the ``items`` at the beginning of the receiver and returns its length
      after this modification.

      .. code:: javascript
         :name: language-node-repl

         > const arr = ['c', 'd'];
         > arr.unshift('e', 'f')
         4
         > arr
         [ 'e', 'f', 'c', 'd' ]

      We can push an Array by spreading (``...``) it into arguments:

      .. code:: javascript
         :name: language-node-repl

         > const arr = ['c'];
         > arr.unshift(...['a', 'b'])
         3
         > arr
         [ 'a', 'b', 'c' ]



.. _array-prototype-combining-extracting-and-changing-sequences-of-elements:

33.17.6â€ƒ``Array.prototype.*``: combining, extracting and changing sequences of elements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Tip: telling ``.slice()`` and ``.splice()`` apart**

      .. container:: boxout-vspace

      -  ``.slice()`` is much more commonly used. The verb â€œsliceâ€ is also much
         more common than the verb â€œspliceâ€.
      -  Using ``.splice()`` is rare: Elements are more commonly
         (non-destructively) removed via ``.filter()``. â€œSpliceâ€ has one letter
         more than â€œsliceâ€ and the method also does more.

   -  ``Array.prototype.concat(...items)`` :sup:`[R, ES3]`

      Returns a new Array that is the concatenation of the receiver and all
      ``items``. Non-Array parameters (such as ``'b'`` in the following example)
      are treated as if they were Arrays with single elements.

      .. code:: javascript
         :name: language-node-repl

         > ['a'].concat('b', ['c', 'd'])
         [ 'a', 'b', 'c', 'd' ]

   -  ``Array.prototype.slice(start?, end?)`` :sup:`[R, ES3]`

      Returns a new Array containing the elements of the receiver whose indices are
      between (including) ``start`` and (excluding) ``end``.

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'c', 'd'].slice(1, 3)
         [ 'b', 'c' ]
         > ['a', 'b'].slice() // shallow copy
         [ 'a', 'b' ]

      ``.slice()`` supports `negative indices <#negative-array-indices>`__:

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'c'].slice(-2)
         [ 'b', 'c' ]

      It can be used to (shallowly) copy Arrays:

      .. code:: javascript

         const copy = original.slice();

   -  ``Array.prototype.splice(start?, deleteCount?, ...items)`` :sup:`[W, ES3]`

      -  At index ``start``,
      -  removes ``deleteCount`` elements (default: all remaining elements) and
      -  replaces them with ``items``.
      -  It returns the deleted elements.
      -  The non-destructive version of this method is
         `.toSpliced() <#qref-Array.prototype.toSpliced>`__.

      .. code:: javascript
         :name: language-node-repl

         > const arr = ['a', 'b', 'c', 'd'];
         > arr.splice(1, 2, 'x', 'y')
         [ 'b', 'c' ]
         > arr
         [ 'a', 'x', 'y', 'd' ]

      If ``deleteCount`` is missing, ``.splice()`` deletes until the end of the
      Array:

      .. code:: javascript
         :name: language-node-repl

         > const arr = ['a', 'b', 'c', 'd'];
         > arr.splice(2)
         [ 'c', 'd' ]
         > arr
         [ 'a', 'b' ]

      ``start`` can be `negative <#negative-array-indices>`__:

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'c'].splice(-2)
         [ 'b', 'c' ]

   -  ``Array.prototype.toSpliced(start?, deleteCount?, ...items)`` :sup:`[R,
      ES2023]`

      -  Creates a new Array where, starting at index ``start``, ``deleteCount``
         elements are replaced with ``items``.
      -  If ``deleteCount`` is missing, all elements from ``start`` until the end
         are deleted.
      -  The destructive version of this method is
         `.splice() <#qref-Array.prototype.splice>`__.

      .. code:: javascript
         :name: language-node-repl

         > const arr = ['a', 'b', 'c', 'd'];
         > arr.toSpliced(1, 2, 'x', 'y')
         [ 'a', 'x', 'y', 'd' ]

      ``start`` can be `negative <#negative-array-indices>`__:

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'c'].toSpliced(-2)
         [ 'a' ]

   -  ``Array.prototype.fill(start=0, end=this.length)`` :sup:`[W, ES6]`

      -  Returns ``this``.
      -  Assigns ``value`` to every index between (including) ``start`` and
         (excluding) ``end``.

      .. code:: javascript
         :name: language-node-repl

         > [0, 1, 2].fill('a')
         [ 'a', 'a', 'a' ]

      Caveat: Donâ€™t use this method to fill an Array with an object ``obj``; then
      each element will refer to the same value (sharing it). In this case, itâ€™s
      better to `use ``Array.from() <#filling-arrays>`__.

   -  ``Array.prototype.copyWithin(target, start, end=this.length)`` :sup:`[W,
      ES6]`

      -  Returns ``this``.

      Copies the elements whose indices range from (including) ``start`` to
      (excluding) ``end`` to indices starting with ``target``. Overlapping is
      handled correctly.

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'c', 'd'].copyWithin(0, 2, 4)
         [ 'c', 'd', 'c', 'd' ]

      ``start`` or ``end`` can be `negative <#negative-array-indices>`__.



.. _array-prototype-searching-for-elements:

33.17.7â€ƒ``Array.prototype.*``: searching for elements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Array.prototype.includes(searchElement, fromIndex)`` :sup:`[R, ES2016]`

      Returns ``true`` if the receiver has an element whose value is
      ``searchElement`` and ``false``, otherwise. Searching starts at index
      ``fromIndex``.

      .. code:: javascript
         :name: language-node-repl

         > [0, 1, 2].includes(1)
         true
         > [0, 1, 2].includes(5)
         false

   -  ``Array.prototype.indexOf(searchElement, fromIndex)`` :sup:`[R, ES5]`

      Returns the index of the first element that is strictly equal to
      ``searchElement``. Returns ``-1`` if there is no such element. Starts
      searching at index ``fromIndex``, visiting higher indices next.

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'a'].indexOf('a')
         0
         > ['a', 'b', 'a'].indexOf('a', 1)
         2
         > ['a', 'b', 'a'].indexOf('c')
         -1

   -  ``Array.prototype.lastIndexOf(searchElement, fromIndex)`` :sup:`[R, ES5]`

      Returns the index of the last element that is strictly equal to
      ``searchElement``. Returns ``-1`` if there is no such element. Starts
      searching at index ``fromIndex``, visiting lower indices next.

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'a'].lastIndexOf('a')
         2
         > ['a', 'b', 'a'].lastIndexOf('a', 1)
         0
         > ['a', 'b', 'a'].lastIndexOf('c')
         -1

   -  ``Array.prototype.find(predicate, thisArg?)`` :sup:`[R, ES6]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.find(
         predicate: (value: T, index: number, obj: Array<T>) => boolean,
         thisArg?: any
         ): T | undefined

      -  Traverses an Array from start to end.
      -  Returns the value of the first element for which ``predicate`` returns a
         truthy value.
      -  If there is no such element, it returns ``undefined``.

      .. code:: javascript
         :name: language-node-repl

         > [-1, 2, -3].find(x => x < 0)
         -1
         > [1, 2, 3].find(x => x < 0)
         undefined

   -  ``Array.prototype.findLast(predicate, thisArg?)`` :sup:`[R, ES2023]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.findLast(
         predicate: (value: T, index: number, obj: Array<T>) => boolean,
         thisArg?: any
         ): T | undefined

      -  Traverses an Array from end to start.
      -  Returns the value of the first element for which ``predicate`` returns a
         truthy value.
      -  If there is no such element, it returns ``undefined``.

      .. code:: javascript
         :name: language-node-repl

         > [-1, 2, -3].findLast(x => x < 0)
         -3
         > [1, 2, 3].findLast(x => x < 0)
         undefined

   -  ``Array.prototype.findIndex(predicate, thisArg?)`` :sup:`[R, ES6]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.findIndex(
         predicate: (value: T, index: number, obj: Array<T>) => boolean,
         thisArg?: any
         ): number

      -  Traverses an Array from start to end.
      -  Returns the index of the first element for which ``predicate`` returns a
         truthy value.
      -  If there is no such element, it returns ``-1``.

      .. code:: javascript
         :name: language-node-repl

         > [-1, 2, -3].findIndex(x => x < 0)
         0
         > [1, 2, 3].findIndex(x => x < 0)
         -1

   -  ``Array.prototype.findLastIndex(predicate, thisArg?)`` :sup:`[R, ES2023]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.findLastIndex(
         predicate: (value: T, index: number, obj: Array<T>) => boolean,
         thisArg?: any
         ): number

      -  Traverses an Array from end to start.
      -  Returns the index of the first element for which ``predicate`` returns a
         truthy value.
      -  If there is no such element, it returns ``-1``.

      .. code:: javascript
         :name: language-node-repl

         > [-1, 2, -3].findLastIndex(x => x < 0)
         2
         > [1, 2, 3].findLastIndex(x => x < 0)
         -1



.. _array-prototype-filtering-and-mapping:

33.17.8â€ƒ``Array.prototype.*``: filtering and mapping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Array.prototype.filter(predicate, thisArg?)`` :sup:`[R, ES5]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.filter(
         predicate: (value: T, index: number, array: Array<T>) => boolean,
         thisArg?: any
         ): Array<T>

      Returns an Array with only those elements for which ``predicate`` returns a
      truthy value.

      .. code:: javascript
         :name: language-node-repl

         > [1, -2, 3].filter(x => x > 0)
         [ 1, 3 ]

   -  ``Array.prototype.map(callback, thisArg?)`` :sup:`[R, ES5]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.map<U>(
         mapFunc: (value: T, index: number, array: Array<T>) => U,
         thisArg?: any
         ): Array<U>

      Returns a new Array, in which every element is the result of ``mapFunc``
      being applied to the corresponding element of the receiver.

      .. code:: javascript
         :name: language-node-repl

         > [1, 2, 3].map(x => x * 2)
         [ 2, 4, 6 ]
         > ['a', 'b', 'c'].map((x, i) => i)
         [ 0, 1, 2 ]

   -  ``Array.prototype.flatMap(callback, thisArg?)`` :sup:`[R, ES2019]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.flatMap<U>(
         callback: (value: T, index: number, array: Array<T>) => U|Array<U>,
         thisValue?: any
         ): Array<U>

      The result is produced by invoking ``callback()`` for each element of the
      original Array and concatenating the Arrays it returns.

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'c'].flatMap(x => [x,x])
         [ 'a', 'a', 'b', 'b', 'c', 'c' ]
         > ['a', 'b', 'c'].flatMap(x => [x])
         [ 'a', 'b', 'c' ]
         > ['a', 'b', 'c'].flatMap(x => [])
         []

   -  ``Array.prototype.flat(depth = 1)`` :sup:`[R, ES2019]`

      â€œFlattensâ€ an Array: It descends into the Arrays that are nested inside the
      input Array and creates a copy where all values it finds at level ``depth``
      or lower are moved to the top level.

      .. code:: javascript
         :name: language-node-repl

         > [ 1,2, [3,4], [[5,6]] ].flat(0) // no change
         [ 1, 2, [3,4], [[5,6]] ]

         > [ 1,2, [3,4], [[5,6]] ].flat(1)
         [1, 2, 3, 4, [5,6]]

         > [ 1,2, [3,4], [[5,6]] ].flat(2)
         [1, 2, 3, 4, 5, 6]



.. _array-prototype-computing-summaries:

33.17.9â€ƒ``Array.prototype.*``: computing summaries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Array.prototype.every(predicate, thisArg?)`` :sup:`[R, ES5]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.every(
         predicate: (value: T, index: number, array: Array<T>) => boolean,
         thisArg?: any
         ): boolean

      Returns ``true`` if ``predicate`` returns a truthy value for every element.
      Otherwise, it returns ``false``:

      .. code:: javascript
         :name: language-node-repl

         > [1, 2, 3].every(x => x > 0)
         true
         > [1, -2, 3].every(x => x > 0)
         false

      -  Stops traversing an Array if the predicate returns a falsy value (because
         then the result is guaranteed to be ``false``).
      -  Corresponds to universal quantification (â€œfor allâ€, âˆ€) in mathematics.
      -  Related method: `.some() <#qref-Array.prototype.some>`__ (â€œexistsâ€).

   -  ``Array.prototype.some(predicate, thisArg?)`` :sup:`[R, ES5]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.some(
         predicate: (value: T, index: number, array: Array<T>) => boolean,
         thisArg?: any
         ): boolean

      Returns ``true`` if ``predicate`` returns a truthy value for at least one
      element. Otherwise, it returns ``false``.

      .. code:: javascript
         :name: language-node-repl

         > [1, 2, 3].some(x => x < 0)
         false
         > [1, -2, 3].some(x => x < 0)
         true

      -  Stops traversing an Array if the predicate returns a truthy value (because
         then the result is guaranteed to be ``true``).
      -  Corresponds to existential quantification (â€œexistsâ€, âˆƒ) in mathematics.
      -  Related method: `.every() <#qref-Array.prototype.every>`__ (â€œfor
         allâ€).

   -  ``Array.prototype.reduce(callback, initialValue?)`` :sup:`[R, ES5]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.reduce<U>(
         callback: (accumulator: U, element: T, index: number, array: Array<T>) => U,
         initialValue?: U
         ): U

      This method produces a summary of the receiver: it feeds all Array elements
      to ``callback``, which combines a current summary (in parameter
      ``accumulator``) with the current Array element and returns the next
      ``accumulator``:

      .. code:: javascript

         const accumulator_0 = callback(initialValue, arr[0]);
         const accumulator_1 = callback(accumulator_0, arr[1]);
         const accumulator_2 = callback(accumulator_1, arr[2]);
         // Etc.

      The result of ``.reduce()`` is the last result of ``callback`` after it has
      visited all Array elements.

      .. code:: javascript
         :name: language-node-repl

         > [1, 2, 3].reduce((accu, x) => accu + x, 0)
         6
         > [1, 2, 3].reduce((accu, x) => accu + String(x), '')
         '123'

      If no ``initialValue`` is provided, the Array element at index 0 is used and
      the element at index 1 is visited first. Therefore, the Array must have at
      least length 1.

   -  ``Array.prototype.reduceRight(callback, initialValue?)`` :sup:`[R, ES5]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.reduceRight<U>(
         callback: (accumulator: U, element: T, index: number, array: Array<T>) => U,
         initialValue?: U
         ): U

      Works like ``.reduce()``, but visits the Array elements backward, starting
      with the last element.

      .. code:: javascript
         :name: language-node-repl

         > [1, 2, 3].reduceRight((accu, x) => accu + String(x), '')
         '321'



.. _array-prototype-converting-to-string:

33.17.10â€ƒ``Array.prototype.*``: converting to string
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Array.prototype.join(separator = ',')`` :sup:`[R, ES1]`

      Creates a string by concatenating string representations of all elements,
      separating them with ``separator``.

      .. code:: javascript
         :name: language-node-repl

         > ['a', 'b', 'c'].join('##')
         'a##b##c'
         > ['a', 'b', 'c'].join()
         'a,b,c'

   -  ``Array.prototype.toString()`` :sup:`[R, ES1]`

      Converts all elements to strings via ``String()``, concatenates them while
      separating them with commas, and returns the result.

      .. code:: javascript
         :name: language-node-repl

         > [1, 2, 3].toString()
         '1,2,3'
         > ['1', '2', '3'].toString()
         '1,2,3'
         > [].toString()
         ''

   -  ``Array.prototype.toLocaleString()`` :sup:`[R, ES3]`

      Works like `.toString() <#qref-Array.prototype.toString>`__ but converts
      its elements to strings via ``.toLocaleString()`` (not via ``.toString()``)
      before separating them via commas and concatenating them to a single string â€“
      that it returns.



.. _array-prototype-sorting-and-reversing:

33.17.11â€ƒ``Array.prototype.*``: sorting and reversing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Array.prototype.sort(compareFunc?)`` :sup:`[W, ES1]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.sort(
         compareFunc?: (a: T, b: T) => number
         ): this

      -  Sorts the receiver and returns it.
      -  The non-destructive version of this method is
         `.toSorted() <#qref-Array.prototype.toSorted>`__.
      -  Sorts string representations of the elements lexicographically.

      Sorting numbers:

      .. code:: javascript

         // Default: lexicographical sorting
         assert.deepEqual(
         [200, 3, 10].sort(),
         [10, 200, 3]
         );

         // Ascending numerical sorting (â€œfrom a to zâ€)
         assert.deepEqual(
         [200, 3, 10].sort((a, z) => a - z),
         [3, 10, 200]
         );

      Sorting strings: By default, strings are sorted by code unit values (char
      codes), where, e.g., all unaccented uppercase letters come before all
      unaccented lowercase letters:

      .. code:: javascript
         :name: language-node-repl

         > ['pie', 'cookie', 'Ã©clair', 'Pie', 'Cookie', 'Ã‰clair'].sort()
         [ 'Cookie', 'Pie', 'cookie', 'pie', 'Ã‰clair', 'Ã©clair' ]

      For human languages, we can use
      `Intl.Collator <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Collator>`__:

      .. code:: javascript

         const arr = ['pie', 'cookie', 'Ã©clair', 'Pie', 'Cookie', 'Ã‰clair'];
         assert.deepEqual(
         arr.sort(new Intl.Collator('en').compare),
         ['cookie', 'Cookie', 'Ã©clair', 'Ã‰clair', 'pie', 'Pie']
         );

   -  ``Array.prototype.toSorted(compareFunc?)`` :sup:`[R, ES2023]`

      .. code:: javascript
         :name: language-ts

         Array<T>.prototype.toSorted.toSorted(
         compareFunc?: (a: T, b: T) => number
         ): Array<T>

      -  Returns a sorted copy of the current Array.
      -  The destructive version of this method is
         `.sort() <#qref-Array.prototype.sort>`__.

      .. code:: javascript

         const original = ['y', 'z', 'x'];
         const sorted = original.toSorted();
         assert.deepEqual(
         // The original is unchanged
         original, ['y', 'z', 'x']
         );
         assert.deepEqual(
         // The copy is sorted
         sorted, ['x', 'y', 'z']
         );

      See the description of `.sort() <#qref-Array.prototype.sort>`__ for more
      information on how to use this method.

   -  ``Array.prototype.reverse()`` :sup:`[W, ES1]`

      Rearranges the elements of the receiver so that they are in reverse order and
      then returns the receiver.

      .. code:: javascript
         :name: language-node-repl

         > const arr = ['a', 'b', 'c'];
         > arr.reverse()
         [ 'c', 'b', 'a' ]
         > arr
         [ 'c', 'b', 'a' ]

      The non-destructive version of this method is
      `.toReversed() <#qref-Array.prototype.toReversed>`__.

   -  ``Array.prototype.toReversed()`` :sup:`[R, ES2023]`

      -  Returns a reversed copy of the current Array.
      -  The destructive version of this method is
         `.reverse() <#qref-Array.prototype.reverse>`__.

      .. code:: javascript

         const original = ['x', 'y', 'z'];
         const reversed = original.toReversed();
         assert.deepEqual(
         // The original is unchanged
         original, ['x', 'y', 'z']
         );
         assert.deepEqual(
         // The copy is reversed
         reversed, ['z', 'y', 'x']
         );

33.17.12â€ƒSources of the quick reference
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  `ECMAScript language specification <https://tc39.es/ecma262/>`__
   -  `TypeScriptâ€™s built-in typings <https://github.com/microsoft/TypeScript/tree/main/src/lib/>`__
   -  `MDN web docs for JavaScript <https://developer.mozilla.org/en-US/docs/Web/JavaScript>`__

   `Comments <https://github.com/rauschma/exploring-js/issues/22>`__



.. _ch_typed-arrays:

34â€ƒTyped Arrays: handling binary data [ES6] (advanced)
=======================================================

   #. `34.1â€ƒAn overview of the API <#an-overview-of-the-api>`__

      #. `34.1.1â€ƒUse cases for Typed Arrays <#use-cases-for-typed-arrays>`__
      #. `34.1.2â€ƒThe core classes: ArrayBuffer, Typed Arrays, DataView <#the-core-classes-arraybuffer-typed-arrays-dataview>`__
      #. `34.1.3â€ƒSharedArrayBuffer [ES2017] <#SharedArrayBuffer>`__

   #. `34.2â€ƒUsing Typed Arrays <#using-typed-arrays>`__

      #. `34.2.1â€ƒCreating Typed Arrays <#creating-typed-arrays>`__
      #. `34.2.2â€ƒThe wrapped ArrayBuffer <#the-wrapped-arraybuffer>`__
      #. `34.2.3â€ƒGetting and setting elements <#getting-and-setting-elements>`__
      #. `34.2.4â€ƒConcatenating Typed Arrays <#concatenating-typed-arrays>`__
      #. `34.2.5â€ƒTyped Arrays vs. normal Arrays <#typed-arrays-vs-normal-arrays>`__

   #. `34.3â€ƒUsing DataViews <#using-dataviews>`__
   #. `34.4â€ƒElement types <#element-types>`__

      #. `34.4.1â€ƒHandling overflow and underflow <#handling-overflow-underflow>`__
      #. `34.4.2â€ƒEndianness <#endianness>`__

   #. `34.5â€ƒConverting to and from Typed Arrays <#converting-to-and-from-typed-arrays>`__

      #. `34.5.1â€ƒThe static method Â«ElementTypeÂ»Array.from() <#the-static-method-elementtype-array-from>`__
      #. `34.5.2â€ƒTyped Arrays are iterable <#typed-arrays-are-iterable>`__
      #. `34.5.3â€ƒConverting Typed Arrays to and from normal Arrays <#converting-typed-arrays-to-and-from-normal-arrays>`__

   #. `34.6â€ƒResizing ArrayBuffers [ES2024] <#resizing-array-buffers>`__

      #. `34.6.1â€ƒNew features for ArrayBuffers <#new-features-for-arraybuffers>`__
      #. `34.6.2â€ƒHow Typed Arrays react to changing ArrayBuffer sizes <#how-typed-arrays-react-to-changing-arraybuffer-sizes>`__
      #. `34.6.3â€ƒGuidelines given by the ECMAScript specification <#guidelines-given-by-the-ecmascript-specification>`__

   #. `34.7â€ƒTransferring and detaching ArrayBuffers [ES2024] <#transferring-detaching-array-buffers>`__

      #. `34.7.1â€ƒPreparation: transferring data and detaching <#preparation-transferring-data-and-detaching>`__
      #. `34.7.2â€ƒMethods related to transferring and detaching <#methods-related-to-transferring-and-detaching>`__
      #. `34.7.3â€ƒTransferring ArrayBuffers via structuredClone() <#transferring-arraybuffers-via-structuredclone>`__
      #. `34.7.4â€ƒTransferring an ArrayBuffer within the same agent <#transferring-an-arraybuffer-within-the-same-agent>`__
      #. `34.7.5â€ƒHow does detaching an ArrayBuffer affect its wrappers? <#how-does-detaching-an-arraybuffer-affect-its-wrappers>`__
      #. `34.7.6â€ƒArrayBuffer.prototype.transferToFixedLength() <#arraybuffer-prototype-transfertofixedlength>`__

   #. `34.8â€ƒQuick references: indices vs. offsets <#typed-arrays-indices-offsets>`__
   #. `34.9â€ƒQuick reference: ArrayBuffers <#quick-reference-arraybuffers>`__

      #. `34.9.1â€ƒnew ArrayBuffer() <#new-arraybuffer>`__
      #. `34.9.2â€ƒArrayBuffer.* <#arraybuffer>`__
      #. `34.9.3â€ƒArrayBuffer.prototype.*: getting and slicing <#arraybuffer-prototype-getting-and-slicing>`__
      #. `34.9.4â€ƒArrayBuffer.prototype.*: resizing <#arraybuffer-prototype-resizing>`__

   #. `34.10â€ƒQuick reference: Typed Arrays <#quick-reference-typed-arrays>`__

      #. `34.10.1â€ƒTypedArray.* <#typedarray>`__
      #. `34.10.2â€ƒTypedArray.prototype.* <#typedarray-prototype>`__
      #. `34.10.3â€ƒnew Â«ElementTypeÂ»Array() <#new-elementtype-array>`__
      #. `34.10.4â€ƒÂ«ElementTypeÂ»Array.* <#elementtype-array>`__
      #. `34.10.5â€ƒÂ«ElementTypeÂ»Array.prototype.* <#elementtype-array-prototype>`__

   #. `34.11â€ƒQuick reference: DataViews <#quick-reference-dataviews>`__

      #. `34.11.1â€ƒnew DataView() <#new-dataview>`__
      #. `34.11.2â€ƒDataView.prototype.* <#dataview-prototype>`__

34.1â€ƒAn overview of the API
----------------------------

   Much data on the web is text: JSON files, HTML files, CSS files, JavaScript
   code, etc. JavaScript handles such data well via its built-in strings.

   However, before 2011, it did not handle binary data well. `The Typed Array
   Specification
   1.0 <https://web.archive.org/web/20160529225618/https://www.khronos.org/registry/typedarray/specs/1.0/>`__
   was introduced on February 8, 2011 and provides tools for working with binary
   data. With ECMAScript 6, Typed Arrays were added to the core language and gained
   methods that were previously only available for normal Arrays (``.map()``,
   ``.filter()``, etc.).

34.1.1â€ƒUse cases for Typed Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The main uses cases for Typed Arrays, are:

   -  Processing binary data: managing image data, manipulating binary files,
      handling binary network protocols, etc.

   -  Interacting with native APIs: Native APIs often receive and return data in a
      binary format, which we could neither store nor manipulate well in pre-ES6
      JavaScript. That meant that whenever we were communicating with such an API,
      data had to be converted from JavaScript to binary and back for every call.
      Typed Arrays eliminate this bottleneck. Examples include:

      -  `WebGL <https://www.khronos.org/webgl/>`__, â€œa low-level 3D graphics API
         based on OpenGL ES, exposed to ECMAScript via the HTML5 Canvas elementâ€.
         Typed Arrays were initially created for WebGL. Section `â€œHistory of Typed
         Arraysâ€ <https://web.dev/articles/webgl-typed-arrays#toc-history>`__ of
         the article `â€œTyped Arrays: Binary Data in the
         Browserâ€ <https://web.dev/articles/webgl-typed-arrays#toc-history>`__ (by
         Ilmari Heikkinen for HTML5 Rocks) has more information.

      -  `WebGPU <https://www.w3.org/TR/webgpu/>`__, â€œan API for performing
         operations, such as rendering and computation, on a Graphics Processing
         Unitâ€. For example, WebGPU uses ArrayBuffers as wrappers for backing
         stores.

      -  `WebAssembly <https://webassembly.org>`__ (short: â€œWasmâ€), â€œa binary
         instruction format for a stack-based virtual machine. Wasm is designed as
         a portable compilation target for programming languages, enabling
         deployment on the web for client and server applications.â€ For example,
         the memory of WebAssembly code is stored in an ArrayBuffer or a
         SharedArrayBuffer
         (`details <https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Memory>`__).

34.1.2â€ƒThe core classes: ``ArrayBuffer``, Typed Arrays, ``DataView``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The Typed Array API stores binary data in instances of ``ArrayBuffer``:

   .. code:: javascript

      const buf = new ArrayBuffer(4); // length in bytes
      // buf is initialized with zeros

   An ArrayBuffer itself is a black box: if we want to access its data, we must
   wrap it in another object â€“ a *view object*. Two kinds of view objects are
   available:

   -  Typed Arrays: let us access the data as an indexed sequence of elements that
      all have the same type. Examples include:

      -  ``Uint8Array``: Elements are unsigned 8-bit integers. *Unsigned* means
         that their ranges start at zero.
      -  ``Int16Array``: Elements are signed 16-bit integers. *Signed* means that
         they have a sign and can be negative, zero, or positive.
      -  ``Float32Array``: Elements are 32-bit floating point numbers.

   -  DataViews: let us interpret the data as various types (``Uint8``, ``Int16``,
      ``Float32``, etc.) that we can read and write at any byte offset.

   `Figure 34.1 <#fig:typed_arrays_class_diagram>`__ shows a class diagram of the
   API.

   .. figure:: https://exploringjs.com/js/book/img-book/typed-arrays/typed_arrays_class_diagram.jpg
      name: fig:typed_arrays_class_diagram
      :width: 411px
      :height: 291px

      Figure 34.1: The classes of the Typed Array API.



.. _SharedArrayBuffer:

34.1.3â€ƒ``SharedArrayBuffer`` [ES2017]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   SharedArrayBuffer is an ArrayBuffer whose memory can be accessed by multiple
   *agents* (an agent being the main thread or a web worker) concurrently.

   -  Where ArrayBuffers can be
      `transferred <#transferring-detaching-array-buffers>`__ (moved, not copied)
      between agents, SharedArrayBuffers are not transferrable and must be cloned.
      However, that only clones their outer parts. The data storage itself is
      shared.
   -  SharedArrayBuffers can be `resized <#resizing-array-buffers>`__ but they can
      only grow not shrink because shrinking shared memory is too complicated.
   -  ``Atomics`` is a global namespace for an API that complements
      SharedArrayBuffers. The ECMAScript specification `describes
      it <https://tc39.es/ecma262/#sec-atomics-object>`__ as â€œfunctions that
      operate indivisibly (atomically) on shared memory array cells as well as
      functions that let agents wait for and dispatch primitive events. When used
      with discipline, the Atomics functions allow multi-agent programs that
      communicate through shared memory to execute in a well-understood order even
      on parallel CPUs.â€

   See MDN Web Docs for more information on
   `SharedArrayBuffer <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer>`__
   and
   `Atomics <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics>`__.

34.2â€ƒUsing Typed Arrays
------------------------

   Typed Arrays are used much like normal Arrays.

34.2.1â€ƒCreating Typed Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following code shows three different ways of creating the same Typed Array:

   .. code:: javascript

      // Argument: Typed Array or Array-like object
      const ta1 = new Uint8Array([0, 1, 2]);

      const ta2 = Uint8Array.of(0, 1, 2);

      const ta3 = new Uint8Array(3); // length of Typed Array
      ta3[0] = 0;
      ta3[1] = 1;
      ta3[2] = 2;

      assert.deepEqual(ta1, ta2);
      assert.deepEqual(ta1, ta3);

34.2.2â€ƒThe wrapped ArrayBuffer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. code:: javascript

      const typedArray = new Int16Array(2); // 2 elements
      assert.equal(typedArray.length, 2);

      assert.deepEqual(
      typedArray.buffer, new ArrayBuffer(4)); // 4 bytes

34.2.3â€ƒGetting and setting elements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. code:: javascript

      const typedArray = new Int16Array(2);

      assert.equal(typedArray[1], 0); // initialized with 0
      typedArray[1] = 72;
      assert.equal(typedArray[1], 72);

34.2.4â€ƒConcatenating Typed Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Typed Arrays donâ€™t have a method ``.concat()``, like normal Arrays do. The
   workaround is to use their overloaded method ``.set()``:

   .. code:: javascript
      :name: language-ts

      .set(typedArray: TypedArray, offset=0): void
      .set(arrayLike: ArrayLike<number>, offset=0): void

   It copies the existing ``typedArray`` or ``arrayLike`` into the receiver, at
   index ``offset``. ``TypedArray`` is an internal abstract superclass of all
   concrete Typed Array classes (that doesnâ€™t actually have a global name).

   The following function uses that method to copy zero or more Typed Arrays (or
   Array-like objects) into an instance of ``resultConstructor``:

   .. code:: javascript

      function concatenate(resultConstructor, ...arrays) {
      let totalLength = 0;
      for (const arr of arrays) {
         totalLength += arr.length;
      }
      const result = new resultConstructor(totalLength);
      let offset = 0;
      for (const arr of arrays) {
         result.set(arr, offset);
         offset += arr.length;
      }
      return result;
      }
      assert.deepEqual(
      concatenate(Uint8Array, Uint8Array.of(1, 2), [3, 4]),
      Uint8Array.of(1, 2, 3, 4));



.. _typed-arrays-vs-normal-arrays:

34.2.5â€ƒTyped Arrays vs. normal Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Typed Arrays are much like normal Arrays: they have a ``.length``, elements can
   be accessed via the bracket operator ``[]``, and they have most of the standard
   Array methods. They differ from normal Arrays in the following ways:

   -  Typed Arrays have buffers. The elements of a Typed Array ``ta`` are not
      stored in ``ta``, they are stored in an associated ArrayBuffer that can be
      accessed via ``ta.buffer``:

      .. code:: javascript

         const ta = new Uint16Array(2); // 2 elements
         assert.deepEqual(
         ta.buffer, new ArrayBuffer(4)); // 4 bytes

   -  Typed Arrays are initialized with zeros:

      -  ``new Array(4)`` creates a normal Array without any elements. It only has
         four *holes* (indices less than the ``.length`` that have no associated
         elements).
      -  ``new Uint8Array(4)`` creates a Typed Array whose four elements are all 0.

      .. code:: javascript

         assert.deepEqual(new Uint8Array(4), Uint8Array.of(0, 0, 0, 0));

   -  All of the elements of a Typed Array have the same type:

      -  Setting elements converts values to that type.

         .. code:: javascript

            const ta = new Uint8Array(1);

            ta[0] = 257;
            assert.equal(ta[0], 1); // 257 % 256 (overflow)

            ta[0] = '2';
            assert.equal(ta[0], 2);

      -  Getting elements returns numbers or bigints.

         .. code:: javascript

            const ta = new Uint8Array(1);
            assert.equal(ta[0], 0);
            assert.equal(typeof ta[0], 'number');

   -  The ``.length`` of a Typed Array is derived from its ArrayBuffer and never
      changes (unless we switch to a different ArrayBuffer).

   -  Normal Arrays can have holes; Typed Arrays canâ€™t.

34.3â€ƒUsing DataViews
---------------------

   This is how DataViews are used:

   .. code:: javascript

      const dataView = new DataView(new ArrayBuffer(4));
      assert.equal(dataView.getInt16(0), 0);
      assert.equal(dataView.getUint8(0), 0);
      dataView.setUint8(0, 5);

34.4â€ƒElement types
-------------------

   ========== ================== ======= ====================== ======== =======
   Element    Typed Array        Bytes   Description             Get/Set  
   Int8       Int8Array          1       8-bit signed integer    number   ES6
   Uint8      Uint8Array         1       8-bit unsigned int      number   ES6
   Uint8C     Uint8ClampedArray  1       8-bit unsigned int      number   ES6
   \                                     (clamped conv.)         number   ES6
   Int16      Int16Array         2       16-bit signed int       number   ES6
   Uint16     Uint16Array        2       16-bit unsigned int     number   ES6
   Int32      Int32Array         4       32-bit signed int       number   ES6
   Uint32     Uint32Array        4       32-bit unsigned int     number   ES6
   BigInt64   BigInt64Array      8       64-bit signed int       bigint   ES2020
   BigUint64  BigUint64Array     8       64-bit unsigned int     bigint   ES2020
   Float32    Float32Array       4       32-bit floating point   number   ES6
   Float64    Float64Array       8       64-bit floating point   number   ES6
   ========== ================== ======= ====================== ======== =======

   Table 34.1: Element types supported by the Typed Array API.

   `Table 34.1 <#tbl:typed-array-element-types>`__ lists the available element
   types. These types (e.g., ``Int32``) show up in two locations:

   -  In Typed Arrays, they specify the types of the elements. For example, all
      elements of a ``Int32Array`` have the type ``Int32``. The element type is the
      only aspect of Typed Arrays that differs.

   -  In DataViews, they are the lenses through which they access their
      ArrayBuffers when we use methods such as ``.getInt32()`` and ``.setInt32()``.

   The element type ``Uint8C`` is special: it is not supported by ``DataView`` and
   only exists to enable ``Uint8ClampedArray``. This Typed Array is used by the
   ``canvas`` element (where it replaces ``CanvasPixelArray``) and should otherwise
   be avoided. The only difference between ``Uint8C`` and ``Uint8`` is how overflow
   and underflow are handled (as explained in the next subsection).

   Typed Arrays and Array Buffers use numbers and bigints to import and export
   values:

   -  The types ``BigInt64`` and ``BigUint64`` are handled via bigints. For
      example, setters accept bigints and getters return bigints.

   -  All other element types are handled via numbers.



.. _handling-overflow-underflow:

34.4.1â€ƒHandling overflow and underflow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Normally, when a value is out of the range of the element type, modulo
   arithmetic is used to convert it to a value within range. For signed and
   unsigned integers that means that:

   -  The highest value plus one is converted to the lowest value (0 for unsigned
      integers).
   -  The lowest value minus one is converted to the highest value.

   The following function helps illustrate how conversion works:

   .. code:: javascript

      function setAndGet(typedArray, value) {
      typedArray[0] = value;
      return typedArray[0];
      }

   Modulo conversion for unsigned 8-bit integers:

   .. code:: javascript

      const uint8 = new Uint8Array(1);

      // Highest value of range
      assert.equal(setAndGet(uint8, 255), 255);
      // Overflow
      assert.equal(setAndGet(uint8, 256), 0);

      // Lowest value of range
      assert.equal(setAndGet(uint8, 0), 0);
      // Underflow
      assert.equal(setAndGet(uint8, -1), 255);

   Modulo conversion for signed 8-bit integers:

   .. code:: javascript

      const int8 = new Int8Array(1);

      // Highest value of range
      assert.equal(setAndGet(int8, 127), 127);
      // Overflow
      assert.equal(setAndGet(int8, 128), -128);

      // Lowest value of range
      assert.equal(setAndGet(int8, -128), -128);
      // Underflow
      assert.equal(setAndGet(int8, -129), 127);

   Clamped conversion is different:

   -  All underflowing values are converted to the lowest value.
   -  All overflowing values are converted to the highest value.

   .. code:: javascript

      const uint8c = new Uint8ClampedArray(1);

      // Highest value of range
      assert.equal(setAndGet(uint8c, 255), 255);
      // Overflow
      assert.equal(setAndGet(uint8c, 256), 255);

      // Lowest value of range
      assert.equal(setAndGet(uint8c, 0), 0);
      // Underflow
      assert.equal(setAndGet(uint8c, -1), 0);

34.4.2â€ƒEndianness
~~~~~~~~~~~~~~~~~~

   Whenever a type (such as ``Uint16``) is stored as a sequence of multiple bytes,
   *endianness* matters:

   -  Big endian: the most significant byte comes first. For example, the
      ``Uint16`` value 0x4321 is stored as two bytes â€“ first 0x43, then 0x21.
   -  Little endian: the least significant byte comes first. For example, the
      ``Uint16`` value 0x4321 is stored as two bytes â€“ first 0x21, then 0x43.

   Endianness tends to be fixed per CPU architecture and consistent across native
   APIs. Typed Arrays are used to communicate with those APIs, which is why their
   endianness follows the endianness of the platform and canâ€™t be changed.

   On the other hand, the endianness of protocols and binary files varies, but is
   fixed per format, across platforms. Therefore, we must be able to access data
   with either endianness. DataViews serve this use case and let us specify
   endianness when we get or set a value.

   `Quoting Wikipedia on Endianness <https://en.wikipedia.org/wiki/Endianness>`__:

   -  Big-endian representation is the most common convention in data networking;
      fields in the protocols of the Internet protocol suite, such as IPv4, IPv6,
      TCP, and UDP, are transmitted in big-endian order. For this reason,
      big-endian byte order is also referred to as network byte order.
   -  Little-endian storage is popular for microprocessors in part due to
      significant historical influence on microprocessor designs by Intel
      Corporation.

   Other orderings are also possible. Those are generically called *middle-endian*
   or *mixed-endian*.

34.5â€ƒConverting to and from Typed Arrays
-----------------------------------------

   In this section, ``Â«ElementTypeÂ»Array`` stands for ``Int8Array``,
   ``Uint8Array``, etc. ``ElementType`` is ``Int8``, ``Uint8``, etc.



.. _the-static-method-elementtype-array-from:

34.5.1â€ƒThe static method ``Â«ElementTypeÂ»Array.from()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This method has the type signature:

   .. code:: javascript
      :name: language-ts

      .from<S>(
      source: Iterable<S>|ArrayLike<S>,
      mapfn?: S => ElementType, thisArg?: any)
      : Â«ElementTypeÂ»Array

   ``.from()`` converts ``source`` into an instance of ``this`` (a Typed Array).

   For example, normal Arrays are iterable and can be converted with this method:

   .. code:: javascript

      assert.deepEqual(
      Uint16Array.from([0, 1, 2]),
      Uint16Array.of(0, 1, 2));

   Typed Arrays are also iterable:

   .. code:: javascript

      assert.deepEqual(
      Uint16Array.from(Uint8Array.of(0, 1, 2)),
      Uint16Array.of(0, 1, 2));

   ``source`` can also be `an Array-like
   object <#array-like-objects>`__:

   .. code:: javascript

      assert.deepEqual(
      Uint16Array.from({0:0, 1:1, 2:2, length: 3}),
      Uint16Array.of(0, 1, 2));

   The optional ``mapfn`` lets us transform the elements of ``source`` before they
   become elements of the result. Why perform the two steps *mapping* and
   *conversion* in one go? Compared to mapping separately via ``.map()``, there are
   two advantages:

   #. No intermediate Array or Typed Array is needed.
   #. When converting between Typed Arrays with different precisions, less can go
      wrong.

   Read on for an explanation of the second advantage.

34.5.1.1â€ƒPitfall: mapping while converting between Typed Array types
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The static method ``.from()`` can optionally both map and convert between Typed
   Array types. Less can go wrong if we use that method.

   To see why that is, let us first convert a Typed Array to a Typed Array with a
   higher precision. If we use ``.from()`` to map, the result is automatically
   correct. Otherwise, we must first convert and then map.

   .. code:: javascript

      const typedArray = Int8Array.of(127, 126, 125);
      assert.deepEqual(
      Int16Array.from(typedArray, x => x * 2),
      Int16Array.of(254, 252, 250));

      assert.deepEqual(
      Int16Array.from(typedArray).map(x => x * 2),
      Int16Array.of(254, 252, 250)); // OK
      assert.deepEqual(
      Int16Array.from(typedArray.map(x => x * 2)),
      Int16Array.of(-2, -4, -6)); // wrong

   If we go from a Typed Array to a Typed Array with a lower precision, mapping via
   ``.from()`` produces the correct result. Otherwise, we must first map and then
   convert.

   .. code:: javascript

      assert.deepEqual(
      Int8Array.from(Int16Array.of(254, 252, 250), x => x / 2),
      Int8Array.of(127, 126, 125));

      assert.deepEqual(
      Int8Array.from(Int16Array.of(254, 252, 250).map(x => x / 2)),
      Int8Array.of(127, 126, 125)); // OK
      assert.deepEqual(
      Int8Array.from(Int16Array.of(254, 252, 250)).map(x => x / 2),
      Int8Array.of(-1, -2, -3)); // wrong

   The problem is that if we map via ``.map()``, then input type and output type
   are the same. In contrast, ``.from()`` goes from an arbitrary input type to an
   output type that we specify via its receiver.

34.5.2â€ƒTyped Arrays are iterable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Typed Arrays are `iterable <#ch_sync-iteration>`__. That
   means that we can use the ``for-of`` loop and other iteration-based mechanisms:

   .. code:: javascript

      const ui8 = Uint8Array.of(0, 1, 2);
      for (const byte of ui8) {
      console.log(byte);
      }

   Output:

   ::

      0
      1
      2

   ArrayBuffers and DataViews are not iterable.

34.5.3â€ƒConverting Typed Arrays to and from normal Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To convert a normal Array to a Typed Array, we pass it to:

   -  A Typed Array constructor â€“ which accepts Typed Arrays, iterable values and
      Array-like objects.
   -  ``Â«ElementTypeÂ»Array.from()`` â€“ which accepts iterable values and Array-like
      values.

   For example:

   .. code:: javascript

      const ta1 = new Uint8Array([0, 1, 2]);
      const ta2 = Uint8Array.from([0, 1, 2]);
      assert.deepEqual(ta1, ta2);

   To convert a Typed Array to a normal Array, we can use ``Array.from()`` or
   spreading (because Typed Arrays are iterable):

   .. code:: javascript

      assert.deepEqual(
      [...Uint8Array.of(0, 1, 2)], [0, 1, 2]
      );
      assert.deepEqual(
      Array.from(Uint8Array.of(0, 1, 2)), [0, 1, 2]
      );



.. _resizing-array-buffers:

34.6â€ƒResizing ArrayBuffers [ES2024]
------------------------------------

   Before ArrayBuffers became resizable, they had fixed sizes. If we wanted one to
   grow or shrink, we had to allocate a new one and copy the old one over. That
   costs time and can fragment the address space on 32-bit systems.

34.6.1â€ƒNew features for ArrayBuffers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   These are the changes introduced by resizing:

   -  The existing constructor gets one more parameter:

      .. code:: javascript
         :name: language-ts

         new ArrayBuffer(byteLength: number, options?: {maxByteLength?: number})

   -  There is one new method and two new getters:

      -  ``ArrayBuffer.prototype.resize(newByteLength: number)``

         -  Resizes the ArrayBuffer.

      -  ``get ArrayBuffer.prototype.resizable``

         -  Returns a boolean indicating if this ArrayBuffer is resizable.

      -  ``get ArrayBuffer.prototype.maxByteLength``

         -  Returns ``options.maxByteLength`` if it was provided to the
            constructor. Otherwise, it returns ``this.byteLength``.

   -  The existing method ``.slice()`` always returns non-resizable ArrayBuffers.

   The ``options`` object of the constructor determines whether or not an
   ArrayBuffer is resizable:

   .. code:: javascript

      const resizableArrayBuffer = new ArrayBuffer(16, {maxByteLength: 32});
      assert.equal(
      resizableArrayBuffer.resizable, true
      );

      const fixedArrayBuffer = new ArrayBuffer(16);
      assert.equal(
      fixedArrayBuffer.resizable, false
      );

34.6.2â€ƒHow Typed Arrays react to changing ArrayBuffer sizes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is what constructors of Typed Arrays look like:

   .. code:: javascript
      :name: language-ts

      new Â«TypedArrayÂ»(
      buffer: ArrayBuffer | SharedArrayBuffer,
      byteOffset?: number,
      length?: number
      )

   If ``length`` is ``undefined`` then the ``.length`` and ``.byteLength`` of the
   Typed Array instance automatically tracks the length of a resizable ``buffer``:

   .. code:: javascript

      const buf = new ArrayBuffer(2, {maxByteLength: 4});
      // `tarr1` starts at offset 0 (`length` is undefined)
      const tarr1 = new Uint8Array(buf);
      // `tarr2` starts at offset 2 (`length` is undefined)
      const tarr2 = new Uint8Array(buf, 2);

      assert.equal(
      tarr1.length, 2
      );
      assert.equal(
      tarr2.length, 0
      );

      buf.resize(4);

      assert.equal(
      tarr1.length, 4
      );
      assert.equal(
      tarr2.length, 2
      );

   If an ArrayBuffer is resized then a wrapper with a fixed length can *go out of
   bounds*: The wrapperâ€™s range isnâ€™t covered by the ArrayBuffer anymore. That is
   treated by JavaScript as if the ArrayBuffer were
   `detached <#transferring-detaching-array-buffers>`__:

   -  ``.length``, ``.byteLength`` and ``.byteOffset`` are zero.
   -  Getting elements returns ``undefined``.
   -  Setting elements is silently ignored.
   -  All element-related methods throw errors.

   .. code:: javascript

      const buf = new ArrayBuffer(4, {maxByteLength: 4});
      const tarr = new Uint8Array(buf, 2, 2);
      assert.equal(
      tarr.length, 2
      );
      buf.resize(3);
      // `tarr` is now partially out of bounds
      assert.equal(
      tarr.length, 0
      );
      assert.equal(
      tarr.byteLength, 0
      );
      assert.equal(
      tarr.byteOffset, 0
      );
      assert.equal(
      tarr[0], undefined
      );
      assert.throws(
      () => tarr.at(0),
      /^TypeError: Cannot perform %TypedArray%.prototype.at on a detached ArrayBuffer$/
      );

34.6.3â€ƒGuidelines given by the ECMAScript specification
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The ECMAScript specification gives `the following
   guidelines <https://tc39.es/ecma262/#sec-resizable-arraybuffer-guidelines>`__
   for working with resizable ArrayBuffers:

   -  We recommend that programs be tested in their deployment environments where
      possible. The amount of available physical memory differs greatly between
      hardware devices. Similarly, virtual memory subsystems also differ greatly
      between hardware devices as well as operating systems. An application that
      runs without out-of-memory errors on a 64-bit desktop web browser could run
      out of memory on a 32-bit mobile web browser.

   -  When choosing a value for the ``maxByteLength`` option for resizable
      ArrayBuffer, we recommend that the smallest possible size for the application
      be chosen. We recommend that ``maxByteLength`` does not exceed 1,073,741,824
      (2\ :sup:`30` bytes or 1 GiB).

   -  Please note that successfully constructing a resizable ArrayBuffer for a
      particular maximum size does not guarantee that future resizes will succeed.



.. _transferring-detaching-array-buffers:

34.7â€ƒTransferring and detaching ArrayBuffers [ES2024]
------------------------------------------------------

34.7.1â€ƒPreparation: transferring data and detaching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The web API (not the ECMAScript standard) has long supported `structured
   cloning <https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data>`__
   for safely moving values across realms (``globalThis``, iframes, web workers,
   etc.). Some objects can also be *transferred*: After cloning, the original
   becomes *detached* (inaccessible) and ownership switches from the original to
   the clone. Transfering is usually faster than copying, especially if large
   amounts of memory are involved. These are the most common classes of
   `transferable
   objects <https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects>`__:

   -  ``ArrayBuffer``
   -  Streams:

      -  ``ReadableStream``
      -  ``TransformStream``
      -  ``WritableStream``

   -  DOM-related data:

      -  ``ImageBitmap``
      -  ``OffscreenCanvas``

   -  Miscellaneous communication:

      -  ``MessagePort``
      -  ``RTCDataChannel``

34.7.2â€ƒMethods related to transferring and detaching
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  Two methods let us explicitly transfer an ArrayBuffer to a new object (weâ€™ll
      see soon why that is useful):

      -  ``ArrayBuffer.prototype.transfer(newLength?: number)``
      -  ``ArrayBuffer.prototype.transferToFixedLength(newLength?: number)``

   -  One getter tells us if an ArrayBuffer is detached:

      -  ``get ArrayBuffer.prototype.detached``

34.7.3â€ƒTransferring ArrayBuffers via ``structuredClone()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The broadly supported
   `structuredClone() <https://2ality.com/2022/01/structured-clone.html>`__
   also lets us transfer (and therefore detach) ArrayBuffers:

   .. code:: javascript

      const original = new ArrayBuffer(16);
      const clone = structuredClone(original, {transfer: [original]});

      assert.equal(
      original.byteLength, 0
      );

      assert.equal(
      clone.byteLength, 16
      );

   .. code:: javascript

      assert.equal(
      original.detached, true
      );
      assert.equal(
      clone.detached, false
      );

   The ArrayBuffer method ``.transfer()`` simply gives us a more concise way to
   detach an ArrayBuffer:

   .. code:: javascript

      const original = new ArrayBuffer(16);
      const transferred = original.transfer();

      assert.equal(
      original.detached, true
      );
      assert.equal(
      transferred.detached, false
      );

34.7.4â€ƒTransferring an ArrayBuffer within the same agent
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Transferring is most often used between two *agents* (an agent being the main
   thread or a web worker). However, transferring within the same agent can make
   sense too: If a function gets a (potentially shared) ArrayBuffer as a parameter,
   it can transfer it so that no external code can interfere with what it does.
   Example (taken from `the ECMAScript
   proposal <https://github.com/tc39/proposal-arraybuffer-transfer?tab=readme-ov-file#ownership>`__
   and slightly edited):

   .. code:: javascript

      async function validateAndWriteSafeAndFast(arrayBuffer) {
      const owned = arrayBuffer.transfer();

      // We have `owned` and no one can access its data via
      // `arrayBuffer` now because the latter is detached:
      assert.equal(
         arrayBuffer.detached, true
      );

      // `await` pauses this function â€“ which gives external
      // code the opportunity to access `arrayBuffer`.
      await validate(owned);
      await fs.writeFile("data.bin", owned);
      }

34.7.5â€ƒHow does detaching an ArrayBuffer affect its wrappers?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

34.7.5.1â€ƒTyped Arrays with detached ArrayBuffers
'''''''''''''''''''''''''''''''''''''''''''''''''

   Preparation:

   .. code:: javascript
      :name: language-node-repl

      > const arrayBuffer = new ArrayBuffer(16);
      > const typedArray = new Uint8Array(arrayBuffer);
      > arrayBuffer.transfer();

   Lengths and offsets are all zero:

   .. code:: javascript
      :name: language-node-repl

      > typedArray.length
      0
      > typedArray.byteLength
      0
      > typedArray.byteOffset
      0

   Getting elements returns ``undefined``; setting elements fails silently:

   .. code:: javascript
      :name: language-node-repl

      > typedArray[0]
      undefined
      > typedArray[0] = 128
      128

   All element-related methods throw exceptions:

   .. code:: javascript
      :name: language-node-repl

      > typedArray.at(0)
      TypeError: Cannot perform %TypedArray%.prototype.at on a detached ArrayBuffer

34.7.5.2â€ƒDataViews with detached ArrayBuffers
''''''''''''''''''''''''''''''''''''''''''''''

   All data-related methods of DataViews throw:

   .. code:: javascript
      :name: language-node-repl

      > const arrayBuffer = new ArrayBuffer(16);
      > const dataView = new DataView(arrayBuffer);
      > arrayBuffer.transfer();
      > dataView.byteLength
      TypeError: Cannot perform get DataView.prototype.byteLength on a detached ArrayBuffer
      > dataView.getUint8(0)
      TypeError: Cannot perform DataView.prototype.getUint8 on a detached ArrayBuffer



.. _we-can-t-create-new-wrappers-with-detached-arraybuffers:

34.7.5.3â€ƒWe canâ€™t create new wrappers with detached ArrayBuffers
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   .. code:: javascript
      :name: language-node-repl

      > const arrayBuffer = new ArrayBuffer(16);
      > arrayBuffer.transfer();
      > new Uint8Array(arrayBuffer)
      TypeError: Cannot perform Construct on a detached ArrayBuffer
      > new DataView(arrayBuffer)
      TypeError: Cannot perform DataView constructor on a detached ArrayBuffer



.. _arraybuffer-prototype-transfertofixedlength:

34.7.6â€ƒ``ArrayBuffer.prototype.transferToFixedLength()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This method rounds out the API: It transfers and converts a resizable
   ArrayBuffer to one with a fixed length. That may free up memory that was held in
   preparation for growth.



.. _typed-arrays-indices-offsets:

34.8â€ƒQuick references: indices vs. offsets
-------------------------------------------

   In preparation for the quick references on ArrayBuffers, Typed Arrays, and
   DataViews, we need learn the differences between indices and offsets:

   -  Indices for the bracket operator ``[ ]``: We can only use non-negative
      indices (starting at 0).

      In normal Arrays, writing to negative indices creates properties:

      .. code:: javascript

         const arr = [6, 7];
         arr[-1] = 5;
         assert.deepEqual(
         Object.keys(arr), ['0', '1', '-1']);

      In Typed Arrays, writing to negative indices is ignored:

      .. code:: javascript

         const tarr = Uint8Array.of(6, 7);
         tarr[-1] = 5;
         assert.deepEqual(
         Object.keys(tarr), ['0', '1']);

   -  Indices for methods of ArrayBuffers, Typed Arrays, and DataViews: Every index
      can be negative. If it is, it is added to the length of the entity to produce
      the actual index. Therefore, ``-1`` refers to the last element, ``-2`` to the
      second-last, etc. Methods of normal Arrays work the same way.

      .. code:: javascript

         const ui8 = Uint8Array.of(0, 1, 2);
         assert.deepEqual(ui8.slice(-1), Uint8Array.of(2));

   -  Offsets passed to methods of Typed Arrays and DataViews: must be non-negative
      â€“ for example:

      .. code:: javascript

         const dataView = new DataView(new ArrayBuffer(4));
         assert.throws(
         () => dataView.getUint8(-1),
         {
            name: 'RangeError',
            message: 'Offset is outside the bounds of the DataView',
         });

   Whether a parameter is an index or an offset can only be determined by looking
   at documentation; there is no simple rule.

34.9â€ƒQuick reference: ArrayBuffers
-----------------------------------

   ArrayBuffers store binary data, which is meant to be accessed via Typed Arrays
   and DataViews.

34.9.1â€ƒ``new ArrayBuffer()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``new ArrayBuffer(byteLength, options?)`` :sup:`[ES6]`

      .. code:: javascript
         :name: language-ts

         new ArrayBuffer(
         byteLength: number,
         options?: { // ES2024
            maxByteLength?: number
         }
         )

      Invoking this constructor via ``new`` creates an instance whose capacity is
      ``length`` bytes. Each of those bytes is initially 0.

      If ``options.maxByteLength`` is provided, the ArrayBuffer can be resized.
      Otherwise, it has a fixed length.



.. _arraybuffer:

34.9.2â€ƒ``ArrayBuffer.*``
~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``ArrayBuffer.isView(arg)`` :sup:`[ES6]`

      Returns ``true`` if ``arg`` is a *view* for an ArrayBuffer (i.e., if it is a
      Typed Array or a DataView).

      .. code:: javascript
         :name: language-node-repl

         > ArrayBuffer.isView(new Uint8Array())
         true
         > ArrayBuffer.isView(new DataView(new ArrayBuffer()))
         true



.. _arraybuffer-prototype-getting-and-slicing:

34.9.3â€ƒ``ArrayBuffer.prototype.*``: getting and slicing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``get ArrayBuffer.prototype.byteLength`` :sup:`[ES6]`

      Returns the capacity of this ArrayBuffer in bytes.

   -  ``ArrayBuffer.prototype.slice(startIndex=0, endIndex=this.byteLength)``
      :sup:`[ES6]`

      Creates a new ArrayBuffer that contains the bytes of this ArrayBuffer whose
      indices are greater than or equal to ``startIndex`` and less than
      ``endIndex``. ``start`` and ``endIndex`` can be negative (see `â€œQuick
      references: indices vs. offsetsâ€ (Â§34.8) <#typed-arrays-indices-offsets>`__).



.. _arraybuffer-prototype-resizing:

34.9.4â€ƒ``ArrayBuffer.prototype.*``: resizing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``ArrayBuffer.prototype.resize(newByteLength)`` :sup:`[ES2024]`

      Changes the size of this ArrayBuffer. For more information, see `â€œResizing
      ArrayBuffersâ€ (Â§34.6) <#resizing-array-buffers>`__.

   -  ``get ArrayBuffer.prototype.resizable`` :sup:`[ES2024]`

      Returns ``true`` if this ArrayBuffer is resizable and ``false`` if it is not.

   -  ``get ArrayBuffer.prototype.maxByteLength`` :sup:`[ES2024]`

      Returns ``options.maxByteLength`` if it was provided to the constructor.
      Otherwise, it returns ``this.byteLength``.

34.10â€ƒQuick reference: Typed Arrays
------------------------------------

   The properties of the various Typed Array objects are introduced in two steps:

   #. ``TypedArray``: First, we look at the abstract superclass of all Typed Array
      classes (which was shown in the class diagram `at the beginning of this
      chapter <#fig:typed_arrays_class_diagram>`__). That superclass is called
      ``TypedArray`` but it does not have a global name in JavaScript:

      .. code:: javascript
         :name: language-node-repl

         > Object.getPrototypeOf(Uint8Array).name
         'TypedArray'

   #. ``Â«ElementTypeÂ»Array``: The concrete Typed Array classes are called
      ``Uint8Array``, ``Int16Array``, ``Float32Array``, etc. These are the classes
      that we use via ``new``, ``.of``, and ``.from()``.



.. _typedarray:

34.10.1â€ƒ``TypedArray.*``
~~~~~~~~~~~~~~~~~~~~~~~~~

   Both static ``TypedArray`` methods are inherited by its subclasses
   (``Uint8Array``, etc.). Therefore, we can use these methods via the subclasses,
   which are concrete and can have direct instances.

   -  ``TypedArray.from(iterableOrArrayLike, mapFunc?)`` :sup:`[ES6]`

      .. code:: javascript
         :name: language-ts

         // BigInt64Array: bigint instead of number
         TypedArray.from<T>(
         iterableOrArrayLike: Iterable<number> | ArrayLike<number>
         ): TypedArray<T>
         TypedArray.from<S, T>(
         iterableOrArrayLike: Iterable<S> | ArrayLike<S>,
         mapFunc: (v: S, k: number) => T, thisArg?: any
         ): TypedArray<T>

      Converts an iterable (including Arrays and Typed Arrays) or `an Array-like
      object <#array-like-objects>`__ to an instance of the Typed
      Array class.

      .. code:: javascript

         assert.deepEqual(
         Uint16Array.from([0, 1, 2]),
         Uint16Array.of(0, 1, 2));

      The optional ``mapFunc`` lets us transform the elements of ``source`` before
      they become elements of the result.

      .. code:: javascript

         assert.deepEqual(
         Int16Array.from(Int8Array.of(127, 126, 125), x => x * 2),
         Int16Array.of(254, 252, 250));

   -  ``TypedArray.of(...items)`` :sup:`[ES6]`

      .. code:: javascript
         :name: language-ts

         // BigInt64Array: bigint instead of number
         TypedArray.of<T>(
         ...items: Array<number>
         ): TypedArray<T>

      Creates a new instance of the Typed Array class whose elements are ``items``
      (coerced to the element type).

      .. code:: javascript

         assert.deepEqual(
         Int16Array.of(-1234, 5, 67),
         new Int16Array([-1234, 5, 67]) );



.. _typedarray-prototype:

34.10.2â€ƒ``TypedArray.prototype.*``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Indices accepted by Typed Array methods can be negative (they work like
   traditional Array methods that way). Offsets must be non-negative. For details,
   see `â€œQuick references: indices vs. offsetsâ€
   (Â§34.8) <#typed-arrays-indices-offsets>`__.

34.10.2.1â€ƒProperties specific to Typed Arrays
''''''''''''''''''''''''''''''''''''''''''''''

   The following properties are specific to Typed Arrays; normal Arrays donâ€™t have
   them:

   -  ``get TypedArray.prototype.buffer``

      Returns the ArrayBuffer backing this Typed Array.

   -  ``get TypedArray.prototype.length``

      Returns the length in elements of this Typed Arrayâ€™s buffer.

      .. code:: javascript
         :name: language-node-repl

         > new Uint32Array(new ArrayBuffer(4)).length
         1

   -  ``get TypedArray.prototype.byteLength``

      Returns the size in bytes of this Typed Arrayâ€™s buffer.

      .. code:: javascript
         :name: language-node-repl

         > new Uint32Array(new ArrayBuffer(4)).byteLength
         4

   -  ``get TypedArray.prototype.byteOffset``

      Returns the offset where this Typed Array â€œstartsâ€ inside its ArrayBuffer.

   -  ``TypedArray.prototype.set(typedArrayOrArrayLike, offset=0)``

      Copies all elements of the first parameter to this Typed Array. The element
      at index 0 of the parameter is written to index ``offset`` of this Typed
      Array (etc.). For more information on Array-like objects, consult
      `â€œArray-like objectsâ€ (Â§33.5) <#array-like-objects>`__.

   -  ``TypedArray.prototype.subarray(startIndex=0, endIndex=this.length)``

      Returns a new Typed Array that has the same buffer as this Typed Array, but a
      (generally) smaller range. If ``startIndex`` is non-negative then the first
      element of the resulting Typed Array is ``this[startIndex]``, the second
      ``this[startIndex+1]`` (etc.). If ``startIndex`` in negative, it is converted
      appropriately.

34.10.2.2â€ƒArray methods
''''''''''''''''''''''''

   The following methods are basically the same as the methods of normal Arrays
   (the ECMAScript versions specify when the methods were added to Arrays â€“ Typed
   Arrays didnâ€™t exist in ECMAScript before ES6):

   -  ``TypedArray.prototype.at(index)`` :sup:`[R, ES2022]`
   -  ``TypedArray.prototype.copyWithin(target, start, end=this.length)`` :sup:`[W,
      ES6]`
   -  ``TypedArray.prototype.entries()`` :sup:`[R, ES6]`
   -  ``TypedArray.prototype.every(predicate, thisArg?)`` :sup:`[R, ES5]`
   -  ``TypedArray.prototype.fill(start=0, end=this.length)`` :sup:`[W, ES6]`
   -  ``TypedArray.prototype.filter(predicate, thisArg?)`` :sup:`[R, ES5]`
   -  ``TypedArray.prototype.find(predicate, thisArg?)`` :sup:`[R, ES6]`
   -  ``TypedArray.prototype.findIndex(predicate, thisArg?)`` :sup:`[R, ES6]`
   -  ``TypedArray.prototype.findLast(predicate, thisArg?)`` :sup:`[R, ES2023]`
   -  ``TypedArray.prototype.findLastIndex(predicate, thisArg?)`` :sup:`[R,
      ES2023]`
   -  ``TypedArray.prototype.forEach(callback)`` :sup:`[R, ES5]`
   -  ``TypedArray.prototype.includes(searchElement, fromIndex)`` :sup:`[R,
      ES2016]`
   -  ``TypedArray.prototype.indexOf(searchElement, fromIndex)`` :sup:`[R, ES5]`
   -  ``TypedArray.prototype.join(separator = ',')`` :sup:`[R, ES1]`
   -  ``TypedArray.prototype.keys()`` :sup:`[R, ES6]`
   -  ``TypedArray.prototype.lastIndexOf(searchElement, fromIndex)`` :sup:`[R,
      ES5]`
   -  ``TypedArray.prototype.map(callback, thisArg?)`` :sup:`[R, ES5]`
   -  ``TypedArray.prototype.reduce(callback, initialValue?)`` :sup:`[R, ES5]`
   -  ``TypedArray.prototype.reduceRight(callback, initialValue?)`` :sup:`[R, ES5]`
   -  ``TypedArray.prototype.reverse()`` :sup:`[W, ES1]`
   -  ``TypedArray.prototype.slice(start?, end?)`` :sup:`[R, ES3]`
   -  ``TypedArray.prototype.some(predicate, thisArg?)`` :sup:`[R, ES5]`
   -  ``TypedArray.prototype.sort(compareFunc?)`` :sup:`[W, ES1]`
   -  ``TypedArray.prototype.toLocaleString()`` :sup:`[R, ES3]`
   -  ``TypedArray.prototype.toReversed()`` :sup:`[R, ES2023]`
   -  ``TypedArray.prototype.toSorted(compareFunc?)`` :sup:`[R, ES2023]`
   -  ``TypedArray.prototype.toSpliced(start?, deleteCount?, ...items)`` :sup:`[R,
      ES2023]`
   -  ``TypedArray.prototype.toString()`` :sup:`[R, ES1]`
   -  ``TypedArray.prototype.values()`` :sup:`[R, ES6]`
   -  ``TypedArray.prototype.with(index, value)`` :sup:`[R, ES2023]`

   For details on how these methods work, see `â€œQuick reference: ``Array``\ â€
   (Â§33.17) <#quickref-Array>`__.



.. _new-elementtype-array:

34.10.3â€ƒ``new Â«ElementTypeÂ»Array()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Each Typed Array constructor has a name that follows the pattern
   ``Â«ElementTypeÂ»Array``, where ``Â«ElementTypeÂ»`` is one of the element types
   listed in `Table 34.1 <#tbl:typed-array-element-types>`__. That means there are
   11 constructors for Typed Arrays:

   -  ``Float32Array``, ``Float64Array``
   -  ``Int8Array``, ``Int16Array``, ``Int32Array``

      -  ``BigInt64Array``

   -  ``Uint8Array``, ``Uint8ClampedArray``, ``Uint16Array``, ``Uint32Array``

      -  ``BigUint64Array``

   Each constructor has several *overloaded* versions â€“ it behaves differently
   depending on how many arguments it receives and what their types are:

   -  ``new Â«ElementTypeÂ»Array(length=0)``

      Creates a new ``Â«ElementTypeÂ»Array`` with the given ``length`` and the
      appropriate buffer. The bufferâ€™s size in bytes is:

      .. code:: javascript

         length * Â«ElementTypeÂ»Array.BYTES_PER_ELEMENT

   -  ``new Â«ElementTypeÂ»Array(source: TypedArray)``

      Creates a new instance of ``Â«ElementTypeÂ»Array`` whose elements have the same
      values as the elements of ``source``, but coerced to ``ElementType``.

   -  ``new Â«ElementTypeÂ»Array(source: Iterable<number>)``

      -  ``BigInt64Array``, ``BigUint64Array``: ``bigint`` instead of ``number``

      -  Creates a new instance of ``Â«ElementTypeÂ»Array`` whose elements have the
         same values as the items of ``source``, but coerced to ``ElementType``.
         For more information on iterables, see `â€œSynchronous iterationâ€
         (Â§32) <#ch_sync-iteration>`__.

   -  ``new Â«ElementTypeÂ»Array(source: ArrayLike<number>)``

      -  ``BigInt64Array``, ``BigUint64Array``: ``bigint`` instead of ``number``

      -  Creates a new instance of ``Â«ElementTypeÂ»Array`` whose elements have the
         same values as the elements of ``source``, but coerced to ``ElementType``.
         For more information on Array-like objects, see `â€œArray-like objectsâ€
         (Â§33.5) <#array-like-objects>`__.

   -  ``new Â«ElementTypeÂ»Array(buffer: ArrayBuffer, byteOffset=0, length=0)``

      Creates a new ``Â«ElementTypeÂ»Array`` whose buffer is ``buffer``. It starts
      accessing the buffer at the given ``byteOffset`` and will have the given
      ``length``. Note that ``length`` counts elements of the Typed Array (with 1â€“8
      bytes each), not bytes.



.. _elementtype-array:

34.10.4â€ƒ``Â«ElementTypeÂ»Array.*``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Â«ElementTypeÂ»Array.BYTES_PER_ELEMENT: number``

      Counts how many bytes are needed to store a single element:

      .. code:: javascript
         :name: language-node-repl

         > Uint8Array.BYTES_PER_ELEMENT
         1
         > Int16Array.BYTES_PER_ELEMENT
         2
         > Float64Array.BYTES_PER_ELEMENT
         8



.. _elementtype-array-prototype:

34.10.5â€ƒ``Â«ElementTypeÂ»Array.prototype.*``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Â«ElementTypeÂ»Array.prototype.BYTES_PER_ELEMENT: number``

      The same as ``Â«ElementTypeÂ»Array.BYTES_PER_ELEMENT``.

34.11â€ƒQuick reference: DataViews
---------------------------------

34.11.1â€ƒ``new DataView()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``new DataView(arrayBuffer, byteOffset?, byteLength?)`` :sup:`[ES6]`

      Creates a new DataView whose data is stored in the ArrayBuffer ``buffer``. By
      default, the new DataView can access all of ``buffer``. The last two
      parameters allow us to change that.



.. _dataview-prototype:

34.11.2â€ƒ``DataView.prototype.*``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In the remainder of this section, ``Â«ElementTypeÂ»`` refers to either:

   -  ``Int8``, ``Int16``, ``Int32``, ``BigInt64``
   -  ``Uint8``, ``Uint16``, ``Uint32``, ``BigUint64``
   -  ``Float32``, ``Float64``

   These are the properties of ``DataView.prototype``:

   -  ``get DataView.prototype.buffer`` :sup:`[ES6]`

      Returns the ArrayBuffer of this DataView.

   -  ``get DataView.prototype.byteLength`` :sup:`[ES6]`

      Returns how many bytes can be accessed by this DataView.

   -  ``get DataView.prototype.byteOffset`` :sup:`[ES6]`

      Returns at which offset this DataView starts accessing the bytes in its
      buffer.

   -  ``DataView.prototype.getÂ«ElementTypeÂ»(byteOffset, littleEndian=false)``
      :sup:`[ES6]`

      Returns:

      -  ``BigInt64``, ``BigUint64``: ``bigint``
      -  All other element types: ``number``

      Reads a value from the buffer of this DataView.

   -  ``DataView.prototype.setÂ«ElementTypeÂ»(byteOffset, value, littleEndian=false)``
      :sup:`[ES6]`

      Type of ``value``:

      -  ``BigInt64``, ``BigUint64``: ``bigint``
      -  All other element types: ``number``

      Writes ``value`` to the buffer of this DataView.

   `Comments <https://github.com/rauschma/exploring-js/issues/45>`__


.. _ch_maps:

35â€ƒMaps (``Map``) [ES6]
========================

   #. `35.1â€ƒUsing Maps <#using-maps>`__

      #. `35.1.1â€ƒCreating Maps <#creating-maps>`__
      #. `35.1.2â€ƒCopying Maps <#copying-maps>`__
      #. `35.1.3â€ƒWorking with single entries <#working-with-single-entries>`__
      #. `35.1.4â€ƒDetermining the size of a Map and clearing it <#determining-the-size-of-a-map-and-clearing-it>`__
      #. `35.1.5â€ƒGetting the keys and values of a Map <#getting-the-keys-and-values-of-a-map>`__
      #. `35.1.6â€ƒGetting the entries of a Map <#getting-the-entries-of-a-map>`__
      #. `35.1.7â€ƒListed in insertion order: entries, keys, values <#listed-in-insertion-order-entries-keys-values>`__
      #. `35.1.8â€ƒConverting between Maps and Objects <#converting-maps-objects>`__

   #. `35.2â€ƒExample: Counting characters <#example-counting-characters>`__
   #. `35.3â€ƒA few more details about the keys of Maps (advanced) <#a-few-more-details-about-the-keys-of-maps>`__

      #. `35.3.1â€ƒWhat keys are considered equal? <#what-keys-are-considered-equal>`__

   #. `35.4â€ƒMissing Map operations <#missing-map-operations>`__

      #. `35.4.1â€ƒMapping and filtering Maps <#mapping-and-filtering-maps>`__
      #. `35.4.2â€ƒCombining Maps <#combining-maps>`__

   #. `35.5â€ƒQuick reference: Map <#quickref-maps>`__

      #. `35.5.1â€ƒnew Map() <#new-map>`__
      #. `35.5.2â€ƒMap.* <#map>`__
      #. `35.5.3â€ƒMap.prototype.*: handling single entries <#map-prototype-handling-single-entries>`__
      #. `35.5.4â€ƒMap.prototype: handling all entries <#map-prototype-handling-all-entries>`__
      #. `35.5.5â€ƒMap.prototype: iterating and looping <#map-prototype-iterating-and-looping>`__

   #. `35.6â€ƒFAQ: Maps <#faq-maps>`__

      #. `35.6.1â€ƒWhen should I use a Map, and when should I use an object? <#when-should-i-use-a-map-and-when-should-i-use-an-object>`__
      #. `35.6.2â€ƒWhen would I use an object as a key in a Map? <#when-would-i-use-an-object-as-a-key-in-a-map>`__
      #. `35.6.3â€ƒWhy do Maps preserve the insertion order of entries? <#why-do-maps-preserve-the-insertion-order-of-entries>`__
      #. `35.6.4â€ƒWhy do Maps have a .size, while Arrays have a .length? <#collection-size-vs-length>`__

   Before ES6, JavaScript didnâ€™t have a data structure for dictionaries and
   (ab)used objects as dictionaries from strings to arbitrary values. ES6 brought
   Maps, which are dictionaries from arbitrary values to arbitrary values.

35.1â€ƒUsing Maps
----------------

   An instance of ``Map`` maps keys to values. A single key-value mapping is called
   an *entry*.

35.1.1â€ƒCreating Maps
~~~~~~~~~~~~~~~~~~~~~

   There are three common ways of creating Maps.

   First, we can use the constructor without any parameters to create an empty Map:

   .. code:: javascript

      const emptyMap = new Map();
      assert.equal(emptyMap.size, 0);

   Second, we can pass an iterable (e.g., an Array) over key-value â€œpairsâ€ (Arrays
   with two elements) to the constructor:

   .. code:: javascript

      const map = new Map([
      [1, 'one'],
      [2, 'two'],
      [3, 'three'], // trailing comma is ignored
      ]);

   Third, the ``.set()`` method adds entries to a Map and is chainable:

   .. code:: javascript

      const map = new Map()
      .set(1, 'one')
      .set(2, 'two')
      .set(3, 'three');

35.1.2â€ƒCopying Maps
~~~~~~~~~~~~~~~~~~~~

   As weâ€™ll see later, Maps are also iterables over key-value pairs. Therefore, we
   can use the constructor to create a copy of a Map. That copy is *shallow*: keys
   and values are the same; they are not duplicated.

   .. code:: javascript

      const original = new Map()
      .set(false, 'no')
      .set(true, 'yes');

      const copy = new Map(original);
      assert.deepEqual(original, copy);

35.1.3â€ƒWorking with single entries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.set()`` and ``.get()`` are for writing and reading values (given keys).

   .. code:: javascript

      const map = new Map();

      map.set('foo', 123);

      assert.equal(map.get('foo'), 123);
      // Unknown key:
      assert.equal(map.get('bar'), undefined);
      // Use the default value '' if an entry is missing:
      assert.equal(map.get('bar') ?? '', '');

   ``.has()`` checks if a Map has an entry with a given key. ``.delete()`` removes
   entries.

   .. code:: javascript

      const map = new Map([['foo', 123]]);

      assert.equal(map.has('foo'), true);
      assert.equal(map.delete('foo'), true)
      assert.equal(map.has('foo'), false)

35.1.4â€ƒDetermining the size of a Map and clearing it
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.size`` contains the number of entries in a Map. ``.clear()`` removes all
   entries of a Map.

   .. code:: javascript

      const map = new Map()
      .set('foo', true)
      .set('bar', false)
      ;

      assert.equal(map.size, 2)
      map.clear();
      assert.equal(map.size, 0)

35.1.5â€ƒGetting the keys and values of a Map
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.keys()`` returns an iterable over the keys of a Map:

   .. code:: javascript

      const map = new Map()
      .set(false, 'no')
      .set(true, 'yes')
      ;

      for (const key of map.keys()) {
      console.log(key);
      }

   Output:

   ::

      false
      true

   We use `Array.from() <#Array.from>`__ to convert the iterable
   returned by ``.keys()`` to an Array:

   .. code:: javascript

      assert.deepEqual(
      Array.from(map.keys()),
      [false, true]);

   ``.values()`` works like ``.keys()``, but for values instead of keys.

35.1.6â€ƒGetting the entries of a Map
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.entries()`` returns an iterable over the entries of a Map:

   .. code:: javascript

      const map = new Map()
      .set(false, 'no')
      .set(true, 'yes')
      ;

      for (const entry of map.entries()) {
      console.log(entry);
      }

   Output:

   ::

      [ false, 'no' ]
      [ true, 'yes' ]

   `Array.from() <#Array.from>`__ converts the iterable returned
   by ``.entries()`` to an Array:

   .. code:: javascript

      assert.deepEqual(
      Array.from(map.entries()),
      [[false, 'no'], [true, 'yes']]);

   Map instances are also iterables over entries. In the following code, we use
   `destructuring <#ch_destructuring>`__ to access the keys
   and values of ``map``:

   .. code:: javascript

      for (const [key, value] of map) {
      console.log(key, value);
      }

   Output:

   ::

      false no
      true yes

35.1.7â€ƒListed in insertion order: entries, keys, values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Maps record in which order entries were created and honor that order when
   listing entries, keys, or values:

   .. code:: javascript

      const map1 = new Map([
      ['a', 1],
      ['b', 2],
      ]);
      assert.deepEqual(
      Array.from(map1.keys()), ['a', 'b']);

      const map2 = new Map([
      ['b', 2],
      ['a', 1],
      ]);
      assert.deepEqual(
      Array.from(map2.keys()), ['b', 'a']);



.. _converting-maps-objects:

35.1.8â€ƒConverting between Maps and Objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   As long as a Map only uses strings and symbols as keys, we can convert it to an
   object (via `Object.fromEntries() <#Object.fromEntries>`__):

   .. code:: javascript

      const map = new Map([
      ['a', 1],
      ['b', 2],
      ]);
      const obj = Object.fromEntries(map);
      assert.deepEqual(
      obj, {a: 1, b: 2});

   We can also convert an object to a Map with string or symbol keys (via
   `Object.entries() <#Object.entries>`__):

   .. code:: javascript

      const obj = {
      a: 1,
      b: 2,
      };
      const map = new Map(Object.entries(obj));
      assert.deepEqual(
      map, new Map([['a', 1], ['b', 2]]));

35.2â€ƒExample: Counting characters
----------------------------------

   ``countChars()`` returns a Map that maps characters to numbers of occurrences.

   .. code:: javascript

      function countChars(chars) {
      const charCounts = new Map();
      for (let ch of chars) {
         ch = ch.toLowerCase();
         const prevCount = charCounts.get(ch) ?? 0;
         charCounts.set(ch, prevCount+1);
      }
      return charCounts;
      }

      const result = countChars('AaBccc');
      assert.deepEqual(
      Array.from(result),
      [
         ['a', 2],
         ['b', 1],
         ['c', 3],
      ]
      );



.. _a-few-more-details-about-the-keys-of-maps:

35.3â€ƒA few more details about the keys of Maps (advanced)
----------------------------------------------------------

   Any value can be a key, even an object:

   .. code:: javascript

      const map = new Map();

      const KEY1 = {};
      const KEY2 = {};

      map.set(KEY1, 'hello');
      map.set(KEY2, 'world');

      assert.equal(map.get(KEY1), 'hello');
      assert.equal(map.get(KEY2), 'world');

35.3.1â€ƒWhat keys are considered equal?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Most Map operations need to check whether a value is equal to one of the keys.
   They do so via the internal operation
   `SameValueZero <https://tc39.es/ecma262/#sec-samevaluezero>`__, which works like
   ``===`` but considers ``NaN`` to be equal to itself.

   As a consequence, we can use ``NaN`` as a key in Maps, just like any other
   value:

   .. code:: javascript
      :name: language-node-repl

      > const map = new Map();

      > map.set(NaN, 123);
      > map.get(NaN)
      123

   Different objects are always considered to be different. That is something that
   canâ€™t be changed (yet â€“ configuring key equality is on TC39â€™s long-term
   roadmap).

   .. code:: javascript
      :name: language-node-repl

      > new Map().set({}, 1).set({}, 2).size
      2

35.4â€ƒMissing Map operations
----------------------------

35.4.1â€ƒMapping and filtering Maps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We can ``.map()`` and ``.filter()`` an Array, but there are no such operations
   for a Map. The solution is:

   #. Convert the Map to an Array of [key, value] pairs.
   #. Map or filter the Array.
   #. Convert the result back to a Map.

   Iâ€™ll use the following Map to demonstrate how that works.

   .. code:: javascript

      const originalMap = new Map()
      .set(1, 'a')
      .set(2, 'b')
      .set(3, 'c');

   Mapping ``originalMap``:

   .. code:: javascript

      const mappedMap = new Map( // step 3
      Array.from(originalMap) // step 1
      .map(([k, v]) => [k * 2, '_' + v]) // step 2
      );
      assert.deepEqual(
      Array.from(mappedMap),
      [[2,'_a'], [4,'_b'], [6,'_c']]);

   Filtering ``originalMap``:

   .. code:: javascript

      const filteredMap = new Map( // step 3
      Array.from(originalMap) // step 1
      .filter(([k, v]) => k < 3) // step 2
      );
      assert.deepEqual(Array.from(filteredMap),
      [[1,'a'], [2,'b']]);

   `Array.from() <#Array.from>`__ converts any iterable to an
   Array.

35.4.2â€ƒCombining Maps
~~~~~~~~~~~~~~~~~~~~~~

   There are no methods for combining Maps, which is why we must use a workaround
   that is similar to the one from the previous section.

   Letâ€™s combine the following two Maps:

   .. code:: javascript

      const map1 = new Map()
      .set(1, '1a')
      .set(2, '1b')
      .set(3, '1c')
      ;

      const map2 = new Map()
      .set(2, '2b')
      .set(3, '2c')
      .set(4, '2d')
      ;

   To combine ``map1`` and ``map2`` we create a new Array and spread (``...``) the
   entries (key-value pairs) of ``map1`` and ``map2`` into it (via iteration). Then
   we convert the Array back into a Map. All of that is done in line A:

   .. code:: javascript

      const combinedMap = new Map([...map1, ...map2]); // (A)
      assert.deepEqual(
      Array.from(combinedMap), // convert to Array for comparison
      [ [ 1, '1a' ],
         [ 2, '2b' ],
         [ 3, '2c' ],
         [ 4, '2d' ] ]
      );

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Combining twoÂ Maps**

      .. container:: boxout-vspace

      ``exercises/maps/combine_maps_test.mjs``



.. _quickref-maps:

35.5â€ƒQuick reference: ``Map``
------------------------------

   Note: For the sake of conciseness, Iâ€™m pretending that all keys have the same
   type ``K`` and that all values have the same type ``V``.

35.5.1â€ƒ``new Map()``
~~~~~~~~~~~~~~~~~~~~~

   -  ``new Map(entries?)`` :sup:`[ES6]`

      .. code:: javascript
         :name: language-ts

         new Map<K, V>(
         entries?: Iterable<[K, V]>
         )

      If we donâ€™t provide the parameter ``entries``, then an empty Map is created.
      If we do provide an iterable over [key, value] pairs, then those pairs are
      added as entries to the Map. For example:

      .. code:: javascript

         const map = new Map([
         [ 1, 'one' ],
         [ 2, 'two' ],
         [ 3, 'three' ], // trailing comma is ignored
         ]);



.. _map:

35.5.2â€ƒ``Map.*``
~~~~~~~~~~~~~~~~~

   -  ``Map.groupBy(items, computeGroupKey)`` :sup:`[ES2024]`

      .. code:: javascript
         :name: language-ts

         Map.groupBy<K, T>(
         items: Iterable<T>,
         computeGroupKey: (item: T, index: number) => K,
         ): Map<K, Array<T>>;

      -  The callback ``computeGroupKey`` returns a *group key* for each of the
         ``items``.
      -  The result of ``Map.groupBy()`` is a Map where:

         -  The key of each entry is a group key and
         -  its value is an Array with all items that have that group key.

      .. code:: javascript

         assert.deepEqual(
         Map.groupBy(
            ['orange', 'apricot', 'banana', 'apple', 'blueberry'],
            (str) => str[0] // compute group key
         ),
         new Map()
            .set('o', ['orange'])
            .set('a', ['apricot', 'apple'])
            .set('b', ['banana', 'blueberry'])
         );



.. _map-prototype-handling-single-entries:

35.5.3â€ƒ``Map.prototype.*``: handling single entries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Map.prototype.get(key)`` :sup:`[ES6]`

      Returns the ``value`` that ``key`` is mapped to in this Map. If there is no
      key ``key`` in this Map, ``undefined`` is returned.

      .. code:: javascript

         const map = new Map([[1, 'one'], [2, 'two']]);
         assert.equal(map.get(1), 'one');
         assert.equal(map.get(5), undefined);

   -  ``Map.prototype.set(key, value)`` :sup:`[ES6]`

      -  Maps the given key to the given value.
      -  If there is already an entry whose key is ``key``, it is updated.
         Otherwise, a new entry is created.
      -  This method returns ``this``, which means that we can chain it.

      .. code:: javascript

         const map = new Map([[1, 'one'], [2, 'two']]);
         map.set(1, 'ONE!') // update an existing entry
            .set(3, 'THREE!') // create a new entry
         ;
         assert.deepEqual(
         Array.from(map.entries()),
         [[1, 'ONE!'], [2, 'two'], [3, 'THREE!']]);

   -  ``Map.prototype.has(key)`` :sup:`[ES6]`

      Returns whether the given key exists in this Map.

      .. code:: javascript

         const map = new Map([[1, 'one'], [2, 'two']]);
         assert.equal(map.has(1), true); // key exists
         assert.equal(map.has(5), false); // key does not exist

   -  ``Map.prototype.delete(key)`` :sup:`[ES6]`

      If there is an entry whose key is ``key``, it is removed and ``true`` is
      returned. Otherwise, nothing happens and ``false`` is returned.

      .. code:: javascript

         const map = new Map([[1, 'one'], [2, 'two']]);
         assert.equal(map.delete(1), true);
         assert.equal(map.delete(5), false); // nothing happens
         assert.deepEqual(
         Array.from(map.entries()),
         [[2, 'two']]);



.. _map-prototype-handling-all-entries:

35.5.4â€ƒ``Map.prototype``: handling all entries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``get Map.prototype.size`` :sup:`[ES6]`

      Returns how many entries this Map has.

      .. code:: javascript

         const map = new Map([[1, 'one'], [2, 'two']]);
         assert.equal(map.size, 2);

   -  ``Map.prototype.clear()`` :sup:`[ES6]`

      Removes all entries from this Map.

      .. code:: javascript

         const map = new Map([[1, 'one'], [2, 'two']]);
         assert.equal(map.size, 2);
         map.clear();
         assert.equal(map.size, 0);



.. _map-prototype-iterating-and-looping:

35.5.5â€ƒ``Map.prototype``: iterating and looping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Both iterating and looping happen in the order in which entries were added to a
   Map.

   -  ``Map.prototype.entries()`` :sup:`[ES6]`

      Returns an iterable with one [key, value] pair for each entry in this Map.
      The pairs are Arrays of length 2.

      .. code:: javascript

         const map = new Map([[1, 'one'], [2, 'two']]);
         for (const entry of map.entries()) {
         console.log(entry);
         }

      Output:

      ::

         [ 1, 'one' ]
         [ 2, 'two' ]

   -  ``Map.prototype.forEach(callback, thisArg?)`` :sup:`[ES6]`

      .. code:: javascript
         :name: language-ts

         Map.prototype.forEach(
         callback: (value: V, key: K, theMap: Map<K,V>) => void,
         thisArg?: any
         ): void

      -  The first parameter is a callback that is invoked once for each entry in
         this Map.
      -  If ``thisArg`` is provided, ``this`` is set to it for each invocation.
         Otherwise, ``this`` is set to ``undefined``.

      .. code:: javascript

         const map = new Map([[1, 'one'], [2, 'two']]);
         map.forEach((value, key) => console.log(value, key));

      Output:

      ::

         one 1
         two 2

   -  ``Map.prototype.keys()`` :sup:`[ES6]`

      Returns an iterable over all keys in this Map.

      .. code:: javascript

         const map = new Map([[1, 'one'], [2, 'two']]);
         for (const key of map.keys()) {
         console.log(key);
         }

      Output:

      ::

         1
         2

   -  ``Map.prototype.values()`` :sup:`[ES6]`

      Returns an iterable over all values in this Map.

      .. code:: javascript

         const map = new Map([[1, 'one'], [2, 'two']]);
         for (const value of map.values()) {
         console.log(value);
         }

      Output:

      ::

         one
         two

   -  ``Map.prototype[Symbol.iterator]()`` :sup:`[ES6]`

      The default way of iterating over Maps. Same as ``.entries()``.

      .. code:: javascript

         const map = new Map([[1, 'one'], [2, 'two']]);
         for (const [key, value] of map) {
         console.log(key, value);
         }

      Output:

      ::

         1 one
         2 two

35.6â€ƒFAQ: Maps
---------------

35.6.1â€ƒWhen should I use a Map, and when should I use an object?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If we need a dictionary-like data structure with keys that are neither strings
   nor symbols, we have no choice: we must use a Map.

   If, however, our keys are either strings or symbols, we must decide whether or
   not to use an object. A rough general guideline is:

   -  Is there a fixed set of keys (known at development time)?

      Then use an object ``obj`` and access the values via fixed keys:

      .. code:: javascript

         const value = obj.key;

   -  Can the set of keys change at runtime?

      Then use a Map ``map`` and access the values via keys stored in variables:

      .. code:: javascript

         const theKey = 123;
         map.get(theKey);

35.6.2â€ƒWhen would I use an object as a key in a Map?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We normally want Map keys to be compared by value (two keys are considered equal
   if they have the same content). That excludes objects. However, there is one use
   case for objects as keys: externally attaching data to objects. But that use
   case is served better by WeakMaps, where entries donâ€™t prevent keys from being
   garbage-collected (for details, consult `the next
   chapter <#ch_weakmaps>`__).

35.6.3â€ƒWhy do Maps preserve the insertion order of entries?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In principle, Maps are unordered. The main reason for ordering entries is so
   that operations that list entries, keys, or values are deterministic. That
   helps, for example, with testing.



.. _collection-size-vs-length:

35.6.4â€ƒWhy do Maps have a ``.size``, while Arrays have a ``.length``?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In JavaScript, indexable sequences (such as Arrays and strings) have a
   ``.length``, while unindexed collections (such as Maps and Sets) have a
   ``.size``:

   -  ``.length`` is based on indices; it is always the highest index plus one.
   -  ``.size`` counts the number of elements in a collection.

   `Comments <https://github.com/rauschma/exploring-js/issues/35>`__



.. _ch_weakmaps:

36â€ƒWeakMaps (``WeakMap``) [ES6] (advanced)
===========================================

   #. `36.1â€ƒWeakMaps are black boxes <#weakmaps-as-black-boxes>`__
   #. `36.2â€ƒThe keys of a WeakMap are weakly held <#weakmap-keys-are-weakly-held>`__

      #. `36.2.1â€ƒWhat values can be keys in WeakMaps? <#weakmap-keys-criteria>`__
      #. `36.2.2â€ƒWhy are symbols as WeakMap keys interesting? [ES2023] <#why-are-symbols-as-weakmap-keys-interesting>`__

   #. `36.3â€ƒAttaching values to objects via WeakMaps <#attaching-values-to-objects-via-weakmaps>`__

      #. `36.3.1â€ƒExample: caching computed results <#example-caching-computed-results>`__
      #. `36.3.2â€ƒExample: keeping data of objects private <#private-data-in-weakmaps>`__

   #. `36.4â€ƒQuick reference: WeakMap <#quickref-weakmaps>`__

   WeakMaps are similar to Maps, with the following differences:

   -  They are black boxes, where a value can only be accessed if we have both the
      WeakMap and the key.
   -  The keys of a WeakMap are *weakly held*: If a value is a key in a WeakMap, it
      can still be garbage-collected. That enables two important use cases:

      -  We can attach data to value that we donâ€™t own â€“ e.g., to cache computed
         results.
      -  We can keep part of a value private, by not making the WeakMap public that
         contains that part.

   The next two sections examine in more detail what that means.



.. _weakmaps-as-black-boxes:

36.1â€ƒWeakMaps are black boxes
------------------------------

   It is impossible to inspect whatâ€™s inside a WeakMap:

   -  For example, we canâ€™t iterate or loop over keys, values or entries. And we
      canâ€™t compute the size.
   -  Additionally, we canâ€™t clear a WeakMap either â€“ we have to create a fresh
      instance.

   These restrictions enable a security property. Quoting `Mark
   Miller <https://github.com/tc39/notes/blob/main/meetings/2014-11/nov-19.md#412-should-weakmapweakset-have-a-clear-method-markm>`__:

      The mapping from weakmap/key pair value can only be observed or affected by
      someone who has both the weakmap and the key. With ``clear()``, someone with
      only the WeakMap wouldâ€™ve been able to affect the WeakMap-and-key-to-value
      mapping.



.. _weakmap-keys-are-weakly-held:

36.2â€ƒThe keys of a WeakMap are weakly held
-------------------------------------------

   The keys of a WeakMap are said to be *weakly held*: Normally if one object
   refers to another one, then the latter object canâ€™t be garbage-collected as long
   as the former exists. With a WeakMap, that is different: If an object is a key
   and not referred to elsewhere, it can be garbage-collected while the WeakMap
   still exists. That also leads to the corresponding entry being removed (but
   there is no way to observe that).



.. _weakmap-keys-criteria:

36.2.1â€ƒWhat values can be keys in WeakMaps?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Which values can be keys in WeakMaps is documented in the ECMAScript
   specification, via the specification function
   `CanBeHeldWeakly() <https://tc39.es/ecma262/#sec-canbeheldweakly>`__:

   -  Objects :sup:`[ES6]`
   -  Symbols :sup:`[ES2023]` â€“ as long as they are not registered (created via
      ``Symbol.for()``)

   All kinds of keys have one thing in common â€“ they have `identity
   semantics <#primitive-values-vs-objects>`__:

   #. When compared via ``===``, two keys are considered equal if they have the
      same identity â€“ they are *not* compared by comparing their contents (their
      values). That means there are never two or more different keys (â€œdifferentâ€
      meaning â€œat different locations in memoryâ€) that are all considered equal.
      Each key is unique.
   #. They are garbage-collected.

   Both conditions are important so that WeakMaps can dispose entries when keys
   disappear and no memory leaks.

   Letâ€™s look at examples:

   -  Non-registered symbols can be used as WeakMap keys: They are primitive but
      they are compared by identity and they are garbage-collected.

   -  The following two kinds of values cannot be used as WeakMap keys:

      -  Strings are garbage-collected but they are compared by value.
      -  `Registered
         symbols <https://exploringjs.com/es6/ch_symbols.html#sec_symbols-crossing-realms>`__
         are different from normal symbols â€“ they do not have identity semantics
         (`source <https://tc39.es/ecma262/#sec-canbeheldweakly>`__). This is how
         registered symbols are used:

      .. code:: javascript

         // Get a symbol from the registry
         const mySymbol = Symbol.for('key-in-symbol-registry');
         assert.equal(
         // Retrieve that symbol again
         Symbol.for('key-in-symbol-registry'),
         mySymbol
         );



.. _why-are-symbols-as-weakmap-keys-interesting:

36.2.2â€ƒWhy are symbols as WeakMap keys interesting? [ES2023]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Symbols as WeakMap keys solve important issues for upcoming JavaScript features:

   -  We can put references to objects inside `records and
      tuples <https://2ality.com/2020/05/records-tuples-first-look.html>`__.
   -  We can pass references to objects in and out of
      `ShadowRealms <https://2ality.com/2022/04/shadow-realms.html>`__.

36.3â€ƒAttaching values to objects via WeakMaps
----------------------------------------------

   We can use WeakMaps to externally attach values to objects â€“ for example:

   .. code:: javascript

      const wm = new WeakMap();
      {
      const obj = {};
      wm.set(obj, 'attachedValue'); // (A)
      }
      // (B)

   In line A, we attach a value to ``obj``. In line B, ``obj`` can already be
   garbage-collected, even though ``wm`` still exists. This technique of attaching
   a value to an object is equivalent to a property of that object being stored
   externally. If ``wm`` were a property, the previous code would look as follows:

   .. code:: javascript

      {
      const obj = {};
      obj.wm = 'attachedValue';
      }

36.3.1â€ƒExample: caching computed results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   With WeakMaps, we can associate previously computed results with objects without
   having to worry about memory management. The following function
   ``countOwnKeys()`` is an example: it caches previous results in the WeakMap
   ``cache``.

   .. code:: javascript

      const cache = new WeakMap();
      function countOwnKeys(obj) {
      if (cache.has(obj)) {
         return [cache.get(obj), 'cached'];
      } else {
         const count = Object.keys(obj).length;
         cache.set(obj, count);
         return [count, 'computed'];
      }
      }

   If we use this function with an object ``obj``, we can see that the result is
   only computed for the first invocation, while a cached value is used for the
   second invocation:

   .. code:: javascript
      :name: language-node-repl

      > const obj = { foo: 1, bar: 2};
      > countOwnKeys(obj)
      [2, 'computed']
      > countOwnKeys(obj)
      [2, 'cached']



.. _private-data-in-weakmaps:

36.3.2â€ƒExample: keeping data of objects private
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In the following code, the WeakMaps ``_counter`` and ``_action`` are used to
   store the values of virtual properties of instances of ``Countdown``:

   .. code:: javascript

      const _counter = new WeakMap();
      const _action = new WeakMap();

      class Countdown {
      constructor(counter, action) {
         _counter.set(this, counter);
         _action.set(this, action);
      }
      dec() {
         let counter = _counter.get(this);
         counter--;
         _counter.set(this, counter);
         if (counter === 0) {
            _action.get(this)();
         }
      }
      }

      // The two pseudo-properties are truly private:
      assert.deepEqual(
      Object.keys(new Countdown()),
      []);

   This is how ``Countdown`` is used:

   .. code:: javascript

      let invoked = false;

      const cd = new Countdown(3, () => invoked = true);

      cd.dec(); assert.equal(invoked, false);
      cd.dec(); assert.equal(invoked, false);
      cd.dec(); assert.equal(invoked, true);

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: WeakMaps for private data**

      .. container:: boxout-vspace

      ``exercises/weakmaps/weakmaps_private_data_test.mjs``



.. _quickref-weakmaps:

36.4â€ƒQuick reference: ``WeakMap``
----------------------------------

   The constructor and the four methods of ``WeakMap`` work the same as `their
   ``Map`` equivalents <#quickref-maps>`__:

   -  ``new WeakMap<K, V>(entries?: Iterable<[K, V]>)`` :sup:`[ES6]`
   -  ``WeakMap.prototype.delete(key: K) : boolean`` :sup:`[ES6]`
   -  ``WeakMap.prototype.get(key: K) : V`` :sup:`[ES6]`
   -  ``WeakMap.prototype.has(key: K) : boolean`` :sup:`[ES6]`
   -  ``WeakMap.prototype.set(key: K, value: V) : this`` :sup:`[ES6]`

   `Comments <https://github.com/rauschma/exploring-js/issues/36>`__



.. _ch_sets:

37â€ƒSets (``Set``) [ES6]
========================

   #. `37.1â€ƒUsing Sets <#using-sets>`__

      #. `37.1.1â€ƒCreating Sets <#creating-sets>`__
      #. `37.1.2â€ƒAdding, removing, checking membership <#adding-removing-checking-membership>`__
      #. `37.1.3â€ƒDetermining the size of a Set and clearing it <#determining-the-size-of-a-set-and-clearing-it>`__
      #. `37.1.4â€ƒIterating over Sets <#iterating-over-sets-1>`__

   #. `37.2â€ƒExamples of using Sets <#examples-of-using-sets>`__

      #. `37.2.1â€ƒRemoving duplicates from an Array <#removing-duplicates-from-an-array>`__
      #. `37.2.2â€ƒCreating a set of Unicode characters (code points) <#creating-a-set-of-unicode-characters-code-points>`__

   #. `37.3â€ƒWhat Set elements are considered equal? <#what-set-elements-are-considered-equal>`__
   #. `37.4â€ƒMissing Set operations <#missing-set-operations>`__

      #. `37.4.1â€ƒUnion (a âˆª b) <#union-a-b>`__
      #. `37.4.2â€ƒIntersection (a âˆ© b) <#intersection-a-b>`__
      #. `37.4.3â€ƒDifference (a \\ b) <#difference-a-b>`__
      #. `37.4.4â€ƒMapping over Sets <#mapping-over-sets>`__
      #. `37.4.5â€ƒFiltering Sets <#filtering-sets>`__

   #. `37.5â€ƒSets can use operations for iterables <#sets-can-use-operations-for-iterables>`__
   #. `37.6â€ƒQuick reference: Set <#quickref-sets>`__

      #. `37.6.1â€ƒnew Set() <#new-set>`__
      #. `37.6.2â€ƒSet.prototype.*: single Set elements <#set-prototype-single-set-elements>`__
      #. `37.6.3â€ƒSet<T>.prototype: all Set elements <#set-t-prototype-all-set-elements>`__
      #. `37.6.4â€ƒSet<T>.prototype: iterating and looping <#set-t-prototype-iterating-and-looping>`__
      #. `37.6.5â€ƒSymmetry with Map <#symmetry-with-map>`__

   #. `37.7â€ƒFAQ: Sets <#faq-sets>`__

      #. `37.7.1â€ƒWhy do Sets have a .size, while Arrays have a .length? <#why-do-sets-have-a-size-while-arrays-have-a-length>`__

   Before ES6, JavaScript didnâ€™t have a data structure for sets. Instead, two
   workarounds were used:

   -  The keys of an object were used as a set of strings.
   -  Arrays were used as sets of arbitrary values. The downside is that checking
      *membership* (if an Array contains a value) is slower.

   Since ES6, JavaScript has the data structure ``Set``, which can contain
   arbitrary values and performs membership checks quickly.

37.1â€ƒUsing Sets
----------------

37.1.1â€ƒCreating Sets
~~~~~~~~~~~~~~~~~~~~~

   There are three common ways of creating Sets.

   First, you can use the constructor without any parameters to create an empty
   Set:

   .. code:: javascript

      const emptySet = new Set();
      assert.equal(emptySet.size, 0);

   Second, you can pass an iterable (e.g., an Array) to the constructor. The
   iterated values become elements of the new Set:

   .. code:: javascript

      const set = new Set(['red', 'green', 'blue']);

   Third, the ``.add()`` method adds elements to a Set and is chainable:

   .. code:: javascript

      const set = new Set()
      .add('red')
      .add('green')
      .add('blue');

37.1.2â€ƒAdding, removing, checking membership
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.add()`` adds an element to a Set.

   .. code:: javascript

      const set = new Set();
      set.add('red');

   ``.has()`` checks if an element is a member of a Set.

   .. code:: javascript

      assert.equal(set.has('red'), true);

   ``.delete()`` removes an element from a Set.

   .. code:: javascript

      assert.equal(set.delete('red'), true); // there was a deletion
      assert.equal(set.has('red'), false);

37.1.3â€ƒDetermining the size of a Set and clearing it
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.size`` contains the number of elements in a Set.

   .. code:: javascript

      const set = new Set()
      .add('foo')
      .add('bar');
      assert.equal(set.size, 2)

   ``.clear()`` removes all elements of a Set.

   .. code:: javascript

      set.clear();
      assert.equal(set.size, 0)



.. _iterating-over-sets-1:

37.1.4â€ƒIterating over Sets
~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets are iterable and the ``for-of`` loop works as youâ€™d expect:

   .. code:: javascript

      const set = new Set(['red', 'green', 'blue']);
      for (const x of set) {
      console.log(x);
      }

   Output:

   ::

      red
      green
      blue

   As you can see, Sets preserve *insertion order*. That is, elements are always
   iterated over in the order in which they were added.

   Given that Sets are iterable, you can use
   `Array.from() <#Array.from>`__ to convert them to Arrays:

   .. code:: javascript

      const set = new Set(['red', 'green', 'blue']);
      const arr = Array.from(set); // ['red', 'green', 'blue']

37.2â€ƒExamples of using Sets
----------------------------

37.2.1â€ƒRemoving duplicates from an Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Converting an Array to a Set and back, removes duplicates from the Array:

   .. code:: javascript

      assert.deepEqual(
      Array.from(new Set([1, 2, 1, 2, 3, 3, 3])),
      [1, 2, 3]);

37.2.2â€ƒCreating a set of Unicode characters (code points)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Strings are iterable and can therefore be used as parameters for ``new Set()``:

   .. code:: javascript

      assert.deepEqual(
      new Set('abc'),
      new Set(['a', 'b', 'c']));

37.3â€ƒWhat Set elements are considered equal?
---------------------------------------------

   As with Map keys, Set elements are compared similarly to ``===``, with the
   exception of ``NaN`` being equal to itself.

   .. code:: javascript
      :name: language-node-repl

      > const set = new Set([NaN, NaN, NaN]);
      > set.size
      1
      > set.has(NaN)
      true

   As with ``===``, two different objects are never considered equal (and there is
   no way to change that at the moment):

   .. code:: javascript
      :name: language-node-repl

      > const set = new Set();

      > set.add({});
      > set.size
      1

      > set.add({});
      > set.size
      2

37.4â€ƒMissing Set operations
----------------------------

   Sets are missing several common operations. Such an operation can usually be
   implemented by:

   -  Converting the input Sets to Arrays by `spreading into Array
      literals <#spreading-into-array-literals>`__.
   -  Performing the operation on Arrays.
   -  Converting the result to a Set and returning it.

37.4.1â€ƒUnion (``a`` âˆª ``b``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computing the union of two Sets ``a`` and ``b`` means creating a Set that
   contains the elements of both ``a`` and ``b``.

   .. code:: javascript

      const a = new Set([1,2,3]);
      const b = new Set([4,3,2]);
      // Use spreading to concatenate two iterables
      const union = new Set([...a, ...b]);

      assert.deepEqual(Array.from(union), [1, 2, 3, 4]);

37.4.2â€ƒIntersection (``a`` âˆ© ``b``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computing the intersection of two Sets ``a`` and ``b`` means creating a Set that
   contains those elements of ``a`` that are also in ``b``.

   .. code:: javascript

      const a = new Set([1,2,3]);
      const b = new Set([4,3,2]);
      const intersection = new Set(
      Array.from(a).filter(x => b.has(x))
      );

      assert.deepEqual(
      Array.from(intersection), [2, 3]
      );

37.4.3â€ƒDifference (``a`` \\ ``b``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Computing the difference between two Sets ``a`` and ``b`` means creating a Set
   that contains those elements of ``a`` that are not in ``b``. This operation is
   also sometimes called *minus* (âˆ’).

   .. code:: javascript

      const a = new Set([1,2,3]);
      const b = new Set([4,3,2]);
      const difference = new Set(
      Array.from(a).filter(x => !b.has(x))
      );

      assert.deepEqual(
      Array.from(difference), [1]
      );

37.4.4â€ƒMapping over Sets
~~~~~~~~~~~~~~~~~~~~~~~~~

   Sets donâ€™t have a method ``.map()``. But we can borrow the one that Arrays have:

   .. code:: javascript

      const set = new Set([1, 2, 3]);
      const mappedSet = new Set(
      Array.from(set).map(x => x * 2)
      );

      // Convert mappedSet to an Array to check whatâ€™s inside it
      assert.deepEqual(
      Array.from(mappedSet), [2, 4, 6]
      );

37.4.5â€ƒFiltering Sets
~~~~~~~~~~~~~~~~~~~~~~

   We canâ€™t directly ``.filter()`` Sets, so we need to use the corresponding Array
   method:

   .. code:: javascript

      const set = new Set([1, 2, 3, 4, 5]);
      const filteredSet = new Set(
      Array.from(set).filter(x => (x % 2) === 0)
      );

      assert.deepEqual(
      Array.from(filteredSet), [2, 4]
      );

37.5â€ƒSets can use operations for iterables
-------------------------------------------

   Sets are iterable and therefore can use operations that accept iterables. These
   are described elsewhere:

   -  `â€œGrouping iterablesâ€
      (Â§32.5) <#grouping-sync-iterables>`__



.. _quickref-sets:

37.6â€ƒQuick reference: ``Set``
------------------------------

37.6.1â€ƒ``new Set()``
~~~~~~~~~~~~~~~~~~~~~

   -  ``new Set(iterable)`` :sup:`[ES6]`

      -  If you donâ€™t provide the parameter ``values``, then an empty Set is
         created.
      -  If you do, then the iterated values are added as elements to the Set.

      .. code:: javascript

         const set = new Set(['red', 'green', 'blue']);



.. _set-prototype-single-set-elements:

37.6.2â€ƒ``Set.prototype.*``: single Set elements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Set.prototype.add(value)`` :sup:`[ES6]`

      -  Adds ``value`` to this Set.
      -  This method returns ``this``, which means that it can be chained.

      .. code:: javascript

         const set = new Set(['red']);
         set.add('green').add('blue');
         assert.deepEqual(
         Array.from(set), ['red', 'green', 'blue']
         );

   -  ``Set.prototype.delete(value)`` :sup:`[ES6]`

      -  Removes ``value`` from this Set.
      -  Returns ``true`` if something was deleted and ``false``, otherwise.

      .. code:: javascript

         const set = new Set(['red', 'green', 'blue']);
         assert.equal(set.delete('red'), true); // there was a deletion
         assert.deepEqual(
         Array.from(set), ['green', 'blue']
         );

   -  ``Set.prototype.has(value)`` :sup:`[ES6]`

      Returns ``true`` if ``value`` is in this Set and ``false`` otherwise.

      .. code:: javascript

         const set = new Set(['red', 'green']);
         assert.equal(set.has('red'), true);
         assert.equal(set.has('blue'), false);



.. _set-t-prototype-all-set-elements:

37.6.3â€ƒ``Set<T>.prototype``: all Set elements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``get Set.prototype.size`` :sup:`[ES6]`

      Returns how many elements there are in this Set.

      .. code:: javascript

         const set = new Set(['red', 'green', 'blue']);
         assert.equal(set.size, 3);

   -  ``Set.prototype.clear()`` :sup:`[ES6]`

      Removes all elements from this Set.

      .. code:: javascript

         const set = new Set(['red', 'green', 'blue']);
         assert.equal(set.size, 3);
         set.clear();
         assert.equal(set.size, 0);



.. _set-t-prototype-iterating-and-looping:

37.6.4â€ƒ``Set<T>.prototype``: iterating and looping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Set.prototype.values()`` :sup:`[ES6]`

      Returns an iterable over all elements of this Set.

      .. code:: javascript

         const set = new Set(['red', 'green']);
         for (const x of set.values()) {
         console.log(x);
         }

      Output:

      ::

         red
         green

   -  ``Set.prototype[Symbol.iterator]()`` :sup:`[ES6]`

      Default way of iterating over Sets. Same as ``.values()``.

      .. code:: javascript

         const set = new Set(['red', 'green']);
         for (const x of set) {
         console.log(x);
         }

      Output:

      ::

         red
         green

   -  ``Set.prototype.forEach(callback, thisArg?)`` :sup:`[ES6]`

      .. code:: javascript
         :name: language-ts

         forEach(
         callback: (value: T, key: T, theSet: Set<T>) => void,
         thisArg?: any
         ): void

      Feeds each element of this Set to ``callback()``. ``value`` and ``key`` both
      contain the current element. This redundancy was introduced so that this
      ``callback`` has the same type signature as the ``callback`` of
      ``Map.prototype.forEach()``.

      You can specify the ``this`` of ``callback`` via ``thisArg``. If you omit it,
      ``this`` is ``undefined``.

      .. code:: javascript

         const set = new Set(['red', 'green']);
         set.forEach(x => console.log(x));

      Output:

      ::

         red
         green

37.6.5â€ƒSymmetry with ``Map``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following two methods mainly exist so that Sets and Maps have similar
   interfaces. Each Set element is handled as if it were a Map entry whose key and
   value are both the element.

   -  ``Set.prototype.entries(): Iterable<[T,T]>`` :sup:`[ES6]`
   -  ``Set.prototype.keys(): Iterable<T>`` :sup:`[ES6]`

   ``.entries()`` enables you to convert a Set to a Map:

   .. code:: javascript

      const set = new Set(['a', 'b', 'c']);
      const map = new Map(set.entries());
      assert.deepEqual(
      Array.from(map.entries()),
      [['a','a'], ['b','b'], ['c','c']]
      );

37.7â€ƒFAQ: Sets
---------------



.. _why-do-sets-have-a-size-while-arrays-have-a-length:

37.7.1â€ƒWhy do Sets have a ``.size``, while Arrays have a ``.length``?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The answer to this question is given in `â€œWhy do Maps have a ``.size``, while
   Arrays have a ``.length``?â€
   (Â§35.6.4) <#collection-size-vs-length>`__.

   `Comments <https://github.com/rauschma/exploring-js/issues/37>`__


.. _ch_weaksets:

38â€ƒWeakSets (``WeakSet``) [ES6] (advanced)
===========================================

   #. `38.1â€ƒExample: Marking objects as safe to use with a method <#example-marking-objects-as-safe-to-use-with-a-method>`__
   #. `38.2â€ƒWeakSet API <#weakset-api>`__

   WeakSets are similar to Sets, with the following differences:

   -  They can hold objects without preventing those objects from being
      garbage-collected.

   -  They are black boxes: we only get any data out of a WeakSet if we have both
      the WeakSet and a value. The only methods that are supported are ``.add()``,
      ``.delete()``, ``.has()``. Consult the section on `WeakMaps as black
      boxes <#weakmaps-as-black-boxes>`__ for an explanation of why
      WeakSets donâ€™t allow iteration, looping, and clearing.

   Given that we canâ€™t iterate over their elements, there are not that many use
   cases for WeakSets. They do enable us to mark objects.

38.1â€ƒExample: Marking objects as safe to use with a method
-----------------------------------------------------------

   The following code demonstrates how a class can ensure that its methods are only
   applied to instances that were created by it (based on `code by Domenic
   Denicola <https://esdiscuss.org/topic/actual-weakset-use-cases#content-1>`__):

   .. code:: javascript

      const instancesOfSafeClass = new WeakSet();

      class SafeClass {
      constructor() {
         instancesOfSafeClass.add(this);
      }

      method() {
         if (!instancesOfSafeClass.has(this)) {
            throw new TypeError('Incompatible object!');
         }
      }
      }

      const safeInstance = new SafeClass();
      safeInstance.method(); // works

      assert.throws(
      () => {
         const obj = {};
         SafeClass.prototype.method.call(obj); // throws an exception
      },
      TypeError
      );

38.2â€ƒWeakSet API
-----------------

   The constructor and the three methods of ``WeakSet`` work the same as `their
   ``Set`` equivalents <#quickref-sets>`__:

   -  ``new WeakSet<T>(values?: Iterable<T>)`` :sup:`[ES6]`
   -  ``.add(value: T): this`` :sup:`[ES6]`
   -  ``.delete(value: T): boolean`` :sup:`[ES6]`
   -  ``.has(value: T): boolean`` :sup:`[ES6]`

   `Comments <https://github.com/rauschma/exploring-js/issues/38>`__


.. _ch_destructuring:

39â€ƒDestructuring [ES6]
=======================

   #. `39.1â€ƒA first taste of destructuring <#a-first-taste-of-destructuring>`__
   #. `39.2â€ƒConstructing vs. extracting <#constructing-vs-extracting>`__
   #. `39.3â€ƒWhere can we destructure? <#where-can-we-destructure>`__
   #. `39.4â€ƒObject-destructuring <#object-destructuring>`__

      #. `39.4.1â€ƒProperty value shorthands <#property-value-shorthands>`__
      #. `39.4.2â€ƒRest properties <#rest-properties>`__
      #. `39.4.3â€ƒSyntax pitfall: assigning via object destructuring <#assigning-via-object-destructuring>`__

   #. `39.5â€ƒArray-destructuring <#array-destructuring>`__

      #. `39.5.1â€ƒArray-destructuring works with any iterable <#array-destructuring-works-with-any-iterable>`__
      #. `39.5.2â€ƒRest elements <#rest-elements>`__

   #. `39.6â€ƒExamples of destructuring <#examples-of-destructuring>`__

      #. `39.6.1â€ƒArray-destructuring: swapping variable values <#array-destructuring-swapping-variable-values>`__
      #. `39.6.2â€ƒArray-destructuring: operations that return Arrays <#array-destructuring-operations-that-return-arrays>`__
      #. `39.6.3â€ƒObject-destructuring: multiple return values <#object-destructuring-multiple-return-values>`__

   #. `39.7â€ƒWhat happens if a pattern part does not match anything? <#what-happens-if-a-pattern-part-does-not-match-anything>`__

      #. `39.7.1â€ƒObject-destructuring and missing properties <#object-destructuring-and-missing-properties>`__
      #. `39.7.2â€ƒArray-destructuring and missing elements <#array-destructuring-and-missing-elements>`__

   #. `39.8â€ƒWhat values canâ€™t be destructured? <#what-values-can-t-be-destructured>`__

      #. `39.8.1â€ƒYou canâ€™t object-destructure undefined and null <#you-can-t-object-destructure-undefined-and-null>`__
      #. `39.8.2â€ƒYou canâ€™t Array-destructure non-iterable values <#you-can-t-array-destructure-non-iterable-values>`__

   #. `39.9â€ƒ(Advanced) <#advanced-4>`__
   #. `39.10â€ƒDefault values <#default-values>`__

      #. `39.10.1â€ƒDefault values in Array-destructuring <#default-values-in-array-destructuring>`__
      #. `39.10.2â€ƒDefault values in object-destructuring <#default-values-in-object-destructuring>`__

   #. `39.11â€ƒParameter definitions are similar to destructuring <#parameter-definitions-are-similar-to-destructuring>`__
   #. `39.12â€ƒNested destructuring <#nested-destructuring>`__

39.1â€ƒA first taste of destructuring
------------------------------------

   With normal assignment, you extract one piece of data at a time â€“ for example:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      const x = arr[0]; // extract
      const y = arr[1]; // extract

   With destructuring, you can extract multiple pieces of data at the same time via
   patterns in locations that receive data. The left-hand side of ``=`` in the
   previous code is one such location. In the following code, the square brackets
   in line A are a destructuring pattern:

   .. code:: javascript

      const arr = ['a', 'b', 'c'];
      const [x, y] = arr; // (A)
      assert.equal(x, 'a');
      assert.equal(y, 'b');

   This code does the same as the previous code.

   Note that the pattern is â€œsmallerâ€ than the data: we are only extracting what we
   need.



.. _constructing-vs-extracting:

39.2â€ƒConstructing vs. extracting
---------------------------------

   In order to understand what destructuring is, consider that JavaScript has two
   kinds of operations that are opposites:

   -  You can *construct* compound data, for example, by setting properties and via
      object literals.
   -  You can *extract* data out of compound data, for example, by getting
      properties.

   Constructing data looks as follows:

   .. code:: javascript

      // Constructing: one property at a time
      const jane1 = {};
      jane1.first = 'Jane';
      jane1.last = 'Doe';

      // Constructing: multiple properties
      const jane2 = {
      first: 'Jane',
      last: 'Doe',
      };

      assert.deepEqual(jane1, jane2);

   Extracting data looks as follows:

   .. code:: javascript

      const jane = {
      first: 'Jane',
      last: 'Doe',
      };

      // Extracting: one property at a time
      const f1 = jane.first;
      const l1 = jane.last;
      assert.equal(f1, 'Jane');
      assert.equal(l1, 'Doe');

      // Extracting: multiple properties (NEW!)
      const {first: f2, last: l2} = jane; // (A)
      assert.equal(f2, 'Jane');
      assert.equal(l2, 'Doe');

   The operation in line A is new: we declare two variables ``f2`` and ``l2`` and
   initialize them via *destructuring* (multivalue extraction).

   The following part of line A is a *destructuring pattern*:

   .. code:: javascript

      {first: f2, last: l2}

   Destructuring patterns are syntactically similar to the literals that are used
   for multivalue construction. But they appear where data is received (e.g., at
   the left-hand sides of assignments), not where data is created (e.g., at the
   right-hand sides of assignments).

39.3â€ƒWhere can we destructure?
-------------------------------

   Destructuring patterns can be used at â€œdata sink locationsâ€ such as:

   -  Variable declarations:

      .. code:: javascript

         const [a] = ['x'];
         assert.equal(a, 'x');

         let [b] = ['y'];
         assert.equal(b, 'y');

   -  Assignments:

      .. code:: javascript

         let b;
         [b] = ['z'];
         assert.equal(b, 'z');

   -  Parameter definitions:

      .. code:: javascript

         const f = ([x]) => x;
         assert.equal(f(['a']), 'a');

   Note that variable declarations include ``const`` and ``let`` declarations in
   ``for-of`` loops:

   .. code:: javascript

      const arr = ['a', 'b'];
      for (const [index, element] of arr.entries()) {
         console.log(index, element);
      }

   Output:

   ::

      0 a
      1 b

   In the next two sections, weâ€™ll look deeper into the two kinds of destructuring:
   object-destructuring and Array-destructuring.

39.4â€ƒObject-destructuring
--------------------------

   *Object-destructuring* lets you batch-extract values of properties via patterns
   that look like object literals:

   .. code:: javascript

      const address = {
      street: 'Evergreen Terrace',
      number: '742',
      city: 'Springfield',
      state: 'NT',
      zip: '49007',
      };

      const { street: s, city: c } = address;
      assert.equal(s, 'Evergreen Terrace');
      assert.equal(c, 'Springfield');

   You can think of the pattern as a transparent sheet that you place over the
   data: the pattern key ``'street'`` has a match in the data. Therefore, the data
   value ``'Evergreen Terrace'`` is assigned to the pattern variable ``s``.

   You can also object-destructure primitive values:

   .. code:: javascript

      const {length: len} = 'abc';
      assert.equal(len, 3);

   And you can object-destructure Arrays:

   .. code:: javascript

      const {0:x, 2:y} = ['a', 'b', 'c'];
      assert.equal(x, 'a');
      assert.equal(y, 'c');

   Why does that work? `Array indices are also
   properties <#array-indices>`__.

39.4.1â€ƒProperty value shorthands
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Object literals support property value shorthands and so do object patterns:

   .. code:: javascript

      const { street, city } = address;
      assert.equal(street, 'Evergreen Terrace');
      assert.equal(city, 'Springfield');

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Object-destructuring**

      .. container:: boxout-vspace

      ``exercises/destructuring/object_destructuring_exrc.mjs``

39.4.2â€ƒRest properties
~~~~~~~~~~~~~~~~~~~~~~~

   In object literals, you can have spread properties. In object patterns, you can
   have rest properties (which must come last):

   .. code:: javascript

      const obj = { a: 1, b: 2, c: 3 };
      const { a: propValue, ...remaining } = obj; // (A)

      assert.equal(propValue, 1);
      assert.deepEqual(remaining, {b:2, c:3});

   A rest property variable, such as ``remaining`` (line A), is assigned an object
   with all data properties whose keys are not mentioned in the pattern.

   ``remaining`` can also be viewed as the result of non-destructively removing
   property ``a`` from ``obj``.



.. _assigning-via-object-destructuring:

39.4.3â€ƒSyntax pitfall: assigning via object destructuring
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If we object-destructure in an assignment, we are facing a pitfall caused by
   `syntactic ambiguity <#ambiguous-syntax>`__ â€“ you canâ€™t start a
   statement with a curly brace because then JavaScript thinks you are starting a
   block:

   .. code:: javascript

      let prop;
      assert.throws(
      () => eval("{prop} = { prop: 'hello' };"),
      {
         name: 'SyntaxError',
         message: "Unexpected token '='",
      });

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Why ``eval()``?**

      .. container:: boxout-vspace

      `eval() <#eval>`__ delays parsing (and
      therefore the ``SyntaxError``) until the callback of ``assert.throws()`` is
      executed. If we didnâ€™t use it, weâ€™d already get an error when this code is
      parsed and ``assert.throws()`` wouldnâ€™t even be executed.

   The workaround is to put the whole assignment in parentheses:

   .. code:: javascript

      let prop;
      ({prop} = { prop: 'hello' });
      assert.equal(prop, 'hello');

39.5â€ƒArray-destructuring
-------------------------

   *Array-destructuring* lets you batch-extract values of Array elements via
   patterns that look like Array literals:

   .. code:: javascript

      const [x, y] = ['a', 'b'];
      assert.equal(x, 'a');
      assert.equal(y, 'b');

   You can skip elements by mentioning holes inside Array patterns:

   .. code:: javascript

      const [, x, y] = ['a', 'b', 'c']; // (A)
      assert.equal(x, 'b');
      assert.equal(y, 'c');

   The first element of the Array pattern in line A is a hole, which is why the
   Array element at index 0 is ignored.

39.5.1â€ƒArray-destructuring works with any iterable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Array-destructuring can be applied to any value that is iterable, not just to
   Arrays:

   .. code:: javascript

      { // Sets are iterable
      const [a, b] = new Set().add('fee').add('fi').add('fo');
      assert.equal(a, 'fee');
      assert.equal(b, 'fi');
      }

      { // Maps are iterable
      const [a, b] = new Map().set('one', 1).set('two', 2);
      assert.deepEqual(
         a, ['one',1]
      );
      assert.deepEqual(
         b, ['two',2]
      );
      }

      { // Strings are iterable
      const [a, b] = 'hello';
      assert.equal(a, 'h');
      assert.equal(b, 'e');
      }

39.5.2â€ƒRest elements
~~~~~~~~~~~~~~~~~~~~~

   In Array literals, you can have spread elements. In Array patterns, you can have
   rest elements (which must come last):

   .. code:: javascript

      const [x, y, ...remaining] = ['a', 'b', 'c', 'd']; // (A)

      assert.equal(x, 'a');
      assert.equal(y, 'b');
      assert.deepEqual(remaining, ['c', 'd']);

   A rest element variable, such as ``remaining`` (line A), is assigned an Array
   with all elements of the destructured value that were not mentioned yet.

39.6â€ƒExamples of destructuring
-------------------------------

39.6.1â€ƒArray-destructuring: swapping variable values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   You can use Array-destructuring to swap the values of two variables without
   needing a temporary variable:

   .. code:: javascript

      let x = 'a';
      let y = 'b';

      [x,y] = [y,x]; // swap

      assert.equal(x, 'b');
      assert.equal(y, 'a');

39.6.2â€ƒArray-destructuring: operations that return Arrays
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Array-destructuring is useful when operations return Arrays, as does, for
   example, the regular expression method ``.exec()``:

   .. code:: javascript

      // Skip the element at index 0 (the whole match):
      const [, year, month, day] =
      /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/
      .exec('2999-12-31');

      assert.equal(year, '2999');
      assert.equal(month, '12');
      assert.equal(day, '31');

39.6.3â€ƒObject-destructuring: multiple return values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Destructuring is very useful if a function returns multiple values â€“ either
   packaged as an Array or packaged as an object.

   Consider a function ``findElement()`` that finds elements in an Array:

   .. code:: javascript

      findElement(array, (value, index) => Â«boolean expressionÂ»)

   Its second parameter is a function that receives the value and index of an
   element and returns a boolean indicating if this is the element the caller is
   looking for.

   We are now faced with a dilemma: Should ``findElement()`` return the value of
   the element it found or the index? One solution would be to create two separate
   functions, but that would result in duplicated code because both functions would
   be very similar.

   The following implementation avoids duplication by returning an object that
   contains both index and value of the element that is found:

   .. code:: javascript

      function findElement(arr, predicate) {
      for (let index=0; index < arr.length; index++) {
         const value = arr[index];
         if (predicate(value)) {
            // We found something:
            return { value, index };
         }
      }
      // We didnâ€™t find anything:
      return { value: undefined, index: -1 };
      }

   Destructuring helps us with processing the result of ``findElement()``:

   .. code:: javascript

      const arr = [7, 8, 6];

      const {value, index} = findElement(arr, x => x % 2 === 0);
      assert.equal(value, 8);
      assert.equal(index, 1);

   As we are working with property keys, the order in which we mention ``value``
   and ``index`` doesnâ€™t matter:

   .. code:: javascript

      const {index, value} = findElement(arr, x => x % 2 === 0);

   The kicker is that destructuring also serves us well if we are only interested
   in one of the two results:

   .. code:: javascript

      const arr = [7, 8, 6];

      const {value} = findElement(arr, x => x % 2 === 0);
      assert.equal(value, 8);

      const {index} = findElement(arr, x => x % 2 === 0);
      assert.equal(index, 1);

   All of these conveniences combined make this way of handling multiple return
   values quite versatile.

39.7â€ƒWhat happens if a pattern part does not match anything?
-------------------------------------------------------------

   What happens if there is no match for part of a pattern? The same thing that
   happens if you use non-batch operators: you get ``undefined``.

39.7.1â€ƒObject-destructuring and missing properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If a property in an object pattern has no match on the right-hand side, you get
   ``undefined``:

   .. code:: javascript

      const {prop: p} = {};
      assert.equal(p, undefined);

39.7.2â€ƒArray-destructuring and missing elements
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If an element in an Array pattern has no match on the right-hand side, you get
   ``undefined``:

   .. code:: javascript

      const [x] = [];
      assert.equal(x, undefined);



.. _what-values-can-t-be-destructured:

39.8â€ƒWhat values canâ€™t be destructured?
----------------------------------------



.. _you-can-t-object-destructure-undefined-and-null:

39.8.1â€ƒYou canâ€™t object-destructure ``undefined`` and ``null``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Object-destructuring only fails if the value to be destructured is either
   ``undefined`` or ``null``. That is, it fails whenever accessing a property via
   the dot operator would fail too.

   .. code:: javascript
      :name: language-node-repl

      > const {prop} = undefined
      TypeError: Cannot destructure property 'prop' of 'undefined'
      as it is undefined.

      > const {prop} = null
      TypeError: Cannot destructure property 'prop' of 'null'
      as it is null.



.. _you-can-t-array-destructure-non-iterable-values:

39.8.2â€ƒYou canâ€™t Array-destructure non-iterable values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Array-destructuring demands that the destructured value be iterable. Therefore,
   you canâ€™t Array-destructure ``undefined`` and ``null``. But you canâ€™t
   Array-destructure non-iterable objects either:

   .. code:: javascript
      :name: language-node-repl

      > const [x] = {}
      TypeError: {} is not iterable



.. _advanced-4:

39.9â€ƒ(Advanced)
----------------

   All of the remaining sections are advanced.

39.10â€ƒDefault values
---------------------

   Normally, if a pattern has no match, the corresponding variable is set to
   ``undefined``:

   .. code:: javascript

      const {prop: p} = {};
      assert.equal(p, undefined);

   If you want a different value to be used, you need to specify a *default value*
   (via ``=``):

   .. code:: javascript

      const {prop: p = 123} = {}; // (A)
      assert.equal(p, 123);

   In line A, we specify the default value for ``p`` to be ``123``. That default is
   used because the data that we are destructuring has no property named ``prop``.

39.10.1â€ƒDefault values in Array-destructuring
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Here, we have two default values that are assigned to the variables ``x`` and
   ``y`` because the corresponding elements donâ€™t exist in the Array that is
   destructured.

   .. code:: javascript

      const [x=1, y=2] = [];

      assert.equal(x, 1);
      assert.equal(y, 2);

   The default value for the first element of the Array pattern is ``1``; the
   default value for the second element is ``2``.

39.10.2â€ƒDefault values in object-destructuring
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   You can also specify default values for object-destructuring:

   .. code:: javascript

      const {first: f='', last: l=''} = {};
      assert.equal(f, '');
      assert.equal(l, '');

   Neither property key ``first`` nor property key ``last`` exist in the object
   that is destructured. Therefore, the default values are used.

   With property value shorthands, this code becomes simpler:

   .. code:: javascript

      const {first='', last=''} = {};
      assert.equal(first, '');
      assert.equal(last, '');

39.11â€ƒParameter definitions are similar to destructuring
---------------------------------------------------------

   Considering what we have learned in this chapter, parameter definitions have
   much in common with an Array pattern (rest elements, default values, etc.). In
   fact, the following two function declarations are equivalent:

   .. code:: javascript

      function f1(Â«pattern1Â», Â«pattern2Â») {
      // Â·Â·Â·
      }

      function f2(...args) {
      const [Â«pattern1Â», Â«pattern2Â»] = args;
      // Â·Â·Â·
      }

39.12â€ƒNested destructuring
---------------------------

   Until now, we have only used variables as *assignment targets* (data sinks)
   inside destructuring patterns. But you can also use patterns as assignment
   targets, which enables you to nest patterns to arbitrary depths:

   .. code:: javascript

      const arr = [
      { first: 'Jane', last: 'Bond' },
      { first: 'Lars', last: 'Croft' },
      ];
      const [, {first}] = arr; // (A)
      assert.equal(first, 'Lars');

   Inside the Array pattern in line A, there is a nested object pattern at index 1.

   Nested patterns can become difficult to understand, so they are best used in
   moderation.

   `Comments <https://github.com/rauschma/exploring-js/issues/25>`__



.. _ch_sync-generators:

40â€ƒSynchronous generators [ES6] (advanced)
===========================================

   #. `40.1â€ƒWhat are synchronous generators? <#what-are-synchronous-generators>`__

      #. `40.1.1â€ƒGenerator functions return iterables and fill them via yield <#generator-functions-return-iterables-and-fill-them-via-yield>`__
      #. `40.1.2â€ƒyield pauses a generator function <#yield-pauses-a-generator-function>`__
      #. `40.1.3â€ƒWhy does yield pause execution? <#why-does-yield-pause-execution>`__
      #. `40.1.4â€ƒExample: Mapping over iterables <#example-mapping-over-iterables>`__

   #. `40.2â€ƒCalling generators from generators (advanced) <#calling-generators-from-generators>`__

      #. `40.2.1â€ƒCalling generators via yield* <#calling-generators-via-yield>`__
      #. `40.2.2â€ƒExample: Iterating over a tree <#example-iterating-over-a-tree>`__

   #. `40.3â€ƒBackground: external iteration vs. internal iteration <#external-iteration-internal-iteration>`__
   #. `40.4â€ƒUse case for generators: reusing traversals <#reusing-traversals>`__

      #. `40.4.1â€ƒThe traversal to reuse <#the-traversal-to-reuse>`__
      #. `40.4.2â€ƒInternal iteration (push) <#internal-iteration-example>`__
      #. `40.4.3â€ƒExternal iteration (pull) <#external-iteration-example>`__

   #. `40.5â€ƒAdvanced features of generators <#advanced-features-of-generators>`__

40.1â€ƒWhat are synchronous generators?
--------------------------------------

   Synchronous generators are special versions of function definitions and method
   definitions that always return synchronous iterables:

   .. code:: javascript

      // Generator function declaration
      function* genFunc1() { /*Â·Â·Â·*/ }

      // Generator function expression
      const genFunc2 = function* () { /*Â·Â·Â·*/ };

      // Generator method definition in an object literal
      const obj = {
      * generatorMethod() {
         // Â·Â·Â·
      }
      };

      // Generator method definition in a class definition
      // (class declaration or class expression)
      class MyClass {
      * generatorMethod() {
         // Â·Â·Â·
      }
      }

   Asterisks (``*``) mark functions and methods as generators:

   -  Functions: The pseudo-keyword ``function*`` is a combination of the keyword
      ``function`` and an asterisk.
   -  Methods: The ``*`` is a modifier (similar to ``static`` and ``get``).

40.1.1â€ƒGenerator functions return iterables and fill them via ``yield``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If we call a generator function, it returns an iterable (actually, an iterator
   that is also iterable). The generator fills that iterable via the ``yield``
   operator:

   .. code:: javascript

      function* genFunc1() {
      yield 'a';
      yield 'b';
      }

      const iterable = genFunc1();
      // Convert the iterable to an Array, to check whatâ€™s inside:
      assert.deepEqual(
      Array.from(iterable), ['a', 'b']
      );

      // We can also use a for-of loop
      for (const x of genFunc1()) {
      console.log(x);
      }

   Output:

   ::

      a
      b

40.1.2â€ƒ``yield`` pauses a generator function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Using a generator function involves the following steps:

   -  Function-calling it returns an iterator ``iter`` (that is also an iterable).
   -  Iterating over ``iter`` repeatedly invokes ``iter.next()``. Each time, we
      jump into the body of the generator function until there is a ``yield`` that
      returns a value.

   Therefore, ``yield`` does more than just add values to iterables â€“ it also
   pauses and exits the generator function:

   -  Like ``return``, a ``yield`` exits the body of the function and returns a
      value (to/via ``.next()``).
   -  Unlike ``return``, if we repeat the invocation (of ``.next()``), execution
      resumes directly after the ``yield``.

   Letâ€™s examine what that means via the following generator function.

   .. code:: javascript

      let location = 0;
      function* genFunc2() {
      location = 1; yield 'a';
      location = 2; yield 'b';
      location = 3;
      }

   In order to use ``genFunc2()``, we must first create the iterator/iterable
   ``iter``. ``genFunc2()`` is now paused â€œbeforeâ€ its body.

   .. code:: javascript

      const iter = genFunc2();
      // genFunc2() is now paused â€œbeforeâ€ its body:
      assert.equal(location, 0);

   ``iter`` implements `the iteration
   protocol <#ch_sync-iteration>`__. Therefore, we control
   the execution of ``genFunc2()`` via ``iter.next()``. Calling that method resumes
   the paused ``genFunc2()`` and executes it until there is a ``yield``. Then
   execution pauses and ``.next()`` returns the operand of the ``yield``:

   .. code:: javascript

      assert.deepEqual(
      iter.next(), {value: 'a', done: false});
      // genFunc2() is now paused directly after the first `yield`:
      assert.equal(location, 1);

   Note that the yielded value ``'a'`` is wrapped in an object, which is how
   iterators always deliver their values.

   We call ``iter.next()`` again and execution continues where we previously
   paused. Once we encounter the second ``yield``, ``genFunc2()`` is paused and
   ``.next()`` returns the yielded value ``'b'``.

   .. code:: javascript

      assert.deepEqual(
      iter.next(), {value: 'b', done: false});
      // genFunc2() is now paused directly after the second `yield`:
      assert.equal(location, 2);

   We call ``iter.next()`` one more time and execution continues until it leaves
   the body of ``genFunc2()``:

   .. code:: javascript

      assert.deepEqual(
      iter.next(), {value: undefined, done: true});
      // We have reached the end of genFunc2():
      assert.equal(location, 3);

   This time, property ``.done`` of the result of ``.next()`` is ``true``, which
   means that the iterator is finished.

40.1.3â€ƒWhy does ``yield`` pause execution?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   What are the benefits of ``yield`` pausing execution? Why doesnâ€™t it simply work
   like the Array method ``.push()`` and fill the iterable with values without
   pausing?

   Due to pausing, generators provide many of the features of *coroutines* (think
   processes that are multitasked cooperatively). For example, when we ask for the
   next value of an iterable, that value is computed *lazily* (on demand). The
   following two generator functions demonstrate what that means.

   .. code:: javascript

      /**
      * Returns an iterable over lines
      */
      function* genLines() {
      yield 'A line';
      yield 'Another line';
      yield 'Last line';
      }

      /**
      * Input: iterable over lines
      * Output: iterable over numbered lines
      */
      function* numberLines(lineIterable) {
      let lineNumber = 1;
      for (const line of lineIterable) { // input
         yield lineNumber + ': ' + line; // output
         lineNumber++;
      }
      }

   Note that the ``yield`` in ``numberLines()`` appears inside a ``for-of`` loop.
   ``yield`` can be used inside loops, but not inside callbacks (more on that
   later).

   Letâ€™s combine both generators to produce the iterable ``numberedLines``:

   .. code:: javascript

      const numberedLines = numberLines(genLines());
      assert.deepEqual(
      numberedLines.next(), {value: '1: A line', done: false});
      assert.deepEqual(
      numberedLines.next(), {value: '2: Another line', done: false});

   The key benefit of using generators here is that everything works incrementally:
   via ``numberedLines.next()``, we ask ``numberLines()`` for only a single
   numbered line. In turn, it asks ``genLines()`` for only a single unnumbered
   line.

   This incrementalism continues to work if, for example, ``genLines()`` reads its
   lines from a large text file: If we ask ``numberLines()`` for a numbered line,
   we get one as soon as ``genLines()`` has read its first line from the text file.

   Without generators, ``genLines()`` would first read all lines and return them.
   Then ``numberLines()`` would number all lines and return them. We therefore have
   to wait much longer until we get the first numbered line.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Turning a normal function into a generator**

      .. container:: boxout-vspace

      ``exercises/sync-generators/fib_seq_test.mjs``

40.1.4â€ƒExample: Mapping over iterables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following function ``mapIter()`` is similar to the Array method ``.map()``,
   but it returns an iterable, not an Array, and produces its results on demand.

   .. code:: javascript

      function* mapIter(iterable, func) {
      let index = 0;
      for (const x of iterable) {
         yield func(x, index);
         index++;
      }
      }

      const iterable = mapIter(['a', 'b'], x => x + x);
      assert.deepEqual(
      Array.from(iterable), ['aa', 'bb']
      );

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Filtering iterables**

      .. container:: boxout-vspace

      ``exercises/sync-generators/filter_iter_gen_test.mjs``



.. _calling-generators-from-generators:

40.2â€ƒCalling generators from generators (advanced)
---------------------------------------------------

40.2.1â€ƒCalling generators via ``yield*``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``yield`` only works directly inside generators â€“ so far we havenâ€™t seen a way
   of delegating yielding to another function or method.

   Letâ€™s first examine what does *not* work: in the following example, weâ€™d like
   ``foo()`` to call ``bar()``, so that the latter yields two values for the
   former. Alas, a naive approach fails:

   .. code:: javascript

      function* bar() {
      yield 'a';
      yield 'b';
      }
      function* foo() {
      // Nothing happens if we call `bar()`:
      bar();
      }
      assert.deepEqual(
      Array.from(foo()), []
      );

   Why doesnâ€™t this work? The function call ``bar()`` returns an iterable, which we
   ignore.

   What we want is for ``foo()`` to yield everything that is yielded by ``bar()``.
   Thatâ€™s what the ``yield*`` operator does:

   .. code:: javascript

      function* bar() {
      yield 'a';
      yield 'b';
      }
      function* foo() {
      yield* bar();
      }
      assert.deepEqual(
      Array.from(foo()), ['a', 'b']
      );

   In other words, the previous ``foo()`` is roughly equivalent to:

   .. code:: javascript

      function* foo() {
      for (const x of bar()) {
         yield x;
      }
      }

   Note that ``yield*`` works with any iterable:

   .. code:: javascript

      function* gen() {
      yield* [1, 2];
      }
      assert.deepEqual(
      Array.from(gen()), [1, 2]
      );

40.2.2â€ƒExample: Iterating over a tree
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``yield*`` lets us make recursive calls in generators, which is useful when
   iterating over recursive data structures such as trees. Take, for example, the
   following data structure for binary trees.

   .. code:: javascript

      class BinaryTree {
      constructor(value, left=null, right=null) {
         this.value = value;
         this.left = left;
         this.right = right;
      }

      /** Prefix iteration: parent before children */
      * [Symbol.iterator]() {
         yield this.value;
         if (this.left) {
            // Same as yield* this.left[Symbol.iterator]()
            yield* this.left;
         }
         if (this.right) {
            yield* this.right;
         }
      }
      }

   Method ``[Symbol.iterator]()`` adds support for the iteration protocol, which
   means that we can use a ``for-of`` loop to iterate over an instance of
   ``BinaryTree``:

   .. code:: javascript

      const tree = new BinaryTree('a',
      new BinaryTree('b',
         new BinaryTree('c'),
         new BinaryTree('d')),
      new BinaryTree('e'));

      for (const x of tree) {
      console.log(x);
      }

   Output:

   ::

      a
      b
      c
      d
      e

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Iterating over a nested Array**

      .. container:: boxout-vspace

      ``exercises/sync-generators/iter_nested_arrays_test.mjs``



.. _external-iteration-internal-iteration:

40.3â€ƒBackground: external iteration vs. internal iteration
-----------------------------------------------------------

   In preparation for the next section, we need to learn about two different styles
   of iterating over the values â€œinsideâ€ an object:

   -  External iteration (pull): Your code asks the object for the values via an
      iteration protocol. For example, the ``for-of`` loop is based on JavaScriptâ€™s
      iteration protocol:

      .. code:: javascript

         for (const x of ['a', 'b']) {
         console.log(x);
         }

      Output:

      ::

         a
         b

   -  Internal iteration (push): We pass a callback function to a method of the
      object and the method feeds the values to the callback. For example, Arrays
      have the method ``.forEach()``:

      .. code:: javascript

         ['a', 'b'].forEach((x) => {
         console.log(x);
         });

      Output:

      ::

         a
         b

   The next section has examples for both styles of iteration.



.. _reusing-traversals:

40.4â€ƒUse case for generators: reusing traversals
-------------------------------------------------

   One important use case for generators is extracting and reusing traversals.

40.4.1â€ƒThe traversal to reuse
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   As an example, consider the following function that traverses a tree of files
   and logs their paths (it uses `the Node.js
   API <https://nodejs.org/docs/latest/api/>`__ for doing so):

   .. code:: javascript

      function logPaths(dir) {
      for (const fileName of fs.readdirSync(dir)) {
         const filePath = path.join(dir, fileName);
         console.log(filePath);
         const stats = fs.statSync(filePath);
         if (stats.isDirectory()) {
            logPaths(filePath); // recursive call
         }
      }
      }

   Consider the following directory:

   .. code:: language-txt

      mydir/
      a.txt
      b.txt
      subdir/
         c.txt

   Letâ€™s log the paths inside ``mydir/``:

   .. code:: javascript

      logPaths('mydir');

   Output:

   ::

      mydir/a.txt
      mydir/b.txt
      mydir/subdir
      mydir/subdir/c.txt

   How can we reuse this traversal and do something other than logging the paths?



.. _internal-iteration-example:

40.4.2â€ƒInternal iteration (push)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   One way of reusing traversal code is via *internal iteration*: Each traversed
   value is passed to a callback (line A).

   .. code:: javascript

      function visitPaths(dir, callback) {
      for (const fileName of fs.readdirSync(dir)) {
         const filePath = path.join(dir, fileName);
         callback(filePath); // (A)
         const stats = fs.statSync(filePath);
         if (stats.isDirectory()) {
            visitPaths(filePath, callback);
         }
      }
      }
      const paths = [];
      visitPaths('mydir', p => paths.push(p));
      assert.deepEqual(
      paths,
      [
         'mydir/a.txt',
         'mydir/b.txt',
         'mydir/subdir',
         'mydir/subdir/c.txt',
      ]);



.. _external-iteration-example:

40.4.3â€ƒExternal iteration (pull)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Another way of reusing traversal code is via *external iteration*: We can write
   a generator that yields all traversed values (line A).

   .. code:: javascript

      function* iterPaths(dir) {
      for (const fileName of fs.readdirSync(dir)) {
         const filePath = path.join(dir, fileName);
         yield filePath; // (A)
         const stats = fs.statSync(filePath);
         if (stats.isDirectory()) {
            yield* iterPaths(filePath);
         }
      }
      }
      const paths = Array.from(iterPaths('mydir'));

40.5â€ƒAdvanced features of generators
-------------------------------------

   `The chapter on generators <https://exploringjs.com/es6/ch_generators.html>`__
   in *Exploring ES6* covers two features that are beyond the scope of this book:

   -  ``yield`` can also *receive* data, via an argument of ``.next()``.
   -  Generators can also ``return`` values (not just ``yield`` them). Such values
      do not become iteration values, but can be retrieved via ``yield*``.

   `Comments <https://github.com/rauschma/exploring-js/issues/43>`__




.. _ch_async-js:

41â€ƒFoundations of asynchronous programming in JavaScript
=========================================================

   #. `41.1â€ƒA roadmap for asynchronous programming in JavaScript <#a-roadmap-for-asynchronous-programming-in-javascript>`__

      #. `41.1.1â€ƒSynchronous functions <#synchronous-functions>`__
      #. `41.1.2â€ƒJavaScript executes tasks sequentially in a single process <#javascript-executes-tasks-sequentially-in-a-single-process>`__
      #. `41.1.3â€ƒCallback-based asynchronous functions <#roadmap-callbacks-for-async>`__
      #. `41.1.4â€ƒPromise-based asynchronous functions <#promise-based-asynchronous-functions>`__
      #. `41.1.5â€ƒAsync functions <#roadmap-async-functions>`__
      #. `41.1.6â€ƒNext steps <#next-steps>`__

   #. `41.2â€ƒThe call stack <#the-call-stack>`__
   #. `41.3â€ƒThe event loop <#the-event-loop>`__
   #. `41.4â€ƒHow to avoid blocking the JavaScript process <#how-to-avoid-blocking-the-javascript-process>`__

      #. `41.4.1â€ƒThe user interface of the browser can be blocked <#blocking-browsers>`__
      #. `41.4.2â€ƒHow can we avoid blocking the browser? <#web-workers>`__
      #. `41.4.3â€ƒTaking breaks <#taking-breaks>`__
      #. `41.4.4â€ƒRun-to-completion semantics <#run-to-completion-semantics>`__

   #. `41.5â€ƒPatterns for delivering asynchronous results <#patterns-for-delivering-asynchronous-results>`__

      #. `41.5.1â€ƒDelivering asynchronous results via events <#event-pattern>`__
      #. `41.5.2â€ƒDelivering asynchronous results via callbacks <#callback-pattern>`__

   #. `41.6â€ƒAsynchronous code: the downsides <#asynchronous-code-the-downsides>`__
   #. `41.7â€ƒResources <#resources>`__

   This chapter explains the foundations of asynchronous programming in JavaScript.

41.1â€ƒA roadmap for asynchronous programming in JavaScript
----------------------------------------------------------

   This section provides a roadmap for the content on asynchronous programming in
   JavaScript.

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**Donâ€™t worry about the details!**

      .. container:: boxout-vspace

      Donâ€™t worry if you donâ€™t understand everything yet. This is just a quick peek
      at whatâ€™s coming up.

41.1.1â€ƒSynchronous functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Normal functions are *synchronous*: the caller waits until the callee is
   finished with its computation. ``divideSync()`` in line A is a synchronous
   function call:

   .. code:: javascript

      function main() {
      try {
         const result = divideSync(12, 3); // (A)
         assert.equal(result, 4);
      } catch (err) {
         assert.fail(err);
      }
      }

41.1.2â€ƒJavaScript executes tasks sequentially in a single process
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   By default, JavaScript *tasks* are functions that are executed sequentially in a
   single process. That looks like this:

   .. code:: javascript

      while (true) {
      const task = taskQueue.dequeue();
      task(); // run task
      }

   This loop is also called the *event loop* because events, such as clicking a
   mouse, add tasks to the queue.

   Due to this style of cooperative multitasking, we donâ€™t want a task to block
   other tasks from being executed while, for example, it waits for results coming
   from a server. The next subsection explores how to handle this case.



.. _roadmap-callbacks-for-async:

41.1.3â€ƒCallback-based asynchronous functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   What if ``divide()`` needs a server to compute its result? Then the result
   should be delivered in a different manner: The caller shouldnâ€™t have to wait
   (synchronously) until the result is ready; it should be notified
   (asynchronously) when it is. One way of delivering the result asynchronously is
   by giving ``divide()`` a callback function that it uses to notify the caller.

   .. code:: javascript

      function main() {
      divideCallback(12, 3,
         (err, result) => {
            if (err) {
            assert.fail(err);
            } else {
            assert.equal(result, 4);
            }
         });
      }

   When there is an asynchronous function call:

   .. code:: javascript

      divideCallback(x, y, callback)

   Then the following steps happen:

   -  ``divideCallback()`` sends a request to a server.
   -  Then the current task ``main()`` is finished and other tasks can be executed.
   -  When a response from the server arrives, it is either:

      -  An error ``err``: Then the following task is added to the queue.

         .. code:: javascript

            taskQueue.enqueue(() => callback(err));

      -  A ``result`` value: Then the following task is added to the queue.

         .. code:: javascript

            taskQueue.enqueue(() => callback(null, result));

41.1.4â€ƒPromise-based asynchronous functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Promises are two things:

   -  A standard pattern that makes working with callbacks easier.
   -  The mechanism on which *async functions* (the topic of the next subsection)
      are built.

   Invoking a Promise-based function looks as follows.

   .. code:: javascript

      function main() {
      dividePromise(12, 3)
         .then(result => assert.equal(result, 4))
         .catch(err => assert.fail(err));
      }



.. _roadmap-async-functions:

41.1.5â€ƒAsync functions
~~~~~~~~~~~~~~~~~~~~~~~

   One way of looking at async functions is as better syntax for Promise-based
   code:

   .. code:: javascript

      async function main() {
      try {
         const result = await dividePromise(12, 3); // (A)
         assert.equal(result, 4);
      } catch (err) {
         assert.fail(err);
      }
      }

   The ``dividePromise()`` we are calling in line A is the same Promise-based
   function as in the previous section. But we now have synchronous-looking syntax
   for handling the call. ``await`` can only be used inside a special kind of
   function, an *async function* (note the keyword ``async`` in front of the
   keyword ``function``). ``await`` pauses the current async function and returns
   from it. Once the awaited result is ready, the execution of the function
   continues where it left off.

41.1.6â€ƒNext steps
~~~~~~~~~~~~~~~~~~

   -  In this chapter, weâ€™ll see how synchronous function calls work. Weâ€™ll also
      explore JavaScriptâ€™s way of executing code in a single process, via its
      *event loop*.
   -  `Asynchronicity via callbacks <#callback-pattern>`__ is also described in
      this chapter.
   -  The following chapters cover `Promises <#ch_promises>`__ and
      `async functions <#ch_async-functions>`__.
   -  This series of chapters on asynchronous programming concludes with `the
      chapter on asynchronous
      iteration <#ch_async-iteration>`__, which is similar
      to `synchronous iteration <#ch_sync-iteration>`__, but
      iterated values are delivered asynchronously.

41.2â€ƒThe call stack
--------------------

   Whenever a function calls another function, we need to remember where to return
   to after the latter function is finished. That is typically done via a stack â€“
   the *call stack*: the caller pushes onto it the location to return to, and the
   callee jumps to that location after it is done.

   This is an example where several calls happen:

   .. code:: javascript

      function h(z) {
      const error = new Error();
      console.log(error.stack);
      }
      function g(y) {
      h(y + 1);
      }
      function f(x) {
      g(x + 1);
      }
      f(3);

   Initially, before running this piece of code, the call stack is empty. After the
   function call ``f(3)`` in line 11, the stack has one entry:

   -  Line 12 (location in top-level scope)

   After the function call ``g(x + 1)`` in line 9, the stack has two entries:

   -  Line 10 (location in ``f()``)
   -  Line 12 (location in top-level scope)

   After the function call ``h(y + 1)`` in line 6, the stack has three entries:

   -  Line 7 (location in ``g()``)
   -  Line 10 (location in ``f()``)
   -  Line 12 (location in top-level scope)

   Logging ``error`` in line 3, produces the following output:

   .. code:: language-txt

      Error
         at h (demos/async-js/stack_trace.mjs:2:17)
         at g (demos/async-js/stack_trace.mjs:7:3)
         at f (demos/async-js/stack_trace.mjs:10:3)
         at demos/async-js/stack_trace.mjs:12:1

   This is a so-called *stack trace* of where the ``Error`` object was created.
   Note that it records where calls were made, not return locations. Creating the
   exception in line 2 is yet another call. Thatâ€™s why the stack trace includes a
   location inside ``h()``.

   After line 3, each of the functions terminates and each time, the top entry is
   removed from the call stack. After function ``f`` is done, we are back in
   top-level scope and the stack is empty. When the code fragment ends then that is
   like an implicit ``return``. If we consider the code fragment to be a task that
   is executed, then returning with an empty call stack ends the task.

41.3â€ƒThe event loop
--------------------

   By default, JavaScript runs in a single process â€“ in both web browsers and
   Node.js. The so-called *event loop* sequentially executes *tasks* (pieces of
   code) inside that process. The event loop is depicted in `figure
   41.1 <#fig:event_loop>`__.

   .. figure:: https://exploringjs.com/js/book/img-book/async-js/event_loop.svg
      name: fig:event_loop
      :width: 349px
      :height: 249px

      Figure 41.1: *Task sources* add code to run to the *task queue*, which is
      emptied by the *event loop*.

   Two parties access the task queue:

   -  *Task sources* add tasks to the queue. Some of those sources run concurrently
      to the JavaScript process. For example, one task source takes care of user
      interface events: if a user clicks somewhere and a click listener was
      registered, then an invocation of that listener is added to the task queue.

   -  The *event loop* runs continuously inside the JavaScript process. During each
      loop iteration, it takes one task out of the queue (if the queue is empty, it
      waits until it isnâ€™t) and executes it. That task is finished when the call
      stack is empty and there is a ``return``. Control goes back to the event
      loop, which then retrieves the next task from the queue and executes it. And
      so on.

   The following JavaScript code is an approximation of the event loop:

   .. code:: javascript

      while (true) {
      const task = taskQueue.dequeue();
      task(); // run task
      }

41.4â€ƒHow to avoid blocking the JavaScript process
--------------------------------------------------



.. _blocking-browsers:

41.4.1â€ƒThe user interface of the browser can be blocked
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Many of the user interface mechanisms of browsers also run in the JavaScript
   process (as tasks). Therefore, long-running JavaScript code can block the user
   interface. Letâ€™s look at a web page that demonstrates that. There are two ways
   in which you can try out that page:

   -  You can `run it
      online <http://rauschma.github.io/async-examples/blocking.html>`__.
   -  You can open the following file inside the repository with the exercises:
      ``demos/async-js/blocking.html``

   The following HTML is the pageâ€™s user interface:

   .. code:: language-html

      <a id="block" href="">Block</a>
      <div id="statusMessage"></div>
      <button>Click me!</button>

   The idea is that you click â€œBlockâ€ and a long-running loop is executed via
   JavaScript. During that loop, you canâ€™t click the button because the
   browser/JavaScript process is blocked.

   A simplified version of the JavaScript code looks like this:

   .. code:: javascript

      document.getElementById('block')
      .addEventListener('click', doBlock); // (A)

      function doBlock(event) {
      // Â·Â·Â·
      displayStatus('Blocking...');
      // Â·Â·Â·
      sleep(5000); // (B)
      displayStatus('Done');
      }

      function sleep(milliseconds) {
      const start = Date.now();
      while ((Date.now() - start) < milliseconds);
      }
      function displayStatus(status) {
      document.getElementById('statusMessage')
         .textContent = status;
      }

   These are the key parts of the code:

   -  Line A: We tell the browser to call ``doBlock()`` whenever the HTML element
      is clicked whose ID is ``block``.
   -  ``doBlock()`` displays status information and then calls ``sleep()`` to block
      the JavaScript process for 5000 milliseconds (line B).
   -  ``sleep()`` blocks the JavaScript process by looping until enough time has
      passed.
   -  ``displayStatus()`` displays status messages inside the ``<div>`` whose ID is
      ``statusMessage``.



.. _web-workers:

41.4.2â€ƒHow can we avoid blocking the browser?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   There are several ways in which you can prevent a long-running operation from
   blocking the browser:

   -  The operation can deliver its result *asynchronously*: Some operations, such
      as downloads, can be performed concurrently to the JavaScript process. The
      JavaScript code triggering such an operation registers a callback, which is
      invoked with the result once the operation is finished. The invocation is
      handled via the task queue. This style of delivering a result is called
      *asynchronous* because the caller doesnâ€™t wait until the results are ready.
      Normal function calls deliver their results synchronously.

   -  Perform long computations in separate processes: This can be done via
      so-called *Web Workers*. Web Workers are heavyweight processes that run
      concurrently to the main process. Each one of them has its own runtime
      environment (global variables, etc.). They are completely isolated and must
      be communicated with via message passing. Consult `MDN web
      docs <https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API>`__
      for more information.

   -  Take breaks during long computations. The next subsection explains how.

41.4.3â€ƒTaking breaks
~~~~~~~~~~~~~~~~~~~~~

   The following global function executes its parameter ``callback`` after a delay
   of ``ms`` milliseconds (the type signature is simplified â€“ ``setTimeout()`` has
   more features):

   .. code:: javascript
      :name: language-ts

      function setTimeout(callback: () => void, ms: number): any

   The function returns a *handle* (an ID) that can be used to *clear* the timeout
   (cancel the execution of the callback) via the following global function:

   .. code:: javascript
      :name: language-ts

      function clearTimeout(handle?: any): void

   ``setTimeout()`` is available on both browsers and Node.js. The next subsection
   shows it in action.

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**``setTimeout()`` lets tasks take breaks**

      .. container:: boxout-vspace

      Another way of looking at ``setTimeout()`` is that the current task takes a
      break and continues later via the callback.

41.4.4â€ƒRun-to-completion semantics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScript makes a guarantee for tasks:

      Each task is always finished (â€œrun to completionâ€) before the next task is
      executed.

   As a consequence, tasks donâ€™t have to worry about their data being changed while
   they are working on it (*concurrent modification*). That simplifies programming
   in JavaScript.

   The following example demonstrates this guarantee:

   .. code:: javascript

      console.log('start');
      setTimeout(() => {
      console.log('callback');
      }, 0);
      console.log('end');

   Output:

   ::

      start
      end
      callback

   ``setTimeout()`` puts its parameter into the task queue. The parameter is
   therefore executed sometime after the current piece of code (task) is completely
   finished.

   The parameter ``ms`` only specifies when the task is put into the queue, not
   when exactly it runs. It may even never run â€“ for example, if there is a task
   before it in the queue that never terminates. That explains why the previous
   code logs ``'end'`` before ``'callback'``, even though the parameter ``ms`` is
   ``0``.

41.5â€ƒPatterns for delivering asynchronous results
--------------------------------------------------

   In order to avoid blocking the main process while waiting for a long-running
   operation to finish, results are often delivered asynchronously in JavaScript.
   These are three popular patterns for doing so:

   -  Events
   -  Callbacks
   -  Promises

   The first two patterns are explained in the next two subsections. Promises are
   explained in `the next chapter <#ch_promises>`__.



.. _event-pattern:

41.5.1â€ƒDelivering asynchronous results via events
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Events as a pattern work as follows:

   -  They are used to deliver values asynchronously.
   -  They do so zero or more times.
   -  There are three roles in this pattern:

      -  The *event* (an object) carries the data to be delivered.
      -  The *event listener* is a function that receives events via a parameter.
      -  The *event source* sends events and lets you register event listeners.

   Multiple variations of this pattern exist in the world of JavaScript. Weâ€™ll look
   at three examples next.

41.5.1.1â€ƒEvents: IndexedDB
'''''''''''''''''''''''''''

   IndexedDB is a database that is built into web browsers. This is an example of
   using it:

   .. code:: javascript

      const openRequest = indexedDB.open('MyDatabase', 1); // (A)

      openRequest.onsuccess = (event) => {
      const db = event.target.result;
      // Â·Â·Â·
      };

      openRequest.onerror = (error) => {
      console.error(error);
      };

   ``indexedDB`` has an unusual way of invoking operations:

   -  Each operation has an associated method for creating *request objects*. For
      example, in line A, the operation is â€œopenâ€, the method is ``.open()``, and
      the request object is ``openRequest``.

   -  The parameters for the operation are provided via the request object, not via
      parameters of the method. For example, the event listeners (functions) are
      stored in the properties ``.onsuccess`` and ``.onerror``.

   -  The invocation of the operation is added to the task queue via the method (in
      line A). That is, we configure the operation *after* its invocation has
      already been added to the queue. Only run-to-completion semantics saves us
      from race conditions here and ensures that the operation runs after the
      current code fragment is finished.



.. _XMLHttpRequest:

41.5.1.2â€ƒEvents: ``XMLHttpRequest``
''''''''''''''''''''''''''''''''''''

   The ``XMLHttpRequest`` API lets us make downloads from within a web browser.
   This is how we download the file ``http://example.com/textfile.txt``:

   .. code:: javascript

      const xhr = new XMLHttpRequest(); // (A)
      xhr.open('GET', 'http://example.com/textfile.txt'); // (B)
      xhr.onload = () => { // (C)
      if (xhr.status == 200) {
         processData(xhr.responseText);
      } else {
         assert.fail(new Error(xhr.statusText));
      }
      };
      xhr.onerror = () => { // (D)
      assert.fail(new Error('Network error'));
      };
      xhr.send(); // (E)

      function processData(str) {
      assert.equal(str, 'Content of textfile.txt\n');
      }

   With this API, we first create a request object (line A), then configure it,
   then activate it (line E). The configuration consists of:

   -  Specifying which HTTP request method to use (line B): ``GET``, ``POST``,
      ``PUT``, etc.
   -  Registering a listener (line C) that is notified if something could be
      downloaded. Inside the listener, we still need to determine if the download
      contains what we requested or informs us of an error. Note that some of the
      result data is delivered via the request object ``xhr``. (Iâ€™m not a fan of
      this kind of mixing of input and output data.)
   -  Registering a listener (line D) that is notified if there was a network
      error.

41.5.1.3â€ƒEvents: DOM
'''''''''''''''''''''

   We have already seen DOM events in action in `â€œThe user interface of the browser
   can be blockedâ€ (Â§41.4.1) <#blocking-browsers>`__. The following code also
   handles ``click`` events:

   .. code:: javascript

      const element = document.getElementById('my-link'); // (A)
      element.addEventListener('click', clickListener); // (B)

      function clickListener(event) {
      event.preventDefault(); // (C)
      console.log(event.shiftKey); // (D)
      }

   We first ask the browser to retrieve the HTML element whose ID is ``'my-link'``
   (line A). Then we add a listener for all ``click`` events (line B). In the
   listener, we first tell the browser not to perform its default action (line C) â€“
   going to the target of the link. Then we log to the console if the shift key is
   currently pressed (line D).



.. _callback-pattern:

41.5.2â€ƒDelivering asynchronous results via callbacks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Callbacks are another pattern for handling asynchronous results. They are only
   used for one-off results and have the advantage of being less verbose than
   events.

   As an example, consider a function ``readFile()`` that reads a text file and
   returns its contents asynchronously. This is how you call ``readFile()`` if it
   uses Node.js-style callbacks:

   .. code:: javascript

      readFile('some-file.txt', {encoding: 'utf-8'},
      (error, data) => {
         if (error) {
            assert.fail(error);
            return;
         }
         assert.equal(data, 'The content of some-file.txt');
      });

   There is a single callback that handles both success and failure. If the first
   parameter is not ``null`` then an error happened. Otherwise, the result can be
   found in the second parameter.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercises: Callback-based code**

      .. container:: boxout-vspace

      The following exercises use tests for asynchronous code, which are different
      from tests for synchronous code. Consult `â€œAsynchronous tests in Mochaâ€
      (Â§12.2.2) <#async-tests-mocha>`__ for more information.

      -  From synchronous to callback-based code:
         ``exercises/async-js/read_file_cb_exrc.mjs``
      -  Implementing a callback-based version of ``.map()``:
         ``exercises/async-js/map_cb_test.mjs``

41.6â€ƒAsynchronous code: the downsides
--------------------------------------

   In many situations, on either browsers or Node.js, you have no choice, you must
   use asynchronous code. In this chapter, we have seen several patterns that such
   code can use. All of them have two disadvantages:

   -  Asynchronous code is more verbose than synchronous code.
   -  If you call asynchronous code, your code must become asynchronous too. Thatâ€™s
      because you canâ€™t wait synchronously for an asynchronous result. Asynchronous
      code has an infectious quality.

   The first disadvantage becomes less severe with Promises (covered in `the next
   chapter <#ch_promises>`__) and mostly disappears with async
   functions (covered in `the chapter after
   next <#ch_async-functions>`__).

   Alas, the infectiousness of async code does not go away. But it is mitigated by
   the fact that switching between sync and async is easy with async functions.

41.7â€ƒResources
---------------

   -  `â€œHelp, I'm stuck in an event-loopâ€ <https://vimeo.com/96425312>`__ by Philip
      Roberts (video).
   -  `â€œEvent loopsâ€ <https://www.w3.org/TR/html5/webappapis.html#event-loops>`__,
      section in HTML5 spec.

   `Comments <https://github.com/rauschma/exploring-js/issues/26>`__



.. _ch_promises:

42â€ƒPromises for asynchronous programming [ES6]
===============================================

   #. `42.1â€ƒThe basics of using Promises <#the-basics-of-using-promises>`__

      #. `42.1.1â€ƒUsing a Promise-based function <#using-a-promise-based-function>`__
      #. `42.1.2â€ƒWhat is a Promise? <#what-is-a-promise>`__
      #. `42.1.3â€ƒImplementing a Promise-based function <#implementing-a-promise-based-function>`__
      #. `42.1.4â€ƒStates of Promises <#states-of-promises>`__
      #. `42.1.5â€ƒCreating resolved and rejected Promises via Promise.resolve() and Promise.reject() <#creating-resolved-and-rejected-promises-via-promise-resolve-and-promise-reject>`__
      #. `42.1.6â€ƒReturning and throwing in .then() callbacks <#returning-and-throwing-in-then-callbacks>`__
      #. `42.1.7â€ƒ.catch() and its callback <#catch-and-its-callback>`__
      #. `42.1.8â€ƒChaining method calls <#chaining-method-calls>`__
      #. `42.1.9â€ƒPromise.prototype.finally() [ES2018] <#Promise.prototype.finally>`__
      #. `42.1.10â€ƒPromise.withResolvers() [ES2024] <#Promise.withResolvers>`__
      #. `42.1.11â€ƒAdvantages of promises over plain callbacks <#advantages-of-promises-over-plain-callbacks>`__

   #. `42.2â€ƒExamples <#examples>`__

      #. `42.2.1â€ƒNode.js: Reading a file asynchronously <#node-js-reading-a-file-asynchronously>`__
      #. `42.2.2â€ƒBrowsers: Promisifying XMLHttpRequest <#promisifying-xmlhttprequest>`__
      #. `42.2.3â€ƒFetch API <#fetch-api>`__

   #. `42.3â€ƒError handling: donâ€™t mix rejections and exceptions <#error-handling-don-t-mix-rejections-and-exceptions>`__
   #. `42.4â€ƒPromise-based functions start synchronously, settle asynchronously <#promise-based-funcs-sync-start-async-settlement>`__
   #. `42.5â€ƒPromise combinator functions: working with Arrays of Promises <#promise-combinators>`__

      #. `42.5.1â€ƒWhat is a Promise combinator function? <#what-is-a-promise-combinator-function>`__
      #. `42.5.2â€ƒPromise.all() <#Promise.all>`__
      #. `42.5.3â€ƒPromise.race() <#Promise.race>`__
      #. `42.5.4â€ƒPromise.any() [ES2021] <#Promise.any>`__
      #. `42.5.5â€ƒPromise.allSettled() [ES2020] <#Promise.allSettled>`__
      #. `42.5.6â€ƒShort-circuiting (advanced) <#short-circuiting>`__

   #. `42.6â€ƒConcurrency and Promise.all() (advanced) <#concurrency-and-promise-all>`__

      #. `42.6.1â€ƒSequential execution vs. concurrent execution <#sequential-execution-vs-concurrent-execution>`__
      #. `42.6.2â€ƒConcurrency tip: focus on when operations start <#focus-on-async-start>`__
      #. `42.6.3â€ƒPromise.all() is fork-join <#promise-all-is-fork-join>`__

   #. `42.7â€ƒTips for chaining Promises <#tips-for-chaining-promises>`__

      #. `42.7.1â€ƒChaining mistake: losing theÂ tail <#chaining-mistake-losing-the-tail>`__
      #. `42.7.2â€ƒChaining mistake: nesting <#chaining-mistake-nesting>`__
      #. `42.7.3â€ƒChaining mistake: more nesting than necessary <#chaining-mistake-more-nesting-than-necessary>`__
      #. `42.7.4â€ƒNot all nesting is bad <#not-all-nesting-is-bad>`__
      #. `42.7.5â€ƒChaining mistake: creating Promises instead of chaining <#chaining-mistake-creating-promises-instead-of-chaining>`__

   #. `42.8â€ƒQuick reference: Promise combinator functions <#quick-reference-promise-combinator-functions>`__

      #. `42.8.1â€ƒPromise.all() <#qref-Promise.all>`__
      #. `42.8.2â€ƒPromise.race() <#qref-Promise.race>`__
      #. `42.8.3â€ƒPromise.any() [ES2021] <#qref-Promise.any>`__
      #. `42.8.4â€ƒPromise.allSettled() [ES2020] <#qref-Promise.allSettled>`__

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**Recommended reading**

      .. container:: boxout-vspace

      This chapter builds on `the previous
      chapter <#ch_async-js>`__ with background on asynchronous
      programming in JavaScript.

42.1â€ƒThe basics of using Promises
----------------------------------

   Promises are a technique for delivering results asynchronously.

42.1.1â€ƒUsing a Promise-based function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following code is an example of using the Promise-based function
   ``addAsync()`` (whose implementation is shown soon):

   .. code:: javascript

      addAsync(3, 4)
      .then(result => { // success
         assert.equal(result, 7);
      })
      .catch(error => { // failure
         assert.fail(error);
      });

   Promises are similar to `the event pattern <#event-pattern>`__:
   There is an object (a *Promise*), where we register callbacks:

   -  Method ``.then()`` registers callbacks that handle results.
   -  Method ``.catch()`` registers callbacks that handle errors.

   A Promise-based function returns a Promise and sends it a result or an error (if
   and when it is done). The Promise passes it on to the relevant callbacks.

   In contrast to the event pattern, Promises are optimized for one-off results:

   -  A result (or an error) is cached so that it doesnâ€™t matter if we register a
      callback before or after the result (or error) was sent.
   -  We can chain the Promise methods ``.then()`` and ``.catch()`` because they
      both return Promises. That helps with sequentially invoking multiple
      asynchronous functions. More on that later.

42.1.2â€ƒWhat is a Promise?
~~~~~~~~~~~~~~~~~~~~~~~~~~

   What is a Promise? There are two ways of looking at it:

   -  On one hand, it is a placeholder and container for the final result that we
      are waiting for.
   -  On the other hand, it is an object with which we can register listeners.

42.1.3â€ƒImplementing a Promise-based function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is an implementation of a Promise-based function that adds two numbers
   ``x`` and ``y``:

   .. code:: javascript

      function addAsync(x, y) {
      return new Promise(
         (resolve, reject) => { // (A)
            if (x === undefined || y === undefined) {
            reject(new Error('Must provide two parameters'));
            } else {
            resolve(x + y);
            }
         });
      }

   ``addAsync()`` immediately invokes the ``Promise`` constructor. The actual
   implementation of the functionality resides in the callback that is passed to
   that constructor (line A). That callback is provided with two functions:

   -  ``resolve`` is used for delivering a result (in case of success).
   -  ``reject`` is used for delivering an error (in case of failure).



.. _revealing-constructor-pattern:

42.1.3.1â€ƒThe revealing constructor pattern (advanced)
''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The Promise constructor uses *the revealing constructor pattern*:

   .. code:: javascript

      const promise = new Promise(
      (resolve, reject) => {
         // Â·Â·Â·
      }
      );

   `Quoting Domenic
   Denicola <https://blog.domenic.me/the-revealing-constructor-pattern/>`__, one of
   the people behind JavaScriptâ€™s Promise API:

      I call this *the revealing constructor pattern* because the ``Promise``
      constructor is *revealing* its internal capabilities, but only to the code
      that constructs the promise in question. The ability to resolve or reject the
      promise is only revealed to the constructing code, and is crucially *not*
      revealed to anyone *using* the promise. So if we hand off ``p`` to another
      consumer, say

      .. code:: javascript

         doThingsWith(p);

      then we can be sure that this consumer cannot mess with any of the internals
      that were revealed to us by the constructor. This is as opposed to, for
      example, putting ``resolve`` and ``reject`` methods on ``p``, which anyone
      could call.

42.1.4â€ƒStates of Promises
~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. figure:: https://exploringjs.com/js/book/img-book/promises/promise_states_simple.svg
      name: fig:promise_states_simple
      :width: 267px
      :height: 105px

      Figure 42.1: A Promise can be in either one of three states: pending,
      fulfilled, or rejected. If a Promise is in a final (non-pending) state, it is
      called *settled*.

   `Figure 42.1 <#fig:promise_states_simple>`__ depicts the three states a Promise
   can be in. Promises specialize in one-off results and protect us against *race
   conditions* (registering too early or too late):

   -  If we register a ``.then()`` callback or a ``.catch()`` callback too early,
      it is notified once a Promise is settled.
   -  Once a Promise is settled, the settlement value (result or error) is cached.
      Thus, if ``.then()`` or ``.catch()`` are called after the settlement, they
      receive the cached value.

   Additionally, once a Promise is settled, its state and settlement value canâ€™t
   change anymore. That helps make code predictable and enforces the one-off nature
   of Promises.

42.1.4.1â€ƒSome Promises are never settled
'''''''''''''''''''''''''''''''''''''''''

   This is an example of a Promise that is never settled and forever pending:

   .. code:: javascript

      new Promise(() => {})

42.1.4.2â€ƒWhat is the difference between resolving and fulfilling a Promise?
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   If the callback of ``new Promise()`` calls ``resolve(x)`` then it depends on
   ``x`` what happens to the newly created Promise ``p``:

   -  If ``x`` is a non-Promise value then ``p`` is fulfilled with ``x``.
   -  If ``x`` is a Promise, then the state of ``p`` locked on the state of ``x``.
      That is:

      -  If ``x`` is fulfilled, ``p`` is fulfilled.
      -  If ``x`` is rejected, ``p`` is rejected.
      -  If ``x`` never settles, ``p`` never settles either.

   In other words: The operation ``resolve`` only determines the fate of a Promise;
   it may or may not fulfill it.



.. _creating-resolved-and-rejected-promises-via-promise-resolve-and-promise-reject:

42.1.5â€ƒCreating resolved and rejected Promises via ``Promise.resolve()`` and ``Promise.reject()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If ``x`` is a non-Promise value then ``Promise.resolve(x)`` creates a Promise
   that is fulfilled with that value:

   .. code:: javascript

      Promise.resolve(123)
      .then(x => {
         assert.equal(x, 123);
      });

   If the argument is already a Promise, it is returned unchanged:

   .. code:: javascript

      const abcPromise = Promise.resolve('abc');
      assert.equal(
      Promise.resolve(abcPromise), abcPromise
      );

   ``Promise.reject(err)`` accepts a value ``err`` (that is normally not a Promise)
   and returns a Promise that is rejected with it:

   .. code:: javascript

      const myError = new Error('My error!');
      Promise.reject(myError)
      .catch(err => {
         assert.equal(err, myError);
      });

   Why is that useful?

   -  On one hand, we can use ``Promise.resolve()`` to convert a value that may or
      may not be a Promise to a value that is guaranteed to be a Promise.
   -  On the other hand, we may want to create a Promise that is fulfilled or
      rejected with a given non-Promise value. Then we can use
      ``Promise.resolve()`` and ``Promise.reject()`` â€“ as demonstrated by the
      example below.

   .. code:: javascript

      function convertToNumber(stringOrNumber) {
      if (typeof stringOrNumber === 'number') {
         return Promise.resolve(stringOrNumber);
      } else if (typeof stringOrNumber === 'string') {
         return stringToNumberAsync(stringOrNumber);
      } else {
         return Promise.reject(new TypeError());
      }
      }



.. _returning-and-throwing-in-then-callbacks:

42.1.6â€ƒReturning and throwing in ``.then()`` callbacks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.then()`` handles Promise fulfillments. It also returns a new Promise. Doing
   so enables method chaining: We can invoke ``.then()`` and ``.catch()`` on the
   result and keep the asynchronous computation going.

   How the Promise returned by ``.then()`` is resolved, depends on what happens
   inside its callback. Letâ€™s look at three common cases.



.. _returning-a-non-promise-value-from-the-then-callback:

42.1.6.1â€ƒReturning a non-Promise value from the ``.then()`` callback
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   First, the callback can return a non-Promise value (line A). Consequently, the
   Promise returned by ``.then()`` is fulfilled with that value (as checked in line
   B):

   .. code:: javascript

      Promise.resolve('abc')
      .then(str => {
         return str + str; // (A)
      })
      .then(str2 => {
         assert.equal(str2, 'abcabc'); // (B)
      });



.. _returning-a-promise-from-the-then-callback:

42.1.6.2â€ƒReturning a Promise from the ``.then()`` callback
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Second, the callback can return a Promise ``q`` (line A). Consequently, the
   Promise ``p`` returned by ``.then()`` is resolved with ``q``. In other words:
   ``p`` is effectively replaced by ``q``.

   .. code:: javascript

      Promise.resolve('abc')
      .then(str => {
         return Promise.resolve(123); // (A)
      })
      .then(num => {
         assert.equal(num, 123);
      });

   Why is that useful? We can return the result of a Promise-based operation and
   process its fulfillment value via a â€œflatâ€ (non-nested) ``.then()``. Compare:

   .. code:: javascript

      // Flat
      asyncFunc1()
      .then(result1 => {
         /*Â·Â·Â·*/
         return asyncFunc2();
      })
      .then(result2 => {
         /*Â·Â·Â·*/
      });

      // Nested
      asyncFunc1()
      .then(result1 => {
         /*Â·Â·Â·*/
         asyncFunc2()
         .then(result2 => {
            /*Â·Â·Â·*/
         });
      });



.. _throwing-an-exception-inside-the-then-callback:

42.1.6.3â€ƒThrowing an exception inside the ``.then()`` callback
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Third, the callback can throw an exception. Consequently, the Promise returned
   by ``.then()`` is rejected with that exception. That is, a synchronous error is
   converted into an asynchronous error.

   .. code:: javascript

      const myError = new Error('My error!');
      Promise.resolve('abc')
      .then(str => {
         throw myError;
      })
      .catch(err => {
         assert.equal(err, myError);
      });

42.1.7â€ƒ``.catch()`` and its callback
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The difference between ``.then()`` and ``.catch()`` is that the latter is
   triggered by rejections, not fulfillments. However, both methods turn the
   actions of their callbacks into Promises in the same manner. For example, in the
   following code, the value returned by the ``.catch()`` callback in line A
   becomes a fulfillment value:

   .. code:: javascript

      const err = new Error();

      Promise.reject(err)
      .catch(e => {
         assert.equal(e, err);
         // Something went wrong, use a default value
         return 'default value'; // (A)
      })
      .then(str => {
         assert.equal(str, 'default value');
      });

42.1.8â€ƒChaining method calls
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.then()`` and ``.catch()`` always returning Promises enables us to create
   arbitrary long chains of method calls:

   .. code:: javascript

      function myAsyncFunc() {
      return asyncFunc1() // (A)
         .then(result1 => {
            // Â·Â·Â·
            return asyncFunc2(); // a Promise
         })
         .then(result2 => {
            // Â·Â·Â·
            return result2 ?? '(Empty)'; // not a Promise
         })
         .then(result3 => {
            // Â·Â·Â·
            return asyncFunc4(); // a Promise
         });
      }

   Due to chaining, the ``return`` in line A returns the result of the last
   ``.then()``.

   In a way, ``.then()`` is the asynchronous version of the synchronous semicolon:

   -  ``asyncFunc1().then(asyncFunc2)`` executes the asynchronous operations
      ``asyncFunc1`` and ``asyncFunc2`` sequentially.
   -  ``syncFunc1(); syncFunc2()`` executes the synchronous operations
      ``syncFunc1`` and ``syncFunc2`` sequentially.

   We can also add ``.catch()`` into the mix and let it handle multiple error
   sources at the same time:

   .. code:: javascript

      asyncFunc1()
      .then(result1 => {
         // Â·Â·Â·
         return asyncFunction2();
      })
      .then(result2 => {
         // Â·Â·Â·
      })
      .catch(error => {
         // Failure: handle errors of asyncFunc1(), asyncFunc2()
         // and any (sync) exceptions thrown in previous callbacks
      });



.. _Promise.prototype.finally:

42.1.9â€ƒ``Promise.prototype.finally()`` [ES2018]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The Promise method ``.finally()`` is often used as follows:

   .. code:: javascript

      somePromise
      .then((result) => {
         // Â·Â·Â·
      })
      .catch((error) => {
         // Â·Â·Â·
      })
      .finally(() => {
         // Â·Â·Â·
      })
      ;

   The ``.finally()`` callback is always executed â€“ independently of
   ``somePromise`` and the values returned by ``.then()`` and/or ``.catch()``. In
   contrast:

   -  The ``.then()`` callback is only executed if ``somePromise`` is fulfilled.
   -  The ``.catch()`` callback is only executed if:

      -  either ``somePromise`` is rejected,
      -  or the ``.then()`` callback returns a rejected Promise,
      -  or the ``.then()`` callback throws an exception.

   ``.finally()`` ignores what its callback returns and simply passes on the
   settlement that existed before it was called:

   .. code:: javascript

      Promise.resolve(123)
      .finally(() => {})
      .then((result) => {
         assert.equal(result, 123);
      });

      Promise.reject('error')
      .finally(() => {})
      .catch((error) => {
         assert.equal(error, 'error');
      });

   If, however, the ``.finally()`` callback throws an exception, the Promise
   returned by ``.finally()`` is rejected:

   .. code:: javascript

      Promise.reject('error (originally)')
      .finally(() => {
         throw 'error (finally)';
      })
      .catch((error) => {
         assert.equal(error, 'error (finally)');
      });



.. _use-case-for-finally-cleaning-up:

42.1.9.1â€ƒUse case for ``.finally()``: cleaning up
''''''''''''''''''''''''''''''''''''''''''''''''''

   One common use case for ``.finally()`` is similar to a common use case of the
   synchronous ``finally`` clause: cleaning up after you are done with a resource.
   That should always happen, regardless of whether everything went smoothly or
   there was an error â€“ for example:

   .. code:: javascript

      let connection;
      db.open()
      .then((conn) => {
      connection = conn;
      return connection.select({ name: 'Jane' });
      })
      .then((result) => {
      // Process result
      // Use `connection` to make more queries
      })
      // Â·Â·Â·
      .catch((error) => {
      // handle errors
      })
      .finally(() => {
      connection.close();
      });



.. _use-case-for-finally-doing-something-first-after-any-kind-of-settlement:

42.1.9.2â€ƒUse case for ``.finally()``: doing something first after any kind of settlement
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   We can also use ``.finally()`` before both ``.then()`` and ``.catch()``. Then
   what we do in the ``.finally()`` callback is always executed before the other
   two callbacks. As an example, consider the following function
   ``handleAsyncResult()``:

   .. code:: javascript

      function handleAsyncResult(promise) {
      return promise
         .finally(() => {
            console.log('finally');
         })
         .then((result) => {
            console.log('then ' + result);
         })
         .catch((error) => {
            console.log('catch ' + error);
         })
      ;
      }

   This is what happens with a fulfilled Promise:

   .. code:: javascript

      handleAsyncResult(Promise.resolve('fulfilled'));

   Output:

   ::

      finally
      then fulfilled

   This is what happens with a rejected Promise:

   .. code:: javascript

      handleAsyncResult(Promise.reject('rejected'));

   Output:

   ::

      finally
      catch rejected



.. _Promise.withResolvers:

42.1.10â€ƒ``Promise.withResolvers()`` [ES2024]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The most common way of creating and resolving a Promise is via the ``Promise``
   constructor:

   .. code:: javascript

      new Promise(
      (resolve, reject) => { Â·Â·Â· }
      );

   One limitation of creating Promises like that is that the settlement functions
   ``resolve`` and ``reject`` are meant to only be used inside the callback.
   Sometimes we want to use them outside of it. Thatâ€™s when the following static
   factory method is useful:

   .. code:: javascript

      const { promise, resolve, reject } = Promise.withResolvers();

   This is what using that factory method looks like:

   .. code:: javascript

      {
      const { promise, resolve, reject } = Promise.withResolvers();
      resolve('fulfilled');
      assert.equal(
         await promise,
         'fulfilled'
      );
      }
      {
      const { promise, resolve, reject } = Promise.withResolvers();
      reject('rejected');
      try {
         await promise;
      } catch (err) {
         assert.equal(err, 'rejected');
      }
      }

42.1.10.1â€ƒAn implementation
''''''''''''''''''''''''''''

   We can implement ``Promise.withResolvers()`` as follows:

   .. code:: javascript

      function promiseWithResolvers() {
      let resolve;
      let reject;
      const promise = new Promise(
         (res, rej) => {
            // Executed synchronously!
            resolve = res;
            reject = rej;
         });
      return {promise, resolve, reject};
      }

42.1.10.2â€ƒExample: one-element queue
'''''''''''''''''''''''''''''''''''''

   .. code:: javascript

      class OneElementQueue {
      #promise = null;
      #resolve = null;
      constructor() {
         const { promise, resolve } = Promise.withResolvers();
         this.#promise = promise;
         this.#resolve = resolve;
      }
      get() {
         return this.#promise;
      }
      put(value) {
         this.#resolve(value);
      }
      }

      { // Putting before getting
      const queue = new OneElementQueue();
      queue.put('one');
      assert.equal(
         await queue.get(),
         'one'
      );
      }
      { // Getting before putting
      const queue = new OneElementQueue();
      setTimeout(
         // Runs after `await` pauses the current execution context
         () => queue.put('two'),
         0
      );
      assert.equal(
         await queue.get(),
         'two'
      );
      }

42.1.11â€ƒAdvantages of promises over plain callbacks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   These are some of the advantages of Promises over plain callbacks when it comes
   to handling one-off results:

   -  The type signatures of Promise-based functions and methods are cleaner: if a
      function is callback-based, some parameters are about input, while the one or
      two callbacks at the end are about output. With Promises, everything
      output-related is handled via the returned value.

   -  Chaining asynchronous processing steps is more convenient.

   -  Promises handle both asynchronous errors (via rejections) and synchronous
      errors: Inside the callbacks for ``new Promise()``, ``.then()``, and
      ``.catch()``, exceptions are converted to rejections. In contrast, if we use
      callbacks for asynchronicity, exceptions are normally not handled for us; we
      have to do it ourselves.

   -  Promises are a single standard that is slowly replacing several, mutually
      incompatible alternatives. For example, in Node.js, many functions are now
      available in Promise-based versions. And new asynchronous browser APIs are
      usually Promise-based.

   One of the biggest advantages of Promises involves not working with them
   directly: they are the foundation of *async functions*, a synchronous-looking
   syntax for performing asynchronous computations. Asynchronous functions are
   covered in `the next chapter <#ch_async-functions>`__.

42.2â€ƒExamples
--------------

   Seeing Promises in action helps with understanding them. Letâ€™s look at examples.



.. _node-js-reading-a-file-asynchronously:

42.2.1â€ƒNode.js: Reading a file asynchronously
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Consider the following text file ``person.json`` with `JSON
   data <#ch_json>`__ in it:

   .. code:: javascripton

      {
      "first": "Jane",
      "last": "Doe"
      }

   Letâ€™s look at two versions of code that reads this file and parses it into an
   object. First, a callback-based version. Second, a Promise-based version.

42.2.1.1â€ƒThe callback-based version
''''''''''''''''''''''''''''''''''''

   The following code reads the contents of this file and converts it to a
   JavaScript object. It is based on Node.js-style callbacks:

   .. code:: javascript

      import * as fs from 'node:fs';
      fs.readFile('person.json',
      (error, text) => {
         if (error) { // (A)
            // Failure
            assert.fail(error);
         } else {
            // Success
            try { // (B)
            const obj = JSON.parse(text); // (C)
            assert.deepEqual(obj, {
               first: 'Jane',
               last: 'Doe',
            });
            } catch (e) {
            // Invalid JSON
            assert.fail(e);
            }
         }
      });

   ``fs`` is a built-in Node.js module for file system operations. We use the
   callback-based function ``fs.readFile()`` to read a file whose name is
   ``person.json``. If we succeed, the content is delivered via the parameter
   ``text`` as a string. In line C, we convert that string from the text-based data
   format JSON into a JavaScript object. ``JSON`` is an object with methods for
   consuming and producing JSON. It is part of JavaScriptâ€™s standard library and
   documented `later in this book <#ch_json>`__.

   Note that there are two error-handling mechanisms: the ``if`` in line A takes
   care of asynchronous errors reported by ``fs.readFile()``, while the ``try`` in
   line B takes care of synchronous errors reported by ``JSON.parse()``.

42.2.1.2â€ƒThe Promise-based version
'''''''''''''''''''''''''''''''''''

   The following code uses ``readFile()`` from ``node:fs/promises``, the
   Promise-based version of ``fs.readFile()``:

   .. code:: javascript

      import {readFile} from 'node:fs/promises';
      readFile('person.json')
      .then(text => { // (A)
         // Success
         const obj = JSON.parse(text);
         assert.deepEqual(obj, {
            first: 'Jane',
            last: 'Doe',
         });
      })
      .catch(err => { // (B)
         // Failure: file I/O error or JSON syntax error
         assert.fail(err);
      });

   Function ``readFile()`` returns a Promise. In line A, we specify a success
   callback via method ``.then()`` of that Promise. The remaining code in
   ``then``\ â€™s callback is synchronous.

   ``.then()`` returns a Promise, which enables the invocation of the Promise
   method ``.catch()`` in line B. We use it to specify a failure callback.

   Note that ``.catch()`` lets us handle both the asynchronous errors of
   ``readFile()`` and the synchronous errors of ``JSON.parse()`` because exceptions
   inside a ``.then()`` callback become rejections.



.. _promisifying-xmlhttprequest:

42.2.2â€ƒBrowsers: Promisifying ``XMLHttpRequest``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We have previously seen the event-based ``XMLHttpRequest`` API for downloading
   data in web browsers. The following function promisifies that API:

   .. code:: javascript

      function httpGet(url) {
      return new Promise(
         (resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.onload = () => {
            if (xhr.status === 200) {
               resolve(xhr.responseText); // (A)
            } else {
               // Something went wrong (404, etc.)
               reject(new Error(xhr.statusText)); // (B)
            }
            }
            xhr.onerror = () => {
            reject(new Error('Network error')); // (C)
            };
            xhr.open('GET', url);
            xhr.send();
         });
      }

   Note how the results and errors of ``XMLHttpRequest`` are handled via
   ``resolve()`` and ``reject()``:

   -  A successful outcome leads to the returned Promise being fullfilled with it
      (line A).
   -  An error leads to the Promise being rejected (lines B and C).

   This is how to use ``httpGet()``:

   .. code:: javascript

      httpGet('http://example.com/textfile.txt')
      .then(content => {
         assert.equal(content, 'Content of textfile.txt\n');
      })
      .catch(error => {
         assert.fail(error);
      });

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Timing out a Promise**

      .. container:: boxout-vspace

      ``exercises/promises/promise_timeout_test.mjs``

42.2.3â€ƒFetch API
~~~~~~~~~~~~~~~~~

   Most JavaScript platforms support Fetch, a Promise-based API for downloading
   data. Think of it as a Promise-based version of ``XMLHttpRequest``. The
   following is an excerpt of `the
   API <https://fetch.spec.whatwg.org/#fetch-api>`__:

   .. code:: javascript
      :name: language-ts

      interface Body {
      text() : Promise<string>;
      Â·Â·Â·
      }
      interface Response extends Body {
      Â·Â·Â·
      }
      declare function fetch(str) : Promise<Response>;

   That means we can use ``fetch()`` as follows:

   .. code:: javascript

      fetch('http://example.com/textfile.txt')
      .then(response => response.text())
      .then(text => {
         assert.equal(text, 'Content of textfile.txt\n');
      });

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Using the fetch API**

      .. container:: boxout-vspace

      ``exercises/promises/fetch_json_test.mjs``



.. _error-handling-don-t-mix-rejections-and-exceptions:

42.3â€ƒError handling: donâ€™t mix rejections and exceptions
---------------------------------------------------------

   Rule for implementing functions and methods:

      Donâ€™t mix (asynchronous) rejections and (synchronous) exceptions.

   This makes our synchronous and asynchronous code more predictable and simpler
   because we can always focus on a single error-handling mechanism.

   For Promise-based functions and methods, the rule means that they should never
   throw exceptions. Alas, it is easy to accidentally get this wrong â€“ for example:

   .. code:: javascript

      // Donâ€™t do this
      function asyncFunc() {
      doSomethingSync(); // (A)
      return doSomethingAsync()
         .then(result => {
            // Â·Â·Â·
         });
      }

   The problem is that if an exception is thrown in line A, then ``asyncFunc()``
   will throw an exception. Callers of that function only expect rejections and are
   not prepared for an exception. There are three ways in which we can fix this
   issue.

   We can wrap the whole body of the function in a ``try-catch`` statement and
   return a rejected Promise if an exception is thrown:

   .. code:: javascript

      // Solution 1
      function asyncFunc() {
      try {
         doSomethingSync();
         return doSomethingAsync()
            .then(result => {
            // Â·Â·Â·
            });
      } catch (err) {
         return Promise.reject(err);
      }
      }

   Given that ``.then()`` converts exceptions to rejections, we can execute
   ``doSomethingSync()`` inside a ``.then()`` callback. To do so, we start a
   Promise chain via ``Promise.resolve()``. We ignore the fulfillment value
   ``undefined`` of that initial Promise.

   .. code:: javascript

      // Solution 2
      function asyncFunc() {
      return Promise.resolve()
         .then(() => {
            doSomethingSync();
            return doSomethingAsync();
         })
         .then(result => {
            // Â·Â·Â·
         });
      }

   Lastly, ``new Promise()`` also converts exceptions to rejections. Using this
   constructor is therefore similar to the previous solution:

   .. code:: javascript

      // Solution 3
      function asyncFunc() {
      return new Promise((resolve, reject) => {
            doSomethingSync();
            resolve(doSomethingAsync());
         })
         .then(result => {
            // Â·Â·Â·
         });
      }



.. _promise-based-funcs-sync-start-async-settlement:

42.4â€ƒPromise-based functions start synchronously, settle asynchronously
------------------------------------------------------------------------

   Most Promise-based functions are executed as follows:

   -  Their execution starts right away, synchronously (in the current task).
   -  But the Promise they return is guaranteed to be settled asynchronously (in a
      later task) â€“ if ever.

   The following code demonstrates that:

   .. code:: javascript

      function asyncFunc() {
      console.log('asyncFunc');
      return new Promise(
         (resolve, _reject) => {
            console.log('new Promise()');
            resolve();
         });
      }
      console.log('START');
      asyncFunc()
      .then(() => {
         console.log('.then()'); // (A)
      });
      console.log('END');

   Output:

   ::

      START
      asyncFunc
      new Promise()
      END
      .then()

   We can see that the callback of ``new Promise()`` is executed before the end of
   the code, while the result is delivered later (line A).

   Benefits of this approach:

   -  Starting synchronously helps avoid race conditions because we can rely on the
      order in which Promise-based functions begin. There is an example `in the
      next chapter <#fire-and-forget-await>`__, where text
      is written to a file and race conditions are avoided.

   -  Chaining Promises wonâ€™t starve other tasks of processing time because before
      a Promise is settled, there will always be a break, during which the event
      loop can run.

   -  Promise-based functions always return results asynchronously; we can be sure
      that there is never a synchronous return. This kind of predictability makes
      code easier to work with.

   .. container:: boxout

      |Icon â€œexternalâ€|â€‚**More information on this approach**

      .. container:: boxout-vspace

      `â€œDesigning APIs for
      Asynchronyâ€ <http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony>`__
      by Isaac Z. Schlueter



.. _promise-combinators:

42.5â€ƒPromise combinator functions: working with Arrays of Promises
-------------------------------------------------------------------

42.5.1â€ƒWhat is a Promise combinator function?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The `combinator pattern <https://wiki.haskell.org/Combinator_pattern>`__ is a
   pattern in functional programming for building structures. It is based on two
   kinds of functions:

   -  *Primitive functions* (short: *primitives*) create atomic pieces.
   -  *Combinator functions* (short: *combinators*) combine atomic and/or compound
      pieces to create compound pieces.

   When it comes to JavaScript Promises:

   -  Primitive functions include: ``Promise.resolve()``, ``Promise.reject()``

   -  Combinators include: ``Promise.all()``, ``Promise.race()``,
      ``Promise.any()``, ``Promise.allSettled()``. In each of these cases:

      -  Input is an iterable over zero or more Promises.
      -  Output is a single Promise.

   Next, weâ€™ll take a closer look at the mentioned Promise combinators.



.. _Promise.all:

42.5.2â€ƒ``Promise.all()``
~~~~~~~~~~~~~~~~~~~~~~~~~

   This is the type signature of ``Promise.all()``:

   .. code:: javascript
      :name: language-ts

      Promise.all<T>(promises: Iterable<Promise<T>>): Promise<Array<T>>

   ``Promise.all()`` returns a Promise which is:

   -  Fulfilled if all ``promises`` are fulfilled.

      -  Then its fulfillment value is an Array with the fulfillment values of
         ``promises``.

   -  Rejected if at least one Promise is rejected.

      -  Then its rejection value is the rejection value of that Promise.

   This is a quick demo of the output Promise being fulfilled:

   .. code:: javascript

      const promises = [
      Promise.resolve('result a'),
      Promise.resolve('result b'),
      Promise.resolve('result c'),
      ];
      Promise.all(promises)
      .then((arr) => assert.deepEqual(
         arr, ['result a', 'result b', 'result c']
      ));

   The following example demonstrates what happens if at least one of the input
   Promises is rejected:

   .. code:: javascript

      const promises = [
      Promise.resolve('result a'),
      Promise.resolve('result b'),
      Promise.reject('ERROR'),
      ];
      Promise.all(promises)
      .catch((err) => assert.equal(
         err, 'ERROR'
      ));

   `Figure 42.2 <#fig:combinator-promise-all>`__ illustrates how ``Promise.all()``
   works.

   .. figure:: https://exploringjs.com/js/book/img-book/promises/combinator-promise-all.svg
      name: fig:combinator-promise-all
      :width: 266px
      :height: 205px

      Figure 42.2: The Promise combinator ``Promise.all()``.



.. _asynchronous-map-via-promise-all:

42.5.2.1â€ƒAsynchronous ``.map()`` via ``Promise.all()``
'''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Array transformation methods such as ``.map()``, ``.filter()``, etc., are made
   for synchronous computations. For example:

   .. code:: javascript

      function timesTwoSync(x) {
      return 2 * x;
      }
      const arr = [1, 2, 3];
      const result = arr.map(timesTwoSync);
      assert.deepEqual(result, [2, 4, 6]);

   What happens if the callback of ``.map()`` is a Promise-based function (a
   function that maps normal values to Promises)? Then the result of ``.map()`` is
   an Array of Promises. Alas, that is not data that normal code can work with.
   Thankfully, we can fix that via ``Promise.all()``: It converts an Array of
   Promises into a Promise that is fulfilled with an Array of normal values.

   .. code:: javascript

      function timesTwoAsync(x) {
      return new Promise(resolve => resolve(x * 2));
      }
      const arr = [1, 2, 3];
      const promiseArr = arr.map(timesTwoAsync);
      Promise.all(promiseArr)
      .then(result => {
         assert.deepEqual(result, [2, 4, 6]);
      });



.. _promise-all-download-text:

42.5.2.2â€ƒA more realistic ``.map()`` example
'''''''''''''''''''''''''''''''''''''''''''''

   Next, weâ€™ll use ``.map()`` and ``Promise.all()`` to downlooad text files from
   the web. For that, we need the following tool function:

   .. code:: javascript

      function downloadText(url) {
      return fetch(url)
         .then((response) => { // (A)
            if (!response.ok) { // (B)
            throw new Error(response.statusText);
            }
            return response.text(); // (C)
         });
      }

   ``downloadText()`` uses the Promise-based `fetch
   API <https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch>`__
   to download a text file as a string:

   -  First, it asynchronously retrieves a ``response`` (line A).
   -  ``response.ok`` (line B) checks if there were errors such as â€œfile not
      foundâ€.
   -  If there werenâ€™t any, we use ``.text()`` (line C) to retrieve the content of
      the file as a string.

   In the following example, we download two text files:

   .. code:: javascript

      const urls = [
      'http://example.com/first.txt',
      'http://example.com/second.txt',
      ];

      const promises = urls.map(
      url => downloadText(url));

      Promise.all(promises)
      .then(
         (arr) => assert.deepEqual(
            arr, ['First!', 'Second!']
         ));



.. _a-simple-implementation-of-promise-all:

42.5.2.3â€ƒA simple implementation of ``Promise.all()``
''''''''''''''''''''''''''''''''''''''''''''''''''''''

   This is a simplified implementation of ``Promise.all()`` (e.g., it performs no
   safety checks):

   .. code:: javascript

      function all(iterable) {
      return new Promise((resolve, reject) => {
         let elementCount = 0;
         let result;

         let index = 0;
         for (const promise of iterable) {
            // Preserve the current value of `index`
            const currentIndex = index;
            promise.then(
            (value) => {
               result[currentIndex] = value;
               elementCount++;
               if (elementCount === result.length) {
                  resolve(result); // (A)
               }
            },
            (err) => {
               reject(err); // (B)
            });
            index++;
         }
         if (index === 0) {
            resolve([]);
            return;
         }
         // Now we know how many Promises there are in `iterable`.
         // We can wait until now with initializing `result` because
         // the callbacks of .then() are executed asynchronously.
         result = new Array(index);
      });
      }

   The two main locations where the result Promise is settled are line A and line
   B. After one of them settled, the other canâ€™t change the settlement value
   anymore because a Promise can only be settled once.



.. _Promise.race:

42.5.3â€ƒ``Promise.race()``
~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is the type signature of ``Promise.race()``:

   .. code:: javascript
      :name: language-ts

      Promise.race<T>(promises: Iterable<Promise<T>>): Promise<T>

   ``Promise.race()`` returns a Promise ``q`` which is settled as soon as the first
   Promise ``p`` among ``promises`` is settled. ``q`` has the same settlement value
   as ``p``.

   In the following demo, the settlement of the fulfilled Promise (line A) happens
   before the settlement of the rejected Promise (line B). Therefore, the result is
   also fulfilled (line C).

   .. code:: javascript

      const promises = [
      new Promise((resolve, reject) =>
         setTimeout(() => resolve('result'), 100)), // (A)
      new Promise((resolve, reject) =>
         setTimeout(() => reject('ERROR'), 200)), // (B)
      ];
      Promise.race(promises)
      .then((result) => assert.equal( // (C)
         result, 'result'));

   In the next demo, the rejection happens first:

   .. code:: javascript

      const promises = [
      new Promise((resolve, reject) =>
         setTimeout(() => resolve('result'), 200)),
      new Promise((resolve, reject) =>
         setTimeout(() => reject('ERROR'), 100)),
      ];
      Promise.race(promises)
      .then(
         (result) => assert.fail(),
         (err) => assert.equal(
            err, 'ERROR'));

   Note that the Promise returned by ``Promise.race()`` is settled as soon as the
   first among its input Promises is settled. That means that the result of
   ``Promise.race([])`` is never settled.

   `Figure 42.3 <#fig:combinator-promise-race>`__ illustrates how
   ``Promise.race()`` works.

   .. figure:: https://exploringjs.com/js/book/img-book/promises/combinator-promise-race.svg
      name: fig:combinator-promise-race
      :width: 265px
      :height: 205px

      Figure 42.3: The Promise combinator ``Promise.race()``.



.. _timing-out-via-race:

42.5.3.1â€ƒUsing ``Promise.race()`` to time out a Promise
''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   In this section, we are going to use ``Promise.race()`` to time out Promises. We
   will be using the following helper functions:

   .. code:: javascript

      /**
      * Returns a Promise that is resolved with `value`
      * after `ms` milliseconds.
      */
      function resolveAfter(ms, value=undefined) {
      return new Promise((resolve, _reject) => {
         setTimeout(() => resolve(value), ms);
      });
      }

      /**
      * Returns a Promise that is rejected with `reason`
      * after `ms` milliseconds.
      */
      function rejectAfter(ms, reason=undefined) {
      return new Promise((_resolve, reject) => {
         setTimeout(() => reject(reason), ms);
      });
      }

   This function times out a Promise:

   .. code:: javascript

      function timeout(timeoutInMs, promise) {
      return Promise.race([
         promise,
         rejectAfter(timeoutInMs,
            new Error('Operation timed out')
         ),
      ]);
      }

   ``timeout()`` returns a Promise whose settlement is the same as the one of
   whichever Promise settles first among the following two:

   #. The parameter ``promise``
   #. A Promise that is rejected after ``timeoutInMs`` milliseconds

   To produce the second Promise, ``timeout()`` uses the fact that resolving a
   pending Promise with a rejected Promise leads to the former being rejected.

   Letâ€™s see ``timeout()`` in action. Here, the input Promise is fulfilled before
   the timeout. Therefore, the output Promise is fulfilled.

   .. code:: javascript

      timeout(200, resolveAfter(100, 'Result!'))
      .then(result => assert.equal(result, 'Result!'));

   Here, the timeout happens before the input Promise is fulfilled. Therefore, the
   output Promise is rejected.

   .. code:: javascript

      timeout(100, resolveAfter(200, 'Result!'))
      .catch(err => assert.deepEqual(err, new Error('Operation timed out')));

   It is important to understand what â€œtiming out a Promiseâ€ really means:

   -  If the input Promise is settled quickly enough, its settlement is passed on
      to the output Promise.
   -  If it isnâ€™t settled quickly enough, the output Promise is rejected.

   That is, timing out only prevents the input Promise from affecting the output
   (since a Promise can only be settled once). But it does not stop the
   asynchronous operation that produced the input Promise.



.. _a-simple-implementation-of-promise-race:

42.5.3.2â€ƒA simple implementation of ``Promise.race()``
'''''''''''''''''''''''''''''''''''''''''''''''''''''''

   This is a simplified implementation of ``Promise.race()`` (e.g., it performs no
   safety checks):

   .. code:: javascript

      function race(iterable) {
      return new Promise((resolve, reject) => {
         for (const promise of iterable) {
            promise.then(
            (value) => {
               resolve(value); // (A)
            },
            (err) => {
               reject(err); // (B)
            });
         }
      });
      }

   The result Promise is settled in either line A or line B. Once it is, the
   settlement value canâ€™t be changed anymore.



.. _Promise.any:

42.5.4â€ƒ``Promise.any()`` [ES2021]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is the type signature of ``Promise.any()``:

   .. code:: javascript
      :name: language-ts

      Promise.any<T>(promises: Iterable<Promise<T>>): Promise<T>

   ``Promise.any()`` returns a Promise ``p``. How it is settled, depends on the
   parameter ``promises`` (which refers to an iterable over Promises):

   -  If and when the first Promise is fulfilled, ``p`` is resolved with that
      Promise.
   -  If all Promises are rejected, ``p`` is rejected with an instance of
      ``AggregateError`` that contains all rejection values.

   `Figure 42.4 <#fig:combinator-promise-any>`__ illustrates how ``Promise.any()``
   works.

   .. figure:: https://exploringjs.com/js/book/img-book/promises/combinator-promise-any.svg
      name: fig:combinator-promise-any
      :width: 265px
      :height: 204px

      Figure 42.4: The Promise combinator ``Promise.any()``.



.. _AggregateError:

42.5.4.1â€ƒ``AggregateError`` [ES2021]
'''''''''''''''''''''''''''''''''''''

   This is the type signature of ``AggregateError`` (a subclass of
   `Error <#class-Error>`__):

   .. code:: javascript
      :name: language-ts

      class AggregateError extends Error {
      // Instance properties (complementing the ones of Error)
      errors: Array<any>;

      constructor(
         errors: Iterable<any>,
         message: string = '',
         options?: ErrorOptions // ES2022
      );
      }
      interface ErrorOptions {
      cause?: any; // ES2022
      }

42.5.4.2â€ƒTwo first examples
''''''''''''''''''''''''''''

   This is what happens if one Promise is fulfilled:

   .. code:: javascript

      const promises = [
      Promise.reject('ERROR A'),
      Promise.reject('ERROR B'),
      Promise.resolve('result'),
      ];
      Promise.any(promises)
      .then((result) => assert.equal(
         result, 'result'
      ));

   This is what happens if all Promises are rejected:

   .. code:: javascript

      const promises = [
      Promise.reject('ERROR A'),
      Promise.reject('ERROR B'),
      Promise.reject('ERROR C'),
      ];
      Promise.any(promises)
      .catch((aggregateError) => assert.deepEqual(
         aggregateError.errors,
         ['ERROR A', 'ERROR B', 'ERROR C']
      ));



.. _promise-any-vs-promise-all:

42.5.4.3â€ƒ``Promise.any()`` vs. ``Promise.all()``
'''''''''''''''''''''''''''''''''''''''''''''''''

   There are two ways in which ``Promise.any()`` and ``Promise.all()`` can be
   compared:

   -  They are inverses of each other:

      -  ``Promise.all()``: First input rejection rejects the result Promise or its
         fulfillment value is an Array with input fulfillment values.
      -  ``Promise.any()``: First input fulfillment fulfills the result Promise or
         its rejection value is an Array with input rejection values (inside an
         error object).

   -  They have different focuses:

      -  ``Promise.all()`` is interested in *all* fulfillments. The opposite case
         (at least one rejection) leads to a rejection.
      -  ``Promise.any()`` is interested in the first fulfillment. The opposite
         case (only rejections) leads to a rejection.



.. _promise-any-vs-promise-race:

42.5.4.4â€ƒ``Promise.any()`` vs. ``Promise.race()``
''''''''''''''''''''''''''''''''''''''''''''''''''

   ``Promise.any()`` and ``Promise.race()`` are also related, but interested in
   different things:

   -  ``Promise.race()`` is interested in settlements. The Promise which is settled
      first, â€œwinsâ€. In other words: We want to know about the asynchronous
      computation that terminates first.
   -  ``Promise.any()`` is interested in fulfillments. The Promise which is
      fulfilled first, â€œwinsâ€. In other words: We want to know about the
      asynchronous computation that succeeds first.

   The main â€“ relatively rare â€“ use case for ``.race()`` is timing out Promises.
   The use cases for ``.any()`` are broader. Weâ€™ll look at them next.



.. _use-cases-for-promise-any:

42.5.4.5â€ƒUse cases for ``Promise.any()``
'''''''''''''''''''''''''''''''''''''''''

   We use ``Promise.any()`` if we have multiple asynchronous computations and we
   are only interested in the first successful one. In a way, we let the
   computations compete with each other and use whichever one is fastest.

   The following code demonstrates what that looks like when downloading resources:

   .. code:: javascript

      const resource = await Promise.any([
      fetch('http://example.com/first.txt')
         .then(response => response.text()),
      fetch('http://example.com/second.txt')
         .then(response => response.text()),
      ]);

   The same pattern enables us to use whichever module downloads more quickly:

   .. code:: javascript

      const mylib = await Promise.any([
      import('https://primary.example.com/mylib'),
      import('https://secondary.example.com/mylib'),
      ]);

   For comparison, this is the code weâ€™d use if the secondary server is only a
   fallback â€“ in case the primary server fails:

   .. code:: javascript

      let mylib;
      try {
      mylib = await import('https://primary.example.com/mylib');
      } catch {
      mylib = await import('https://secondary.example.com/mylib');
      }



.. _how-would-we-implement-promise-any:

42.5.4.6â€ƒHow would we implement ``Promise.any()``?
'''''''''''''''''''''''''''''''''''''''''''''''''''

   A simple implementation of ``Promise.any()`` is basically a mirror version of
   the implementation of ``Promise.all()``.



.. _Promise.allSettled:

42.5.5â€ƒ``Promise.allSettled()`` [ES2020]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This time, the type signatures are a little more complicated. Feel free to skip
   ahead to the first demo, which should be easier to understand.

   This is the type signature of ``Promise.allSettled()``:

   .. code:: javascript
      :name: language-ts

      Promise.allSettled<T>(promises: Iterable<Promise<T>>)
      : Promise<Array<SettlementObject<T>>>

   It returns a Promise for an Array whose elements have the following type
   signature:

   .. code:: javascript
      :name: language-ts

      type SettlementObject<T> = FulfillmentObject<T> | RejectionObject;

      interface FulfillmentObject<T> {
      status: 'fulfilled';
      value: T;
      }

      interface RejectionObject {
      status: 'rejected';
      reason: unknown;
      }

   ``Promise.allSettled()`` returns a Promise ``out``. Once all ``promises`` are
   settled, ``out`` is fulfilled with an Array. Each element ``e`` of that Array
   corresponds to one Promise ``p`` of ``promises``:

   -  If ``p`` is fulfilled with the fulfillment value ``v``, then ``e`` is

      .. code:: javascript

         { status: 'fulfilled', value:  v }

   -  If ``p`` is rejected with the rejection value ``r``, then ``e`` is

      .. code:: javascript

         { status: 'rejected',  reason: r }

   Unless there is an error when iterating over ``promises``, the output Promise
   ``out`` is never rejected.

   `Figure 42.5 <#fig:combinator-promise-all-settled>`__ illustrates how
   ``Promise.allSettled()`` works.

   .. figure:: https://exploringjs.com/js/book/img-book/promises/combinator-promise-all-settled.svg
      name: fig:combinator-promise-all-settled
      :width: 374px
      :height: 220px

      Figure 42.5: The Promise combinator ``Promise.allSettled()``.



.. _a-first-demo-of-promise-allsettled:

42.5.5.1â€ƒA first demo of ``Promise.allSettled()``
''''''''''''''''''''''''''''''''''''''''''''''''''

   This is a quick first demo of how ``Promise.allSettled()`` works:

   .. code:: javascript

      Promise.allSettled([
      Promise.resolve('a'),
      Promise.reject('b'),
      ])
      .then(arr => assert.deepEqual(arr, [
      { status: 'fulfilled', value:  'a' },
      { status: 'rejected',  reason: 'b' },
      ]));



.. _a-longer-example-for-promise-allsettled:

42.5.5.2â€ƒA longer example for ``Promise.allSettled()``
'''''''''''''''''''''''''''''''''''''''''''''''''''''''

   The next example is similar to `the ``.map()`` plus ``Promise.all()``
   example <#promise-all-download-text>`__ (from which we are borrowing the
   function ``downloadText()``): We are downloading multiple text files whose URLs
   are stored in an Array. However, this time, we donâ€™t want to stop when there is
   an error, we want to keep going. ``Promise.allSettled()`` allows us to do that:

   .. code:: javascript

      const urls = [
      'http://example.com/exists.txt',
      'http://example.com/missing.txt',
      ];

      const result = Promise.allSettled(
      urls.map(u => downloadText(u))
      );
      result.then(
      (arr) => {
         assert.deepEqual(
            arr,
            [
            {
               status: 'fulfilled',
               value: 'Hello!',
            },
            {
               status: 'rejected',
               reason: new Error(),
            },
            ]
         )
      }
      );



.. _a-simple-implementation-of-promise-allsettled:

42.5.5.3â€ƒA simple implementation of ``Promise.allSettled()``
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   This is a simplified implementation of ``Promise.allSettled()`` (e.g., it
   performs no safety checks):

   .. code:: javascript

      function allSettled(iterable) {
      return new Promise((resolve, reject) => {
         let elementCount = 0;
         let result;

         function addElementToResult(i, elem) {
            result[i] = elem;
            elementCount++;
            if (elementCount === result.length) {
            resolve(result);
            }
         }

         let index = 0;
         for (const promise of iterable) {
            // Capture the current value of `index`
            const currentIndex = index;
            promise.then(
            (value) => addElementToResult(
               currentIndex, {
                  status: 'fulfilled',
                  value
               }),
            (reason) => addElementToResult(
               currentIndex, {
                  status: 'rejected',
                  reason
               }));
            index++;
         }
         if (index === 0) {
            resolve([]);
            return;
         }
         // Now we know how many Promises there are in `iterable`.
         // We can wait until now with initializing `result` because
         // the callbacks of .then() are executed asynchronously.
         result = new Array(index);
      });
      }



.. _short-circuiting:

42.5.6â€ƒShort-circuiting (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   For a Promise combinator, *short-circuiting* means that the output Promise is
   settled early â€“ before all input Promises are settled. The following combinators
   short-circuit:

   -  ``Promise.all()``: The output Promise is rejected as soon as one input
      Promise is rejected.
   -  ``Promise.race()``: The output Promise is settled as soon as one input
      Promise is settled.
   -  ``Promise.any()``: The output Promise is fulfilled as soon as one input
      Promise is fulfilled.

   Once again, settling early does not mean that the operations behind the ignored
   Promises are stopped. It just means that their settlements are ignored.



.. _concurrency-and-promise-all:

42.6â€ƒConcurrency and ``Promise.all()`` (advanced)
--------------------------------------------------



.. _sequential-execution-vs-concurrent-execution:

42.6.1â€ƒSequential execution vs. concurrent execution
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Consider the following code:

   .. code:: javascript

      const asyncFunc1 = () => Promise.resolve('one');
      const asyncFunc2 = () => Promise.resolve('two');

      asyncFunc1()
      .then(result1 => {
         assert.equal(result1, 'one');
         return asyncFunc2();
      })
      .then(result2 => {
         assert.equal(result2, 'two');
      });

   Using ``.then()`` in this manner executes Promise-based functions
   *sequentially*: only after the result of ``asyncFunc1()`` is settled will
   ``asyncFunc2()`` be executed.

   ``Promise.all()`` helps execute Promise-based functions more concurrently:

   .. code:: javascript

      Promise.all([asyncFunc1(), asyncFunc2()])
      .then(arr => {
         assert.deepEqual(arr, ['one', 'two']);
      });



.. _focus-on-async-start:

42.6.2â€ƒConcurrency tip: focus on when operations start
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Tip for determining how â€œconcurrentâ€ asynchronous code is: Focus on when
   asynchronous operations start, not on how their Promises are handled.

   For example, each of the following functions executes ``asyncFunc1()`` and
   ``asyncFunc2()`` concurrently because they are started at nearly the same time.

   .. code:: javascript

      function concurrentAll() {
      return Promise.all([asyncFunc1(), asyncFunc2()]);
      }

      function concurrentThen() {
      const p1 = asyncFunc1();
      const p2 = asyncFunc2();
      return p1.then(r1 => p2.then(r2 => [r1, r2]));
      }

   On the other hand, both of the following functions execute ``asyncFunc1()`` and
   ``asyncFunc2()`` sequentially: ``asyncFunc2()`` is only invoked after the
   Promise of ``asyncFunc1()`` is fulfilled.

   .. code:: javascript

      function sequentialThen() {
      return asyncFunc1()
         .then(r1 => asyncFunc2()
            .then(r2 => [r1, r2]));
      }

      function sequentialAll() {
      const p1 = asyncFunc1();
      const p2 = p1.then(() => asyncFunc2());
      return Promise.all([p1, p2]);
      }



.. _promise-all-is-fork-join:

42.6.3â€ƒ``Promise.all()`` is fork-join
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``Promise.all()`` is loosely related to the concurrency pattern â€œfork joinâ€.
   Letâ€™s revisit an example that we have encountered
   `previously <#promise-all-download-text>`__:

   .. code:: javascript

      Promise.all([
         // (A) fork
         downloadText('http://example.com/first.txt'),
         downloadText('http://example.com/second.txt'),
      ])
      // (B) join
      .then(
         (arr) => assert.deepEqual(
            arr, ['First!', 'Second!']
         ));

   -  Fork: In line A, we are forking two asynchronous computations and executing
      them concurrently.
   -  Join: In line B, we are joining these computations into a single â€œthreadâ€
      which is started once all of them are done.

42.7â€ƒTips for chaining Promises
--------------------------------

   This section gives tips for chaining Promises.

42.7.1â€ƒChaining mistake: losing theÂ tail
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Problem:

   .. code:: javascript

      // Donâ€™t do this
      function foo() {
      const promise = asyncFunc();
      promise.then(result => {
         // Â·Â·Â·
      });

      return promise;
      }

   Computation starts with the Promise returned by ``asyncFunc()``. But afterward,
   computation continues and another Promise is created via ``.then()``. ``foo()``
   returns the former Promise, but should return the latter. This is how to fix it:

   .. code:: javascript

      function foo() {
      const promise = asyncFunc();
      return promise.then(result => {
         // Â·Â·Â·
      });
      }

42.7.2â€ƒChaining mistake: nesting
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Problem:

   .. code:: javascript

      // Donâ€™t do this
      asyncFunc1()
      .then(result1 => {
         return asyncFunc2()
         .then(result2 => { // (A)
            // Â·Â·Â·
         });
      });

   The ``.then()`` in line A is nested. A flat structure would be better:

   .. code:: javascript

      asyncFunc1()
      .then(result1 => {
         return asyncFunc2();
      })
      .then(result2 => {
         // Â·Â·Â·
      });

42.7.3â€ƒChaining mistake: more nesting than necessary
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is another example of avoidable nesting:

   .. code:: javascript

      // Donâ€™t do this
      asyncFunc1()
      .then(result1 => {
         if (result1 < 0) {
            return asyncFuncA()
            .then(resultA => 'Result: ' + resultA);
         } else {
            return asyncFuncB()
            .then(resultB => 'Result: ' + resultB);
         }
      });

   We can once again get a flat structure:

   .. code:: javascript

      asyncFunc1()
      .then(result1 => {
         return result1 < 0 ? asyncFuncA() : asyncFuncB();
      })
      .then(resultAB => {
         return 'Result: ' + resultAB;
      });

42.7.4â€ƒNot all nesting is bad
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In the following code, we actually benefit from nesting:

   .. code:: javascript

      db.open()
      .then(connection => { // (A)
         return connection.select({ name: 'Jane' })
            .then(result => { // (B)
            // Process result
            // Use `connection` to make more queries
            })
            // Â·Â·Â·
            .finally(() => {
            connection.close(); // (C)
            });
      })

   We are receiving an asynchronous result in line A. In line B, we are nesting so
   that we have access to variable ``connection`` inside the callback and in line
   C.

42.7.5â€ƒChaining mistake: creating Promises instead of chaining
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Problem:

   .. code:: javascript

      // Donâ€™t do this
      class Model {
      insertInto(db) {
         return new Promise((resolve, reject) => { // (A)
            db.insert(this.fields)
            .then(resultCode => {
               this.notifyObservers({event: 'created', model: this});
               resolve(resultCode);
            }).catch(err => {
               reject(err);
            })
         });
      }
      // Â·Â·Â·
      }

   In line A, we are creating a Promise to deliver the result of ``db.insert()``.
   That is unnecessarily verbose and can be simplified:

   .. code:: javascript

      class Model {
      insertInto(db) {
         return db.insert(this.fields)
            .then(resultCode => {
            this.notifyObservers({event: 'created', model: this});
            return resultCode;
            });
      }
      // Â·Â·Â·
      }

   The key idea is that we donâ€™t need to create a Promise; we can return the result
   of the ``.then()`` call. An additional benefit is that we donâ€™t need to catch
   and re-reject the failure of ``db.insert()``. We simply pass its rejection on to
   the caller of ``.insertInto()``.

42.8â€ƒQuick reference: Promise combinator functions
---------------------------------------------------

   Unless noted otherwise, the functionality was introduced in ECMAScript 6 (which
   is when Promises were added to the language).

   Glossary:

   -  *Short-circuiting*: In some cases, the output Promise can be settled early
      (before every input Promise is settled). More information on how this works
      is given later.



.. _qref-Promise.all:

42.8.1â€ƒ``Promise.all()``
~~~~~~~~~~~~~~~~~~~~~~~~~

   .. code:: javascript
      :name: language-ts

      Promise.all<T>(promises: Iterable<Promise<T>>)
      : Promise<Array<T>>

   -  **Fulfillment** of ``P``: if all input Promises are fulfilled.

      -  Value: Array with the fulfillment values of the input Promises

   -  **Rejection** of ``P``: if one input Promise is rejected.

      -  Value: rejection value of the input Promise

   -  Short-circuits: yes
   -  Use case: processing Arrays with Promises (rejections terminate processing)



.. _qref-Promise.race:

42.8.2â€ƒ``Promise.race()``
~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. code:: javascript
      :name: language-ts

      Promise.race<T>(promises: Iterable<Promise<T>>)
      : Promise<T>

   -  **Settlement** of ``P``: if the first input Promise is settled.

      -  Value: settlement value of the input Promise

   -  Short-circuits: yes
   -  Use case: reacting to the first settlement among multiple Promises



.. _qref-Promise.any:

42.8.3â€ƒ``Promise.any()`` [ES2021]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. code:: javascript
      :name: language-ts

      Promise.any<T>(promises: Iterable<Promise<T>>): Promise<T>

   -  **Fulfillment** of ``P``: if one input Promise is fulfilled.

      -  Value: fulfillment value of the input Promise

   -  **Rejection** of ``P``: if all input Promises are rejected.

      -  Value: ``AggregateError`` that contains the rejection values of the input
         Promises.

   -  Short-circuits: yes
   -  Use case: Among several asynchronous computations, we are only interested in
      the first successful one. That is, we are trying several approaches and the
      fastest one should win.

   This is the type signature of ``AggregateError`` (a few members were omitted):

   .. code:: javascript
      :name: language-ts

      class AggregateError {
      constructor(errors: Iterable<any>, message: string);
      get errors(): Array<any>;
      get message(): string;
      }



.. _qref-Promise.allSettled:

42.8.4â€ƒ``Promise.allSettled()`` [ES2020]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. code:: javascript
      :name: language-ts

      Promise.allSettled<T>(promises: Iterable<Promise<T>>)
      : Promise<Array<SettlementObject<T>>>

   -  **Fulfillment** of ``P``: if all input Promise are settled.

      -  Value: Array with one *settlement object* for each input Promise. A
         settlement object contains the kind of settlement and the settlement
         value.

   -  **Rejection** of ``P``: if there is an error when iterating over the input
      Promises.
   -  Short-circuits: no
   -  Use case: processing Arrays with Promises (rejections donâ€™t terminate
      processing)

   This is the type signature of ``SettlementObject``:

   .. code:: javascript
      :name: language-ts

      type SettlementObject<T> = FulfillmentObject<T> | RejectionObject;

      interface FulfillmentObject<T> {
      status: 'fulfilled';
      value: T;
      }

      interface RejectionObject {
      status: 'rejected';
      reason: unknown;
      }

   `Comments <https://github.com/rauschma/exploring-js/issues/27>`__



.. _ch_async-functions:

43â€ƒAsync functions [ES2017]
============================

   #. `43.1â€ƒAsync functions: the basics <#async-functions-the-basics>`__

      #. `43.1.1â€ƒAsync constructs <#async-constructs>`__

   #. `43.2â€ƒReturning from async functions <#returning-from-async-functions>`__

      #. `43.2.1â€ƒAsync functions always return Promises <#async-functions-always-return-promises>`__
      #. `43.2.2â€ƒReturned Promises are not wrapped <#returned-promises-are-not-wrapped>`__
      #. `43.2.3â€ƒExecuting async functions: synchronous start, asynchronous settlement (advanced) <#async-funcs-sync-start-async-settlement>`__

   #. `43.3â€ƒawait: working with Promises <#await-working-with-promises>`__

      #. `43.3.1â€ƒawait and fulfilled Promises <#await-and-fulfilled-promises>`__
      #. `43.3.2â€ƒawait and rejected Promises <#await-and-rejected-promises>`__
      #. `43.3.3â€ƒawait is shallow (we canâ€™t use it in callbacks) <#await-is-shallow-we-can-t-use-it-in-callbacks>`__
      #. `43.3.4â€ƒUsing await at the top levels of modules [ES2022] <#using-await-at-the-top-levels-of-modules>`__

   #. `43.4â€ƒ(Advanced) <#advanced-5>`__
   #. `43.5â€ƒConcurrency and await <#concurrency-and-await>`__

      #. `43.5.1â€ƒawait: running asynchronous functions sequentially <#await-sequentially>`__
      #. `43.5.2â€ƒawait: running asynchronous functions concurrently <#await-concurrently>`__

   #. `43.6â€ƒTips for using async functions <#tips-for-using-async-functions>`__

      #. `43.6.1â€ƒWe donâ€™t need await if we â€œfire and forgetâ€ <#fire-and-forget-await>`__
      #. `43.6.2â€ƒIt can make sense to await and ignore the result <#it-can-make-sense-to-await-and-ignore-the-result>`__

   Roughly, *async functions* provide better syntax for code that uses Promises. In
   order to use async functions, we should therefore understand Promises. They are
   explained in `the previous chapter <#ch_promises>`__.

43.1â€ƒAsync functions: the basics
---------------------------------

   Consider the following async function:

   .. code:: javascript

      async function fetchJsonAsync(url) {
      try {
         const request = await fetch(url); // async
         const text = await request.text(); // async
         return JSON.parse(text); // sync
      }
      catch (error) {
         assert.fail(error);
      }
      }

   The previous, rather synchronous-looking code is equivalent to the following
   code that uses Promises directly:

   .. code:: javascript

      function fetchJsonViaPromises(url) {
      return fetch(url) // async
      .then(request => request.text()) // async
      .then(text => JSON.parse(text)) // sync
      .catch(error => {
         assert.fail(error);
      });
      }

   A few observations about the async function ``fetchJsonAsync()``:

   -  Async functions are marked with the keyword ``async``.

   -  Inside the body of an async function, we write Promise-based code as if it
      were synchronous. We only need to apply the ``await`` operator whenever a
      value is a Promise. That operator pauses the async function and resumes it
      once the Promise is settled:

      -  If the Promise is fulfilled, ``await`` returns the fulfillment value.
      -  If the Promise is rejected, ``await`` throws the rejection value.

   -  The result of an async function is always a Promise:

      -  Any value that is returned (explicitly or implicitly) is used to fulfill
         the Promise.
      -  Any exception that is thrown is used to reject the Promise.

   Both ``fetchJsonAsync()`` and ``fetchJsonViaPromises()`` are called in exactly
   the same way, like this:

   .. code:: javascript

      fetchJsonAsync('http://example.com/person.json')
      .then(obj => {
      assert.deepEqual(obj, {
         first: 'Jane',
         last: 'Doe',
      });
      });

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Async functions are as Promise-based as functions that use
      Promises directly**

      .. container:: boxout-vspace

      From the outside, it is virtually impossible to tell the difference between
      an async function and a function that returns a Promise.

43.1.1â€ƒAsync constructs
~~~~~~~~~~~~~~~~~~~~~~~~

   JavaScript has the following async versions of synchronous callable entities.
   Their roles are always either real function or method.

   .. code:: javascript

      // Async function declaration
      async function func1() {}

      // Async function expression
      const func2 = async function () {};

      // Async arrow function
      const func3 = async () => {};

      // Async method definition in an object literal
      const obj = { async m() {} };

      // Async method definition in a class definition
      class MyClass { async m() {} }

   .. container:: boxout

      |Icon â€œdetailsâ€|â€‚**Asynchronous functions vs. async functions**

      .. container:: boxout-vspace

      The difference between the terms *asynchronous function* and *async function*
      is subtle, but important:

      -  An *asynchronous function* is any function that delivers its result
         asynchronously â€“ for example, a callback-based function or a Promise-based
         function.

      -  An *async function* is defined via special syntax, involving the keywords
         ``async`` and ``await``. It is also called async/await due to these two
         keywords. Async functions are based on Promises and therefore also
         asynchronous functions (which is somewhat confusing).

43.2â€ƒReturning from async functions
------------------------------------

43.2.1â€ƒAsync functions always return Promises
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Each async function always returns a Promise.

   Inside the async function, we fulfill the result Promise via ``return`` (line
   A):

   .. code:: javascript

      async function asyncFunc() {
      return 123; // (A)
      }

      asyncFunc()
      .then(result => {
      assert.equal(result, 123);
      });

   As usual, if we donâ€™t explicitly return anything, ``undefined`` is returned for
   us:

   .. code:: javascript

      async function asyncFunc() {
      }

      asyncFunc()
      .then(result => {
      assert.equal(result, undefined);
      });

   We reject the result Promise via ``throw`` (line A):

   .. code:: javascript

      async function asyncFunc() {
      throw new Error('Problem!'); // (A)
      }

      asyncFunc()
      .catch(err => {
      assert.deepEqual(err, new Error('Problem!'));
      });

43.2.2â€ƒReturned Promises are not wrapped
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If we return a Promise ``p`` from an async function, then ``p`` becomes the
   result of the function (or rather, the result â€œlocks inâ€ on ``p`` and behaves
   exactly like it). That is, the Promise is not wrapped in yet another Promise.

   .. code:: javascript

      async function asyncFunc() {
      return Promise.resolve('abc');
      }

      asyncFunc()
      .then(result => assert.equal(result, 'abc'));

   Recall that any Promise ``q`` is treated similarly in the following situations:

   -  ``resolve(q)`` inside ``new Promise((resolve, reject) => { Â·Â·Â· })``
   -  ``return q`` inside ``.then(result => { Â·Â·Â· })``
   -  ``return q`` inside ``.catch(err => { Â·Â·Â· })``



.. _async-funcs-sync-start-async-settlement:

43.2.3â€ƒExecuting async functions: synchronous start, asynchronous settlement (advanced)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Async functions are executed as follows:

   -  The Promise ``resultPromise`` for the result is created when the async
      function is started.
   -  Then the body is executed. There are two ways in which execution can leave
      the body:

      -  **A permanent exit** happens when ``resultPromise`` is settled:

         -  ``return`` fulfills ``resultPromise``.
         -  ``throw`` rejects ``resultPromise``.

      -  **A temporary exit** happens when there is an ``await`` whose operand is a
         Promise ``p``:

         -  The async function is paused and execution leaves it.
         -  It is resumed asynchronously (in a new task) once ``p`` is settled.

   -  Promise ``resultPromise`` is returned after the first (permanent or
      temporary) exit.

   Note that the notification of the settlement of ``resultPromise`` happens
   asynchronously, as is always the case with Promises.

   The following code demonstrates that an async function is started synchronously
   (line A), then the current task finishes (line C), then the result Promise is
   settled â€“ asynchronously (line B).

   .. code:: javascript

      async function asyncFunc() {
      console.log('asyncFunc() starts'); // (A)
      return 'abc';
      }
      asyncFunc().
      then(x => { // (B)
      console.log(`Resolved: ${x}`);
      });
      console.log('Task ends'); // (C)

   Output:

   ::

      asyncFunc() starts
      Task ends
      Resolved: abc

43.3â€ƒ``await``: working with Promises
--------------------------------------

   The ``await`` operator can only be used inside async functions and async
   generators (which are explained in `â€œAsynchronous generatorsâ€
   (Â§44.2) <#async-generators>`__). Its operand is usually a
   Promise and leads to the following steps being performed:

   -  The current async function is paused and returned from. This step is similar
      to how ``yield`` works in `sync
      generators <#ch_sync-generators>`__.
   -  Eventually, the current task is finished and processing of the task queue
      continues.
   -  When and if the Promise is settled, the async function is resumed in a new
      task:

      -  If the Promise is fulfilled, ``await`` returns the fulfillment value.
      -  If the Promise is rejected, ``await`` throws the rejection value.

   Read on to find out more about how ``await`` handles Promises in various states.

43.3.1â€ƒ``await`` and fulfilled Promises
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If its operand ends up being a fulfilled Promise, ``await`` returns its
   fulfillment value:

   .. code:: javascript

      assert.equal(await Promise.resolve('yes!'), 'yes!');

   Non-Promise values are allowed, too, and simply passed on (synchronously,
   without pausing the async function):

   .. code:: javascript

      assert.equal(await 'yes!', 'yes!');

43.3.2â€ƒ``await`` and rejected Promises
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If its operand is a rejected Promise, then ``await`` throws the rejection value:

   .. code:: javascript

      try {
      await Promise.reject(new Error());
      assert.fail(); // we never get here
      } catch (e) {
      assert.equal(e instanceof Error, true);
      }

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Fetch API via async functions**

      .. container:: boxout-vspace

      ``exercises/async-functions/fetch_json2_test.mjs``



.. _await-is-shallow-we-can-t-use-it-in-callbacks:

43.3.3â€ƒ``await`` is shallow (we canâ€™t use it in callbacks)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If we are inside an async function and want to pause it via ``await``, we must
   do so directly within that function; we canâ€™t use it inside a nested function,
   such as a callback. That is, pausing is *shallow*.

   For example, the following code canâ€™t be executed:

   .. code:: javascript

      async function downloadContent(urls) {
      return urls.map((url) => {
         return await httpGet(url); // SyntaxError!
      });
      }

   The reason is that normal arrow functions donâ€™t allow ``await`` inside their
   bodies.

   OK, letâ€™s try an async arrow function then:

   .. code:: javascript

      async function downloadContent(urls) {
      return urls.map(async (url) => {
         return await httpGet(url);
      });
      }

   Alas, this doesnâ€™t work either: Now ``.map()`` (and therefore
   ``downloadContent()``) returns an Array with Promises, not an Array with
   (unwrapped) values.

   One possible solution is to use ``Promise.all()`` to unwrap all Promises:

   .. code:: javascript

      async function downloadContent(urls) {
      const promiseArray = urls.map(async (url) => {
         return await httpGet(url); // (A)
      });
      return await Promise.all(promiseArray);
      }

   Can this code be improved? Yes it can: in line A, we are unwrapping a Promise
   via ``await``, only to re-wrap it immediately via ``return``. If we omit
   ``await``, we donâ€™t even need an async arrow function:

   .. code:: javascript

      async function downloadContent(urls) {
      const promiseArray = urls.map(
         url => httpGet(url));
      return await Promise.all(promiseArray); // (B)
      }

   For the same reason, we can also omit ``await`` in line B.



.. _using-await-at-the-top-levels-of-modules:

43.3.4â€ƒUsing ``await`` at the top levels of modules [ES2022]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We can use ``await`` at the top levels of modules â€“ for example:

   .. code:: javascript

      let mylib;
      try {
      mylib = await import('https://primary.example.com/mylib');
      } catch {
      mylib = await import('https://secondary.example.com/mylib');
      }

   For more information on this feature, see `â€œTop-level ``await`` in modulesâ€
   (Â§29.15) <#top-level-await>`__.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Mapping and filtering asynchronously**

      .. container:: boxout-vspace

      ``exercises/async-functions/map_async_test.mjs``



.. _advanced-5:

43.4â€ƒ(Advanced)
----------------

   All remaining sections are advanced.

43.5â€ƒConcurrency and ``await``
-------------------------------

   In the next two subsections, weâ€™ll use the helper function ``paused()``:

   .. code:: javascript

      /**
      * Resolves after `ms` milliseconds
      */
      function delay(ms) {
      return new Promise((resolve, _reject) => {
         setTimeout(resolve, ms);
      });
      }
      async function paused(id) {
      console.log('START ' + id);
      await delay(10); // pause
      console.log('END ' + id);
      return id;
      }



.. _await-sequentially:

43.5.1â€ƒ``await``: running asynchronous functions sequentially
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If we prefix the invocations of multiple asynchronous functions with ``await``,
   then those functions are executed sequentially:

   .. code:: javascript

      async function sequentialAwait() {
      const result1 = await paused('first');
      assert.equal(result1, 'first');
      
      const result2 = await paused('second');
      assert.equal(result2, 'second');
      }

   Output:

   ::

      START first
      END first
      START second
      END second

   That is, ``paused('second')`` is only started after ``paused('first')`` is
   completely finished.



.. _await-concurrently:

43.5.2â€ƒ``await``: running asynchronous functions concurrently
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If we want to run multiple functions concurrently, we can use the tool method
   ``Promise.all()``:

   .. code:: javascript

      async function concurrentPromiseAll() {
      const result = await Promise.all([
         paused('first'), paused('second')
      ]);
      assert.deepEqual(result, ['first', 'second']);
      }

   Output:

   ::

      START first
      START second
      END first
      END second

   Here, both asynchronous functions are started at the same time. Once both are
   settled, ``await`` gives us either an Array of fulfillment values or â€“ if at
   least one Promise is rejected â€“ an exception.

   Recall from `â€œConcurrency tip: focus on when operations startâ€
   (Â§42.6.2) <#focus-on-async-start>`__ that what counts is when we
   start a Promise-based computation; not how we process its result. Therefore, the
   following code is as â€œconcurrentâ€ as the previous one:

   .. code:: javascript

      async function concurrentAwait() {
      const resultPromise1 = paused('first');
      const resultPromise2 = paused('second');
      
      assert.equal(await resultPromise1, 'first');
      assert.equal(await resultPromise2, 'second');
      }

   Output:

   ::

      START first
      START second
      END first
      END second

43.6â€ƒTips for using async functions
------------------------------------



.. _fire-and-forget-await:

43.6.1â€ƒWe donâ€™t need ``await`` if we â€œfire and forgetâ€
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``await`` is not required when working with a Promise-based function; we only
   need it if we want to pause and wait until the returned Promise is settled. If
   we only want to start an asynchronous operation, then we donâ€™t need it:

   .. code:: javascript

      async function asyncFunc() {
      const writer = openFile('someFile.txt');
      writer.write('hello'); // donâ€™t wait
      writer.write('world'); // donâ€™t wait
      await writer.close(); // wait for file to close
      }

   In this code, we donâ€™t await ``.write()`` because we donâ€™t care when it is
   finished. We do, however, want to wait until ``.close()`` is done.

   Note: Each invocation of ``.write()`` starts synchronously. That prevents race
   conditions.

43.6.2â€ƒIt can make sense to ``await`` and ignore the result
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   It can occasionally make sense to use ``await``, even if we ignore its result â€“
   for example:

   .. code:: javascript

      await longRunningAsyncOperation();
      console.log('Done!');

   Here, we are using ``await`` to join a long-running asynchronous operation. That
   ensures that the logging really happens *after* that operation is done.

   `Comments <https://github.com/rauschma/exploring-js/issues/28>`__



.. _ch_async-iteration:

44â€ƒAsynchronous iteration [ES2018]
===================================

   #. `44.1â€ƒBasic asynchronous iteration <#basic-asynchronous-iteration>`__

      #. `44.1.1â€ƒProtocol: async iteration <#protocol-async-iteration>`__
      #. `44.1.2â€ƒUsing async iteration directly <#using-async-iteration-directly>`__
      #. `44.1.3â€ƒUsing async iteration via for-await-of <#for-await-of>`__

   #. `44.2â€ƒAsynchronous generators <#async-generators>`__

      #. `44.2.1â€ƒExample: creating an async iterable via an async generator <#example-creating-an-async-iterable-via-an-async-generator>`__
      #. `44.2.2â€ƒExample: converting a sync iterable to an async iterable <#example-converting-a-sync-iterable-to-an-async-iterable>`__
      #. `44.2.3â€ƒExample: converting an async iterable to an Array <#asyncIterableToArray>`__
      #. `44.2.4â€ƒExample: transforming an async iterable <#example-transforming-an-async-iterable>`__
      #. `44.2.5â€ƒExample: mapping over asynchronous iterables <#example-mapping-over-asynchronous-iterables>`__

   #. `44.3â€ƒAsync iteration over Node.js streams <#async-iteration-over-node-js-streams>`__

      #. `44.3.1â€ƒNode.js streams: async via callbacks (push) <#node-js-streams-async-via-callbacks-push>`__
      #. `44.3.2â€ƒNode.js streams: async via async iteration (pull) <#node-js-streams-async-via-async-iteration-pull>`__
      #. `44.3.3â€ƒExample: from chunks to lines <#example-from-chunks-to-lines>`__

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**Required knowledge**

      .. container:: boxout-vspace

      For this chapter, you should be familiar with:

      -  `Promises <#ch_promises>`__
      -  `Async functions <#ch_async-functions>`__

44.1â€ƒBasic asynchronous iteration
----------------------------------

44.1.1â€ƒProtocol: async iteration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To understand how asynchronous iteration works, letâ€™s first revisit `synchronous
   iteration <#ch_sync-iteration>`__. It comprises the
   following interfaces:

   .. code:: javascript
      :name: language-ts

      interface Iterable<T> {
      [Symbol.iterator]() : Iterator<T>;
      }
      interface Iterator<T> {
      next() : IteratorResult<T>;
      }
      interface IteratorResult<T> {
      value: T;
      done: boolean;
      }

   -  An ``Iterable`` is a data structure whose contents can be accessed via
      iteration. It is a factory for iterators.
   -  An ``Iterator`` is a factory for iteration results that we retrieve by
      calling the method ``.next()``.
   -  Each ``IterationResult`` contains the iterated ``.value`` and a boolean
      ``.done`` that is ``true`` after the last element and ``false`` before.

   For the protocol for asynchronous iteration, we only want to change one thing:
   the values produced by ``.next()`` should be delivered asynchronously. There are
   two conceivable options:

   -  The ``.value`` could contain a ``Promise<T>``.
   -  ``.next()`` could return ``Promise<IteratorResult<T>>``.

   In other words, the question is whether to wrap just values or whole iterator
   results in Promises.

   It has to be the latter because when ``.next()`` returns a result, it starts an
   asynchronous computation. Whether or not that computation produces a value or
   signals the end of the iteration can only be determined after it is finished.
   Therefore, both ``.done`` and ``.value`` need to be wrapped in a Promise.

   The interfaces for async iteration look as follows.

   .. code:: javascript
      :name: language-ts

      interface AsyncIterable<T> {
      [Symbol.asyncIterator]() : AsyncIterator<T>;
      }
      interface AsyncIterator<T> {
      next() : Promise<IteratorResult<T>>; // (A)
      }
      interface IteratorResult<T> {
      value: T;
      done: boolean;
      }

   The only difference to the synchronous interfaces is the return type of
   ``.next()`` (line A).

44.1.2â€ƒUsing async iteration directly
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following code uses the asynchronous iteration protocol directly:

   .. code:: javascript

      const asyncIterable = syncToAsyncIterable(['a', 'b']); // (A)
      const asyncIterator = asyncIterable[Symbol.asyncIterator]();

      // Call .next() until .done is true:
      asyncIterator.next() // (B)
      .then(iteratorResult => {
      assert.deepEqual(
         iteratorResult,
         { value: 'a', done: false });
      return asyncIterator.next(); // (C)
      })
      .then(iteratorResult => {
      assert.deepEqual(
         iteratorResult,
         { value: 'b', done: false });
      return asyncIterator.next(); // (D)
      })
      .then(iteratorResult => {
      assert.deepEqual(
         iteratorResult,
         { value: undefined, done: true });
      })
      ;

   In line A, we create an asynchronous iterable over the value ``'a'`` and
   ``'b'``. Weâ€™ll see an implementation of ``syncToAsyncIterable()`` later.

   We call ``.next()`` in line B, line C and line D. Each time, we use ``.then()``
   to unwrap the Promise and ``assert.deepEqual()`` to check the unwrapped value.

   We can simplify this code if we use an async function. Now we unwrap Promises
   via ``await`` and the code looks almost like we are doing synchronous iteration:

   .. code:: javascript

      async function f() {
      const asyncIterable = syncToAsyncIterable(['a', 'b']);
      const asyncIterator = asyncIterable[Symbol.asyncIterator]();
      
      // Call .next() until .done is true:
      assert.deepEqual(
         await asyncIterator.next(),
         { value: 'a', done: false });
      assert.deepEqual(
         await asyncIterator.next(),
         { value: 'b', done: false });
      assert.deepEqual(
         await asyncIterator.next(),
         { value: undefined, done: true });
      }



.. _for-await-of:

44.1.3â€ƒUsing async iteration via ``for-await-of``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The asynchronous iteration protocol is not meant to be used directly. One of the
   language constructs that supports it is the ``for-await-of`` loop, which is an
   asynchronous version of the ``for-of`` loop. It can be used in async functions
   and *async generators* (which are introduced later in this chapter). This is an
   example of ``for-await-of`` in use:

   .. code:: javascript

      for await (const x of syncToAsyncIterable(['a', 'b'])) {
      console.log(x);
      }

   Output:

   ::

      a
      b

   ``for-await-of`` is relatively flexible. In addition to asynchronous iterables,
   it also supports synchronous iterables:

   .. code:: javascript

      for await (const x of ['a', 'b']) {
      console.log(x);
      }

   Output:

   ::

      a
      b

   And it supports synchronous iterables over values that are wrapped in Promises:

   .. code:: javascript

      const arr = [Promise.resolve('a'), Promise.resolve('b')];
      for await (const x of arr) {
      console.log(x);
      }

   Output:

   ::

      a
      b

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Convert an async iterable to an Array**

      .. container:: boxout-vspace

      Warning: Weâ€™ll soon see the solution for this exercise in this chapter.

      -  ``exercises/async-iteration/async_iterable_to_array_test.mjs``



.. _async-generators:

44.2â€ƒAsynchronous generators
-----------------------------

   An asynchronous generator is two things at the same time:

   -  An async function (input): We can use ``await`` and ``for-await-of`` to
      retrieve data.
   -  A generator that returns an asynchronous iterable (output): We can use
      ``yield`` and ``yield*`` to produce data.

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**Asynchronous generators are very similar to synchronous
      generators**

      .. container:: boxout-vspace

      Due to async generators and sync generators being so similar, I donâ€™t explain
      how exactly ``yield`` and ``yield*`` work. Please consult `â€œSynchronous
      generatorsâ€ (Â§40) <#ch_sync-generators>`__ if you have
      doubts.

   Therefore, an asynchronous generator has:

   -  Input that can be:

      -  synchronous (single values, sync iterables) or
      -  asynchronous (Promises, async iterables).

   -  Output that is an asynchronous iterable.

   This looks as follows:

   .. code:: javascript

      async function* asyncGen() {
      // Input: Promises, async iterables
      const x = await somePromise;
      for await (const y of someAsyncIterable) {
         // Â·Â·Â·
      }

      // Output
      yield someValue;
      yield* otherAsyncGen();
      }

44.2.1â€ƒExample: creating an async iterable via an async generator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Letâ€™s look at an example. The following code creates an async iterable with
   three numbers:

   .. code:: javascript

      async function* yield123() {
      for (let i=1; i<=3; i++) {
         yield i;
      }
      }

   Does the result of ``yield123()`` conform to the async iteration protocol?

   .. code:: javascript

      async function check() {
      const asyncIterable = yield123();
      const asyncIterator = asyncIterable[Symbol.asyncIterator]();
      assert.deepEqual(
         await asyncIterator.next(),
         { value: 1, done: false });
      assert.deepEqual(
         await asyncIterator.next(),
         { value: 2, done: false });
      assert.deepEqual(
         await asyncIterator.next(),
         { value: 3, done: false });
      assert.deepEqual(
         await asyncIterator.next(),
         { value: undefined, done: true });
      }
      check();

44.2.2â€ƒExample: converting a sync iterable to an async iterable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following asynchronous generator converts a synchronous iterable to an
   asynchronous iterable. It implements the function ``syncToAsyncIterable()`` that
   we have used previously.

   .. code:: javascript

      async function* syncToAsyncIterable(syncIterable) {
      for (const elem of syncIterable) {
         yield elem;
      }
      }

   Note: The input is synchronous in this case (no ``await`` is needed).



.. _asyncIterableToArray:

44.2.3â€ƒExample: converting an async iterable to an Array
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following function is a solution to a previous exercise. It converts an
   async iterable to an Array (think spreading, but for async iterables instead of
   sync iterables).

   .. code:: javascript

      async function asyncIterableToArray(asyncIterable) {
      const result = [];
      for await (const value of asyncIterable) {
         result.push(value);
      }
      return result;
      }

   Note that we canâ€™t use an async generator in this case: We get our input via
   ``for-await-of`` and return an Array wrapped in a Promise. The latter
   requirement rules out async generators.

   This is a test for ``asyncIterableToArray()``:

   .. code:: javascript

      async function* createAsyncIterable() {
      yield 'a';
      yield 'b';
      }
      const asyncIterable = createAsyncIterable();
      assert.deepEqual(
      await asyncIterableToArray(asyncIterable), // (A)
      ['a', 'b']
      );

   Note the ``await`` in line A, which is needed to unwrap the Promise returned by
   ``asyncIterableToArray()``. In order for ``await`` to work, this code fragment
   must be run inside an async function.

44.2.4â€ƒExample: transforming an async iterable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Letâ€™s implement an async generator that produces a new async iterable by
   transforming an existing async iterable.

   .. code:: javascript

      async function* timesTwo(asyncNumbers) {
      for await (const x of asyncNumbers) {
         yield x * 2;
      }
      }

   To test this function, we use ``asyncIterableToArray()`` from the previous
   section.

   .. code:: javascript

      async function* createAsyncIterable() {
      for (let i=1; i<=3; i++) {
         yield i;
      }
      }
      assert.deepEqual(
      await asyncIterableToArray(timesTwo(createAsyncIterable())),
      [2, 4, 6]
      );

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Async generators**

      .. container:: boxout-vspace

      Warning: Weâ€™ll soon see the solution for this exercise in this chapter.

      -  ``exercises/async-iteration/number_lines_test.mjs``

44.2.5â€ƒExample: mapping over asynchronous iterables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   As a reminder, this is how to map over synchronous iterables:

   .. code:: javascript

      function* mapSync(iterable, func) {
      let index = 0;
      for (const x of iterable) {
         yield func(x, index);
         index++;
      }
      }
      const syncIterable = mapSync(['a', 'b', 'c'], s => s.repeat(3));
      assert.deepEqual(
      Array.from(syncIterable),
      ['aaa', 'bbb', 'ccc']);

   The asynchronous version looks as follows:

   .. code:: javascript

      async function* mapAsync(asyncIterable, func) { // (A)
      let index = 0;
      for await (const x of asyncIterable) { // (B)
         yield func(x, index);
         index++;
      }
      }

   Note how similar the sync implementation and the async implementation are. The
   only two differences are the ``async`` in line A and the ``await`` in line B.
   That is comparable to going from a synchronous function to an asynchronous
   function â€“ we only need to add the keyword ``async`` and the occasional
   ``await``.

   To test ``mapAsync()``, we use the helper function ``asyncIterableToArray()``
   `(shown earlier in this chapter) <#asyncIterableToArray>`__:

   .. code:: javascript

      async function* createAsyncIterable() {
      yield 'a';
      yield 'b';
      }
      const mapped = mapAsync(
      createAsyncIterable(), s => s.repeat(3));
      assert.deepEqual(
      await asyncIterableToArray(mapped), // (A)
      ['aaa', 'bbb']);

   Once again, we ``await`` to unwrap a Promise (line A) and this code fragment
   must run inside an async function.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: ``filterAsyncIter()``**

      .. container:: boxout-vspace

      ``exercises/async-iteration/filter_async_iter_test.mjs``



.. _async-iteration-over-node-js-streams:

44.3â€ƒAsync iteration over Node.js streams
------------------------------------------



.. _node-js-streams-async-via-callbacks-push:

44.3.1â€ƒNode.js streams: async via callbacks (push)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Traditionally, reading asynchronously from Node.js streams is done via
   callbacks:

   .. code:: javascript

      function main(inputFilePath) {
      const readStream = fs.createReadStream(inputFilePath,
         { encoding: 'utf-8', highWaterMark: 1024 });
      readStream.on('data', (chunk) => {
         console.log('>>> '+chunk);
      });
      readStream.on('end', () => {
         console.log('### DONE ###');
      });
      }

   That is, the stream is in control and pushes data to the reader.



.. _node-js-streams-async-via-async-iteration-pull:

44.3.2â€ƒNode.js streams: async via async iteration (pull)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Starting with Node.js 10, we can also use asynchronous iteration to read from
   streams:

   .. code:: javascript

      async function main(inputFilePath) {
      const readStream = fs.createReadStream(inputFilePath,
         { encoding: 'utf-8', highWaterMark: 1024 });

      for await (const chunk of readStream) {
         console.log('>>> '+chunk);
      }
      console.log('### DONE ###');
      }

   This time, the reader is in control and pulls data from the stream.

44.3.3â€ƒExample: from chunks to lines
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Node.js streams iterate over *chunks* (arbitrarily long pieces) of data. The
   following asynchronous generator converts an async iterable over chunks to an
   async iterable over lines:

   .. code:: javascript

      /**
      * @param chunkIterable An asynchronous or synchronous iterable
      * over â€œchunksâ€ (arbitrary strings)
      * @returns An asynchronous iterable over â€œlinesâ€
      * (strings with at most one newline that always appears at the end)
      */
      async function* chunksToLines(chunkIterable) {
      let previous = '';
      for await (const chunk of chunkIterable) {
         let startSearch = previous.length;
         previous += chunk;
         while (true) {
            // Works for EOL === '\n' and EOL === '\r\n'
            const eolIndex = previous.indexOf('\n', startSearch);
            if (eolIndex < 0) break;
            // Line includes the EOL
            const line = previous.slice(0, eolIndex+1);
            yield line;
            previous = previous.slice(eolIndex+1);
            startSearch = 0;
         }
      }
      if (previous.length > 0) {
         yield previous;
      }
      }

   Letâ€™s apply ``chunksToLines()`` to an async iterable over chunks (as produced by
   ``chunkIterable()``):

   .. code:: javascript

      async function* chunkIterable() {
      yield 'First\nSec';
      yield 'ond\nThird\nF';
      yield 'ourth';
      }
      const linesIterable = chunksToLines(chunkIterable());
      assert.deepEqual(
      await asyncIterableToArray(linesIterable),
      [
         'First\n',
         'Second\n',
         'Third\n',
         'Fourth',
      ]);

   Now that we have an asynchronous iterable over lines, we can use the solution of
   a previous exercise, ``numberLines()``, to number those lines:

   .. code:: javascript

      async function* numberLines(linesAsync) {
      let lineNumber = 1;
      for await (const line of linesAsync) {
         yield lineNumber + ': ' + line;
         lineNumber++;
      }
      }
      const numberedLines = numberLines(chunksToLines(chunkIterable()));
      assert.deepEqual(
      await asyncIterableToArray(numberedLines),
      [
         '1: First\n',
         '2: Second\n',
         '3: Third\n',
         '4: Fourth',
      ]);

   `Comments <https://github.com/rauschma/exploring-js/issues/44>`__




.. _ch_regexps:

45â€ƒRegular expressions (``RegExp``)
====================================

   #. `45.1â€ƒCreating regular expressions <#creating-regular-expressions>`__

      #. `45.1.1â€ƒLiteral vs. constructor <#literal-vs-constructor>`__
      #. `45.1.2â€ƒCloning and non-destructively modifying regular expressions <#cloning-regexps>`__

   #. `45.2â€ƒSyntax characters and escaping <#escaping-for-regexp>`__

      #. `45.2.1â€ƒSyntax characters <#syntax-characters>`__
      #. `45.2.2â€ƒIllegal top-level escaping <#illegal-top-level-escaping>`__
      #. `45.2.3â€ƒEscaping inside character classes ([Â·Â·Â·]) <#escaping-inside-character-classes>`__

   #. `45.3â€ƒSyntax: atoms of regular expressions <#syntax-atoms-of-regular-expressions>`__
   #. `45.4â€ƒSyntax: character class escapes <#syntax-character-class-escapes>`__

      #. `45.4.1â€ƒBasic character class escapes (sets of code units): \d \D \s \S \w \W <#basic-character-class-escapes>`__
      #. `45.4.2â€ƒUnicode character property escapes [ES2018] <#unicode-character-property-escapes>`__
      #. `45.4.3â€ƒUnicode string property escapes [ES2024] <#unicode-string-property-escapes>`__

   #. `45.5â€ƒSyntax: character classes <#syntax-character-classes>`__

      #. `45.5.1â€ƒString literals in character classes [ES2024] <#character-class-string-literals>`__
      #. `45.5.2â€ƒSet operations for character classes [ES2024] <#regexp-character-class-set-operations>`__

   #. `45.6â€ƒSyntax: capture groups <#syntax-capture-groups>`__
   #. `45.7â€ƒSyntax: quantifiers <#syntax-quantifiers>`__
   #. `45.8â€ƒSyntax: assertions <#syntax-assertions>`__

      #. `45.8.1â€ƒLookahead assertions <#regexp-lookahead-assertions>`__
      #. `45.8.2â€ƒLookbehind assertions [ES2018] <#regexp-lookbehind-assertions>`__

   #. `45.9â€ƒSyntax: disjunction (|) <#syntax-disjunction>`__
   #. `45.10â€ƒRegular expression flags <#reg-exp-flags>`__

      #. `45.10.1â€ƒHow to order regular expression flags? <#how-to-order-regular-expression-flags>`__
      #. `45.10.2â€ƒWithout /u and /v: matching UTF-16 code units <#without-u-and-v-matching-utf-16-code-units>`__
      #. `45.10.3â€ƒFlag /u: matching code points [ES6] <#regexp-flag-unicode>`__
      #. `45.10.4â€ƒFlag /v: limited support for multi-code-point grapheme clusters [ES2024] <#regexp-flag-unicode-sets>`__

   #. `45.11â€ƒProperties of regular expression objects <#properties-of-regular-expression-objects>`__

      #. `45.11.1â€ƒFlags as properties <#flags-as-properties>`__
      #. `45.11.2â€ƒOther properties <#other-properties>`__

   #. `45.12â€ƒMatch objects <#match-objects>`__

      #. `45.12.1â€ƒMatch indices in match objects [ES2022] <#regexp-match-indices>`__

   #. `45.13â€ƒMethods for working with regular expressions <#methods-for-working-with-regular-expressions>`__

      #. `45.13.1â€ƒBy default, regular expressions match anywhere in a string <#by-default-regular-expressions-match-anywhere-in-a-string>`__
      #. `45.13.2â€ƒregExp.test(str): is there a match? [ES3] <#RegExp.prototype.test>`__
      #. `45.13.3â€ƒstr.search(regExp): at what index is the match? [ES3] <#String.prototype.search>`__
      #. `45.13.4â€ƒregExp.exec(str): capturing groups [ES3] <#RegExp.prototype.exec>`__
      #. `45.13.5â€ƒstr.match(regExp): getting all group 0 captures [ES3] <#String.prototype.match>`__
      #. `45.13.6â€ƒstr.matchAll(regExp): getting an iterable over all match objects [ES2020] <#String.prototype.matchAll>`__
      #. `45.13.7â€ƒregExp.exec() vs. str.match() vs. str.matchAll() <#regexp-exec-vs-str-match-vs-str-matchall>`__
      #. `45.13.8â€ƒReplacing with str.replace() and str.replaceAll() <#replace-replaceAll>`__
      #. `45.13.9â€ƒOther methods for working with regular expressions <#other-methods-for-working-with-regular-expressions>`__

   #. `45.14â€ƒThe flags /g and /y, and the property .lastIndex (advanced) <#regexp-flags-gy>`__

      #. `45.14.1â€ƒThe flags /g and /y <#the-flags-g-and-y>`__
      #. `45.14.2â€ƒHow exactly are methods affected by /g and /y? <#how-exactly-are-methods-affected-by-g-and-y>`__
      #. `45.14.3â€ƒFour pitfalls of /g and /y and how to deal with them <#four-pitfalls-of-g-and-y-and-how-to-deal-with-them>`__
      #. `45.14.4â€ƒUse case for .lastIndex: starting matching at a given index <#use-case-for-lastindex-starting-matching-at-a-given-index>`__
      #. `45.14.5â€ƒThe downsides of .lastIndex <#the-downsides-of-lastindex>`__
      #. `45.14.6â€ƒSummary: .global (/g) and .sticky (/y) <#summary-global-g-and-sticky-y>`__

   #. `45.15â€ƒTechniques for working with regular expressions <#techniques-for-working-with-regular-expressions>`__

      #. `45.15.1â€ƒEscaping arbitrary text for regular expressions <#escapeForRegExp>`__
      #. `45.15.2â€ƒMatching everything or nothing <#matching-everything-or-nothing>`__
      #. `45.15.3â€ƒUsing a tagged template to write regular expressions that are easier to understand <#using-a-tagged-template-to-write-regular-expressions-that-are-easier-to-understand>`__

   .. container:: boxout

      |Icon â€œreadingâ€|â€‚**Availability of features**

      .. container:: boxout-vspace

      Unless stated otherwise, each regular expression feature has been available
      since ES3.

45.1â€ƒCreating regular expressions
----------------------------------



.. _literal-vs-constructor:

45.1.1â€ƒLiteral vs. constructor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The two main ways of creating regular expressions are:

   -  Literal: compiled statically (at load time).

      .. code:: javascript

         /abc/iv

   -  Constructor: compiled dynamically (at runtime).

      .. code:: javascript

         new RegExp('abc', 'iv')

   Both regular expressions have the same two parts:

   -  The *body* ``abc`` â€“ the actual regular expression.
   -  The *flags* ``i`` and ``v``. Flags configure how the pattern is interpreted.
      For example, ``i`` enables case-insensitive matching. A list of available
      flags is given `later in this chapter <#reg-exp-flags>`__.



.. _cloning-regexps:

45.1.2â€ƒCloning and non-destructively modifying regular expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   There are two variants of the constructor ``RegExp()``:

   -  ``new RegExp(pattern : string, flags = '')`` :sup:`[ES3]`

      A new regular expression is created as specified via ``pattern``. If
      ``flags`` is missing, the empty string ``''`` is used.

   -  ``new RegExp(regExp : RegExp, flags = regExp.flags)`` :sup:`[ES6]`

      ``regExp`` is cloned. If ``flags`` is provided, then it determines the flags
      of the clone.

   The second variant is useful for cloning regular expressions, optionally while
   modifying them. Flags are immutable and this is the only way of changing them â€“
   for example:

   .. code:: javascript

      function copyAndAddFlags(regExp, flagsToAdd='') {
      // The constructor doesnâ€™t allow duplicate flags;
      // make sure there arenâ€™t any:
      const newFlags = Array.from(
         new Set(regExp.flags + flagsToAdd)
      ).join('');
      return new RegExp(regExp, newFlags);
      }
      assert.equal(/abc/i.flags, 'i');
      assert.equal(copyAndAddFlags(/abc/i, 'g').flags, 'gi');



.. _escaping-for-regexp:

45.2â€ƒSyntax characters and escaping
------------------------------------

45.2.1â€ƒSyntax characters
~~~~~~~~~~~~~~~~~~~~~~~~~

   At the top level of a regular expression, the following *syntax characters* are
   special. They are escaped by prefixing a backslash (``\``).

   .. code:: language-txt

      \ ^ $ . * + ? ( ) [ ] { } |

   In regular expression literals, we must escape slashes:

   .. code:: javascript
      :name: language-node-repl

      > /\//.test('/')
      true

   In the argument of ``new RegExp()``, we donâ€™t have to escape slashes:

   .. code:: javascript
      :name: language-node-repl

      > new RegExp('/').test('/')
      true

45.2.2â€ƒIllegal top-level escaping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Without flag ``/u`` and ``/v``, an escaped non-syntax character at the top level
   matches itself:

   .. code:: javascript
      :name: language-node-repl

      > /^\a$/.test('a')
      true

   With flag ``/u`` or ``/v``, escaping a non-syntax character at the top level is
   a syntax error:

   .. code:: javascript

      assert.throws(
      () => eval(String.raw`/\a/v`),
      {
         name: 'SyntaxError',
         message: 'Invalid regular expression: /\\a/v: Invalid escape',
      }
      );
      assert.throws(
      () => eval(String.raw`/\-/v`),
      {
         name: 'SyntaxError',
         message: 'Invalid regular expression: /\\-/v: Invalid escape',
      }
      );

45.2.3â€ƒEscaping inside character classes (``[Â·Â·Â·]``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Rules for escaping inside character classes without flag ``/v``:

   -  We always must escape: ``\ ]``
   -  Some characters only have to be escaped in some locations:

      -  ``-`` only has to be escaped if it doesnâ€™t come first or last.
      -  ``^`` only has to be escaped if it comes first.

   Rules with flag ``/v``:

   -  A single ``^`` only has to be escaped if it comes first.

   -  `Class set syntax
      characters <https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter>`__ have to
      be escaped:

      ::

         ( ) [ ] { } / - \ |

   -  `Class set reserved double
      punctuators <https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator>`__
      have to be escaped:

      ::

         && !! ## $$ %% ** ++ ,, .. :: ;; << == >> ?? @@ ^^ `` ~~

45.3â€ƒSyntax: atoms of regular expressions
------------------------------------------

   *Atoms* are the basic building blocks of regular expressions.

   -  *Pattern characters* are all characters *except* syntax characters (``^``,
      ``$``, etc.). Pattern characters match themselves. Examples: ``A b %``
   -  ``.`` matches any character. We can use `the flag ``/s``
      (``dotAll``) <#regexp-dot-all-flag>`__ to control if the dot matches line
      terminators or not.
   -  *Character escapes* (each escape matches a single fixed character):

      -  Control escapes (for a few control characters):

         -  ``\f``: form feed (FF)
         -  ``\n``: line feed (LF)
         -  ``\r``: carriage return (CR)
         -  ``\t``: character tabulation
         -  ``\v``: line tabulation

      -  Arbitrary control characters: ``\cA`` (Ctrl-A), â€¦, ``\cZ`` (Ctrl-Z)
      -  Unicode code units: ``\u00E4``
      -  Unicode code points (require flag ``/u`` or ``/v``): ``\u{1F44D}``

   -  *Character class escapes* define sets of characters (or character sequences)
      that match:

      -  *Basic character class escapes* define sets of characters:
         ``\d \D \s \S \w \W``

         -  Described in `â€œBasic character class escapes (sets of code units):
            ``\d \D \s \S \w \W``\ â€ (Â§45.4.1) <#basic-character-class-escapes>`__.

      -  *Unicode character property escapes* :sup:`[ES2018]` define sets of code
         points: ``\p{White_Space}``, ``\P{White_Space}``, etc.

         -  Require flag ``/u`` or ``/v``.
         -  Described in `â€œUnicode character property escapes [ES2018]\ â€
            (Â§45.4.2) <#unicode-character-property-escapes>`__.

      -  *Unicode string property escapes* :sup:`[ES2024]` define sets of code
         point sequences: ``\p{RGI_Emoji}``, etc.

         -  Require flag ``/v``.
         -  Described in `â€œUnicode string property escapes [ES2024]\ â€
            (Â§45.4.3) <#unicode-string-property-escapes>`__.

   Without ``/u`` and ``/v``, a character is a UTF-16 code unit. With those flags,
   a character is a code point.

45.4â€ƒSyntax: character class escapes
-------------------------------------



.. _basic-character-class-escapes:

45.4.1â€ƒBasic character class escapes (sets of code units): ``\d \D \s \S \w \W``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following character class escapes and their complements are always
   supported:

   Escape

   Equivalent

   Complement

   Digits

   ``\d``

   ``[0-9]``

   ``\D``

   â€œWordâ€ characters

   ``\w``

   ``[a-zA-Z0-9_]``

   ``\W``

   Whitespace

   ``\s``

   ``\S``

   Note:

   -  Whitespace: ``\s`` matches all whitespace code points: space, tab, line
      terminators, etc. They all fit into single UTF-16 code units.
   -  â€œWordâ€ characters are related to identifiers in programming languages.

   Examples:

   .. code:: javascript
      :name: language-node-repl

      > 'a7x4'.match(/\d/g)
      [ '7', '4' ]
      > 'a7x4'.match(/\D/g)
      [ 'a', 'x' ]
      > 'high - low'.match(/\w+/g)
      [ 'high', 'low' ]
      > 'hello\t\n everyone'.replaceAll(/\s/g, '-')
      'hello---everyone'



.. _unicode-character-property-escapes:

45.4.2â€ƒUnicode character property escapes [ES2018]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   With flag ``/u`` and flag ``/v``, we can use ``\p{}`` and ``\P{}`` to specify
   sets of code points via *Unicode character properties* (weâ€™ll learn more about
   those in the next subsection). That looks like this:

   #. ``\p{prop=value}``: matches all characters whose Unicode character property
      ``prop`` has the value ``value``.
   #. ``\P{prop=value}``: matches all characters that do not have a Unicode
      character property ``prop`` whose value is ``value``.
   #. ``\p{bin_prop}``: matches all characters whose binary Unicode character
      property ``bin_prop`` is True.
   #. ``\P{bin_prop}``: matches all characters whose binary Unicode character
      property ``bin_prop`` is False.

   Comments:

   -  Without the flags ``/u`` and ``/v``, ``\p`` is the same as ``p``.

   -  Forms (3) and (4) can be used as abbreviations if the property is
      ``General_Category``. For example, the following two escapes are equivalent:

      .. code:: language-txt

         \p{Uppercase_Letter}
         \p{General_Category=Uppercase_Letter}

   Examples:

   -  Checking for whitespace:

      .. code:: javascript
         :name: language-node-repl

         > /^\p{White_Space}+$/u.test('\t \n\r')
         true

   -  Checking for Greek letters:

      .. code:: javascript
         :name: language-node-repl

         > /^\p{Script=Greek}+$/u.test('Î¼ÎµÏ„Î¬')
         true

   -  Deleting any letters:

      .. code:: javascript
         :name: language-node-repl

         > '1Ï€2Ã¼3Ã©4'.replace(/\p{Letter}/ug, '')
         '1234'

   -  Deleting lowercase letters:

      .. code:: javascript
         :name: language-node-repl

         > 'AbCdEf'.replace(/\p{Lowercase_Letter}/ug, '')
         'ACE'

45.4.2.1â€ƒUnicode character properties
''''''''''''''''''''''''''''''''''''''

   In the Unicode standard, each character has *properties* â€“ metadata describing
   it. Properties play an important role in defining the nature of a character.
   Quoting `the Unicode Standard, Sect. 3.3,
   D3 <http://www.unicode.org/versions/Unicode9.0.0/ch03.pdf>`__:

      The semantics of a character are determined by its identity, normative
      properties, and behavior.

   These are a few examples of properties:

   -  ``Name``: a unique name, composed of uppercase letters, digits, hyphens, and
      spaces â€“ for example:

      -  A: ``Name = LATIN CAPITAL LETTER A``
      -  ``ğŸ™‚``: ``Name = SLIGHTLY SMILING FACE``

   -  ``General_Category``: categorizes characters â€“ for example:

      -  x: ``General_Category = Lowercase_Letter``
      -  $: ``General_Category = Currency_Symbol``

   -  ``White_Space``: used for marking invisible spacing characters, such as
      spaces, tabs and newlines â€“ for example:

      -  \\t: ``White_Space = True``
      -  Ï€: ``White_Space = False``

   -  ``Age``: version of the Unicode Standard in which a character was introduced
      â€“ for example: The Euro sign â‚¬ was added in version 2.1 of the Unicode
      standard.

      -  â‚¬: ``Age = 2.1``

   -  ``Block``: a contiguous range of code points. Blocks donâ€™t overlap and their
      names are unique. For example:

      -  S: ``Block = Basic_Latin`` (range 0x0000..0x007F)
      -  ``ğŸ™‚``: ``Block = Emoticons`` (range 0x1F600..0x1F64F)

   -  ``Script``: is a collection of characters used by one or more writing
      systems.

      -  Some scripts support several writing systems. For example, the Latin
         script supports the writing systems English, French, German, Latin, etc.
      -  Some languages can be written in multiple alternate writing systems that
         are supported by multiple scripts. For example, Turkish used the Arabic
         script before it transitioned to the Latin script in the early 20th
         century.
      -  Examples:

         -  Î±: ``Script = Greek``
         -  Ğ”: ``Script = Cyrillic``

   Further reading:

   -  Lists of Unicode properties and their values: `â€œUnicode Standard Annex #44:
      Unicode Character Databaseâ€ <https://unicode.org/reports/tr44/#Properties>`__
      (Editors: Mark Davis, LaurenÈ›iu Iancu, Ken Whistler)



.. _unicode-string-property-escapes:

45.4.3â€ƒUnicode string property escapes [ES2024]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   With ``/u``, we can use Unicode property escapes (``\p{}`` and ``\P{}``) to
   specify sets of code points via Unicode character properties.

   With ``/v``, we can additionally use ``\p{}`` to specify sets of code point
   sequences via Unicode string properties (negation via ``\P{}`` is not
   supported):

   .. code:: javascript
      :name: language-node-repl

      > /^\p{RGI_Emoji}$/v.test('â›”') // 1 code point (1 code unit)
      true
      > /^\p{RGI_Emoji}$/v.test('ğŸ™‚') // 1 code point (2 code units)
      true
      > /^\p{RGI_Emoji}$/v.test('ğŸ˜µâ€ğŸ’«') // 3 code points
      true

   Letâ€™s see how the character property ``Emoji`` would do with these inputs:

   .. code:: javascript
      :name: language-node-repl

      > /^\p{Emoji}$/u.test('â›”') // 1 code point (1 code unit)
      true
      > /^\p{Emoji}$/u.test('ğŸ™‚') // 1 code point (2 code units)
      true
      > /^\p{Emoji}$/u.test('ğŸ˜µâ€ğŸ’«') // 3 code points
      false

45.4.3.1â€ƒUnicode string properties
'''''''''''''''''''''''''''''''''''

   For now, the following Unicode properties of strings are supported by
   JavaScript:

   -  ``Basic_Emoji``: single code points
   -  ``Emoji_Keycap_Sequence``
   -  ``RGI_Emoji_Modifier_Sequence``
   -  ``RGI_Emoji_Flag_Sequence``
   -  ``RGI_Emoji_Tag_Sequence``
   -  ``RGI_Emoji_ZWJ_Sequence``
   -  ``RGI_Emoji``: union of all of the above sets

   Further reading:

   -  `Section â€œProperties of
      Stringsâ€ <https://www.unicode.org/reports/tr23/#PropertyStringsDefinitions>`__
      in â€œUnicode Technical Report #23: The Unicode Character Property Modelâ€
      defines what properties of strings are.

   -  `Table â€œBinary Unicode properties of
      stringsâ€ <https://tc39.es/ecma262/#table-binary-unicode-properties-of-strings>`__
      in the ECMAScript specification lists the properties of strings that are
      supported by JavaScript.

   -  The semantics of Unicode string properties are defined in `text
      files <https://www.unicode.org/reports/tr51/#Emoji_Properties_and_Data_Files>`__
      that enumerate code point sequences likes this:

      ::

         0023 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: \x{23}
         002A FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: *
         0030 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 0
         0031 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 1
         0032 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 2
         0033 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 3
         0034 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 4
         0035 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 5
         0036 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 6
         0037 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 7
         0038 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 8
         0039 FE0F 20E3 ; Emoji_Keycap_Sequence ; keycap: 9

45.5â€ƒSyntax: character classes
-------------------------------

   A *character class* wraps *class ranges* in square brackets. The class ranges
   specify a set of characters:

   -  ``[Â«class rangesÂ»]`` matches any character in the set.
   -  ``[^Â«class rangesÂ»]`` matches any character not in the set.

   Rules for class ranges:

   -  Non-syntax characters stand for themselves: ``[abc]``

   -  | Only the following four characters are special and must be escaped via
      slashes:
      | ``^ \ - ]``

      -  ``^`` only has to be escaped if it comes first.
      -  ``-`` need not be escaped if it comes first or last.

   -  Character escapes (``\n``, ``\u{1F44D}``, etc.) have the usual meaning.

      -  Watch out: ``\b`` stands for backspace. Elsewhere in a regular expression,
         it matches word boundaries.

   -  Character class escapes (``\d``, ``\P{White_Space}``, ``\p{RGI_Emoji}``,
      etc.) have the usual meanings.

   -  Ranges of characters are specified via dashes: ``[a-z]``



.. _character-class-string-literals:

45.5.1â€ƒString literals in character classes [ES2024]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Flag ``/v`` enables a new feature inside character classes â€“ we can use ``\q{}``
   to add code points sequences to their character sets:

   .. code:: javascript
      :name: language-node-repl

      > /^[\q{ğŸ˜µâ€ğŸ’«}]$/v.test('ğŸ˜µâ€ğŸ’«')
      true

   Without ``\q{}``, grapheme clusters are still treated as several units:

   .. code:: javascript
      :name: language-node-repl

      > /^[ğŸ˜µâ€ğŸ’«]$/v.test('ğŸ˜µâ€ğŸ’«')
      false
      > /^[\u{1F635}\u{200D}\u{1F4AB}]$/v.test('ğŸ˜µâ€ğŸ’«') // equivalent
      false
      > /^[ğŸ˜µâ€ğŸ’«]$/v.test('\u{1F635}')
      true

   We can use a single ``\q{}`` to add multiple code point sequences â€“ if we
   separate them with pipes:

   .. code:: javascript
      :name: language-node-repl

      > /^[\q{abc|def}]$/v.test('abc')
      true
      > /^[\q{abc|def}]$/v.test('def')
      true



.. _regexp-character-class-set-operations:

45.5.2â€ƒSet operations for character classes [ES2024]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Flag ``/v`` enables set operations for character classes.

45.5.2.1â€ƒNesting character classes
'''''''''''''''''''''''''''''''''''

   To enable set operations for character classes, we must be able to nest them.
   Character class escapes already provides some kind of nesting:

   .. code:: javascript
      :name: language-node-repl

      > /^[\d\w]$/v.test('7')
      true
      > /^[\d\w]$/v.test('H')
      true
      > /^[\d\w]$/v.test('?')
      false

   With flag ``/v``, we can additionally nest character classes (the regular
   expression below is equivalent to the regular expression in the previous
   example):

   .. code:: javascript
      :name: language-node-repl

      > /^[[0-9][A-Za-z0-9_]]$/v.test('7')
      true
      > /^[[0-9][A-Za-z0-9_]]$/v.test('H')
      true
      > /^[[0-9][A-Za-z0-9_]]$/v.test('?')
      false



.. _subtraction-of-character-sets-via:

45.5.2.2â€ƒSubtraction of character sets via ``--``
''''''''''''''''''''''''''''''''''''''''''''''''''

   We can use the ``--`` operator to set-theoretically subtract the character sets
   defined by character classes or character class escapes:

   .. code:: javascript
      :name: language-node-repl

      > /^[\w--[a-g]]$/v.test('a')
      false
      > /^[\w--[a-g]]$/v.test('h')
      true

      > /^[\p{Number}--[0-9]]$/v.test('Ù£')
      true
      > /^[\p{Number}--[0-9]]$/v.test('3')
      false

      > /^[\p{RGI_Emoji}--\q{ğŸ˜µâ€ğŸ’«}]$/v.test('ğŸ˜µâ€ğŸ’«') // emoji has 3 code points
      false
      > /^[\p{RGI_Emoji}--\q{ğŸ˜µâ€ğŸ’«}]$/v.test('ğŸ™‚')
      true

   Single code points can also be used on either side of the ``--`` operator:

   .. code:: javascript
      :name: language-node-repl

      > /^[\w--a]$/v.test('a')
      false
      > /^[\w--a]$/v.test('b')
      true

45.5.2.3â€ƒIntersection of character sets via ``&&``
'''''''''''''''''''''''''''''''''''''''''''''''''''

   We can use the ``&&`` operator to set-theoretically intersect the character sets
   defined by character classes or character class escapes:

   .. code:: javascript
      :name: language-node-repl

      > /[\p{ASCII}&&\p{Letter}]/v.test('D')
      true
      > /[\p{ASCII}&&\p{Letter}]/v.test('Î”')
      false

      > /^[\p{Script=Arabic}&&\p{Number}]$/v.test('Ù£')
      true
      > /^[\p{Script=Arabic}&&\p{Number}]$/v.test('Ø¬')
      false

45.5.2.4â€ƒUnion of characters sets
''''''''''''''''''''''''''''''''''

   Two compute the set-theoretical union of character sets, we only need to write
   their definining constructs next to each other inside a character class:

   .. code:: javascript
      :name: language-node-repl

      > /^[\p{Emoji_Keycap_Sequence}[a-z]]+$/v.test('a2ï¸âƒ£c')
      true

45.6â€ƒSyntax: capture groups
----------------------------

   -  Numbered capture group: ``(#+)``

      -  Backreference: ``\1``, ``\2``, etc.

   -  Named capture group :sup:`[ES2018]`: ``(?<hashes>#+)``

      -  Backreference: ``\k<hashes>``

   -  Noncapturing group: ``(?:#+)``

45.7â€ƒSyntax: quantifiers
-------------------------

   By default, all of the following quantifiers are *greedy* (they match as many
   characters as possible):

   -  ``?``: match never or once
   -  ``*``: match zero or more times
   -  ``+``: match one or more times
   -  ``{n}``: match ``n`` times
   -  ``{n,}``: match ``n`` or more times
   -  ``{n,m}``: match at least ``n`` times, at most ``m`` times.

   To make them *reluctant* (so that they match as few characters as possible), put
   question marks (``?``) after them:

   .. code:: javascript
      :name: language-node-repl

      > /".*"/.exec('"abc"def"')[0]  // greedy
      '"abc"def"'
      > /".*?"/.exec('"abc"def"')[0] // reluctant
      '"abc"'

45.8â€ƒSyntax: assertions
------------------------

   -  ``^`` matches only at the beginning of the input
   -  ``$`` matches only at the end of the input
   -  ``\b`` matches only at a word boundary

      -  ``\B`` matches only when not at a word boundary

   Overview of available lookaround assertions:

   Pattern

   Name

   ``(?=Â«patternÂ»)``

   Positive lookahead

   ES3

   ``(?!Â«patternÂ»)``

   Negative lookahead

   ES3

   ``(?<=Â«patternÂ»)``

   Positive lookbehind

   ES2018

   ``(?<!Â«patternÂ»)``

   Negative lookbehind

   ES2018



.. _regexp-lookahead-assertions:

45.8.1â€ƒLookahead assertions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   **Positive lookahead:** ``(?=Â«patternÂ»)`` matches if ``pattern`` matches what
   comes next.

   Example: sequences of lowercase letters that are followed by an ``X``.

   .. code:: javascript
      :name: language-node-repl

      > 'abcX def'.match(/[a-z]+(?=X)/g)
      [ 'abc' ]

   Note that the ``X`` itself is not part of the matched substring.

   **Negative lookahead:** ``(?!Â«patternÂ»)`` matches if ``pattern`` does not match
   what comes next.

   Example: sequences of lowercase letters that are not followed by an ``X``.

   .. code:: javascript
      :name: language-node-repl

      > 'abcX def'.match(/[a-z]+(?!X)/g)
      [ 'ab', 'def' ]



.. _regexp-lookbehind-assertions:

45.8.2â€ƒLookbehind assertions [ES2018]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   **Positive lookbehind:** ``(?<=Â«patternÂ»)`` matches if ``pattern`` matches what
   came before.

   Example: sequences of lowercase letters that are preceded by an ``X``.

   .. code:: javascript
      :name: language-node-repl

      > 'Xabc def'.match(/(?<=X)[a-z]+/g)
      [ 'abc' ]

   **Negative lookbehind:** ``(?<!Â«patternÂ»)`` matches if ``pattern`` does not
   match what came before.

   Example: sequences of lowercase letters that are not preceded by an ``X``.

   .. code:: javascript
      :name: language-node-repl

      > 'Xabc def'.match(/(?<!X)[a-z]+/g)
      [ 'bc', 'def' ]

   Example: replace â€œ.jsâ€ with â€œ.htmlâ€, but not in â€œNode.jsâ€.

   .. code:: javascript
      :name: language-node-repl

      > 'Node.js: index.js and main.js'.replace(/(?<!Node)\.js/g, '.html')
      'Node.js: index.html and main.html'

45.9â€ƒSyntax: disjunction (``|``)
---------------------------------

   Caveat: this operator has low precedence. Use groups if necessary:

   -  ``^aa|zz$`` matches all strings that start with ``aa`` and/or end with
      ``zz``.

      -  Note that ``|`` has a lower precedence than ``^`` and ``$``.

   -  ``^(aa|zz)$`` matches the two strings ``'aa'`` and ``'zz'``.
   -  ``^a(a|z)z$`` matches the two strings ``'aaz'`` and ``'azz'``.



.. _reg-exp-flags:

45.10â€ƒRegular expression flags
-------------------------------

   ============= ============== ======== ================================
   Literal flag  Property name  ES       Description
   d             hasIndices     ES2022   Switch on match indices
   g             global         ES3      Match multiple times
   i             ignoreCase     ES3      Match case-insensitively
   m             multiline      ES3      ^ and $ match per line
   s             dotAll         ES2018   Dot matches line terminators
   u             unicode        ES6      Unicode mode
   v             unicodeSets    ES2024   Unicode sets mode (recommended)
   y             sticky         ES6      No characters between matches
   ============= ============== ======== ================================

   Table 45.1: These are the regular expression flags supported by JavaScript.

   The following regular expression flags are available in JavaScript (`table
   45.1 <#tbl:reg-exp-flags-table>`__ provides a compact overview):

   -  ``/d`` (``.hasIndices``): Some RegExp-related methods return *match objects*
      that describe where the regular expression matched in an input string. If
      this flag is on, each match object includes *match indices* which tell us
      where each group capture starts and ends. More information: `â€œMatch indices
      in match objects [ES2022]\ â€ (Â§45.12.1) <#regexp-match-indices>`__.

   -  ``/g`` (``.global``) fundamentally changes how the following methods work.

      -  ``RegExp.prototype.test()``
      -  ``RegExp.prototype.exec()``
      -  ``String.prototype.match()``

      How, is explained in `â€œThe flags ``/g`` and ``/y``, and the property
      ``.lastIndex``\ â€ (Â§45.14) <#regexp-flags-gy>`__. In a nutshell, without
      ``/g``, the methods only consider the first match for a regular expression in
      an input string. With ``/g``, they consider all matches.

   -  ``/i`` (``.ignoreCase``) switches on case-insensitive matching:

      .. code:: javascript
         :name: language-node-repl

         > /a/.test('A')
         false
         > /a/i.test('A')
         true

   -  ``/m`` (``.multiline``): If this flag is on, ``^`` matches the beginning of
      each line and ``$`` matches the end of each line. If it is off, ``^`` matches
      the beginning of the whole input string and ``$`` matches the end of the
      whole input string.

      .. code:: javascript
         :name: language-node-repl

         > 'a1\na2\na3'.match(/^a./gm)
         [ 'a1', 'a2', 'a3' ]
         > 'a1\na2\na3'.match(/^a./g)
         [ 'a1' ]

   -  ``/s`` (``.dotAll``): By default, the dot does not match line terminators.
      With this flag, it does:

      .. code:: javascript
         :name: language-node-repl

         > /./.test('\n')
         false
         > /./s.test('\n')
         true

      Workaround: If ``/s`` isnâ€™t supported, we can use ``[^]`` instead of a dot.

      .. code:: javascript
         :name: language-node-repl

         > /[^]/.test('\n')
         true

   -  ``/u`` (``.unicode``): This flag provides better support for Unicode code
      points and is explained in `â€œFlag ``/u``: matching code points [ES6]\ â€
      (Â§45.10.3) <#regexp-flag-unicode>`__.

   -  ``/v`` (``.unicodeSets``): This flag improves on flag ``/u`` and provides
      limited support for multi-code-point grapheme clusters. It also supports set
      operations in character classes. It is explained in `â€œFlag ``/v``: limited
      support for multi-code-point grapheme clusters [ES2024]\ â€
      (Â§45.10.4) <#regexp-flag-unicode-sets>`__.

   -  ``/y`` (``.sticky``): This flag mainly makes sense in conjunction with
      ``/g``. When both are switched on, any match must directly follow the
      previous one (that is, it must start at index ``.lastIndex`` of the regular
      expression object). Therefore, the first match must be at index 0.

      .. code:: javascript
         :name: language-node-repl

         > 'a1a2 a3'.match(/a./gy)
         [ 'a1', 'a2' ]
         > '_a1a2 a3'.match(/a./gy) // first match must be at index 0
         null

         > 'a1a2 a3'.match(/a./g)
         [ 'a1', 'a2', 'a3' ]
         > '_a1a2 a3'.match(/a./g)
         [ 'a1', 'a2', 'a3' ]

      The main use case for ``/y`` is tokenization (during parsing). More
      information on this flag: `â€œThe flags ``/g`` and ``/y``, and the property
      ``.lastIndex``\ â€ (Â§45.14) <#regexp-flags-gy>`__.

45.10.1â€ƒHow to order regular expression flags?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Consider the following regular expression: ``/â€œ([^â€]+)â€/udg``

   In which order should we list its flags? Two options are:

   #. Alphabetical order: ``/dgu``
   #. In order of importance (arguably, ``/u`` is most fundamental etc.): ``/ugd``

   Given that (2) is not obvious, (1) is the better choice. JavaScript also uses it
   for the RegExp property ``.flags`` :

   .. code:: javascript
      :name: language-node-repl

      > /-/gymdivs.flags
      'dgimsvy'

45.10.2â€ƒWithout ``/u`` and ``/v``: matching UTF-16 code units
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Without the flags ``/u`` and ``/v``, most constructs work with single UTF-16
   code units â€“ which is a problem whenever there is a code point with two code
   units â€“ such as ğŸ™‚:

   .. code:: javascript
      :name: language-node-repl

      > 'ğŸ™‚'.length
      2

   We can use code unit escapes â€“ ``\u`` followed by four hexadecimal digits:

   .. code:: javascript
      :name: language-node-repl

      > /^\uD83D\uDE42$/.test('ğŸ™‚')
      true

   The dot operator (``.``) matches code units:

   .. code:: javascript
      :name: language-node-repl

      > 'ğŸ™‚'.match(/./g)
      [ '\uD83D', '\uDE42' ]

   Quantifiers apply to code units:

   .. code:: javascript
      :name: language-node-repl

      > /^ğŸ™‚{2}$/.test('\uD83D\uDE42\uDE42')
      true
      > /^\uD83D\uDE42{2}$/.test('\uD83D\uDE42\uDE42') // equivalent
      true

   Character class escapes define sets of code units:

   .. code:: javascript
      :name: language-node-repl

      > 'ğŸ™‚'.match(/\D/g)
      [ '\uD83D', '\uDE42' ]

   Character classes define sets of code units:

   .. code:: javascript
      :name: language-node-repl

      > /^[ğŸ™‚]$/.test('ğŸ™‚')
      false
      > /^[\uD83D\uDE42]$/.test('\uD83D\uDE42') // equivalent
      false
      > /^[ğŸ™‚]$/.test('\uD83D')
      true



.. _regexp-flag-unicode:

45.10.3â€ƒFlag ``/u``: matching code points [ES6]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In the previous subsection, we encountered problems when we wanted to match a
   code point with more than one UTF-16 code unit â€“ such as ğŸ™‚. Flag ``/u`` enables
   support for this kind of code point and fixes those problems.

   We can use code point escapes â€“ ``\u{}`` with one to six hexadecimal digits:

   .. code:: javascript
      :name: language-node-repl

      > /^\u{1F642}$/u.test('ğŸ™‚')
      true

   The dot operator (``.``) matches code points:

   .. code:: javascript
      :name: language-node-repl

      > 'ğŸ™‚'.match(/./gu)
      [ 'ğŸ™‚' ]

   Quantifiers apply to code points:

   .. code:: javascript
      :name: language-node-repl

      > /^ğŸ™‚{2}$/u.test('ğŸ™‚ğŸ™‚')
      true

   Character class escapes define sets of code points:

   .. code:: javascript
      :name: language-node-repl

      > 'ğŸ™‚'.match(/\D/gu)
      [ 'ğŸ™‚' ]

   A new kind of character class escapes is supported â€“ `Unicode character property
   escapes <#unicode-character-property-escapes>`__:

   .. code:: javascript
      :name: language-node-repl

      > /^\p{Emoji}$/u.test('â›”') // 1 code point (1 code unit)
      true
      > /^\p{Emoji}$/u.test('ğŸ™‚') // 1 code point (2 code units)
      true

   Character classes define sets of code points:

   .. code:: javascript
      :name: language-node-repl

      > /^[ğŸ™‚]$/u.test('ğŸ™‚')
      true
      > /^[ğŸ™‚]$/u.test('\uD83D')
      false



.. _regexp-flag-unicode-sets:

45.10.4â€ƒFlag ``/v``: limited support for multi-code-point grapheme clusters [ES2024]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Use flag ``/v`` whenever you can**

      .. container:: boxout-vspace

      This flag improves many aspects of JavaScriptâ€™s regular expressions and
      should be used by default. If you canâ€™t use it yet because itâ€™s still too
      new, you can use ``/u``, instead.

   -  Flag ``/v`` builds on the improvements brought by flag ``/u`` and fixes
      several of its shortcomings.

   -  Note that flag ``/v`` and flag ``/u`` are mutually exclusive â€“ we canâ€™t use
      them both at the same time:

      .. code:: javascript

         assert.throws(
         () => eval('/-/uv'),
         SyntaxError
         );

45.10.4.1â€ƒLimitation of flag ``/u``: handling grapheme clusters with more than one code point
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Some font glyphs are represented by *grapheme clusters* (code point sequences)
   with more than one code point â€“Â e.g. ğŸ˜µâ€ğŸ’«:

   .. code:: javascript
      :name: language-node-repl

      > Array.from('ğŸ˜µâ€ğŸ’«').length // count code points
      3

   Flag ``/u`` does not help us with those kinds of grapheme clusters:

   .. code:: javascript

      // Grapheme cluster is not matched by single dot
      assert.equal(
      'ğŸ˜µâ€ğŸ’«'.match(/./gu).length, 3
      );

      // Quantifiers only repeat last code point of grapheme cluster
      assert.equal(
      /^ğŸ˜µâ€ğŸ’«{2}$/u.test('ğŸ˜µâ€ğŸ’«ğŸ˜µâ€ğŸ’«'), false
      );

      // Character class escapes only match single code points
      assert.equal(
      /^\p{Emoji}$/u.test('ğŸ˜µâ€ğŸ’«'), false
      );

      // Character classes only match single code points
      assert.equal(
      /^[ğŸ˜µâ€ğŸ’«]$/u.test('ğŸ˜µâ€ğŸ’«'), false
      );

45.10.4.2â€ƒFlag ``/v``: Unicode string property escapes and character class string literals
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Flag ``/v`` works like flag ``/u`` but provides better support for
   multi-code-point grapheme clusters. It doesnâ€™t switch from code points to
   grapheme clusters everywhere, but it does fix the last two issues we encountered
   in the previous subsection â€“ by adding support for multi-code-point grapheme
   clusters to:

   -  Character class escapes â€“ we can refer to `Unicode string
      properties <#unicode-string-properties>`__ via ``\p{}``:

      .. code:: javascript
         :name: language-node-repl

         > /^\p{RGI_Emoji}$/v.test('â›”') // 1 code point (1 code unit)
         true
         > /^\p{RGI_Emoji}$/v.test('ğŸ™‚') // 1 code point (2 code units)
         true
         > /^\p{RGI_Emoji}$/v.test('ğŸ˜µâ€ğŸ’«') // 3 code points
         true

   -  Character classes â€“ ``\q{}`` lets us define `string
      literals <#character-class-string-literals>`__ in character classes:

      .. code:: javascript
         :name: language-node-repl

         > /^[\q{ğŸ˜µâ€ğŸ’«}]$/v.test('ğŸ˜µâ€ğŸ’«')
         true

45.10.4.3â€ƒFlag ``/v``: character class set operations
''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Character classes can be nested and combined via the set operations subtraction
   and intersection â€“ see `â€œSet operations for character classes [ES2024]\ â€
   (Â§45.5.2) <#regexp-character-class-set-operations>`__.

45.10.4.4â€ƒFlag ``/v``: improved case-insensitive matching
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Flag ``/u`` has a quirk when it comes to case-insensitive matching: Using
   ``\P{Â·Â·Â·}`` produces different results than ``[^\p{Â·Â·Â·}]``:

   .. code:: javascript
      :name: language-node-repl

      > /^\P{Lowercase_Letter}$/iu.test('A')
      true
      > /^\P{Lowercase_Letter}$/iu.test('a')
      true

      > /^[^\p{Lowercase_Letter}]$/iu.test('A')
      false
      > /^[^\p{Lowercase_Letter}]$/iu.test('a')
      false

   Observations:

   -  Both ways of negating should produce the same results.
   -  Intuitively, if we add ``/i`` to a regular expression, it should match at
      least as many strings as before â€“ not fewer.

   Flag ``/v`` fixes that quirk:

   .. code:: javascript
      :name: language-node-repl

      > /^\P{Lowercase_Letter}$/iv.test('A')
      false
      > /^\P{Lowercase_Letter}$/iv.test('a')
      false

      > /^[^\p{Lowercase_Letter}]$/iv.test('A')
      false
      > /^[^\p{Lowercase_Letter}]$/iv.test('a')
      false

   Further reading:

   -  `A 2ality blog
      post <https://2ality.com/2022/11/regexp-v-flag.html#improved-case-insensitive-matching>`__
      explains why ``/u`` causes this behavior.
   -  Source of this section: `GitHub issue â€œIgnoreCase vs. complement vs. nested
      classâ€ <https://github.com/tc39/proposal-regexp-v-flag/issues/30>`__

45.11â€ƒProperties of regular expression objects
-----------------------------------------------

   Noteworthy:

   -  Strictly speaking, only ``.lastIndex`` is a real instance property. All other
      properties are implemented via getters.
   -  Accordingly, ``.lastIndex`` is the only mutable property. All other
      properties are read-only. If we want to change them, we need to copy the
      regular expression (consult `â€œCloning and non-destructively modifying regular
      expressionsâ€ (Â§45.1.2) <#cloning-regexps>`__ for details).

45.11.1â€ƒFlags as properties
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Each regular expression flag exists as a property with a longer, more
   descriptive name:

   .. code:: javascript
      :name: language-node-repl

      > /a/i.ignoreCase
      true
      > /a/.ignoreCase
      false

   This is the complete list of flag properties:

   -  ``.dotAll`` (``/s``)
   -  ``.global`` (``/g``)
   -  ``.hasIndices`` (``/d``)
   -  ``.ignoreCase`` (``/i``)
   -  ``.multiline`` (``/m``)
   -  ``.sticky`` (``/y``)
   -  ``.unicode`` (``/u``)
   -  ``.unicodeSets`` (``/v``)

45.11.2â€ƒOther properties
~~~~~~~~~~~~~~~~~~~~~~~~~

   Each regular expression also has the following properties:

   -  ``.source`` :sup:`[ES3]`: The regular expression pattern

      .. code:: javascript
         :name: language-node-repl

         > /abc/ig.source
         'abc'

   -  ``.flags`` :sup:`[ES6]`: The flags of the regular expression

      .. code:: javascript
         :name: language-node-repl

         > /abc/ig.flags
         'gi'

   -  ``.lastIndex`` :sup:`[ES3]`: Used when flag ``/g`` is switched on. Consult
      `â€œThe flags ``/g`` and ``/y``, and the property ``.lastIndex``\ â€
      (Â§45.14) <#regexp-flags-gy>`__ for details.

45.12â€ƒMatch objects
--------------------

   Several regular expression-related methods return so-called *match objects* to
   provide detailed information for the locations where a regular expression
   matches an input string. These methods are:

   -  ``RegExp.prototype.exec()`` returns ``null`` or single match objects.
   -  ``String.prototype.match()`` returns ``null`` or single match objects (if
      flag ``/g`` is not set).
   -  ``String.prototype.matchAll()`` returns an iterable of match objects (flag
      ``/g`` must be set; otherwise, an exception is thrown).

   This is an example:

   .. code:: javascript

      assert.deepEqual(
      /(a+)b/d.exec('ab aaab'),
      {
         0: 'ab',
         1: 'a',
         index: 0,
         input: 'ab aaab',
         groups: undefined,
         indices: {
            0: [0, 2],
            1: [0, 1],
            groups: undefined
         },
      }
      );

   The result of ``.exec()`` is a *match object* for the first match with the
   following properties:

   -  ``[0]``: the complete substring matched by the regular expression
   -  ``[1]``: capture of numbered group 1 (etc.)
   -  ``.index``: where did the match occur?
   -  ``.input``: the string that was matched against
   -  ``.groups``: captures of named groups (see `â€œNamed capture groups [ES2018]\ â€
      (Â§45.13.4.2) <#named-capture-groups>`__)
   -  ``.indices``: the index ranges of captured groups

      -  This property is only created if flag ``/d`` is switched on.



.. _regexp-match-indices:

45.12.1â€ƒMatch indices in match objects [ES2022]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   *Match indices* are a feature of match objects: If we turn it on via the regular
   expression flag ``/d`` (property ``.hasIndices``), they record the start and end
   indices of where groups were captured.

45.12.1.1â€ƒMatch indices for numbered groups
''''''''''''''''''''''''''''''''''''''''''''

   This is how we access the captures of numbered groups:

   .. code:: javascript

      const matchObj = /(a+)(b+)/d.exec('aaaabb');
      assert.equal(
      matchObj[1], 'aaaa'
      );
      assert.equal(
      matchObj[2], 'bb'
      );

   Due to the regular expression flag ``/d``, ``matchObj`` also has a property
   ``.indices`` that records for each numbered group where it was captured in the
   input string:

   .. code:: javascript

      assert.deepEqual(
      matchObj.indices[1], [0, 4]
      );
      assert.deepEqual(
      matchObj.indices[2], [4, 6]
      );

45.12.1.2â€ƒMatch indices for named groups
'''''''''''''''''''''''''''''''''''''''''

   The captures of named groups are accessed likes this:

   .. code:: javascript

      const matchObj = /(?<as>a+)(?<bs>b+)/d.exec('aaaabb');
      assert.equal(
      matchObj.groups.as, 'aaaa');
      assert.equal(
      matchObj.groups.bs, 'bb');

   Their indices are stored in ``matchObj.indices.groups``:

   .. code:: javascript

      assert.deepEqual(
      matchObj.indices.groups.as, [0, 4]);
      assert.deepEqual(
      matchObj.indices.groups.bs, [4, 6]);

45.12.1.3â€ƒA more realistic example
'''''''''''''''''''''''''''''''''''

   One important use case for match indices are parsers that point to where exactly
   a syntactic error is located. The following code solves a related problem: It
   points to where quoted content starts and where it ends (see demonstration at
   the end).

   .. code:: javascript

      const reQuoted = /â€œ([^â€]+)â€/dgu;
      function pointToQuotedText(str) {
      const startIndices = new Set();
      const endIndices = new Set();
      for (const match of str.matchAll(reQuoted)) {
         const [start, end] = match.indices[1];
         startIndices.add(start);
         endIndices.add(end);
      }
      let result = '';
      for (let index=0; index < str.length; index++) {
         if (startIndices.has(index)) {
            result += '[';
         } else if (endIndices.has(index+1)) {
            result += ']';
         } else {
            result += ' ';
         }
      }
      return result;
      }

      assert.equal(
      pointToQuotedText(
         'They said â€œhelloâ€ and â€œgoodbyeâ€.'),
         '           [   ]       [     ]  '
      );

45.13â€ƒMethods for working with regular expressions
---------------------------------------------------

45.13.1â€ƒBy default, regular expressions match anywhere in a string
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   By default, regular expressions match anywhere in a string:

   .. code:: javascript
      :name: language-node-repl

      > /a/.test('__a__')
      true

   We can change that by using assertions such as ``^`` or by using the flag
   ``/y``:

   .. code:: javascript
      :name: language-node-repl

      > /^a/.test('__a__')
      false
      > /^a/.test('a__')
      true



.. _RegExp.prototype.test:

45.13.2â€ƒ``regExp.test(str)``: is there a match? [ES3]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The regular expression method ``.test()`` returns ``true`` if ``regExp`` matches
   ``str``:

   .. code:: javascript
      :name: language-node-repl

      > /bc/.test('ABCD')
      false
      > /bc/i.test('ABCD')
      true
      > /\.mjs$/.test('main.mjs')
      true

   With ``.test()`` we should normally avoid the ``/g`` flag. If we use it, we
   generally donâ€™t get the same result every time we call the method:

   .. code:: javascript
      :name: language-node-repl

      > const r = /a/g;
      > r.test('aab')
      true
      > r.test('aab')
      true
      > r.test('aab')
      false

   The results are due to ``/a/`` having two matches in the string. After all of
   those were found, ``.test()`` returns ``false``.



.. _String.prototype.search:

45.13.3â€ƒ``str.search(regExp)``: at what index is the match? [ES3]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The string method ``.search()`` returns the first index of ``str`` at which
   there is a match for ``regExp``:

   .. code:: javascript
      :name: language-node-repl

      > '_abc_'.search(/abc/)
      1
      > 'main.mjs'.search(/\.mjs$/)
      4



.. _RegExp.prototype.exec:

45.13.4â€ƒ``regExp.exec(str)``: capturing groups [ES3]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

45.13.4.1â€ƒGetting a match object for the first match
'''''''''''''''''''''''''''''''''''''''''''''''''''''

   Without the flag ``/g``, ``.exec()`` returns `a match object <#match-objects>`__
   for the first match of ``regExp`` in ``str``:

   .. code:: javascript

      assert.deepEqual(
      /(a+)b/.exec('ab aab'),
      {
         0: 'ab',
         1: 'a',
         index: 0,
         input: 'ab aab',
         groups: undefined,
      }
      );



.. _named-capture-groups:

45.13.4.2â€ƒNamed capture groups [ES2018]
''''''''''''''''''''''''''''''''''''''''

   The previous example contained a single numbered group. The following example
   demonstrates named groups:

   .. code:: javascript

      assert.deepEqual(
      /(?<as>a+)b/.exec('ab aab'),
      {
         0: 'ab',
         1: 'a',
         index: 0,
         input: 'ab aab',
         groups: { as: 'a' },
      }
      );

   In the result of ``.exec()``, we can see that a named group is also a numbered
   group â€“ its capture exists twice:

   -  Once as a numbered capture (property ``'1'``).
   -  Once as a named capture (property ``groups.as``).

45.13.4.3â€ƒLooping over all matches
'''''''''''''''''''''''''''''''''''

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Better alternative for retrieving all matches:
      ``str.matchAll(regExp)`` [ES2020]**

      .. container:: boxout-vspace

      Since ECMAScript 2020, JavaScript has another method for retrieving all
      matches: `str.matchAll(regExp) <#String.prototype.matchAll>`__. That
      method is easier to use and has fewer caveats.

   If we want to retrieve all matches of a regular expression (not just the first
   one), we need to switch on the flag ``/g``. Then we can call ``.exec()``
   multiple times and get one match each time. After the last match, ``.exec()``
   returns ``null``.

   .. code:: javascript
      :name: language-node-repl

      > const regExp = /(a+)b/g;
      > regExp.exec('ab aab')
      { 0: 'ab', 1: 'a', index: 0, input: 'ab aab', groups: undefined }
      > regExp.exec('ab aab')
      { 0: 'aab', 1: 'aa', index: 3, input: 'ab aab', groups: undefined }
      > regExp.exec('ab aab')
      null

   Therefore, we can loop over all matches as follows:

   .. code:: javascript

      const regExp = /(a+)b/g;
      const str = 'ab aab';

      let match;
      // Check for null via truthiness
      // Alternative: while ((match = regExp.exec(str)) !== null)
      while (match = regExp.exec(str)) {
      console.log(match[1]);
      }

   Output:

   ::

      a
      aa

   .. container:: boxout

      |Icon â€œwarningâ€|â€‚**Be careful when sharing regular expressions with ``/g``!**

      .. container:: boxout-vspace

      Sharing regular expressions with ``/g`` has a few pitfalls, which are
      explained `later <#regexp-flags-gy>`__.

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Extracting quoted text via ``.exec()``**

      .. container:: boxout-vspace

      ``exercises/regexps/extract_quoted_test.mjs``



.. _String.prototype.match:

45.13.5â€ƒ``str.match(regExp)``: getting all group 0 captures [ES3]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Without ``/g``, ``.match()`` works like ``.exec()`` â€“ it returns a single match
   object.

   With ``/g``, ``.match()`` returns all substrings of ``str`` that match
   ``regExp``:

   .. code:: javascript
      :name: language-node-repl

      > 'ab aab'.match(/(a+)b/g)
      [ 'ab', 'aab' ]

   If there is no match, ``.match()`` returns ``null``:

   .. code:: javascript
      :name: language-node-repl

      > 'xyz'.match(/(a+)b/g)
      null

   We can use `the nullish coalescing operator
   (``??``) <#nullish-coalescing-operator>`__ to protect
   ourselves against ``null``:

   .. code:: javascript

      const numberOfMatches = (str.match(regExp) ?? []).length;



.. _String.prototype.matchAll:

45.13.6â€ƒ``str.matchAll(regExp)``: getting an iterable over all match objects [ES2020]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This is how ``.matchAll()`` is invoked:

   .. code:: language-txt

      const matchIterable = str.matchAll(regExp);

   Given a string and a regular expression, ``.matchAll()`` returns an iterable
   over the match objects of all matches.

   In the following example, we use
   `Array.from() <#Array.from>`__ to convert iterables to Arrays
   so that we can compare them better.

   .. code:: javascript
      :name: language-node-repl

      > Array.from('-a-a-a'.matchAll(/-(a)/ug))
      [
      { 0:'-a', 1:'a', index: 0, input: '-a-a-a', groups: undefined },
      { 0:'-a', 1:'a', index: 2, input: '-a-a-a', groups: undefined },
      { 0:'-a', 1:'a', index: 4, input: '-a-a-a', groups: undefined },
      ]

   Flag ``/g`` must be set:

   .. code:: javascript
      :name: language-node-repl

      > Array.from('-a-a-a'.matchAll(/-(a)/u))
      TypeError: String.prototype.matchAll called with a non-global
      RegExp argument

   ``.matchAll()`` isnâ€™t affected by ``regExp.lastIndex`` and doesnâ€™t change it.



.. _implementing-matchall:

45.13.6.1â€ƒImplementing ``.matchAll()``
'''''''''''''''''''''''''''''''''''''''

   ``.matchAll()`` could be implemented via ``.exec()`` as follows:

   .. code:: javascript

      function* matchAll(str, regExp) {
      if (!regExp.global) {
         throw new TypeError('Flag /g must be set!');
      }
      const localCopy = new RegExp(regExp, regExp.flags);
      let match;
      while (match = localCopy.exec(str)) {
         yield match;
      }
      }

   Making a local copy ensures two things:

   -  ``regex.lastIndex`` isnâ€™t changed.
   -  ``localCopy.lastIndex`` is zero.

   Using ``matchAll()``:

   .. code:: javascript

      const str = '"fee" "fi" "fo" "fum"';
      const regex = /"([^"]*)"/g;

      for (const match of matchAll(str, regex)) {
      console.log(match[1]);
      }

   Output:

   ::

      fee
      fi
      fo
      fum



.. _regexp-exec-vs-str-match-vs-str-matchall:

45.13.7â€ƒ``regExp.exec()`` vs. ``str.match()`` vs. ``str.matchAll()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following table summarizes the differences between three methods:

   Without ``/g``

   With ``/g``

   ``regExp.exec(str)``

   First match object

   Next match object or ``null``

   ``str.match(regExp)``

   First match object

   Array of group 0 captures

   ``str.matchAll(regExp)``

   ``TypeError``

   Iterable over match objects



.. _replace-replaceAll:

45.13.8â€ƒReplacing with ``str.replace()`` and ``str.replaceAll()``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Both replacing methods have two parameters:

   -  ``str.replace(searchValue, replacementValue)``
   -  ``str.replaceAll(searchValue, replacementValue)``

   ``searchValue`` can be:

   -  A string
   -  A regular expression

   ``replacementValue`` can be:

   -  String: Replace matches with this string. The character ``$`` has special
      meaning and lets us insert captures of groups and more (details are explained
      later).
   -  Function: Compute strings that replace matches via this function.

   The two methods differ as follows:

   -  ``.replace()`` replaces the first occurrence of a string or a regular
      expression without ``/g``.
   -  ``.replaceAll()`` replaces all occurrences of a string or a regular
      expression with ``/g``.

   This table summarizes how that works:

   Search for: â†’

   string

   RegExp w/o ``/g``

   RegExp with ``/g``

   ``.replace``

   First occurrence

   First occurrence

   (All occurrences)

   ``.replaceAll``

   All occurrences

   ``TypeError``

   All occurrences

   The last column of ``.replace()`` is in parentheses because this method existed
   long before ``.replaceAll()`` and therefore supports functionality that should
   now be handled via the latter method. If we could change that, ``.replace()``
   would throw a ``TypeError`` here.

   We first explore how ``.replace()`` and ``.replaceAll()`` work individually when
   ``replacementValue`` is a simple string (without the character ``$``). Then we
   examine how both are affected by more complicated replacement values.



.. _String.prototype.replace:

45.13.8.1â€ƒ``str.replace(searchValue, replacementValue)`` [ES3]
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   How ``.replace()`` operates is influenced by its first parameter
   ``searchValue``:

   -  Regular expression without ``/g``: Replace first match of this regular
      expression.

      .. code:: javascript
         :name: language-node-repl

         > 'aaa'.replace(/a/, 'x')
         'xaa'

   -  String: Replace first occurrence of this string (the string is interpreted
      verbatim, not as a regular expression).

      .. code:: javascript
         :name: language-node-repl

         > 'aaa'.replace('a', 'x')
         'xaa'

   -  Regular expression with ``/g``: Replace all matches of this regular
      expression.

      .. code:: javascript
         :name: language-node-repl

         > 'aaa'.replace(/a/g, 'x')
         'xxx'

      Recommendation: If ``.replaceAll()`` is available, itâ€™s better to use that
      method in this case â€“ its purpose is to replace multiple occurrences.

   If we want to replace every occurrence of a string, we have two options:

   -  We can use ``.replaceAll()`` (which was introduced in ES2021).

   -  Later in this chapter, we will encounter [the tool function
      ``escapeForRegExp()``) which will help us convert a string into a regular
      expression that matches that string multiple times (e.g., ``'*'`` becomes
      ``/\*/g``).



.. _String.prototype.replaceAll:

45.13.8.2â€ƒ``str.replaceAll(searchValue, replacementValue)`` [ES2021]
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   How ``.replaceAll()`` operates is influenced by its first parameter
   ``searchValue``:

   -  Regular expression with ``/g``: Replace all matches of this regular
      expression.

      .. code:: javascript
         :name: language-node-repl

         > 'aaa'.replaceAll(/a/g, 'x')
         'xxx'

   -  String: Replace all occurrences of this string (the string is interpreted
      verbatim, not as a regular expression).

      .. code:: javascript
         :name: language-node-repl

         > 'aaa'.replaceAll('a', 'x')
         'xxx'

   -  Regular expression without ``/g``: A ``TypeError`` is thrown (because the
      purpose of ``.replaceAll()`` is to replace multiple occurrences).

      .. code:: javascript
         :name: language-node-repl

         > 'aaa'.replaceAll(/a/, 'x')
         TypeError: String.prototype.replaceAll called with
         a non-global RegExp argument



.. _the-parameter-replacementvalue-of-replace-and-replaceall:

45.13.8.3â€ƒThe parameter ``replacementValue`` of ``.replace()`` and ``.replaceAll()``
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   So far, we have only used the parameter ``replacementValue`` with simple
   strings, but it can do more. If its value is:

   -  A string, then matches are replaced with this string. The character ``$`` has
      special meaning and lets us insert captures of groups and more (read on for
      details).

   -  A function, then matches are replaced by strings that are computed via this
      function.

45.13.8.4â€ƒ``replacementValue`` is a string
'''''''''''''''''''''''''''''''''''''''''''

   If the replacement value is a string, the dollar sign has special meaning â€“ it
   inserts text matched by the regular expression:

   Text

   Result

   ``$$``

   single ``$``

   ``$&``

   complete match

   :literal:`$\``

   text before match

   ``$'``

   text after match

   ``$n``

   capture of numbered group ``n`` (``n`` > 0)

   ``$<name>``

   capture of named group ``name`` :sup:`[ES2018]`

   Example: Inserting the text before, inside, and after the matched substring.

   .. code:: javascript
      :name: language-node-repl

      > 'a1 a2'.replaceAll(/a/g, "($`|$&|$')")
      '(|a|1 a2)1 (a1 |a|2)2'

   Example: Inserting the captures of numbered groups.

   .. code:: javascript
      :name: language-node-repl

      > const regExp = /^([A-Za-z]+): (.*)$/ug;
      > 'first: Jane'.replaceAll(regExp, 'KEY: $1, VALUE: $2')
      'KEY: first, VALUE: Jane'

   Example: Inserting the captures of named groups.

   .. code:: javascript
      :name: language-node-repl

      > const regExp = /^(?<key>[A-Za-z]+): (?<value>.*)$/ug;
      > 'first: Jane'.replaceAll(regExp, 'KEY: $<key>, VALUE: $<value>')
      'KEY: first, VALUE: Jane'

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Change quotes via ``.replace()`` and a named
      group**

      .. container:: boxout-vspace

      ``exercises/regexps/change_quotes_test.mjs``

45.13.8.5â€ƒ``replacementValue`` is a function
'''''''''''''''''''''''''''''''''''''''''''''

   If the replacement value is a function, we can compute each replacement. In the
   following example, we multiply each non-negative integer that we find by two.

   .. code:: javascript

      assert.equal(
      '3 cats and 4 dogs'.replaceAll(/[0-9]+/g, (all) => 2 * Number(all)),
      '6 cats and 8 dogs'
      );

   The replacement function gets the following parameters. Note how similar they
   are to match objects. These parameters are all positional, but Iâ€™ve included how
   one might name them:

   -  ``all``: complete match
   -  ``g1``: capture of numbered group 1
   -  Etc.
   -  ``index``: where did the match occur?
   -  ``input``: the string in which we are replacing
   -  ``groups`` :sup:`[ES2018]`: captures of named groups (an object). Always the
      last parameter.

   If we are only interested in ``groups``, we can use the following technique:

   .. code:: javascript

      const result = 'first=jane, last=doe'.replace(
      /(?<key>[a-z]+)=(?<value>[a-z]+)/g,
      (...args) => { // (A)
         const groups = args.at(-1); // (B)
         const {key, value} = groups;
         return key.toUpperCase() + '=' + value.toUpperCase();
      });
      assert.equal(result, 'FIRST=JANE, LAST=DOE');

   Due to the `rest parameter <#rest-parameters>`__ in line A,
   ``args`` contains an Array with all parameters. We access the last parameter via
   `the Array method ``.at() <#Array.prototype.at>`__ in line B.

45.13.9â€ƒOther methods for working with regular expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``String.prototype.split()`` is described `in the chapter on
   strings <#string-api-extracting>`__. Its first parameter of
   ``String.prototype.split()`` is either a string or a regular expression. If it
   is the latter, then captures of groups appear in the result:

   .. code:: javascript
      :name: language-node-repl

      > 'a:b : c'.split(':')
      [ 'a', 'b ', ' c' ]
      > 'a:b : c'.split(/ *: */)
      [ 'a', 'b', 'c' ]
      > 'a:b : c'.split(/( *):( *)/)
      [ 'a', '', '', 'b', ' ', ' ', 'c' ]



.. _regexp-flags-gy:

45.14â€ƒThe flags ``/g`` and ``/y``, and the property ``.lastIndex`` (advanced)
------------------------------------------------------------------------------

   In this section, we examine how the RegExp flags ``/g`` and ``/y`` work and how
   they depend on the RegExp property ``.lastIndex``. Weâ€™ll also discover an
   interesting use case for ``.lastIndex`` that you may find surprising.

45.14.1â€ƒThe flags ``/g`` and ``/y``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Every method reacts differently to ``/g`` and ``/y``; this gives us a rough
   general idea:

   -  ``/g`` (``.global``, ES3): The regular expression should match multiple
      times, anywhere in a string.
   -  ``/y`` (``.sticky``, ES6): Any match inside a string should immediately
      follow a previous match (the matches â€œstickâ€Â together).

   If a regular expression has neither the flag ``/g`` nor the flag ``/y``,
   matching happens once and starts at the beginning.

   With either ``/g`` or ``/y``, matching is performed relative to a â€œcurrent
   positionâ€ inside the input string. That position is stored in the regular
   expression property ``.lastIndex``.

   There are three groups of regular-expression-related methods:

   #. The string methods ``.search(regExp)`` and ``.split(regExp)`` completely
      ignore ``/g`` and ``/y`` (and therefore also ``.lastIndex``).

   #. The ``RegExp`` methods ``.exec(str)`` and ``.test(str)`` change in two ways
      if either ``/g`` or ``/y`` is set.

      First, we get multiple matches, by calling one method repeatedly. Each time,
      it returns either another result (a match object or ``true``) or an â€œend of
      resultsâ€ value (``null`` or ``false``).

      Second, the regular expression property ``.lastIndex`` is used to step
      through the input string. On one hand, ``.lastIndex`` determines where
      matching starts:

      -  ``/g`` means that a match must begin at ``.lastIndex`` or later.

      -  ``/y`` means that a match must begin at ``.lastIndex``. That is, the
         beginning of the regular expression is anchored to ``.lastIndex``.

         Note that ``^`` and ``$`` continue to work as usually: They anchor matches
         to the beginning or end of the input string, unless ``.multiline`` is set.
         Then they anchor to the beginnings or ends of lines.

      On the other hand, ``.lastIndex`` is set to one plus the last index of the
      previous match.

   #. All other methods are affected as follows:

      -  ``/g`` leads to multiple matches.
      -  ``/y`` leads to a single match that must start at ``.lastIndex``.
      -  ``/yg`` leads to multiple matches without gaps.

   This was a first overview. The next sections get into more details.

45.14.2â€ƒHow exactly are methods affected by ``/g`` and ``/y``?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. _regexp-exec-str-es3:

45.14.2.1â€ƒ``regExp.exec(str)`` [ES3]
'''''''''''''''''''''''''''''''''''''

   Without ``/g`` and ``/y``, ``.exec()`` ignores ``.lastIndex`` and always returns
   a match object for the first match:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/; re.lastIndex = 1;
      > [re.exec('##-#'), re.lastIndex]
      [{ 0: '#', index: 0, input: '##-#' }, 1]
      > [re.exec('##-#'), re.lastIndex]
      [{ 0: '#', index: 0, input: '##-#' }, 1]

   With ``/g``, the match must start at ``.lastIndex`` or later. ``.lastIndex`` is
   updated. If there is no match, ``null`` is returned.

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/g; re.lastIndex = 1;
      > [re.exec('##-#'), re.lastIndex]
      [{ 0: '#', index: 1, input: '##-#' }, 2]
      > [re.exec('##-#'), re.lastIndex]
      [{ 0: '#', index: 3, input: '##-#' }, 4]
      > [re.exec('##-#'), re.lastIndex]
      [null, 0]

   With ``/y``, the match must start at exactly ``.lastIndex``. ``.lastIndex`` is
   updated. If there is no match, ``null`` is returned.

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/y; re.lastIndex = 1;
      > [re.exec('##-#'), re.lastIndex]
      [{ 0: '#', index: 1, input: '##-#' }, 2]
      > [re.exec('##-#'), re.lastIndex]
      [null, 0]

   With ``/yg``, ``.exec()`` behaves the same as with ``/y``.



.. _regexp-test-str-es3:

45.14.2.2â€ƒ``regExp.test(str)`` [ES3]
'''''''''''''''''''''''''''''''''''''

   This method behaves the same same as ``.exec()``, but instead of returning a
   match object, it returns ``true``, and instead of returning ``null``, it returns
   ``false``.

   For example, without either ``/g`` or ``/y``, the result is always ``true``:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/; re.lastIndex = 1;
      > [re.test('##-#'), re.lastIndex]
      [true, 1]
      > [re.test('##-#'), re.lastIndex]
      [true, 1]

   With ``/g``, there are two matches:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/g; re.lastIndex = 1;
      > [re.test('##-#'), re.lastIndex]
      [true, 2]
      > [re.test('##-#'), re.lastIndex]
      [true, 4]
      > [re.test('##-#'), re.lastIndex]
      [false, 0]

   With ``/y``, there is only one match:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/y; re.lastIndex = 1;
      > [re.test('##-#'), re.lastIndex]
      [true, 2]
      > [re.test('##-#'), re.lastIndex]
      [false, 0]

   With ``/yg``, ``.test()`` behaves the same as with ``/y``.



.. _str-match-regexp-es3:

45.14.2.3â€ƒ``str.match(regExp)`` [ES3]
''''''''''''''''''''''''''''''''''''''

   Without ``/g``, ``.match()`` works like ``.exec()``. Either without ``/y``:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/; re.lastIndex = 1;
      > ['##-#'.match(re), re.lastIndex]
      [{ 0: '#', index: 0, input: '##-#' }, 1]
      > ['##-#'.match(re), re.lastIndex]
      [{ 0: '#', index: 0, input: '##-#' }, 1]

   Or with ``/y``:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/y; re.lastIndex = 1;
      > ['##-#'.match(re), re.lastIndex]
      [{ 0: '#', index: 1, input: '##-#' }, 2]
      > ['##-#'.match(re), re.lastIndex]
      [null, 0]

   With ``/g``, we get all matches (group 0) in an Array. ``.lastIndex`` is ignored
   and reset to zero.

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/g; re.lastIndex = 1;
      > '##-#'.match(re)
      ['#', '#', '#']
      > re.lastIndex
      0

   ``/yg`` works similarly to ``/g``, but no gaps between matches are allowed:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/yg; re.lastIndex = 1;
      > '##-#'.match(re)
      ['#', '#']
      > re.lastIndex
      0



.. _str-matchall-regexp-es2020:

45.14.2.4â€ƒ``str.matchAll(regExp)`` [ES2020]
''''''''''''''''''''''''''''''''''''''''''''

   If ``/g`` is not set, ``.matchAll()`` throws an exception:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/y; re.lastIndex = 1;
      > '##-#'.matchAll(re)
      TypeError: String.prototype.matchAll called with
      a non-global RegExp argument

   If ``/g`` is set, matching starts at ``.lastIndex`` and that property isnâ€™t
   changed:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/g; re.lastIndex = 1;
      > Array.from('##-#'.matchAll(re))
      [
      { 0: '#', index: 1, input: '##-#' },
      { 0: '#', index: 3, input: '##-#' },
      ]
      > re.lastIndex
      1

   ``/yg`` works similarly to ``/g``, but no gaps between matches are allowed:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/yg; re.lastIndex = 1;
      > Array.from('##-#'.matchAll(re))
      [
      { 0: '#', index: 1, input: '##-#' },
      ]
      > re.lastIndex
      1



.. _str-replace-regexp-str-es3:

45.14.2.5â€ƒ``str.replace(regExp, str)`` [ES3]
'''''''''''''''''''''''''''''''''''''''''''''

   Without ``/g`` and ``/y``, only the first occurrence is replaced:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/; re.lastIndex = 1;
      > '##-#'.replace(re, 'x')
      'x#-#'
      > re.lastIndex
      1

   With ``/g``, all occurrences are replaced. ``.lastIndex`` is ignored but reset
   to zero.

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/g; re.lastIndex = 1;
      > '##-#'.replace(re, 'x')
      'xx-x'
      > re.lastIndex
      0

   With ``/y``, only the (first) occurrence at ``.lastIndex`` is replaced.
   ``.lastIndex`` is updated.

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/y; re.lastIndex = 1;
      > '##-#'.replace(re, 'x')
      '#x-#'
      > re.lastIndex
      2

   ``/yg`` works like ``/g``, but gaps between matches are not allowed:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/yg; re.lastIndex = 1;
      > '##-#'.replace(re, 'x')
      'xx-#'
      > re.lastIndex
      0



.. _str-replaceall-regexp-str-es2021:

45.14.2.6â€ƒ``str.replaceAll(regExp, str)`` [ES2021]
'''''''''''''''''''''''''''''''''''''''''''''''''''

   ``.replaceAll()`` works like ``.replace()`` but throws an exception if ``/g`` is
   not set:

   .. code:: javascript
      :name: language-node-repl

      > const re = /#/y; re.lastIndex = 1;
      > '##-#'.replaceAll(re, 'x')
      TypeError: String.prototype.replaceAll called
      with a non-global RegExp argument

45.14.3â€ƒFour pitfalls of ``/g`` and ``/y`` and how to deal with them
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   We will first look at four pitfalls of ``/g`` and ``/y`` and then at ways of
   dealing with those pitfalls.



.. _pitfall-1-we-can-t-inline-a-regular-expression-with-g-or-y:

45.14.3.1â€ƒPitfall 1: We canâ€™t inline a regular expression with ``/g`` or ``/y``
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   A regular expression with ``/g`` canâ€™t be inlined. For example, in the following
   ``while`` loop, the regular expression is created fresh, every time the
   condition is checked. Therefore, its ``.lastIndex`` is always zero and the loop
   never terminates.

   .. code:: javascript

      let matchObj;
      // Infinite loop
      while (matchObj = /a+/g.exec('bbbaabaaa')) {
      console.log(matchObj[0]);
      }

   With ``/y``, the problem is the same.

45.14.3.2â€ƒPitfall 2: Removing ``/g`` or ``/y`` can break code
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   If code expects a regular expression with ``/g`` and has a loop over the results
   of ``.exec()`` or ``.test()``, then a regular expression without ``/g`` can
   cause an infinite loop:

   .. code:: javascript

      function collectMatches(regExp, str) {
      const matches = [];
      let matchObj;
      // Infinite loop
      while (matchObj = regExp.exec(str)) {
         matches.push(matchObj[0]);
      }
      return matches;
      }
      collectMatches(/a+/, 'bbbaabaaa'); // Missing: flag /g

   Why is there an infinite loop? Because ``.exec()`` always returns the first
   result, a match object, and never ``null``.

   With ``/y``, the problem is the same.

45.14.3.3â€ƒPitfall 3: Adding ``/g`` or ``/y`` can break code
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   With ``.test()``, there is another caveat: It is affected by ``.lastIndex``.
   Therefore, if we want to check exactly once if a regular expression matches a
   string, then the regular expression must not have ``/g``. Otherwise, we
   generally get a different result every time we call ``.test()``:

   .. code:: javascript
      :name: language-node-repl

      > const regExp = /^X/g;
      > [regExp.test('Xa'), regExp.lastIndex]
      [ true, 1 ]
      > [regExp.test('Xa'), regExp.lastIndex]
      [ false, 0 ]
      > [regExp.test('Xa'), regExp.lastIndex]
      [ true, 1 ]

   The first invocation produces a match and updates ``.lastIndex``. The second
   invocation does not find a match and resets ``.lastIndex`` to zero.

   If we create a regular expression specifically for ``.test()``, then we probably
   wonâ€™t add ``/g``. However, the likeliness of encountering ``/g`` increases if we
   use the same regular expression for replacing and for testing.

   Once again, this problem also exists with ``/y``:

   .. code:: javascript
      :name: language-node-repl

      > const regExp = /^X/y;
      > regExp.test('Xa')
      true
      > regExp.test('Xa')
      false
      > regExp.test('Xa')
      true



.. _pitfall-4-code-can-produce-unexpected-results-if-lastindex-isn-t-zero:

45.14.3.4â€ƒPitfall 4: Code can produce unexpected results if ``.lastIndex`` isnâ€™t zero
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Given all the regular expression operations that are affected by ``.lastIndex``,
   we must be careful with many algorithms that ``.lastIndex`` is zero at the
   beginning. Otherwise, we may get unexpected results:

   .. code:: javascript

      function countMatches(regExp, str) {
      let count = 0;
      while (regExp.test(str)) {
         count++;
      }
      return count;
      }

      const myRegExp = /a/g;
      myRegExp.lastIndex = 4;
      assert.equal(
      countMatches(myRegExp, 'babaa'), 1); // should be 3

   Normally, ``.lastIndex`` is zero in newly created regular expressions and we
   wonâ€™t change it explicitly like we did in the example. But ``.lastIndex`` can
   still end up not being zero if we use the regular expression multiple times.

45.14.3.5â€ƒHow to avoid the pitfalls of ``/g`` and ``/y``
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   As an example of dealing with ``/g`` and ``.lastIndex``, we revisit
   ``countMatches()`` from the previous example. How do we prevent a wrong regular
   expression from breaking our code? Letâ€™s look at three approaches.

   `45.14.3.5.1â€ƒThrowing exceptions <#throwing-exceptions>`__
                                                            

   First, we can throw an exception if ``/g`` isnâ€™t set or ``.lastIndex`` isnâ€™t
   zero:

   .. code:: javascript

      function countMatches(regExp, str) {
      if (!regExp.global) {
         throw new Error('Flag /g of regExp must be set');
      }
      if (regExp.lastIndex !== 0) {
         throw new Error('regExp.lastIndex must be zero');
      }
      
      let count = 0;
      while (regExp.test(str)) {
         count++;
      }
      return count;
      }

   `45.14.3.5.2â€ƒCloning regular expressions <#cloning-regular-expressions>`__
                                                                           

   Second, we can clone the parameter. That has the added benefit that ``regExp``
   wonâ€™t be changed.

   .. code:: javascript

      function countMatches(regExp, str) {
      const cloneFlags = regExp.flags + (regExp.global ? '' : 'g');
      const clone = new RegExp(regExp, cloneFlags);

      let count = 0;
      while (clone.test(str)) {
         count++;
      }
      return count;
      }



.. _using-an-operation-that-isn-t-affected-by-lastindex-or-flags:

   `45.14.3.5.3â€ƒUsing an operation that isnâ€™t affected by ``.lastIndex`` or flags <#using-an-operation-that-isn-t-affected-by-lastindex-or-flags>`__
                                                                                                                                                   

   Several regular expression operations are not affected by ``.lastIndex`` or by
   flags. For example, ``.match()`` ignores ``.lastIndex`` if ``/g`` is present:

   .. code:: javascript

      function countMatches(regExp, str) {
      if (!regExp.global) {
         throw new Error('Flag /g of regExp must be set');
      }
      return (str.match(regExp) ?? []).length;
      }

      const myRegExp = /a/g;
      myRegExp.lastIndex = 4;
      assert.equal(countMatches(myRegExp, 'babaa'), 3); // OK!

   Here, ``countMatches()`` works even though we didnâ€™t check or fix
   ``.lastIndex``.



.. _use-case-for-lastindex-starting-matching-at-a-given-index:

45.14.4â€ƒUse case for ``.lastIndex``: starting matching at a given index
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Apart from storing state, ``.lastIndex`` can also be used to start matching at a
   given index. This section describes how.

45.14.4.1â€ƒExample: Checking if a regular expression matches at a given index
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Given that ``.test()`` is affected by ``/y`` and ``.lastIndex``, we can use it
   to check if a regular expression ``regExp`` matches a string ``str`` at a given
   ``index``:

   .. code:: javascript

      function matchesStringAt(regExp, str, index) {
      if (!regExp.sticky) {
         throw new Error('Flag /y of regExp must be set');
      }
      regExp.lastIndex = index;
      return regExp.test(str);
      }
      assert.equal(
      matchesStringAt(/x+/y, 'aaxxx', 0), false);
      assert.equal(
      matchesStringAt(/x+/y, 'aaxxx', 2), true);

   ``regExp`` is anchored to ``.lastIndex`` due to ``/y``.

   Note that we must not use the assertion ``^`` which would anchor ``regExp`` to
   the beginning of the input string.

45.14.4.2â€ƒExample: Finding the location of a match, starting at a given index
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   ``.search()`` lets us find the location where a regular expression matches:

   .. code:: javascript
      :name: language-node-repl

      > '#--#'.search(/#/)
      0

   Alas, we canâ€™t change where ``.search()`` starts looking for matches. As a
   workaround, we can use ``.exec()`` for searching:

   .. code:: javascript

      function searchAt(regExp, str, index) {
      if (!regExp.global && !regExp.sticky) {
         throw new Error('Either flag /g or flag /y of regExp must be set');
      }
      regExp.lastIndex = index;
      const match = regExp.exec(str);
      if (match) {
         return match.index;
      } else {
         return -1;
      }
      }

      assert.equal(
      searchAt(/#/g, '#--#', 0), 0);
      assert.equal(
      searchAt(/#/g, '#--#', 1), 3);

45.14.4.3â€ƒExample: Replacing an occurrence at a given index
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   When used without ``/g`` and with ``/y``, ``.replace()`` makes one replacement â€“
   if there is a match at ``.lastIndex``:

   .. code:: javascript

      function replaceOnceAt(str, regExp, replacement, index) {
      if (!(regExp.sticky && !regExp.global)) {
         throw new Error('Flag /y must be set, flag /g must not be set');
      }
      regExp.lastIndex = index;
      return str.replace(regExp, replacement);
      }
      assert.equal(
      replaceOnceAt('aa aaaa a', /a+/y, 'X', 0), 'X aaaa a');
      assert.equal(
      replaceOnceAt('aa aaaa a', /a+/y, 'X', 3), 'aa X a');
      assert.equal(
      replaceOnceAt('aa aaaa a', /a+/y, 'X', 8), 'aa aaaa X');



.. _the-downsides-of-lastindex:

45.14.5â€ƒThe downsides of ``.lastIndex``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The regular expression property ``.lastIndex`` has two significant downsides:

   -  It makes regular expressions stateful:

      -  We now have to be mindful of the states of regular expressions and how we
         share them.
      -  For many use cases, we canâ€™t make them immutable via freezing, either.

   -  Support for ``.lastIndex`` is inconsistent among regular expression
      operations.

   On the upside, ``.lastIndex`` also gives us additional useful functionality: We
   can dictate where matching should begin (for some operations).



.. _summary-global-g-and-sticky-y:

45.14.6â€ƒSummary: ``.global`` (``/g``) and ``.sticky`` (``/y``)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following two methods are completely unaffected by ``/g`` and ``/y``:

   -  ``String.prototype.search()``
   -  ``String.prototype.split()``

   This table explains how the remaining regular-expression-related methods are
   affected by these two flags:

   ``r.lastIndex = 2``

   Result

   ``r.lastIndex``

   ``exec``

   ``/#/.exec("##-#")``

   ``{i:0}``

   âœ˜

   ``/#/g.exec("##-#")``

   ``{i:3}``

   ``4``

   ``/#/y.exec("##-#")``

   ``null``

   ``0``

   ``test``

   ``/#/.test("##-#")``

   ``true``

   âœ˜

   ``/#/g.test("##-#")``

   ``true``

   ``4``

   ``/#/y.test("##-#")``

   ``false``

   ``0``

   ``match``

   ``"##-#".match(/#/)``

   ``{i:0}``

   âœ˜

   ``"##-#".match(/#/g)``

   ``["#","#","#"]``

   ``0``

   ``"##-#".match(/#/y)``

   ``null``

   ``0``

   ``"##-#".match(/#/gy)``

   ``["#","#"]``

   ``0``

   ``matchAll``

   ``"##-#".matchAll(/#/)``

   ``TypeError``

   âœ˜

   ``"##-#".matchAll(/#/g)``

   ``<{i:3}>``

   âœ˜

   ``"##-#".matchAll(/#/y)``

   ``TypeError``

   âœ˜

   ``"##-#".matchAll(/#/gy)``

   ``<>``

   âœ˜

   ``replace``

   ``"##-#".replace(/#/, "x")``

   ``"x#-#"``

   âœ˜

   ``"##-#".replace(/#/g, "x")``

   ``"xx-x"``

   ``0``

   ``"##-#".replace(/#/y, "x")``

   ``"##-#"``

   ``0``

   ``"##-#".replace(/#/gy, "x")``

   ``"xx-#"``

   ``0``

   ``replaceAll``

   ``"##-#".replaceAll(/#/, "x")``

   ``TypeError``

   âœ˜

   ``"##-#".replaceAll(/#/g, "x")``

   ``"xx-x"``

   ``0``

   ``"##-#".replaceAll(/#/y, "x")``

   ``TypeError``

   âœ˜

   ``"##-#".replaceAll(/#/gy, "x")``

   ``"xx-#"``

   ``0``

   Abbreviations:

   -  ``{i:2}``: a match object whose property ``.index`` has the value ``2``.
   -  ``<i1, i2>``: an iterable with the two items ``i1`` and ``i2``.
   -  âœ˜ means â€œno changeâ€

   .. container:: boxout

      |Icon â€œexternalâ€|â€‚**The Node.js script that generated the previous table**

      .. container:: boxout-vspace

      The previous table was generated via `a Node.js
      script <https://gist.github.com/rauschma/5c90e6c19923611521a61e199d8cb15b>`__.

45.15â€ƒTechniques for working with regular expressions
------------------------------------------------------



.. _escapeForRegExp:

45.15.1â€ƒEscaping arbitrary text for regular expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following function escapes an arbitrary text so that it is matched verbatim
   if we put it inside a regular expression (except inside character classes
   (``[Â·Â·Â·]``)):

   .. code:: javascript

      function escapeForRegExp(str) {
      return str.replace(/[\\^$.*+?\(\)\[\]\{\}\|]/gv, '\\$&'); // (A)
      }
      assert.equal(escapeForRegExp('[yes?]'), String.raw`\[yes\?\]`);
      assert.equal(escapeForRegExp('_g_'), String.raw`_g_`);

   In line A, we escape all syntax characters. We have to be selective because the
   regular expression flags ``/u`` and ``/v`` forbid many escapes â€“ see `â€œSyntax
   characters and escapingâ€ (Â§45.2) <#escaping-for-regexp>`__. Examples:
   ``\a \: \-``

   ``escapeForRegExp()`` has two use cases:

   -  We want to insert plain text into a regular expression that we create
      dynamically via ``new RegExp()``.
   -  We want to replace all occurrences of a plain text string via the regular
      expression method ``.replace()`` (and canâ€™t use ``.replaceAll()``).

   ``.replace()`` only lets us replace plain text once. With ``escapeForRegExp()``,
   we can work around that limitation:

   .. code:: javascript

      const plainText = ':-)';
      const regExp = new RegExp(escapeForRegExp(plainText), 'ug');
      assert.equal(
      ':-) :-) :-)'.replace(regExp, 'ğŸ™‚'), 'ğŸ™‚ ğŸ™‚ ğŸ™‚'
      );

   If you have more complicated requirements such as escaping plain text inside
   character classes, you can take a look at `the
   polyfill <https://github.com/es-shims/regexp.escape>`__ for `the ECMAScript
   proposal
   â€œ\ ``RegExp.escape()``\ â€ <https://github.com/tc39/proposal-regex-escaping>`__.

45.15.2â€ƒMatching everything or nothing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Sometimes, we may need a regular expression that matches everything or nothing â€“
   for example, as a default value.

   -  Match everything: ``/(?:)/``

      The empty group ``()`` matches everything. We make it non-capturing (via
      ``?:``), to avoid unnecessary work.

      .. code:: javascript
         :name: language-node-repl

         > /(?:)/.test('')
         true
         > /(?:)/.test('abc')
         true

   -  Match nothing: ``/.^/``

      ``^`` only matches at the beginning of a string. The dot moves matching
      beyond the first character and now ``^`` doesnâ€™t match anymore.

      .. code:: javascript
         :name: language-node-repl

         > /.^/.test('')
         false
         > /.^/.test('abc')
         false

   Regular expression literals canâ€™t be empty because ``//`` starts a single-line
   comment. Therefore, the first of the previous two regular expressions is used in
   this case:

   .. code:: javascript
      :name: language-node-repl

      > new RegExp('')
      /(?:)/

45.15.3â€ƒUsing a tagged template to write regular expressions that are easier to understand
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   For more information, see `â€œTag function library: regexâ€
   (Â§23.4.2) <#regex-library>`__.

   `Comments <https://github.com/rauschma/exploring-js/issues/34>`__



.. _ch_dates:

46â€ƒDates (``Date``)
====================

   #. `46.1â€ƒBest practice: avoid the built-in Date <#date-libraries>`__

      #. `46.1.1â€ƒThings to look for in a date library <#things-to-look-for-in-a-date-library>`__

   #. `46.2â€ƒTime standards <#time-standards>`__

      #. `46.2.1â€ƒBackground: UTC vs. Z vs. GMT <#background-utc-vs-z-vs-gmt>`__
      #. `46.2.2â€ƒDates do not support time zones <#dates-have-no-time-zones>`__

   #. `46.3â€ƒBackground: date time formats (ISO) <#date-time-formats>`__

      #. `46.3.1â€ƒTip: append a Z to make date parsing deterministic <#tip-append-a-z-to-make-date-parsing-deterministic>`__

   #. `46.4â€ƒTime values <#time-values>`__

      #. `46.4.1â€ƒCreating time values <#creating-time-values>`__
      #. `46.4.2â€ƒGetting and setting time values <#getting-and-setting-time-values>`__

   #. `46.5â€ƒCreating Dates <#creating-dates>`__

      #. `46.5.1â€ƒCreating dates via numbers <#creating-dates-via-numbers>`__
      #. `46.5.2â€ƒParsing dates from strings <#parsing-dates-from-strings>`__
      #. `46.5.3â€ƒOther ways of creating dates <#other-ways-of-creating-dates>`__

   #. `46.6â€ƒGetters and setters <#getters-and-setters>`__

      #. `46.6.1â€ƒTime unit getters and setters <#time-unit-getters-and-setters>`__

   #. `46.7â€ƒConverting Dates to strings <#converting-dates-to-strings>`__

      #. `46.7.1â€ƒStrings with times <#strings-with-times>`__
      #. `46.7.2â€ƒStrings with dates <#strings-with-dates>`__
      #. `46.7.3â€ƒStrings with dates and times <#strings-with-dates-and-times>`__
      #. `46.7.4â€ƒOther methods <#other-methods>`__

   This chapter describes JavaScriptâ€™s API for working with dates â€“ the class
   ``Date``.



.. _date-libraries:

46.1â€ƒBest practice: avoid the built-in ``Date``
------------------------------------------------

   The JavaScript ``Date`` API is cumbersome to use. Hence, itâ€™s best to rely on a
   library for anything related to dates. Popular libraries include:

   -  Libraries with custom date objects (for complex use cases):

      -  `Luxon <https://moment.github.io/luxon/>`__
      -  `Day.js <https://github.com/iamkun/dayjs>`__
      -  `js-joda <https://js-joda.github.io/js-joda/>`__
      -  `Moment.js <https://momentjs.com>`__

   -  Libraries that use the built-in ``Date`` objects (for simpler use cases):

      -  `Tempo <https://tempo.formkit.com>`__
      -  `date-fns <https://github.com/date-fns/date-fns>`__

   -  The ``Intl`` API is supported by most JavaScript platforms:
      `Intl.DateTimeFormat <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat>`__
      provides language-sensitive date and time formatting.

   Additionally, TC39 is working on a new date API for JavaScript:
   `Temporal <https://github.com/tc39/proposal-temporal>`__.

46.1.1â€ƒThings to look for in a date library
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Two things are important to keep in mind:

   -  `Tree-shaking <#tree-shaking>`__ can considerably reduce
      the size of a library. It is a technique of only deploying those exports of a
      library to a web server that are imported somewhere. Functions are much more
      amenable to tree-shaking than classes.

   -  Support for time zones: As explained `later <#dates-have-no-time-zones>`__,
      ``Date`` does not support time zones, which introduces a number of pitfalls
      and is a key weakness. Make sure that your date library supports them.

46.2â€ƒTime standards
--------------------



.. _background-utc-vs-z-vs-gmt:

46.2.1â€ƒBackground: UTC vs. Z vs. GMT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   UTC, Z, and GMT are ways of specifying time that are similar, but subtly
   different:

   -  UTC (Coordinated Universal Time) is the time standard that all times zones
      are based on. They are specified relative to it. That is, no country or
      territory has UTC as its local time zone.

   -  Z (Zulu Time Zone) is a military time zone that is often used in aviation and
      the military as another name for UTC+0.

   -  GMT (Greenwich Mean Time) is a time zone used in some European and African
      countries. It is UTC plus zero hours and therefore has the same time as UTC.

   Sources:

   -  `â€œThe Difference Between GMT and
      UTCâ€ <https://www.timeanddate.com/time/gmt-utc-time.html>`__ at
      TimeAndDate.com
   -  `â€œZ â€“ Zulu Time Zone (Military
      Time)â€ <https://www.timeanddate.com/time/zones/z>`__ at TimeAndDate.com



.. _dates-have-no-time-zones:

46.2.2â€ƒDates do not support time zones
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Dates support the following time standards:

   -  The local time zone (which depends on the current location)
   -  UTC
   -  Time offsets (relative to UTC)

   Depending on the operation, only some of those options are available. For
   example, when converting dates to strings or extracting time units such as the
   day of the month, you can only choose between the local time zone and UTC.

   Internally, Dates are stored as UTC. When converting from or to the local time
   zone, the necessary offsets are determined via the date. In the following
   example, the local time zone is Europe/Paris:

   .. code:: javascript

      // CEST (Central European Summer Time)
      assert.equal(
      new Date('2122-06-29').getTimezoneOffset(), -120);
      
      // CET (Central European Time)
      assert.equal(
      new Date('2122-12-29').getTimezoneOffset(), -60);

   Whenever you create or convert dates, you need to be mindful of the time
   standard being used â€“ for example: ``new Date()`` uses the local time zone while
   ``.toISOString()`` uses UTC.

   .. code:: javascript
      :name: language-node-repl

      > new Date(2077, 0, 27).toISOString()
      '2077-01-26T23:00:00.000Z'

   Dates interpret 0 as January. The day of the month is 27 in the local time zone,
   but 26 in UTC.

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Documenting the time standards supported by each operation**

      .. container:: boxout-vspace

      In the remainder of this chapter, the supported time standards are noted for
      each operation.

46.2.2.1â€ƒThe downsides of not being able to specify time zones
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Not being able to specify time zones has two downsides:

   -  It makes it impossible to support multiple time zones.

   -  It can lead to location-specific bugs. For example, the previous example
      produces different results depending on where it is executed. To be safe:

      -  Use UTC-based operations whenever possible
      -  Use ``Z`` or a time offset when parsing strings (see the next section for
         more information).



.. _date-time-formats:

46.3â€ƒBackground: date time formats (ISO)
-----------------------------------------

   Date time formats describe:

   -  The strings accepted by:

      -  ``Date.parse()``
      -  ``new Date()``

   -  The strings returned by (always longest format):

      -  ``Date.prototype.toISOString()``

   The following is an example of a date time string returned by
   ``.toISOString()``:

   .. code:: javascript

      '2033-05-28T15:59:59.123Z'

   Date time formats have the following structures:

   -  Date formats: Y=year; M=month; D=day

      .. code:: language-txt

         YYYY-MM-DD
         YYYY-MM
         YYYY

   -  Time formats: T=separator (the string ``'T'``); H=hour; m=minute; s=second
      and millisecond; Z=Zulu Time Zone (the string ``'Z'``)

      .. code:: language-txt

         THH:mm:ss.sss
         THH:mm:ss.sssZ

         THH:mm:ss
         THH:mm:ssZ

         THH:mm
         THH:mmZ

   -  Date time formats: are date formats followed by time formats.

      -  For example (longest): ``YYYY-MM-DDTHH:mm:ss.sssZ``

   Instead of ``Z`` (which is UTC+0), we can also specify *time offsets* relative
   to UTC:

   -  ``THH:mm+HH:mm`` (etc.)
   -  ``THH:mm-HH:mm`` (etc.)

46.3.1â€ƒTip: append a ``Z`` to make date parsing deterministic
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If you add a ``Z`` to the end of a string, date parsing doesnâ€™t produce
   different results at different locations:

   -  Without ``Z``: Input is January 27 (in the Europe/Paris time zone), output is
      January 26 (in UTC).

      .. code:: javascript
         :name: language-node-repl

         > new Date('2077-01-27T00:00').toISOString()
         '2077-01-26T23:00:00.000Z'

   -  With ``Z``: Input is January 27, output is January 27.

      .. code:: javascript
         :name: language-node-repl

         > new Date('2077-01-27T00:00Z').toISOString()
         '2077-01-27T00:00:00.000Z'

46.4â€ƒTime values
-----------------

   A *time value* represents a date via the number of milliseconds since 1 January
   1970 00:00:00 UTC.

   Time values can be used to create Dates:

   .. code:: javascript

      const timeValue = 0;
      assert.equal(
      new Date(timeValue).toISOString(),
      '1970-01-01T00:00:00.000Z');

   Coercing a Date to a number returns its time value:

   .. code:: javascript
      :name: language-node-repl

      > Number(new Date(123))
      123

   Ordering operators coerce their operands to numbers. Therefore, you can use
   these operators to compare Dates:

   .. code:: javascript

      assert.equal(
      new Date('1972-05-03') < new Date('2001-12-23'), true);

      // Internally:
      assert.equal(73699200000 < 1009065600000, true);

46.4.1â€ƒCreating time values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following methods create time values:

   -  ``Date.now(): number`` (UTC)

      Returns the current time as a time value.

   -  ``Date.parse(dateTimeStr: string): number`` (local time zone, UTC, time
      offset)

      Parses ``dateTimeStr`` and returns the corresponding time value.

   -  ``Date.UTC(year, month, date?, hours?, minutes?, seconds?, milliseconds?): number``
      (UTC)

      Returns the time value for the specified UTC date time.

46.4.2â€ƒGetting and setting time values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Date.prototype.getTime(): number`` (UTC)

      Returns the time value corresponding to the Date.

   -  ``Date.prototype.setTime(timeValue)`` (UTC)

      Sets ``this`` to the date encoded by ``timeValue``.

46.5â€ƒCreating Dates
--------------------

46.5.1â€ƒCreating dates via numbers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``new Date(year: number, month: number, date?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number)``
   (local time zone)

   Two of the parameters have pitfalls:

   -  For ``month``, 0 is January, 1 is February, etc.

   -  If 0 â‰¤ ``year`` â‰¤ 99, then 1900 is added:

      .. code:: javascript
         :name: language-node-repl

         > new Date(12, 1, 22, 19, 11).getFullYear()
         1912

      Thatâ€™s why, elsewhere in this chapter, we avoid the time unit ``year`` and
      always use ``fullYear``. But in this case, we have no choice.

   Example:

   .. code:: javascript
      :name: language-node-repl

      > new Date(2077,0,27, 21,49).toISOString() // CET (UTC+1)
      '2077-01-27T20:49:00.000Z'

   Note that the input hours (21) are different from the output hours (20). The
   former refer to the local time zone, the latter to UTC.

46.5.2â€ƒParsing dates from strings
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``new Date(dateTimeStr: string)`` (local time zone, UTC, time offset)

   If there is a ``Z`` at the end, UTC is used:

   .. code:: javascript
      :name: language-node-repl

      > new Date('2077-01-27T00:00Z').toISOString()
      '2077-01-27T00:00:00.000Z'

   If there is no ``Z`` or time offset at the end, the local time zone is used:

   .. code:: javascript
      :name: language-node-repl

      > new Date('2077-01-27T00:00').toISOString() // CET (UTC+1)
      '2077-01-26T23:00:00.000Z'

   If a string only contains a date, it is interpreted as UTC:

   .. code:: javascript
      :name: language-node-repl

      > new Date('2077-01-27').toISOString()
      '2077-01-27T00:00:00.000Z'

46.5.3â€ƒOther ways of creating dates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``new Date(timeValue: number)`` (UTC)

      .. code:: javascript
         :name: language-node-repl

         > new Date(0).toISOString()
         '1970-01-01T00:00:00.000Z'

   -  ``new Date()`` (UTC)

      The same as ``new Date(Date.now())``.

46.6â€ƒGetters and setters
-------------------------

46.6.1â€ƒTime unit getters and setters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Dates have getters and setters for time units â€“ for example:

   -  ``Date.prototype.getFullYear()``
   -  ``Date.prototype.setFullYear(num)``

   These getters and setters conform to the following patterns:

   -  Local time zone:

      -  ``Date.prototype.getÂ«UnitÂ»()``
      -  ``Date.prototype.setÂ«UnitÂ»(num)``

   -  UTC:

      -  ``Date.prototype.getUTCÂ«UnitÂ»()``
      -  ``Date.prototype.setUTCÂ«UnitÂ»(num)``

   These are the time units that are supported:

   -  Date

      -  ``FullYear``
      -  ``Month``: month (0â€“11). **Pitfall:** 0 is January, etc.
      -  ``Date``: day of the month (1â€“31)
      -  ``Day`` (getter only): day of the week (0â€“6, 0 is Sunday)

   -  Time

      -  ``Hours``: hour (0â€“23)
      -  ``Minutes``: minutes (0â€“59)
      -  ``Seconds``: seconds (0â€“59)
      -  ``Milliseconds``: milliseconds (0â€“999)

   There is one more getter that doesnâ€™t conform to the previously mentioned
   patterns:

   -  ``Date.prototype.getTimezoneOffset()``

      Returns the time difference between local time zone and UTC in minutes. For
      example, for Europe/Paris, it returns ``-120`` (CEST, Central European Summer
      Time) or ``-60`` (CET, Central European Time):

      .. code:: javascript
         :name: language-node-repl

         > new Date('2122-06-29').getTimezoneOffset()
         -120
         > new Date('2122-12-29').getTimezoneOffset()
         -60

46.7â€ƒConverting Dates to strings
---------------------------------

   Example Date:

   .. code:: javascript

      const d = new Date(0);

46.7.1â€ƒStrings with times
~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Date.prototype.toTimeString()`` (local time zone)

      .. code:: javascript
         :name: language-node-repl

         > d.toTimeString()
         '01:00:00 GMT+0100 (Central European Standard Time)'

46.7.2â€ƒStrings with dates
~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Date.prototype.toDateString()`` (local time zone)

      .. code:: javascript
         :name: language-node-repl

         > d.toDateString()
         'Thu Jan 01 1970'

46.7.3â€ƒStrings with dates and times
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   -  ``Date.prototype.toString()`` (local time zone)

      .. code:: javascript
         :name: language-node-repl

         > d.toString()
         'Thu Jan 01 1970 01:00:00 GMT+0100 (Central European Standard Time)'

   -  ``Date.prototype.toUTCString()`` (UTC)

      .. code:: javascript
         :name: language-node-repl

         > d.toUTCString()
         'Thu, 01 Jan 1970 00:00:00 GMT'

   -  ``Date.prototype.toISOString()`` (UTC)

      .. code:: javascript
         :name: language-node-repl

         > d.toISOString()
         '1970-01-01T00:00:00.000Z'

46.7.4â€ƒOther methods
~~~~~~~~~~~~~~~~~~~~~

   The following three methods are not really part of ECMAScript, but rather of
   `the ECMAScript internationalization
   API <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl>`__.
   That API has much functionality for formatting dates (including support for time
   zones), but not for parsing them.

   -  ``Date.prototype.toLocaleTimeString()``
   -  ``Date.prototype.toLocaleDateString()``
   -  ``Date.prototype.toLocaleString()``

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Creating a date string**

      .. container:: boxout-vspace

      ``exercises/dates/create_date_string_test.mjs``

   `Comments <https://github.com/rauschma/exploring-js/issues/40>`__



.. _ch_json:

47â€ƒCreating and parsing JSON (``JSON``)
========================================

   #. `47.1â€ƒThe discovery and standardization of JSON <#the-discovery-and-standardization-of-json>`__

      #. `47.1.1â€ƒJSONâ€™s grammar is frozen <#json-s-grammar-is-frozen>`__

   #. `47.2â€ƒJSON syntax <#json-syntax>`__
   #. `47.3â€ƒUsing the JSON API <#using-the-json-api>`__

      #. `47.3.1â€ƒJSON.stringify(data, replacer?, space?) <#JSON.stringify>`__
      #. `47.3.2â€ƒJSON.parse(text, reviver?) <#json-parse-text-reviver>`__
      #. `47.3.3â€ƒExample: converting to and from JSON <#example-converting-to-and-from-json>`__

   #. `47.4â€ƒCustomizing stringification and parsing (advanced) <#json-replacers-revivers>`__

      #. `47.4.1â€ƒ.stringfy(): specifying which properties of objects to stringify <#stringfy-specifying-which-properties-of-objects-to-stringify>`__
      #. `47.4.2â€ƒ.stringify() and .parse(): value visitors <#json-value-visitors>`__
      #. `47.4.3â€ƒExample: visiting values <#example-visiting-values>`__
      #. `47.4.4â€ƒExample: stringifying unsupported values <#example-stringifying-unsupported-values>`__
      #. `47.4.5â€ƒExample: parsing unsupported values <#example-parsing-unsupported-values>`__

   #. `47.5â€ƒFAQ <#faq>`__

      #. `47.5.1â€ƒWhy doesnâ€™t JSON support comments? <#why-doesn-t-json-support-comments>`__

   JSON (â€œJavaScript Object Notationâ€) is a storage format that uses text to encode
   data. Its syntax is a subset of JavaScript expressions. As an example, consider
   the following text, stored in a file ``jane.json``:

   .. code:: javascript

      {
      "first": "Jane",
      "last": "Porter",
      "married": true,
      "born": 1890,
      "friends": [ "Tarzan", "Cheeta" ]
      }

   JavaScript has the global namespace object ``JSON`` that provides methods for
   creating and parsing JSON.

47.1â€ƒThe discovery and standardization of JSON
-----------------------------------------------

   A specification for JSON was published by Douglas Crockford in 2001, at
   `json.org <http://json.org/>`__. He explains:

      I discovered JSON. I do not claim to have invented JSON because it already
      existed in nature. What I did was I found it, I named it, I described how it
      was useful. I don't claim to be the first person to have discovered it; I
      know that there are other people who discovered it at least a year before I
      did. The earliest occurrence I've found was, there was someone at Netscape
      who was using JavaScript array literals for doing data communication as early
      as 1996, which was at least five years before I stumbled onto the idea.

   Later, JSON was standardized as
   `ECMA-404 <https://ecma-international.org/publications-and-standards/standards/ecma-404/>`__:

   -  1st edition: October 2013
   -  2nd edition: December 2017



.. _json-s-grammar-is-frozen:

47.1.1â€ƒJSONâ€™s grammar is frozen
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Quoting the ECMA-404 standard:

      Because it is so simple, it is not expected that the JSON grammar will ever
      change. This gives JSON, as a foundational notation, tremendous stability.

   Therefore, JSON will never get improvements such as optional trailing commas,
   comments, or unquoted keys â€“ independently of whether or not they are considered
   desirable. However, that still leaves room for creating supersets of JSON that
   compile to plain JSON.

47.2â€ƒJSON syntax
-----------------

   JSON consists of the following parts of JavaScript:

   -  Compound:

      -  Object literals:

         -  Property keys are double-quoted strings.
         -  Property values are JSON values.
         -  No trailing commas are allowed.

      -  Array literals:

         -  Elements are JSON values.
         -  No holes or trailing commas are allowed.

   -  Atomic:

      -  ``null`` (but not ``undefined``)
      -  Booleans
      -  Numbers (excluding ``NaN``, ``+Infinity``, ``-Infinity``)
      -  Strings (must be double-quoted)

   As a consequence, you canâ€™t (directly) represent cyclic structures in JSON.

47.3â€ƒUsing the ``JSON`` API
----------------------------

   The global namespace object ``JSON`` contains methods for working with JSON
   data.



.. _JSON.stringify:

47.3.1â€ƒ``JSON.stringify(data, replacer?, space?)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.stringify()`` converts JavaScript ``data`` to a JSON string. In this section,
   we are ignoring the parameter ``replacer``; it is explained in `â€œCustomizing
   stringification and parsingâ€ (Â§47.4) <#json-replacers-revivers>`__.

47.3.1.1â€ƒResult: a single line of text
'''''''''''''''''''''''''''''''''''''''

   If you only provide the first argument, ``.stringify()`` returns a single line
   of text:

   .. code:: javascript

      assert.equal(
      JSON.stringify({foo: ['a', 'b']}),
      '{"foo":["a","b"]}' );

47.3.1.2â€ƒResult: a tree of indented lines
''''''''''''''''''''''''''''''''''''''''''

   If you provide a non-negative integer for ``space``, then ``.stringify()``
   returns one or more lines and indents by ``space`` spaces per level of nesting:

   .. code:: javascript

      assert.equal(
      JSON.stringify({foo: ['a', 'b']}, null, 2),
      `{
      "foo": [
         "a",
         "b"
      ]
      }`);



.. _stringification-details:

47.3.1.3â€ƒDetails on how JavaScript data is stringified
'''''''''''''''''''''''''''''''''''''''''''''''''''''''

   **Primitive values:**

   -  Supported primitive values are stringified as expected:

      .. code:: javascript
         :name: language-node-repl

         > JSON.stringify('abc')
         '"abc"'
         > JSON.stringify(123)
         '123'
         > JSON.stringify(null)
         'null'

   -  Unsupported numbers: ``'null'``

      .. code:: javascript
         :name: language-node-repl

         > JSON.stringify(NaN)
         'null'
         > JSON.stringify(Infinity)
         'null'

   -  Bigints: ``TypeError``

      .. code:: javascript
         :name: language-node-repl

         > JSON.stringify(123n)
         TypeError: Do not know how to serialize a BigInt

   -  Other unsupported primitive values are not stringified; they produce the
      result ``undefined``:

      .. code:: javascript
         :name: language-node-repl

         > JSON.stringify(undefined)
         undefined
         > JSON.stringify(Symbol())
         undefined

   **Objects:**

   -  If an object has a method ``.toJSON()``, then the result of that method is
      stringified:

      .. code:: javascript
         :name: language-node-repl

         > JSON.stringify({toJSON() {return true}})
         'true'

      Dates have a method ``.toJSON()`` that returns a string:

      .. code:: javascript
         :name: language-node-repl

         > JSON.stringify(new Date(2999, 11, 31))
         '"2999-12-30T23:00:00.000Z"'

   -  Wrapped primitive values are unwrapped and stringified:

      .. code:: javascript
         :name: language-node-repl

         > JSON.stringify(new Boolean(true))
         'true'
         > JSON.stringify(new Number(123))
         '123'

   -  Arrays are stringified as Array literals. Unsupported Array elements are
      stringified as if they were ``null``:

      .. code:: javascript
         :name: language-node-repl

         > JSON.stringify([undefined, 123, Symbol()])
         '[null,123,null]'

   -  All other objects â€“ except for functions â€“ are stringified as object
      literals. Properties with unsupported values are omitted:

      .. code:: javascript
         :name: language-node-repl

         > JSON.stringify({a: Symbol(), b: true})
         '{"b":true}'

   -  Functions are not stringified:

      .. code:: javascript
         :name: language-node-repl

         > JSON.stringify(() => {})
         undefined



.. _json-parse-text-reviver:

47.3.2â€ƒ``JSON.parse(text, reviver?)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``.parse()`` converts a JSON ``text`` to a JavaScript value. In this section, we
   are ignoring the parameter ``reviver``; it is explained in `â€œCustomizing
   stringification and parsingâ€ (Â§47.4) <#json-replacers-revivers>`__.

   This is an example of using ``.parse()``:

   .. code:: javascript
      :name: language-node-repl

      > JSON.parse('{"foo":["a","b"]}')
      { foo: [ 'a', 'b' ] }

47.3.3â€ƒExample: converting to and from JSON
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following class implements conversions from (line A) and to (line B) JSON.

   .. code:: javascript

      class Point {
      static fromJson(jsonObj) { // (A)
         return new Point(jsonObj.x, jsonObj.y);
      }

      constructor(x, y) {
         this.x = x;
         this.y = y;
      }
      
      toJSON() { // (B)
         return {x: this.x, y: this.y};
      }
      }

   -  Converting JSON to a point: We use the static method ``Point.fromJson()`` to
      parse JSON and create an instance of ``Point``.

      .. code:: javascript

         assert.deepEqual(
         Point.fromJson(JSON.parse('{"x":3,"y":5}')),
         new Point(3, 5) );

   -  Converting a point to JSON: ``JSON.stringify()`` internally calls `the
      previously mentioned method ``.toJSON() <#stringification-details>`__.

      .. code:: javascript

         assert.equal(
         JSON.stringify(new Point(3, 5)),
         '{"x":3,"y":5}' );

   .. container:: boxout

      |Icon â€œexerciseâ€|â€‚**Exercise: Converting an object to and from JSON**

      .. container:: boxout-vspace

      ``exercises/json/to_from_json_test.mjs``



.. _json-replacers-revivers:

47.4â€ƒCustomizing stringification and parsing (advanced)
--------------------------------------------------------

   Stringification and parsing can be customized as follows:

   -  ``JSON.stringify(data, replacer?, space?)``

      The optional parameter ``replacer`` contains either:

      -  An Array with names of properties. If a value in ``data`` is stringified
         as an object literal, then only the mentioned properties are considered.
         All other properties are ignored.
      -  A *value visitor*, a function that can transform JavaScript data before it
         is stringified.

   -  ``JSON.parse(text, reviver?)``

      The optional parameter ``reviver`` contains a value visitor that can
      transform the parsed JSON data before it is returned.

47.4.1â€ƒ``.stringfy()``: specifying which properties of objects to stringify
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If the second parameter of ``.stringify()`` is an Array, then only object
   properties, whose names are mentioned there, are included in the result:

   .. code:: javascript

      const obj = {
      a: 1,
      b: {
         c: 2,
         d: 3,
      }
      };
      assert.equal(
      JSON.stringify(obj, ['b', 'c']),
      '{"b":{"c":2}}');



.. _json-value-visitors:

47.4.2â€ƒ``.stringify()`` and ``.parse()``: value visitors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   What I call a *value visitor* is a function that transforms JavaScript data:

   -  ``JSON.stringify()`` lets the value visitor in its parameter ``replacer``
      transform JavaScript data before it is stringified.
   -  ``JSON.parse()`` lets the value visitor in its parameter ``reviver``
      transform parsed JavaScript data before it is returned.

   In this section, JavaScript data is considered to be a tree of values. If the
   data is atomic, it is a tree that only has a root. All values in the tree are
   fed to the value visitor, one at a time. Depending on what the visitor returns,
   the current value is omitted, changed, or preserved.

   A value visitor has the following type signature:

   .. code:: javascript
      :name: language-ts

      type ValueVisitor = (key: string, value: any) => any;

   The parameters are:

   -  ``value``: The current value.
   -  ``this``: Parent of current value. The parent of the root value ``r`` is
      ``{'': r}``.

      -  Note: ``this`` is an implicit parameter and only available if the value
         visitor is an ordinary function.

   -  ``key``: Key or index of the current value inside its parent. The key of the
      root value is ``''``.

   The value visitor can return:

   -  ``value``: means there wonâ€™t be any change.
   -  A different value ``x``: leads to ``value`` being replaced with ``x`` in the
      output tree.
   -  ``undefined``: leads to ``value`` being omitted in the output tree.

47.4.3â€ƒExample: visiting values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The following code shows in which order a value visitor sees values:

   .. code:: javascript

      const log = [];
      function valueVisitor(key, value) {
      log.push({this: this, key, value});
      return value; // no change
      }

      const root = {
      a: 1,
      b: {
         c: 2,
         d: 3,
      }
      };
      JSON.stringify(root, valueVisitor);
      assert.deepEqual(log, [
      { this: { '': root }, key: '',  value: root   },
      { this: root        , key: 'a', value: 1      },
      { this: root        , key: 'b', value: root.b },
      { this: root.b      , key: 'c', value: 2      },
      { this: root.b      , key: 'd', value: 3      },
      ]);

   As we can see, the replacer of ``JSON.stringify()`` visits values top-down (root
   first, leaves last). The rationale for going in that direction is that we are
   converting JavaScript values to JSON values. And a single JavaScript object may
   be expanded into a tree of JSON-compatible values.

   In contrast, the reviver of ``JSON.parse()`` visits values bottom-up (leaves
   first, root last). The rationale for going in that direction is that we are
   assembling JSON values into JavaScript values. Therefore, we need to convert the
   parts before we can convert the whole.

47.4.4â€ƒExample: stringifying unsupported values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   ``JSON.stringify()`` has no special support for regular expression objects â€“ it
   stringifies them as if they were plain objects:

   .. code:: javascript

      const obj = {
      name: 'abc',
      regex: /abc/ui,
      };
      assert.equal(
      JSON.stringify(obj),
      '{"name":"abc","regex":{}}');

   We can fix that via a replacer:

   .. code:: javascript

      function replacer(key, value) {
      if (value instanceof RegExp) {
         return {
            __type__: 'RegExp',
            source: value.source,
            flags: value.flags,
         };
      } else {
         return value; // no change
      }
      }
      assert.equal(
      JSON.stringify(obj, replacer, 2),
      `{
      "name": "abc",
      "regex": {
         "__type__": "RegExp",
         "source": "abc",
         "flags": "iu"
      }
      }`);

47.4.5â€ƒExample: parsing unsupported values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   To ``JSON.parse()`` the result from the previous section, we need a reviver:

   .. code:: javascript

      function reviver(key, value) {
      // Very simple check
      if (value && value.__type__ === 'RegExp') {
         return new RegExp(value.source, value.flags);
      } else {
         return value;
      }
      }
      const str = `{
      "name": "abc",
      "regex": {
         "__type__": "RegExp",
         "source": "abc",
         "flags": "iu"
      }
      }`;
      assert.deepEqual(
      JSON.parse(str, reviver),
      {
         name: 'abc',
         regex: /abc/ui,
      });

47.5â€ƒFAQ
---------



.. _why-doesn-t-json-support-comments:

47.5.1â€ƒWhy doesnâ€™t JSON support comments?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Douglas Crockford explains why in `a Google+ post from 1 May
   2012 <https://web.archive.org/web/20190308024153/https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr>`__:

      I removed comments from JSON because I saw people were using them to hold
      parsing directives, a practice which would have destroyed interoperability. I
      know that the lack of comments makes some people sad, but it shouldn't.

      Suppose you are using JSON to keep configuration files, which you would like
      to annotate. Go ahead and insert all the comments you like. Then pipe it
      through JSMin [a minifier for JavaScript] before handing it to your JSON
      parser.

   `Comments <https://github.com/rauschma/exploring-js/issues/39>`__




.. _ch_next-steps:

48â€ƒNext steps: overview of web development
===========================================

   #. `48.1â€ƒTips against feeling overwhelmed <#tips-against-feeling-overwhelmed>`__
   #. `48.2â€ƒThings worth learning for web development <#things-worth-learning-for-web-development>`__

      #. `48.2.1â€ƒKeep an eye on WebAssembly (Wasm)! <#web-assembly>`__

   #. `48.3â€ƒAn overview of JavaScript tools <#overview-of-js-tools>`__

      #. `48.3.1â€ƒBuilding: getting from the JavaScript we write to the JavaScript we deploy <#building-getting-from-the-javascript-we-write-to-the-javascript-we-deploy>`__
      #. `48.3.2â€ƒStatic checking <#static-checking>`__
      #. `48.3.3â€ƒTesting <#testing>`__
      #. `48.3.4â€ƒPackage managers <#package-managers>`__
      #. `48.3.5â€ƒLibraries <#libraries>`__

   #. `48.4â€ƒTools not related to JavaScript <#tools-not-related-to-javascript>`__

   You now know most of the JavaScript language. This chapter gives an overview of
   web development and describes next steps. It answers questions such as:

   -  What should I learn next for web development?
   -  What JavaScript-related tools should I know about?

48.1â€ƒTips against feeling overwhelmed
--------------------------------------

   Web development has become a vast field: Between JavaScript, web browsers,
   server-side JavaScript, JavaScript libraries, and JavaScript tools, there is a
   lot to know. Additionally, everything is always changing: some things go out of
   style, new things are invented, etc.

   How can you avoid feeling overwhelmed when faced with this constantly changing
   vastness of knowledge?

   -  Focus on the web technologies that you work with most often and learn them
      well. If you do frontend development, that may be JavaScript, CSS, SVG, or
      something else.
   -  For JavaScript: Know the language, but also try out one tool in each of the
      following categories (which are covered in more detail later).

      -  Compilers: compile future JavaScript or supersets of JavaScript to normal
         JavaScript.
      -  Bundlers: combine all modules used by a web app into a single file (a
         script or a module). That makes loading faster and enables dead code
         elimination.
      -  Static checkers. For example:

         -  Linters: check for anti-patterns, style violations, and more.
         -  Type checkers: type JavaScript statically and report errors.

      -  Test libraries and tools
      -  Version control (usually git)

   .. container:: boxout

      |Icon â€œtipâ€|â€‚**Trust in your ability to learn on demand**

      .. container:: boxout-vspace

      It is commendable to learn something out of pure curiosity. But Iâ€™m wary of
      trying to learn everything and spreading oneself too thin. That also induces
      an anxiety of not knowing enough (because you never will). Instead, trust in
      your ability to learn things on demand!

48.2â€ƒThings worth learning for web development
-----------------------------------------------

   These are a few things worth learning for web development:

   -  Browser APIs such as the *Document Object Model* (DOM), the browsersâ€™
      representation of HTML in memory. They are the foundations of any kind of
      frontend development.

   -  JavaScript-adjacent technologies such as HTML and CSS.

   -  Frontend frameworks: When you get started with web development, it can be
      instructive to write user interfaces without any libraries. Once you feel
      more confident, frontend frameworks make many things easier, especially for
      larger apps. Popular frameworks include: Alpine.js, Angular, Ember, Lit,
      Preact, Qwik, React, Solid, Stencil, Svelte, Vue.js.

   -  JavaScript runtimes: Some JavaScript platform are for running code on
      servers. But they are also used for running command-line tools. The most
      popular runtime is Node.js. Most JavaScript-related tools (even compilers!)
      are implemented in Node.js-based JavaScript and installed via npm. A good way
      to get started with Node.js, is to `use it for shell
      scripting <https://exploringjs.com/nodejs-shell-scripting/>`__.

      -  Other JavaScript runtimes include: Deno, Bun.
      -  Important standards group in this area:
         `WinterCG <https://wintercg.org>`__ (Web-interoperable Runtimes Community
         Group). â€œThis community group aims to provide a space for JavaScript
         runtimes to collaborate on API interoperability. We focus on documenting
         and improving interoperability of web platform APIs across runtimes
         (especially non-browser ones).â€

   -  JavaScript tooling: Modern web development involves many tools. Later in this
      chapter, there is an overview of the current tooling ecosystem.

   -  Progressive web apps (PWAs): The driving idea behind progressive web apps is
      to give web apps features that, traditionally, only native apps had â€“ for
      example: native installation on mobile and desktop operating systems; offline
      operation; showing notifications to users. Google has published `a
      checklist <https://web.dev/articles/pwa-checklist>`__ detailing what makes a
      web app *progressive*. The minimum requirements are:

      -  The app must be served over HTTPS (not the unsecure HTTP).
      -  The app must have a *Web App Manifest file*, specifying metadata such as
         app name and icon (often in multiple resolutions). The file(s) of the icon
         must also be present.
      -  The app must have a *service worker*: a base layer of the app that runs in
         the background, in a separate process (independently of web pages). One of
         its responsibilities is to keep the app functioning when there is no
         internet connection. Among others, two mechanisms help it do that: It is a
         local proxy that supervises all of the web resource requests of the app.
         And it has access to a browserâ€™s cache. Therefore, it can use the cache to
         fulfill requests when the app is offline â€“ after initially caching all
         critical resources. Other capabilities of service workers include
         synchronizing data in the background; receiving server-sent push messages;
         and the aforementioned showing notifications to users.

   One good resource for learning web development â€“ including JavaScript â€“ is `MDN
   web docs <https://developer.mozilla.org/en-US/docs/Learn>`__.



.. _web-assembly:

48.2.1â€ƒKeep an eye on WebAssembly (Wasm)!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   `WebAssembly <https://webassembly.org>`__ is a universal virtual machine that is
   built into most JavaScript engines. We often get the following distribution of
   work:

   -  JavaScript is for dynamic, higher-level code.
   -  WebAssembly is for static, lower-level code.

   For static code, WebAssembly is quite fast: C/C++ code, compiled to WebAssembly,
   is about 50% as fast as the same code, compiled to native
   (`source <https://arxiv.org/abs/1901.09056>`__). Use cases include support for
   new video formats, machine learning, gaming, etc. It helps that it is relatively
   easy to compile existing code bases (e.g. ones written in C) to WebAssembly.

   WebAssembly works well as a compilation target for various languages. Does this
   mean JavaScript will be compiled to WebAssembly or replaced by another language?

48.2.1.1â€ƒWill JavaScript be compiled to WebAssembly?
'''''''''''''''''''''''''''''''''''''''''''''''''''''

   JavaScript engines perform many optimizations for JavaScriptâ€™s highly dynamic
   features. If we wanted to compile JavaScript to WebAssembly, weâ€™d have to
   implement these optimizations on top of WebAssembly. The result would be slower
   than current engines and have a similar code base. Therefore, we wouldnâ€™t gain
   anything.

48.2.1.2â€ƒWill JavaScript be replaced by another language?
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

   Does WebAssembly mean that JavaScript is about to be replaced by another
   language? WebAssembly does make it easier to support languages other than
   JavaScript in web browsers. But those languages face several challenges on that
   platform:

   -  All browser APIs are based on JavaScript.
   -  The runtimes (standard library, etc.) of other languages incur an additional
      memory overhead, whereas JavaScriptâ€™s runtime is already built into web
      browsers.
   -  JavaScript is well-known, has many libraries and tools, etc.

   For dynamic code, JavaScript is comparatively fast. Therefore, for the
   foreseeable future, it will probably remain the most popular choice for
   high-level code. For low-level code, compiling more static languages (such as
   Rust) to WebAssembly is an intriguing option.

   Given that it is just a virtual machine, there are not that many practically
   relevant things to learn about WebAssembly. But it is worth keeping an eye on
   its evolving role in web development. It is also becoming popular as a
   stand-alone virtual machine:

   -  Important standards group in this area: â€œThe `Bytecode
      Alliance <https://bytecodealliance.org>`__ is a nonprofit organization
      dedicated to creating secure new software foundations, building on standards
      such as WebAssembly and WebAssembly System Interface (WASI).â€

   -  `WebAssembly System Interface (WASI) <https://wasi.dev>`__: â€œgroup of
      standard API specifications for software compiled to the W3C WebAssembly
      (Wasm) standard. WASI is designed to provide a secure standard interface for
      applications that can be compiled to Wasm from any language, and that may run
      anywhere â€“ from browsers to clouds to embedded devices.â€

   -  `WebAssembly Component Model
      (WCM) <https://component-model.bytecodealliance.org>`__: â€œbroad-reaching
      architecture for building interoperable Wasm libraries, applications, and
      environments.â€

   -  `warg â€“ secure registry protocol for Wasm packages <https://warg.io>`__: An
      important foundation for WebAssembly package managers.



.. _overview-of-js-tools:

48.3â€ƒAn overview of JavaScript tools
-------------------------------------

   In this section, we take a look at:

   -  Categories of tools
   -  Names of specific tools in those categories

   The former are much more important. The names change, as tools come into and out
   of style, but I wanted you to see at least some of them.

48.3.1â€ƒBuilding: getting from the JavaScript we write to the JavaScript we deploy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   *Building* JavaScript means getting from the JavaScript we write to the
   JavaScript we deploy. The following tools are often involved in this process.

48.3.1.1â€ƒTranspilers
'''''''''''''''''''''

   A transpiler is a compiler that compiles source code to source code. Two
   transpilers that are popular in the JavaScript community are:

   -  TypeScript is a superset of JavaScript. Roughly, it is the latest version of
      JavaScript plus static typing. The TypeScript compiler ``tsc`` performs two
      tasks:

      -  It type-checks the JavaScript code.
      -  It compiles TypeScript to JavaScript (which still looks much the same).

      One important trend is to use faster tools (such as bundlers, see below) for
      the relatively simply task of compiling TypeScript to JavaScript and to use
      the TypeScript compiler only for type-checking during development â€“ which is
      a complicated task (so far no practical alternatives to ``tsc`` have
      emerged).

   -  Babel compiles upcoming and modern JavaScript features to older versions of
      the language. That means we can use new features in our code and still run it
      on older browsers.

      -  Most browsers are now *evergreen* and frequently update themselves. Before
         that happened, Babel was essential. Now itâ€™s being used less, also due to
         TypeScript having become popular.

48.3.1.2â€ƒMinification
''''''''''''''''''''''

   Minification means compiling JavaScript to equivalent, smaller (as in fewer
   characters) JavaScript. It does so by renaming variables, removing comments,
   removing whitespace, etc.

   For example, given the following input:

   .. code:: javascript

      let numberOfOccurrences = 5;
      if (Math.random()) {
      // Math.random() is not zero
      numberOfOccurrences++
      }

   A minifier might produce:

   .. code:: javascript

      let a=5;Math.random()&&a++;

   Bundlers (see below) usually support minification.



.. _bundler:

48.3.1.3â€ƒBundlers
''''''''''''''''''

   *Bundlers* compile and optimize the code of a JavaScript app. The input of a
   bundler is many files â€“ all of the appâ€™s code plus the libraries it uses. A
   bundler combines these input files to produce fewer output files (`which tends
   to improve
   performance <https://medium.com/@asyncmax/the-right-way-to-bundle-your-assets-for-faster-sites-over-http-2-437c37efe3ff>`__).

   A bundler minimizes the size of its output via techniques such as
   *tree-shaking*. Tree-shaking is a form of dead code elimination: only those
   module exports are put in the output that are imported somewhere (across all
   code, while considering transitive imports).

   It is also common to perform compilation steps such as transpiling and
   minification while bundling.

   Popular bundlers include:

   -  More like a framework (the tool takes control):

      -  Vite

   -  More like a library (we control the tool):

      -  esbuild
      -  Rollup
      -  Rolldown

   -  Somewhere between:

      -  Parcel
      -  Rspack
      -  TurboPack
      -  webpack

48.3.1.4â€ƒTask runners
''''''''''''''''''''''

   Sometimes there are build tasks that involve multiple tools or invoke tools with
   specific arguments. *Task runners* (in the tradition of Unix ``make``) let us
   define simpler names for such tasks and often also help with connecting tools
   and processing files. There are:

   -  Dedicated task runners: grunt, gulp, broccoli, etc.
   -  Tools that can be used as simple task runners:

      -  Most package managers can run tasks, e.g. via ``"scripts"`` in
         ``package.json``.
      -  Most runtimes also come with built-in support for running tasks.

48.3.2â€ƒStatic checking
~~~~~~~~~~~~~~~~~~~~~~~

   *Static checking* means analyzing source code *statically* (without running it).
   It can be used to detect a variety of problems. Tools include:

   -  Linters: check the source code for problematic patterns, unused variables,
      etc. Linters are especially useful if you are still learning the language
      because they point out if you are doing something wrong.

      -  Popular linters include ESLint, Biome, oxlint, quick-lint-js

   -  Code style checkers: check if code is formatted properly. They consider
      indentation, spaces after brackets, spaces after commas, etc.

      -  Example: JSCS (JavaScript Code Style checker)

   -  Code formatters: automatically format our code for us, according to rules
      that we can customize.

      -  Examples: Prettier, Biome

   -  Type checkers: add static type checking to JavaScript.

      -  Most popular type checker: TypeScript (which is also a transpiler)

48.3.3â€ƒTesting
~~~~~~~~~~~~~~~

   JavaScript has many testing frameworks â€“ for example:

   -  Unit testing: AVA, Jasmine, Jest, Mocha, QUnit, Vitest, etc.

      -  The JavaScript runtimes Node.js, Deno and Bun all have built-in test
         runners.

   -  Integration testing: Jenkins, Cypress, etc.
   -  User interface testing: CasperJS, Nightwatch.js, TestCafÃ©, Cypress,
      Playwright, Web Test Runner, etc.
   -  Automating browsers (e.g. for testing): Puppeteer, Selenium, etc.

48.3.4â€ƒPackage managers
~~~~~~~~~~~~~~~~~~~~~~~~

   The most popular package manager for JavaScript is npm. It started as a package
   manager for Node.js but has since also become dominant for client-side web
   development and tools of any kind.

   The following alternatives to npm use npmâ€™s *package registry* (think online
   database):

   -  `Yarn <https://yarnpkg.com>`__ is a different take on npm; some of the
      features it pioneered are now also supported by npm.
   -  `pnpm <https://github.com/pnpm/pnpm>`__ focuses on saving space when
      installing packages locally.

   Additionally, there is JSR (JavaScript Registry):

   -  It focuses on TypeScript but also supports JavaScript.
   -  It can be used by all of the aforementioned package managers (including npm).
   -  Support for it is built into Deno. JSR was created by the team behind Deno
      and designed to be a good fit for it.

48.3.5â€ƒLibraries
~~~~~~~~~~~~~~~~~

   -  Various helpers: `lodash <https://lodash.com>`__ (which was originally based
      on the Underscore.js library) is one of the most popular general helper
      libraries for JavaScript.
   -  Data structures: The following libraries are two examples among many.

      -  `Immutable.js <https://github.com/immutable-js/immutable-js>`__ provides
         immutable data structures for JavaScript.
      -  `Immer <https://github.com/immerjs/immer>`__ is an interesting lightweight
         alternative to Immutable.js. It also doesnâ€™t mutate the data it operates
         on, but it works with normal objects, Arrays, Sets and Maps.

   -  Date libraries: JavaScriptâ€™s built-in support for dates is limited and full
      of pitfalls. The chapter on dates lists
      `libraries <#date-libraries>`__ that we can use instead.
   -  Internationalization: In this area, ECMAScriptâ€™s standard library is
      complemented by `the ECMAScript Internationalization API
      (ECMA-402) <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl>`__.
      It is accessed via the global variable ``Intl`` and available in most modern
      browsers.
   -  Implementing and accessing services: The following are two popular options
      that are supported by a variety of libraries and tools.

      -  REST (Representative State Transfer) is one popular option for services
         and based on HTTP(S).
      -  RPC (remote procedure calls) are another popular paradigm for
         communicating with servers. There are many standards and approaches for
         RPC â€“ two examples:

         -  `The JSON-RPC standard <https://www.jsonrpc.org>`__: â€œA light weight
            remote procedure call protocol. It is designed to be simple!â€
         -  `The gRPC framework <https://grpc.io>`__: â€œgRPC is a modern open source
            high performance Remote Procedure Call (RPC) framework that can run in
            any environment. It can efficiently connect services in and across data
            centers with pluggable support for load balancing, tracing, health
            checking and authentication. It is also applicable in last mile of
            distributed computing to connect devices, mobile applications and
            browsers to backend services.â€

      -  `GraphQL <https://graphql.org/>`__ is more sophisticated (for example, it
         can combine multiple data sources) and supports a query language.

48.4â€ƒTools not related to JavaScript
-------------------------------------

   Given that JavaScript is just one of several kinds of artifacts involved in web
   development, more tools exist. These are but a few examples:

   -  CSS:

      -  Minifiers: reduce the size of CSS by removing comments, etc.
      -  Preprocessors: let us write compact CSS (sometimes augmented with control
         flow constructs, etc.) that is expanded into deployable, more verbose CSS.
      -  Frameworks: provide help with layout, decent-looking user interface
         components, etc.

   -  Images: Automatically optimizing the size of bitmap images, etc.

   `Comments <https://github.com/rauschma/exploring-js/issues/29>`__




.. _ch_index:

Aâ€ƒIndex
========

   .. container:: content-index

      -  ``--x``, `#1 <#index-entry---prefix2>`__
      -  ``x--``, `#1 <#index-entry---suffix2>`__
      -  ``-x``, `#1 <#index-entry--x2>`__
      -  ``,`` (comma operator),
         `#1 <#index-entry----comma-operator->`__
      -  ``!x``, `#1 <#index-entry--2>`__
      -  ``c ? t : e``, `#1 <#index-entry--:>`__
      -  ``obj?.prop``, `#1 <#index-entry--.>`__
      -  ``.__proto__``, `#1 <#index-entry-.__proto__>`__
      -  ``x - y``, `#1 <#index-entry-.x-y2>`__
      -  ``x ??= y``, `#1 <#index-entry-.x---y2>`__
      -  ``x ?? d``, `#1 <#index-entry-.x--d>`__
      -  ``x ** y``, `#1 <#index-entry-.x--y3>`__
      -  ``x * y``, `#1 <#index-entry-.x-y3>`__
      -  ``x / y``, `#1 <#index-entry-.x-y4>`__
      -  ``x && y``, `#1 <#index-entry-.x--y>`__
      -  ``x & y``, `#1 <#index-entry-.x-y5>`__
      -  ``x Ùª y``, `#1 <#index-entry-.xÙªy>`__
      -  ``x ^ y``, `#1 <#index-entry-.x-y7>`__
      -  ``x + y``, `#1 <#index-entry-.x-y>`__
      -  ``x << y``, `#1 <#index-entry-.x--y4>`__
      -  ``x === y``, `#1 <#index-entry-.x---y>`__
      -  ``x >>> y``, `#1 <#index-entry-.x---y3>`__
      -  ``x >> y``, `#1 <#index-entry-.x--y5>`__
      -  ``x Â¦Â¦ y``, `#1 <#index-entry-.x--y2>`__
      -  ``x Â¦ y``, `#1 <#index-entry-.x-y6>`__
      -  ``++x``, `#1 <#index-entry---prefix>`__
      -  ``x++``, `#1 <#index-entry---suffix>`__
      -  ``+x``, `#1 <#index-entry--x>`__
      -  ``=``, `#1 <#index-entry-->`__
      -  ``~x``, `#1 <#index-entry--x3>`__

      -  accessor (object literal),
         `#1 <#index-entry-accessor--object-literal->`__
      -  addition, `#1 <#index-entry-addition>`__
      -  ``AggregateError``, `#1 <#AggregateError>`__
      -  AMD module, `#1 <#index-entry-AMD-module>`__
      -  anonymous function expression,
         `#1 <#index-entry-anonymous-function-expression>`__
      -  argument, `#1 <#index-entry-argument>`__
      -  argument vs. parameter,
         `#1 <#index-entry-argument-vs.-parameter>`__
      -  ``Array``, `#1 <#index-entry-Array>`__
      -  Array hole, `#1 <#index-entry-Array-hole>`__
      -  Array index, `#1 <#index-entry-Array-index>`__
      -  Array literal, `#1 <#index-entry-Array-literal>`__
      -  Array-destructuring,
         `#1 <#index-entry-Array-destructuring>`__
      -  Array-like object, `#1 <#index-entry-Array-like-object>`__
      -  Array, dense, `#1 <#index-entry-Array--dense>`__
      -  Array, multidimensional,
         `#1 <#index-entry-Array--multidimensional>`__
      -  ``new Array()``, `#1 <#qref-new-Array>`__
      -  Array, sparse, `#1 <#index-entry-Array--sparse>`__
      -  ``Array.from()``, `#1 <#qref-Array.from>`__
      -  ``Array.of()``, `#1 <#qref-Array.of>`__
      -  ``Array.prototype.at()``, `#1 <#qref-Array.prototype.at>`__
      -  ``Array.prototype.concat()``,
         `#1 <#qref-Array.prototype.concat>`__
      -  ``Array.prototype.copyWithin()``,
         `#1 <#qref-Array.prototype.copyWithin>`__
      -  ``Array.prototype.entries()``,
         `#1 <#qref-Array.prototype.entries>`__
      -  ``Array.prototype.every()``,
         `#1 <#qref-Array.prototype.every>`__
      -  ``Array.prototype.fill()``,
         `#1 <#qref-Array.prototype.fill>`__
      -  ``Array.prototype.filter()``,
         `#1 <#qref-Array.prototype.filter>`__
      -  ``Array.prototype.find()``,
         `#1 <#qref-Array.prototype.find>`__
      -  ``Array.prototype.findIndex()``,
         `#1 <#qref-Array.prototype.findIndex>`__
      -  ``Array.prototype.findLast()``,
         `#1 <#qref-Array.prototype.findLast>`__
      -  ``Array.prototype.findLastIndex()``,
         `#1 <#qref-Array.prototype.findLastIndex>`__
      -  ``Array.prototype.flat()``,
         `#1 <#qref-Array.prototype.flat>`__
      -  ``Array.prototype.flatMap()``,
         `#1 <#qref-Array.prototype.flatMap>`__
      -  ``Array.prototype.forEach()``,
         `#1 <#qref-Array.prototype.forEach>`__
      -  ``Array.prototype.includes()``,
         `#1 <#qref-Array.prototype.includes>`__
      -  ``Array.prototype.indexOf()``,
         `#1 <#qref-Array.prototype.indexOf>`__
      -  ``Array.prototype.join()``,
         `#1 <#qref-Array.prototype.join>`__
      -  ``Array.prototype.keys()``,
         `#1 <#qref-Array.prototype.keys>`__
      -  ``Array.prototype.lastIndexOf()``,
         `#1 <#qref-Array.prototype.lastIndexOf>`__
      -  ``Array.prototype.map()``,
         `#1 <#qref-Array.prototype.map>`__
      -  ``Array.prototype.pop()``,
         `#1 <#qref-Array.prototype.pop>`__
      -  ``Array.prototype.push()``,
         `#1 <#qref-Array.prototype.push>`__
      -  ``Array.prototype.reduce()``,
         `#1 <#qref-Array.prototype.reduce>`__
      -  ``Array.prototype.reduceRight()``,
         `#1 <#qref-Array.prototype.reduceRight>`__
      -  ``Array.prototype.reverse()``,
         `#1 <#qref-Array.prototype.reverse>`__
      -  ``Array.prototype.shift()``,
         `#1 <#qref-Array.prototype.shift>`__
      -  ``Array.prototype.slice()``,
         `#1 <#qref-Array.prototype.slice>`__
      -  ``Array.prototype.some()``,
         `#1 <#qref-Array.prototype.some>`__
      -  ``Array.prototype.sort()``,
         `#1 <#qref-Array.prototype.sort>`__
      -  ``Array.prototype.splice()``,
         `#1 <#qref-Array.prototype.splice>`__
      -  ``Array.prototype.toLocaleString()``,
         `#1 <#qref-Array.prototype.toLocaleString>`__
      -  ``Array.prototype.toReversed()``,
         `#1 <#qref-Array.prototype.toReversed>`__
      -  ``Array.prototype.toSorted()``,
         `#1 <#qref-Array.prototype.toSorted>`__
      -  ``Array.prototype.toSpliced()``,
         `#1 <#qref-Array.prototype.toSpliced>`__
      -  ``Array.prototype.toString()``,
         `#1 <#qref-Array.prototype.toString>`__
      -  ``Array.prototype.unshift()``,
         `#1 <#qref-Array.prototype.unshift>`__
      -  ``Array.prototype.values()``,
         `#1 <#qref-Array.prototype.values>`__
      -  ``Array.prototype.with()``,
         `#1 <#qref-Array.prototype.with>`__
      -  ``ArrayBuffer``, `#1 <#index-entry-ArrayBuffer>`__
      -  ``new ArrayBuffer()``, `#1 <#qref-new-ArrayBuffer>`__
      -  ``ArrayBuffer.isView()``,
         `#1 <#qref-ArrayBuffer.isView>`__
      -  ``ArrayBuffer.prototype.byteLength``,
         `#1 <#qref-ArrayBuffer.prototype.byteLength>`__
      -  ``ArrayBuffer.prototype.maxByteLength``,
         `#1 <#qref-ArrayBuffer.prototype.maxByteLength>`__
      -  ``ArrayBuffer.prototype.resizable``,
         `#1 <#qref-ArrayBuffer.prototype.resizable>`__
      -  ``ArrayBuffer.prototype.resize()``,
         `#1 <#qref-ArrayBuffer.prototype.resize>`__
      -  ``ArrayBuffer.prototype.slice()``,
         `#1 <#qref-ArrayBuffer.prototype.slice>`__
      -  Arrays, fixed-layout,
         `#1 <#index-entry-Arrays--fixed-layout>`__
      -  Arrays, sequence, `#1 <#index-entry-Arrays--sequence>`__
      -  arrow function, `#1 <#index-entry-arrow-function>`__
      -  ASCII escape, `#1 <#index-entry-ASCII-escape>`__
      -  ASI (automatic semicolon insertion),
         `#1 <#index-entry-ASI--automatic-semicolon-insertion->`__
      -  ``assert`` (module),
         `#1 <#index-entry-assert--module->`__
      -  ``assert.deepEqual()``,
         `#1 <#qref-assert.deepEqual>`__
      -  ``assert.equal()``, `#1 <#qref-assert.equal>`__
      -  ``assert.fail()``, `#1 <#qref-assert.fail>`__
      -  ``assert.notDeepEqual()``,
         `#1 <#qref-assert.notDeepEqual>`__
      -  ``assert.notEqual()``, `#1 <#qref-assert.notEqual>`__
      -  ``assert.throws()``, `#1 <#assert.throws>`__
      -  assertion, `#1 <#index-entry-assertion>`__
      -  assignment operator,
         `#1 <#index-entry-assignment-operator>`__
      -  ``async``, `#1 <#index-entry-async>`__
      -  async function,
         `#1 <#index-entry-async-function>`__
      -  ``async function*``,
         `#1 <#index-entry-async-function->`__
      -  ``async-await``, `#1 <#index-entry-async-await>`__
      -  asynchronous generator,
         `#1 <#index-entry-asynchronous-generator>`__
      -  asynchronous iterable,
         `#1 <#index-entry-asynchronous-iterable>`__
      -  asynchronous iteration,
         `#1 <#index-entry-asynchronous-iteration>`__
      -  asynchronous iterator,
         `#1 <#index-entry-asynchronous-iterator>`__
      -  asynchronous programming,
         `#1 <#index-entry-asynchronous-programming>`__
      -  attribute of a property,
         `#1 <#index-entry-attribute-of-a-property>`__
      -  automatic semicolon insertion (ASI),
         `#1 <#index-entry-automatic-semicolon-insertion--ASI->`__
      -  ``await`` (async function),
         `#1 <#index-entry-await--async-function->`__
      -  ``await`` (asynchronous generator),
         `#1 <#index-entry-await--asynchronous-generator->`__

      -  base class, `#1 <#index-entry-base-class>`__
      -  big endian, `#1 <#index-entry-big-endian>`__
      -  bigint, `#1 <#index-entry-bigint>`__
      -  ``BigInt64Array``, `#1 <#index-entry-BigInt64Array>`__
      -  ``BigUint64Array``,
         `#1 <#index-entry-BigUint64Array>`__
      -  binary integer literal,
         `#1 <#index-entry-binary-integer-literal>`__
      -  binding (variable),
         `#1 <#index-entry-binding--variable->`__
      -  bitwise And, `#1 <#index-entry-bitwise-And>`__
      -  bitwise Not, `#1 <#index-entry-bitwise-Not>`__
      -  bitwise Or, `#1 <#index-entry-bitwise-Or>`__
      -  bitwise Xor, `#1 <#index-entry-bitwise-Xor>`__
      -  boolean, `#1 <#index-entry-boolean>`__
      -  ``Boolean()``, `#1 <#index-entry-Boolean-->`__
      -  bound variable,
         `#1 <#index-entry-bound-variable>`__
      -  ``break``, `#1 <#index-entry-break>`__
      -  bundler, `#1 <#index-entry-bundler>`__
      -  bundling, `#1 <#index-entry-bundling>`__

      -  call stack, `#1 <#index-entry-call-stack>`__
      -  callback (asynchronous pattern),
         `#1 <#index-entry-callback--asynchronous-pattern->`__
      -  callback function,
         `#1 <#index-entry-callback-function>`__
      -  camel case, `#1 <#index-entry-camel-case>`__,
         `#2 <#index-entry-camel-case2>`__
      -  case, camel, `#1 <#index-entry-case--camel>`__
      -  case, dash, `#1 <#index-entry-case--dash>`__
      -  case, kebab, `#1 <#index-entry-case--kebab>`__
      -  case, snake, `#1 <#index-entry-case--snake>`__
      -  case, underscore, `#1 <#index-entry-case--underscore>`__
      -  ``catch``, `#1 <#index-entry-catch>`__
      -  class, `#1 <#index-entry-class>`__,
         `#2 <#index-entry-class2>`__
      -  class declaration, `#1 <#index-entry-class-declaration>`__
      -  class definition, `#1 <#index-entry-class-definition>`__
      -  class expression, `#1 <#index-entry-class-expression>`__
      -  class, base, `#1 <#index-entry-class--base>`__
      -  class, derived, `#1 <#index-entry-class--derived>`__
      -  class, mixin, `#1 <#index-entry-class--mixin>`__
      -  classes, extending,
         `#1 <#index-entry-classes--extending>`__
      -  closure, `#1 <#index-entry-closure>`__
      -  code point, `#1 <#index-entry-code-point>`__
      -  code unit, `#1 <#index-entry-code-unit>`__
      -  coercion, `#1 <#index-entry-coercion>`__
      -  combinator function, Promise,
         `#1 <#index-entry-combinator-function--Promise>`__
      -  comma operator, `#1 <#index-entry-comma-operator>`__
      -  CommonJS module, `#1 <#index-entry-CommonJS-module>`__
      -  comparing by identity,
         `#1 <#index-entry-comparing-by-identity>`__
      -  comparing by value, `#1 <#index-entry-comparing-by-value>`__
      -  computed property key,
         `#1 <#index-entry-computed-property-key>`__
      -  concatenating strings,
         `#1 <#index-entry-concatenating-strings>`__
      -  conditional operator,
         `#1 <#index-entry-conditional-operator>`__
      -  console, `#1 <#index-entry-console>`__
      -  ``console.error()``, `#1 <#index-entry-console.error-->`__
      -  ``console.log()``, `#1 <#index-entry-console.log-->`__
      -  ``const``, `#1 <#index-entry-const>`__
      -  constant, `#1 <#index-entry-constant>`__
      -  constructor function (role of an ordinary function),
         `#1 <#index-entry-constructor-function--role-of-an-ordinary-function->`__
      -  ``continue``, `#1 <#index-entry-continue>`__
      -  Converting to [type],
         `#1 <#index-entry-Converting-to--type->`__
      -  Coordinated Universal Time (UTC),
         `#1 <#index-entry-Coordinated-Universal-Time--UTC->`__
      -  copy object deeply,
         `#1 <#index-entry-copy-object-deeply>`__
      -  copy object shallowly,
         `#1 <#index-entry-copy-object-shallowly>`__

      -  dash case, `#1 <#index-entry-dash-case>`__,
         `#2 <#index-entry-dash-case2>`__
      -  ``DataView``, `#1 <#index-entry-DataView>`__
      -  ``new DataView()``, `#1 <#qref-new-DataView>`__
      -  ``DataView.prototype.buffer``,
         `#1 <#qref-DataView.prototype.buffer>`__
      -  ``DataView.prototype.byteLength``,
         `#1 <#qref-DataView.prototype.byteLength>`__
      -  ``DataView.prototype.byteOffset``,
         `#1 <#qref-DataView.prototype.byteOffset>`__
      -  ``DataView.prototype.get()``,
         `#1 <#qref-DataView.prototype.get>`__
      -  ``DataView.prototype.set()``,
         `#1 <#qref-DataView.prototype.set>`__
      -  date, `#1 <#index-entry-date>`__
      -  date time format, `#1 <#index-entry-date-time-format>`__
      -  decimal floating point literal,
         `#1 <#index-entry-decimal-floating-point-literal>`__
      -  decimal integer literal,
         `#1 <#index-entry-decimal-integer-literal>`__
      -  decrementation operator (prefix),
         `#1 <#index-entry-decrementation-operator--prefix->`__
      -  decrementation operator (suffix),
         `#1 <#index-entry-decrementation-operator--suffix->`__
      -  deep copy of an object,
         `#1 <#index-entry-deep-copy-of-an-object>`__
      -  default export, `#1 <#index-entry-default-export>`__
      -  default value (destructuring),
         `#1 <#index-entry-default-value--destructuring->`__
      -  default value (parameter),
         `#1 <#index-entry-default-value--parameter->`__
      -  default value operator (``??``),
         `#1 <#index-entry-default-value-operator>`__
      -  ``delete``, `#1 <#index-entry-delete>`__
      -  deleting a property,
         `#1 <#index-entry-deleting-a-property>`__
      -  dense Array, `#1 <#index-entry-dense-Array>`__
      -  derived class, `#1 <#index-entry-derived-class>`__
      -  descriptor of a property,
         `#1 <#index-entry-descriptor-of-a-property>`__
      -  destructive operation,
         `#1 <#index-entry-destructive-operation>`__
      -  destructuring, `#1 <#index-entry-destructuring>`__
      -  destructuring an Array,
         `#1 <#index-entry-destructuring-an-Array>`__
      -  destructuring an object,
         `#1 <#index-entry-destructuring-an-object>`__
      -  dictionary object, `#1 <#index-entry-dictionary-object>`__
      -  direct method call,
         `#1 <#index-entry-direct-method-call>`__
      -  dispatched method call,
         `#1 <#index-entry-dispatched-method-call>`__
      -  divided by operator,
         `#1 <#index-entry-divided-by-operator>`__
      -  division, `#1 <#index-entry-division>`__
      -  ``do-while``, `#1 <#index-entry-do-while>`__
      -  dynamic imports, `#1 <#index-entry-dynamic-imports>`__
      -  dynamic ``this``, `#1 <#index-entry-dynamic-this>`__
      -  dynamic vs. static,
         `#1 <#index-entry-dynamic-vs.-static>`__

      -  early activation,
         `#1 <#index-entry-early-activation>`__
      -  Ecma, `#1 <#index-entry-Ecma>`__
      -  ECMA-262, `#1 <#index-entry-ECMA-262>`__
      -  ECMAScript, `#1 <#index-entry-ECMAScript>`__
      -  ECMAScript module, `#1 <#index-entry-ECMAScript-module>`__
      -  ECMAScript proposal,
         `#1 <#index-entry-ECMAScript-proposal>`__
      -  Eich, Brendan, `#1 <#index-entry-Eich--Brendan>`__
      -  endianness (Typed Arrays),
         `#1 <#index-entry-endianness--Typed-Arrays->`__
      -  enumerability, `#1 <#index-entry-enumerability>`__
      -  enumerable (property attribute),
         `#1 <#index-entry-enumerable--property-attribute->`__
      -  equality operator,
         `#1 <#index-entry-equality-operator>`__
      -  ES module, `#1 <#index-entry-ES-module>`__
      -  escape, ASCII, `#1 <#index-entry-escape--ASCII>`__
      -  escape, Unicode code point,
         `#1 <#index-entry-escape--Unicode-code-point>`__
      -  escape, Unicode code unit,
         `#1 <#index-entry-escape--Unicode-code-unit>`__
      -  escaping HTML,
         `#1 <#index-entry-escaping-HTML>`__
      -  ``eval()``, `#1 <#index-entry-eval-->`__
      -  evaluating an expression,
         `#1 <#index-entry-evaluating-an-expression>`__
      -  event (asynchronous pattern),
         `#1 <#index-entry-event--asynchronous-pattern->`__
      -  event loop, `#1 <#index-entry-event-loop>`__
      -  exception, `#1 <#index-entry-exception>`__
      -  exercises, getting started with,
         `#1 <#index-entry-exercises--getting-started-with>`__
      -  exponentiation, `#1 <#index-entry-exponentiation>`__
      -  ``export``, `#1 <#index-entry-export>`__
      -  ``export default``, `#1 <#index-entry-export-default>`__
      -  export, default, `#1 <#index-entry-export--default>`__
      -  export, named, `#1 <#index-entry-export--named>`__
      -  expression, `#1 <#index-entry-expression>`__
      -  extending classes, `#1 <#index-entry-extending-classes>`__
      -  ``extends``, `#1 <#index-entry-extends>`__
      -  external iteration,
         `#1 <#index-entry-external-iteration>`__
      -  extracting a method,
         `#1 <#index-entry-extracting-a-method>`__

      -  ``false``, `#1 <#index-entry-false>`__
      -  falsiness, `#1 <#index-entry-falsiness>`__
      -  falsy, `#1 <#index-entry-falsy>`__
      -  ``finally``, `#1 <#index-entry-finally>`__
      -  fixed-layout Arrays,
         `#1 <#index-entry-fixed-layout-Arrays>`__
      -  fixed-layout object,
         `#1 <#index-entry-fixed-layout-object>`__
      -  flags (regular expression),
         `#1 <#index-entry-flags--regular-expression->`__
      -  ``Float32Array``, `#1 <#index-entry-Float32Array>`__
      -  ``Float64Array``, `#1 <#index-entry-Float64Array>`__
      -  floating point literal,
         `#1 <#index-entry-floating-point-literal>`__
      -  ``for``, `#1 <#index-entry-for>`__
      -  ``for-await-of``,
         `#1 <#index-entry-for-await-of>`__
      -  ``for-in``, `#1 <#index-entry-for-in>`__
      -  ``for-of``, `#1 <#index-entry-for-of>`__
      -  free variable,
         `#1 <#index-entry-free-variable>`__
      -  fulfilled (Promise state),
         `#1 <#index-entry-fulfilled--Promise-state->`__
      -  function declaration,
         `#1 <#index-entry-function-declaration>`__
      -  function expression, anonymous,
         `#1 <#index-entry-function-expression--anonymous>`__
      -  function expression, named,
         `#1 <#index-entry-function-expression--named>`__
      -  function, arrow, `#1 <#index-entry-function--arrow>`__
      -  function, ordinary,
         `#1 <#index-entry-function--ordinary>`__
      -  function, roles of an ordinary,
         `#1 <#index-entry-function--roles-of-an-ordinary>`__
      -  function, specialized,
         `#1 <#index-entry-function--specialized>`__
      -  ``function*``, `#1 <#index-entry-function->`__

      -  garbage collection, `#1 <#index-entry-garbage-collection>`__
      -  generator, asynchronous,
         `#1 <#index-entry-generator--asynchronous>`__
      -  generator, synchronous,
         `#1 <#index-entry-generator--synchronous>`__
      -  getter (object literal),
         `#1 <#index-entry-getter--object-literal->`__
      -  ``global``, `#1 <#index-entry-global>`__
      -  global object,
         `#1 <#index-entry-global-object>`__
      -  global scope,
         `#1 <#index-entry-global-scope>`__
      -  global variable,
         `#1 <#index-entry-global-variable>`__
      -  ``globalThis``,
         `#1 <#index-entry-globalThis>`__
      -  GMT (Greenwich Mean Time),
         `#1 <#index-entry-GMT--Greenwich-Mean-Time->`__
      -  grapheme cluster, `#1 <#index-entry-grapheme-cluster>`__
      -  Greenwich Mean Time (GMT),
         `#1 <#index-entry-Greenwich-Mean-Time--GMT->`__

      -  heap, `#1 <#index-entry-heap>`__
      -  hexadecimal integer literal,
         `#1 <#index-entry-hexadecimal-integer-literal>`__
      -  hoisting, `#1 <#index-entry-hoisting>`__
      -  hole in an Array, `#1 <#index-entry-hole-in-an-Array>`__

      -  identifier, `#1 <#index-entry-identifier>`__
      -  identity of an object,
         `#1 <#index-entry-identity-of-an-object>`__
      -  ``if``, `#1 <#index-entry-if>`__
      -  IIFE (immediately invoked function expression),
         `#1 <#index-entry-IIFE--immediately-invoked-function-expression->`__
      -  immediately invoked function expression (IIFE),
         `#1 <#index-entry-immediately-invoked-function-expression--IIFE->`__
      -  ``import``, `#1 <#index-entry-import>`__
      -  import, named, `#1 <#index-entry-import--named>`__
      -  import, namespace, `#1 <#index-entry-import--namespace>`__
      -  ``import.meta``, `#1 <#index-entry-import.meta>`__
      -  ``import.meta.url``, `#1 <#index-entry-import.meta.url>`__
      -  ``import()``, `#1 <#index-entry-import-->`__
      -  imports, dynamic, `#1 <#index-entry-imports--dynamic>`__
      -  ``in``, `#1 <#index-entry-in>`__
      -  incrementation operator (prefix),
         `#1 <#index-entry-incrementation-operator--prefix->`__
      -  incrementation operator (suffix),
         `#1 <#index-entry-incrementation-operator--suffix->`__
      -  index of an Array, `#1 <#index-entry-index-of-an-Array>`__
      -  ``Infinity``, `#1 <#index-entry-Infinity>`__
      -  inheritance, multiple,
         `#1 <#index-entry-inheritance--multiple>`__
      -  inheritance, single,
         `#1 <#index-entry-inheritance--single>`__
      -  ``instanceof``, `#1 <#index-entry-instanceof>`__,
         `#2 <#index-entry-instanceof2>`__
      -  ``Int8Array``, `#1 <#index-entry-Int8Array>`__
      -  ``Int16Array``, `#1 <#index-entry-Int16Array>`__
      -  ``Int32Array``, `#1 <#index-entry-Int32Array>`__
      -  integer numbers, `#1 <#index-entry-integer-numbers>`__
      -  integer, safe, `#1 <#index-entry-integer--safe>`__
      -  internal iteration,
         `#1 <#index-entry-internal-iteration>`__
      -  iterable (asynchronous),
         `#1 <#index-entry-iterable--asynchronous->`__
      -  iterable (synchronous),
         `#1 <#index-entry-iterable--synchronous->`__
      -  iteration, asynchronous,
         `#1 <#index-entry-iteration--asynchronous>`__
      -  iteration, external,
         `#1 <#index-entry-iteration--external>`__
      -  iteration, internal,
         `#1 <#index-entry-iteration--internal>`__
      -  iteration, synchronous,
         `#1 <#index-entry-iteration--synchronous>`__
      -  iterator (asynchronous),
         `#1 <#index-entry-iterator--asynchronous->`__
      -  iterator (synchronous),
         `#1 <#index-entry-iterator--synchronous->`__

      -  JSON (data format), `#1 <#index-entry-JSON--data-format->`__
      -  ``JSON`` (namespace object),
         `#1 <#index-entry-JSON--namespace-object->`__

      -  kebab case, `#1 <#index-entry-kebab-case>`__,
         `#2 <#index-entry-kebab-case2>`__
      -  keyword, `#1 <#index-entry-keyword>`__

      -  label, `#1 <#index-entry-label>`__
      -  leading surrogate, `#1 <#index-entry-leading-surrogate>`__
      -  left shift operator,
         `#1 <#index-entry-left-shift-operator>`__
      -  ``let``, `#1 <#index-entry-let>`__
      -  lexical ``this``, `#1 <#index-entry-lexical-this>`__
      -  listing properties,
         `#1 <#index-entry-listing-properties>`__
      -  little endian, `#1 <#index-entry-little-endian>`__
      -  logical And, `#1 <#index-entry-logical-And>`__
      -  logical Not, `#1 <#index-entry-logical-Not>`__
      -  logical Or, `#1 <#index-entry-logical-Or>`__
      -  lone surrogate, `#1 <#unicode-lone-surrogate>`__

      -  ``Map``, `#1 <#index-entry-Map>`__
      -  Map vs. object, `#1 <#index-entry-Map-vs.-object>`__
      -  ``new Map()``, `#1 <#qref-new-Map>`__
      -  ``Map.groupBy()``, `#1 <#qref-Map.groupBy>`__
      -  ``Map.prototype.clear()``, `#1 <#qref-Map.prototype.clear>`__
      -  ``Map.prototype.delete()``,
         `#1 <#qref-Map.prototype.delete>`__
      -  ``Map.prototype.entries()``,
         `#1 <#qref-Map.prototype.entries>`__
      -  ``Map.prototype.forEach()``,
         `#1 <#qref-Map.prototype.forEach>`__
      -  ``Map.prototype.get()``, `#1 <#qref-Map.prototype.get>`__
      -  ``Map.prototype.has()``, `#1 <#qref-Map.prototype.has>`__
      -  ``Map.prototype.keys()``, `#1 <#qref-Map.prototype.keys>`__
      -  ``Map.prototype.set()``, `#1 <#qref-Map.prototype.set>`__
      -  ``Map.prototype.size``, `#1 <#qref-Map.prototype.size>`__
      -  ``Map.prototype.values()``,
         `#1 <#qref-Map.prototype.values>`__
      -  ``Map.prototype[Symbol.iterator]()``,
         `#1 <#qref-Map.prototype-Symbol.iterator->`__
      -  ``Math`` (namespace object),
         `#1 <#index-entry-Math--namespace-object->`__
      -  method, `#1 <#index-entry-method>`__
      -  method (object literal),
         `#1 <#index-entry-method--object-literal->`__
      -  method (role of an ordinary function),
         `#1 <#index-entry-method--role-of-an-ordinary-function->`__
      -  method call, direct,
         `#1 <#index-entry-method-call--direct>`__
      -  method call, dispatched,
         `#1 <#index-entry-method-call--dispatched>`__
      -  method, extracting a,
         `#1 <#index-entry-method--extracting-a>`__
      -  minification, `#1 <#index-entry-minification>`__
      -  minifier, `#1 <#index-entry-minifier>`__
      -  minus operator (binary),
         `#1 <#index-entry-minus-operator--binary->`__
      -  minus operator (unary),
         `#1 <#index-entry-minus-operator--unary->`__
      -  mixin class, `#1 <#index-entry-mixin-class>`__
      -  module specifier, `#1 <#index-entry-module-specifier>`__
      -  module, AMD, `#1 <#index-entry-module--AMD>`__
      -  module, CommonJS, `#1 <#index-entry-module--CommonJS>`__
      -  multidimensional Array,
         `#1 <#index-entry-multidimensional-Array>`__
      -  multiple inheritance,
         `#1 <#index-entry-multiple-inheritance>`__
      -  multiple return values,
         `#1 <#index-entry-multiple-return-values>`__
      -  multiplication, `#1 <#index-entry-multiplication>`__

      -  named export, `#1 <#index-entry-named-export>`__
      -  named function expression,
         `#1 <#index-entry-named-function-expression>`__
      -  named import, `#1 <#index-entry-named-import>`__
      -  named parameter, `#1 <#index-entry-named-parameter>`__
      -  namespace import, `#1 <#index-entry-namespace-import>`__
      -  ``NaN``, `#1 <#index-entry-NaN>`__
      -  ``node_modules``, `#1 <#index-entry-node_modules>`__
      -  non-destructive operation,
         `#1 <#index-entry-non-destructive-operation>`__
      -  npm, `#1 <#index-entry-npm>`__
      -  npm package, `#1 <#index-entry-npm-package>`__
      -  ``null``, `#1 <#index-entry-null>`__
      -  nullish coalescing assignment operator (``??=``),
         `#1 <#index-entry-nullish-coalescing-assignment-operator------>`__
      -  nullish coalescing operator (``??``),
         `#1 <#index-entry-nullish-coalescing-operator>`__
      -  number, `#1 <#index-entry-number>`__
      -  ``Number.EPSILON()``, `#1 <#qref-Number.EPSILON>`__
      -  ``Number.isFinite()``, `#1 <#qref-Number.isFinite>`__
      -  ``Number.isInteger()``, `#1 <#qref-Number.isInteger>`__
      -  ``Number.isNaN()``, `#1 <#qref-Number.isNaN>`__
      -  ``Number.isSafeInteger()``,
         `#1 <#qref-Number.isSafeInteger>`__
      -  ``Number.MAX_SAFE_INTEGER()``,
         `#1 <#qref-Number.MAX_SAFE_INTEGER>`__
      -  ``Number.MAX_VALUE()``, `#1 <#qref-Number.MAX_VALUE>`__
      -  ``Number.MIN_SAFE_INTEGER()``,
         `#1 <#qref-Number.MIN_SAFE_INTEGER>`__
      -  ``Number.MIN_VALUE()``, `#1 <#qref-Number.MIN_VALUE>`__
      -  ``Number.NaN()``, `#1 <#qref-Number.NaN>`__
      -  ``Number.NEGATIVE_INFINITY()``,
         `#1 <#qref-Number.NEGATIVE_INFINITY>`__
      -  ``Number.parseFloat()``, `#1 <#qref-Number.parseFloat>`__
      -  ``Number.parseInt()``, `#1 <#qref-Number.parseInt>`__
      -  ``Number.POSITIVE_INFINITY()``,
         `#1 <#qref-Number.POSITIVE_INFINITY>`__
      -  ``Number.prototype.toExponential()``,
         `#1 <#qref-Number.prototype.toExponential>`__
      -  ``Number.prototype.toFixed()``,
         `#1 <#qref-Number.prototype.toFixed>`__
      -  ``Number.prototype.toPrecision()``,
         `#1 <#qref-Number.prototype.toPrecision>`__
      -  ``Number.prototype.toString()``,
         `#1 <#qref-Number.prototype.toString>`__
      -  ``Number()``, `#1 <#index-entry-Number-->`__

      -  object, `#1 <#index-entry-object>`__
      -  object literal, `#1 <#index-entry-object-literal>`__
      -  object vs. Map, `#1 <#index-entry-object-vs.-Map>`__
      -  object vs. primitive value,
         `#1 <#index-entry-object-vs.-primitive-value>`__
      -  object-destructuring,
         `#1 <#index-entry-object-destructuring>`__
      -  object, copy deeply,
         `#1 <#index-entry-object--copy-deeply>`__
      -  object, copy shallowly,
         `#1 <#index-entry-object--copy-shallowly>`__
      -  object, dictionary,
         `#1 <#index-entry-object--dictionary>`__
      -  object, fixed-layout,
         `#1 <#index-entry-object--fixed-layout>`__
      -  object, identity of an,
         `#1 <#index-entry-object--identity-of-an>`__
      -  ``Object.assign()``, `#1 <#qref-Object.assign>`__
      -  ``Object.create()``, `#1 <#qref-Object.create>`__
      -  ``Object.defineProperties()``,
         `#1 <#qref-Object.defineProperties>`__
      -  ``Object.defineProperty()``,
         `#1 <#qref-Object.defineProperty>`__
      -  ``Object.entries()``, `#1 <#qref-Object.entries>`__
      -  ``Object.freeze()``, `#1 <#qref-Object.freeze>`__
      -  ``Object.fromEntries()``, `#1 <#qref-Object.fromEntries>`__
      -  ``Object.getOwnPropertyDescriptor()``,
         `#1 <#qref-Object.getOwnPropertyDescriptor>`__
      -  ``Object.getOwnPropertyDescriptors()``,
         `#1 <#qref-Object.getOwnPropertyDescriptors>`__
      -  ``Object.getOwnPropertyNames()``,
         `#1 <#qref-Object.getOwnPropertyNames>`__
      -  ``Object.getOwnPropertySymbols()``,
         `#1 <#qref-Object.getOwnPropertySymbols>`__
      -  ``Object.getPrototypeOf()``,
         `#1 <#qref-Object.getPrototypeOf>`__
      -  ``Object.groupBy()``, `#1 <#qref-Object.groupBy>`__
      -  ``Object.hasOwn()``, `#1 <#qref-Object.hasOwn>`__
      -  ``Object.is()``, `#1 <#index-entry-Object.is-->`__,
         `#2 <#qref-Object.is>`__
      -  ``Object.isExtensible()``,
         `#1 <#qref-Object.isExtensible>`__
      -  ``Object.isFrozen()``, `#1 <#qref-Object.isFrozen>`__
      -  ``Object.isSealed()``, `#1 <#qref-Object.isSealed>`__
      -  ``Object.keys()``, `#1 <#qref-Object.keys>`__
      -  ``Object.preventExtensions()``,
         `#1 <#qref-Object.preventExtensions>`__
      -  ``Object.prototype`` methods,
         `#1 <#index-entry-Object.prototype-methods>`__
      -  ``Object.prototype.__proto__``,
         `#1 <#Object.prototype.__proto__>`__
      -  ``Object.prototype.hasOwnProperty()``,
         `#1 <#Object.prototype.hasOwnProperty>`__
      -  ``Object.prototype.isPrototypeOf()``,
         `#1 <#Object.prototype.isPrototypeOf>`__
      -  ``Object.prototype.propertyIsEnumerable()``,
         `#1 <#Object.prototype.propertyIsEnumerable>`__
      -  ``Object.prototype.toLocaleString()``,
         `#1 <#Object.prototype.toLocaleString>`__
      -  ``Object.prototype.toString()``,
         `#1 <#Object.prototype.toString>`__
      -  ``Object.prototype.valueOf()``,
         `#1 <#Object.prototype.valueOf>`__
      -  ``Object.seal()``, `#1 <#qref-Object.seal>`__
      -  ``Object.setPrototypeOf()``,
         `#1 <#qref-Object.setPrototypeOf>`__
      -  ``Object.values()``, `#1 <#qref-Object.values>`__
      -  ``Object()``, `#1 <#index-entry-Object-->`__
      -  octal integer literal,
         `#1 <#index-entry-octal-integer-literal>`__
      -  onesâ€™ complement, `#1 <#index-entry-ones--complement>`__
      -  operator, assignment,
         `#1 <#index-entry-operator--assignment>`__
      -  operator, comma, `#1 <#index-entry-operator--comma>`__
      -  operator, default value (``??``),
         `#1 <#index-entry-operator--default-value>`__
      -  operator, equality,
         `#1 <#index-entry-operator--equality>`__
      -  operator, nullish coalescing (``??``),
         `#1 <#index-entry-operator--nullish-coalescing>`__
      -  operator, nullish coalescing assignment (``??=``),
         `#1 <#index-entry-operator--nullish-coalescing-assignment------>`__
      -  operator, ``void``, `#1 <#index-entry-operator--void>`__
      -  optional chaining (``?.``),
         `#1 <#index-entry-optional-chaining---.->`__
      -  ordinary function,
         `#1 <#index-entry-ordinary-function>`__
      -  ordinary function, roles of an,
         `#1 <#index-entry-ordinary-function--roles-of-an>`__
      -  overriding a property,
         `#1 <#index-entry-overriding-a-property>`__

      -  package, npm, `#1 <#index-entry-package--npm>`__
      -  ``package.json``, `#1 <#index-entry-package.json>`__
      -  parameter, `#1 <#index-entry-parameter>`__
      -  parameter default value,
         `#1 <#index-entry-parameter-default-value>`__
      -  parameter vs. argument,
         `#1 <#index-entry-parameter-vs.-argument>`__
      -  passing by identity,
         `#1 <#index-entry-passing-by-identity>`__
      -  passing by value, `#1 <#index-entry-passing-by-value>`__
      -  pattern (regular expression),
         `#1 <#index-entry-pattern--regular-expression->`__
      -  pending (Promise state),
         `#1 <#index-entry-pending--Promise-state->`__
      -  plus operator (binary),
         `#1 <#index-entry-plus-operator--binary->`__
      -  plus operator (unary),
         `#1 <#index-entry-plus-operator--unary->`__
      -  polyfill, `#1 <#index-entry-polyfill>`__
      -  polyfill, speculative,
         `#1 <#index-entry-polyfill--speculative>`__
      -  ponyfill, `#1 <#index-entry-ponyfill>`__
      -  primitive value, `#1 <#index-entry-primitive-value>`__
      -  primitive value vs. object,
         `#1 <#index-entry-primitive-value-vs.-object>`__
      -  private name, `#1 <#index-entry-private-name>`__
      -  private slot, `#1 <#index-entry-private-slot>`__
      -  progressive web app (PWA),
         `#1 <#index-entry-progressive-web-app--PWA->`__
      -  prollyfill, `#1 <#index-entry-prollyfill>`__
      -  Promise, `#1 <#index-entry-Promise>`__,
         `#2 <#index-entry-Promise2>`__
      -  Promise combinator function,
         `#1 <#index-entry-Promise-combinator-function>`__
      -  Promise, states of a,
         `#1 <#index-entry-Promise--states-of-a>`__
      -  ``Promise.all()``, `#1 <#index-entry-Promise.all-->`__,
         `#2 <#qref-Promise.all>`__
      -  ``Promise.allSettled()``,
         `#1 <#index-entry-Promise.allSettled-->`__,
         `#2 <#qref-Promise.allSettled>`__
      -  ``Promise.any()``, `#1 <#index-entry-Promise.any-->`__,
         `#2 <#qref-Promise.any>`__
      -  ``Promise.race()``, `#1 <#index-entry-Promise.race-->`__,
         `#2 <#qref-Promise.race>`__
      -  properties, listing,
         `#1 <#index-entry-properties--listing>`__
      -  property, `#1 <#index-entry-property>`__
      -  property (object), `#1 <#index-entry-property--object->`__
      -  property attribute,
         `#1 <#index-entry-property-attribute>`__
      -  property descriptor,
         `#1 <#index-entry-property-descriptor>`__
      -  property key, `#1 <#index-entry-property-key>`__
      -  property key, computed,
         `#1 <#index-entry-property-key--computed>`__
      -  property key, quoted,
         `#1 <#index-entry-property-key--quoted>`__
      -  property name, `#1 <#index-entry-property-name>`__
      -  property symbol, `#1 <#index-entry-property-symbol>`__
      -  property value shorthand,
         `#1 <#index-entry-property-value-shorthand>`__
      -  property, deleting a,
         `#1 <#index-entry-property--deleting-a>`__
      -  prototype, `#1 <#index-entry-prototype>`__
      -  prototype chain, `#1 <#index-entry-prototype-chain>`__
      -  public slot, `#1 <#index-entry-public-slot>`__
      -  publicly known symbol,
         `#1 <#index-entry-publicly-known-symbol>`__
      -  PWA (progressive web app),
         `#1 <#index-entry-PWA--progressive-web-app->`__

      -  quoted property key,
         `#1 <#index-entry-quoted-property-key>`__

      -  real function (role of an ordinary function),
         `#1 <#index-entry-real-function--role-of-an-ordinary-function->`__
      -  receiver, `#1 <#index-entry-receiver>`__
      -  ``Reflect.apply()``, `#1 <#qref-Reflect.apply>`__
      -  ``Reflect.construct()``, `#1 <#qref-Reflect.construct>`__
      -  ``Reflect.defineProperty()``,
         `#1 <#qref-Reflect.defineProperty>`__
      -  ``Reflect.deleteProperty()``,
         `#1 <#qref-Reflect.deleteProperty>`__
      -  ``Reflect.get()``, `#1 <#qref-Reflect.get>`__
      -  ``Reflect.getOwnPropertyDescriptor()``,
         `#1 <#qref-Reflect.getOwnPropertyDescriptor>`__
      -  ``Reflect.getPrototypeOf()``,
         `#1 <#qref-Reflect.getPrototypeOf>`__
      -  ``Reflect.has()``, `#1 <#qref-Reflect.has>`__
      -  ``Reflect.isExtensible()``,
         `#1 <#qref-Reflect.isExtensible>`__
      -  ``Reflect.ownKeys()``, `#1 <#qref-Reflect.ownKeys>`__
      -  ``Reflect.preventExtensions()``,
         `#1 <#qref-Reflect.preventExtensions>`__
      -  ``Reflect.set()``, `#1 <#qref-Reflect.set>`__
      -  ``Reflect.setPrototypeOf()``,
         `#1 <#qref-Reflect.setPrototypeOf>`__
      -  ``RegExp``, `#1 <#index-entry-RegExp>`__
      -  regular expression,
         `#1 <#index-entry-regular-expression>`__
      -  regular expression literal,
         `#1 <#index-entry-regular-expression-literal>`__
      -  rejected (Promise state),
         `#1 <#index-entry-rejected--Promise-state->`__
      -  remainder operator,
         `#1 <#index-entry-remainder-operator>`__
      -  REPL, `#1 <#index-entry-REPL>`__
      -  replica, `#1 <#index-entry-replica>`__
      -  RequireJS, `#1 <#index-entry-RequireJS>`__
      -  reserved word, `#1 <#index-entry-reserved-word>`__
      -  rest element (Array-destructuring),
         `#1 <#index-entry-rest-element--Array-destructuring->`__
      -  rest parameter (function call),
         `#1 <#index-entry-rest-parameter--function-call->`__
      -  rest property (object-destructuring),
         `#1 <#index-entry-rest-property--object-destructuring->`__
      -  return values, multiple,
         `#1 <#index-entry-return-values--multiple>`__
      -  revealing module pattern,
         `#1 <#index-entry-revealing-module-pattern>`__
      -  roles of an ordinary function,
         `#1 <#index-entry-roles-of-an-ordinary-function>`__
      -  run-to-completion semantics,
         `#1 <#index-entry-run-to-completion-semantics>`__

      -  safe integer, `#1 <#index-entry-safe-integer>`__
      -  scope of a variable,
         `#1 <#index-entry-scope-of-a-variable>`__
      -  script, `#1 <#index-entry-script>`__
      -  ``self``, `#1 <#index-entry-self>`__
      -  sequence Arrays, `#1 <#index-entry-sequence-Arrays>`__
      -  Set, `#1 <#index-entry-Set>`__,
         `#2 <#index-entry-Set2>`__
      -  ``new Set()``, `#1 <#qref-new-Set>`__
      -  ``Set.prototype.add()``, `#1 <#qref-Set.prototype.add>`__
      -  ``Set.prototype.clear()``, `#1 <#qref-Set.prototype.clear>`__
      -  ``Set.prototype.delete()``,
         `#1 <#qref-Set.prototype.delete>`__
      -  ``Set.prototype.forEach()``,
         `#1 <#qref-Set.prototype.forEach>`__
      -  ``Set.prototype.has()``, `#1 <#qref-Set.prototype.has>`__
      -  ``Set.prototype.size``, `#1 <#qref-Set.prototype.size>`__
      -  ``Set.prototype.values()``,
         `#1 <#qref-Set.prototype.values>`__
      -  ``Set.prototype[Symbol.iterator]()``,
         `#1 <#qref-Set.prototype-Symbol.iterator->`__
      -  setter (object literal),
         `#1 <#index-entry-setter--object-literal->`__
      -  settled (Promise state),
         `#1 <#index-entry-settled--Promise-state->`__
      -  shadowing, `#1 <#index-entry-shadowing>`__
      -  shallow copy of an object,
         `#1 <#index-entry-shallow-copy-of-an-object>`__
      -  shim, `#1 <#index-entry-shim>`__
      -  short-circuiting, `#1 <#index-entry-short-circuiting>`__
      -  signed right shift operator,
         `#1 <#index-entry-signed-right-shift-operator>`__
      -  single inheritance,
         `#1 <#index-entry-single-inheritance>`__
      -  sloppy mode, `#1 <#index-entry-sloppy-mode>`__
      -  slot, private, `#1 <#index-entry-slot--private>`__
      -  slot, public, `#1 <#index-entry-slot--public>`__
      -  snake case, `#1 <#index-entry-snake-case>`__,
         `#2 <#index-entry-snake-case2>`__
      -  sparse Array, `#1 <#index-entry-sparse-Array>`__
      -  specialized function,
         `#1 <#index-entry-specialized-function>`__
      -  specifier, module, `#1 <#index-entry-specifier--module>`__
      -  speculative polyfill,
         `#1 <#index-entry-speculative-polyfill>`__
      -  spreading (``...``) into a function call,
         `#1 <#index-entry-spreading-into-a-function-call>`__
      -  spreading into an Array literal,
         `#1 <#index-entry-spreading-into-an-Array-literal>`__
      -  spreading into an object literal,
         `#1 <#index-entry-spreading-into-an-object-literal>`__
      -  statement, `#1 <#index-entry-statement>`__
      -  states of a Promise,
         `#1 <#index-entry-states-of-a-Promise>`__
      -  ``static``, `#1 <#index-entry-static>`__
      -  static vs. dynamic,
         `#1 <#index-entry-static-vs.-dynamic>`__
      -  strict mode, `#1 <#index-entry-strict-mode>`__
      -  string, `#1 <#index-entry-string>`__
      -  ``String.prototype.at()``,
         `#1 <#qref-String.prototype.at>`__
      -  ``String.prototype.concat()``,
         `#1 <#qref-String.prototype.concat>`__
      -  ``String.prototype.endsWith()``,
         `#1 <#qref-String.prototype.endsWith>`__
      -  ``String.prototype.includes()``,
         `#1 <#qref-String.prototype.includes>`__
      -  ``String.prototype.indexOf()``,
         `#1 <#qref-String.prototype.indexOf>`__
      -  ``String.prototype.isWellFormed()``,
         `#1 <#qref-String.prototype.isWellFormed>`__
      -  ``String.prototype.lastIndexOf()``,
         `#1 <#qref-String.prototype.lastIndexOf>`__
      -  ``String.prototype.match()``,
         `#1 <#qref-String.prototype.match>`__
      -  ``String.prototype.normalize()``,
         `#1 <#qref-String.prototype.normalize>`__
      -  ``String.prototype.padEnd()``,
         `#1 <#qref-String.prototype.padEnd>`__
      -  ``String.prototype.padStart()``,
         `#1 <#qref-String.prototype.padStart>`__
      -  ``String.prototype.repeat()``,
         `#1 <#qref-String.prototype.repeat>`__
      -  ``String.prototype.replace()``,
         `#1 <#qref-String.prototype.replace>`__
      -  ``String.prototype.replaceAll()``,
         `#1 <#qref-String.prototype.replaceAll>`__
      -  ``String.prototype.search()``,
         `#1 <#qref-String.prototype.search>`__
      -  ``String.prototype.slice()``,
         `#1 <#qref-String.prototype.slice>`__
      -  ``String.prototype.split()``,
         `#1 <#qref-String.prototype.split>`__
      -  ``String.prototype.startsWith()``,
         `#1 <#qref-String.prototype.startsWith>`__
      -  ``String.prototype.substring()``,
         `#1 <#qref-String.prototype.substring>`__
      -  ``String.prototype.toLowerCase()``,
         `#1 <#qref-String.prototype.toLowerCase>`__
      -  ``String.prototype.toUpperCase()``,
         `#1 <#qref-String.prototype.toUpperCase>`__
      -  ``String.prototype.toWellFormed()``,
         `#1 <#qref-String.prototype.toWellFormed>`__
      -  ``String.prototype.trim()``,
         `#1 <#qref-String.prototype.trim>`__
      -  ``String.prototype.trimEnd()``,
         `#1 <#qref-String.prototype.trimEnd>`__
      -  ``String.prototype.trimStart()``,
         `#1 <#qref-String.prototype.trimStart>`__
      -  ``String()``, `#1 <#index-entry-String-->`__
      -  subclass, `#1 <#index-entry-subclass>`__
      -  subclassing, `#1 <#index-entry-subclassing>`__
      -  subtraction, `#1 <#index-entry-subtraction>`__
      -  superclass, `#1 <#index-entry-superclass>`__
      -  surrogate, leading,
         `#1 <#index-entry-surrogate--leading>`__
      -  surrogate, lone, `#1 <#index-entry-surrogate--lone>`__
      -  surrogate, trailing,
         `#1 <#index-entry-surrogate--trailing>`__
      -  ``switch``, `#1 <#index-entry-switch>`__
      -  symbol, `#1 <#index-entry-symbol>`__
      -  symbol, publicly known,
         `#1 <#index-entry-symbol--publicly-known>`__
      -  synchronous generator,
         `#1 <#index-entry-synchronous-generator>`__
      -  synchronous iterable,
         `#1 <#index-entry-synchronous-iterable>`__
      -  synchronous iteration,
         `#1 <#index-entry-synchronous-iteration>`__
      -  synchronous iterator,
         `#1 <#index-entry-synchronous-iterator>`__
      -  syntax, `#1 <#index-entry-syntax>`__

      -  tagged template,
         `#1 <#index-entry-tagged-template>`__
      -  task queue, `#1 <#index-entry-task-queue>`__
      -  task runner, `#1 <#index-entry-task-runner>`__
      -  TC39, `#1 <#index-entry-TC39>`__
      -  TC39 process, `#1 <#index-entry-TC39-process>`__
      -  TDZ (temporal dead zone),
         `#1 <#index-entry-TDZ--temporal-dead-zone->`__
      -  Technical CommitteeÂ 39,
         `#1 <#index-entry-Technical-Committee-39>`__
      -  template literal,
         `#1 <#index-entry-template-literal>`__
      -  temporal dead zone,
         `#1 <#index-entry-temporal-dead-zone>`__
      -  ternary operator, `#1 <#index-entry-ternary-operator>`__
      -  ``this``, `#1 <#index-entry-this>`__
      -  ``this``, dynamic, `#1 <#index-entry-this--dynamic>`__
      -  ``this``, lexical, `#1 <#index-entry-this--lexical>`__
      -  ``this``, values of, `#1 <#index-entry-this--values-of>`__
      -  ``throw``, `#1 <#index-entry-throw>`__
      -  time value, `#1 <#index-entry-time-value>`__
      -  times operator, `#1 <#index-entry-times-operator>`__
      -  to the power of operator,
         `#1 <#index-entry-to-the-power-of-operator>`__
      -  trailing commas in Array literals,
         `#1 <#index-entry-trailing-commas-in-Array-literals>`__
      -  trailing commas in JSON,
         `#1 <#index-entry-trailing-commas-in-JSON>`__
      -  trailing commas in object literals,
         `#1 <#index-entry-trailing-commas-in-object-literals>`__
      -  trailing commas in parameter lists,
         `#1 <#index-entry-trailing-commas-in-parameter-lists>`__
      -  trailing surrogate,
         `#1 <#index-entry-trailing-surrogate>`__
      -  transpilation, `#1 <#index-entry-transpilation>`__
      -  transpiler, `#1 <#index-entry-transpiler>`__
      -  tree-shaking, `#1 <#index-entry-tree-shaking>`__
      -  ``true``, `#1 <#index-entry-true>`__
      -  truthiness, `#1 <#index-entry-truthiness>`__
      -  truthy, `#1 <#index-entry-truthy>`__
      -  ``try``, `#1 <#index-entry-try>`__
      -  type, `#1 <#index-entry-type>`__
      -  type hierarchy, `#1 <#index-entry-type-hierarchy>`__
      -  type signature, `#1 <#index-entry-type-signature>`__
      -  Typed Array, `#1 <#index-entry-Typed-Array>`__
      -  ``TypedArray.from()``, `#1 <#qref-TypedArray.from>`__
      -  ``TypedArray.of()``, `#1 <#qref-TypedArray.of>`__
      -  ``TypedArray.prototype.buffer``,
         `#1 <#qref-TypedArray.prototype.buffer>`__
      -  ``TypedArray.prototype.byteLength``,
         `#1 <#qref-TypedArray.prototype.byteLength>`__
      -  ``TypedArray.prototype.byteOffset``,
         `#1 <#qref-TypedArray.prototype.byteOffset>`__
      -  ``TypedArray.prototype.length``,
         `#1 <#qref-TypedArray.prototype.length>`__
      -  ``TypedArray.prototype.set()``,
         `#1 <#qref-TypedArray.prototype.set>`__
      -  ``TypedArray.prototype.subarray()``,
         `#1 <#qref-TypedArray.prototype.subarray>`__
      -  ``typeof``, `#1 <#index-entry-typeof>`__
      -  TypeScript, `#1 <#index-entry-TypeScript>`__

      -  ``Uint8Array``, `#1 <#index-entry-Uint8Array>`__
      -  ``Uint8ClampedArray``,
         `#1 <#index-entry-Uint8ClampedArray>`__
      -  ``Uint16Array``, `#1 <#index-entry-Uint16Array>`__
      -  ``Uint32Array``, `#1 <#index-entry-Uint32Array>`__
      -  ``undefined``, `#1 <#index-entry-undefined>`__
      -  underscore case, `#1 <#index-entry-underscore-case>`__,
         `#2 <#index-entry-underscore-case2>`__
      -  Unicode, `#1 <#index-entry-Unicode>`__
      -  Unicode code point escape,
         `#1 <#index-entry-Unicode-code-point-escape>`__
      -  Unicode code unit escape,
         `#1 <#index-entry-Unicode-code-unit-escape>`__
      -  Unicode scalar, `#1 <#index-entry-Unicode-scalar>`__,
         `#2 <#index-entry-Unicode-scalar2>`__
      -  Unicode Transformation Format (UTF),
         `#1 <#index-entry-Unicode-Transformation-Format--UTF->`__
      -  unit test, `#1 <#index-entry-unit-test>`__
      -  unsigned right shift operator,
         `#1 <#index-entry-unsigned-right-shift-operator>`__
      -  UTC (Coordinated Universal Time),
         `#1 <#index-entry-UTC--Coordinated-Universal-Time->`__
      -  UTF (Unicode Transformation Format),
         `#1 <#index-entry-UTF--Unicode-Transformation-Format->`__
      -  UTF-8, `#1 <#index-entry-UTF-8>`__
      -  UTF-16, `#1 <#index-entry-UTF-16>`__
      -  UTF-32, `#1 <#index-entry-UTF-32>`__

      -  value-preservation,
         `#1 <#index-entry-value-preservation>`__
      -  variable, bound,
         `#1 <#index-entry-variable--bound>`__
      -  variable, free,
         `#1 <#index-entry-variable--free>`__
      -  variable, scope of a,
         `#1 <#index-entry-variable--scope-of-a>`__
      -  ``void`` operator, `#1 <#index-entry-void-operator>`__

      -  Wasm (WebAssembly),
         `#1 <#index-entry-Wasm--WebAssembly->`__
      -  WeakMap, `#1 <#index-entry-WeakMap>`__,
         `#2 <#index-entry-WeakMap2>`__
      -  WeakSet, `#1 <#index-entry-WeakSet>`__,
         `#2 <#index-entry-WeakSet2>`__
      -  Web Worker, `#1 <#index-entry-Web-Worker>`__
      -  WebAssembly, `#1 <#index-entry-WebAssembly>`__
      -  ``while``, `#1 <#index-entry-while>`__
      -  ``window``, `#1 <#index-entry-window>`__
      -  wrapper types (for primitive types),
         `#1 <#index-entry-wrapper-types--for-primitive-types->`__

      -  ``yield`` (asynchronous generator),
         `#1 <#index-entry-yield--asynchronous-generator->`__
      -  ``yield`` (synchronous generator),
         `#1 <#index-entry-yield--synchronous-generator->`__
      -  ``yield*`` (asynchronous generator),
         `#1 <#index-entry-yield---asynchronous-generator->`__
      -  ``yield*`` (synchronous generator),
         `#1 <#index-entry-yield---synchronous-generator->`__

      -  Z (Zulu Time Zone), `#1 <#index-entry-Z--Zulu-Time-Zone->`__
      -  Zulu Time Zone (Z), `#1 <#index-entry-Zulu-Time-Zone--Z->`__
