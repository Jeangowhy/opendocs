
/TOC 💛 Jetpack Compose libraries
================================

.. container:: devsite-doc-set-nav-row

   -  `Core areas <https://developer.android.google.cn/develop/core-areas>`__
   -  `UI <https://developer.android.google.cn/develop/ui>`__
   -  `Overview <https://developer.android.google.cn/develop/ui>`__
   -  `Tutorial <https://developer.android.google.cn/develop/ui/compose/tutorial>`__
   -  `Samples <https://developer.android.google.cn/develop/ui/compose/samples>`__
   -  `Guides <https://developer.android.google.cn/develop/ui/compose/documentation>`__

.. container:: devsite-mobile-nav-bottom

   -  Introduction

      -  `Documentation <https://developer.android.google.cn/develop/ui/compose/documentation>`__
      -  `Why Compose <https://developer.android.google.cn/develop/ui/compose/why-adopt>`__
      -  `Quick start <https://developer.android.google.cn/develop/ui/compose/setup>`__
      -  `Compose Compiler Gradle Plugin <https://developer.android.google.cn/develop/ui/compose/compiler>`__
      -  `Thinking in Compose <https://developer.android.google.cn/develop/ui/compose/mental-model>`__

      -  Bill of Materials

         -  `Using the Bill of Materials <https://developer.android.google.cn/develop/ui/compose/bom>`__
         -  `BOM to library version mapping <https://developer.android.google.cn/develop/ui/compose/bom/bom-mapping>`__

   -  UI architecture

      -  `Lifecycle <https://developer.android.google.cn/develop/ui/compose/lifecycle>`__
      -  `Side-effects <https://developer.android.google.cn/develop/ui/compose/side-effects>`__
      -  `Phases <https://developer.android.google.cn/develop/ui/compose/phases>`__

      -  Managing state

         -  `Overview <https://developer.android.google.cn/develop/ui/compose/state>`__
         -  `Where to hoist state <https://developer.android.google.cn/develop/ui/compose/state-hoisting>`__
         -  `Save UI state <https://developer.android.google.cn/develop/ui/compose/state-saving>`__

      -  `Architecture <https://developer.android.google.cn/develop/ui/compose/architecture>`__
      -  `Architectural layering <https://developer.android.google.cn/develop/ui/compose/layering>`__
      -  `CompositionLocal <https://developer.android.google.cn/develop/ui/compose/compositionlocal>`__
      -  `Navigation <https://developer.android.google.cn/develop/ui/compose/navigation>`__

   -  Develop your app's layout

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/layouts>`__
      -  `Layout basics <https://developer.android.google.cn/develop/ui/compose/layouts/basics>`__
      -  `Modifiers <https://developer.android.google.cn/develop/ui/compose/modifiers>`__
      -  `Constraints and modifier order <https://developer.android.google.cn/develop/ui/compose/layouts/constraints-modifiers>`__
      -  `Custom modifiers <https://developer.android.google.cn/develop/ui/compose/custom-modifiers>`__
      -  `List of modifiers <https://developer.android.google.cn/develop/ui/compose/modifiers-list>`__
      -  `Pager <https://developer.android.google.cn/develop/ui/compose/layouts/pager>`__
      -  `Flow layouts <https://developer.android.google.cn/develop/ui/compose/layouts/flow>`__
      -  `Custom layouts <https://developer.android.google.cn/develop/ui/compose/layouts/custom>`__

      -  Adaptive layouts

         -  `Build adaptive layouts <https://developer.android.google.cn/develop/ui/compose/layouts/adaptive>`__
         -  `Build a list-detail layout <https://developer.android.google.cn/develop/ui/compose/layouts/list-detail>`__

      -  `Alignment lines <https://developer.android.google.cn/develop/ui/compose/layouts/alignment-lines>`__
      -  `Intrinsic measurements <https://developer.android.google.cn/develop/ui/compose/layouts/intrinsic-measurements>`__
      -  `ConstraintLayout <https://developer.android.google.cn/develop/ui/compose/layouts/constraintlayout>`__

   -  Components

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/components>`__
      -  `Scaffold <https://developer.android.google.cn/develop/ui/compose/components/scaffold>`__
      -  `App bars <https://developer.android.google.cn/develop/ui/compose/components/app-bars>`__
      -  `Button <https://developer.android.google.cn/develop/ui/compose/components/button>`__
      -  `Floating action button <https://developer.android.google.cn/develop/ui/compose/components/fab>`__
      -  `Card <https://developer.android.google.cn/develop/ui/compose/components/card>`__
      -  `Chip <https://developer.android.google.cn/develop/ui/compose/components/chip>`__
      -  `Dialog <https://developer.android.google.cn/develop/ui/compose/components/dialog>`__
      -  `Progress indicators <https://developer.android.google.cn/develop/ui/compose/components/progress>`__
      -  `Slider <https://developer.android.google.cn/develop/ui/compose/components/slider>`__
      -  `Switch <https://developer.android.google.cn/develop/ui/compose/components/switch>`__
      -  `Bottom sheets <https://developer.android.google.cn/develop/ui/compose/components/bottom-sheets>`__
      -  `Navigation drawer <https://developer.android.google.cn/develop/ui/compose/components/drawer>`__
      -  `Snackbar <https://developer.android.google.cn/develop/ui/compose/components/snackbar>`__
      -  `Lists and grids <https://developer.android.google.cn/develop/ui/compose/lists>`__
      -  `Resources <https://developer.android.google.cn/develop/ui/compose/resources>`__

   -  Theming

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/designsystems>`__
      -  `Material Design 3 <https://developer.android.google.cn/develop/ui/compose/designsystems/material3>`__
      -  `Migrate from Material 2 to Material 3 <https://developer.android.google.cn/develop/ui/compose/designsystems/material2-material3>`__
      -  `Material Design 2 <https://developer.android.google.cn/develop/ui/compose/designsystems/material>`__
      -  `Custom theming <https://developer.android.google.cn/develop/ui/compose/designsystems/custom>`__
      -  `Anatomy of a theme <https://developer.android.google.cn/develop/ui/compose/designsystems/anatomy>`__
      -  `Migrating XML themes to Compose <https://developer.android.google.cn/develop/ui/compose/designsystems/views-to-compose>`__

   -  Text and typography

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/text>`__

      -  Display and style text

         -  `Display text from resource <https://developer.android.google.cn/develop/ui/compose/text/display-text>`__
         -  `Style text <https://developer.android.google.cn/develop/ui/compose/text/style-text>`__
         -  `Style paragraph <https://developer.android.google.cn/develop/ui/compose/text/style-paragraph>`__
         -  `Configure text layout <https://developer.android.google.cn/develop/ui/compose/text/configure-layout>`__

      -  `Handle user input <https://developer.android.google.cn/develop/ui/compose/text/user-input>`__
      -  `Enable user interactions <https://developer.android.google.cn/develop/ui/compose/text/user-interactions>`__
      -  `Work with fonts <https://developer.android.google.cn/develop/ui/compose/text/fonts>`__
      -  `Display emoji <https://developer.android.google.cn/develop/ui/compose/text/emoji>`__

   -  Images and graphics

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/graphics>`__

      -  Images

         -  `Overview <https://developer.android.google.cn/develop/ui/compose/graphics/images>`__
         -  `Loading images <https://developer.android.google.cn/develop/ui/compose/graphics/images/loading>`__
         -  `ImageBitmap vs ImageVector <https://developer.android.google.cn/develop/ui/compose/graphics/images/compare>`__
         -  `Material icons <https://developer.android.google.cn/develop/ui/compose/graphics/images/material>`__
         -  `Customize an image <https://developer.android.google.cn/develop/ui/compose/graphics/images/customize>`__
         -  `Custom painter <https://developer.android.google.cn/develop/ui/compose/graphics/images/custompainter>`__
         -  `Optimizing performance <https://developer.android.google.cn/develop/ui/compose/graphics/images/optimization>`__

      -  Graphics

         -  `Overview <https://developer.android.google.cn/develop/ui/compose/graphics/draw/overview>`__
         -  `Graphics Modifiers <https://developer.android.google.cn/develop/ui/compose/graphics/draw/modifiers>`__
         -  `Brush <https://developer.android.google.cn/develop/ui/compose/graphics/draw/brush>`__
         -  `Shapes <https://developer.android.google.cn/develop/ui/compose/graphics/draw/shapes>`__

   -  Animation

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/animation/introduction>`__
      -  `Choose an animation API <https://developer.android.google.cn/develop/ui/compose/animation/choose-api>`__
      -  `Quick guide <https://developer.android.google.cn/develop/ui/compose/animation/quick-guide>`__
      -  `Animation modifiers and composables <https://developer.android.google.cn/develop/ui/compose/animation/composables-modifiers>`__
      -  `Value-based animations <https://developer.android.google.cn/develop/ui/compose/animation/value-based>`__
      -  `Animated vector images <https://developer.android.google.cn/develop/ui/compose/animation/vectors>`__
      -  `Advanced animation example <https://developer.android.google.cn/develop/ui/compose/animation/advanced>`__
      -  `Customize animations <https://developer.android.google.cn/develop/ui/compose/animation/customize>`__

      -  Shared elements

         -  `Introduction <https://developer.android.google.cn/develop/ui/compose/animation/shared-elements>`__
         -  `Customize <https://developer.android.google.cn/develop/ui/compose/animation/shared-elements/customize>`__
         -  `Common use cases <https://developer.android.google.cn/develop/ui/compose/animation/shared-elements/common-use-cases>`__
         -  `With navigation <https://developer.android.google.cn/develop/ui/compose/animation/shared-elements/navigation>`__
         -  `Additional samples <https://developer.android.google.cn/develop/ui/compose/animation/shared-elements/additional-samples>`__

      -  `Test animations <https://developer.android.google.cn/develop/ui/compose/animation/testing>`__
      -  `Tools <https://developer.android.google.cn/develop/ui/compose/animation/tooling>`__
      -  `Additional resources <https://developer.android.google.cn/develop/ui/compose/animation/resources>`__

   -  Accessibility

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/accessibility>`__
      -  `Key steps <https://developer.android.google.cn/develop/ui/compose/accessibility/key-steps>`__
      -  `Semantics <https://developer.android.google.cn/develop/ui/compose/accessibility/semantics>`__
      -  `Control traversal order <https://developer.android.google.cn/develop/ui/compose/accessibility/traversal>`__
      -  `Testing <https://developer.android.google.cn/develop/ui/compose/accessibility/testing>`__

   -  Touch and input

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/touch-input>`__

      -  Pointer input

         -  `Overview <https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input>`__
         -  `Understand gestures <https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/understand-gestures>`__
         -  `Tap and press <https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/tap-and-press>`__
         -  `Scroll <https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/scroll>`__
         -  `Drag, swipe, and fling <https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/drag-swipe-fling>`__
         -  `Migrate from Swipeable to AnchoredDraggable <https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/migrate-swipeable>`__
         -  `Multi-touch gestures <https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/multi-touch>`__

      -  Keyboard input

         -  `Keyboard Shortcut Helper <https://developer.android.google.cn/develop/ui/compose/touch-input/keyboard-input/keyboard-shortcut-helper>`__

      -  Focus

         -  `Overview <https://developer.android.google.cn/develop/ui/compose/touch-input/focus>`__
         -  `Change focus traversal order <https://developer.android.google.cn/develop/ui/compose/touch-input/focus/change-focus-traversal-order>`__
         -  `Change focus behavior <https://developer.android.google.cn/develop/ui/compose/touch-input/focus/change-focus-behavior>`__
         -  `React to focus <https://developer.android.google.cn/develop/ui/compose/touch-input/focus/react-to-focus>`__

      -  User interactions

         -  `Handling interactions <https://developer.android.google.cn/develop/ui/compose/touch-input/user-interactions/handling-interactions>`__
         -  `Migrate to Indication and Ripple APIs <https://developer.android.google.cn/develop/ui/compose/touch-input/user-interactions/migrate-indication-ripple>`__

   -  Performance

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/performance>`__
      -  `Phases <https://developer.android.google.cn/develop/ui/compose/performance/phases>`__
      -  `Baseline profiles <https://developer.android.google.cn/develop/ui/compose/performance/baseline-profiles>`__

      -  Stability

         -  `Overview <https://developer.android.google.cn/develop/ui/compose/performance/stability>`__
         -  `Diagnose stability issues <https://developer.android.google.cn/develop/ui/compose/performance/stability/diagnose>`__
         -  `Fix stability issues <https://developer.android.google.cn/develop/ui/compose/performance/stability/fix>`__

      -  `Tools <https://developer.android.google.cn/develop/ui/compose/performance/tooling>`__
      -  `Best practices <https://developer.android.google.cn/develop/ui/compose/performance/bestpractices>`__

   -  Style guidelines

      -  `Compose API guidelines <https://developer.android.google.cn/develop/ui/compose/api-guidelines>`__
      -  `Kotlin for Compose <https://developer.android.google.cn/develop/ui/compose/kotlin>`__

   -  UI testing

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/testing>`__
      -  `Cheatsheet <https://developer.android.google.cn/develop/ui/compose/testing/testing-cheatsheet>`__
      -  `Semantics <https://developer.android.google.cn/develop/ui/compose/testing/semantics>`__
      -  `Testing APIs <https://developer.android.google.cn/develop/ui/compose/testing/apis>`__
      -  `Synchronize tests <https://developer.android.google.cn/develop/ui/compose/testing/synchronization>`__
      -  `Interoperability <https://developer.android.google.cn/develop/ui/compose/testing/interoperability>`__
      -  `Common patterns <https://developer.android.google.cn/develop/ui/compose/testing/common-patterns>`__
      -  `Debug tests <https://developer.android.google.cn/develop/ui/compose/testing/debug>`__

   -  Migrate to Compose

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/migrate>`__
      -  `Migration strategy <https://developer.android.google.cn/develop/ui/compose/migrate/strategy>`__

      -  Interoperability APIs

         -  `Overview <https://developer.android.google.cn/develop/ui/compose/migrate/interoperability-apis>`__
         -  `Using Compose in Views <https://developer.android.google.cn/develop/ui/compose/migrate/interoperability-apis/compose-in-views>`__
         -  `Using Views in Compose <https://developer.android.google.cn/develop/ui/compose/migrate/interoperability-apis/views-in-compose>`__

      -  Common migration scenarios

         -  `Migrate RecyclerView to Compose <https://developer.android.google.cn/develop/ui/compose/migrate/migration-scenarios/recycler-view>`__
         -  `Migrate CoordinatorLayout to Compose <https://developer.android.google.cn/develop/ui/compose/migrate/migration-scenarios/coordinator-layout>`__
         -  `Migrate Jetpack Navigation to Navigation Compose <https://developer.android.google.cn/develop/ui/compose/migrate/migration-scenarios/navigation>`__

      -  `Other considerations <https://developer.android.google.cn/develop/ui/compose/migrate/other-considerations>`__
      -  `Adopt Compose for teams <https://developer.android.google.cn/develop/ui/compose/adopt/for-large-teams>`__
      -  `Compose and other libraries <https://developer.android.google.cn/develop/ui/compose/libraries>`__
      -  `Compare Compose and View metrics <https://developer.android.google.cn/develop/ui/compose/migrate/compare-metrics>`__

   -  Tools

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/tooling>`__

      -  Design

         -  `Preview your UI <https://developer.android.google.cn/develop/ui/compose/tooling/previews>`__
         -  `Preview and debug animations <https://developer.android.google.cn/develop/ui/compose/tooling/animation-preview>`__

      -  Develop

         -  `Develop code iteratively <https://developer.android.google.cn/develop/ui/compose/tooling/iterative-development>`__
         -  `Editor actions <https://developer.android.google.cn/develop/ui/compose/tooling/editor-actions>`__

      -  Debug

         -  `Inspect your layout <https://developer.android.google.cn/develop/ui/compose/tooling/layout-inspector>`__
         -  `Trace app performance <https://developer.android.google.cn/develop/ui/compose/tooling/tracing>`__

      -  Relay designer and developer tooling

         -  `Overview <https://developer.android.google.cn/develop/ui/compose/tooling/relay>`__
         -  `Install Relay <https://developer.android.google.cn/develop/ui/compose/tooling/relay/install-relay>`__
         -  `Set up your Android project <https://developer.android.google.cn/develop/ui/compose/tooling/relay/android-project-setup>`__

         -  Basic tutorial

            -  `Overview <https://developer.android.google.cn/develop/ui/compose/tooling/relay/basic-tutorial>`__
            -  `Create UI Package in Figma <https://developer.android.google.cn/develop/ui/compose/tooling/relay/create-ui-package-in-figma>`__
            -  `Convert the designs to code in Android Studio <https://developer.android.google.cn/develop/ui/compose/tooling/relay/convert-designs-android-studio>`__
            -  `Make and propagate design updates <https://developer.android.google.cn/develop/ui/compose/tooling/relay/design-updates>`__
            -  `Content parameters <https://developer.android.google.cn/develop/ui/compose/tooling/relay/content-parameters>`__

         -  Advanced tutorial

            -  `Overview <https://developer.android.google.cn/develop/ui/compose/tooling/relay/advanced-tutorial>`__
            -  `Handling design variants <https://developer.android.google.cn/develop/ui/compose/tooling/relay/design-variants>`__
            -  `Content parameters <https://developer.android.google.cn/develop/ui/compose/tooling/relay/content-parameters-advanced>`__
            -  `Add interaction handlers to designs <https://developer.android.google.cn/develop/ui/compose/tooling/relay/interaction-handlers>`__

         -  Relay workflow

            -  `Overview <https://developer.android.google.cn/develop/ui/compose/tooling/relay/relay-workflow>`__
            -  `Create UI Packages <https://developer.android.google.cn/develop/ui/compose/tooling/relay/create-ui-packages>`__
            -  `Add parameters <https://developer.android.google.cn/develop/ui/compose/tooling/relay/add-parameters>`__
            -  `Check errors <https://developer.android.google.cn/develop/ui/compose/tooling/relay/check-errors>`__
            -  `Share UI Packages <https://developer.android.google.cn/develop/ui/compose/tooling/relay/share-ui-packages>`__
            -  `Android Studio workflow <https://developer.android.google.cn/develop/ui/compose/tooling/relay/android-studio-workflow>`__
            -  `Understand UI Package & generated code <https://developer.android.google.cn/develop/ui/compose/tooling/relay/understand-ui-package>`__
            -  `Figma DevMode <https://developer.android.google.cn/develop/ui/compose/tooling/relay/figma-devmode>`__

         -  Design-to-code translation details

            -  `Figma Component Properties <https://developer.android.google.cn/develop/ui/compose/tooling/relay/figma-component-properties>`__
            -  `Children parameters <https://developer.android.google.cn/develop/ui/compose/tooling/relay/children-parameters>`__
            -  `Nested package instances <https://developer.android.google.cn/develop/ui/compose/tooling/relay/nested-package-instances>`__
            -  `Vector graphics <https://developer.android.google.cn/develop/ui/compose/tooling/relay/vector-graphics>`__
            -  `Multiple styles in text <https://developer.android.google.cn/develop/ui/compose/tooling/relay/multiple-styles-in-text>`__
            -  `Absolute positioning within auto layout <https://developer.android.google.cn/develop/ui/compose/tooling/relay/absolute-positioning>`__
            -  `Fill color <https://developer.android.google.cn/develop/ui/compose/tooling/relay/fill-color>`__
            -  `Effects <https://developer.android.google.cn/develop/ui/compose/tooling/relay/effects>`__

         -  `Limitations and troubleshooting <https://developer.android.google.cn/develop/ui/compose/tooling/relay/limitations-and-troubleshooting>`__

         -  Experimental features

            -  `Mapping styles to Compose theme <https://developer.android.google.cn/develop/ui/compose/tooling/relay/mapping-styles-to-compose-theme>`__
            -  `Mapping components to existing code <https://developer.android.google.cn/develop/ui/compose/tooling/relay/mapping-components-to-existing-code>`__

         -  `Releases <https://developer.android.google.cn/develop/ui/compose/tooling/relay/releases>`__

   -  Leverage system capabilities

      -  `Window Insets <https://developer.android.google.cn/develop/ui/compose/layouts/insets>`__
      -  `Cutouts <https://developer.android.google.cn/develop/ui/compose/system/cutouts>`__
      -  `Picture-in-picture <https://developer.android.google.cn/develop/ui/compose/system/picture-in-picture>`__

   -  Create widgets

      -  `Overview <https://developer.android.google.cn/develop/ui/compose/glance>`__
      -  `Glance setup <https://developer.android.google.cn/develop/ui/compose/glance/setup>`__
      -  `Create an app widget with Glance <https://developer.android.google.cn/develop/ui/compose/glance/create-app-widget>`__
      -  `Handle user interaction with Glance <https://developer.android.google.cn/develop/ui/compose/glance/user-interaction>`__
      -  `Manage and update GlanceAppWidget <https://developer.android.google.cn/develop/ui/compose/glance/glance-app-widget>`__
      -  `Build UI with Glance <https://developer.android.google.cn/develop/ui/compose/glance/build-ui>`__
      -  `Implement a Glance theme <https://developer.android.google.cn/develop/ui/compose/glance/theme>`__
      -  `Glance interoperability <https://developer.android.google.cn/develop/ui/compose/glance/interoperability>`__
      -  `Additional resources <https://developer.android.google.cn/develop/ui/compose/glance/additional-resources>`__


/Get started with Jetpack Compose
=================================

.. container:: devsite-article-meta nocontent

   -  `Android Developers <https://developer.android.google.cn/>`__
   -  `Develop <https://developer.android.google.cn/develop>`__
   -  `Core areas <https://developer.android.google.cn/develop/core-areas>`__
   -  `UI <https://developer.android.google.cn/develop/ui>`__
   -  `Guides <https://developer.android.google.cn/develop/ui/compose/documentation>`__

.. container:: devsite-article-body clearfix

   Jetpack Compose is the modern toolkit for building native Android
   UI. Here's where you'll find the latest information about using
   Compose.

   -  `Overview <https://developer.android.google.cn/develop/ui/compose>`__
      : See all the resources
      available to Compose developers.

   -  `Tutorial <https://developer.android.google.cn/develop/ui/compose/tutorial>`__
      : Get started with
      Compose, by using it to build a simple UI.

   .. rubric:: Foundation
      :name: core

   -  `Thinking in Compose <https://developer.android.google.cn/develop/ui/compose/mental-model>`__
      : Learn
      how Compose's declarative approach is different from the
      view-based approach you may have used in the past, and how to
      build a mental model of working with Compose.

   -  `Managing state <https://developer.android.google.cn/develop/ui/compose/state>`__
      : Learn about
      setting and using state in your Compose app.

   -  `Lifecycle of composables <https://developer.android.google.cn/develop/ui/compose/lifecycle>`__
      : Learn about the lifecycle of a composable, and how Compose
      decides if it needs to be redrawn.

   -  `Modifiers <https://developer.android.google.cn/develop/ui/compose/modifiers>`__
      : Learn how to use
      modifiers to augment or decorate your composables.

   -  `Side-effects in Compose <https://developer.android.google.cn/develop/ui/compose/side-effects>`__
      : Learn the best ways to manage side-effects.

   -  `Jetpack Compose Phases <https://developer.android.google.cn/develop/ui/compose/phases>`__
      : Learn
      about the steps Compose goes through to render your UI, and how
      to use that information to write efficient code
   -  `Architectural layering <https://developer.android.google.cn/develop/ui/compose/layering>`__
      : Learn
      about the architectural layers that make up Jetpack Compose, and
      the core principles that informed its design.

   -  `Performance <https://developer.android.google.cn/develop/ui/compose/performance>`__
      : Learn how to
      avoid the common programming pitfalls that can hurt your app's
      performance.

   -  `Semantics in Compose <https://developer.android.google.cn/develop/ui/compose/semantics>`__
      : Learn
      about the Semantics tree, which organizes your UI in a way that
      can be used by accessibility services and the testing framework.

   -  `Locally scoped data with CompositionLocal <https://developer.android.google.cn/develop/ui/compose/compositionlocal>`__
      : Learn
      how to use ``CompositionLocal`` to pass data through the Composition.

   .. rubric:: Development environment
      :name: dev-env

   -  `Android Studio with Compose <https://developer.android.google.cn/develop/ui/compose/setup>`__
      : Set
      up your development environment to use Compose.

   -  `Tooling for Compose <https://developer.android.google.cn/develop/ui/compose/tooling>`__
      : Learn
      about Android Studio's new features to support Compose.

   -  `Kotlin for Compose <https://developer.android.google.cn/develop/ui/compose/kotlin>`__
      : Learn how
      certain Kotlin-specific idioms work with Compose.

   -  `Compare Compose and View performance <https://developer.android.google.cn/develop/ui/compose/ergonomics>`__
      : Learn how
      migrating to Compose can affect your app's APK size and runtime
      performance.

   -  `Bill of Materials <https://developer.android.google.cn/develop/ui/compose/bom>`__
      : Manage all your
      Compose dependencies by specifying only the BOM's version.

   .. rubric:: Design
      :name: design

   -  `Layouts <https://developer.android.google.cn/develop/ui/compose/layouts>`__
      : Learn about Compose's
      native layout components, and how to design your own.

      -  `Layout basics <https://developer.android.google.cn/develop/ui/compose/layouts/basics>`__
         : Learn
         about the building blocks for a straightforward app UI.
      -  `Material Components and layouts <https://developer.android.google.cn/develop/ui/compose/layouts/material>`__
         : Learn about Material components and layouts in Compose.
      -  `Custom layouts <https://developer.android.google.cn/develop/ui/compose/layouts/custom>`__
         : Learn
         how to take control of your app's layout, and how to design a
         custom layout of your own.
      -  `Build adaptive layouts <https://developer.android.google.cn/develop/ui/compose/layouts/adaptive>`__
         : Learn how to use Compose to build layouts that adapt to different screen
         sizes, orientations, and form factors.
      -  `Alignment lines <https://developer.android.google.cn/develop/ui/compose/layouts/alignment-lines>`__
         : Learn how to create custom alignment lines to precisely align and
         position your UI elements.
      -  `Intrinsic measurements <https://developer.android.google.cn/develop/ui/compose/layouts/intrinsic-measurements>`__
         : Since Compose only allows you to measure UI elements once per
         pass, this page explains how to query for information about
         child elements before measuring them.
      -  `ConstraintLayout <https://developer.android.google.cn/develop/ui/compose/layouts/constraintlayout>`__
         : Learn how to use ``ConstraintLayout`` in your Compose UI.

   -  `Design Systems <https://developer.android.google.cn/develop/ui/compose/designsystems>`__
      : Learn how
      to implement a design system and give your app a consistent look
      and feel.

      -  `Material Design 3 <https://developer.android.google.cn/develop/ui/compose/designsystems/material3>`__
         : Learn how
         to implement Material You with Compose's implementation of
         `Material Design 3 <https://m3.material.io/>`__.
      -  `Migrating from Material 2 to Material 3 <https://developer.android.google.cn/develop/ui/compose/designsystems/material2-material3>`__
         : Learn how to migrate your app from Material Design 2 to
         Material Design 3 in Compose.
      -  `Material Design 2 <https://developer.android.google.cn/develop/ui/compose/designsystems/material>`__
         : Learn how
         to customize Compose's implementation of `Material Design
         2 <https://material.io/>`__ to fit your product's brand.
      -  `Custom design systems <https://developer.android.google.cn/develop/ui/compose/designsystems/custom>`__
         : Learn
         how to implement a custom design system in Compose, and how to
         adapt existing Material Design composables to handle this.
      -  `Anatomy of a theme <https://developer.android.google.cn/develop/ui/compose/designsystems/anatomy>`__
         : Learn
         about the lower-level constructs and APIs used by
         ``MaterialTheme`` and custom design systems.

   -  `Lists and grids <https://developer.android.google.cn/develop/ui/compose/lists>`__
      : Learn about some
      of Compose's options for managing and displaying lists and grids of data.

   -  `Text <https://developer.android.google.cn/develop/ui/compose/text>`__
      : Learn about Compose's main
      options for displaying and editing text.

   -  `Graphics <https://developer.android.google.cn/develop/ui/compose/graphics>`__
      : Learn about
      Compose's features for building and working with custom graphics.

   -  `Animation <https://developer.android.google.cn/develop/ui/compose/animation>`__
      : Learn about
      Compose's different options for animating your UI elements.

   -  `Gestures <https://developer.android.google.cn/develop/ui/compose/gestures>`__
      : Learn how to build a
      Compose UI that detects and interacts with user gestures.

   -  `Handling user interactions <https://developer.android.google.cn/develop/ui/compose/touch-input/user-interactions/handling-interactions>`__
      : Learn how Compose abstracts low-level input into higher-level
      interactions, so you can customize how your components respond to
      user actions.

   .. rubric:: Adopting Compose
      :name: adopting

   -  `Migrate existing View-based apps <https://developer.android.google.cn/develop/ui/compose/migrate>`__
      : Learn how to migrate your existing View-based app to Compose.

      -  `Migration strategy <https://developer.android.google.cn/develop/ui/compose/migrate/strategy>`__
         : Learn the strategy to safely and incrementally introduce
         Compose into your codebase.
      -  `Interoperability APIs <https://developer.android.google.cn/develop/ui/compose/migrate/interoperability-apis>`__
         : Learn about Compose's APIs to help you combine Compose with
         View-based UI.
      -  `Other considerations <https://developer.android.google.cn/develop/ui/compose/migrate/other-considerations>`__
         : Learn about other considerations like theming, architecture,
         and testing while migrating your View-based app to Compose.

   -  `Compose and other libraries <https://developer.android.google.cn/develop/ui/compose/libraries>`__
      : Learn how to use view-based libraries in your Compose content.

   -  `Compose architecture <https://developer.android.google.cn/develop/ui/compose/architecture>`__
      : Learn how to implement the unidirectional flow pattern in
      Compose, how to implement events and state holders, and how to
      work with ``ViewModel`` in Compose.

   -  `Navigation <https://developer.android.google.cn/develop/ui/compose/navigation>`__
      : Learn how to use
      ``NavController`` to integrate the Navigation component with your
      Compose UI.

      -  `Navigation for responsive UIs <https://developer.android.google.cn/guide/topics/large-screens/navigation-for-responsive-uis>`__
         : Learn how to design your app's navigation so it adapts to
         different screen sizes, orientations, and form factors.

   -  `Resources <https://developer.android.google.cn/develop/ui/compose/resources>`__
      : Learn how to work
      with your app's resources in your Compose code.

   -  `Accessibility <https://developer.android.google.cn/develop/ui/compose/accessibility>`__
      : Learn how
      to make your Compose UI suitable for users with different
      accessibility requirements.

   -  `Testing <https://developer.android.google.cn/develop/ui/compose/testing>`__
      : Learn about testing
      your Compose code.

      -  `Testing cheat sheet <https://developer.android.google.cn/develop/ui/compose/testing-cheatsheet>`__
         : A quick reference of useful Compose testing APIs.

   .. rubric:: Additional resources
      :name: resources

   -  `Get setup <https://developer.android.google.cn/develop/ui/compose/setup>`__
   -  `Curated learning pathway <https://developer.android.google.cn/courses/pathways/compose>`__
   -  `Compose API guidelines <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/compose/docs/compose-api-guidelines.md>`__
   -  `API reference <https://developer.android.google.cn/reference/kotlin/androidx/compose>`__
   -  `Codelabs <https://goo.gle/compose-codelabs>`__
   -  `Sample apps <https://github.com/android/compose-samples>`__
   -  `Videos <https://www.youtube.com/user/androiddevelopers/search?query=%23jetpackcompose>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Locally scoped data with CompositionLocal <https://developer.android.google.cn/develop/ui/compose/compositionlocal>`__
   -  `Other considerations <https://developer.android.google.cn/develop/ui/compose/migrate/other-considerations>`__
   -  `Anatomy of a theme in Compose <https://developer.android.google.cn/develop/ui/compose/designsystems/anatomy>`__

Last updated 2024-05-03 UTC.


/Why Compose
============

.. https://developer.android.google.cn/develop/ui/compose/why-adopt?hl=en

.. container:: devsite-article-body clearfix

   .. container:: section

      .. rubric:: Why adopt Compose
         :name: why-adopt-compose

   .. container:: section

         Jetpack Compose is Android’s modern toolkit for building
         native UI. It simplifies and accelerates UI development on
         Android bringing your apps to life with less code, powerful
         tools, and intuitive Kotlin APIs. It makes building Android UI
         faster and easier. While creating Compose we worked with
         different partners who experienced all of these benefits first
         hand and shared some of their takeaways with us.

   .. container:: section

      .. rubric:: Less code
         :name: less-code


         Writing less code affects all stages of development: as an
         author, you get to focus on the problem at hand, with less to
         test and debug and with less chances of bugs; as a reviewer or
         maintainer you have less code to read, understand, review and
         maintain.

         Compose allows you to do more with less code, compared to
         using the Android View system: Buttons, lists or animation -
         whatever you need to build, now there’s less code to write.
         Here’s what some of our partners say:

         -  “\ *For the same Button class it [the code] was 10x of
            magnitude smaller.*\ ” (Twitter)
         -  “\ *There’s also a significant reduction for any screen
            built with a RecyclerView, which the majority of our
            screens are.*\ ” (Monzo)
         -  “\ *We were very pleased to see how few lines were required
            to create lists or animations in our app. We’re writing
            fewer lines of code per-feature, which allows us to focus
            more on delivering value to our customers.*\ ” (Cuvva)

         The code you’re writing is written only in Kotlin, rather than
         having it split between Kotlin and XML: “\ *It’s much easier
         to trace through code when it’s all written in the same
         language and often the same file, rather than jumping back and
         forth between Kotlin and XML*\ ” (Monzo)

         Code written with Compose is simple and easy to maintain
         whatever you’re building. “\ *The layout system of Compose is
         conceptually simpler so it’s easier to reason about. Reading
         the code for complicated components is easier as well.*\ ”
         (Square)

   .. container:: section

      .. rubric:: Intuitive
         :name: intuitive

         Compose uses a declarative API, which means that all you need
         to do is describe your UI - Compose takes care of the rest.
         The APIs are intuitive - easy to discover and use: “\ *Our
         theming layer is vastly more intuitive and legible. We've been
         able to accomplish within a single Kotlin file what otherwise
         extended across multiple XML files that were responsible for
         attribute definitions and assignments via multiple layered
         theme overlays.*\ ” (Twitter)

         With Compose, you build small, stateless components that are
         not tied to a specific activity or fragment. That makes them
         easy to reuse and test: “\ *We set a goal for ourselves to
         deliver a new set of UI components that were stateless, easy
         to use and maintain, and intuitive to
         implement/extend/customize. Compose really provided a solid
         answer for us in this.*\ ” (Twitter)

         In Compose, state is explicit and passed to the composable.
         That way there’s one single source of truth for the state,
         making it encapsulated and decoupled. Then, as app state
         changes, your UI automatically updates. “\ *There’s less to
         hold in your head while you’re reasoning about something and
         less behavior that is outside of your control or poorly
         understood*\ ” (Cuvva)

   .. container:: section

      .. rubric:: Accelerate development
         :name: accelerate-development

         Compose is compatible with all your existing code: you can
         call Compose code from Views and Views from Compose. Most
         common libraries like Navigation, ViewModel and Kotlin
         coroutines work with Compose, so you can start adopting when
         and where you want. “\ *Interoperability was where we started
         integrating Compose, and what we found was it 'just works'. We
         found that we didn’t have to think about things like light and
         dark mode, and the whole experience was incredibly
         seamless.*\ ” (Cuvva)

         Using the full Android Studio support, with features like live
         previews, you get to iterate and ship code faster:
         “\ *Previews in Android Studio have been a big time saver.
         Being able to build out multiple previews also saves us time.
         Often we need to check a UI component in different states or
         with different settings -- like error states, or with a
         different font size, etc. With the ability to create multiple
         previews we can easily check this.*\ ” (Square)

   .. container:: section

      .. rubric:: Powerful
         :name: powerful

         Compose enables you to create beautiful apps with direct
         access to the Android platform APIs and built-in support for
         Material Design, Dark theme, animations, and more: “\ *Compose
         has also solved more than declarative UI -- accessibility
         apis, layout, all kinds of stuff have been improved. There are
         fewer steps between the thing you want to make and actually
         making it*\ ” (Square).

         With Compose, bringing movement and life to your apps through
         animations is quick and easy to implement: “\ *animations are
         so easy to add in Compose that there’s very little reason not
         to animate things like color/size/elevation changes*\ ”
         (Monzo), “\ *you can make animations without requiring
         anything special -- it’s not different than showing a static
         screen*\ ” (Square).

         Whether you’re building with Material Design or your own
         design system, Compose gives you the flexibility to implement
         the design you want: “\ *Having Material Design separated from
         the foundation has been really useful to us as we’re building
         our own design system that often requires differing design
         requirements from Material.*\ ” (Square)

         Check out the in-depth case studies to learn more about how
         `Twitter <https://developer.android.google.cn/stories/apps/twitter-compose>`__,
         `Square <https://developer.android.google.cn/stories/apps/square-compose>`__,
         `Monzo <https://developer.android.google.cn/stories/apps/monzo-compose>`__
         and
         `Cuvva <https://developer.android.google.cn/stories/apps/cuvva-compose>`__
         are using Compose.

Last updated 2024-03-25 UTC.

/Quick start
============

.. https://developer.android.google.cn/develop/ui/compose/setup?hl=en

.. container:: devsite-article-body clearfix

   For the best experience developing with Compose, download and install
   `Android Studio  <https://developer.android.google.cn/studio>`__. It includes many 
   `smart editor features  <#tooling>`__, such as new project templates and
   the ability to immediately preview your Compose UI and animations.

   `Get Android Studio  <https://developer.android.google.cn/studio>`__

   Follow these instructions to create a new Compose app project, set up Compose
   for an existing app project, or import a sample app written in Compose.

   .. rubric:: Create a new app with support for Compose
      :name: create-new

   If you want to start a new project that includes support for Compose by
   default, Android Studio includes various project templates to help you get
   started. To create a new project that has Compose setup correctly, proceed as
   follows:

   #. If you're in the **Welcome to Android Studio** window, click **Start a new
      Android Studio project**. If you already have an Android Studio project
      open , select **File > New > New Project** from the menu bar.
   #. In the **Select a Project Template** window, select **Empty Activity** and
      click **Next**.
   #. In the **Configure your project** window, do the following:

      #. Set the **Name, Package name**, and **Save location** as you normally
         would. Note that, in the **Language** dropdown menu, **Kotlin** is the
         only available option because Jetpack Compose works only with classes
         written in Kotlin.
      #. In the **Minimum API level dropdown** menu, select API level 21 or
         higher.

   #. Click **Finish**.

   Now you're ready to start developing an app using Jetpack Compose. To help
   you get started and learn about what you can do with the toolkit, try the
   `Jetpack Compose tutorial  <#tutorial>`__.

   .. rubric:: Set up Compose for an existing app
      :name: setup-compose

   To start using Compose, you need to first add some build configurations to
   your project. Add the following definition to your app’s ``build.gradle``
   file:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Groovy
            :name: groovy

         .. code:: prettyprint

            android {
                buildFeatures {
                    compose true
                }

                composeOptions {
                    kotlinCompilerExtensionVersion = "1.5.13"
                }
            }

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            android {
                buildFeatures {
                    compose = true
                }

                composeOptions {
                    kotlinCompilerExtensionVersion = "1.5.13"
                }
            }

   Some things to note:

   -  Setting the ``compose`` flag to ``true`` inside the Android
      `BuildFeatures  <#BuildFeatures>`__
      block enables Compose functionality.
   -  Kotlin Compiler extension versioning defined in the
      `ComposeOptions  <#ComposeOptions>`__
      block is tied to Kotlin versioning. Make sure to consult the
      `Compatibility map  <#compose-kotlin>`__ and
      choose a version of the library that matches your project’s Kotlin
      version.

   In addition, add the Compose BOM and the subset of Compose library
   dependencies you need to your dependencies from the block below:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Groovy
            :name: groovy_1

         .. code:: prettyprint

            dependencies {

                def composeBom = platform('androidx.compose:compose-bom:2024.05.00')
                implementation composeBom
                androidTestImplementation composeBom

                // Choose one of the following:
                // Material Design 3
                implementation 'androidx.compose.material3:material3'
                // or Material Design 2
                implementation 'androidx.compose.material:material'
                // or skip Material Design and build directly on top of foundational components
                implementation 'androidx.compose.foundation:foundation'
                // or only import the main APIs for the underlying toolkit systems,
                // such as input and measurement/layout
                implementation 'androidx.compose.ui:ui'

                // Android Studio Preview support
                implementation 'androidx.compose.ui:ui-tooling-preview'
                debugImplementation 'androidx.compose.ui:ui-tooling'

                // UI Tests
                androidTestImplementation 'androidx.compose.ui:ui-test-junit4'
                debugImplementation 'androidx.compose.ui:ui-test-manifest'

                // Optional - Included automatically by material, only add when you need
                // the icons but not the material library (e.g. when using Material3 or a
                // custom design system based on Foundation)
                implementation 'androidx.compose.material:material-icons-core'
                // Optional - Add full set of material icons
                implementation 'androidx.compose.material:material-icons-extended'
                // Optional - Add window size utils
                implementation 'androidx.compose.material3:material3-window-size-class'

                // Optional - Integration with activities
                implementation 'androidx.activity:activity-compose:1.9.0'
                // Optional - Integration with ViewModels
                implementation 'androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1'
                // Optional - Integration with LiveData
                implementation 'androidx.compose.runtime:runtime-livedata'
                // Optional - Integration with RxJava
                implementation 'androidx.compose.runtime:runtime-rxjava2'

            }

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin_1

         .. code:: prettyprint

            dependencies {

                val composeBom = platform("androidx.compose:compose-bom:2024.05.00")
                implementation(composeBom)
                androidTestImplementation(composeBom)

                // Choose one of the following:
                // Material Design 3
                implementation("androidx.compose.material3:material3")
                // or Material Design 2
                implementation("androidx.compose.material:material")
                // or skip Material Design and build directly on top of foundational components
                implementation("androidx.compose.foundation:foundation")
                // or only import the main APIs for the underlying toolkit systems,
                // such as input and measurement/layout
                implementation("androidx.compose.ui:ui")

                // Android Studio Preview support
                implementation("androidx.compose.ui:ui-tooling-preview")
                debugImplementation("androidx.compose.ui:ui-tooling")

                // UI Tests
                androidTestImplementation("androidx.compose.ui:ui-test-junit4")
                debugImplementation("androidx.compose.ui:ui-test-manifest")

                // Optional - Included automatically by material, only add when you need
                // the icons but not the material library (e.g. when using Material3 or a
                // custom design system based on Foundation)
                implementation("androidx.compose.material:material-icons-core")
                // Optional - Add full set of material icons
                implementation("androidx.compose.material:material-icons-extended")
                // Optional - Add window size utils
                implementation("androidx.compose.material3:material3-window-size-class")

                // Optional - Integration with activities
                implementation("androidx.activity:activity-compose:1.9.0")
                // Optional - Integration with ViewModels
                implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1")
                // Optional - Integration with LiveData
                implementation("androidx.compose.runtime:runtime-livedata")
                // Optional - Integration with RxJava
                implementation("androidx.compose.runtime:runtime-rxjava2")

            }

   **Note:**\  Jetpack Compose is shipped using a Bill of Materials (BOM), to
   keep the versions of all library groups in sync. Read more about it in the
   `Bill of Materials page  <#bom>`__.

   .. rubric:: Try Jetpack Compose sample apps
      :name: sample

   The fastest way to experiment with the capabilities of Jetpack Compose is by
   trying `Jetpack Compose sample apps <https://github.com/android/compose-samples>`__ hosted on GitHub. To
   import a sample app project from Android Studio, proceed as follows:

   #. If you're in the **Welcome to Android Studio** window, select **Import an
      Android code sample**. If you already have an Android Studio project open,
      select **File > New > Import Sample** from the menu bar.
   #. In the search bar near the top of the **Browse Samples** wizard, type
      "compose".
   #. Select one of the Jetpack Compose sample apps from the search results and
      click **Next**.
   #. Either change the **Application name** and **Project location** or keep
      the default values.
   #. Click **Finish**.

   Android Studio downloads the sample app to the path you specified and opens
   the project. You can then inspect ``MainActivity.kt`` in each of the examples
   to see Jetpack Compose APIs such as crossfade animation, custom components,
   using typography, and displaying light and dark colors in the in-IDE preview.

   To use Jetpack Compose for Wear OS, see `Set up Jetpack Compose on Wear OS  <#compose-setup>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Navigating with Compose  <#navigation>`__
   -  `Testing your Compose layout  <#testing>`__
   -  `React to focus  <#react-to-focus>`__

Last updated 2024-05-03 UTC.

/Compose Compiler Gradle Plugin
===============================

.. https://developer.android.google.cn/develop/ui/compose/compiler?hl=en

.. container:: devsite-article-body clearfix

   For Gradle users, you can use the Compose Compiler Gradle plugin to make
   setting up and configuring Compose easier.

   **Note:**\  The Compose Compiler Gradle Plugin is only available from Kotlin
   2.0+. For migration instructions, see `"Jetpack Compose compiler moving to the Kotlin repository" <https://android-developers.googleblog.com/2024/04/jetpack-compose-compiler-moving-to-kotlin-repository.html>`__.
   For an example migration, see the `Compose Samples PR <https://github.com/android/compose-samples/pull/1354>`__ in the Compose
   samples.

   .. rubric:: Set up with Gradle version catalogs
      :name: version-catalog

   The following instructions outline how how can set up the Compose Compiler
   Gradle plugin:

   #. In your ``libs.versions.toml`` file, remove any reference to the Compose
      compiler
   #. In the plugins section, add the following new dependency

   .. code:: prettyprint

      [versions]
      kotlin = "2.0.0"

      [plugins]
      org-jetbrains-kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }

      // Add this line
      compose-compiler = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }

   #. In your projects root ``build.gradle.kts`` file, add the following to the
      plugins section:

   .. code:: prettyprint

      plugins {
         // Existing plugins
         alias(libs.plugins.compose.compiler) apply false
      }

   #. In each module that uses Compose, apply the plugin:

   .. code:: prettyprint

      plugins {
         // Existing plugins
         alias(libs.plugins.compose.compiler)
      }

   Your app should now build and compile if you are using the default set up. If
   you had configured custom options on the Compose compiler, see the following
   section.

   .. rubric:: Set up without Gradle version catalogs
      :name: set-gradle

   To set up the Compose Compiler Gradle plugin without version catalogs, add
   the following plugin to ``build.gradle.kts`` files associated with modules
   you use Compose:

   .. code:: prettyprint

      plugins {
          id("org.jetbrains.kotlin.plugin.compose") version "2.0.0" // this version matches your Kotlin version
      }

   .. rubric:: Configuration options with the Compose Compiler Gradle Plugin
      :name: configuration-options

   To configure the Compose compiler using the Gradle plugin, add the
   ``composeCompiler`` block to the module's ``build.gradle.kts`` file at the
   top level.

   .. code:: prettyprint

      android { … }

      composeCompiler {
          enableStrongSkippingMode = true

          reportsDestination = layout.buildDirectory.dir("compose_compiler")
          stabilityConfigurationFile = rootProject.layout.projectDirectory.file("stability_config.conf")
      }

   For the full list of available options, see the
   `documentation <https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-compiler.html#compose-compiler-options-dsl>`__.

Last updated 2024-04-29 UTC.

/Thinking in Compose
====================

.. https://developer.android.google.cn/develop/ui/compose/mental-model?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   Jetpack Compose is a modern declarative UI Toolkit for Android. Compose makes
   it easier to write and maintain your app UI by providing a *declarative API*
   that allows you to render your app UI without imperatively mutating frontend
   views. This terminology needs some explanation, but the implications are
   important for your app design.

   .. rubric:: The declarative programming paradigm
      :name: paradigm

   Historically, an Android view hierarchy has been representable as a tree of
   UI widgets. As the state of the app changes because of things like user
   interactions, the UI hierarchy needs to be updated to display the current
   data. The most common way of updating the UI is to walk the tree using
   functions like
   `findViewById()  <#findViewById>`__, and
   change nodes by calling methods like ``button.setText(String)``,
   ``container.addChild(View)``, or ``img.setImageBitmap(Bitmap)``. These
   methods change the internal state of the widget.

   Manipulating views manually increases the likelihood of errors. If a piece of
   data is rendered in multiple places, it’s easy to forget to update one of the
   views that shows it. It’s also easy to create illegal states, when two
   updates conflict in an unexpected way. For example, an update might try to
   set a value of a node that was just removed from the UI. In general, the
   software maintenance complexity grows with the number of views that require
   updating.

   Over the last several years, the entire industry has started shifting to a
   declarative UI model, which greatly simplifies the engineering associated
   with building and updating user interfaces. The technique works by
   conceptually regenerating the entire screen from scratch, then applying only
   the necessary changes. This approach avoids the complexity of manually
   updating a stateful view hierarchy. Compose is a declarative UI framework.

   One challenge with regenerating the entire screen is that it is potentially
   expensive, in terms of time, computing power, and battery usage. To mitigate
   this cost, Compose intelligently chooses which parts of the UI need to be
   redrawn at any given time. This does have some implications for how you
   design your UI components, as discussed in
   `Recomposition <#recomposition>`__.

   .. rubric:: A simple composable function
      :name: simple-example

   Using Compose, you can build your user interface by defining a set of
   *composable* functions that take in data and emit UI elements. A simple
   example is a ``Greeting`` widget, which takes in a ``String`` and emits a
   ``Text`` widget which displays a greeting message.

   |A screenshot of a phone showing the text|

   **Figure 1.** A simple composable function that is passed data and uses it to
   render a text widget on the screen.

   A few noteworthy things about this function:

   -  The function is annotated with the ``@Composable`` annotation. All
      Composable functions must have this annotation; this annotation informs
      the Compose compiler that this function is intended to convert data into
      UI.

   -  The function takes in data. Composable functions can accept parameters,
      which allow the app logic to describe the UI. In this case, our widget
      accepts a ``String`` so it can greet the user by name.

   -  The function displays text in the UI. It does so by calling the ``Text()``
      composable function, which actually creates the text UI element.
      Composable functions emit UI hierarchy by calling other composable
      functions.

   -  The function doesn't return anything. Compose functions that emit UI do
      not need to return anything, because they describe the desired screen
      state instead of constructing UI widgets.

   -  This function is fast,
      `idempotent <https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning>`__,
      and free of *side-effects*.

      -  The function behaves the same way when called multiple times with the
         same argument, and it does not use other values such as global
         variables or calls to ``random()``.
      -  The function describes the UI without any side-effects, such as
         modifying properties or global variables.

      In general, all composable functions should be written with these
      properties, for reasons discussed in `Recomposition <#recomposition>`__.

   .. rubric:: The declarative paradigm shift
      :name: paradigm

   With many imperative object-oriented UI toolkits, you initialize the UI by
   instantiating a tree of widgets. You often do this by inflating an XML layout
   file. Each widget maintains its own internal state, and exposes getter and
   setter methods that allow the app logic to interact with the widget.

   In Compose's declarative approach, widgets are relatively stateless and do
   not expose setter or getter functions. In fact, widgets are not exposed as
   objects. You update the UI by calling the same composable function with
   different arguments. This makes it easy to provide state to architectural
   patterns such as a
   `ViewModel  <#ViewModel>`__, as described in
   the `Guide to app architecture  <#guide>`__. Then, your composables
   are responsible for transforming the current application state into a UI
   every time the observable data updates.

   |Illustration of the flow of data in a Compose UI, from high-level objects
   down to their children.|

   **Figure 2.** The app logic provides data to the top-level composable
   function. That function uses the data to describe the UI by calling other
   composables, and passes the appropriate data to those composables, and on
   down the hierarchy.

   When the user interacts with the UI, the UI raises events such as
   ``onClick``. Those events should notify the app logic, which can then change
   the app's state. When the state changes, the composable functions are called
   again with the new data. This causes the UI elements to be redrawn--this
   process is called *recomposition*.

   |Illustration of how UI elements respond to interaction, by triggering events
   that are handled by the app logic.|

   **Figure 3.** The user interacted with a UI element, causing an event to be
   triggered. The app logic responds to the event, then the composable functions
   are automatically called again with new parameters, if necessary.

   .. rubric:: Dynamic content
      :name: dynamic

   Because composable functions are written in Kotlin instead of XML, they can
   be as dynamic as any other Kotlin code. For example, suppose you want to
   build a UI that greets a list of users:

   .. code:: prettyprint

      @Composable
      fun Greeting(names: List<String>) {
          for (name in names) {
              Text("Hello $name")
          }
      }ThinkingInComposeSnippets.kt

   This function takes in a list of names and generates a greeting for each
   user. Composable functions can be quite sophisticated. You can use ``if``
   statements to decide if you want to show a particular UI element. You can use
   loops. You can call helper functions. You have the full flexibility of the
   underlying language. This power and flexibility is one of the key advantages
   of Jetpack Compose.

   .. rubric:: Recomposition
      :name: recomposition

   In an imperative UI model, to change a widget, you call a setter on the
   widget to change its internal state. In Compose, you call the composable
   function again with new data. Doing so causes the function to be
   *recomposed*--the widgets emitted by the function are redrawn, if necessary,
   with new data. The Compose framework can intelligently recompose only the
   components that changed.

   For example, consider this composable function which displays a button:

   .. code:: prettyprint

      @Composable
      fun ClickCounter(clicks: Int, onClick: () -> Unit) {
          Button(onClick = onClick) {
              Text("I've been clicked $clicks times")
          }
      }ThinkingInComposeSnippets.kt

   Every time the button is clicked, the caller updates the value of ``clicks``.
   Compose calls the lambda with the ``Text`` function again to show the new
   value; this process is called *recomposition*. Other functions that don't
   depend on the value are not recomposed.

   As we discussed, recomposing the entire UI tree can be computationally
   expensive, which uses computing power and battery life. Compose solves this
   problem with this *intelligent recomposition*.

   Recomposition is the process of calling your composable functions again when
   inputs change. This happens when the function's inputs change. When Compose
   recomposes based on new inputs, it only calls the functions or lambdas that
   might have changed, and skips the rest. By skipping all functions or lambdas
   that don't have changed parameters, Compose can recompose efficiently.

   Never depend on side-effects from executing composable functions, since a
   function's recomposition may be skipped. If you do, users may experience
   strange and unpredictable behavior in your app. A side-effect is any change
   that is visible to the rest of your app. For example, these actions are all
   dangerous side-effects:

   -  Writing to a property of a shared object
   -  Updating an observable in ``ViewModel``
   -  Updating shared preferences

   Composable functions might be re-executed as often as every frame, such as
   when an animation is being rendered. Composable functions should be fast to
   avoid jank during animations. If you need to do expensive operations, such as
   reading from shared preferences, do it in a background coroutine and pass the
   value result to the composable function as a parameter.

   As an example, this code creates a composable to update a value in
   ``SharedPreferences``. The composable shouldn't read or write from shared
   preferences itself. Instead, this code moves the read and write to a
   ``ViewModel`` in a background coroutine. The app logic passes the current
   value with a callback to trigger an update.

   .. code:: prettyprint

      @Composable
      fun SharedPrefsToggle(
          text: String,
          value: Boolean,
          onValueChanged: (Boolean) -> Unit
      ) {
          Row {
              Text(text)
              Checkbox(checked = value, onCheckedChange = onValueChanged)
          }
      }ThinkingInComposeSnippets.kt

   This document discusses a number of things to be aware of when you use
   Compose:

   -  Composable functions can execute in any order.
   -  Composable functions can execute in parallel.
   -  Recomposition skips as many composable functions and lambdas as possible.
   -  Recomposition is optimistic and may be canceled.
   -  A composable function might be run quite frequently, as often as every
      frame of an animation.

   The following sections will cover how to build composable functions to
   support recomposition. In every case, the best practice is to keep your
   composable functions fast, idempotent, and side-effect free.

   .. rubric:: Composable functions can execute in any order
      :name: any-order

   If you look at the code for a composable function, you might assume that the
   code is run in the order it appears. But this isn't necessarily true. If a
   composable function contains calls to other composable functions, those
   functions might run in any order. Compose has the option of recognizing that
   some UI elements are higher priority than others, and drawing them first.

   For example, suppose you have code like this to draw three screens in a tab
   layout:

   .. code:: prettyprint

      @Composable
      fun ButtonRow() {
          MyFancyNavigation {
              StartScreen()
              MiddleScreen()
              EndScreen()
          }
      }ThinkingInComposeSnippets.kt

   The calls to ``StartScreen``, ``MiddleScreen``, and ``EndScreen`` might
   happen in any order. This means you can't, for example, have
   ``StartScreen()`` set some global variable (a side-effect) and have
   ``MiddleScreen()`` take advantage of that change. Instead, each of those
   functions needs to be self-contained.

   .. rubric:: Composable functions can run in parallel
      :name: parallel

   Compose can optimize recomposition by running composable functions in
   parallel. This lets Compose take advantage of multiple cores, and run
   composable functions not on the screen at a lower priority.

   This optimization means a composable function might execute within a pool of
   background threads. If a composable function calls a function on a
   ``ViewModel``, Compose might call that function from several threads at the
   same time.

   To ensure your application behaves correctly, all composable functions should
   have no side-effects. Instead, trigger side-effects from callbacks such as
   ``onClick`` that always execute on the UI thread.

   When a composable function is invoked, the invocation might occur on a
   different thread from the caller. That means code that modifies variables in
   a composable lambda should be avoided–both because such code is not
   thread-safe, and because it is an impermissible side-effect of the composable
   lambda.

   Here's an example showing a composable that displays a list and its count:

   .. code:: prettyprint

      @Composable
      fun ListComposable(myList: List<String>) {
          Row(horizontalArrangement = Arrangement.SpaceBetween) {
              Column {
                  for (item in myList) {
                      Text("Item: $item")
                  }
              }
              Text("Count: ${myList.size}")
          }
      }ThinkingInComposeSnippets.kt

   This code is side-effect free, and transforms the input list to UI. This is
   great code for displaying a small list. However, if the function writes to a
   local variable, this code will not be thread-safe or correct:

   .. code:: prettyprint

      @Composable
      @Deprecated("Example with bug")
      fun ListWithBug(myList: List<String>) {
          var items = 0

          Row(horizontalArrangement = Arrangement.SpaceBetween) {
              Column {
                  for (item in myList) {
                      Text("Item: $item")
                      items++ // Avoid! Side-effect of the column recomposing.
                  }
              }
              Text("Count: $items")
          }
      }ThinkingInComposeSnippets.kt

   In this example, ``items`` is modified with every recomposition. That could
   be every frame of an animation, or when the list updates. Either way, the UI
   will display the wrong count. Because of this, writes like this are not
   supported in Compose; by prohibiting those writes, we allow the framework to
   change threads to execute composable lambdas.

   .. rubric:: Recomposition skips as much as possible
      :name: skips

   When portions of your UI are invalid, Compose does its best to recompose just
   the portions that need to be updated. This means it may skip to re-run a
   single Button's composable without executing any of the composables above or
   below it in the UI tree.

   Every composable function and lambda might recompose by itself. Here's an
   example that demonstrates how recomposition can skip some elements when
   rendering a list:

   .. code:: prettyprint

      /**
       * Display a list of names the user can click with a header
       */
      @Composable
      fun NamePicker(
          header: String,
          names: List<String>,
          onNameClicked: (String) -> Unit
      ) {
          Column {
              // this will recompose when [header] changes, but not when [names] changes
              Text(header, style = MaterialTheme.typography.bodyLarge)
              Divider()

              // LazyColumn is the Compose version of a RecyclerView.
              // The lambda passed to items() is similar to a RecyclerView.ViewHolder.
              LazyColumn {
                  items(names) { name ->
                      // When an item's [name] updates, the adapter for that item
                      // will recompose. This will not recompose when [header] changes
                      NamePickerItem(name, onNameClicked)
                  }
              }
          }
      }

      /**
       * Display a single name the user can click.
       */
      @Composable
      private fun NamePickerItem(name: String, onClicked: (String) -> Unit) {
          Text(name, Modifier.clickable(onClick = { onClicked(name) }))
      }ThinkingInComposeSnippets.kt

   Each of these scopes might be the only thing to execute during a
   recomposition. Compose might skip to the ``Column`` lambda without executing
   any of its parents when the ``header`` changes. And when executing
   ``Column``, Compose might choose to skip the ``LazyColumn``'s items if
   ``names`` didn't change.

   Again, executing all composable functions or lambdas should be side-effect
   free. When you need to perform a side-effect, trigger it from a callback.

   .. rubric:: Recomposition is optimistic
      :name: optimistic

   Recomposition starts whenever Compose thinks that the parameters of a
   composable might have changed. Recomposition is *optimistic,* which means
   Compose expects to finish recomposition before the parameters change again.
   If a parameter *does* change before recomposition finishes, Compose might
   cancel the recomposition and restart it with the new parameter.

   When recomposition is canceled, Compose discards the UI tree from the
   recomposition. If you have any side-effects that depend on the UI being
   displayed, the side-effect will be applied even if composition is canceled.
   This can lead to inconsistent app state.

   Ensure that all composable functions and lambdas are idempotent and
   side-effect free to handle optimistic recomposition.

   .. rubric:: Composable functions might run quite frequently
      :name: frequent

   In some cases, a composable function might run for every frame of a UI
   animation. If the function performs expensive operations, like reading from
   device storage, the function can cause UI jank.

   For example, if your widget tried to read device settings, it could
   potentially read those settings hundreds of times a second, with disastrous
   effects on your app's performance.

   If your composable function needs data, it should define parameters for the
   data. You can then move expensive work to another thread, outside of
   composition, and pass the data to Compose using ``mutableStateOf`` or
   ``LiveData``.

   .. rubric:: Learn more
      :name: learn_more

   To learn more about how to think in Compose and composable functions, check
   out the following additional resources.

   .. rubric:: Videos
      :name: videos

   -  `Composable functions - MAD Skills <https://www.youtube.com/watch?v=fFLBCgoHHys>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Kotlin for Jetpack Compose  <#kotlin>`__
   -  `State and Jetpack Compose  <#state>`__
   -  `Jetpack Compose architectural layering  <#layering>`__

Last updated 2024-05-03 UTC.

.. |A screenshot of a phone showing the text| image:: https://developer.android.google.cn/static/develop/ui/compose/images/mmodel-simple.png
   :width: 500px
.. |Illustration of the flow of data in a Compose UI, from high-level objects down to their children.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/mmodel-flow-data.png
   :width: 500px
.. |Illustration of how UI elements respond to interaction, by triggering events that are handled by the app logic.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/mmodel-flow-events.png
   :width: 500px

/Using the Bill of Materials
============================

.. https://developer.android.google.cn/develop/ui/compose/bom?hl=en

.. container:: devsite-article-body clearfix

   The Compose Bill of Materials (BOM) lets you manage all of your Compose
   library versions by specifying only the BOM’s version. The BOM itself has
   links to the stable versions of the different Compose libraries, in such a
   way that they work well together. When using the BOM in your app, you don't
   need to add any version to the Compose library dependencies themselves. When
   you update the BOM version, all the libraries that you're using are
   automatically updated to their new versions.

   To find out which Compose library versions are mapped to a specific BOM
   version, check out the `BOM to library version mapping  <#bom-mapping>`__.

   .. rubric:: Why isn't the Compose Compiler library included in the BOM?
      :name: why_isnt_the_compose_compiler_library_included_in_the_bom

   The Compose Kotlin compiler extension (androidx.compose.compiler) is not
   linked to the Compose library versions. Instead, it is linked to versions of
   the Kotlin compiler plugin and released in a separate cadence from the rest
   of Compose, so make sure to use a version that is compatible with your
   version of Kotlin. You can find the Kotlin version that maps to each version
   of the plugin at `Compose to Kotlin Compatibility Map  <#compose-kotlin>`__.

   .. rubric:: How do I use a different library version than what's designated
      in the BOM?
      :name: how_do_i_use_a_different_library_version_than_whats_designated_in_the_bom

   In the ``build.gradle`` dependencies section, keep the import of the BOM
   platform. On the library dependency import, specify the desired version. For
   example, here's how to declare dependencies if you want to use an alpha
   version of Material 3, no matter what version is designated in the BOM:

   .. code:: prettyprint

      dependencies {
          // Import the Compose BOM
          implementation platform('androidx.compose:compose-bom:2024.05.00')

          // Import Material Design 3 library
          implementation 'androidx.compose.material3:material3:1.2.1'

          // Import other Compose libraries without version numbers
          // ..
          implementation 'androidx.compose.foundation:foundation'
      }

   **Note:**\  Overriding the BOM to use an alpha version of a Compose library
   will update your build to use the required dependencies of that alpha library
   (which in turn, could be alpha).

   .. rubric:: Does the BOM automatically add all the Compose libraries to my
      app?
      :name: does_the_bom_automatically_add_all_the_compose_libraries_to_my_app

   No. To actually add and use Compose libraries in your app, you must declare
   each library as a separate dependency line in your module (app-level) Gradle
   file (usually app/build.gradle).

   Using the BOM ensures that the versions of any Compose libraries in your app
   are compatible, but the BOM doesn't actually add those Compose libraries to
   your app.

   .. rubric:: Why is the BOM the recommended way to manage Compose library
      versions?
      :name: why_is_the_bom_the_recommended_way_to_manage_compose_library_versions

   Going forward, Compose libraries will be versioned independently, which means
   version numbers will start to be incremented at their own pace. The latest
   stable releases of each library are tested and guaranteed to work nicely
   together. However, finding the latest stable versions of each library can be
   difficult, and the BOM helps you to automatically use these latest versions.

   .. rubric:: Am I forced to use the BOM?
      :name: am_i_forced_to_use_the_bom

   No. You can still choose to add each dependency version manually. However, we
   recommend using the BOM as it will make it easier to use all of the latest
   stable versions at the same time.

   .. rubric:: Does the BOM work with version catalogs?
      :name: does_the_bom_work_with_version_catalogs

   Yes. You can include the BOM itself in the version catalog, and omit the
   other Compose library versions:

   .. code:: prettyprint

      [libraries]
      androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "androidxComposeBom" }
      androidx-compose-foundation = { group = "androidx.compose.foundation", name = "foundation" }

   Don’t forget to import the BOM in your module’s ``build.gradle``:

   .. code:: prettyprint

      dependencies {
          val composeBom = platform(libs.androidx.compose.bom)
          implementation(composeBom)
          androidTestImplementation(composeBom)

          // import Compose dependencies as usual
      }

   .. rubric:: How do I report an issue or offer feedback on the BOM?
      :name: how_do_i_report_an_issue_or_offer_feedback_on_the_bom

   You can file issues on our `issue tracker <https://issuetracker.google.com/issues/new?component=612128&template=1253476>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Material Design 3 in Compose  <#material3>`__
   -  `ConstraintLayout in Compose  <#constraintlayout>`__
   -  `Resources in Compose  <#resources>`__

Last updated 2024-05-03 UTC.

/BOM to library version mapping
===============================

.. https://developer.android.google.cn/develop/ui/compose/bom/bom-mapping?hl=en

.. container:: devsite-article-body clearfix

   .. container::

      Versions: 2024.05.00 2024.04.01 2024.04.00 2024.03.00 2024.02.02
      2024.02.01 2024.02.00 2024.01.00 2023.10.01 2023.10.00 2023.09.02
      2023.09.01 2023.09.00 2023.08.00 2023.06.01 2023.06.00 2023.05.01
      2023.05.00 2023.04.01 2023.04.00 2023.03.00 2023.01.00 2022.12.00
      2022.11.00 2022.10.00

   .. container:: 2024.05.00

      =======================================================  ============
      Library group                                            BOM Versions
      =======================================================  ============
      androidx.compose.animation:animation                     1.6.7
      androidx.compose.animation:animation-core                1.6.7
      androidx.compose.animation:animation-graphics            1.6.7
      androidx.compose.foundation:foundation                   1.6.7
      androidx.compose.foundation:foundation-layout            1.6.7
      androidx.compose.material:material                       1.6.7
      androidx.compose.material:material-icons-core            1.6.7
      androidx.compose.material:material-icons-extended        1.6.7
      androidx.compose.material:material-ripple                1.6.7
      androidx.compose.material3:material3                     1.2.1
      androidx.compose.material3:material3-window-size-class   1.2.1
      androidx.compose.runtime:runtime                         1.6.7
      androidx.compose.runtime:runtime-livedata                1.6.7
      androidx.compose.runtime:runtime-rxjava2                 1.6.7
      androidx.compose.runtime:runtime-rxjava3                 1.6.7
      androidx.compose.runtime:runtime-saveable                1.6.7
      androidx.compose.ui:ui                                   1.6.7
      androidx.compose.ui:ui-geometry                          1.6.7
      androidx.compose.ui:ui-graphics                          1.6.7
      androidx.compose.ui:ui-test                              1.6.7
      androidx.compose.ui:ui-test-junit4                       1.6.7
      androidx.compose.ui:ui-test-manifest                     1.6.7
      androidx.compose.ui:ui-text                              1.6.7
      androidx.compose.ui:ui-text-google-fonts                 1.6.7
      androidx.compose.ui:ui-tooling                           1.6.7
      androidx.compose.ui:ui-tooling-data                      1.6.7
      androidx.compose.ui:ui-tooling-preview                   1.6.7
      androidx.compose.ui:ui-unit                              1.6.7
      androidx.compose.ui:ui-util                              1.6.7
      androidx.compose.ui:ui-viewbinding                       1.6.7
      =======================================================  ============

   .. container:: 2023.01.00

      =======================================================  ============
      Library group                                            BOM Versions
      =======================================================  ============
      androidx.compose.animation:animation                     1.3.3
      androidx.compose.animation:animation-core                1.3.3
      androidx.compose.animation:animation-graphics            1.3.3
      androidx.compose.foundation:foundation                   1.3.3
      androidx.compose.foundation:foundation-layout            1.3.3
      androidx.compose.material:material                       1.3.3
      androidx.compose.material:material-icons-core            1.3.3
      androidx.compose.material:material-icons-extended        1.3.3
      androidx.compose.material:material-ripple                1.3.3
      androidx.compose.material3:material3                     1.0.1
      androidx.compose.material3:material3-window-size-class   1.0.1
      androidx.compose.runtime:runtime                         1.3.3
      androidx.compose.runtime:runtime-livedata                1.3.3
      androidx.compose.runtime:runtime-rxjava2                 1.3.3
      androidx.compose.runtime:runtime-rxjava3                 1.3.3
      androidx.compose.runtime:runtime-saveable                1.3.3
      androidx.compose.ui:ui                                   1.3.3
      androidx.compose.ui:ui-geometry                          1.3.3
      androidx.compose.ui:ui-graphics                          1.3.3
      androidx.compose.ui:ui-test                              1.3.3
      androidx.compose.ui:ui-test-junit4                       1.3.3
      androidx.compose.ui:ui-test-manifest                     1.3.3
      androidx.compose.ui:ui-text                              1.3.3
      androidx.compose.ui:ui-text-google-fonts                 1.3.3
      androidx.compose.ui:ui-tooling                           1.3.3
      androidx.compose.ui:ui-tooling-data                      1.3.3
      androidx.compose.ui:ui-tooling-preview                   1.3.3
      androidx.compose.ui:ui-unit                              1.3.3
      androidx.compose.ui:ui-util                              1.3.3
      androidx.compose.ui:ui-viewbinding                       1.3.3
      =======================================================  ============

Last updated 2024-05-03 UTC.

/Lifecycle
==========

.. https://developer.android.google.cn/develop/ui/compose/lifecycle?hl=en

.. container:: devsite-article-body clearfix

   In this page, you'll learn about the lifecycle of a composable and how
   Compose decides whether a composable needs recomposition.

   .. rubric:: Lifecycle overview
      :name: lifecycle-overview

   As mentioned in the `Managing state documentation  <#state>`__, a Composition describes the UI
   of your app and is produced by running composables. A Composition is a
   tree-structure of the composables that describe your UI.

   When Jetpack Compose runs your composables for the first time, during
   *initial composition*, it will keep track of the composables that you call to
   describe your UI in a Composition. Then, when the state of your app changes,
   Jetpack Compose schedules a *recomposition*. Recomposition is when Jetpack
   Compose re-executes the composables that may have changed in response to
   state changes, and then updates the Composition to reflect any changes.

   A Composition can only be produced by an initial composition and updated by
   recomposition. The only way to modify a Composition is through recomposition.

   **Key Point:**\  The lifecycle of a composable is defined by the following
   events: entering the Composition, getting recomposed 0 or more times, and
   leaving the Composition.
   |Diagram showing the lifecycle of a composable|

   **Figure 1.** Lifecycle of a composable in the Composition. It enters the
   Composition, gets recomposed 0 or more times, and leaves the Composition.

   Recomposition is typically triggered by a change to a
   `State<T>  <#State>`__ object.
   Compose tracks these and runs all composables in the Composition that read
   that particular ``State<T>``, and any composables that they call that cannot
   be `skipped <#skipping>`__.

   **Note:**\  A composable's lifecycle is simpler than the lifecycle of views,
   activities, and fragments. When a composable needs to manage or interact with
   external resources that *do* have a more complex lifecycle, you should use
   `effects <#state-effect-use-cases>`__.
   If a composable is called multiple times, multiple instances are placed in
   the Composition. Each call has its own lifecycle in the Composition.

   .. code:: prettyprint

      @Composable
      fun MyComposable() {
          Column {
              Text("Hello")
              Text("World")
          }
      }LifecycleSnippets.kt

   |Diagram showing the hierarchical arrangement of the elements in the previous
   code snippet|

   **Figure 2.** Representation of ``MyComposable`` in the Composition. If a
   composable is called multiple times, multiple instances are placed in the
   Composition. An element having a different color is indicative of it being a
   separate instance.

   .. rubric:: Anatomy of a composable in Composition
      :name: composition-anatomy

   The instance of a composable in Composition is identified by its **call
   site**. The Compose compiler considers each call site as distinct. Calling
   composables from multiple call sites will create multiple instances of the
   composable in Composition.

   **Key Term:**\  The **call site** is the *source code location* in which a
   composable is called. This influences its place in Composition, and
   therefore, the UI tree.
   If during a recomposition a composable calls different composables than it
   did during the previous composition, Compose will **identify which
   composables were called or not called** and for the composables that were
   called in both compositions, Compose will **avoid recomposing them if their
   inputs haven't changed**.

   Preserving identity is crucial to associate side effects with their
   composable, so that they can complete successfully rather than restart for
   every recomposition.

   Consider the following example:

   .. code:: prettyprint

      @Composable
      fun LoginScreen(showError: Boolean) {
          if (showError) {
              LoginError()
          }
          LoginInput() // This call site affects where LoginInput is placed in Composition
      }

      @Composable
      fun LoginInput() { /* ... */ }

      @Composable
      fun LoginError() { /* ... */ }LifecycleSnippets.kt

   In the code snippet above, ``LoginScreen`` will conditionally call the
   ``LoginError`` composable and will always call the ``LoginInput`` composable.
   Each call has a unique call site and source position, which the compiler will
   use to uniquely identify it.

   |Diagram showing how the preceding code is recomposed if the showError flag
   is changed to true. The LoginError composable is added, but the other
   composables are not recomposed.|

   **Figure 3.** Representation of ``LoginScreen`` in the Composition when the
   state changes and a recomposition occurs. Same color means it hasn't been
   recomposed.

   Even though ``LoginInput`` went from being called first to being called
   second, the ``LoginInput`` instance will be preserved across recompositions.
   Additionally, because ``LoginInput`` doesn’t have any parameters that have
   changed across recomposition, the call to ``LoginInput`` will be skipped by
   Compose.

   .. rubric:: Add extra information to help smart recompositions
      :name: add-info-smart-recomposition

   Calling a composable multiple times will add it to Composition multiple times
   as well. When calling a composable multiple times from the same call site,
   Compose doesn’t have any information to uniquely identify each call to that
   composable, so the execution order is used in addition to the call site in
   order to keep the instances distinct. This behavior is sometimes all that is
   needed, but in some cases it can cause unwanted behavior.

   .. code:: prettyprint

      @Composable
      fun MoviesScreen(movies: List<Movie>) {
          Column {
              for (movie in movies) {
                  // MovieOverview composables are placed in Composition given its
                  // index position in the for loop
                  MovieOverview(movie)
              }
          }
      }LifecycleSnippets.kt

   In the example above, Compose uses the execution order in addition to the
   call site to keep the instance distinct in the Composition. If a new
   ``movie`` is added to the *bottom* of the list, Compose can reuse the
   instances already in the Composition since their location in the list haven't
   changed and therefore, the ``movie`` input is the same for those instances.

   |Diagram showing how the preceding code is recomposed if a new element is
   added to the bottom of the list. The other items in the list have not changed
   position, and are not recomposed.|

   **Figure 4.** Representation of ``MoviesScreen`` in the Composition when a
   new element is added to the bottom of the list. ``MovieOverview`` composables
   in the Composition can be reused. Same color in ``MovieOverview`` means the
   composable hasn't been recomposed.

   However, if the ``movies`` list changes by either adding to the *top* or the
   *middle* of the list, removing or reordering items, it'll cause a
   recomposition in all ``MovieOverview`` calls whose input parameter has
   changed position in the list. That's extremely important if, for example,
   ``MovieOverview`` fetches a movie image using a side effect. If recomposition
   happens while the effect is in progress, it will be cancelled and will start
   again.

   .. code:: prettyprint

      @Composable
      fun MovieOverview(movie: Movie) {
          Column {
              // Side effect explained later in the docs. If MovieOverview
              // recomposes, while fetching the image is in progress,
              // it is cancelled and restarted.
              val image = loadNetworkImage(movie.url)
              MovieHeader(image)

              /* ... */
          }
      }
      LifecycleSnippets.kt

   |Diagram showing how the preceding code is recomposed if a new element is
   added to the top of the list. Every other item in the list changes position
   and has to be recomposed.|

   **Figure 5.** Representation of ``MoviesScreen`` in the Composition when a
   new element is added to the list. ``MovieOverview`` composables cannot be
   reused and all side effects will restart. A different color in
   ``MovieOverview`` means the composable has been recomposed.

   Ideally, we want to think of the identity of the ``MovieOverview`` instance
   as linked to the identity of the ``movie`` that is passed to it. If we
   reorder the list of movies, ideally we would similarly reorder the instances
   in the Composition tree instead of recomposing each ``MovieOverview``
   composable with a different movie instance. Compose provides a way for you to
   tell the runtime what values you want to use to identify a given part of the
   tree: the
   `key  <#key>`__
   composable.

   By wrapping a block of code with a call to the key composable with one or
   more values passed in, those values will be combined to be used to identify
   that instance in the composition. The value for a ``key`` does not need to be
   *globally* unique, it needs to only be unique amongst the invocations of
   composables at the call site. So in this example, each ``movie`` needs to
   have a ``key`` that's unique among the ``movies``; it's fine if it shares
   that ``key`` with some other composable elsewhere in the app.

   .. code:: prettyprint

      @Composable
      fun MoviesScreenWithKey(movies: List<Movie>) {
          Column {
              for (movie in movies) {
                  key(movie.id) { // Unique ID for this movie
                      MovieOverview(movie)
                  }
              }
          }
      }LifecycleSnippets.kt

   With the above, even if the elements on the list change, Compose recognizes
   individual calls to ``MovieOverview`` and can reuse them.

   |Diagram showing how the preceding code is recomposed if a new element is
   added to the top of the list. Because the list items are identified by keys,
   Compose knows not to recompose them, even though their positions have
   changed.|

   **Figure 6.** Representation of ``MoviesScreen`` in the Composition when a
   new element is added to the list. Since the ``MovieOverview`` composables
   have unique keys, Compose recognizes which ``MovieOverview`` instances
   haven't changed, and can reuse them; their side effects will continue
   executing.

   **Key Point:**\  Use the ``key`` composable to help Compose identify
   composable instances in Composition. It's important when multiple composables
   are called from the same call site and contain side-effects or internal
   state.
   Some composables have built-in support for the ``key`` composable. For
   example, ``LazyColumn`` accepts specifying a custom ``key`` in the ``items``
   DSL.

   .. code:: prettyprint

      @Composable
      fun MoviesScreenLazy(movies: List<Movie>) {
          LazyColumn {
              items(movies, key = { movie -> movie.id }) { movie ->
                  MovieOverview(movie)
              }
          }
      }LifecycleSnippets.kt

   .. rubric:: Skipping if the inputs haven't changed
      :name: skipping

   During recomposition, some eligible composable functions can have their
   execution be skipped entirely if their inputs have not changed from the
   previous composition.

   A composable function is eligible for skipping *unless*:

   -  The function has a non-``Unit`` return type
   -  The function is annotated with ``@NonRestartableComposable`` or
      ``@NonSkippableComposable``
   -  A required parameter is of a non-stable type

   There is an experimental compiler mode, `Strong Skipping <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/compose/compiler/design/strong-skipping.md>`__,
   which relaxes the last requirement.

   In order for a type to be considered stable it must comply with the following
   contract:

   -  The result of ``equals`` for two instances will *forever* be the same for
      the same two instances.
   -  If a public property of the type changes, Composition will be notified.
   -  All public property types are also stable.

   There are some important common types that fall into this contract that the
   Compose compiler will treat as stable, even though they are not explicitly
   marked as stable by using the ``@Stable`` annotation:

   -  All primitive value types: ``Boolean``, ``Int``, ``Long``, ``Float``,
      ``Char``, etc.
   -  Strings
   -  All function types (lambdas)

   All of these types are able to follow the contract of stable because they are
   immutable. Since immutable types never change, they never have to notify
   Composition of the change, so it is much easier to follow this contract.

   **Note:**\  All deeply immutable types can safely be considered stable types.
   One notable type that is stable but *is* mutable is Compose’s
   ``MutableState`` type. If a value is held in a ``MutableState``, the state
   object overall is considered to be stable as Compose will be notified of any
   changes to the ``.value`` property of ``State``.

   When all types passed as parameters to a composable are stable, the parameter
   values are compared for equality based on the composable position in the UI
   tree. Recomposition is skipped if all the values are unchanged since the
   previous call.

   **Key Point:**\  Compose skips the recomposition of a composable if all the
   inputs are stable and haven't changed. The comparison uses the ``equals``
   method.
   Compose considers a type stable only if it can prove it. For example, an
   interface is generally treated as not stable, and types with mutable public
   properties whose implementation could be immutable are not stable either.

   If Compose is not able to infer that a type is stable, but you want to force
   Compose to treat it as stable, mark it with the
   `@Stable  <#Stable>`__
   annotation.

   .. code:: prettyprint

      // Marking the type as stable to favor skipping and smart recompositions.
      @Stable
      interface UiState<T : Result<T>> {
          val value: T?
          val exception: Throwable?

          val hasError: Boolean
              get() = exception != null
      }LifecycleSnippets.kt

   In the code snippet above, since ``UiState`` is an interface, Compose could
   ordinarily consider this type to be not stable. By adding the ``@Stable``
   annotation, you tell Compose that this type is stable, allowing Compose to
   favor smart recompositions. This also means that Compose will treat all its
   implementations as stable if the interface is used as the parameter type.

   **Key Point:**\  If Compose is not able to infer the stability of a type,
   annotate the type with ``@Stable`` to allow Compose to favor smart
   recompositions.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `State and Jetpack Compose  <#state>`__
   -  `Side-effects in Compose  <#side-effects>`__
   -  `Save UI state in Compose  <#state-saving>`__

Last updated 2024-05-03 UTC.

.. |Diagram showing the lifecycle of a composable| image:: https://developer.android.google.cn/static/develop/ui/compose/images/lifecycle-composition.png
   :width: 500px
.. |Diagram showing the hierarchical arrangement of the elements in the previous code snippet| image:: https://developer.android.google.cn/static/develop/ui/compose/images/lifecycle-hierarchy.png
   :width: 500px
.. |Diagram showing how the preceding code is recomposed if the showError flag is changed to true. The LoginError composable is added, but the other composables are not recomposed.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/lifecycle-showerror.png
.. |Diagram showing how the preceding code is recomposed if a new element is added to the bottom of the list. The other items in the list have not changed position, and are not recomposed.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/lifecycle-newelement-bottom.png
.. |Diagram showing how the preceding code is recomposed if a new element is added to the top of the list. Every other item in the list changes position and has to be recomposed.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/lifecycle-newelement-top-all-recompose.png
.. |Diagram showing how the preceding code is recomposed if a new element is added to the top of the list. Because the list items are identified by keys, Compose knows not to recompose them, even though their positions have changed.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/lifecycle-newelement-top-keys.png

/Side-effects
=============

.. https://developer.android.google.cn/develop/ui/compose/side-effects?hl=en

.. container:: devsite-article-body clearfix

   A **side-effect** is a change to the state of the app that happens outside
   the scope of a composable function. Due to composables' lifecycle and
   properties such as unpredictable recompositions, executing recompositions of
   composables in different orders, or recompositions that can be discarded,
   composables `should ideally be side-effect free  <#mental-model>`__.

   However, sometimes side-effects are necessary, for example, to trigger a
   one-off event such as showing a snackbar or navigate to another screen given
   a certain state condition. These actions should be called from a controlled
   environment that is aware of the lifecycle of the composable. In this page,
   you'll learn about the different side-effect APIs Jetpack Compose offers.

   .. rubric:: State and effect use cases
      :name: state-effect-use-cases

   As covered in the `Thinking in Compose  <#mental-model>`__
   documentation, composables should be side-effect free. When you need to make
   changes to the state of the app (as described in the `Managing state documentation  <#state>`__ doc), **you should use the
   Effect APIs so that those side effects are executed in a predictable
   manner**.

   **Key Term:**\  An **effect** is a composable function that doesn't emit UI
   and causes side effects to run when a composition completes.
   Due to the different possibilities effects open up in Compose, they can be
   easily overused. Make sure that the work you do in them is UI related and
   doesn't break **unidirectional data flow** as explained in the `Managing state documentation  <#unidirectional-data-flow-in-jetpack-compose>`__.

   **Note:**\  A responsive UI is inherently asynchronous, and Jetpack Compose
   solves this by embracing coroutines at the API level instead of using
   callbacks. To learn more about coroutines, check out the `Kotlin coroutines on Android  <#coroutines>`__ guide.

   .. rubric:: ``LaunchedEffect``: run suspend functions in the scope of a
      composable
      :name: launchedeffect

   To call suspend functions safely from inside a composable, use the
   `LaunchedEffect  <#LaunchedEffect>`__
   composable. When ``LaunchedEffect`` enters the Composition, it launches a
   coroutine with the block of code passed as a parameter. The coroutine will be
   cancelled if ``LaunchedEffect`` leaves the composition. If ``LaunchedEffect``
   is recomposed with different keys (see the `Restarting Effects <#restarting-effects>`__ section below), the existing coroutine will
   be cancelled and the new suspend function will be launched in a new
   coroutine.

   For example, showing a
   `Snackbar <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Snackbar(androidx.compose.material3.SnackbarData,androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color)>`__
   in a
   `Scaffold <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Scaffold(androidx.compose.ui.Modifier,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,androidx.compose.material3.FabPosition,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.foundation.layout.WindowInsets,kotlin.Function1)>`__
   is done with the
   `SnackbarHostState.showSnackbar  <#SnackbarHostState>`__
   function, which is a suspend function.

   .. code:: prettyprint

      @Composable
      fun MyScreen(
          state: UiState<List<Movie>>,
          snackbarHostState: SnackbarHostState
      ) {

          // If the UI state contains an error, show snackbar
          if (state.hasError) {

              // `LaunchedEffect` will cancel and re-launch if
              // `scaffoldState.snackbarHostState` changes
              LaunchedEffect(snackbarHostState) {
                  // Show snackbar using a coroutine, when the coroutine is cancelled the
                  // snackbar will automatically dismiss. This coroutine will cancel whenever
                  // `state.hasError` is false, and only start when `state.hasError` is true
                  // (due to the above if-check), or if `scaffoldState.snackbarHostState` changes.
                  snackbarHostState.showSnackbar(
                      message = "Error message",
                      actionLabel = "Retry message"
                  )
              }
          }

          Scaffold(
              snackbarHost = {
                  SnackbarHost(hostState = snackbarHostState)
              }
          ) { contentPadding ->
              // ...
          }
      }SideEffectsSnippets.kt

   In the code above, a coroutine is triggered if the state contains an error
   and it'll be cancelled when it doesn't. As the ``LaunchedEffect`` call site
   is inside an if statement, when the statement is false, if ``LaunchedEffect``
   was in the Composition, it'll be removed, and therefore, the coroutine will
   be cancelled.

   .. rubric:: ``rememberCoroutineScope``: obtain a composition-aware scope to
      launch a coroutine outside a composable
      :name: remembercoroutinescope

   As ``LaunchedEffect`` is a composable function, it can only be used inside
   other composable functions. In order to launch a coroutine outside of a
   composable, but scoped so that it will be automatically canceled once it
   leaves the composition, use
   `rememberCoroutineScope  <#rememberCoroutineScope>`__.
   Also use ``rememberCoroutineScope`` whenever you need to control the
   lifecycle of one or more coroutines manually, for example, cancelling an
   animation when a user event happens.

   ``rememberCoroutineScope`` is a composable function that returns a
   ``CoroutineScope`` bound to the point of the Composition where it's called.
   The scope will be cancelled when the call leaves the Composition.

   Following the previous example, you could use this code to show a
   ``Snackbar`` when the user taps on a ``Button``:

   .. code:: prettyprint

      @Composable
      fun MoviesScreen(snackbarHostState: SnackbarHostState) {

          // Creates a CoroutineScope bound to the MoviesScreen's lifecycle
          val scope = rememberCoroutineScope()

          Scaffold(
              snackbarHost = {
                  SnackbarHost(hostState = snackbarHostState)
              }
          ) { contentPadding ->
              Column(Modifier.padding(contentPadding)) {
                  Button(
                      onClick = {
                          // Create a new coroutine in the event handler to show a snackbar
                          scope.launch {
                              snackbarHostState.showSnackbar("Something happened!")
                          }
                      }
                  ) {
                      Text("Press me")
                  }
              }
          }
      }SideEffectsSnippets.kt

   .. rubric:: ``rememberUpdatedState``: reference a value in an effect that
      shouldn't restart if the value changes
      :name: rememberupdatedstate

   ``LaunchedEffect`` restarts when one of the key parameters changes. However,
   in some situations you might want to capture a value in your effect that, if
   it changes, you do not want the effect to restart. In order to do this, it is
   required to use ``rememberUpdatedState`` to create a reference to this value
   which can be captured and updated. This approach is helpful for effects that
   contain long-lived operations that may be expensive or prohibitive to
   recreate and restart.

   For example, suppose your app has a ``LandingScreen`` that disappears after
   some time. Even if ``LandingScreen`` is recomposed, the effect that waits for
   some time and notifies that the time passed shouldn't be restarted:

   .. code:: prettyprint

      @Composable
      fun LandingScreen(onTimeout: () -> Unit) {

          // This will always refer to the latest onTimeout function that
          // LandingScreen was recomposed with
          val currentOnTimeout by rememberUpdatedState(onTimeout)

          // Create an effect that matches the lifecycle of LandingScreen.
          // If LandingScreen recomposes, the delay shouldn't start again.
          LaunchedEffect(true) {
              delay(SplashWaitTimeMillis)
              currentOnTimeout()
          }

          /* Landing screen content */
      }SideEffectsSnippets.kt

   To create an effect that matches the lifecycle of the call site, a
   never-changing constant like ``Unit`` or ``true`` is passed as a parameter.
   In the code above, ``LaunchedEffect(true)`` is used. To make sure that the
   ``onTimeout`` lambda *always* contains the latest value that
   ``LandingScreen`` was recomposed with, ``onTimeout`` needs to be wrapped with
   the ``rememberUpdatedState`` function. The returned ``State``,
   ``currentOnTimeout`` in the code, should be used in the effect.

   **Warning:**\  ``LaunchedEffect(true)`` is as suspicious as a
   ``while(true)``. Even though there are valid use cases for it, *always* pause
   and make sure that's what you need.

   .. rubric:: ``DisposableEffect``: effects that require cleanup
      :name: disposableeffect

   For side effects that need to be *cleaned up* after the keys change or if the
   composable leaves the Composition, use
   `DisposableEffect  <#DisposableEffect>`__.
   If the ``DisposableEffect`` keys change, the composable needs to *dispose*
   (do the cleanup for) its current effect, and reset by calling the effect
   again.

   As an example, you might want to send analytics events based on
   `Lifecycle events  <#lc>`__ by
   using a
   `LifecycleObserver  <#LifecycleObserver>`__.
   To listen for those events in Compose, use a ``DisposableEffect`` to register
   and unregister the observer when needed.

   .. code:: prettyprint

      @Composable
      fun HomeScreen(
          lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
          onStart: () -> Unit, // Send the 'started' analytics event
          onStop: () -> Unit // Send the 'stopped' analytics event
      ) {
          // Safely update the current lambdas when a new one is provided
          val currentOnStart by rememberUpdatedState(onStart)
          val currentOnStop by rememberUpdatedState(onStop)

          // If `lifecycleOwner` changes, dispose and reset the effect
          DisposableEffect(lifecycleOwner) {
              // Create an observer that triggers our remembered callbacks
              // for sending analytics events
              val observer = LifecycleEventObserver { _, event ->
                  if (event == Lifecycle.Event.ON_START) {
                      currentOnStart()
                  } else if (event == Lifecycle.Event.ON_STOP) {
                      currentOnStop()
                  }
              }

              // Add the observer to the lifecycle
              lifecycleOwner.lifecycle.addObserver(observer)

              // When the effect leaves the Composition, remove the observer
              onDispose {
                  lifecycleOwner.lifecycle.removeObserver(observer)
              }
          }

          /* Home screen content */
      }SideEffectsSnippets.kt

   In the code above, the effect will add the ``observer`` to the
   ``lifecycleOwner``. If ``lifecycleOwner`` changes, the effect is disposed and
   restarted with the new ``lifecycleOwner``.

   A ``DisposableEffect`` must include an ``onDispose`` clause as the final
   statement in its block of code. Otherwise, the IDE displays a build-time
   error.

   **Note:**\  Having an empty block in ``onDispose`` is not a good practice.
   Always reconsider to see if there's an effect that fits your use case better.

   .. rubric:: ``SideEffect``: publish Compose state to non-Compose code
      :name: sideeffect-publish

   To share Compose state with objects not managed by compose, use the
   `SideEffect  <#SideEffect>`__
   composable. Using a ``SideEffect`` guarantees that the effect executes after
   every successful recomposition. On the other hand, it is incorrect to perform
   an effect before a successful recomposition is guaranteed, which is the case
   when writing the effect directly in a composable.

   For example, your analytics library might allow you to segment your user
   population by attaching custom metadata ("user properties" in this example)
   to all subsequent analytics events. To communicate the user type of the
   current user to your analytics library, use ``SideEffect`` to update its
   value.

   .. code:: prettyprint

      @Composable
      fun rememberFirebaseAnalytics(user: User): FirebaseAnalytics {
          val analytics: FirebaseAnalytics = remember {
              FirebaseAnalytics()
          }

          // On every successful composition, update FirebaseAnalytics with
          // the userType from the current User, ensuring that future analytics
          // events have this metadata attached
          SideEffect {
              analytics.setUserProperty("userType", user.userType)
          }
          return analytics
      }SideEffectsSnippets.kt

   .. rubric:: ``produceState``: convert non-Compose state into Compose state
      :name: producestate

   `produceState  <#produceState>`__
   launches a coroutine scoped to the Composition that can push values into a
   returned `State  <#State>`__.
   Use it to convert non-Compose state into Compose state, for example bringing
   external subscription-driven state such as ``Flow``, ``LiveData``, or
   ``RxJava`` into the Composition.

   The producer is launched when ``produceState`` enters the Composition, and
   will be cancelled when it leaves the Composition. The returned ``State``
   conflates; setting the same value won't trigger a recomposition.

   Even though ``produceState`` creates a coroutine, it can also be used to
   observe non-suspending sources of data. To remove the subscription to that
   source, use the
   `awaitDispose  <#awaitDispose>`__
   function.

   The following example shows how to use ``produceState`` to load an image from
   the network. The ``loadNetworkImage`` composable function returns a ``State``
   that can be used in other composables.

   .. code:: prettyprint

      @Composable
      fun loadNetworkImage(
          url: String,
          imageRepository: ImageRepository = ImageRepository()
      ): State<Result<Image>> {

          // Creates a State<T> with Result.Loading as initial value
          // If either `url` or `imageRepository` changes, the running producer
          // will cancel and will be re-launched with the new inputs.
          return produceState<Result<Image>>(initialValue = Result.Loading, url, imageRepository) {

              // In a coroutine, can make suspend calls
              val image = imageRepository.load(url)

              // Update State with either an Error or Success result.
              // This will trigger a recomposition where this State is read
              value = if (image == null) {
                  Result.Error
              } else {
                  Result.Success(image)
              }
          }
      }SideEffectsSnippets.kt

   **Note:**\  Composables with a return type should be named the way you'd name
   a normal Kotlin function, starting with a lowercase letter.
   **Key Point:** Under the hood, ``produceState`` makes use of other effects!
   It holds a ``result`` variable using
   ``remember { mutableStateOf(initialValue) }``, and triggers the ``producer``
   block in a ``LaunchedEffect``. Whenever ``value`` is updated in the
   ``producer`` block, the ``result`` state is updated to the new value.

   You can easily create your own effects building on top of the existing APIs.

   .. rubric:: ``derivedStateOf``: convert one or multiple state objects into
      another state
      :name: derivedstateof

   In Compose,
   `recomposition  <#recomposition>`__ occurs
   each time an observed state object or composable input changes. A state
   object or input may be changing more often than the UI actually needs to
   update, leading to unnecessary recomposition.

   You should use the
   `derivedStateOf  <#derivedStateOf>`__
   function when your inputs to a composable are changing more often than you
   need to recompose. This often occurs when something is frequently changing,
   such as a scroll position, but the composable only needs to react to it once
   it crosses a certain threshold. ``derivedStateOf`` creates a new Compose
   state object you can observe that only updates as much as you need. In this
   way, it acts similarly to the Kotlin Flows
   `distinctUntilChanged() <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html#:%7E:text=Returns%20flow%20where%20all%20subsequent,a%20StateFlow%20has%20no%20effect.>`__
   operator.

   **Caution:**\  ``derivedStateOf`` is expensive, and you should only use it to
   avoid unnecessary recomposition when a result hasn't changed.

   .. rubric:: Correct usage
      :name: correct-usage

   The following snippet shows an appropriate use case for ``derivedStateOf``:

   .. code:: prettyprint

      @Composable
      // When the messages parameter changes, the MessageList
      // composable recomposes. derivedStateOf does not
      // affect this recomposition.
      fun MessageList(messages: List<Message>) {
          Box {
              val listState = rememberLazyListState()

              LazyColumn(state = listState) {
                  // ...
              }

              // Show the button if the first visible item is past
              // the first item. We use a remembered derived state to
              // minimize unnecessary compositions
              val showButton by remember {
                  derivedStateOf {
                      listState.firstVisibleItemIndex > 0
                  }
              }

              AnimatedVisibility(visible = showButton) {
                  ScrollToTopButton()
              }
          }
      }SideEffectsSnippets.kt

   In this snippet, ``firstVisibleItemIndex`` changes any time the first visible
   item changes. As you scroll, the value becomes ``0``, ``1``, ``2``, ``3``,
   ``4``, ``5``, etc. However, recomposition only needs to occur if the value is
   greater than ``0``. This mismatch in update frequency means that this is a
   good use case for ``derivedStateOf``.

   .. rubric:: Incorrect usage
      :name: incorrect-usage

   A common mistake is to assume that, when you combine two Compose state
   objects, you should use ``derivedStateOf`` because you are "deriving state".
   However, this is purely overhead and not required, as shown in the following
   snippet:

   **Warning:**\  The following snippet shows an incorrect usage of
   ``derivedStateOf``. Do not use this code in your project.
   .. code:: prettyprint

      // DO NOT USE. Incorrect usage of derivedStateOf.
      var firstName by remember { mutableStateOf("") }
      var lastName by remember { mutableStateOf("") }

      val fullNameBad by remember { derivedStateOf { "$firstName $lastName" } } // This is bad!!!
      val fullNameCorrect = "$firstName $lastName" // This is correctSideEffectsSnippets.kt

   In this snippet, ``fullName`` needs to update just as often as ``firstName``
   and ``lastName``. Therefore, no excess recomposition is occurring, and using
   ``derivedStateOf`` is not necessary.

   .. rubric:: ``snapshotFlow``: convert Compose's State into Flows
      :name: snapshotFlow

   Use
   `snapshotFlow  <#snapshotFlow>`__
   to convert
   `State<T>  <#State>`__ objects
   into a cold Flow. ``snapshotFlow`` runs its block when collected and emits
   the result of the ``State`` objects read in it. When one of the ``State``
   objects read inside the ``snapshotFlow`` block mutates, the Flow will emit
   the new value to its collector if the new value is not `equal to <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html>`__
   the previous emitted value (this behavior is similar to that of
   `Flow.distinctUntilChanged <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html>`__).

   The following example shows a side effect that records when the user scrolls
   past the first item in a list to analytics:

   .. code:: prettyprint

      val listState = rememberLazyListState()

      LazyColumn(state = listState) {
          // ...
      }

      LaunchedEffect(listState) {
          snapshotFlow { listState.firstVisibleItemIndex }
              .map { index -> index > 0 }
              .distinctUntilChanged()
              .filter { it == true }
              .collect {
                  MyAnalyticsService.sendScrolledPastFirstItemEvent()
              }
      }

   In the code above, ``listState.firstVisibleItemIndex`` is converted to a Flow
   that can benefit from the power of Flow's operators.

   .. rubric:: Restarting effects
      :name: restarting-effects

   Some effects in Compose, like ``LaunchedEffect``, ``produceState``, or
   ``DisposableEffect``, take a variable number of arguments, keys, that are
   used to cancel the running effect and start a new one with the new keys.

   The typical form for these APIs is:

   .. code:: prettyprint

      EffectName(restartIfThisKeyChanges, orThisKey, orThisKey, ...) { block }

   Due to the subtleties of this behavior, problems can occur if the parameters
   used to restart the effect are not the right ones:

   -  Restarting effects less than they should could cause bugs in your app.
   -  Restarting effects more than they should could be inefficient.

   As a rule of thumb, mutable and immutable variables used in the effect block
   of code should be added as parameters to the effect composable. Apart from
   those, more parameters can be added to force restarting the effect. If the
   change of a variable shouldn't cause the effect to restart, the variable
   should be wrapped in `rememberUpdatedState <#rememberupdatedstate>`__. If
   the variable never changes because it's wrapped in a ``remember`` with no
   keys, you don't need to pass the variable as a key to the effect.

   **Key Point:**\  Variables used in an effect should be added as a parameter
   of the effect composable, or use ``rememberUpdatedState``.
   In the ``DisposableEffect`` code shown above, the effect takes as a parameter
   the ``lifecycleOwner`` used in its block, because any change to them should
   cause the effect to restart.

   .. code:: prettyprint

      @Composable
      fun HomeScreen(
          lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
          onStart: () -> Unit, // Send the 'started' analytics event
          onStop: () -> Unit // Send the 'stopped' analytics event
      ) {
          // These values never change in Composition
          val currentOnStart by rememberUpdatedState(onStart)
          val currentOnStop by rememberUpdatedState(onStop)

          DisposableEffect(lifecycleOwner) {
              val observer = LifecycleEventObserver { _, event ->
                  /* ... */
              }

              lifecycleOwner.lifecycle.addObserver(observer)
              onDispose {
                  lifecycleOwner.lifecycle.removeObserver(observer)
              }
          }
      }

   ``currentOnStart`` and ``currentOnStop`` are not needed as
   ``DisposableEffect`` keys, because their value never change in Composition
   due to the usage of ``rememberUpdatedState``. If you don't pass
   ``lifecycleOwner`` as a parameter and it changes, ``HomeScreen`` recomposes,
   but the ``DisposableEffect`` isn't disposed of and restarted. That causes
   problems because the wrong ``lifecycleOwner`` is used from that point onward.

   .. rubric:: Constants as keys
      :name: constants-as-keys

   You can use a constant like ``true`` as an effect key to make it **follow the
   lifecycle of the call site**. There are valid use cases for it, like the
   ``LaunchedEffect`` example shown above. However, before doing that, think
   twice and make sure that's what you need.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `State and Jetpack Compose  <#state>`__
   -  `Kotlin for Jetpack Compose  <#kotlin>`__
   -  `Using Views in Compose  <#views-in-compose>`__

Last updated 2024-05-03 UTC.

/Phases
=======

.. https://developer.android.google.cn/develop/ui/compose/phases?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   Like most other UI toolkits, Compose renders a frame through several distinct
   *phases*. If we look at the Android View system, it has three main phases:
   measure, layout, and drawing. Compose is very similar but has an important
   additional phase called *composition* at the start.

   Composition is described across our Compose docs, including `Thinking in Compose  <#mental-model>`__ and `State and Jetpack Compose  <#state>`__.

   .. rubric:: The three phases of a frame
      :name: 3-phases

   Compose has three main phases:

   #. **Composition**: *What* UI to show. Compose runs composable functions and
      creates a description of your UI.
   #. **Layout**: *Where* to place UI. This phase consists of two steps:
      measurement and placement. Layout elements measure and place themselves
      and any child elements in 2D coordinates, for each node in the layout
      tree.
   #. **Drawing**: *How* it renders. UI elements draw into a Canvas, usually a
      device screen.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/compose-phases.png
      name: image-1
      :alt: An image of the three phases in which Compose transforms data into
      UI (in order, data, composition, layout, drawing, UI).
      :width: 100.0%

      **Figure 1.** The three phases in which Compose transforms data into UI.

   The order of these phases is generally the same, allowing data to flow in one
   direction from composition to layout to drawing to produce a frame (also
   known as `unidirectional data flow  <#udf>`__).
   `BoxWithConstraints  <#constraints>`__
   and `LazyColumn and ``LazyRow``  <#lazy>`__ are
   notable exceptions, where the composition of its children depends on the
   parent's layout phase.

   You can safely assume that these three phases happen virtually for every
   frame, but for the sake of performance, Compose avoids repeating work that
   would compute the same results from the same inputs in all of these phases.
   Compose `skips  <#skips>`__ running a
   composable function if it can reuse a former result, and Compose UI doesn't
   re-layout or re-draw the entire tree if it doesn't have to. Compose performs
   only the minimum amount of work required to update the UI. This optimization
   is possible because Compose tracks state reads within the different phases.

   .. rubric:: Understand the phases
      :name: understand-phases

   This section describes how the three Compose phases are executed for
   composables in greater detail.

   .. rubric:: Composition
      :name: composition

   In the composition phase, the Compose runtime executes composable functions
   and outputs a tree structure that represents your UI. This UI tree consists
   of layout nodes that contain all the information needed for the next phases,
   as shown in the following video:

   **Figure 2.** The tree representing your UI that is created in the
   composition phase.

   A subsection of the code and UI tree looks like the following:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/code-subsection.png
      name: image-3
      :alt: A code snippet with five composables and the resulting UI tree, with
      child nodes branching from their parent nodes.
      :width: 60.0%

      **Figure 3.** A subsection of a UI tree with the corresponding code.

   In these examples, each composable function in the code maps to a single
   layout node in the UI tree. In more complex examples, composables can contain
   logic and control flow, and produce a different tree given different states.

   .. rubric:: Layout
      :name: layout

   In the layout phase, Compose uses the UI tree produced in the composition
   phase as input. The collection of layout nodes contain all the information
   needed to decide on each node's size and location in 2D space.

   **Figure 4.** The measurement and placement of each layout node in the UI
   tree during the layout phase.

   During the layout phase, the tree is traversed using the following three step
   algorithm:

   #. **Measure children**: A node measures its children if any exist.
   #. **Decide own size**: Based on these measurements, a node decides on its
      own size.
   #. **Place children**: Each child node is placed relative to a node's own
      position.

   At the end of this phase, each layout node has:

   -  An assigned **width** and **height**
   -  An **x, y coordinate** where it should be drawn

   Recall the UI tree from the previous section:

   |A code snippet with five composables and the resulting UI tree, with child
   nodes branching from their parent nodes|

   For this tree, the algorithm works as follows:

   #. The ``Row`` measures its children, ``Image`` and ``Column``.
   #. The ``Image`` is measured. It doesn't have any children, so it decides its
      own size and reports the size back to the ``Row``.
   #. The ``Column`` is measured next. It measures its own children (two
      ``Text`` composables) first.
   #. The first ``Text`` is measured. It doesn't have any children so it decides
      its own size and reports its size back to the ``Column``.

      #. The second ``Text`` is measured. It doesn't have any children so it
         decides its own size and reports it back to the ``Column``.

   #. The ``Column`` uses the child measurements to decide its own size. It uses
      the maximum child width and the sum of the height of its children.
   #. The ``Column`` places its children relative to itself, putting them
      beneath each other vertically.
   #. The ``Row`` uses the child measurements to decide its own size. It uses
      the maximum child height and the sum of the widths of its children. It
      then places its children.

   Note that each node was visited only once. The Compose runtime requires only
   one pass through the UI tree to measure and place all the nodes, which
   improves performance. When the number of nodes in the tree increases, the
   time spent traversing it increases in a linear fashion. In contrast, if each
   node was visited multiple times, the traversal time increases exponentially.

   .. rubric:: Drawing
      :name: drawing

   In the drawing phase, the tree is traversed again from top to bottom, and
   each node draws itself on the screen in turn.

   **Figure 5.** The drawing phase draws the pixels on the screen.

   Using the previous example, the tree content is drawn in the following way:

   #. The ``Row`` draws any content it might have, such as a background color.
   #. The ``Image`` draws itself.
   #. The ``Column`` draws itself.
   #. The first and second ``Text`` draw themselves, respectively.

   **Figure 6.** A UI tree and its drawn representation.

   .. rubric:: State reads
      :name: state-reads

   When you read the value of a `snapshot state  <#state>`__
   during one of the phases listed above, Compose automatically tracks what it
   was doing when the value was read. This tracking allows Compose to re-execute
   the reader when the state value changes, and is the basis of state
   observability in Compose.

   State is commonly created using ``mutableStateOf()`` and then accessed
   through one of two ways: by directly accessing the ``value`` property, or
   alternatively by using a Kotlin property delegate. You can read more about
   them in `State in composables  <#state-in-composables>`__. For the
   purposes of this guide, a "state read" refers to either of those equivalent
   access methods.

   .. code:: prettyprint

      // State read without property delegate.
      val paddingState: MutableState<Dp> = remember { mutableStateOf(8.dp) }
      Text(
          text = "Hello",
          modifier = Modifier.padding(paddingState.value)
      )PhasesSnippets.kt

   .. code:: prettyprint

      // State read with property delegate.
      var padding: Dp by remember { mutableStateOf(8.dp) }
      Text(
          text = "Hello",
          modifier = Modifier.padding(padding)
      )PhasesSnippets.kt

   Under the hood of the `property delegate <https://kotlinlang.org/docs/delegated-properties.html>`__, "getter"
   and "setter" functions are used to access and update the State’s ``value``.
   These getter and setter functions are only invoked when you reference the
   property as a value, and not when it is created, which is why the two ways
   above are equivalent.

   Each block of code that can be re-executed when a read state changes is a
   *restart scope*. Compose keeps track of state value changes and restart
   scopes in different phases.

   .. rubric:: Phased state reads
      :name: phased-state-reads

   As mentioned above, there are three main phases in Compose, and Compose
   tracks what state is read within each of them. This allows Compose to notify
   only the specific phases that need to perform work for each affected element
   of your UI.

   **Note:**\  Where a state instance is created and stored has little bearing
   on the phases, it only matters when and where a state value is **read**.
   Let's go through each phase and describe what happens when a state value is
   read within it.

   .. rubric:: Phase 1: Composition
      :name: phase1-comp

   State reads within a ``@Composable`` function or lambda block affect
   composition and potentially the subsequent phases. When the state value
   changes, the recomposer schedules reruns of all the composable functions
   which read that state value. Note that the runtime may decide to skip some or
   all of the composable functions if the inputs haven't changed. See `Skipping if the inputs haven't changed  <#skipping>`__ for
   more information.

   Depending on the result of composition, Compose UI runs the layout and
   drawing phases. It might skip these phases if the content remains the same
   and the size and the layout won't change.

   .. code:: prettyprint

      var padding by remember { mutableStateOf(8.dp) }
      Text(
          text = "Hello",
          // The `padding` state is read in the composition phase
          // when the modifier is constructed.
          // Changes in `padding` will invoke recomposition.
          modifier = Modifier.padding(padding)
      )PhasesSnippets.kt

   .. rubric:: Phase 2: Layout
      :name: phase2-layout

   The layout phase consists of two steps: *measurement* and *placement*. The
   measurement step runs the measure lambda passed to the ``Layout`` composable,
   the ``MeasureScope.measure`` method of the ``LayoutModifier`` interface, and
   so on. The placement step runs the placement block of the ``layout``
   function, the lambda block of ``Modifier.offset { … }``, and so on.

   State reads during each of these steps affect the layout and potentially the
   drawing phase. When the state value changes, Compose UI schedules the layout
   phase. It also runs the drawing phase if size or position has changed.

   To be more precise, the measurement step and the placement step have separate
   restart scopes, meaning that state reads in the placement step don't
   re-invoke the measurement step before that. However, these two steps are
   often intertwined, so a state read in the placement step can affect other
   restart scopes that belong to the measurement step.

   .. code:: prettyprint

      var offsetX by remember { mutableStateOf(8.dp) }
      Text(
          text = "Hello",
          modifier = Modifier.offset {
              // The `offsetX` state is read in the placement step
              // of the layout phase when the offset is calculated.
              // Changes in `offsetX` restart the layout.
              IntOffset(offsetX.roundToPx(), 0)
          }
      )PhasesSnippets.kt

   .. rubric:: Phase 3: Drawing
      :name: phase3-drawing

   State reads during drawing code affect the drawing phase. Common examples
   include ``Canvas()``, ``Modifier.drawBehind``, and
   ``Modifier.drawWithContent``. When the state value changes, Compose UI runs
   only the draw phase.

   .. code:: prettyprint

      var color by remember { mutableStateOf(Color.Red) }
      Canvas(modifier = modifier) {
          // The `color` state is read in the drawing phase
          // when the canvas is rendered.
          // Changes in `color` restart the drawing.
          drawRect(color)
      }PhasesSnippets.kt

   |image-phases-state-read-draw|

   .. rubric:: Optimizing state reads
      :name: optimizing-state-reads

   As Compose performs localized state read tracking, we can minimize the amount
   of work performed by reading each state in an appropriate phase.

   Let’s take a look at an example. Here we have an ``Image()`` which uses the
   offset modifier to offset its final layout position, resulting in a parallax
   effect as the user scrolls.

   .. code:: prettyprint

      Box {
          val listState = rememberLazyListState()

          Image(
              // ...
              // Non-optimal implementation!
              Modifier.offset(
                  with(LocalDensity.current) {
                      // State read of firstVisibleItemScrollOffset in composition
                      (listState.firstVisibleItemScrollOffset / 2).toDp()
                  }
              )
          )

          LazyColumn(state = listState) {
              // ...
          }
      }PhasesSnippets.kt

   This code works, but results in nonoptimal performance. As written, the code
   reads the value of the ``firstVisibleItemScrollOffset`` state and passes it
   to the
   `Modifier.offset(offset: Dp)  <#offset>`__
   function. As the user scrolls the ``firstVisibleItemScrollOffset`` value will
   change. As we know, Compose tracks any state reads so that it can restart
   (re-invoke) the reading code, which in our example is the content of the
   ``Box``.

   This is an example of state being read within the **composition** phase. This
   is not necessarily a bad thing at all, and in fact is the basis of
   recomposition, allowing data changes to emit new UI.

   In this example though it is nonoptimal, because every scroll event will
   result in the entire composable content being reevaluated, and then also
   measured, laid out and finally drawn. We’re triggering the Compose phase on
   every scroll even though **what** we are showing hasn’t changed, only
   **where** it is shown. We can optimize our state read to only re-trigger the
   layout phase.

   There is another version of the offset modifier available:
   `Modifier.offset(offset: Density.() -> IntOffset)  <#offset>`__.

   This version takes a lambda parameter, where the resulting offset is returned
   by the lambda block. Let’s update our code to use it:

   .. code:: prettyprint

      Box {
          val listState = rememberLazyListState()

          Image(
              // ...
              Modifier.offset {
                  // State read of firstVisibleItemScrollOffset in Layout
                  IntOffset(x = 0, y = listState.firstVisibleItemScrollOffset / 2)
              }
          )

          LazyColumn(state = listState) {
              // ...
          }
      }PhasesSnippets.kt

   So why is this more performant? The lambda block we provide to the modifier
   is invoked during the **layout** phase (specifically, during the layout
   phase's placement step), meaning that our ``firstVisibleItemScrollOffset``
   state is no longer read during composition. Because Compose tracks when state
   is read, this change means that if the ``firstVisibleItemScrollOffset`` value
   changes, Compose only has to restart the layout and drawing phases.

   **Note:**\  You might wonder if taking a lambda parameter might add extra
   cost compared to taking a simple value. It does. However, the benefit of
   limiting the state read to the layout phase overweighs the cost in this case.
   The value of ``firstVisibleItemScrollOffset`` changes every frame during
   scroll, and by deferring the state read to the layout phase, we can avoid
   recompositions all along.
   This example relies on the different offset modifiers to be able to optimize
   the resulting code, but the general idea is true: try to localize state reads
   to the lowest possible phase, enabling Compose to perform the minimum amount
   of work.

   Of course, it is often absolutely necessary to read states in the composition
   phase. Even so, there are cases where we can minimize the number of
   recompositions by filtering state changes. For more information about this,
   see `derivedStateOf: convert one or multiple state objects into another state  <#derivedstateof>`__.

   .. rubric:: Recomposition loop (cyclic phase dependency)
      :name: recomp-loop

   Earlier we mentioned that the phases of Compose are always invoked in the
   same order, and that there is no way to go backwards while in the same frame.
   However, that doesn’t prohibit apps getting into composition loops across
   *different* frames. Consider this example:

   .. code:: prettyprint

      Box {
          var imageHeightPx by remember { mutableStateOf(0) }

          Image(
              painter = painterResource(R.drawable.rectangle),
              contentDescription = "I'm above the text",
              modifier = Modifier
                  .fillMaxWidth()
                  .onSizeChanged { size ->
                      // Don't do this
                      imageHeightPx = size.height
                  }
          )

          Text(
              text = "I'm below the image",
              modifier = Modifier.padding(
                  top = with(LocalDensity.current) { imageHeightPx.toDp() }
              )
          )
      }PhasesSnippets.kt

   Here we have (badly) implemented a vertical column, with the image at the
   top, and then the text below it. We’re using ``Modifier.onSizeChanged()`` to
   know the resolved size of the image, and then using ``Modifier.padding()`` on
   the text to shift it down. The unnatural conversion from ``Px`` back to
   ``Dp`` already indicates that the code has some issue.

   The issue with this example is that we don’t arrive at the "final" layout
   within a single frame. The code relies on multiple frames happening, which
   performs unnecessary work, and results in UI jumping around on screen for the
   user.

   Let’s step through each frame to see what is happening:

   At the composition phase of the first frame, ``imageHeightPx`` has a value of
   0, and the text is provided with ``Modifier.padding(top = 0)``. Then, the
   layout phase follows, and the callback for the ``onSizeChanged`` modifier is
   called. This is when the ``imageHeightPx`` is updated to the actual height of
   the image. Compose schedules recomposition for the next frame. At the drawing
   phase, the text is rendered with the padding of 0 since the value change is
   not reflected yet.

   Compose then starts the second frame scheduled by the value change of
   ``imageHeightPx``. The state is read in the Box content block, and it is
   invoked in the composition phase. This time, the text is provided with a
   padding matching the image height. At the layout phase, the code does set the
   value of ``imageHeightPx`` again, but no recomposition is scheduled since the
   value remains the same.

   In the end, we get the desired padding on the text, but it is nonoptimal to
   spend an extra frame to pass the padding value back to a different phase and
   will result in producing a frame with overlapping content.

   |image-phases-recomp-loop|

   This example may seem contrived, but be careful of this general pattern:

   -  ``Modifier.onSizeChanged()``, ``onGloballyPositioned()``, or some other
      layout operations
   -  Update some state
   -  Use that state as input to a layout modifier
      (``padding()``,\ ``height()``, or similar)
   -  Potentially repeat

   The fix for the sample above is to use the proper layout primitives. The
   example above can be implemented with a simple ``Column()``, but you may have
   a more complex example which requires something custom, which will require
   writing a custom layout. See the `Custom layouts  <#custom>`__ guide for more information.

   The general principle here is to have a single source of truth for multiple
   UI elements that should be measured and placed with regards to one another.
   Using a proper layout primitive or creating a custom layout means that the
   minimal shared parent serves as the source of truth that can coordinate the
   relation between multiple elements. Introducing a dynamic state breaks this
   principle.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `State and Jetpack Compose  <#state>`__
   -  `Lists and grids  <#lists>`__
   -  `Kotlin for Jetpack Compose  <#kotlin>`__

Last updated 2024-03-25 UTC.

.. |A code snippet with five composables and the resulting UI tree, with child nodes branching from their parent nodes| image:: https://developer.android.google.cn/static/develop/ui/compose/images/code-subsection.png
   :width: 60.0%
.. |image-phases-state-read-draw| image:: https://developer.android.google.cn/static/develop/ui/compose/images/phases-state-read-draw.svg
.. |image-phases-recomp-loop| image:: https://developer.android.google.cn/static/develop/ui/compose/images/phases-recomp-loop.svg

/Overview: Managing state
=========================

.. https://developer.android.google.cn/develop/ui/compose/state?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   State in an app is any value that can change over time. This is a very broad
   definition and encompasses everything from a Room database to a variable in a
   class.

   All Android apps display state to the user. A few examples of state in
   Android apps:

   -  A Snackbar that shows when a network connection can't be established.
   -  A blog post and associated comments.
   -  Ripple animations on buttons that play when a user clicks them.
   -  Stickers that a user can draw on top of an image.

   Jetpack Compose helps you be explicit about where and how you store and use
   state in an Android app. This guide focuses on the connection between state
   and composables, and on the APIs that Jetpack Compose offers to work with
   state more easily.

   .. rubric:: State and composition
      :name: state-and-composition

   Compose is declarative and as such the only way to update it is by calling
   the same composable with new arguments. These arguments are representations
   of the UI state. Any time a state is updated a *recomposition* takes place.
   As a result, things like ``TextField`` don’t automatically update like they
   do in imperative XML based views. A composable has to explicitly be told the
   new state in order for it to update accordingly.

   .. code:: prettyprint

      @Composable
      private fun HelloContent() {
          Column(modifier = Modifier.padding(16.dp)) {
              Text(
                  text = "Hello!",
                  modifier = Modifier.padding(bottom = 8.dp),
                  style = MaterialTheme.typography.bodyMedium
              )
              OutlinedTextField(
                  value = "",
                  onValueChange = { },
                  label = { Text("Name") }
              )
          }
      }StateOverviewSnippets.kt

   If you run this and try to enter text, you'll see that nothing happens.
   That's because the ``TextField`` doesn't update itself—it updates when its
   ``value`` parameter changes. This is due to how composition and recomposition
   work in Compose.

   **Key Term:** **Composition:** a description of the UI built by Jetpack
   Compose when it executes composables.

   **Initial composition:** creation of a Composition by running composables the
   first time.

   **Recomposition:** re-running composables to update the Composition when data
   changes.

   To learn more about initial composition and recomposition, see `Thinking in Compose  <#mental-model>`__.

   .. rubric:: State in composables
      :name: state-in-composables

   Composable functions can use the
   `remember  <#remember>`__
   API to store an object in memory. A value computed by ``remember`` is stored
   in the Composition during initial composition, and the stored value is
   returned during recomposition. ``remember`` can be used to store both mutable
   and immutable objects.

   **Note:**\  ``remember`` stores objects in the Composition, and forgets the
   object when the composable that called ``remember`` is removed from the
   Composition.
   `mutableStateOf  <#mutableStateOf>`__
   creates an observable
   `MutableState<T>  <#MutableState>`__,
   which is an observable type integrated with the compose runtime.

   .. code:: prettyprint

      interface MutableState<T> : State<T> {
          override var value: T
      }

   Any changes to ``value`` schedules recomposition of any composable functions
   that read ``value``.

   There are three ways to declare a ``MutableState`` object in a composable:

   -  ``val mutableState = remember { mutableStateOf(default) }``
   -  ``var value by remember { mutableStateOf(default) }``
   -  ``val (value, setValue) = remember { mutableStateOf(default) }``

   These declarations are equivalent, and are provided as syntax sugar for
   different uses of state. You should pick the one that produces the
   easiest-to-read code in the composable you're writing.

   The ``by`` delegate syntax requires the following imports:

   .. code:: prettyprint

      import androidx.compose.runtime.getValue
      import androidx.compose.runtime.setValue

   You can use the remembered value as a parameter for other composables or even
   as logic in statements to change which composables are displayed. For
   example, if you don't want to display the greeting if the name is empty, use
   the state in an ``if`` statement:

   .. code:: prettyprint

      @Composable
      fun HelloContent() {
          Column(modifier = Modifier.padding(16.dp)) {
              var name by remember { mutableStateOf("") }
              if (name.isNotEmpty()) {
                  Text(
                      text = "Hello, $name!",
                      modifier = Modifier.padding(bottom = 8.dp),
                      style = MaterialTheme.typography.bodyMedium
                  )
              }
              OutlinedTextField(
                  value = name,
                  onValueChange = { name = it },
                  label = { Text("Name") }
              )
          }
      }StateOverviewSnippets.kt

   While ``remember`` helps you retain state across recompositions, the state is
   not retained across configuration changes. For this, you must use
   ``rememberSaveable``. ``rememberSaveable`` automatically saves any value that
   can be saved in a ``Bundle``. For other values, you can pass in a custom
   saver object.

   **Caution:**\  Using mutable objects such as ``ArrayList<T>`` or
   ``mutableListOf()`` as state in Compose causes your users to see incorrect or
   stale data in your app. Mutable objects that are not observable, such as
   ArrayList or a mutable data class, are not observable by Compose and don't
   trigger a recomposition when they change. Instead of using non-observable
   mutable objects, the recommendation is to use an observable data holder such
   as ``State<List<T>>`` and the immutable ``listOf()``.

   .. rubric:: Other supported types of state
      :name: use-other-types-of-state-in-jetpack-compose

   Compose doesn't require that you use ``MutableState<T>`` to hold state; it
   supports other observable types. Before reading another observable type in
   Compose, you must convert it to a ``State<T>`` so that composables can
   automatically recompose when the state changes.

   Compose ships with functions to create
   `State<T>  <#State>`__ from
   common observable types used in Android apps. Before using these
   integrations, add the appropriate
   `artifact(s)  <#declaring_dependencies>`__
   as outlined below:

   -  `Flow <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html>`__:
      `collectAsStateWithLifecycle()  <#extension-functions>`__

      `collectAsStateWithLifecycle()  <#extension-functions>`__
      collects values from a
      `Flow <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html>`__
      in a lifecycle-aware manner, allowing your app to conserve app resources.
      It represents the latest emitted value from the Compose
      `State  <#State>`__. Use this
      API as the recommended way to collect flows on Android apps.

      **Note:**\  To learn more about collecting flows safely in Android with
      ``collectAsStateWithLifecycle()`` API , you can read `this blog post <https://medium.com/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3>`__.

      The following `dependency  <#lifecycle>`__ is
      required in the ``build.gradle`` file (it should be 2.6.0-beta01 or
      newer):

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            dependencies {
                  ...
                  implementation("androidx.lifecycle:lifecycle-runtime-compose:2.6.2")
            }

      .. container:: section

         .. rubric:: Groovy
            :name: groovy

         .. code:: prettyprint

            dependencies {
                  ...
                  implementation "androidx.lifecycle:lifecycle-runtime-compose:2.6.2"
            }

   -  `Flow <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html>`__:
      `collectAsState()  <#collectAsState>`__

      ``collectAsState`` is similar to ``collectAsStateWithLifecycle``, because
      it also collects values from a ``Flow`` and transforms it into Compose
      `State  <#State>`__.

      Use ``collectAsState`` for platform-agnostic code instead of
      ``collectAsStateWithLifecycle``, which is Android-only.

      Additional dependencies are not required for ``collectAsState``, because
      it is available in ``compose-runtime``.

   -  `LiveData  <#package-summary>`__:
      `observeAsState()  <#observeAsState>`__

      ``observeAsState()`` starts observing this
      `LiveData  <#LiveData>`__ and
      represents its values via
      `State  <#State>`__.

      The following `dependency  <#compose-runtime>`__
      is required in the ``build.gradle`` file:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin_1

         .. code:: prettyprint

            dependencies {
                  ...
                  implementation("androidx.compose.runtime:runtime-livedata:1.6.7")
            }

      .. container:: section

         .. rubric:: Groovy
            :name: groovy_1

         .. code:: prettyprint

            dependencies {
                  ...
                  implementation "androidx.compose.runtime:runtime-livedata:1.6.7"
            }

   -  `RxJava2  <#package-summary>`__:
      `subscribeAsState()  <#extension-functions>`__

      ``subscribeAsState()`` are extension functions that transform RxJava2’s
      reactive streams (e.g.
      `Single <http://reactivex.io/RxJava/2.x/javadoc/2.0.8/io/reactivex/Single.html>`__,
      `Observable <http://reactivex.io/RxJava/2.x/javadoc/2.0.8/io/reactivex/Observable.html>`__,
      `Completable <http://reactivex.io/RxJava/2.x/javadoc/2.0.8/io/reactivex/Completable.html>`__)
      into Compose
      `State  <#State>`__.

      The following `dependency  <#compose-runtime>`__
      is required in the ``build.gradle`` file:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin_2

         .. code:: prettyprint

            dependencies {
                  ...
                  implementation("androidx.compose.runtime:runtime-rxjava2:1.6.7")
            }

      .. container:: section

         .. rubric:: Groovy
            :name: groovy_2

         .. code:: prettyprint

            dependencies {
                  ...
                  implementation "androidx.compose.runtime:runtime-rxjava2:1.6.7"
            }

   -  `RxJava3  <#package-summary>`__:
      `subscribeAsState()  <#extension-functions>`__

      ``subscribeAsState()`` are extension functions that transform RxJava3’s
      reactive streams (e.g.
      `Single <http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Single.html>`__,
      `Observable <http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Observable.html>`__,
      `Completable <http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Completable.html>`__)
      into Compose
      `State  <#State>`__.

      The following `dependency  <#compose-runtime>`__
      is required in the ``build.gradle`` file:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin_3

         .. code:: prettyprint

            dependencies {
                  ...
                  implementation("androidx.compose.runtime:runtime-rxjava3:1.6.7")
            }

      .. container:: section

         .. rubric:: Groovy
            :name: groovy_3

         .. code:: prettyprint

            dependencies {
                  ...
                  implementation "androidx.compose.runtime:runtime-rxjava3:1.6.7"
            }

   **Key Point:**\  Compose automatically recomposes from reading ``State``
   objects. If you use another observable type such as ``LiveData`` in Compose,
   you should convert it to ``State`` before reading it. Make sure that type
   conversion happens in a composable, using a composable extension function
   like ``LiveData<T>.observeAsState()``.
   **Note:**\  You are not limited to these integrations. You can build an
   extension function for Jetpack Compose that reads other observable types. If
   your app uses a custom observable class, convert it to produce ``State<T>``
   using the
   `produceState  <#produceState>`__
   API.
   See the implementation of the builtins for examples of how to do this:
   `collectAsStateWithLifecycle <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-runtime-compose/src/main/java/androidx/lifecycle/compose/FlowExt.kt;l=168?q=collectAsStateWithLifecycle>`__.
   Any object that allows Jetpack Compose to subscribe to every change can be
   converted to ``State<T>`` and read in a Composable.

   .. rubric:: Stateful versus stateless
      :name: stateful-vs-stateless

   A composable that uses ``remember`` to store an object creates internal
   state, making the composable *stateful*. ``HelloContent`` is an example of a
   stateful composable because it holds and modifies its ``name`` state
   internally. This can be useful in situations where a caller doesn't need to
   control the state and can use it without having to manage the state
   themselves. However, composables with internal state tend to be less reusable
   and harder to test.

   A *stateless* composable is a composable that doesn't hold any state. An easy
   way to achieve stateless is by using `state hoisting  <#state-hoisting>`__.

   As you develop reusable composables, you often want to expose both a stateful
   and a stateless version of the same composable. The stateful version is
   convenient for callers that don't care about the state, and the stateless
   version is necessary for callers that need to control or hoist the state.

   .. rubric:: State hoisting
      :name: state-hoisting

   State hoisting in Compose is a pattern of moving state to a composable's
   caller to make a composable stateless. The general pattern for state hoisting
   in Jetpack Compose is to replace the state variable with two parameters:

   -  **``value: T``:** the current value to display
   -  **``onValueChange: (T) -> Unit``:** an event that requests the value to
      change, where ``T`` is the proposed new value

   However, you are not limited to ``onValueChange``. If more specific events
   are appropriate for the composable, you should define them using lambdas.

   State that is hoisted this way has some important properties:

   -  **Single source of truth:** By moving state instead of duplicating it,
      we're ensuring there's only one source of truth. This helps avoid bugs.
   -  **Encapsulated:** Only stateful composables can modify their state. It's
      completely internal.
   -  **Shareable:** Hoisted state can be shared with multiple composables. If
      you wanted to read ``name`` in a different composable, hoisting would
      allow you to do that.
   -  **Interceptable:** callers to the stateless composables can decide to
      ignore or modify events before changing the state.
   -  **Decoupled:** the state for the stateless composables may be stored
      anywhere. For example, it's now possible to move ``name`` into a
      ``ViewModel``.

   In the example case, you extract the ``name`` and the ``onValueChange`` out
   of ``HelloContent`` and move them up the tree to a ``HelloScreen`` composable
   that calls ``HelloContent``.

   .. code:: prettyprint

      @Composable
      fun HelloScreen() {
          var name by rememberSaveable { mutableStateOf("") }

          HelloContent(name = name, onNameChange = { name = it })
      }

      @Composable
      fun HelloContent(name: String, onNameChange: (String) -> Unit) {
          Column(modifier = Modifier.padding(16.dp)) {
              Text(
                  text = "Hello, $name",
                  modifier = Modifier.padding(bottom = 8.dp),
                  style = MaterialTheme.typography.bodyMedium
              )
              OutlinedTextField(value = name, onValueChange = onNameChange, label = { Text("Name") })
          }
      }StateOverviewSnippets.kt

   By hoisting the state out of ``HelloContent``, it's easier to reason about
   the composable, reuse it in different situations, and test. ``HelloContent``
   is decoupled from how its state is stored. Decoupling means that if you
   modify or replace ``HelloScreen``, you don't have to change how
   ``HelloContent`` is implemented.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/udf-hello-screen.png
      :figclass: screenshot
      :width: 300px

   The pattern where the state goes down, and events go up is called a
   *unidirectional data flow*. In this case, the state goes down from
   ``HelloScreen`` to ``HelloContent`` and events go up from ``HelloContent`` to
   ``HelloScreen``. By following unidirectional data flow, you can decouple
   composables that display state in the UI from the parts of your app that
   store and change state.

   **Key Point:** When hoisting state, there are three rules to help you figure
   out where state should go:

   #. State should be hoisted to at *least* the **lowest common parent** of all
      composables that use the state (read).
   #. State should be hoisted to at *least* the **highest level it may be
      changed** (write).
   #. If **two states change in response to the same events** they should be
      **hoisted together.**

   You can hoist state higher than these rules require, but underhoisting state
   makes it difficult or impossible to follow unidirectional data flow.

   See the `Where to hoist state  <#state-hoisting>`__ page to
   learn more.

   .. rubric:: Restoring state in Compose
      :name: restore-ui-state

   The
   `rememberSaveable  <#rememberSaveable>`__
   API behaves similarly to ``remember`` because it retains state across
   recompositions, and also across activity or process recreation using the
   saved instance state mechanism. For example, this happens, when the screen is
   rotated.

   **Note:**\  ``rememberSaveable`` will not retain state if the activity is
   `completely dismissed by the user  <#ui-dismissal-user>`__. For
   example, it does not retain state if the user swipes the current activity up
   from the `recents screen  <#recents>`__.

   .. rubric:: Ways to store state
      :name: ways-to-store

   All data types that are added to the ``Bundle`` are saved automatically. If
   you want to save something that cannot be added to the ``Bundle``, there are
   several options.

   .. rubric:: Parcelize
      :name: parcelize

   The simplest solution is to add the
   `@Parcelize <https://github.com/Kotlin/KEEP/blob/master/proposals/extensions/android-parcelable.md>`__
   annotation to the object. The object becomes parcelable, and can be bundled.
   For example, this code makes a parcelable ``City`` data type and saves it to
   the state.

   .. code:: prettyprint

      @Parcelize
      data class City(val name: String, val country: String) : Parcelable

      @Composable
      fun CityScreen() {
          var selectedCity = rememberSaveable {
              mutableStateOf(City("Madrid", "Spain"))
          }
      }StateOverviewSnippets.kt

   .. rubric:: MapSaver
      :name: mapsaver

   If for some reason ``@Parcelize`` is not suitable, you can use ``mapSaver``
   to define your own rule for converting an object into a set of values that
   the system can save to the ``Bundle``.

   .. code:: prettyprint

      data class City(val name: String, val country: String)

      val CitySaver = run {
          val nameKey = "Name"
          val countryKey = "Country"
          mapSaver(
              save = { mapOf(nameKey to it.name, countryKey to it.country) },
              restore = { City(it[nameKey] as String, it[countryKey] as String) }
          )
      }

      @Composable
      fun CityScreen() {
          var selectedCity = rememberSaveable(stateSaver = CitySaver) {
              mutableStateOf(City("Madrid", "Spain"))
          }
      }StateOverviewSnippets.kt

   .. rubric:: ListSaver
      :name: listsaver

   To avoid needing to define the keys for the map, you can also use
   ``listSaver`` and use its indices as keys:

   .. code:: prettyprint

      data class City(val name: String, val country: String)

      val CitySaver = listSaver<City, Any>(
          save = { listOf(it.name, it.country) },
          restore = { City(it[0] as String, it[1] as String) }
      )

      @Composable
      fun CityScreen() {
          var selectedCity = rememberSaveable(stateSaver = CitySaver) {
              mutableStateOf(City("Madrid", "Spain"))
          }
      }StateOverviewSnippets.kt

   .. rubric:: State holders in Compose
      :name: managing-state

   Simple state hoisting can be managed in the composable functions itself.
   However, if the amount of state to keep track of increases, or the logic to
   perform in composable functions arises, it's a good practice to delegate the
   logic and state responsibilities to other classes: **state holders**.

   **Key Term:** **State holders** manage logic and state of composables.

   Note that in other materials, state holders are also called *hoisted state
   objects*.

   See the `state hoisting in Compose  <#state-hoisting>`__
   documentation or, more generally, the `State holders and UI State  <#stateholders>`__ page in the architecture
   guide to learn more.

   .. rubric:: Retrigger remember calculations when keys change
      :name: retrigger-remember

   The
   `remember  <#remember>`__
   API is frequently used together with
   `MutableState  <#MutableState>`__:

   .. code:: prettyprint

      var name by remember { mutableStateOf("") }StateOverviewSnippets.kt

   Here, using the ``remember`` function makes the ``MutableState`` value
   survive recompositions.

   In general, ``remember`` takes a ``calculation`` lambda parameter. When
   ``remember`` is first run, it invokes the ``calculation`` lambda and stores
   its result. During recomposition, ``remember`` returns the value that was
   last stored.

   Apart from caching state, you can also use ``remember`` to store any object
   or result of an operation in the Composition that is expensive to initialize
   or calculate. You might not want to repeat this calculation in every
   recomposition. An example is creating this
   `ShaderBrush  <#ShaderBrush>`__
   object, which is an expensive operation:

   .. code:: prettyprint

      val brush = remember {
          ShaderBrush(
              BitmapShader(
                  ImageBitmap.imageResource(res, avatarRes).asAndroidBitmap(),
                  Shader.TileMode.REPEAT,
                  Shader.TileMode.REPEAT
              )
          )
      }StateOverviewSnippets.kt

   ``remember`` stores the value until it leaves the Composition. However, there
   is a way to invalidate the cached value. The ``remember`` API also takes a
   ``key`` or ``keys`` parameter. *If any of these keys change, the next time
   the function recomposes*, ``remember`` *invalidates the cache and executes
   the calculation lambda block again*. This mechanism gives you control over
   the lifetime of an object in the Composition. The calculation remains valid
   until the inputs change, instead of until the remembered value leaves the
   Composition.

   The following examples show how this mechanism works.

   In this snippet, a
   `ShaderBrush  <#ShaderBrush>`__
   is created and used as the background paint of a ``Box`` composable.
   ``remember`` stores the
   `ShaderBrush  <#ShaderBrush>`__
   instance because it is expensive to recreate, as explained earlier.
   ``remember`` takes ``avatarRes`` as the ``key1`` parameter, which is the
   selected background image. If ``avatarRes`` changes, the brush recomposes
   with the new image, and reapplies to the ``Box``. This can occur when the
   user selects another image to be the background from a picker.

   .. code:: prettyprint

      @Composable
      private fun BackgroundBanner(
          @DrawableRes avatarRes: Int,
          modifier: Modifier = Modifier,
          res: Resources = LocalContext.current.resources
      ) {
          val brush = remember(key1 = avatarRes) {
              ShaderBrush(
                  BitmapShader(
                      ImageBitmap.imageResource(res, avatarRes).asAndroidBitmap(),
                      Shader.TileMode.REPEAT,
                      Shader.TileMode.REPEAT
                  )
              )
          }

          Box(
              modifier = modifier.background(brush)
          ) {
              /* ... */
          }
      }StateOverviewSnippets.kt

   In the next snippet, state is hoisted to a `plain state holder class  <#choose_between_a_viewmodel_and_plain_class_for_a_state_holder>`__
   ``MyAppState``. It exposes a ``rememberMyAppState`` function to initialize an
   instance of the class using ``remember``. Exposing such functions to create
   an instance that survives recompositions is a common pattern in Compose. The
   ``rememberMyAppState`` function receives
   `windowSizeClass  <#WindowSizeClass>`__,
   which serves as the ``key`` parameter for ``remember``. If this parameter
   changes, the app needs to recreate the plain state holder class with the
   latest value. This may occur if, for example, the user rotates the device.

   .. code:: prettyprint

      @Composable
      private fun rememberMyAppState(
          windowSizeClass: WindowSizeClass
      ): MyAppState {
          return remember(windowSizeClass) {
              MyAppState(windowSizeClass)
          }
      }

      @Stable
      class MyAppState(
          private val windowSizeClass: WindowSizeClass
      ) { /* ... */ }StateOverviewSnippets.kt

   **Note:**\  For more information about plain state holder classes, see the
   `Plain state holder class as state owner  <#plain-state>`__ documentation, or
   the `State holders and UI State  <#stateholders>`__ documentation in the
   Architecture guide.
   Compose uses the class's
   `equals  <#equals>`__
   implementation to decide if a key has changed and invalidate the stored
   value.

   **Note:**\  At first glance, using ``remember`` with keys might seem similar
   to using other Compose APIs, like
   `derivedStateOf  <#derivedStateOf>`__.
   See the `Jetpack Compose — When should I use derivedStateOf? <https://medium.com/androiddevelopers/jetpack-compose-when-should-i-use-derivedstateof-63ce7954c11b>`__
   blog post to learn about the difference.

   .. rubric:: Store state with keys beyond recomposition
      :name: store-state

   The
   `rememberSaveable  <#rememberSaveable>`__
   API is a wrapper around ``remember`` that can store data in a
   `Bundle  <#Bundle>`__. This API allows state to
   survive not only recomposition, but also activity recreation and
   system-initiated process death. ``rememberSaveable`` receives ``input``
   parameters for the same purpose that ``remember`` receives ``keys``. *The
   cache is invalidated when any of the inputs change*. The next time the
   function recomposes, ``rememberSaveable`` re-executes the calculation lambda
   block.

   **Note:**\  There is a difference in API naming that you should note. In the
   ``remember`` API, you use the parameter name ``keys``, and in
   ``rememberSaveable`` you use ``inputs`` for the same purpose. If any of these
   parameters changes, the cached value is invalidated.
   In the following example, ``rememberSaveable`` stores ``userTypedQuery``
   until ``typedQuery`` changes:

   .. code:: prettyprint

      var userTypedQuery by rememberSaveable(typedQuery, stateSaver = TextFieldValue.Saver) {
          mutableStateOf(
              TextFieldValue(text = typedQuery, selection = TextRange(typedQuery.length))
          )
      }StateOverviewSnippets.kt

   .. rubric:: Learn more
      :name: learn-more

   To learn more about state and Jetpack Compose, consult the following
   additional resources.

   .. rubric:: Samples
      :name: samples

   .. rubric:: Codelabs
      :name: codelabs

   -  `Using State in Jetpack Compose <https://developers.google.cn/codelabs/codelabs/jetpack-compose-state/index.html?index=..%2F..index#0>`__

   .. rubric:: Videos
      :name: videos

   -  `A Compose state of mind <https://www.youtube.com/watch?v=rmv2ug-wW4U>`__

   .. rubric:: Blogs
      :name: blogs

   -  `Effective State Management for ``TextField`` in
      Compose <https://medium.com/androiddevelopers/effective-state-management-for-textfield-in-compose-d6e5b070fbe5>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Architecting your Compose UI  <#architecture>`__
   -  `Save UI state in Compose  <#state-saving>`__
   -  `Side-effects in Compose  <#side-effects>`__

Last updated 2024-05-03 UTC.

/Where to hoist state
=====================

.. https://developer.android.google.cn/develop/ui/compose/state-hoisting?hl=en

.. container:: devsite-article-body clearfix

   In a Compose application, where you hoist `UI state  <#define-ui-state>`__ depends on whether UI
   logic or business logic requires it. This document lays out these two main
   scenarios.

   .. rubric:: Best practice
      :name: best-practice

   .. container:: video-wrapper

   You should hoist UI state to the **lowest common ancestor** between all the
   composables that read and write it. You should keep state closest to where it
   is consumed. From the state owner, expose to consumers immutable state and
   events to modify the state.

   The lowest common ancestor can also be outside of the Composition. For
   example, when hoisting state in a ``ViewModel`` because business logic is
   involved.

   This page explains this best practice in detail and a caveat to keep in mind.

   .. rubric:: Types of UI state and UI logic
      :name: types-of-state-and-logic

   Below there are definitions for types of UI state and logic that are used
   throughout this document.

   .. rubric:: UI state
      :name: types-ui-state

   `UI state  <#define-ui-state>`__ is the property
   that describes the UI. There are two types of UI state:

   -  **Screen UI state** is *what* you need to display on the screen. For
      example, a ``NewsUiState`` class can contain the news articles and other
      information needed to render the UI. This state is usually connected with
      other layers of the hierarchy because it contains app data.
   -  **UI element state** refers to properties intrinsic to UI elements that
      influence how they are rendered. A UI element may be shown or hidden and
      may have a certain font, font size, or font color. In Android Views, the
      View manages this state itself as it is inherently stateful, exposing
      methods to modify or query its state. An example of this are the
      `get  <#getText>`__ and
      `set  <#setText>`__
      methods of the `TextView  <#TextView>`__ class
      for its text. In Jetpack Compose, the state is external to the composable,
      and you can even hoist it out of the immediate vicinity of the composable
      into the calling composable function or a state holder. An example of this
      is
      `ScaffoldState  <#ScaffoldState>`__
      for the
      `Scaffold  <#Scaffold>`__
      composable.

   .. rubric:: Logic
      :name: types-ui-logic

   Logic in an application can be either business logic or UI logic:

   -  **Business logic** is the implementation of product requirements for app
      data. For example, bookmarking an article in a news reader app when the
      user taps the button. This logic to save a bookmark to a file or database
      is usually placed in the domain or data layers. The state holder usually
      delegates this logic to those layers by calling the methods they expose.
   -  **UI logic** is related to *how* to display UI state on the screen. For
      example, obtaining the right search bar hint when the user has selected a
      category, scrolling to a particular item in a list, or the navigation
      logic to a particular screen when the user clicks a button.

   .. rubric:: UI logic
      :name: ui-logic

   When `UI logic  <#logic-types>`__ needs to read or
   write state, you should scope the state to the UI, following its lifecycle.
   To achieve this, you should hoist the state at the correct level in a
   composable function. Alternatively, you can do so in a `plain state holder class  <#ui-logic>`__, also scoped to
   the UI lifecycle.

   Below is a description of both solutions and explanation of when to use
   which.

   .. rubric:: Composables as state owner
      :name: composables-as-state-owner

   Having UI logic and UI element state in composables is a good approach if the
   state and logic is simple. You can leave your state internal to a composable
   or hoist as required.

   .. rubric:: No state hoisting needed
      :name: no-state-hoisting

   Hoisting state isn't always required. State can be kept internal in a
   composable when no other composable need to control it. In this snippet,
   there is a composable that expands and collapses on tap:

   .. code:: prettyprint

      @Composable
      fun ChatBubble(
          message: Message
      ) {
          var showDetails by rememberSaveable { mutableStateOf(false) } // Define the UI element expanded state

          ClickableText(
              text = AnnotatedString(message.content),
              onClick = { showDetails = !showDetails } // Apply simple UI logic
          )

          if (showDetails) {
              Text(message.timestamp)
          }
      }StateHoistingSnippets.kt

   The variable ``showDetails`` is the internal state for this UI element. It's
   only read and modified in this composable and the logic applied to it is very
   simple. Hoisting the state in this case therefore wouldn't bring much
   benefit, so you can leave it internal. Doing so makes this composable the
   owner and single source of truth of the expanded state.

   **Key Point:**\  Keeping UI element state internal to composable functions is
   acceptable. This is a good solution if the state and logic you apply to it is
   simple and other parts of the UI hierarchy don't need the state. For example,
   this is usually the case of animation state.

   .. rubric:: Hoisting within composables
      :name: hoisting-composables

   If you need to share your UI element state with other composables and apply
   UI logic to it in different places, you can hoist it higher in the UI
   hierarchy. This also makes your composables more reusable and easier to test.

   The following example is a chat app that implements two pieces of
   functionality:

   -  The ``JumpToBottom`` button scrolls the messages list to the bottom. The
      button performs UI logic on the list state.
   -  The ``MessagesList`` list scrolls to the bottom after the user sends new
      messages. UserInput performs UI logic on the list state.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/state-hoisting-chat.png
      name: state-hoisting-chat
      :alt: Chat app with a JumpToBottom button and scroll to bottom on new
      messages
      :width: 75.0%

      **Figure 1.** Chat app with a ``JumpToBottom`` button and scroll to bottom
      on new messages

   The composable hierarchy is as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/state-hoisting-initial-tree.png
      name: state-hoisting-initial-tree
      :alt: Chat composable tree
      :width: 50.0%

      **Figure 2.** Chat composable tree

   The
   `LazyColumn  <#LazyColumn>`__
   state is hoisted to the conversation screen so the app can perform UI logic
   and read the state from all composables that require it:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/state-hoisting-animated.gif
      name: state-hoisting-animated
      :alt: Hoisting LazyColumn state from the LazyColumn to the
      ConversationScreen
      :width: 100.0%

      **Figure 3.** Hoisting ``LazyColumn`` state from the ``LazyColumn`` to the
      ``ConversationScreen``

   So finally the composables are:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/state-hoisting-passing-state.png
      name: state-hoisting-passing-state
      :alt: Chat composable tree with LazyListState hoisted to
      ConversationScreen
      :width: 70.0%

      **Figure 4.** Chat composable tree with ``LazyListState`` hoisted to
      ``ConversationScreen``

   The code is as follows:

   .. code:: prettyprint

      @Composable
      private fun ConversationScreen(/*...*/) {
          val scope = rememberCoroutineScope()

          val lazyListState = rememberLazyListState() // State hoisted to the ConversationScreen

          MessagesList(messages, lazyListState) // Reuse same state in MessageList

          UserInput(
              onMessageSent = { // Apply UI logic to lazyListState
                  scope.launch {
                      lazyListState.scrollToItem(0)
                  }
              },
          )
      }

      @Composable
      private fun MessagesList(
          messages: List<Message>,
          lazyListState: LazyListState = rememberLazyListState() // LazyListState has a default value
      ) {

          LazyColumn(
              state = lazyListState // Pass hoisted state to LazyColumn
          ) {
              items(messages, key = { message -> message.id }) { item ->
                  Message(/*...*/)
              }
          }

          val scope = rememberCoroutineScope()

          JumpToBottom(onClicked = {
              scope.launch {
                  lazyListState.scrollToItem(0) // UI logic being applied to lazyListState
              }
          })
      }StateHoistingSnippets.kt

   ``LazyListState`` is hoisted as high as required for the UI logic that has to
   be applied. Since it is initialized in a composable function, it is stored in
   the Composition, following its lifecycle.

   Note that ``lazyListState`` is defined in the ``MessagesList`` method, with
   the default value of ``rememberLazyListState()``. This is a common pattern in
   Compose. It makes composables more reusable and flexible. You can then use
   the composable in different parts of the app which might not need to control
   the state. This is usually the case while testing or previewing a composable.
   This is exactly how ``LazyColumn`` defines its state.

   **Key Point:**\  Hoist state to the lowest common ancestor and avoid passing
   it to composables that don't need it.
   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/state-hoisting-lca.png
      name: state-hoisting-lca
      :alt: Lowest common ancestor for LazyListState is ConversationScreen
      :width: 70.0%

      **Figure 5.** Lowest common ancestor for ``LazyListState`` is
      ``ConversationScreen``

   .. rubric:: Plain state holder class as state owner
      :name: classes-as-state-owner

   When a composable contains complex UI logic that involves one or multiple
   state fields of a UI element, it should delegate that responsibility to
   `state holders  <#ui-logic>`__, like
   a plain state holder class. This makes the composable's logic more testable
   in isolation, and reduces its complexity. This approach favors the
   `separation of concerns principle <https://en.wikipedia.org/wiki/Separation_of_concerns>`__: **the
   composable is in charge of emitting UI elements, and the state holder
   contains the UI logic and UI element state**.

   Plain state holder classes provide convenient functions to callers of your
   composable function, so they don't have to write this logic themselves.

   These plain classes are created and remembered in the Composition. Because
   they follow the `composable's lifecycle  <#lifecycle>`__,
   they can take types provided by the Compose library such as
   `rememberNavController()  <#rememberNavController>`__
   or
   `rememberLazyListState()  <#rememberLazyListState>`__.

   An example of this is the
   `LazyListState <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/lazy/LazyListState.kt;l=82?q=LazyListState.kt&ss=androidx%2Fplatform%2Fframeworks%2Fsupport>`__
   plain state holder class, implemented in Compose to control the UI complexity
   of
   `LazyColumn  <#LazyColumn>`__
   or
   `LazyRow  <#lazyrow>`__.

   .. code:: prettyprint

      // LazyListState.kt

      @Stable
      class LazyListState constructor(
          firstVisibleItemIndex: Int = 0,
          firstVisibleItemScrollOffset: Int = 0
      ) : ScrollableState {
          /**
           *   The holder class for the current scroll position.
           */
          private val scrollPosition = LazyListScrollPosition(
              firstVisibleItemIndex, firstVisibleItemScrollOffset
          )

          suspend fun scrollToItem(/*...*/) { /*...*/ }

          override suspend fun scroll() { /*...*/ }

          suspend fun animateScrollToItem() { /*...*/ }
      }StateHoistingSnippets.kt

   ``LazyListState`` encapsulates the state of the
   `LazyColumn  <#LazyColumn>`__
   storing the ``scrollPosition`` for this UI element. It also exposes methods
   to modify the scroll position by for instance scrolling to a given item.

   **Note:**\  This class is annotated as
   `Stable  <#Stable>`__. For more
   information on stability in Compose, see this `blog post <https://medium.com/androiddevelopers/jetpack-compose-stability-explained-79c10db270c8>`__.
   As you can see, **incrementing a composable's responsibilities increases the
   need for a state holder**. The responsibilities could be in UI logic, or just
   in the amount of state to keep track of.

   **Note:**\  If plain state holder classes contain state you want to preserve
   after an Activity or process is recreated, use ``rememberSaveable`` and
   create a custom ``Saver`` for it.
   Another common pattern is using a plain state holder class to handle the
   complexity of root composable functions in the app. You can use such a class
   to encapsulate app-level state like navigation state and screen sizing. A
   complete description of this can be found in the `UI logic and its state holder page  <#ui-logic>`__.

   .. rubric:: Business logic
      :name: business-logic

   If composables and plain state holders classes are in charge of the UI logic
   and UI element state, a screen level state holder is in charge of the
   following tasks:

   -  Providing access to the `business logic  <#logic-types>`__ of the application
      that is usually placed in other layers of the hierarchy such as the
      business and data layers.
   -  Preparing the application data for presentation in a particular screen,
      which becomes the screen UI state.

   .. rubric:: ViewModels as state owner
      :name: viewmodels-as-state-owner

   The `benefits  <#best-practices>`__ of
   AAC ViewModels in Android development make them suitable for providing access
   to the business logic and preparing the application data for presentation on
   the screen.

   **Key Point:**\  A ``ViewModel`` is just an implementation detail of a state
   holder with certain responsibilities. If you want to keep your project's
   module away from Android dependencies, you can rely on interfaces to make the
   implementation swappable in different contexts. For instance, you can use
   ``ViewModel`` in your Android-specific module, and simpler platform-agnostic
   implementations in other modules, like a plain state holder class.
   When you hoist UI state in the ``ViewModel``, you move it outside of the
   Composition.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/state-hoisting-vm.png
      name: state-hoisting-vm
      :alt: State hoisted to the ViewModel is stored outside of the Composition.
      :width: 75.0%

      **Figure 6.** State hoisted to the ``ViewModel`` is stored outside of the
      Composition.

   ViewModels aren't stored as part of the Composition. They're provided by the
   framework and they're scoped to a
   `ViewModelStoreOwner  <#ViewModelStoreOwner>`__
   which can be an Activity, Fragment, navigation graph, or destination of a
   navigation graph. For more information on `ViewModel scopes  <#viewmodel-apis>`__ you can
   review the documentation.

   Then, the ``ViewModel`` is the source of truth and **lowest common ancestor**
   for UI state.

   .. rubric:: Screen UI state
      :name: screen-ui-state

   As per the definitions above, screen UI state is produced by applying
   business rules. Given that the screen level state holder is responsible for
   it, this means the `screen UI state  <#ui-state>`__ is typically
   hoisted in the screen level state holder, in this case a ``ViewModel``.

   Consider the ``ConversationViewModel`` of a chat app and how it exposes the
   screen UI state and events to modify it:

   .. code:: prettyprint

      class ConversationViewModel(
          channelId: String,
          messagesRepository: MessagesRepository
      ) : ViewModel() {

          val messages = messagesRepository
              .getLatestMessages(channelId)
              .stateIn(
                  scope = viewModelScope,
                  started = SharingStarted.WhileSubscribed(5_000),
                  initialValue = emptyList()
              )

          // Business logic
          fun sendMessage(message: Message) { /* ... */ }
      }StateHoistingSnippets.kt

   Composables consume the screen UI state hoisted in the ``ViewModel``. You
   should inject the ``ViewModel`` instance in your screen-level composables to
   provide access to business logic.

   **Note:**\  You shouldn't pass ``ViewModel`` instances down to other
   composables. For more information, see the `Architecture state holders documentation  <#business-logic>`__.
   The following is an example of a ``ViewModel`` used in a screen-level
   composable. Here, the composable ``ConversationScreen()`` consumes the screen
   UI state hoisted in the ``ViewModel``:

   .. code:: prettyprint

      @Composable
      private fun ConversationScreen(
          conversationViewModel: ConversationViewModel = viewModel()
      ) {

          val messages by conversationViewModel.messages.collectAsStateWithLifecycle()

          ConversationScreen(
              messages = messages,
              onSendMessage = { message: Message -> conversationViewModel.sendMessage(message) }
          )
      }

      @Composable
      private fun ConversationScreen(
          messages: List<Message>,
          onSendMessage: (Message) -> Unit
      ) {

          MessagesList(messages, onSendMessage)
          /* ... */
      }StateHoistingSnippets.kt

   **Note:**\  To use the ``viewModel()`` function, add the
   `androidx.lifecycle:lifecycle-viewmodel-compose  <#lifecycle>`__
   dependency to your ``build.gradle`` file. Learn more about this function in
   our documentation for `working with other libraries  <#viewmodel>`__ in Compose.
   **Note:**\  If ViewModels contain state that you want to preserve after
   system-initiated process recreation, use
   `SavedStateHandle  <#SavedStateHandle>`__ to
   persist it. For more information, see the Saving `UI states page  <#saving-states>`__.

   .. rubric:: Property drilling
      :name: property_drilling

   “Property drilling” refers to passing data through several nested children
   components to the location where they’re read.

   A typical example of where property drilling can appear in Compose is when
   you inject the screen level state holder at the top level and pass down state
   and events to children composables. This might additionally generate an
   overload of composable functions signatures.

   Even though exposing events as individual lambda parameters could overload
   the function signature, it maximizes the visibility of what the composable
   function responsibilities are. You can see what it does at a glance.

   Property drilling is preferable over creating wrapper classes to encapsulate
   state and events in one place because this reduces the visibility of the
   composable responsibilities. By not having wrapper classes you’re also more
   likely to pass composables only the parameters they need, which is a `best practice  <#composable-parameters>`__.

   The same best practice applies if these events are navigation events, you can
   learn more about that in the `navigation docs  <#nav-calls-best-practices>`__.

   If you have identified a performance issue, you may also choose to defer
   reading of state. You can check the `performance docs  <#defer-reads>`__ to learn
   more.

   .. rubric:: UI element state
      :name: ui-element-state

   You can hoist UI element state to the screen level state holder if there is
   business logic that needs to read or write it.

   Continuing the example of a chat app, the app displays user suggestions in a
   group chat when the user types ``@`` and a hint. Those suggestions come from
   the data layer and the logic to calculate a list of user suggestions is
   considered business logic. The feature looks like this:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/state-hoisting-suggestions.png
      name: state-hoisting-suggestions
      :alt: Feature that displays user suggestions in a group chat when the user
      types \`@\` and a hint
      :width: 50.0%

      **Figure 7.** Feature that displays user suggestions in a group chat when
      the user types ``@`` and a hint

   The ``ViewModel`` implementing this feature would look as follows:

   .. code:: prettyprint

      class ConversationViewModel(/*...*/) : ViewModel() {

          // Hoisted state
          var inputMessage by mutableStateOf("")
              private set

          val suggestions: StateFlow<List<Suggestion>> =
              snapshotFlow { inputMessage }
                  .filter { hasSocialHandleHint(it) }
                  .mapLatest { getHandle(it) }
                  .mapLatest { repository.getSuggestions(it) }
                  .stateIn(
                      scope = viewModelScope,
                      started = SharingStarted.WhileSubscribed(5_000),
                      initialValue = emptyList()
                  )

          fun updateInput(newInput: String) {
              inputMessage = newInput
          }
      }StateHoistingSnippets.kt

   ``inputMessage`` is a variable storing the
   `TextField  <#TextField>`__
   state. Every time the user types in new input, the app calls business logic
   to produce ``suggestions``.

   **Note:**\  if this variable wasn't needed for business logic as it is needed
   now to produce user suggestions, it shouldn't be hoisted to the screen level
   state holder. It should be defined and stored in the UI, closer to the
   composable function that needs it.
   ``suggestions`` is screen UI state and is consumed from Compose UI by
   collecting from the
   `StateFlow <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/>`__.

   **Note:**\  it's possible for a screen-level composable to have both a
   ``ViewModel`` that provides access to business logic AND a plain state holder
   class that manages its UI logic and UI elements' state.

   .. rubric:: Caveat
      :name: caveat

   For some Compose UI element state, hoisting to the ``ViewModel`` might
   require special considerations. For example, some state holders of Compose UI
   elements expose methods to modify the state. Some of them might be suspend
   functions that trigger animations. These suspend functions can throw
   exceptions if you call them from a
   `CoroutineScope <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/>`__
   that is not scoped to the Composition.

   Let’s say the app drawer’s content is dynamic and you need to fetch and
   refresh it from the data layer after it’s closed. You should hoist the drawer
   state to the ``ViewModel`` so you can call both the UI and business logic on
   this element from the state owner.

   However, calling
   `DrawerState  <#DrawerState>`__'s
   `close()  <#close>`__
   method using the
   `viewModelScope  <#viewmodelscope>`__
   from Compose UI causes a runtime exception of type
   `IllegalStateException <https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html>`__
   with a message reading “a
   `MonotonicFrameClock  <#MonotonicFrameClock>`__
   is not available in this
   `CoroutineContext” <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/>`__.

   To fix this, use a ``CoroutineScope`` scoped to the Composition. It provides
   a ``MonotonicFrameClock`` in the ``CoroutineContext`` that is necessary for
   the suspend functions to work.

   **Warning:**\  Calling some suspend functions exposed from Compose UI element
   state that trigger animations throw exceptions if called from a
   ``CoroutineScope`` that's not scoped to the Composition. For example,
   `LazyListState.animateScrollTo()  <#animateScrollToItem>`__
   and
   `DrawerState.close()  <#close>`__.
   To fix this crash, switch the ``CoroutineContext`` of the coroutine in the
   ``ViewModel`` to one that is scoped to the Composition. It could look like
   this:

   .. code:: prettyprint

      class ConversationViewModel(/*...*/) : ViewModel() {

          val drawerState = DrawerState(initialValue = DrawerValue.Closed)

          private val _drawerContent = MutableStateFlow(DrawerContent.Empty)
          val drawerContent: StateFlow<DrawerContent> = _drawerContent.asStateFlow()

          fun closeDrawer(uiScope: CoroutineScope) {
              viewModelScope.launch {
                  withContext(uiScope.coroutineContext) { // Use instead of the default context
                      drawerState.close()
                  }
                  // Fetch drawer content and update state
                  _drawerContent.update { content }
              }
          }
      }

      // in Compose
      @Composable
      private fun ConversationScreen(
          conversationViewModel: ConversationViewModel = viewModel()
      ) {
          val scope = rememberCoroutineScope()

          ConversationScreen(onCloseDrawer = { conversationViewModel.closeDrawer(uiScope = scope) })
      }StateHoistingSnippets.kt

   .. rubric:: Learn more
      :name: learn-more

   To learn more about state and Jetpack Compose, consult the following
   additional resources.

   .. rubric:: Samples
      :name: samples

   .. rubric:: Codelabs
      :name: codelabs

   -  `Using State in Jetpack Compose <https://developers.google.cn/codelabs/codelabs/jetpack-compose-state/index.html?index=..%2F..index#0>`__

   .. rubric:: Videos
      :name: videos

   -  `State holders and state production in the UI Layer <https://youtu.be/pCX9wvu-Bq0>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Save UI state in Compose  <#state-saving>`__
   -  `Lists and grids  <#lists>`__
   -  `Architecting your Compose UI  <#architecture>`__

Last updated 2024-03-25 UTC.

/Save UI state
==============

.. https://developer.android.google.cn/develop/ui/compose/state-saving?hl=en

.. container:: devsite-article-body clearfix

   Depending on where your state is hoisted to and the logic that is required,
   you can use different APIs to store and restore your `UI state  <#ui-state>`__. Every app uses
   a combination of APIs to best achieve this.

   **Note:**\  You can see more information on where to hoist your state based
   on the logic applied in the `Where to hoist state  <#state-hoisting>`__ documentation.
   Any Android app could lose its `UI state  <#ui-state>`__ due to activity
   or process recreation. This loss of state can occur because of the following
   events:

   -  `Configuration changes  <#runtime-changes>`__. The
      activity is destroyed and recreated unless the configuration change is
      `handled manually  <#HandlingTheChange>`__.
   -  `System-initiated process death  <#ui-dismissal-system>`__.
      The app is in the background and the device frees up resources (like
      memory) to be used by other processes.

   **Note:**\  `System-initiated process death  <#ui-dismissal-system>`__ is
   different from `user-initiated process death  <#ui-dismissal-user>`__, in
   which the user explicitly dismisses the activity. In the case of
   user-initiated process death, the loss of transient state is generally
   reasonable (for example, losing the animation state or the content of a
   `TextField  <#TextField>`__
   while filling out a form).
   Preserving the state after these events is essential for a positive user
   experience. Selecting which state to persist depends on your app's unique
   user flows. As a best practice, you should at least preserve user input and
   navigation-related state. Examples of this include the scroll position of a
   list, the ID of the item the user wants more detail about, the in-progress
   selection of user preferences, or input in text fields.

   This page summarizes the APIs available to store UI state depending on where
   your state is hoisted to and the logic that needs it.

   .. rubric:: UI logic
      :name: ui-logic

   If your state is hoisted in the UI, either in composable functions or plain
   state holder classes scoped to the Composition, you can use
   `rememberSaveable  <#rememberSaveable>`__
   to retain state across activity and process recreation.

   In the following snippet, ``rememberSaveable`` is used to store a single
   boolean UI element state:

   .. code:: prettyprint

      @Composable
      fun ChatBubble(
          message: Message
      ) {
          var showDetails by rememberSaveable { mutableStateOf(false) }

          ClickableText(
              text = AnnotatedString(message.content),
              onClick = { showDetails = !showDetails }
          )

          if (showDetails) {
              Text(message.timestamp)
          }
      }SavingUIStateSnippets.kt

   .. container:: float

   ``showDetails`` is a boolean variable that stores if the chat bubble is
   collapsed or expanded.

   **Important:**\  Usually, data stored in saved instance state is transient
   state that depends on user input or navigation. Examples of this include the
   scroll position of a list, the ID of the item the user wants more detail
   about, the in-progress selection of user preferences, or input in text
   fields.
   ``rememberSaveable`` stores `UI element state  <#ui-state>`__ in a
   `Bundle  <#Bundle>`__ through the saved instance
   state mechanism.

   It is able to store primitive types to the bundle automatically. If your
   state is held in a type that is not primitive, like a data class, you can use
   different storing mechanisms, such as using the
   `Parcelize  <#parcelize>`__ annotation, using Compose APIs like
   `listSaver  <#listSaver>`__
   and
   `mapSaver  <#mapSaver>`__,
   or implementing a custom saver class extending Compose runtime
   `Saver  <#Saver>`__
   class. See the `Ways to store state  <#ways-to-store>`__ documentation to learn
   more about these methods.

   In the following snippet, the
   `rememberLazyListState <https://cs.android.com/androidx/platform/tools/dokka-devsite-plugin/+/master:testData/compose/source/androidx/compose/foundation/lazy/LazyListState.kt;l=49?q=LazyListState>`__
   Compose API stores
   `LazyListState  <#LazyListState>`__,
   which consists of the scroll state of a
   `LazyColumn  <#LazyColumn>`__
   or
   `LazyRow  <#LazyRow>`__,
   using ``rememberSaveable``. It uses a
   `LazyListState.Saver <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/lazy/LazyListState.kt;l=413?q=LazyListState.kt>`__,
   which is a custom saver that is able to store and restore the scroll state.
   After an activity or process recreation (for example, after a configuration
   change like changing device orientation), the scroll state is preserved.

   .. code:: prettyprint

      @Composable
      fun rememberLazyListState(
          initialFirstVisibleItemIndex: Int = 0,
          initialFirstVisibleItemScrollOffset: Int = 0
      ): LazyListState {
          return rememberSaveable(saver = LazyListState.Saver) {
              LazyListState(
                  initialFirstVisibleItemIndex, initialFirstVisibleItemScrollOffset
              )
          }
      }SavingUIStateSnippets.kt

   .. rubric:: Best practice
      :name: best_practice

   ``rememberSaveable`` uses a `Bundle  <#Bundle>`__ to
   store UI state, which is shared by other APIs that also write to it, like
   `onSaveInstanceState()  <#onSaveInstanceState>`__
   calls in your activity. However, the size of this ``Bundle`` is limited, and
   storing large objects could lead to
   `TransactionTooLarge  <#TransactionTooLargeException>`__
   exceptions in runtime. This can be particularly problematic in single
   ``Activity`` apps where the same ``Bundle`` is being used across the app.

   To avoid this type of crash, *you should not store large complex objects or
   lists of objects in the bundle*.

   Instead, store the minimum state required, like IDs or keys, and use these to
   delegate restoring more complex UI state to other mechanisms, like
   `persistent storage  <#local>`__.

   **Note:**\  In some cases, it might be acceptable not to store all UI
   elements' state.
   These design choices depend on the specific use cases for your app and how
   your users expect it to behave.

   .. rubric:: Verify state restoration
      :name: verify_state_restoration

   You can verify that the state stored with
   `rememberSaveable  <#rememberSaveable>`__
   in your Compose elements is correctly restored when the activity or process
   is recreated. There are specific APIs to achieve this, such as
   `StateRestorationTester  <#StateRestorationTester>`__.
   Check out the
   `Testing  <#verify_state_restoration>`__
   documentation to learn more.

   .. rubric:: Business logic
      :name: business-logic

   If your `UI element state  <#ui-state>`__ is hoisted to
   the ``ViewModel`` because it is required by business logic, you can use
   ``ViewModel``'s APIs.

   One of the main benefits of using a ``ViewModel`` in your Android application
   is that it handles configuration changes for free. When there is a
   configuration change, and the activity is destroyed and recreated, the UI
   state hoisted to the ``ViewModel`` is kept in memory. After the recreation,
   the old ``ViewModel`` instance is attached to the new activity instance.

   **Note:**\  The ``ViewModel``, as the implementation of a screen level state
   holder, handles the business logic used to produce `screen UI state  <#ui-state>`__. You should
   hoist the UI state to the ``ViewModel``, not because it will handle
   configuration changes for free, but because it makes sense for your
   architecture.
   However, a ``ViewModel`` instance does not survive system-initiated process
   death. To have the UI state survive this, use the `Saved State module for ViewModel  <#savedstate-compose-state>`__,
   which contains the
   `SavedStateHandle  <#SavedStateHandle>`__
   API.

   .. rubric:: Best practice
      :name: best_practice_2

   `SavedStateHandle  <#SavedStateHandle>`__
   also uses the ``Bundle`` mechanism to store UI state, so you should only use
   it to store simple `UI element state  <#ui-state>`__.

   `Screen UI state  <#ui-state>`__,
   which is produced by applying business rules and accessing layers of your
   application other than UI, should not be stored in ``SavedStateHandle`` due
   to its potential complexity and size. You can use different mechanisms to
   store complex or large data, like `local persistent storage  <#local>`__. After a
   process recreation, the screen is recreated with the restored transient state
   that was stored in ``SavedStateHandle`` (if any), and the screen UI state is
   produced again from the data layer.

   **Note:**\  For more information on the different ways of saving UI state,
   see the `Save UI states  <#saving-states>`__
   documentation.

   .. rubric:: ``SavedStateHandle`` APIs
      :name: savedstatehandle_apis

   `SavedStateHandle  <#SavedStateHandle>`__ has
   different APIs to store UI element state, most notably:

   .. list-table::

      - 

         - Compose
            `State  <#State>`__
         - `saveable()  <#saveable>`__
      - 

         - `StateFlow <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/>`__
         - `getStateFlow()  <#getStateFlow>`__

   .. rubric:: Compose ``State``
      :name: compose_state

   Use the ``saveable`` API of ``SavedStateHandle`` to read and write UI element
   state as ``MutableState``, so it survives activity and process recreation
   with minimal code setup.

   The ``saveable`` API supports primitive types out of the box and receives a
   ``stateSaver`` parameter to use custom savers, just like
   ``rememberSaveable()``.

   In the following snippet, ``message`` stores the user input types into a
   ``TextField``:

   .. code:: prettyprint

      class ConversationViewModel(
          savedStateHandle: SavedStateHandle
      ) : ViewModel() {

          var message by savedStateHandle.saveable(stateSaver = TextFieldValue.Saver) {
              mutableStateOf(TextFieldValue(""))
          }
              private set

          fun update(newMessage: TextFieldValue) {
              message = newMessage
          }

          /*...*/
      }

      val viewModel = ConversationViewModel(SavedStateHandle())

      @Composable
      fun UserInput(/*...*/) {
          TextField(
              value = viewModel.message,
              onValueChange = { viewModel.update(it) }
          )
      }SavingUIStateSnippets.kt

   See the
   `SavedStateHandle  <#savedstate-compose-state>`__
   documentation for more information on using the ``saveable`` API.

   **Caution:**\  The
   `saveable  <#savedstate-compose-state>`__
   API is experimental.

   .. rubric:: ``StateFlow``
      :name: stateflow

   Use
   `getStateFlow()  <#getStateFlow>`__
   to store UI element state and consume it as a flow from the
   `SavedStateHandle  <#SavedStateHandle>`__.
   The
   `StateFlow <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/>`__
   is read only, and the API requires you to specify a key so you can replace
   the flow to emit a new value. With the key you configured, you can retrieve
   the ``StateFlow`` and collect the latest value.

   In the following snippet, ``savedFilterType`` is a ``StateFlow`` variable
   that stores a filter type applied to a list of chat channels in a chat app:

   .. code:: prettyprint

      private const val CHANNEL_FILTER_SAVED_STATE_KEY = "ChannelFilterKey"

      class ChannelViewModel(
          channelsRepository: ChannelsRepository,
          private val savedStateHandle: SavedStateHandle
      ) : ViewModel() {

          private val savedFilterType: StateFlow<ChannelsFilterType> = savedStateHandle.getStateFlow(
              key = CHANNEL_FILTER_SAVED_STATE_KEY, initialValue = ChannelsFilterType.ALL_CHANNELS
          )

          private val filteredChannels: Flow<List<Channel>> =
              combine(channelsRepository.getAll(), savedFilterType) { channels, type ->
                  filter(channels, type)
              }.onStart { emit(emptyList()) }

          fun setFiltering(requestType: ChannelsFilterType) {
              savedStateHandle[CHANNEL_FILTER_SAVED_STATE_KEY] = requestType
          }

          /*...*/
      }

      enum class ChannelsFilterType {
          ALL_CHANNELS, RECENT_CHANNELS, ARCHIVED_CHANNELS
      }SavingUIStateSnippets.kt

   Every time the user selects a new filter type, ``setFiltering`` is called.
   This saves a new value in ``SavedStateHandle`` stored with the key
   ``_CHANNEL_FILTER_SAVED_STATE_KEY_``. ``savedFilterType`` is a flow emitting
   the latest value stored to the key. ``filteredChannels`` is subscribed to the
   flow to perform the channel filtering.

   See the
   `SavedStateHandle  <#savedstate-stateflow>`__
   documentation for more information on the ``getStateFlow()`` API.

   .. rubric:: Summary
      :name: summary

   The following table summarizes the APIs covered in this section, and when to
   use each to save UI state:

   .. list-table::
      :header-rows: 1

      - 

         - Event
         - UI logic
         - Business logic in a ``ViewModel``
      - 

         - Configuration changes
         - ``rememberSaveable``
         - Automatic
      - 

         - System-initiated process death
         - ``rememberSaveable``
         - ``SavedStateHandle``

   The API to use depends on where the state is held and the logic that it
   requires. For state that is used in `UI logic  <#logic>`__, use
   ``rememberSaveable``. For state that is used in `business logic  <#logic>`__, if you hold it in
   a ``ViewModel``, save it using ``SavedStateHandle``.

   You should use the bundle APIs (``rememberSaveable`` and
   ``SavedStateHandle``) to store small amounts of UI state. This data is the
   minimum necessary to restore the UI back to its previous state, together with
   other storing mechanisms. For example, if you store the ID of a profile the
   user was looking at in the bundle, you can fetch heavy data, like profile
   details, from the data layer.

   For more information on the different ways of saving UI state, see the
   general `Saving UI State documentation  <#saving-states>`__ and the `data layer  <#data-layer>`__ page of the architecture guide.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Where to hoist state  <#state-hoisting>`__
   -  `State and Jetpack Compose  <#state>`__
   -  `Lists and grids  <#lists>`__

Last updated 2024-03-25 UTC.

/Architecture
=============

.. https://developer.android.google.cn/develop/ui/compose/architecture?hl=en

.. container:: devsite-article-body clearfix

   In Compose the UI is immutable—there's no way to update it after it's been
   drawn. What you can control is the state of your UI. Every time the state of
   the UI changes, Compose `recreates the parts of the UI tree that have changed  <#recomposition>`__. Composables can
   accept state and expose events—for example, a ``TextField`` accepts a value
   and exposes a callback ``onValueChange`` that requests the callback handler
   to change the value.

   .. code:: prettyprint

      var name by remember { mutableStateOf("") }
      OutlinedTextField(
          value = name,
          onValueChange = { name = it },
          label = { Text("Name") }
      )ArchitectureSnippets.kt

   Because composables accept state and expose events, the unidirectional data
   flow pattern fits well with Jetpack Compose. This guide focuses on how to
   implement the unidirectional data flow pattern in Compose, how to implement
   events and state holders, and how to work with ViewModels in Compose.

   **Note:**\  The other layers of your app—the data layer and the business
   layer—are not affected by adopting Jetpack Compose. To learn more about
   architecting all layers of your app, check out the `guide to app architecture  <#guide>`__.

   .. rubric:: Unidirectional data flow
      :name: udf

   A *unidirectional data flow* (UDF) is a design pattern where state flows down
   and events flow up. By following unidirectional data flow, you can decouple
   composables that display state in the UI from the parts of your app that
   store and change state.

   The UI update loop for an app using unidirectional data flow looks like this:

   -  **Event**: Part of the UI generates an event and passes it upward, such as
      a button click passed to the ViewModel to handle; or an event is passed
      from other layers of your app, such as indicating that the user session
      has expired.
   -  **Update state**: An event handler might change the state.
   -  **Display state**: The state holder passes down the state, and the UI
      displays it.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/state-unidirectional-flow.png
      :figclass: screenshot
      :width: 300px

      **Figure 1.** Unidirectional data flow.

   Following this pattern when using Jetpack Compose provides several
   advantages:

   -  **Testability**: Decoupling state from the UI that displays it makes it
      easier to test both in isolation.
   -  **State encapsulation**: Because state can only be updated in one place
      and there is only one source of truth for the state of a composable, it's
      less likely that you'll create bugs due to inconsistent states.
   -  **UI consistency**: All state updates are immediately reflected in the UI
      by the use of observable state holders, like ``StateFlow`` or
      ``LiveData``.

   .. rubric:: Unidirectional data flow in Jetpack Compose
      :name: udf-compose

   Composables work based on state and events. For example, a ``TextField`` is
   only updated when its ``value`` parameter is updated and it exposes an
   ``onValueChange`` callback—an event that requests the value to be changed to
   a new one. Compose defines the ``State`` object as a value holder, and
   changes to the state value trigger a recomposition. You can hold the state in
   a ``remember { mutableStateOf(value) }`` or a
   ``rememberSaveable { mutableStateOf(value)`` depending on how long you need
   to remember the value for.

   The type of the ``TextField`` composable's value is ``String``, so this can
   come from anywhere—from a hardcoded value, from a ViewModel, or passed in
   from the parent composable. You don't have to hold it in a ``State`` object,
   but you need to update the value when ``onValueChange`` is called.

   **Key Points:**

   ``mutableStateOf(value)`` creates a ``MutableState``, which is an observable
   type in Compose. Any changes to its value will schedule recomposition of any
   composable functions that read that value.

   ``remember`` stores objects in the composition, and forgets the object when
   the composable that called ``remember`` is removed from the composition.

   ``rememberSaveable`` retains the state across configuration changes by saving
   it in a ``Bundle``.

   **Note:**\  To learn more about state and state hoisting in Compose, see
   `State and Jetpack Compose  <#state>`__.

   .. rubric:: Define composable parameters
      :name: composable-parameters

   When defining the state parameters of a composable you should keep the
   following questions in mind:

   -  How reusable or flexible is the composable?
   -  How do the state parameters affect this composable's performance?

   To encourage decoupling and reuse, each composable should hold the least
   amount of information possible. For example, when building a composable to
   hold the header of a news article, prefer passing in only the information
   that needs to be displayed, rather than the entire news article:

   .. code:: prettyprint

      @Composable
      fun Header(title: String, subtitle: String) {
          // Recomposes when title or subtitle have changed.
      }

      @Composable
      fun Header(news: News) {
          // Recomposes when a new instance of News is passed in.
      }ArchitectureSnippets.kt

   Sometimes, using individual parameters also improves performance—for example,
   if ``News`` contains more information than just ``title`` and ``subtitle``,
   whenever a new instance of ``News`` is passed into ``Header(news)``, the
   composable will recompose, even if ``title`` and ``subtitle`` haven't
   changed.

   Consider carefully the number of parameters you pass in. Having a function
   with too many parameters decreases the ergonomics of the function, so in this
   case grouping them up in a class is preferred.

   .. rubric:: Events in Compose
      :name: architecture-events

   Every input to your app should be represented as an event: taps, text
   changes, and even timers or other updates. As these events change the state
   of your UI, the ``ViewModel`` should be the one to handle them and update the
   UI state.

   The UI layer should never change state outside of an event handler because
   this can introduce inconsistencies and bugs in your application.

   Prefer passing immutable values for state and event handler lambdas. This
   approach has the following benefits:

   -  You improve reusability.
   -  You ensure that your UI doesn't change the value of the state directly.
   -  You avoid concurrency issues because you make sure that the state isn't
      mutated from another thread.
   -  Often, you reduce code complexity.

   For example, a composable that accepts a ``String`` and a lambda as
   parameters can be called from many contexts and is highly reusable. Suppose
   that the top app bar in your app always displays text and has a back button.
   You can define a more generic ``MyAppTopAppBar`` composable that receives the
   text and the back button handle as parameters:

   .. code:: prettyprint

      @Composable
      fun MyAppTopAppBar(topAppBarText: String, onBackPressed: () -> Unit) {
          TopAppBar(
              title = {
                  Text(
                      text = topAppBarText,
                      textAlign = TextAlign.Center,
                      modifier = Modifier
                          .fillMaxSize()
                          .wrapContentSize(Alignment.Center)
                  )
              },
              navigationIcon = {
                  IconButton(onClick = onBackPressed) {
                      Icon(
                          Icons.Filled.ArrowBack,
                          contentDescription = localizedString
                      )
                  }
              },
              // ...
          )
      }ArchitectureSnippets.kt

   .. rubric:: ViewModels, states, and events: an example
      :name: example

   By using ``ViewModel`` and ``mutableStateOf``, you can also introduce
   unidirectional data flow in your app if one of the following is true:

   -  The state of your UI is exposed via observable state holders, like
      ``StateFlow`` or ``LiveData``.
   -  The ``ViewModel`` handles events coming from the UI or other layers of
      your app and updates the state holder based on the events.

   For example, when implementing a sign-in screen, tapping on a *Sign in*
   button should cause your app to display a progress spinner and a network
   call. If the login was successful, then your app navigates to a different
   screen; in case of an error the app shows a Snackbar. Here's how you would
   model the screen state and the event:

   The screen has four states:

   -  **Signed out**: when the user hasn't signed in yet.
   -  **In progress**: when your app is currently trying to sign the user in by
      performing a network call.
   -  **Error**: when an error occurred while signing in.
   -  **Signed in**: when the user is signed in.

   You can model these states as a sealed class. The ``ViewModel`` exposes the
   state as a ``State``, sets the initial state, and updates the state as
   needed. The ``ViewModel`` also handles the sign-in event by exposing an
   ``onSignIn()`` method.

   .. code:: prettyprint

      class MyViewModel : ViewModel() {
          private val _uiState = mutableStateOf<UiState>(UiState.SignedOut)
          val uiState: State<UiState>
              get() = _uiState

          // ...
      }ArchitectureSnippets.kt

   In addition to the ``mutableStateOf`` API, Compose `provides extensions  <#streams>`__ for ``LiveData``,
   ``Flow``, and ``Observable`` to register as a listener and represent the
   value as a state.

   .. code:: prettyprint

      class MyViewModel : ViewModel() {
          private val _uiState = MutableLiveData<UiState>(UiState.SignedOut)
          val uiState: LiveData<UiState>
              get() = _uiState

          // ...
      }

      @Composable
      fun MyComposable(viewModel: MyViewModel) {
          val uiState = viewModel.uiState.observeAsState()
          // ...
      }ArchitectureSnippets.kt

   .. rubric:: Learn more
      :name: additional-resources

   To learn more about architecture in Jetpack Compose, consult the following
   resources:

   .. rubric:: Samples
      :name: samples

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `State and Jetpack Compose  <#state>`__
   -  `Save UI state in Compose  <#state-saving>`__
   -  `Handle user input  <#user-input>`__

Last updated 2024-03-25 UTC.

/Architectural layering
=======================

.. https://developer.android.google.cn/develop/ui/compose/layering?hl=en

.. container:: devsite-article-body clearfix

   This page provides a high-level overview of the architectural layers that
   make up Jetpack Compose, and the core principles that inform this design.

   Jetpack Compose is not a single monolithic project; it is created from a
   number of modules which are assembled together to form a complete stack.
   Understanding the different modules that make up Jetpack Compose enables you
   to:

   -  Use the appropriate level of abstraction to build your app or library
   -  Understand when you can ‘drop down’ to a lower level for more control or
      customization
   -  Minimize your dependencies

   .. rubric:: Layers
      :name: anchor

   The major layers of Jetpack Compose are:

   |image-layering-major-layers|

   **Figure 1.** The major layers of Jetpack Compose.

   Each layer is built upon the lower levels, combining functionality to create
   higher level components. Each layer builds on public APIs of the lower layers
   to verify the module boundaries and enable you to replace any layer should
   you need to. Let's examine these layers from the bottom up.

   `Runtime  <#package-summary>`__
      This module provides the fundamentals of the Compose runtime such as
      `remember  <#remember>`__,
      `mutableStateOf  <#mutableStateOf>`__,
      the
      `@Composable  <#Composable>`__
      annotation and
      `SideEffect  <#SideEffect>`__.
      You might consider building directly upon this layer if you only need
      Compose’s tree management abilities, not its UI.
   `UI  <#package-summary>`__
      The UI layer is made up of multiple modules (
      `ui-text  <#package-summary>`__,
      `ui-graphics  <#package-summary>`__,
      `ui-tooling  <#package-summary>`__,
      etc.). These modules implement the fundamentals of the UI toolkit, such as
      ``LayoutNode``,
      `Modifier  <#Modifier>`__, input
      handlers, custom layouts, and drawing. You might consider building upon
      this layer if you only need fundamental concepts of a UI toolkit.
   `Foundation  <#package-summary>`__
      This module provides design system agnostic building blocks for Compose
      UI, like
      `Row  <#Row>`__
      and
      `Column  <#Column>`__,
      `LazyColumn  <#LazyColumn>`__,
      recognition of particular gestures, etc. You might consider building upon
      the foundation layer to create your own design system.
   `Material  <#package-summary>`__
      This module provides an implementation of the Material Design system for
      Compose UI, providing a theming system, styled components, ripple
      indications, icons. Build upon this layer when using Material Design in
      your app.

   .. rubric:: Design principles
      :name: design-principles

   A guiding principle for Jetpack Compose is to provide small, focused pieces
   of functionality that can be assembled (or composed) together, rather than a
   few monolithic components. This approach has a number of advantages.

   .. rubric:: Control
      :name: control

   Higher level components tend to do more for you, but limit the amount of
   direct control that you have. If you need more control, you can "drop down"
   to use a lower level component.

   For example, if you want to animate the color of a component you might use
   the
   `animateColorAsState  <#animateColorAsState>`__
   API:

   .. code:: prettyprint

      val color = animateColorAsState(if (condition) Color.Green else Color.Red)ArchitectureLayering.kt

   However, if you needed the component to always start out grey, you cannot do
   it with this API. Instead, you can drop down to use the lower level
   `Animatable  <#Animatable>`__
   API:

   .. code:: prettyprint

      val color = remember { Animatable(Color.Gray) }
      LaunchedEffect(condition) {
          color.animateTo(if (condition) Color.Green else Color.Red)
      }ArchitectureLayering.kt

   The higher level ``animateColorAsState`` API is itself built upon the lower
   level ``Animatable`` API. Using the lower level API is more complex but
   offers more control. Choose the level of abstraction that best suits your
   needs.

   .. rubric:: Customization
      :name: customization

   Assembling higher level components from smaller building blocks makes it far
   easier to customize components should you need to. For example, consider the
   `implementation <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material/material/src/commonMain/kotlin/androidx/compose/material/Button.kt>`__
   of
   `Button  <#Button>`__
   provided by the Material layer:

   .. code:: prettyprint

      @Composable
      fun Button(
          // …
          content: @Composable RowScope.() -> Unit
      ) {
          Surface(/* … */) {
              CompositionLocalProvider(/* … */) { // set LocalContentAlpha
                  ProvideTextStyle(MaterialTheme.typography.button) {
                      Row(
                          // …
                          content = content
                      )
                  }
              }
          }
      }ArchitectureLayering.kt

   A ``Button`` is assembled from 4 components:

   #. A material
      `Surface  <#Surface>`__
      providing the background, shape, click handling, etc.

   #. A
      `CompositionLocalProvider  <#CompositionLocalProvider>`__
      which changes the content’s alpha when the button is enabled or disabled

   #. A
      `ProvideTextStyle  <#ProvideTextStyle>`__
      sets the default text style to use

   #. A ``Row`` provides the default layout policy for the button's content

   We have omitted some parameters and comments to make the structure clearer,
   but the entire component is only around 40 lines of code because it simply
   assembles these 4 components to implement the button. Components like
   ``Button`` are opinionated about which parameters they expose, balancing
   enabling common customizations against an explosion of parameters that can
   make a component harder to use. Material components, for example, offer
   customizations specified in the Material Design system, making it easy to
   follow material design principles.

   If, however, you wish to make a customization beyond a component's
   parameters, then you can "drop down" a level and fork a component. For
   example, Material Design specifies that buttons should have a solid colored
   background. If you need a gradient background, this option is not supported
   by the ``Button`` parameters. In this case you can use the Material
   ``Button`` implementation as a reference and build your own component:

   .. code:: prettyprint

      @Composable
      fun GradientButton(
          // …
          background: List<Color>,
          modifier: Modifier = Modifier,
          content: @Composable RowScope.() -> Unit
      ) {
          Row(
              // …
              modifier = modifier
                  .clickable(onClick = {})
                  .background(
                      Brush.horizontalGradient(background)
                  )
          ) {
              CompositionLocalProvider(/* … */) { // set material LocalContentAlpha
                  ProvideTextStyle(MaterialTheme.typography.button) {
                      content()
                  }
              }
          }
      }ArchitectureLayering.kt

   The above implementation continues to use components from the Material layer,
   such as Material’s concepts of `current content alpha  <#emphasis>`__ and the current text style.
   However, it replaces the material ``Surface`` with a ``Row`` and styles it to
   achieve the desired appearance.

   **Caution:**\  When dropping down to a lower layer to customize a component,
   ensure that you do not degrade any functionality by, for example, neglecting
   accessibility support. Use the component you are forking as a guide.
   If you do not want to use Material concepts at all, for example if building
   your own bespoke design system, then you can drop down to purely using
   foundation layer components:

   .. code:: prettyprint

      @Composable
      fun BespokeButton(
          // …
          backgroundColor: Color,
          modifier: Modifier = Modifier,
          content: @Composable RowScope.() -> Unit
      ) {
          Row(
              // …
              modifier = modifier
                  .clickable(onClick = {})
                  .background(backgroundColor)
          ) {
              // No Material components used
              content()
          }
      }ArchitectureLayering.kt

   Jetpack Compose reserves the simplest names for the highest level components.
   For example,
   `androidx.compose.material.Text  <#Text>`__
   is built upon
   `androidx.compose.foundation.text.BasicText  <#BasicText>`__.
   This makes it possible to provide your own implementation with the most
   discoverable name if you wish to replace higher levels.

   **Caution:**\  Forking a component means that you will not benefit from any
   future additions or bug fixes from the upstream component.

   .. rubric:: Picking the right abstraction
      :name: pick-right-abstraction

   Compose’s philosophy of building layered, reusable components means that you
   should not always reach for the lower level building blocks. Many higher
   level components not only offer more functionality but often implement best
   practices such as supporting accessibility.

   For example, if you wanted to add gesture support to your custom component,
   you could build this from scratch using
   `Modifier.pointerInput  <#pointerInput>`__
   but there are other, higher level components built on top of this which may
   offer a better starting point, for example
   `Modifier.draggable  <#draggable>`__,
   `Modifier.scrollable  <#scrollable>`__
   or
   `Modifier.swipeable  <#swipeable>`__.

   As a rule, prefer building on the *highest-level* component which offers the
   functionality you need in order to benefit from the best practices they
   include.

   .. rubric:: Learn more
      :name: learn-more

   See the `Jetsnack sample <https://github.com/android/compose-samples/tree/main/Jetsnack>`__ for
   an example of building a custom design system.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Kotlin for Jetpack Compose  <#kotlin>`__
   -  `Lists and grids  <#lists>`__
   -  `Side-effects in Compose  <#side-effects>`__

Last updated 2024-05-03 UTC.

.. |image-layering-major-layers| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layering-major-layers.svg
   :width: 300px

/CompositionLocal
=================

.. https://developer.android.google.cn/develop/ui/compose/compositionlocal?hl=en

.. container:: devsite-article-body clearfix

   `CompositionLocal  <#CompositionLocal>`__
   is a tool for passing data down through the Composition implicitly. In this
   page, you'll learn what a ``CompositionLocal`` is in more detail, how to
   create your own ``CompositionLocal``, and know if a ``CompositionLocal`` is a
   good solution for your use case.

   .. rubric:: Introducing ``CompositionLocal``
      :name: intro

   Usually in Compose, `data flows down  <#architecture>`__
   through the UI tree as parameters to each composable function. This makes a
   composable’s dependencies explicit. This can however be cumbersome for data
   that is very frequently and widely used such as colors or type styles. See
   the following example:

   .. code:: prettyprint

      @Composable
      fun MyApp() {
          // Theme information tends to be defined near the root of the application
          val colors = colors()
      }

      // Some composable deep in the hierarchy
      @Composable
      fun SomeTextLabel(labelText: String) {
          Text(
              text = labelText,
              color = colors.onPrimary // ← need to access colors here
          )
      }CompositionLocalSnippets.kt

   To support not needing to pass the colors as an explicit parameter dependency
   to most composables, **Compose offers**
   `CompositionLocal  <#CompositionLocal>`__
   **which allows you to create tree-scoped named objects that can be used as an
   implicit way to have data flow through the UI tree.**

   ``CompositionLocal`` elements are usually provided with a value in a certain
   node of the UI tree. That value can be used by its composable descendants
   without declaring the ``CompositionLocal`` as a parameter in the composable
   function.

   **Key terms:** In this guide, we use the terms **Composition**, **UI tree**,
   and **UI hierarchy**. Although they might be used interchangeably in other
   guides, they have different meanings:

   **The Composition** is the record of the call graph of composable functions.

   The **UI tree** or **UI hierarchy** is the tree of
   `LayoutNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/LayoutNode.kt>`__
   constructed, updated, and maintained by the composition process.

   ``CompositionLocal`` is what the Material theme uses under the hood.
   `MaterialTheme  <#MaterialTheme>`__
   is an object that provides three ``CompositionLocal`` instances——colors,
   typography and shapes——allowing you to retrieve them later in any descendant
   part of the Composition. Specifically, these are the ``LocalColors``,
   ``LocalShapes``, and ``LocalTypography`` properties that you can access
   through the ``MaterialTheme`` ``colors``, ``shapes``, and ``typography``
   attributes.

   .. code:: prettyprint

      @Composable
      fun MyApp() {
          // Provides a Theme whose values are propagated down its `content`
          MaterialTheme {
              // New values for colors, typography, and shapes are available
              // in MaterialTheme's content lambda.

              // ... content here ...
          }
      }

      // Some composable deep in the hierarchy of MaterialTheme
      @Composable
      fun SomeTextLabel(labelText: String) {
          Text(
              text = labelText,
              // `primary` is obtained from MaterialTheme's
              // LocalColors CompositionLocal
              color = MaterialTheme.colors.primary
          )
      }CompositionLocalSnippets.kt

   A **``CompositionLocal`` instance is scoped to a part of the Composition** so
   you can provide different values at different levels of the tree. The
   `current  <#current>`__
   value of a ``CompositionLocal`` corresponds to the closest value provided by
   an ancestor in that part of the Composition.

   **To provide a new value to a ``CompositionLocal``, use
   the**\ `CompositionLocalProvider  <#CompositionLocalProvider>`__
   and its
   `provides  <#provides>`__
   infix function that associates a ``CompositionLocal`` key to a ``value``. The
   ``content`` lambda of the ``CompositionLocalProvider`` will get the provided
   value when accessing the ``current`` property of the ``CompositionLocal``.
   When a new value is provided, Compose recomposes parts of the Composition
   that read the ``CompositionLocal``.

   As an example of this, the
   `LocalContentAlpha  <#LocalContentAlpha>`__
   ``CompositionLocal`` contains the preferred content alpha used for text and
   iconography to emphasize or de-emphasize different parts of the UI. In the
   following example, ``CompositionLocalProvider`` is used to provide different
   values for different parts of the Composition.

   .. code:: prettyprint

      @Composable
      fun CompositionLocalExample() {
          MaterialTheme { // MaterialTheme sets ContentAlpha.high as default
              Column {
                  Text("Uses MaterialTheme's provided alpha")
                  CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                      Text("Medium value provided for LocalContentAlpha")
                      Text("This Text also uses the medium value")
                      CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.disabled) {
                          DescendantExample()
                      }
                  }
              }
          }
      }

      @Composable
      fun DescendantExample() {
          // CompositionLocalProviders also work across composable functions
          Text("This Text uses the disabled alpha now")
      }CompositionLocalSnippets.kt

   |image-compositionlocal-alpha|

   **Figure 1.** Preview of the ``CompositionLocalExample`` composable.

   In all the examples above, the ``CompositionLocal`` instances were internally
   used by Material composables. To access the current value of a
   ``CompositionLocal``, use its
   `current  <#current>`__
   property. In the following example, the current
   `Context  <#Context>`__ value of the
   `LocalContext  <#LocalContext>`__
   ``CompositionLocal`` that is commonly used in Android apps is used to format
   the text:

   .. code:: prettyprint

      @Composable
      fun FruitText(fruitSize: Int) {
          // Get `resources` from the current value of LocalContext
          val resources = LocalContext.current.resources
          val fruitText = remember(resources, fruitSize) {
              resources.getQuantityString(R.plurals.fruit_title, fruitSize)
          }
          Text(text = fruitText)
      }CompositionLocalSnippets.kt

   **Note:**\  ``CompositionLocal`` objects or constants are usually prefixed
   with ``Local`` to allow better discoverability with auto-complete in the IDE.

   .. rubric:: Creating your own ``CompositionLocal``
      :name: creating

   ``CompositionLocal`` is a **tool for passing data down through the
   Composition implicitly**.

   **Another key signal for using ``CompositionLocal`` is when the parameter is
   cross-cutting and intermediate layers of implementation should not be aware
   it exists**, because making those intermediate layers aware would limit the
   utility of the composable. For example, querying for Android permissions is
   afforded by a ``CompositionLocal`` under the hood. A media picker composable
   can add new functionality to access permission-protected content on the
   device without changing its API and requiring callers of the media picker to
   be aware of this added context used from the environment.

   However, ``CompositionLocal`` is not always the best solution. We discourage
   *overusing* ``CompositionLocal`` as it comes with some downsides:

   **``CompositionLocal`` makes a composable's behavior harder to reason
   about**. As they create implicit dependencies, callers of composables that
   use them need to make sure that a value for every ``CompositionLocal`` is
   satisfied.

   Furthermore, there might be no clear source of truth for this dependency as
   it can mutate in any part of the Composition. Thus, **debugging the app when
   a problem occurs can be more challenging** as you need to navigate up the
   Composition to see where the ``current`` value was provided. Tools such as
   *Find usages* in the IDE or the `Compose layout inspector  <#layout-inspector>`__ provide enough
   information to mitigate this issue.

   **Note:**\  ``CompositionLocal`` works well for foundational architecture and
   Jetpack Compose makes heavy use of it.

   .. rubric:: Deciding whether to use ``CompositionLocal``
      :name: deciding

   There are certain conditions that can make ``CompositionLocal`` a good
   solution for your use case:

   A **``CompositionLocal`` should have a good default value**. If there's no
   default value, you must guarantee that it is exceedingly difficult for a
   developer to get into a situation where a value for the ``CompositionLocal``
   isn't provided. Not providing a default value can cause problems and
   frustration when creating tests or previewing a composable that uses that
   ``CompositionLocal`` will always require it to be explicitly provided.

   **Avoid ``CompositionLocal`` for concepts that aren't thought as tree-scoped
   or sub-hierarchy scoped**. A ``CompositionLocal`` makes sense when it can be
   potentially used by any descendant, not by a few of them.

   If your use case doesn't meet these requirements, check out the `Alternatives to consider <#alternatives>`__ section before creating a
   ``CompositionLocal``.

   An example of a bad practice is creating a ``CompositionLocal`` that holds
   the ``ViewModel`` of a particular screen so that all composables in that
   screen can get a reference to the ``ViewModel`` to perform some logic. This
   is a bad practice because not all composables below a particular UI tree need
   to know about a ``ViewModel``. The good practice is to pass to composables
   only the information that they need following the pattern that `state flows down and events flow up  <#architecture>`__. This approach
   will make your composables more reusable and easier to test.

   .. rubric:: Creating a ``CompositionLocal``
      :name: creating-apis

   There are two APIs to create a ``CompositionLocal``:

   -  `compositionLocalOf  <#compositionLocalOf>`__:
      Changing the value provided during recomposition invalidates *only* the
      content that reads its
      `current  <#current>`__
      value.

   -  `staticCompositionLocalOf  <#staticCompositionLocalOf>`__:
      Unlike ``compositionLocalOf``, reads of a ``staticCompositionLocalOf`` are
      not tracked by Compose. Changing the value causes the entirety of the
      ``content`` lambda where the ``CompositionLocal`` is provided to be
      recomposed, instead of just the places where the ``current`` value is read
      in the Composition.

   If the value provided to the ``CompositionLocal`` is highly unlikely to
   change or will never change, use ``staticCompositionLocalOf`` to get
   performance benefits.

   For example, an app's design system might be opinionated in the way
   composables are elevated using a shadow for the UI component. Since the
   different elevations for the app should propagate throughout the UI tree, we
   use a ``CompositionLocal``. As the ``CompositionLocal`` value is derived
   conditionally based on the system theme, we use the ``compositionLocalOf``
   API:

   .. code:: prettyprint

      // LocalElevations.kt file

      data class Elevations(val card: Dp = 0.dp, val default: Dp = 0.dp)

      // Define a CompositionLocal global object with a default
      // This instance can be accessed by all composables in the app
      val LocalElevations = compositionLocalOf { Elevations() }CompositionLocalSnippets.kt

   .. rubric:: Providing values to a ``CompositionLocal``
      :name: providing-values

   **The**
   `CompositionLocalProvider  <#CompositionLocalProvider>`__\ **composable
   binds values to ``CompositionLocal`` instances for the given hierarchy**. To
   provide a new value to a ``CompositionLocal``, use the
   `provides  <#provides>`__
   infix function that associates a ``CompositionLocal`` key to a ``value`` as
   follows:

   .. code:: prettyprint

      // MyActivity.kt file

      class MyActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)

              setContent {
                  // Calculate elevations based on the system theme
                  val elevations = if (isSystemInDarkTheme()) {
                      Elevations(card = 1.dp, default = 1.dp)
                  } else {
                      Elevations(card = 0.dp, default = 0.dp)
                  }

                  // Bind elevation as the value for LocalElevations
                  CompositionLocalProvider(LocalElevations provides elevations) {
                      // ... Content goes here ...
                      // This part of Composition will see the `elevations` instance
                      // when accessing LocalElevations.current
                  }
              }
          }
      }CompositionLocalSnippets.kt

   .. rubric:: Consuming the ``CompositionLocal``
      :name: consuming

   `CompositionLocal.current  <#current>`__
   returns the value provided by the nearest ``CompositionLocalProvider`` that
   provides a value to that ``CompositionLocal``:

   .. code:: prettyprint

      @Composable
      fun SomeComposable() {
          // Access the globally defined LocalElevations variable to get the
          // current Elevations in this part of the Composition
          Card(elevation = LocalElevations.current.card) {
              // Content
          }
      }CompositionLocalSnippets.kt

   .. rubric:: Alternatives to consider
      :name: alternatives

   A ``CompositionLocal`` might be an excessive solution for some use cases. If
   your use case doesn't meet the criteria specified in the `Deciding whether to use CompositionLocal <#deciding>`__ section, another solution might likely be
   better suited for your use case.

   .. rubric:: Pass explicit parameters
      :name: explicit-params

   Being explicit about composable's dependencies is a good habit. We recommend
   that you **pass composables only what they need**. To encourage decoupling
   and reuse of composables, each composable should hold the least amount of
   information possible.

   .. code:: prettyprint

      @Composable
      fun MyComposable(myViewModel: MyViewModel = viewModel()) {
          // ...
          MyDescendant(myViewModel.data)
      }

      // Don't pass the whole object! Just what the descendant needs.
      // Also, don't  pass the ViewModel as an implicit dependency using
      // a CompositionLocal.
      @Composable
      fun MyDescendant(myViewModel: MyViewModel) { /* ... */ }

      // Pass only what the descendant needs
      @Composable
      fun MyDescendant(data: DataToDisplay) {
          // Display data
      }CompositionLocalSnippets.kt

   .. rubric:: Inversion of control
      :name: inversion-of-control

   Another way to avoid passing unnecessary dependencies to a composable is via
   *inversion of control*. Instead of the descendant taking in a dependency to
   execute some logic, the parent does that instead.

   See the following example where a descendant needs to trigger the request to
   load some data:

   .. code:: prettyprint

      @Composable
      fun MyComposable(myViewModel: MyViewModel = viewModel()) {
          // ...
          MyDescendant(myViewModel)
      }

      @Composable
      fun MyDescendant(myViewModel: MyViewModel) {
          Button(onClick = { myViewModel.loadData() }) {
              Text("Load data")
          }
      }CompositionLocalSnippets.kt

   Depending on the case, ``MyDescendant`` might have a lot of responsibility.
   Also, passing ``MyViewModel`` as a dependency makes ``MyDescendant`` less
   reusable since they're now coupled together. Consider the alternative that
   doesn't pass the dependency into the descendant and uses inversion of control
   principles that makes the ancestor responsible for executing the logic:

   .. code:: prettyprint

      @Composable
      fun MyComposable(myViewModel: MyViewModel = viewModel()) {
          // ...
          ReusableLoadDataButton(
              onLoadClick = {
                  myViewModel.loadData()
              }
          )
      }

      @Composable
      fun ReusableLoadDataButton(onLoadClick: () -> Unit) {
          Button(onClick = onLoadClick) {
              Text("Load data")
          }
      }CompositionLocalSnippets.kt

   This approach can be better suited for some use cases as it **decouples the
   child from its immediate ancestors**. Ancestor composables tend to become
   more complex in favor of having more flexible lower-level composables.

   Similarly, **``@Composable`` content lambdas can be used in the same way to
   get the same benefits**:

   .. code:: prettyprint

      @Composable
      fun MyComposable(myViewModel: MyViewModel = viewModel()) {
          // ...
          ReusablePartOfTheScreen(
              content = {
                  Button(
                      onClick = {
                          myViewModel.loadData()
                      }
                  ) {
                      Text("Confirm")
                  }
              }
          )
      }

      @Composable
      fun ReusablePartOfTheScreen(content: @Composable () -> Unit) {
          Column {
              // ...
              content()
          }
      }CompositionLocalSnippets.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Anatomy of a theme in Compose  <#anatomy>`__
   -  `Using Views in Compose  <#views-in-compose>`__
   -  `Kotlin for Jetpack Compose  <#kotlin>`__

Last updated 2024-05-03 UTC.

.. |image-compositionlocal-alpha| image:: https://developer.android.google.cn/static/develop/ui/compose/images/compositionlocal-alpha.png
   :width: 500px

/Navigation
===========

.. https://developer.android.google.cn/develop/ui/compose/navigation?hl=en

.. container:: devsite-article-body clearfix

   The `Navigation component  <#navigation>`__ provides support for Jetpack
   Compose applications. You can navigate between composables while taking
   advantage of the Navigation component's infrastructure and features.

   **Note:**\  If you are not familiar with Compose, review the `Jetpack Compose  <#compose>`__ resources before continuing.

   .. rubric:: Setup
      :name: setup

   To support Compose, use the following dependency in your app module's
   ``build.gradle`` file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   def nav_version = "2.7.7"

                   implementation "androidx.navigation:navigation-compose:$nav_version"
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   val nav_version = "2.7.7"

                   implementation("androidx.navigation:navigation-compose:$nav_version")
               }

   .. rubric:: Get started
      :name: getting-started

   When implementing navigation in an app, implement a navigation host, graph,
   and controller. For more information, see the
   `Navigation  <#get-started>`__ overview.

   .. rubric:: Create a NavController
      :name: navcontroller

   For information on how to create a ``NavController`` in Compose, see the
   Compose section of `Create a navigation controller  <#navcontroller>`__.

   .. rubric:: Create a NavHost
      :name: create-navhost

   For information on how to create a ``NavHost`` in Compose, see the Compose
   section of `Design your navigation graph  <#compose>`__.

   .. rubric:: Navigate to a composable
      :name: nav-to-composable

   For information on navigating to a Composable, see `Navigate to a destination  <#navigate>`__ in the architecture
   documentation.

   .. rubric:: Navigate with arguments
      :name: nav-with-args

   Navigation Compose also supports passing arguments between composable
   destinations. In order to do this, you need to add argument placeholders to
   your route, similar to how you `add arguments to a deep link  <#implicit>`__ when using the base
   navigation library:

   .. code:: prettyprint

      NavHost(startDestination = "profile/{userId}") {
          ...
          composable("profile/{userId}") {...}
      }

   By default, all arguments are parsed as strings. The ``arguments`` parameter
   of ``composable()`` accepts a list of
   `NamedNavArgument  <#NamedNavArgument>`__
   objects. You can quickly create a ``NamedNavArgument`` using the
   `navArgument()  <#navArgument>`__
   method and then specify its exact ``type``:

   .. code:: prettyprint

      NavHost(startDestination = "profile/{userId}") {
          ...
          composable(
              "profile/{userId}",
              arguments = listOf(navArgument("userId") { type = NavType.StringType })
          ) {...}
      }

   You should extract the arguments from the
   `NavBackStackEntry  <#NavBackStackEntry>`__
   that is available in the lambda of the ``composable()`` function.

   .. code:: prettyprint

      composable("profile/{userId}") { backStackEntry ->
          Profile(navController, backStackEntry.arguments?.getString("userId"))
      }

   To pass the argument to the destination, you need to add append it to the
   route when you make the ``navigate`` call:

   .. code:: prettyprint

      navController.navigate("profile/user1234")

   For a list of supported types, see `Pass data between destinations  <#supported_argument_types>`__.

   .. rubric:: Retrieve complex data when navigating
      :name: retrieving-complex-data

   It is strongly advised not to pass around complex data objects when
   navigating, but instead pass the minimum necessary information, such as a
   unique identifier or other form of ID, as arguments when performing
   navigation actions:

   .. code:: prettyprint

      // Pass only the user ID when navigating to a new destination as argument
      navController.navigate("profile/user1234")

   Complex objects should be stored as data in a single source of truth, such as
   the data layer. Once you land on your destination after navigating, you can
   then load the required information from the single source of truth by using
   the passed ID. To retrieve the arguments in your ``ViewModel`` that's
   responsible for accessing the data layer, use the
   `SavedStateHandle  <#savedstatehandle>`__
   of the ``ViewModel``:

   .. code:: prettyprint

      class UserViewModel(
          savedStateHandle: SavedStateHandle,
          private val userInfoRepository: UserInfoRepository
      ) : ViewModel() {

          private val userId: String = checkNotNull(savedStateHandle["userId"])

          // Fetch the relevant user information from the data layer,
          // ie. userInfoRepository, based on the passed userId argument
          private val userInfo: Flow<UserInfo> = userInfoRepository.getUserInfo(userId)

      // …

      }

   This approach helps prevent data loss during configuration changes and any
   inconsistencies when the object in question is being updated or mutated.

   For a more in depth explanation on why you should avoid passing complex data
   as arguments, as well as a list of supported argument types, see `Pass data between destinations  <#supported_argument_types>`__.

   .. rubric:: Add optional arguments
      :name: optional-args

   Navigation Compose also supports optional navigation arguments. Optional
   arguments differ from required arguments in two ways:

   -  They must be included using query parameter syntax
      (``"?argName={argName}"``)
   -  They must have a ``defaultValue`` set, or have ``nullable = true`` (which
      implicitly sets the default value to ``null``)

   This means that all optional arguments must be explicitly added to the
   ``composable()`` function as a list:

   .. code:: prettyprint

      composable(
          "profile?userId={userId}",
          arguments = listOf(navArgument("userId") { defaultValue = "user1234" })
      ) { backStackEntry ->
          Profile(navController, backStackEntry.arguments?.getString("userId"))
      }

   Now, even if there is no argument passed to the destination, the
   ``defaultValue``, "user1234", is used instead.

   The structure of handling the arguments through the routes means that your
   composables remain completely independent of Navigation and makes them much
   more testable.

   .. rubric:: Deep links
      :name: deeplinks

   Navigation Compose supports implicit deep links that can be defined as part
   of the ``composable()`` function as well. Its ``deepLinks`` parameter accepts
   a list of `NavDeepLink  <#NavDeepLink>`__
   objects which can be quickly created using the
   `navDeepLink()  <#navDeepLink>`__
   method:

   .. code:: prettyprint

      val uri = "https://www.example.com"

      composable(
          "profile?id={id}",
          deepLinks = listOf(navDeepLink { uriPattern = "$uri/{id}" })
      ) { backStackEntry ->
          Profile(navController, backStackEntry.arguments?.getString("id"))
      }

   These deep links let you associate a specific URL, action or mime type with a
   composable. By default, these deep links are not exposed to external apps. To
   make these deep links externally available you must add the appropriate
   ``<intent-filter>`` elements to your app's ``manifest.xml`` file. To enable
   the deep link in the preceding example, you should add the following inside
   of the ``<activity>`` element of the manifest:

   .. code:: prettyprint

      <activity …>
        <intent-filter>
          ...
          <data android:scheme="https" android:host="www.example.com" />
        </intent-filter>
      </activity>

   Navigation automatically deep links into that composable when the deep link
   is triggered by another app.

   These same deep links can also be used to build a ``PendingIntent`` with the
   appropriate deep link from a composable:

   .. code:: prettyprint

      val id = "exampleId"
      val context = LocalContext.current
      val deepLinkIntent = Intent(
          Intent.ACTION_VIEW,
          "https://www.example.com/$id".toUri(),
          context,
          MyActivity::class.java
      )

      val deepLinkPendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {
          addNextIntentWithParentStack(deepLinkIntent)
          getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT)
      }

   You can then use this ``deepLinkPendingIntent`` like any other
   ``PendingIntent`` to open your app at the deep link destination.

   .. rubric:: Nested Navigation
      :name: nested-nav

   For information on how to create nested navigation graphs, see `Nested graphs  <#nested-graphs>`__.

   .. rubric:: Integration with the bottom nav bar
      :name: bottom-nav

   By defining the ``NavController`` at a higher level in your composable
   hierarchy, you can connect Navigation with other components such as the
   bottom navigation component. Doing this lets you navigate by selecting the
   icons in the bottom bar.

   To use the
   `BottomNavigation  <#BottomNavigation>`__
   and
   `BottomNavigationItem  <#BottomNavigationItem>`__
   components, add the ``androidx.compose.material`` dependency to your Android
   application.

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   implementation "androidx.compose.material:material:1.6.7"
               }

               android {
                   buildFeatures {
                       compose true
                   }

                   composeOptions {
                       kotlinCompilerExtensionVersion = "1.5.13"
                   }

                   kotlinOptions {
                       jvmTarget = "1.8"
                   }
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   implementation("androidx.compose.material:material:1.6.7")
               }

               android {
                   buildFeatures {
                       compose = true
                   }

                   composeOptions {
                       kotlinCompilerExtensionVersion = "1.5.13"
                   }

                   kotlinOptions {
                       jvmTarget = "1.8"
                   }
               }

   To link the items in a bottom navigation bar to routes in your navigation
   graph, it is recommended to define a sealed class, such as ``Screen`` seen
   here, that contains the route and String resource ID for the destinations.

   .. code:: prettyprint

      sealed class Screen(val route: String, @StringRes val resourceId: Int) {
          object Profile : Screen("profile", R.string.profile)
          object FriendsList : Screen("friendslist", R.string.friends_list)
      }

   Then place those items in a list that can be used by the
   `BottomNavigationItem  <#BottomNavigationItem>`__:

   .. code:: prettyprint

      val items = listOf(
         Screen.Profile,
         Screen.FriendsList,
      )

   In your
   `BottomNavigation  <#BottomNavigation>`__
   composable, get the current ``NavBackStackEntry`` using the
   ``currentBackStackEntryAsState()`` function. This entry gives you access to
   the current ``NavDestination``. The selected state of each
   ``BottomNavigationItem`` can then be determined by comparing the item's route
   with the route of the current destination and its parent destinations to
   handle cases when you are using `nested navigation <#nested-nav)>`__ using
   the `NavDestination  <#NavDestination>`__
   hierarchy.

   The item's route is also used to connect the ``onClick`` lambda to a call to
   ``navigate`` so that tapping on the item navigates to that item. By using the
   ``saveState`` and ``restoreState`` flags, the state and back stack of that
   item is correctly saved and restored as you swap between bottom navigation
   items.

   .. code:: prettyprint

      val navController = rememberNavController()
      Scaffold(
        bottomBar = {
          BottomNavigation {
            val navBackStackEntry by navController.currentBackStackEntryAsState()
            val currentDestination = navBackStackEntry?.destination
            items.forEach { screen ->
              BottomNavigationItem(
                icon = { Icon(Icons.Filled.Favorite, contentDescription = null) },
                label = { Text(stringResource(screen.resourceId)) },
                selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true,
                onClick = {
                  navController.navigate(screen.route) {
                    // Pop up to the start destination of the graph to
                    // avoid building up a large stack of destinations
                    // on the back stack as users select items
                    popUpTo(navController.graph.findStartDestination().id) {
                      saveState = true
                    }
                    // Avoid multiple copies of the same destination when
                    // reselecting the same item
                    launchSingleTop = true
                    // Restore state when reselecting a previously selected item
                    restoreState = true
                  }
                }
              )
            }
          }
        }
      ) { innerPadding ->
        NavHost(navController, startDestination = Screen.Profile.route, Modifier.padding(innerPadding)) {
          composable(Screen.Profile.route) { Profile(navController) }
          composable(Screen.FriendsList.route) { FriendsList(navController) }
        }
      }

   Here you take advantage of the
   ``NavController.currentBackStackEntryAsState()`` method to hoist the
   ``navController`` state out of the ``NavHost`` function, and share it with
   the ``BottomNavigation`` component. This means the ``BottomNavigation``
   automatically has the most up-to-date state.

   .. rubric:: Type safety in Navigation Compose
      :name: type-safety

   .. container:: video-wrapper

   The code on this page isn't type-safe. You can call the ``navigate()``
   function with inexisting routes or incorrect arguments. However, you can
   structure your Navigation code to be type-safe at runtime. By doing so, you
   can avoid crashes and make sure that:

   -  The arguments you provide when navigating to a destination or navigation
      graph are the right types and that all required arguments are present.
   -  The arguments you retrieve from ``SavedStateHandle`` are the correct
      types.

   For more information about this, see `Type safety in Kotlin DSL and Navigation Compose  <#navigation-type-safety>`__.

   .. rubric:: Interoperability
      :name: interoperability

   If you want to use the Navigation component with Compose, you have two
   options:

   -  Define a navigation graph with the Navigation component for fragments.
   -  Define a navigation graph with a ``NavHost`` in Compose using Compose
      destinations. This is possible only if all of the screens in the
      navigation graph are composables.

   Therefore, the recommendation for mixed Compose and Views apps is to use the
   Fragment-based Navigation component. Fragments will then hold View-based
   screens, Compose screens, and screens that use both Views and Compose. Once
   each Fragment's contents are in Compose, the next step is to tie all of those
   screens together with Navigation Compose and remove all of the Fragments.

   .. rubric:: Navigate from Compose with Navigation for fragments
      :name: navigate-from-Compose

   In order to change destinations inside Compose code, you expose events that
   can be passed to and triggered by any composable in the hierarchy:

   .. code:: prettyprint

      @Composable
      fun MyScreen(onNavigate: (Int) -> Unit) {
          Button(onClick = { onNavigate(R.id.nav_profile) } { /* ... */ }
      }

   In your fragment, you make the bridge between Compose and the fragment-based
   Navigation component by finding the ``NavController`` and navigating to the
   destination:

   .. code:: prettyprint

      override fun onCreateView( /* ... */ ) {
          setContent {
              MyScreen(onNavigate = { dest -> findNavController().navigate(dest) })
          }
      }

   Alternatively, you can pass the ``NavController`` down your Compose
   hierarchy. However, exposing simple functions is much more reusable and
   testable.

   .. rubric:: Testing
      :name: testing

   Decouple the navigation code from your composable destinations to enable
   testing each composable in isolation, separate from the ``NavHost``
   composable.

   This means that you shouldn't pass the ``navController`` `directly into any composable  <#design>`__ and instead pass navigation
   callbacks as parameters. This allows all your composables to be individually
   testable, as they don't require an instance of ``navController`` in tests.

   The level of indirection provided by the ``composable`` lambda is what lets
   you separate your Navigation code from the composable itself. This works in
   two directions:

   -  Pass only parsed arguments into your composable
   -  Pass lambdas that should be triggered by the composable to navigate,
      rather than the ``NavController`` itself.

   For example, a ``Profile`` composable that takes in a ``userId`` as input and
   allows users to navigate to a friend's profile page might have the signature
   of:

   .. code:: prettyprint

      @Composable
      fun Profile(
          userId: String,
          navigateToFriendProfile: (friendUserId: String) -> Unit
      ) {
       …
      }

   This way, the ``Profile`` composable works independently from Navigation,
   allowing it to be tested independently. The ``composable`` lambda would
   encapsulate the minimal logic needed to bridge the gap between the Navigation
   APIs and your composable:

   .. code:: prettyprint

      composable(
          "profile?userId={userId}",
          arguments = listOf(navArgument("userId") { defaultValue = "user1234" })
      ) { backStackEntry ->
          Profile(backStackEntry.arguments?.getString("userId")) { friendUserId ->
              navController.navigate("profile?userId=$friendUserId")
          }
      }

   It is recommended to write tests that cover your app navigation requirements
   by testing the ``NavHost``, navigation actions passed to your composables as
   well as your individual screen composables.

   .. rubric:: Testing the ``NavHost``
      :name: testing-nav-host

   To begin testing your ``NavHost`` , add the following navigation-testing
   dependency:

   .. code:: prettyprint

      dependencies {
      // ...
        androidTestImplementation "androidx.navigation:navigation-testing:$navigationVersion"
        // ...
      }

   You can set up your ``NavHost`` test subject and pass an instance of the
   ``navController`` instance to it. For this, the navigation testing artifact
   provides a
   `TestNavHostController  <#TestNavHostController>`__.
   A UI test that verifies the start destination of your app and ``NavHost``
   would look like this:

   .. code:: prettyprint

      class NavigationTest {

          @get:Rule
          val composeTestRule = createComposeRule()
          lateinit var navController: TestNavHostController

          @Before
          fun setupAppNavHost() {
              composeTestRule.setContent {
                  navController = TestNavHostController(LocalContext.current)
                  navController.navigatorProvider.addNavigator(ComposeNavigator())
                  AppNavHost(navController = navController)
              }
          }

          // Unit test
          @Test
          fun appNavHost_verifyStartDestination() {
              composeTestRule
                  .onNodeWithContentDescription("Start Screen")
                  .assertIsDisplayed()
          }
      }

   .. rubric:: Testing navigation actions
      :name: testing-actions

   You can test your navigation implementation in multiple ways, by performing
   clicks on the UI elements and then either verifying the displayed destination
   or by comparing the expected route against the current route.

   As you want to test your concrete app's implementation, clicks on the UI are
   preferable. To learn how to test this alongside individual composable
   functions in isolation, make sure to check out the `Testing in Jetpack Compose  <#jetpack-compose-testing>`__ codelab.

   You also can use the ``navController`` to check your assertions by comparing
   the current String route to the expected one, using ``navController``'s
   ``currentBackStackEntry``:

   .. code:: prettyprint

      @Test
      fun appNavHost_clickAllProfiles_navigateToProfiles() {
          composeTestRule.onNodeWithContentDescription("All Profiles")
              .performScrollTo()
              .performClick()

          val route = navController.currentBackStackEntry?.destination?.route
          assertEquals(route, "profiles")
      }

   For more guidance on Compose testing basics, see `Testing your Compose layout  <#testing>`__ and the `Testing in Jetpack Compose  <#jetpack-compose-testing>`__ codelab. To learn more about
   advanced testing of navigation code, visit the `Test Navigation  <#navigation-testing>`__ guide.

   .. rubric:: Learn more
      :name: learn-more

   To learn more about Jetpack Navigation, see `Get started with the Navigation component  <#navigation-getting-started>`__ or take the
   `Jetpack Compose Navigation codelab  <#jetpack-compose-navigation>`__.

   To learn how to design your app's navigation so it adapts to different screen
   sizes, orientations, and form factors, see `Navigation for responsive UIs  <#navigation-for-responsive-uis>`__.

   To learn about a more advanced Compose navigation implementation in a
   modularized app, including concepts like nested graphs and bottom navigation
   bar integration, take a look at the `Now in Android <https://github.com/android/nowinandroid>`__ app on GitHub.

   .. rubric:: Samples
      :name: samples

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Material Design 2 in Compose  <#material>`__
   -  `Migrate Jetpack Navigation to Navigation Compose  <#navigation>`__
   -  `Where to hoist state  <#state-hoisting>`__

Last updated 2024-05-03 UTC.

/Overview: Develop your app's layout
====================================

.. https://developer.android.google.cn/develop/ui/compose/layouts?hl=en

.. container:: devsite-article-body clearfix

   Jetpack Compose makes it easy to design an efficient layout for your app.

   The following pages provide details on how to design and implement your
   layout:

   -  `Layout basics  <#basics>`__: Learn about the
      building blocks for a straightforward app UI.
   -  `Material components and layouts  <#material>`__: Learn about Material
      components and layouts in Compose.
   -  `Custom layouts  <#custom>`__: Learn how to take
      control of your app's layout, and how to design a custom layout of your
      own.
   -  `Build adaptive layouts  <#adaptive>`__: Learn
      how to use Compose to build layouts that adapt to different screen sizes,
      orientations, and form factors.
   -  `Alignment lines  <#alignment-lines>`__: Learn
      how to create custom alignment lines to precisely align and position your
      UI elements.
   -  `Intrinsic measurements  <#intrinsic-measurements>`__:
      Learn how to set an intrinsic height or width for your UI elements, giving
      you precise control over how the elements are arranged in the layout.
   -  `ConstraintLayout  <#constraintlayout>`__: Learn
      how to use ``ConstraintLayout`` in your Compose UI.

   .. rubric:: Learn more
      :name: nextsteps

   To learn more about Compose layouts, try the `Layouts in Jetpack Compose codelab  <#jetpack-compose-layouts>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Get started with Jetpack Compose  <#documentation>`__
   -  `ConstraintLayout in Compose  <#constraintlayout>`__

Last updated 2024-05-03 UTC.

/Layout basics
==============

.. https://developer.android.google.cn/develop/ui/compose/layouts/basics?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   Jetpack Compose makes it much easier to design and build your app's UI.
   Compose transforms state into UI elements, via:

   #. Composition of elements
   #. Layout of elements
   #. Drawing of elements

   |Compose transforming state to UI via composition, layout, drawing|

   This document focuses on the layout of elements, explaining some of the
   building blocks Compose provides to help you lay out your UI elements.

   .. rubric:: Goals of layouts in Compose
      :name: layout-goals

   The Jetpack Compose implementation of the layout system has two main goals:

   -  `High performance <#performance>`__
   -  Ability to easily write `custom layouts  <#custom>`__

   **Note:**\  With the Android View system, you could face some performance
   issues when nesting certain Views such as ``RelativeLayout``. Since Compose
   avoids multiple measurements, you can nest as deeply as you want without
   affecting performance.

   .. rubric:: Basics of composable functions
      :name: composable-functions

   Composable functions are the basic building block of Compose. A composable
   function is a function emitting ``Unit`` that describes some part of your UI.
   The function takes some input and generates what's shown on the screen. For
   more information about composables, take a look at the `Compose mental model  <#mental-model>`__ documentation.

   A composable function might emit several UI elements. However, if you don't
   provide guidance on how they should be arranged, Compose might arrange the
   elements in a way you don't like. For example, this code generates two text
   elements:

   .. code:: prettyprint

      @Composable
      fun ArtistCard() {
          Text("Alfred Sisley")
          Text("3 minutes ago")
      }LayoutBasicsSnippets.kt

   Without guidance on how you want them arranged, Compose stacks the text
   elements on top of each other, making them unreadable:

   |Two text elements drawn on top of each other, making the text unreadable|

   Compose provides a collection of ready-to-use layouts to help you arrange
   your UI elements, and makes it easy to define your own, more-specialized
   layouts.

   .. rubric:: Standard layout components
      :name: standard-layouts

   In many cases, you can just use `Compose's standard layout elements  <#package-summary>`__.

   Use
   `Column  <#Column>`__
   to place items vertically on the screen.

   .. code:: prettyprint

      @Composable
      fun ArtistCardColumn() {
          Column {
              Text("Alfred Sisley")
              Text("3 minutes ago")
          }
      }LayoutBasicsSnippets.kt

   |Two text elements arranged in a column layout, so the text is readable|

   Similarly, use
   `Row  <#Row>`__
   to place items horizontally on the screen. Both ``Column`` and ``Row``
   support configuring the alignment of the elements they contain.

   .. code:: prettyprint

      @Composable
      fun ArtistCardRow(artist: Artist) {
          Row(verticalAlignment = Alignment.CenterVertically) {
              Image(bitmap = artist.image, contentDescription = "Artist image")
              Column {
                  Text(artist.name)
                  Text(artist.lastSeenOnline)
              }
          }
      }
      LayoutBasicsSnippets.kt

   |Shows a more complex layout, with a small graphic next to a column of text
   elements|

   Use
   `Box  <#Box>`__
   to put elements on top of another. ``Box`` also supports configuring specific
   alignment of the elements it contains.

   .. code:: prettyprint

      @Composable
      fun ArtistAvatar(artist: Artist) {
          Box {
              Image(bitmap = artist.image, contentDescription = "Artist image")
              Icon(Icons.Filled.Check, contentDescription = "Check mark")
          }
      }LayoutBasicsSnippets.kt

   |Shows two elements stacked on one another|

   Often these building blocks are all you need. You can write your own
   composable function to combine these layouts into a more elaborate layout
   that suits your app.

   |Compares three simple layout composables: column, row, and box|

   **Note:**\  Compose handles nested layouts efficiently, making them a great
   way to design a complicated UI. This is an improvement from Android Views,
   where you need to avoid nested layouts for performance reasons.
   To set children's position within a ``Row``, set the
   ``horizontalArrangement`` and ``verticalAlignment`` arguments. For a
   ``Column``, set the ``verticalArrangement`` and ``horizontalAlignment``
   arguments:

   .. code:: prettyprint

      @Composable
      fun ArtistCardArrangement(artist: Artist) {
          Row(
              verticalAlignment = Alignment.CenterVertically,
              horizontalArrangement = Arrangement.End
          ) {
              Image(bitmap = artist.image, contentDescription = "Artist image")
              Column { /*...*/ }
          }
      }LayoutBasicsSnippets.kt

   |Items are aligned to the right|

   .. rubric:: The layout model
      :name: model

   In the layout model, the UI tree is laid out in a single pass. Each node is
   first asked to measure itself, then measure any children recursively, passing
   size constraints down the tree to children. Then, leaf nodes are sized and
   placed, with the resolved sizes and placement instructions passed back up the
   tree.

   Briefly, parents measure before their children, but are sized and placed
   after their children.

   Consider the following ``SearchResult`` function.

   .. code:: prettyprint

      @Composable
      fun SearchResult() {
          Row {
              Image(
                  // ...
              )
              Column {
                  Text(
                      // ...
                  )
                  Text(
                      // ...
                  )
              }
          }
      }LayoutBasicsSnippets.kt

   This function yields the following UI tree.

   .. code:: kotlin

      SearchResult
        Row
          Image
          Column
            Text
            Text

   In the ``SearchResult`` example, the UI tree layout follows this order:

   #. The root node ``Row`` is asked to measure.
   #. The root node ``Row`` asks its first child, ``Image``, to measure.
   #. ``Image`` is a leaf node (that is, it has no children), so it reports a
      size and returns placement instructions.
   #. The root node ``Row`` asks its second child, ``Column``, to measure.
   #. The ``Column`` node asks its first ``Text`` child to measure.
   #. The first ``Text`` node is a leaf node, so it reports a size and returns
      placement instructions.
   #. The ``Column`` node asks its second ``Text`` child to measure.
   #. The second ``Text`` node is a leaf node, so it reports a size and returns
      placement instructions.
   #. Now that the ``Column`` node has measured, sized, and, placed its
      children, it can determine its own size and placement.
   #. Now that the root node ``Row`` has measured, sized, and placed its
      children, it can determine its own size and placement.

   |Ordering of measuring, sizing, and placement in Search Result UI tree|

   .. rubric:: Performance
      :name: performance

   Compose achieves high performance by measuring children only once.
   Single-pass measurement is good for performance, allowing Compose to
   efficiently handle deep UI trees. If an element measured its child twice and
   that child measured each of its children twice and so on, a single attempt to
   lay out a whole UI would have to do a lot of work, making it hard to keep
   your app performant.

   If your layout needs multiple measurements for some reason, Compose offers a
   special system, *intrinsic measurements*. You can read more about this
   feature in `Intrinsic measurements in Compose layouts  <#intrinsic-measurements>`__.

   Since measurement and placement are distinct sub-phases of the layout pass,
   any changes that only affects placement of items, not measurement, can be
   executed separately.

   .. rubric:: Using modifiers in your layouts
      :name: modifiers

   As discussed in `Compose modifiers  <#modifiers>`__, you
   can use modifiers to decorate or augment your composables. Modifiers are
   essential for customizing your layout. For example, here we chain several
   modifiers to customize the ``ArtistCard``:

   .. code:: prettyprint

      @Composable
      fun ArtistCardModifiers(
          artist: Artist,
          onClick: () -> Unit
      ) {
          val padding = 16.dp
          Column(
              Modifier
                  .clickable(onClick = onClick)
                  .padding(padding)
                  .fillMaxWidth()
          ) {
              Row(verticalAlignment = Alignment.CenterVertically) { /*...*/ }
              Spacer(Modifier.size(padding))
              Card(
                  elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
              ) { /*...*/ }
          }
      }LayoutBasicsSnippets.kt

   |A still more complex layout, using modifiers to change how the graphics are
   arranged and which areas respond to user input|

   In the code above, notice different modifier functions used together.

   -  ``clickable`` makes a composable react to user input and shows a ripple.
   -  ``padding`` puts space around an element.
   -  ``fillMaxWidth`` makes the composable fill the maximum width given to it
      from its parent.
   -  ``size()`` specifies an element's preferred width and height.

   **Note:**\  Among other things, modifiers play a role similar to that of
   layout parameters in view-based layouts. However, since modifiers are
   sometimes scope-specific, they offer type safety and also help you to
   discover and understand what is available and applicable to a certain layout.
   With XML layouts, it is sometimes hard to find out if a particular layout
   attribute is applicable to a given view.

   .. rubric:: Scrollable layouts
      :name: scrollable

   Learn more about scrollable layouts in the `Compose gestures documentation  <#understand-gestures>`__.

   For lists and lazy lists, check out the `Compose lists documentation  <#lists>`__.

   .. rubric:: Responsive layouts
      :name: responsive-layouts

   A layout should be designed with consideration of different screen
   orientations and form factor sizes. Compose offers out of the box a few
   mechanisms to facilitate adapting your composable layouts to various screen
   configurations.

   .. rubric:: Constraints
      :name: constraints

   In order to know the constraints coming from the parent and design the layout
   accordingly, you can use a ``BoxWithConstraints``.
   The `measurement constraints  <#BoxWithConstraintsScope>`__
   can be found in the scope of the content lambda. You can use these
   measurement constraints to compose different layouts for different screen
   configurations:

   .. code:: prettyprint

      @Composable
      fun WithConstraintsComposable() {
          BoxWithConstraints {
              Text("My minHeight is $minHeight while my maxWidth is $maxWidth")
          }
      }LayoutBasicsSnippets.kt

   .. rubric:: Slot-based layouts
      :name: slot-based-layouts

   Compose provides a large variety of composables based on 
   `Material Design <https://material.io/design/>`__ with the
   ``androidx.compose.material:material`` dependency (included when creating a
   Compose project in Android Studio) to make UI building easy. Elements like
   `Drawer <https://material.io/components/navigation-drawer/>`__,
   `FloatingActionButton <https://material.io/components/buttons-floating-action-button/>`__,
   and `TopAppBar <https://material.io/components/app-bars-top>`__ are all
   provided.

   Material components make heavy use of *slot APIs*, a pattern Compose
   introduces to bring in a layer of customization on top of composables. This
   approach makes components more flexible, as they accept a child element which
   can configure itself rather than having to expose every configuration
   parameter of the child. Slots leave an empty space in the UI for the
   developer to fill as they wish. For example, these are the slots that you can
   customize in a
   `TopAppBar <https://material.io/components/app-bars-top>`__:

   |A diagram showing the available slots in a Material Components app bar|

   Composables usually take a ``content`` composable lambda (
   ``content: @Composable () -> Unit``). Slot APIs expose multiple ``content``
   parameters for specific uses. For example, ``TopAppBar`` allows you to
   provide the content for ``title``, ``navigationIcon``, and ``actions``.

   For example,
   `Scaffold <https://developer.android.google.cn/reference/kotlin/androidx/compose/material3/package-summary#Scaffold>`__
   allows you to implement a UI with the basic Material Design layout structure.
   ``Scaffold``\ provides slots for the most common top-level Material
   components, such as
   `TopAppBar <https://material.io/components/app-bars-top>`__,
   `BottomAppBar <https://material.io/components/app-bars-bottom/>`__,
   `FloatingActionButton <https://material.io/components/buttons-floating-action-button/>`__,
   and `Drawer <https://material.io/components/navigation-drawer/>`__. By
   using ``Scaffold``, it's easy to make sure these components are properly
   positioned and work together correctly.

   |The JetNews sample app, which uses Scaffold to position multiple elements|

   .. code:: prettyprint

      @Composable
      fun HomeScreen(/*...*/) {
          ModalNavigationDrawer(drawerContent = { /* ... */ }) {
              Scaffold(
                  topBar = { /*...*/ }
              ) { contentPadding ->
                  // ...
              }
          }
      }LayoutBasicsSnippets.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Compose modifiers  <#modifiers>`__
   -  `Kotlin for Jetpack Compose  <#kotlin>`__
   -  `Material Components and layouts  <#material>`__

Last updated 2024-05-03 UTC.

.. |Compose transforming state to UI via composition, layout, drawing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/composition-layout-drawing.svg
.. |Two text elements drawn on top of each other, making the text unreadable| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-overlap.png
   :width: 250px
.. |Two text elements arranged in a column layout, so the text is readable| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-text-in-column.png
   :width: 300px
.. |Shows a more complex layout, with a small graphic next to a column of text elements| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-text-with-picture.png
   :width: 400px
.. |Shows two elements stacked on one another| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-box-with-picture.png
   :width: 200px
.. |Compares three simple layout composables: column, row, and box| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-column-row-box.svg
   :width: 720px
.. |Items are aligned to the right| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-row-end.png
   :width: 400px
.. |Ordering of measuring, sizing, and placement in Search Result UI tree| image:: https://developer.android.google.cn/static/develop/ui/compose/images/search-result-layout.svg
.. |A still more complex layout, using modifiers to change how the graphics are arranged and which areas respond to user input| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-with-modifiers.png
   :width: 400px
.. |A diagram showing the available slots in a Material Components app bar| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-appbar-slots.png
   :width: 400px
.. |The JetNews sample app, which uses Scaffold to position multiple elements| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-jetnews-scaffold.png

/Modifiers
==========

.. https://developer.android.google.cn/develop/ui/compose/modifiers?hl=en

.. container:: devsite-article-body clearfix

   Modifiers allow you to decorate or augment a composable. Modifiers let you do
   these sorts of things:

   -  Change the composable's size, layout, behavior, and appearance
   -  Add information, like accessibility labels
   -  Process user input
   -  Add high-level interactions, like making an element clickable, scrollable,
      draggable, or zoomable

   Modifiers are standard Kotlin objects. Create a modifier by calling one of
   the `Modifier  <#Modifier>`__ class
   functions:

   .. code:: prettyprint

      @Composable
      private fun Greeting(name: String) {
          Column(modifier = Modifier.padding(24.dp)) {
              Text(text = "Hello,")
              Text(text = name)
          }
      }ModifierSnippets.kt

   |Two lines of text on a colored background, with padding around the text.|

   You can chain these functions together to compose them:

   .. code:: prettyprint

      @Composable
      private fun Greeting(name: String) {
          Column(
              modifier = Modifier
                  .padding(24.dp)
                  .fillMaxWidth()
          ) {
              Text(text = "Hello,")
              Text(text = name)
          }
      }ModifierSnippets.kt

   |The colored background behind the text now extends the full width of the
   device.|

   In the code above, notice different modifier functions used together.

   -  ``padding`` puts space around an element.
   -  ``fillMaxWidth`` makes the composable fill the maximum width given to it
      from its parent.

   It's a best practice to have *all* of your composables accept a ``modifier``
   parameter, and pass that modifier to its first child that emits UI. Doing so
   makes your code more reusable and makes its behavior more predictable and
   intuitive. For more information, see the Compose API guidelines, 
   `Elements accept and respect a Modifier parameter <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/compose/docs/compose-api-guidelines.md#elements-accept-and-respect-a-modifier-parameter>`__.

   .. rubric:: Order of modifiers matters
      :name: order-modifier-matters

   The order of modifier functions is **significant**. Since each function makes
   changes to the ``Modifier``\ returned by the previous function, the sequence
   affects the final result. Let's see an example of this:

   .. code:: prettyprint

      @Composable
      fun ArtistCard(/*...*/) {
          val padding = 16.dp
          Column(
              Modifier
                  .clickable(onClick = onClick)
                  .padding(padding)
                  .fillMaxWidth()
          ) {
              // rest of the implementation
          }
      }ModifierSnippets.kt

   |The entire area, including the padding around the edges, responds to clicks|

   In the code above the whole area is clickable, including the surrounding
   padding, because the ``padding`` modifier has been applied *after* the
   ``clickable`` modifier. If the modifiers order is reversed, the space added
   by ``padding`` does not react to user input:

   .. code:: prettyprint

      @Composable
      fun ArtistCard(/*...*/) {
          val padding = 16.dp
          Column(
              Modifier
                  .padding(padding)
                  .clickable(onClick = onClick)
                  .fillMaxWidth()
          ) {
              // rest of the implementation
          }
      }ModifierSnippets.kt

   |The padding around the edge of the layout no longer responds to clicks|

   **Note:**\  The explicit order helps you to reason about how different
   modifiers will interact. Compare this to the view-based system where you had
   to learn the box model, that margins applied "outside" the element but
   padding "inside" it, and a background element would be sized accordingly. The
   modifier design makes this kind of behavior explicit and predictable, and
   gives you more control to achieve the exact behavior you want. It also
   explains why there is not a margin modifier but only a ``padding`` one.

   .. rubric:: Built-in modifiers
      :name: built-in-modifiers

   Jetpack Compose provides a list of built-in modifiers to help you decorate or
   augment a composable. Here are some common modifiers you'll use to adjust
   your layouts.

   **Note:**\  Many of these modifiers are designed to help you arrange your
   UI's layout just the way you need it. For more information about how
   modifiers work in your layout, see the `Compose layout basics  <#basics>`__ documentation.

   .. rubric:: ``padding`` and ``size``
      :name: padding-and-size

   By default, layouts provided in Compose wrap their children. However, you can
   set a size by using the
   `size  <#size>`__
   modifier:

   .. code:: prettyprint

      @Composable
      fun ArtistCard(/*...*/) {
          Row(
              modifier = Modifier.size(width = 400.dp, height = 100.dp)
          ) {
              Image(/*...*/)
              Column { /*...*/ }
          }
      }ModifierSnippets.kt

   Note that the size you specified might not be respected if it does not
   satisfy the constraints coming from the layout's parent. If you require the
   composable size to be fixed regardless of the incoming constraints, use the
   ``requiredSize`` modifier:

   .. code:: prettyprint

      @Composable
      fun ArtistCard(/*...*/) {
          Row(
              modifier = Modifier.size(width = 400.dp, height = 100.dp)
          ) {
              Image(
                  /*...*/
                  modifier = Modifier.requiredSize(150.dp)
              )
              Column { /*...*/ }
          }
      }ModifierSnippets.kt

   |Child image is bigger than the constraints coming from its parent|

   In this example, even with the parent ``height`` set to ``100.dp``, the
   height of the ``Image`` will be ``150.dp``, as the ``requiredSize`` modifier
   takes precedence.

   **Note:**\  Layouts are based on constraints, and normally, the parent passes
   those constraints to the children. The child *should* respect the
   constraints. However, that might not always be what the UI requires. There
   are ways to bypass this child behavior. For example, you can pass modifiers
   like ``requiredSize`` directly to the child, overriding the constraints
   received by the child from the parent, or you can use a custom layout with
   different behavior. When a child does not respect its constraints, the layout
   system will hide this from the parent. The parent will see the child's
   ``width`` and ``height`` values as if they were coerced in the constraints
   provided by the parent. The layout system will then center the child within
   the space allocated by the parent under the assumption that the child
   respected the constraints. Developers can override this centering behaviour
   by applying ``wrapContentSize`` modifiers to the child.
   If you want a child layout to fill all the available height allowed by the
   parent, add the ``fillMaxHeight`` modifier (Compose also provides
   ``fillMaxSize`` and ``fillMaxWidth``):

   .. code:: prettyprint

      @Composable
      fun ArtistCard(/*...*/) {
          Row(
              modifier = Modifier.size(width = 400.dp, height = 100.dp)
          ) {
              Image(
                  /*...*/
                  modifier = Modifier.fillMaxHeight()
              )
              Column { /*...*/ }
          }
      }ModifierSnippets.kt

   |The image height is as big as its parent|

   To add padding all around an element, set a
   `padding  <#padding>`__
   modifier.

   If you want to add padding above a text baseline such that you achieve a
   specific distance from the top of the layout to the baseline, use the
   ``paddingFromBaseline`` modifier:

   .. code:: prettyprint

      @Composable
      fun ArtistCard(artist: Artist) {
          Row(/*...*/) {
              Column {
                  Text(
                      text = artist.name,
                      modifier = Modifier.paddingFromBaseline(top = 50.dp)
                  )
                  Text(artist.lastSeenOnline)
              }
          }
      }ModifierSnippets.kt

   |Text with padding above it|

   .. rubric:: Offset
      :name: offset

   To position a layout relative to its original position, add the
   `offset  <#offset>`__
   modifier and set the offset in the **x** and **y** axis. Offsets can be
   positive as well as non-positive. The difference between ``padding`` and
   ``offset`` is that adding an ``offset`` to a composable does not change its
   measurements:

   .. code:: prettyprint

      @Composable
      fun ArtistCard(artist: Artist) {
          Row(/*...*/) {
              Column {
                  Text(artist.name)
                  Text(
                      text = artist.lastSeenOnline,
                      modifier = Modifier.offset(x = 4.dp)
                  )
              }
          }
      }ModifierSnippets.kt

   |Text shifted to the right side of its parent container|

   The ``offset`` modifier is applied horizontally according to the layout
   direction. In a **left-to-right** context, a positive ``offset`` shifts the
   element to the right, while in a **right-to-left** context, it shifts the
   element to the left. If you need to set an offset without considering layout
   direction, see the
   `absoluteOffset  <#absoluteOffset>`__
   modifier, in which a positive offset value always shifts the element to the
   right.

   The ``offset`` modifier provides two overloads -
   `offset  <#offset>`__
   that takes the offsets as parameters and
   `offset  <#offset>`__
   that takes in a lambda. For more in depth information on when to use each of
   these and how to optimize for performance, read through the 
   `Compose performance - Defer reads as long as possible  <#defer-reads>`__ section.

   .. rubric:: Scope safety in Compose
      :name: scope-safety

   In Compose, there are modifiers that can only be used when applied to
   children of certain composables. Compose enforces this by means of custom
   scopes.

   For example, if you want to make a child as big as the parent ``Box`` without
   affecting the ``Box`` size, use the
   `matchParentSize  <#matchParentSize>`__
   modifier. ``matchParentSize`` is only available in
   `BoxScope  <#BoxScope>`__.
   Therefore, it can only be used on a child within a ``Box`` parent.

   Scope safety prevents you from adding modifiers that wouldn't work in other
   composables and scopes and saves time from trial and error.

   **Note:**\  In the Android View system, there is no scope safety. Developers
   usually find themselves trying out different layout params to discover which
   ones are considered and their meaning in the context of a particular parent.
   Scoped modifiers notify the parent about some information the parent should
   know about the child. These are also commonly referred to as *parent data
   modifiers*. Their internals are different from the general purpose modifiers,
   but from a usage perspective, these differences don't matter.

   .. rubric:: ``matchParentSize`` in ``Box``
      :name: matchparentsize-box

   As mentioned above, if you want a child layout to be the same size as a
   parent ``Box`` without affecting the ``Box`` size, use the
   ``matchParentSize`` modifier.

   Note that ``matchParentSize`` is only available within a ``Box`` scope,
   meaning that it only applies to *direct* children of ``Box`` composables.

   In the example below, the child ``Spacer`` takes its size from its parent
   ``Box``, which in turn takes its size from the biggest children,
   ``ArtistCard`` in this case.

   .. code:: prettyprint

      @Composable
      fun MatchParentSizeComposable() {
          Box {
              Spacer(
                  Modifier
                      .matchParentSize()
                      .background(Color.LightGray)
              )
              ArtistCard()
          }
      }ModifierSnippets.kt

   |Gray background filling its container|

   If ``fillMaxSize`` were used instead of ``matchParentSize``, the ``Spacer``
   would take all the available space allowed to the parent, in turn causing the
   parent to expand and fill all the available space.

   |Gray background filling the screen|

   .. rubric:: ``weight`` in ``Row`` and ``Column``
      :name: weight-in-row-and-column

   As you have seen in the previous section on 
   `Padding and size <#padding-and-size>`__, by default, a composable size is defined by the
   content it is wrapping. You can set a composable size to be flexible within
   its parent using the ``weight`` Modifier that is only available in
   ``RowScope``, and ``ColumnScope``.

   Let’s take a ``Row`` that contains two ``Box`` composables. The first box is
   given twice the ``weight`` of the second, so it's given twice the width.
   Since the ``Row`` is ``210.dp`` wide, the first ``Box`` is ``140.dp`` wide,
   and the second is ``70.dp``:

   .. code:: prettyprint

      @Composable
      fun ArtistCard(/*...*/) {
          Row(
              modifier = Modifier.fillMaxWidth()
          ) {
              Image(
                  /*...*/
                  modifier = Modifier.weight(2f)
              )
              Column(
                  modifier = Modifier.weight(1f)
              ) {
                  /*...*/
              }
          }
      }ModifierSnippets.kt

   |The image width is twice text width|

   .. rubric:: Extracting and reusing modifiers
      :name: reusing-modifiers

   Multiple modifiers can be chained together to decorate or augment a
   composable. This chain is created via the
   `Modifier  <#Modifier>`__ interface
   which represents an ordered, immutable list of single
   `Modifier.Elements  <#Modifier.Element>`__.

   Each ``Modifier.Element`` represents an individual behavior, like layout,
   drawing and graphics behaviors, all gesture-related, focus and semantics
   behaviors, as well as device input events. Their ordering matters: modifier
   elements that are added first will be applied first.

   Sometimes it can be beneficial to reuse the same modifier chain instances in
   multiple composables, by extracting them into variables and hoisting them
   into higher scopes. It can improve code readability or help improve your
   app's performance for a few reasons:

   -  The re-allocation of the modifiers won’t be repeated when recomposition
      occurs for composables that use them
   -  Modifier chains could potentially be very long and complex, so reusing the
      same instance of a chain can alleviate the workload Compose runtime needs
      to do when comparing them
   -  This extraction promotes code cleanliness, consistency and maintainability
      across the codebase

   .. rubric:: Best practices for reusing modifiers
      :name: best_practices_for_reusing_modifiers

   Create your own ``Modifier`` chains and extract them to reuse them on
   multiple composable components. It is completely fine to just save a
   modifier, as they are data-like objects:

   .. code:: prettyprint

      val reusableModifier = Modifier
          .fillMaxWidth()
          .background(Color.Red)
          .padding(12.dp)ModifierSnippets.kt

   .. rubric:: Extracting and reusing modifiers when observing frequently
      changing state
      :name: extracting_and_reusing_modifiers_when_observing_frequently_changing_state

   When observing frequently changing states inside composables, like animation
   states or ``scrollState``, there can be a significant amount of
   recompositions done. In this case, your modifiers will get allocated on every
   recomposition and potentially for every frame:

   .. code:: prettyprint

      @Composable
      fun LoadingWheelAnimation() {
          val animatedState = animateFloatAsState(/*...*/)

          LoadingWheel(
              // Creation and allocation of this modifier will happen on every frame of the animation!
              modifier = Modifier
                  .padding(12.dp)
                  .background(Color.Gray),
              animatedState = animatedState
          )
      }ModifierSnippets.kt

   Instead, you can create, extract and reuse the same instance of the modifier
   and pass it to the composable like this:

   .. code:: prettyprint

      // Now, the allocation of the modifier happens here:
      val reusableModifier = Modifier
          .padding(12.dp)
          .background(Color.Gray)

      @Composable
      fun LoadingWheelAnimation() {
          val animatedState = animateFloatAsState(/*...*/)

          LoadingWheel(
              // No allocation, as we're just reusing the same instance
              modifier = reusableModifier,
              animatedState = animatedState
          )
      }ModifierSnippets.kt

   .. rubric:: Extracting and reusing unscoped modifiers
      :name: extracting_and_reusing_unscoped_modifiers

   Modifiers can be unscoped or scoped to a specific composable. In the case of
   unscoped modifiers, you can easily extract them outside of any composables as
   simple variables:

   .. code:: prettyprint

      val reusableModifier = Modifier
          .fillMaxWidth()
          .background(Color.Red)
          .padding(12.dp)

      @Composable
      fun AuthorField() {
          HeaderText(
              // ...
              modifier = reusableModifier
          )
          SubtitleText(
              // ...
              modifier = reusableModifier
          )
      }ModifierSnippets.kt

   This can be especially beneficial when combined with Lazy layouts. In most
   cases, you’d want all of your, potentially significant, amount of items to
   have the exact same modifiers:

   .. code:: prettyprint

      val reusableItemModifier = Modifier
          .padding(bottom = 12.dp)
          .size(216.dp)
          .clip(CircleShape)

      @Composable
      private fun AuthorList(authors: List<Author>) {
          LazyColumn {
              items(authors) {
                  AsyncImage(
                      // ...
                      modifier = reusableItemModifier,
                  )
              }
          }
      }ModifierSnippets.kt

   .. rubric:: Extracting and reusing scoped modifiers
      :name: extracting_and_reusing_scoped_modifiers

   When dealing with modifiers that are scoped to certain composables, you can
   extract them to the highest possible level and reuse where appropriate:

   .. code:: prettyprint

      Column(/*...*/) {
          val reusableItemModifier = Modifier
              .padding(bottom = 12.dp)
              // Align Modifier.Element requires a ColumnScope
              .align(Alignment.CenterHorizontally)
              .weight(1f)
          Text1(
              modifier = reusableItemModifier,
              // ...
          )
          Text2(
              modifier = reusableItemModifier
              // ...
          )
          // ...
      }ModifierSnippets.kt

   You should only be passing the extracted, scoped modifiers to the
   same-scoped, direct children. See the section `Scope safety in Compose  <#scope-safety>`__ for more reference on
   why this matters:

   .. code:: prettyprint

      Column(modifier = Modifier.fillMaxWidth()) {
          // Weight modifier is scoped to the Column composable
          val reusableItemModifier = Modifier.weight(1f)

          // Weight will be properly assigned here since this Text is a direct child of Column
          Text1(
              modifier = reusableItemModifier
              // ...
          )

          Box {
              Text2(
                  // Weight won't do anything here since the Text composable is not a direct child of Column
                  modifier = reusableItemModifier
                  // ...
              )
          }
      }ModifierSnippets.kt

   .. rubric:: Further chaining of extracted modifiers
      :name: further_chaining_of_extracted_modifiers

   You can further chain or append your extracted modifier chains by calling the
   `.then()  <#then>`__
   function:

   .. code:: prettyprint

      val reusableModifier = Modifier
          .fillMaxWidth()
          .background(Color.Red)
          .padding(12.dp)

      // Append to your reusableModifier
      reusableModifier.clickable { /*...*/ }

      // Append your reusableModifier
      otherModifier.then(reusableModifier)ModifierSnippets.kt

   Just keep in mind that `the order of modifiers matters!  <#order-modifier-matters>`__

   .. rubric:: Learn more
      :name: additional-resources

   We provide a `full list of modifiers  <#modifiers-list>`__,
   with their parameters and scopes.

   For more practice on how to use modifiers, you can also go through the 
   `Basic layouts in Compose codelab  <#jetpack-compose-migration>`__ or refer
   to the `Now in Android repository <https://github.com/android/nowinandroid>`__.

   For more information on custom modifiers and how to create them, take a look
   at the documentation on `Custom layouts - Using the layout modifier  <#layout-modifier>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Compose layout basics  <#basics>`__
   -  `Editor actions {:#editor-actions}  <#editor-actions>`__
   -  `Custom layouts {:#custom-layouts }  <#custom>`__

Last updated 2024-05-03 UTC.

.. |Two lines of text on a colored background, with padding around the text.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/modifier-1-modifier.png
.. |The colored background behind the text now extends the full width of the device.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/modifier-chained.png
.. |The entire area, including the padding around the edges, responds to clicks| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-padding-clickable.gif
.. |The padding around the edge of the layout no longer responds to clicks| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-padding-not-clickable.gif
.. |Child image is bigger than the constraints coming from its parent| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-requiredsize-new.png
   :width: 400px
.. |The image height is as big as its parent| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-fillmaxheight.png
   :width: 400px
.. |Text with padding above it| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-paddingfrombaseline-new.png
   :width: 400px
.. |Text shifted to the right side of its parent container| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-offset-new.png
   :width: 400px
.. |Gray background filling its container| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-matchparentsize-new.png
   :width: 400px
.. |Gray background filling the screen| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-fillmaxsize.png
   :width: 400px
.. |The image width is twice text width| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-weight.png
   :width: 400px

/Constraints and modifier order
===============================

.. https://developer.android.google.cn/develop/ui/compose/layouts/constraints-modifiers?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   In Compose, you can chain multiple modifiers together to change the look and
   feel of a composable. These modifier chains can affect the *constraints*
   passed to composables, which define width and height bounds.

   This page describes how chained modifiers affect constraints and, in turn,
   the measurement and placement of composables.

   .. rubric:: Modifiers in the UI tree
      :name: modifiers-ui

   To understand how modifiers influence each other, it's helpful to visualize
   how they appear in the UI tree, which is generated during the composition
   phase. For more information, see the
   `Composition  <#composition>`__ section.

   In the UI tree, you can visualize modifiers as wrapper nodes for the layout
   nodes:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/modifier-wrapping.png
      name: image-1
      :alt: Code for composables and modifiers, and their visual representation
      as a UI tree.
      :width: 50.0%

      **Figure 1.** Modifiers wrapping layout nodes in the UI tree.

   Adding more than one modifier to a composable creates a chain of modifiers.
   When you chain multiple modifiers, each modifier node *wraps the rest of the
   chain and the layout node within*. For example, when you chain a
   `clip  <#clip>`__
   and a
   `size  <#size>`__
   modifier, the ``clip`` modifier node wraps the ``size`` modifier node, which
   then wraps the ``Image`` layout node.

   In the layout phase, the `algorithm that walks the tree  <#layout>`__ stays the same, but each modifier
   node is visited as well. This way, a modifier can change the size
   requirements and placement of the modifier or layout node that it wraps.

   As shown in Figure 2, the implementation of the ``Image`` and ``Text``
   composables themselves consist of a chain of modifiers wrapping a single
   layout node. The implementations of ``Row`` and ``Column`` are simply layout
   nodes that describe how to lay out their children.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/composables-modifiers.png
      name: image-2
      :alt: The tree structure from before, but now each node is just a simple
      layout, with a lot of modifier wrapping nodes around it.
      :width: 50.0%

      **Figure 2.** The same tree structure as in Figure 1, but with composables
      in the UI tree visualized as chains of modifiers.

   To summarize:

   -  Modifiers wrap a single modifier or layout node.
   -  Layout nodes can lay out multiple child nodes.

   The following sections describe how to use this mental model to reason about
   modifier chaining and how it influences the size of composables.

   .. rubric:: Constraints in the layout phase
      :name: constraints-layout

   `The layout phase  <#layout>`__ follows a three-step
   algorithm to find each layout node's width, height, and x, y coordinate:

   #. **Measure children**: A node measures its children, if any.
   #. **Decide own size**: Based on those measurements, a node decides on its
      own size.
   #. **Place children**: Each child node is placed relative to a node's own
      position.

   `Constraints  <#Constraints>`__
   help find the right sizes for the nodes during the first two steps of the
   algorithm. Constraints define the minimum and maximum bounds for a node's
   width and height. When the node decides on its size, its measured size should
   fall within this size range.

   .. rubric:: Types of constraints
      :name: types-constraints

   A constraint can be one of the following:

   -  **Bounded**: The node has a maximum and minimum width and height.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/bounded-constraints.png
      name: image-3
      :alt: Bounded constraints of different sizes within a container.
      :width: 50.0%

      **Figure 3.** Bounded constraints.

   -  **Unbounded**: The node is not constrained to any size. The maximum width
      and height bounds are set to infinity.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/unbounded-constraints.png
      name: image-4
      :alt: Unbounded constraints that have the width and height set to
      infinity. The constraints extend beyond the container.
      :width: 70.0%

      **Figure 4.** Unbounded constraints.

   -  **Exact**: The node is asked to follow an exact size requirement. The
      minimum and maximum bounds are set to the same value.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/exact-constraints.png
      name: image-5
      :alt: Exact constraints that conform to an exact size requirement within
      the container.
      :width: 40.0%

      **Figure 5.** Exact constraints.

   -  **Combination**: The node follows a combination of the above constraint
      types. For example, a constraint could bound the width while allowing for
      an unbounded maximum height, or set an exact width but provide a bounded
      height.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/combination-constraints.png
      name: image-6
      :alt: Two containers that show combinations of bounded and unbounded
      constraints and exact widths and heights.
      :width: 70.0%

      **Figure 6.** Combinations of bounded and unbounded constraints and exact
      widths and heights.

   The next section describes how these constraints are passed from a parent to
   a child.

   .. rubric:: How constraints are passed from parent to child
      :name: constraints-passed

   During the first step of the algorithm described in `Constraints in the layout phase <#constraints-layout>`__, constraints are passed down from
   parent to child in the UI tree.

   When a parent node measures its children, it provides these constraints to
   each child to let them know how big or small they're allowed to be. Then,
   when it decides its own size, it also adheres to the constraints that were
   passed in by its own parents.

   At a high level, the algorithm works in the following way:

   #. To decide the size it actually wants to occupy, the root node in the UI
      tree measures its children and forwards the same constraints to its first
      child.
   #. If the child is a modifier that does not impact measurement, it forwards
      the constraints to the next modifier. The constraints are passed down the
      modifier chain as-is unless a modifier that impacts measurement is
      reached. The constraints are then re-sized accordingly.
   #. Once a node is reached that doesn't have any children (referred to as a
      "leaf node"), it decides its size based on the constraints that were
      passed in, and returns this resolved size to its parent.
   #. The parent adapts its constraints based on this child's measurements, and
      calls its next child with these adjusted constraints.
   #. Once all children of a parent are measured, the parent node decides on its
      own size and communicates that to its own parent.
   #. This way, the whole tree is traversed depth-first. Eventually, all the
      nodes have decided on their sizes, and the measurement step is completed.

   For an in-depth example, see the `Constraints and modifier order <https://www.youtube.com/watch?v=OeC5jMV342A&t=204s>`__ video.

   .. rubric:: Modifiers that affect constraints
      :name: modifiers-affect

   You learned in the previous section that some modifiers can affect constraint
   size. The following sections describe specific modifiers that impact
   constraints.

   .. rubric:: ``size`` modifier
      :name: size-modifier

   The
   `size  <#size>`__
   modifier declares the preferred size of the content.

   For example, the following UI tree should be rendered in a container of
   ``300dp`` by ``200dp``. The constraints are bounded, allowing widths between
   ``100dp`` and ``300dp``, and heights between ``100dp`` and ``200dp``:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/size-modifier.png
      name: image-7
      :alt: A portion of a UI tree with the size modifier wrapping a layout
      node, and the representation of the bounded constraints set by the size
      modifier in a container.
      :width: 50.0%

      **Figure 7.** Bounded constraints in the UI tree and its representation in
      a container.

   The ``size`` modifier adapts incoming constraints to match the value passed
   to it. In this example, the value is ``150dp``:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/size-modifier-2.png
      name: image-8
      :alt: The same as Figure 7, except with the size modifier adapting
      incoming constraints to match the value passed to it.
      :width: 50.0%

      **Figure 8.** The ``size`` modifier adjusting constraints to ``150dp``.

   If the width and height are smaller than the smallest constraint bound, or
   larger than the largest constraint bound, the modifier matches the passed
   constraints as closely as it can while still adhering to the constraints
   passed in:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/size-modifier-3.png
      name: image-9
      :alt: Two UI trees and their corresponding representations in containers.
      In the first, the size modifier accepts the incmoing constraints; in the
      second, the size modifier adapts to the too-large constraints as closely
      as possible, resulting in constraints that fill the container.

      **Figure 9.** The ``size`` modifier adhering to the passed constraint as
      closely as possible.

   Note that chaining multiple ``size`` modifiers does not work. The first
   ``size`` modifier sets both the minimum and maximum constraints to a fixed
   value. Even if the second size modifier requests a smaller or larger size, it
   still needs to adhere to the exact bounds passed in, so it won't override
   those values:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/size-modifier-4.png
      name: image-10
      :alt: A chain of two size modifiers in the UI tree and its representation
      in a container, which is the result of the first value passed in and not
      the second value.
      :width: 70.0%

      **Figure 10.** A chain of two ``size`` modifiers, in which the second
      value passed in (``50dp``) does not override the first value (``100dp``).

   .. rubric:: ``requiredSize`` modifier
      :name: requiredsize-modifier

   Use the
   `requiredSize  <#requiredSize>`__
   modifier instead of
   `size  <#size>`__
   if you need your node to override the incoming constraints. The
   ``requiredSize`` modifier replaces the incoming constraints and passes the
   size you specify as exact bounds.

   When the size is passed back up the tree, the child node will be centered in
   the available space:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/requiredsize-modifier.png
      name: image-11
      :alt: The size and requiredSize modifier chained in a UI tree, and the
      corresponding representation in a container. The requiredSize modifier
      constraints override the size modifier constraints.
      :width: 70.0%

      **Figure 11.** The ``requiredSize`` modifier overriding incoming
      constraints from the ``size`` modifier.

   .. rubric:: ``width`` and ``height`` modifiers
      :name: width-height

   The ``size`` modifier adapts both the width and height of the constraints.
   With the ``width`` modifier, you can set a fixed width but leave the height
   undecided. Similarly, with the ``height`` modifier, you can set a fixed
   height, but leave the width undecided:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/width-height-modifier.png
      name: image-12
      :alt: Two UI trees, one with the width modifier and its container
      representation and the other with the height modifier and its
      representation.
      :width: 80.0%

      **Figure 12.** The ``width`` modifier and ``height`` modifier setting a
      fixed width and height, respectively.

   .. rubric:: ``sizeIn`` modifier
      :name: sizein-modifier

   The ``sizeIn`` modifier lets you set exact minimum and maximum constraints
   for width and height. Use the ``sizeIn`` modifier if you need fine-grained
   control over the constraints.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/sizein-modifier.png
      name: image-13
      :alt: A UI tree with the sizeIn modifier with minimum and maximum widths
      and heights set, and its representation within a container.
      :width: 70.0%

      **Figure 13.** The ``sizeIn`` modifier with ``minWidth``, ``maxWidth``,
      ``minHeight``, and ``maxHeight`` set.

   .. rubric:: Examples
      :name: examples

   This section shows and explains the output from several code snippets with
   chained modifiers.

   .. code:: prettyprint

      Image(
          painterResource(R.drawable.hero),
          contentDescription = null,
          Modifier
              .fillMaxSize()
              .size(50.dp)
      )ConstraintsModifiersSnippets.kt

   This snippet produces the following output:

   |image-example-1|

   -  The
      `fillMaxSize  <#fillMaxSize>`__
      modifier changes the constraints to set both the minimum width and height
      to the maximum value — ``300dp`` in width and ``200dp`` in height.
   -  Even though the ``size`` modifier wants to use a size of ``50dp``, it
      still needs to adhere to the incoming minimum constraints. So the ``size``
      modifier will also output the exact constraint bounds of ``300`` by
      ``200``, effectively ignoring the value provided in the ``size`` modifier.
   -  The ``Image`` follows these bounds and reports a size of ``300`` by
      ``200``, which is passed all the way up the tree.

   .. code:: prettyprint

      Image(
          painterResource(R.drawable.hero),
          contentDescription = null,
          Modifier
              .fillMaxSize()
              .wrapContentSize()
              .size(50.dp)
      )ConstraintsModifiersSnippets.kt

   This snippet produces the following output:

   |image-example-2|

   -  The ``fillMaxSize`` modifier adapts the constraints to set both the
      minimum width and height to the maximum value — ``300dp`` in width, and
      ``200dp`` in height.
   -  The ``wrapContentSize`` modifier resets the minimum constraints. So, while
      ``fillMaxSize`` resulted in fixed constraints, ``wrapContentSize`` *resets
      it back to bounded constraints*. The following node can now take up the
      whole space again, or be smaller than the entire space.
   -  The ``size`` modifier sets the constraints to minimum and maximum bounds
      of ``50``.
   -  The ``Image`` resolves to a size of ``50`` by ``50``, and the ``size``
      modifier forwards that.
   -  The
      `wrapContentSize  <#wrapContentSize>`__
      modifier has a special property. It takes its child and *puts it in the
      center of the available minimum bounds* that were passed to it. The size
      it communicates to its parents is thus equal to the minimum bounds that
      were passed into it.

   By combining just three modifiers, you can define a size for the composable
   and center it in its parent.

   .. code:: prettyprint

      Image(
          painterResource(R.drawable.hero),
          contentDescription = null,
          Modifier
              .clip(CircleShape)
              .padding(10.dp)
              .size(100.dp)
      )ConstraintsModifiersSnippets.kt

   This snippet produces the following output:

   |image-example-3|

   -  The ``clip`` modifier does not change the constraints.

      -  The ``padding`` modifier lowers the maximum constraints.
      -  The ``size`` modifier sets all constraints to ``100dp``.
      -  The ``Image`` adheres to those constraints and reports a size of
         ``100`` by ``100dp``.
      -  The ``padding`` modifier adds ``10dp`` on all sizes, so it increases
         the reported width and height by ``20dp``.
      -  Now in the drawing phase, the ``clip`` modifier acts on a canvas of
         ``120`` by ``120dp``. So, it *creates a circle mask of that size*.
      -  The ``padding`` modifier then insets its content by ``10dp`` on all
         sizes, so it lowers the canvas size to ``100`` by ``100dp``.
      -  The ``Image`` is drawn in that canvas. The image is clipped based on
         the original circle of ``120dp``, so the output is a non-round result.

Last updated 2024-05-03 UTC.

.. |image-example-1| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/example-1.png
   :width: 70.0%
.. |image-example-2| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/example-2.png
   :width: 70.0%
.. |image-example-3| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/constraints-modifiers/example-3.png
   :width: 70.0%

/Custom modifiers
=================

.. https://developer.android.google.cn/develop/ui/compose/custom-modifiers?hl=en

.. container:: devsite-article-body clearfix

   Compose provides many `modifiers  <#modifiers>`__ for
   common behaviors right out of the box, but you can also create your own
   custom modifiers.

   Modifiers have multiple parts:

   -  A modifier factory

      -  This is an extension function on ``Modifier``, which provides an
         idiomatic API for your modifier and allows modifiers to be easily
         chained together. The modifier factory produces the modifier elements
         used by Compose to modify your UI.

   -  A modifier element

      -  This is where you can implement the behavior of your modifier.

   There are multiple ways to implement a custom modifier depending on the
   functionality needed. Often, the easiest way to implement a custom modifier
   is just to implement a custom modifier factory which combines other already
   defined modifier factories together. If you need more custom behavior,
   implement the modifier element using the ``Modifier.Node`` APIs, which are
   lower level but provide more flexibility.

   .. rubric:: Chain existing modifiers together
      :name: chain-existing

   It is often possible to create custom modifiers just by using existing
   modifiers. For example,
   `Modifier.clip()  <#clip>`__
   is implemented using the ``graphicsLayer`` modifier. This strategy uses
   existing modifier elements, and you provide your own custom modifier factory.

   Before implementing your own custom modifier, see if you can use the same
   strategy.

   .. code:: prettyprint

      fun Modifier.clip(shape: Shape) = graphicsLayer(shape = shape, clip = true)CustomModifierSnippets.kt

   Or, if you find you are repeating the same group of modifiers often, you can
   wrap them into your own modifier:

   .. code:: prettyprint

      fun Modifier.myBackground(color: Color) = padding(16.dp)
          .clip(RoundedCornerShape(8.dp))
          .background(color)CustomModifierSnippets.kt

   .. rubric:: Create a custom modifier using a composable modifier factory
      :name: create_a_custom_modifier_using_a_composable_modifier_factory

   You can also create a custom modifier using a composable function to pass
   values to an existing modifier. This is known as a composable modifier
   factory.

   **Note:**\  In previous versions of Compose, we recommended against this
   approach and suggested using
   `composed {}  <#composed>`__
   instead via a lint rule. Now that ``composed {}`` is not recommended, the
   lint rule has been removed.
   Using a composable modifier factory to create a modifier also allows for
   using higher level compose APIs, such as
   `animate*AsState  <#animate-as-state>`__
   and other `Compose state backed animation APIs  <#choose-api>`__. For example, the
   following snippet shows a modifier that animates an alpha change when
   enabled/disabled:

   .. code:: prettyprint

      @Composable
      fun Modifier.fade(enable: Boolean): Modifier {
          val alpha by animateFloatAsState(if (enable) 0.5f else 1.0f)
          return this then Modifier.graphicsLayer { this.alpha = alpha }
      }CustomModifierSnippets.kt

   **Warning:**\  When creating custom modifiers, don't break the modifier
   chain. You must always reference ``this`` or else any modifiers previously
   added will be dropped. You can use ``this then Modifier`` as in the preceding
   example or implicitly using ``return graphicsLayer { this.alpha = alpha }``.
   If your custom modifier is a convenience method to provide default values
   from a ``CompositionLocal``, the easiest way to implement this is to use a
   composable modifier factory:

   .. code:: prettyprint

      @Composable
      fun Modifier.fadedBackground(): Modifier {
          val color = LocalContentColor.current
          return this then Modifier.background(color.copy(alpha = 0.5f))
      }CustomModifierSnippets.kt

   This approach has some caveats detailed below.

   .. rubric:: ``CompositionLocal`` values are resolved at the call site of the
      modifier factory
      :name: compositionlocal_values_are_resolved_at_the_call_site_of_the_modifier_factory

   When creating a custom modifier using a composable modifier factory,
   composition locals take the value from the composition tree where they are
   created, not used. This can lead to unexpected results. For example, take the
   composition local modifier example from above, implemented slightly
   differently using a composable function:

   .. code:: prettyprint

      @Composable
      fun Modifier.myBackground(): Modifier {
          val color = LocalContentColor.current
          return this then Modifier.background(color.copy(alpha = 0.5f))
      }

      @Composable
      fun MyScreen() {
          CompositionLocalProvider(LocalContentColor provides Color.Green) {
              // Background modifier created with green background
              val backgroundModifier = Modifier.myBackground()

              // LocalContentColor updated to red
              CompositionLocalProvider(LocalContentColor provides Color.Red) {

                  // Box will have green background, not red as expected.
                  Box(modifier = backgroundModifier)
              }
          }
      }CustomModifierSnippets.kt

   If this is not how you expect your modifier to work, use a custom
   `Modifier.Node <#implement-custom>`__ instead, as composition locals will
   be correctly resolved at the usage site and can be safely hoisted.

   .. rubric:: Composable function modifiers are never skipped
      :name: composable_function_modifiers_are_never_skipped

   Composable factory modifiers are never
   `skipped  <#skips>`__ because composable
   functions that have return values cannot be skipped. This means your modifier
   function will be called on every recomposition, which may be expensive if it
   recomposes frequently.

   .. rubric:: Composable function modifiers must be called within a composable
      function
      :name: composable_function_modifiers_must_be_called_within_a_composable_function

   Like all composable functions, a composable factory modifier must be called
   from within composition. This limits where a modifier can be hoisted to, as
   it can never be hoisted out of composition. In comparison, non-composable
   modifier factories can be hoisted out of composable functions to allow easier
   reuse and improve performance:

   .. code:: prettyprint

      val extractedModifier = Modifier.background(Color.Red) // Hoisted to save allocations

      @Composable
      fun Modifier.composableModifier(): Modifier {
          val color = LocalContentColor.current.copy(alpha = 0.5f)
          return this then Modifier.background(color)
      }

      @Composable
      fun MyComposable() {
          val composedModifier = Modifier.composableModifier() // Cannot be extracted any higher
      }CustomModifierSnippets.kt

   .. rubric:: Implement custom modifier behavior using ``Modifier.Node``
      :name: implement-custom

   `Modifier.Node  <#Modifier.Node>`__
   is a lower level API for creating modifiers in Compose. It is the same API
   that Compose implements its own modifiers in and is the most performant way
   to create custom modifiers.

   **Note:**\  There is another API for creating custom modifiers,
   `composed {}  <#composed>`__.
   This API is no longer recommended due to the performance issues it created.
   ``Modifier.Node`` was designed from the ground up to be far more performant
   than composed modifiers. For more details on the problems with composed
   modifiers, see the Android Dev Summit talk `Compose Modifiers Deep Dive <https://www.youtube.com/watch?v=BjGX2RftXsU>`__.

   .. rubric:: Implement a custom modifier using ``Modifier.Node``
      :name: implement_a_custom_modifier_using_modifiernode

   There are three parts to implementing a custom modifier using Modifier.Node:

   -  A `Modifier.Node <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/Modifier.kt;l=184>`__
      implementation that holds the logic and state of your modifier.
   -  A `ModifierNodeElement <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/ModifierNodeElement.kt;l=39>`__
      that creates and updates modifier node instances.
   -  An optional modifier factory as detailed above.

   ``ModifierNodeElement`` classes are stateless and new instances are allocated
   each recomposition, whereas ``Modifier.Node`` classes can be stateful and
   will survive across multiple recompositions, and can even be reused.

   The following section describes each part and shows an example of building a
   custom modifier to draw a circle.

   .. rubric:: ``Modifier.Node``
      :name: modifiernode

   The ``Modifier.Node`` implementation (in this example, ``CircleNode``)
   implements the functionality of your custom modifier.

   .. code:: prettyprint

      // Modifier.Node
      private class CircleNode(var color: Color) : DrawModifierNode, Modifier.Node() {
          override fun ContentDrawScope.draw() {
              drawCircle(color)
          }
      }CustomModifierSnippets.kt

   In this example, it draws the circle with the color passed in to the modifier
   function.

   A node implements ``Modifier.Node`` as well as zero or more node types. There
   are different node types based on the functionality your modifier requires.
   The example above needs to be able to draw, so it implements
   ``DrawModifierNode``, which allows it to override the draw method.

   The available types are as follows:

   .. list-table::
      :widths: 27 27 27

      - 

         - **Node**
         - **Usage**
         - **Sample Link**
      - 

         - `LayoutModifierNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/LayoutModifierNode.kt>`__
         - A ``Modifier.Node`` that changes how its wrapped content is measured
            and laid out.
         - `Sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/samples/src/main/java/androidx/compose/ui/samples/LayoutSample.kt;l=198>`__
      - 

         - `DrawModifierNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/DrawModifierNode.kt>`__
         - A ``Modifier.Node`` that draws into the space of the layout.
         - `Sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/samples/src/main/java/androidx/compose/ui/samples/ModifierSamples.kt;l=313>`__
      - 

         - `CompositionLocalConsumerModifierNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/CompositionLocalConsumerModifierNode.kt>`__
         - Implementing this interface allows your ``Modifier.Node`` to read
            composition locals.
         - `Sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/samples/src/main/java/androidx/compose/ui/samples/ModifierCompositionLocalSample.kt;l=64>`__
      - 

         - `SemanticsModifierNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/SemanticsModifierNode.kt>`__
         - A ``Modifier.Node`` that adds semantics key/value for use in testing,
            accessibility, and similar use cases.
         - `Sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/samples/src/main/java/androidx/compose/ui/samples/ModifierSamples.kt;l=338>`__
      - 

         - `PointerInputModifierNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/PointerInputModifierNode.kt>`__
         - A ``Modifier.Node`` that receives
            `PointerInputChanges. <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/input/pointer/PointerEvent.kt>`__
         - `Sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/samples/src/main/java/androidx/compose/ui/samples/ModifierSamples.kt;l=366>`__
      - 

         - `ParentDataModifierNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/ParentDataModifierNode.kt>`__
         - A ``Modifier.Node`` that provides data to the parent layout.
         - `Sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation-layout/src/commonMain/kotlin/androidx/compose/foundation/layout/Box.kt;l=295>`__
      - 

         - `LayoutAwareModifierNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/LayoutAwareModifierNode.kt>`__
         - A ``Modifier.Node`` which receives ``onMeasured`` and ``onPlaced``
            callbacks.
         - `Sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/samples/src/main/java/androidx/compose/ui/samples/ModifierSamples.kt;l=405>`__
      - 

         - `GlobalPositionAwareModifierNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/GlobalPositionAwareModifierNode.kt>`__
         - A ``Modifier.Node`` which receives an ``onGloballyPositioned``
            callback with the final ``LayoutCoordinates`` of the layout when the
            global position of the content may have changed.
         - `Sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/samples/src/main/java/androidx/compose/ui/samples/ModifierSamples.kt;l=405>`__
      - 

         - `ObserverModifierNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/ObserverModifierNode.kt>`__
         - ``Modifier.Node``\ s that implement ``ObserverNode`` can provide
            their own implementation of ``onObservedReadsChanged`` that will be
            called in response to changes to snapshot objects read within an
            ``observeReads`` block.
         - `Sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/samples/src/main/java/androidx/compose/ui/samples/ModifierCompositionLocalSample.kt;l=64>`__
      - 

         - `DelegatingNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/DelegatingNode.kt>`__
         - A ``Modifier.Node`` which is able to delegate work to other
            ``Modifier.Node`` instances.

            This can be useful to compose multiple node implementations into
            one.
         - `Sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/samples/src/main/java/androidx/compose/ui/samples/ModifierSamples.kt>`__
      - 

         - `TraversableNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/TraversableNode.kt;l=28>`__
         - Allows ``Modifier.Node`` classes to traverse up/down the node tree
            for classes of the same type or for a particular key.
         - `Sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/integration-tests/ui-demos/src/main/java/androidx/compose/ui/demos/modifier/TraverseModifierDemo.kt;l=123>`__

   Nodes are automatically invalidated when update is called on their
   corresponding element. Because our example is a ``DrawModifierNode``, any
   time update is called on the element, the node triggers a redraw and its
   color correctly updates. It is possible to opt out of auto-invalidation as
   detailed `below <#autoinvalidation>`__.

   .. rubric:: ``ModifierNodeElement``
      :name: modifiernodeelement

   A ``ModifierNodeElement`` is an immutable class that holds the data to create
   or update your custom modifier:

   .. code:: prettyprint

      // ModifierNodeElement
      private data class CircleElement(val color: Color) : ModifierNodeElement<CircleNode>() {
          override fun create() = CircleNode(color)

          override fun update(node: CircleNode) {
              node.color = color
          }
      }CustomModifierSnippets.kt

   ``ModifierNodeElement`` implementations need to override the following
   methods:

   #. ``create``: This is the function that instantiates your modifier node.
      This gets called to create the node when your modifier is first applied.
      Usually, this amounts to constructing the node and configuring it with the
      parameters that were passed in to the modifier factory.
   #. ``update``: This function is called whenever this modifier is provided in
      the same spot this node already exists, but a property has changed. This
      is determined by the ``equals`` method of the class. The modifier node
      that was previously created is sent as a parameter to the ``update`` call.
      At this point, you should update the nodes' properties to correspond with
      the updated parameters. The ability for nodes to be reused this way is key
      to the performance gains that ``Modifier.Node`` brings; therefore, you
      must update the existing node rather than creating a new one in the
      ``update`` method. In our circle example, the color of the node is
      updated.

   Additionally, ``ModifierNodeElement`` implementations also need to implement
   ``equals`` and ``hashCode``. ``update`` will only get called if an equals
   comparison with the previous element returns false.

   **Warning:**\  Your ``ModifierNodeElement`` must implement ``equals`` and
   ``hashCode`` correctly and not rely on instance equality. Without this, your
   modifier node will be updated unnecessarily and perform poorly. Use a data
   class to achieve this automatically.
   The example above uses a data class to achieve this. These methods are used
   to check if a node needs updating or not. If your element has properties that
   do not contribute to whether a node needs to be updated, or you want to avoid
   data classes for binary compatibility reasons, then you can manually
   implement ``equals`` and ``hashCode`` e.g. 
   the `padding modifier element <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation-layout/src/commonMain/kotlin/androidx/compose/foundation/layout/Padding.kt;l=358>`__.

   .. rubric:: Modifier factory
      :name: modifier_factory

   This is the public API surface of your modifier. Most implementations simply
   create the modifier element and add it to the modifier chain:

   .. code:: prettyprint

      // Modifier factory
      fun Modifier.circle(color: Color) = this then CircleElement(color)CustomModifierSnippets.kt

   .. rubric:: Complete example
      :name: complete_example

   These three parts come together to create the custom modifier to draw a
   circle using the ``Modifier.Node`` APIs:

   .. code:: prettyprint

      // Modifier factory
      fun Modifier.circle(color: Color) = this then CircleElement(color)

      // ModifierNodeElement
      private data class CircleElement(val color: Color) : ModifierNodeElement<CircleNode>() {
          override fun create() = CircleNode(color)

          override fun update(node: CircleNode) {
              node.color = color
          }
      }

      // Modifier.Node
      private class CircleNode(var color: Color) : DrawModifierNode, Modifier.Node() {
          override fun ContentDrawScope.draw() {
              drawCircle(color)
          }
      }CustomModifierSnippets.kt

   .. rubric:: Common situations using ``Modifier.Node``
      :name: common-situations

   When creating custom modifiers with ``Modifier.Node``, here are some common
   situations you might encounter.

   .. rubric:: Zero parameters
      :name: zero_parameters

   If your modifier has no parameters, then it never needs to update and,
   furthermore, does not need to be a data class. Here is a sample
   implementation of a modifier that applies a fixed amount of padding to a
   composable:

   .. code:: prettyprint

      fun Modifier.fixedPadding() = this then FixedPaddingElement

      data object FixedPaddingElement : ModifierNodeElement<FixedPaddingNode>() {
          override fun create() = FixedPaddingNode()
          override fun update(node: FixedPaddingNode) {}
      }

      class FixedPaddingNode : LayoutModifierNode, Modifier.Node() {
          private val PADDING = 16.dp

          override fun MeasureScope.measure(
              measurable: Measurable,
              constraints: Constraints
          ): MeasureResult {
              val paddingPx = PADDING.roundToPx()
              val horizontal = paddingPx * 2
              val vertical = paddingPx * 2

              val placeable = measurable.measure(constraints.offset(-horizontal, -vertical))

              val width = constraints.constrainWidth(placeable.width + horizontal)
              val height = constraints.constrainHeight(placeable.height + vertical)
              return layout(width, height) {
                  placeable.place(paddingPx, paddingPx)
              }
          }
      }CustomModifierSnippets.kt

   .. rubric:: Referencing composition locals
      :name: referencing_composition_locals

   ``Modifier.Node`` modifiers do not automatically observe changes to Compose
   state objects, like ``CompositionLocal``. The advantage ``Modifier.Node``
   modifiers have over modifiers that are just created with a composable factory
   is that they can read the value of the composition local from where the
   modifier is used in your UI tree, not where the modifier is allocated, using
   `currentValueOf  <#currentValueOf>`__.

   However, modifier node instances do not automatically observe state changes.
   To automatically react to a composition local changing, you can read its
   current value inside a scope:

   -  ``DrawModifierNode``:
      `ContentDrawScope <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/DrawModifierNode.kt;l=31>`__
   -  ``LayoutModifierNode``:
      `MeasureScope <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/LayoutModifierNode.kt;l=64>`__
      &
      `IntrinsicMeasureScope <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/LayoutModifierNode.kt;l=87>`__
   -  ``SemanticsModifierNode``:
      `SemanticsPropertyReceiver <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/semantics/SemanticsProperties.kt;l=788>`__

   This example observes the value of ``LocalContentColor`` to draw a background
   based on its color. As ``ContentDrawScope`` does observe snapshot changes,
   this automatically redraws when the value of ``LocalContentColor`` changes:

   .. code:: prettyprint

      class BackgroundColorConsumerNode :
          Modifier.Node(),
          DrawModifierNode,
          CompositionLocalConsumerModifierNode {
          override fun ContentDrawScope.draw() {
              val currentColor = currentValueOf(LocalContentColor)
              drawRect(color = currentColor)
              drawContent()
          }
      }CustomModifierSnippets.kt

   To react to state changes outside of a scope and automatically update your
   modifier, use an
   `ObserverModifierNode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/node/ObserverModifierNode.kt>`__.

   For example,
   `Modifier.scrollable <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/gestures/Scrollable.kt;l=269>`__
   uses this technique to observe changes in ``LocalDensity``. A simplified
   example is shown below:

   .. code:: prettyprint

      class ScrollableNode :
          Modifier.Node(),
          ObserverModifierNode,
          CompositionLocalConsumerModifierNode {

          // Place holder fling behavior, we'll initialize it when the density is available.
          val defaultFlingBehavior = DefaultFlingBehavior(splineBasedDecay(UnityDensity))

          override fun onAttach() {
              updateDefaultFlingBehavior()
              observeReads { currentValueOf(LocalDensity) } // monitor change in Density
          }

          override fun onObservedReadsChanged() {
              // if density changes, update the default fling behavior.
              updateDefaultFlingBehavior()
          }

          private fun updateDefaultFlingBehavior() {
              val density = currentValueOf(LocalDensity)
              defaultFlingBehavior.flingDecay = splineBasedDecay(density)
          }
      }CustomModifierSnippets.kt

   .. rubric:: Animating modifier
      :name: animating_modifier

   ``Modifier.Node`` implementations have access to a ``coroutineScope``. This
   allows for use of the `Compose Animatable APIs  <#animatable>`__. For example,
   this snippet modifies the ``CircleNode`` from above to fade in and out
   repeatedly:

   .. code:: prettyprint

      class CircleNode(var color: Color) : Modifier.Node(), DrawModifierNode {
          private val alpha = Animatable(1f)

          override fun ContentDrawScope.draw() {
              drawCircle(color = color, alpha = alpha.value)
              drawContent()
          }

          override fun onAttach() {
              coroutineScope.launch {
                  alpha.animateTo(
                      0f,
                      infiniteRepeatable(tween(1000), RepeatMode.Reverse)
                  ) {
                  }
              }
          }
      }CustomModifierSnippets.kt

   .. rubric:: Sharing state between modifiers using delegation
      :name: sharing_state_between_modifiers_using_delegation

   ``Modifier.Node`` modifiers can delegate to other nodes. There are many use
   cases for this, such as extracting common implementations across different
   modifiers, but it can also be used to share common state across modifiers.

   For example, a basic implementation of a clickable modifier node that shares
   interaction data:

   .. code:: prettyprint

      class ClickableNode : DelegatingNode() {
          val interactionData = InteractionData()
          val focusableNode = delegate(
              FocusableNode(interactionData)
          )
          val indicationNode = delegate(
              IndicationNode(interactionData)
          )
      }CustomModifierSnippets.kt

   .. rubric:: Opting out of node auto-invalidation
      :name: autoinvalidation

   ``Modifier.Node`` nodes invalidate automatically when their corresponding
   ``ModifierNodeElement`` calls update. Sometimes, in a more complex modifier,
   you may want to opt out of this behavior to have more fine-grained control
   over when your modifier invalidates phases.

   This can be particularly useful if your custom modifier modifies both layout
   and draw. Opting out of auto-invalidation allows you to just invalidate draw
   when only draw-related properties, like ``color``, change, and not invalidate
   layout. This can improve the performance of your modifier.

   A hypothetical example of this is shown below with a modifier that has a
   ``color``, ``size``, and ``onClick`` lambda as properties. This modifier only
   invalidates what is required, and skips any invalidation that isn't:

   .. code:: prettyprint

      class SampleInvalidatingNode(
          var color: Color,
          var size: IntSize,
          var onClick: () -> Unit
      ) : DelegatingNode(), LayoutModifierNode, DrawModifierNode {
          override val shouldAutoInvalidate: Boolean
              get() = false

          private val clickableNode = delegate(
              ClickablePointerInputNode(onClick)
          )

          fun update(color: Color, size: IntSize, onClick: () -> Unit) {
              if (this.color != color) {
                  this.color = color
                  // Only invalidate draw when color changes
                  invalidateDraw()
              }

              if (this.size != size) {
                  this.size = size
                  // Only invalidate layout when size changes
                  invalidateMeasurement()
              }

              // If only onClick changes, we don't need to invalidate anything
              clickableNode.update(onClick)
          }

          override fun ContentDrawScope.draw() {
              drawRect(color)
          }

          override fun MeasureScope.measure(
              measurable: Measurable,
              constraints: Constraints
          ): MeasureResult {
              val size = constraints.constrain(size)
              val placeable = measurable.measure(constraints)
              return layout(size.width, size.height) {
                  placeable.place(0, 0)
              }
          }
      }CustomModifierSnippets.kt

Last updated 2024-05-03 UTC.

/List of modifiers
==================

.. https://developer.android.google.cn/develop/ui/compose/modifiers-list?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: :heading:`Actions`
      :name: Actions

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``<T:Any?>`` ``Modifier``.``anchoredDraggable`` (
                        ``state:`` ``AnchoredDraggableState`` ``<T>,`` ``orientation:`` ``Orientation``,
                        ``enabled:`` ``Boolean``,
                        ``reverseDirection:`` ``Boolean``,
                        ``interactionSource:`` ``MutableInteractionSource``?
                    )

               Enable drag gestures between a set of predefined values.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``clickable`` (
                        ``enabled:`` ``Boolean``,
                        ``onClickLabel:`` ``String``?,
                        ``role:`` ``Role``?,
                        ``onClick:()`` -> ``Unit``
                    )

               Configure component to receive clicks via input or accessibility
               "click" event.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``clickable`` (
                        ``interactionSource:`` ``MutableInteractionSource``,
                        ``indication:`` ``Indication``?,
                        ``enabled:`` ``Boolean``,
                        ``onClickLabel:`` ``String``?,
                        ``role:`` ``Role``?,
                        ``onClick:()`` -> ``Unit``
                    )

               Configure component to receive clicks via input or accessibility
               "click" event.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``combinedClickable`` (
                        ``enabled:`` ``Boolean``,
                        ``onClickLabel:`` ``String``?,
                        ``role:`` ``Role``?,
                        ``onLongClickLabel:`` ``String``?,
                        ``onLongClick:(()`` -> ``Unit``?, ``onDoubleClick:(()`` -> ``Unit``?, ``onClick:()`` -> ``Unit``
                    )

               Configure component to receive clicks, double clicks and long
               clicks via input or accessibility "click" event.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``combinedClickable`` (
                        ``interactionSource:`` ``MutableInteractionSource``,
                        ``indication:`` ``Indication``?,
                        ``enabled:`` ``Boolean``,
                        ``onClickLabel:`` ``String``?,
                        ``role:`` ``Role``?,
                        ``onLongClickLabel:`` ``String``?,
                        ``onLongClick:(()`` -> ``Unit``?, ``onDoubleClick:(()`` -> ``Unit``?, ``onClick:()`` -> ``Unit``
                    )

               Configure component to receive clicks, double clicks and long
               clicks via input or accessibility "click" event.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``mouseClickable`` (
                        ``enabled:`` ``Boolean``,
                        ``onClickLabel:`` ``String``?,
                        ``role:`` ``Role``?,
                        ``onClick:`` ``MouseClickScope``.( ) -> ``Unit``
                    )

               Creates modifier similar to
               ``Modifier.clickable``
               but provides additional context with information about pressed
               buttons and keyboard modifiers

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``draggable2D`` (
                        ``state:`` ``Draggable2DState``,
                        ``enabled:`` ``Boolean``,
                        ``interactionSource:`` ``MutableInteractionSource``?,
                        ``startDragImmediately:`` ``Boolean``,
                        ``onDragStarted:suspend`` ``CoroutineScope``.( ``startedPosition:`` ``Offset`` ) -> ``Unit``,
                        ``onDragStopped:suspend`` ``CoroutineScope``.( ``velocity:`` ``Velocity`` ) -> ``Unit``,
                        ``reverseDirection:`` ``Boolean``
                    )

               Configure touch dragging for the UI element in both orientations.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``draggable`` (
                        ``state:`` ``DraggableState``,
                        ``orientation:`` ``Orientation``,
                        ``enabled:`` ``Boolean``,
                        ``interactionSource:`` ``MutableInteractionSource``?,
                        ``startDragImmediately:`` ``Boolean``,
                        ``onDragStarted:suspend`` ``CoroutineScope``.( ``startedPosition:`` ``Offset`` ) -> ``Unit``,
                        ``onDragStopped:suspend`` ``CoroutineScope``.( ``velocity:`` ``Float`` ) -> ``Unit``,
                        ``reverseDirection:`` ``Boolean``
                    )

               Configure touch dragging for the UI element in a single
               ``Orientation``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``selectableGroup`` ()

               Use this modifier to group a list of ``selectable``
               items like Tabs or RadioButtons together for accessibility purpose.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``selectable`` (
                        ``selected:`` ``Boolean``,
                        ``enabled:`` ``Boolean``,
                        ``role:`` ``Role``?,
                        ``onClick:()`` -> ``Unit``
                    )

               Configure component to be selectable, usually as a part of a
               mutually exclusive group, where only one item can be selected at
               any point in time.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``selectable`` (
                        ``selected:`` ``Boolean``,
                        ``interactionSource:`` ``MutableInteractionSource``,
                        ``indication:`` ``Indication``?,
                        ``enabled:`` ``Boolean``,
                        ``role:`` ``Role``?,
                        ``onClick:()`` -> ``Unit``
                    )

               Configure component to be selectable, usually as a part of a
               mutually exclusive group, where only one item can be selected at
               any point in time.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalMaterialApi``
                  ``<T:Any?>`` ``Modifier``.``swipeable`` (
                        ``state:`` ``SwipeableState<T>``,
                        ``anchors:`` ``Map<Float,T>``,
                        ``orientation:`` ``Orientation``,
                        ``enabled:`` ``Boolean``,
                        ``reverseDirection:`` ``Boolean``,
                        ``interactionSource:`` ``MutableInteractionSource``?,
                        ``thresholds:(from, to)`` -> ``ThresholdConfig``,
                        ``resistance:`` ``ResistanceConfig``?,
                        ``velocityThreshold:`` ``Dp``
                    )

               **This function is deprecated.** Material's Swipeable has been
               replaced by Foundation's AnchoredDraggable APIs.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalWearMaterialApi`` ``<T:Any?>`` ``Modifier``.``swipeable`` (
                        ``state:`` ``SwipeableState<T>``,
                        ``anchors:`` ``Map<Float,T>``,
                        ``orientation:`` ``Orientation``,
                        ``enabled:`` ``Boolean``,
                        ``reverseDirection:`` ``Boolean``,
                        ``interactionSource:`` ``MutableInteractionSource``?,
                        ``thresholds:(from, to)`` -> ``ThresholdConfig``,
                        ``resistance:`` ``ResistanceConfig``?,
                        ``velocityThreshold:`` ``Dp``
                    )

               Enable swipe gestures between a set of predefined states.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``toggleable`` (
                        ``value:`` ``Boolean``,
                        ``enabled:`` ``Boolean``,
                        ``role:`` ``Role``?,
                        ``onValueChange:``( ``Boolean`` ) -> ``Unit``
                    )

               Configure component to make it toggleable via input and
               accessibility events

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``toggleable`` (
                        ``value:`` ``Boolean``,
                        ``interactionSource:`` ``MutableInteractionSource``,
                        ``indication:`` ``Indication``?,
                        ``enabled:`` ``Boolean``,
                        ``role:`` ``Role``?,
                        ``onValueChange:``( ``Boolean`` ) -> ``Unit``
                    )

               Configure component to make it toggleable via input and
               accessibility events.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``triStateToggleable`` (
                        ``state:`` ``ToggleableState``,
                        ``enabled:`` ``Boolean``,
                        ``role:`` ``Role``?,
                        ``onClick:()`` -> ``Unit``
                    )

               Configure component to make it toggleable via input and
               accessibility events with three states: On, Off and
               Indeterminate.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``triStateToggleable`` (
                        ``state:`` ``ToggleableState``,
                        ``interactionSource:`` ``MutableInteractionSource``,
                        ``indication:`` ``Indication``?,
                        ``enabled:`` ``Boolean``,
                        ``role:`` ``Role``?,
                        ``onClick:()`` -> ``Unit``
                    )

               Configure component to make it toggleable via input and
               accessibility events with three states: On, Off and
               Indeterminate.

   .. rubric:: :heading:`Alignment`
      :name: Alignment

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: ``RowScope``
            - 
               .. container::

                  ``Modifier``.``align`` (``alignment:`` ``Alignment.Vertical`` )

               Align the element vertically within the
               ``Row``.

         - 
            -  Scope: ``RowScope``
            - 
               .. container::

                  ``Modifier``.``alignBy`` (``alignmentLineBlock:``( ``Measured`` ) -> ``Int`` )

               Position the element vertically such that the alignment line for
               the content as determined by ``alignmentLineBlock``
               aligns with sibling elements also configured to ``alignBy``.

         - 
            -  Scope: ``RowScope``
            - 
               .. container::

                  ``Modifier``.``alignBy`` (``alignmentLine:`` ``HorizontalAlignmentLine`` )

               Position the element vertically such that its
               ``alignmentLine``
               aligns with sibling elements also configured to
               ``alignBy``.

         - 
            -  Scope: ``RowScope``
            - 
               .. container::

                  ``Modifier``.``alignByBaseline`` ()

               Position the element vertically such that its first baseline
               aligns with sibling elements also configured to
               ``alignByBaseline``
               or
               ``alignBy``.

         - 
            -  Scope: ``ColumnScope``
            - 
               .. container::

                  ``Modifier``.``align`` (``alignment:`` ``Alignment.Horizontal`` )

               Align the element horizontally within the
               ``Column``.

         - 
            -  Scope: ``ColumnScope``
            - 
               .. container::

                  ``Modifier``.``alignBy`` (``alignmentLineBlock:``( ``Measured`` ) -> ``Int`` )

               Position the element horizontally such that the alignment line
               for the content as determined by
               ``alignmentLineBlock``
               aligns with sibling elements also configured to
               ``alignBy``.

         - 
            -  Scope: ``ColumnScope``
            - 
               .. container::

                  ``Modifier``.``alignBy`` (``alignmentLine:`` ``VerticalAlignmentLine`` )

               Position the element horizontally such that its
               ``alignmentLine``
               aligns with sibling elements also configured to
               ``alignBy``.

         - 
            -  Scope: ``BoxScope``
            - 
               .. container::

                  ``Modifier``.``align`` (``alignment:`` ``Alignment`` )

               Pull the content element to a specific
               ``Alignment``
               within the
               ``Box``.

   .. rubric:: :heading:`Animation`
      :name: Animation

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: ``AnimatedVisibilityScope`` ``open``
            - 
               .. container::

                  ``@`` ``ExperimentalAnimationApi`` ``Modifier``.``animateEnterExit`` (
                        ``enter:`` ``EnterTransition``,
                        ``exit:`` ``ExitTransition``,
                        ``label:`` ``String``
                    )

               ``animateEnterExit``
               modifier can be used for any direct or indirect children of
               ``AnimatedVisibility``
               to create a different enter/exit animation than what's specified
               in ``AnimatedVisibility``.

         - 
            -  Scope: ``LazyItemScope``
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``animateItemPlacement`` (
                        ``animationSpec:`` ``FiniteAnimationSpec`` ``<IntOffset>``
                    )

               This modifier animates the item placement within the Lazy list.

         - 
            -  Scope: ``LazyStaggeredGridItemScope``
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``animateItemPlacement`` (
                        ``animationSpec:`` ``FiniteAnimationSpec`` ``<IntOffset>``
                    )

               This modifier animates the item placement within the grid.

   .. rubric:: :heading:`Border`
      :name: Border

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``border`` (``border:`` ``BorderStroke`` ``,shape:`` ``Shape`` )

               Modify element to add border with appearance specified with a
               ``border`` and a ``shape`` and clip it.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``border`` (``width:`` ``Dp`` ``,brush:`` ``Brush`` ``,shape:`` ``Shape`` )

               Modify element to add border with appearance specified with a
               ``width``, a ``brush`` and a ``shape`` and clip it.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``border`` (``width:`` ``Dp`` ``,color:`` ``Color`` ``,shape:`` ``Shape`` )

               Modify element to add border with appearance specified with a
               ``width``, a ``color`` and a ``shape`` and clip it.

   .. rubric:: :heading:`Drawing`
      :name: Drawing

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``alpha`` (``alpha:`` ``Float`` )

               Draw content with modified alpha that may be less than 1.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``background`` (``color:`` ``Color`` ``,shape:`` ``Shape`` )

               Draws ``shape`` with a solid ``color`` behind the content.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``background`` (
                        ``brush:`` ``Brush``,
                        ``shape:`` ``Shape``,
                        ``alpha:@`` ``FloatRange`` (``from=0.0,to=1.0``) ``Float``
                    )

               Draws ``shape`` with ``brush`` behind the content.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``clip`` (``shape:`` ``Shape`` )

               Clip the content to ``shape``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``clipToBounds`` ()

               Clip the content to the bounds of a layer defined at this modifier.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``drawBehind`` (``onDraw:`` ``DrawScope``.( ) -> ``Unit`` )

               Draw into a ``Canvas`` behind the modified content.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``drawWithCache`` (``onBuildDrawCache:`` ``CacheDrawScope``.( ) -> ``DrawResult`` )

               Draw into a ``DrawScope``
               with content that is persisted across draw calls as long as the
               size of the drawing area is the same or any state objects that
               are read have not changed.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``drawWithContent`` (``onDraw:`` ``ContentDrawScope``.( ) -> ``Unit`` )

               Creates a ``DrawModifier``
               that allows the developer to draw before or after the layout's
               contents.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``indication`` (
                        ``interactionSource:`` ``InteractionSource``,
                        ``indication:`` ``Indication``?
                    )

               Draws visual effects for this component when interactions occur.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``paint`` (
                        ``painter:`` ``Painter``,
                        ``sizeToIntrinsics:`` ``Boolean``,
                        ``alignment:`` ``Alignment``,
                        ``contentScale:`` ``ContentScale``,
                        ``alpha:`` ``Float``,
                        ``colorFilter:`` ``ColorFilter``?
                    )

               Paint the content using ``painter``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``shadow`` (
                        ``elevation:`` ``Dp``,
                        ``shape:`` ``Shape``,
                        ``clip:`` ``Boolean``,
                        ``ambientColor:`` ``Color``,
                        ``spotColor:`` ``Color``
                    )

               Creates a ``graphicsLayer`` that draws a shadow.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``safeDrawingPadding`` ()

               Adds padding to accommodate the ``safe drawing`` insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``zIndex`` (``zIndex:`` ``Float`` )

               Creates a modifier that controls the drawing order for the
               children of the same layout parent.

   .. rubric:: :heading:`Focus`
      :name: Focus

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``onFocusChanged`` (``onFocusChanged:``( ``FocusState`` ) -> ``Unit`` )

               Add this modifier to a component to observe focus state events.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``onFocusEvent`` (``onFocusEvent:``( ``FocusState`` ) -> ``Unit`` )

               Add this modifier to a component to observe focus state events.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``focusModifier`` ()

               **This function is deprecated.** Replaced by focusTarget

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``focusTarget`` ()

               Add this modifier to a component to make it focusable.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``focusOrder`` (``focusOrderReceiver:`` ``FocusOrder``.( ) -> ``Unit`` )

               **This function is deprecated.** Use focusProperties() instead

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``focusOrder`` (``focusRequester:`` ``FocusRequester`` )

               **This function is deprecated.** Use focusRequester() instead

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``focusOrder`` (
                        ``focusRequester:`` ``FocusRequester``,
                        ``focusOrderReceiver:`` ``FocusOrder``.( ) -> ``Unit``
                    )

               **This function is deprecated.** Use focusProperties() and
               focusRequester() instead

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``focusProperties`` (``scope:`` ``FocusProperties``.( ) -> ``Unit`` )

               This modifier allows you to specify properties that are
               accessible to
               ``focusTarget``s
               further down the modifier chain or on child layout nodes.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``focusRequester`` (``focusRequester:`` ``FocusRequester`` )

               Add this modifier to a component to request changes to focus.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``focusRestorer`` (``onRestoreFailed:(()`` -> ``FocusRequester`` ``)?)``

               This modifier can be used to save and restore focus to a focus group.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``focusGroup`` ()

               Creates a focus group or marks this component as a focus group.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``focusable`` (
                        ``enabled:`` ``Boolean``,
                        ``interactionSource:`` ``MutableInteractionSource``?
                    )

               Configure component to be focusable via focus system or
               accessibility "focus" event.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``onFocusedBoundsChanged`` (
                        ``onPositioned:``( ``LayoutCoordinates`` ``?)`` -> ``Unit``
                    )

               Calls ``onPositioned`` whenever the bounds of the currently-focused area changes.

   .. rubric:: :heading:`Graphics`
      :name: Graphics

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``graphicsLayer`` (``block:`` ``GraphicsLayerScope``.( ) -> ``Unit`` )

               A ``Modifier.Node`` that makes content draw into a draw layer.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``graphicsLayer`` (
                        ``scaleX:`` ``Float``,
                        ``scaleY:`` ``Float``,
                        ``alpha:`` ``Float``,
                        ``translationX:`` ``Float``,
                        ``translationY:`` ``Float``,
                        ``shadowElevation:`` ``Float``,
                        ``rotationX:`` ``Float``,
                        ``rotationY:`` ``Float``,
                        ``rotationZ:`` ``Float``,
                        ``cameraDistance:`` ``Float``,
                        ``transformOrigin:`` ``TransformOrigin``,
                        ``shape:`` ``Shape``,
                        ``clip:`` ``Boolean``,
                        ``renderEffect:`` ``RenderEffect``?,
                        ``ambientShadowColor:`` ``Color``,
                        ``spotShadowColor:`` ``Color``,
                        ``compositingStrategy:`` ``CompositingStrategy``
                    )

               A ``Modifier.Element`` that makes content draw into a draw layer.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``toolingGraphicsLayer`` ()

               A ``Modifier.Element``
               that adds a draw layer such that tooling can identify an element
               in the drawn image.

   .. rubric:: :heading:`Keyboard`
      :name: Keyboard

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``onKeyEvent`` (``onKeyEvent:``( ``KeyEvent`` ) -> ``Boolean`` )

               Adding this ``modifier`` to the ``modifier``
               parameter of a component will allow it to intercept hardware key
               events when it (or one of its children) is focused.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``onPreviewKeyEvent`` (``onPreviewKeyEvent:``( ``KeyEvent`` ) -> ``Boolean`` )

               Adding this ``modifier`` to the ``modifier``
               parameter of a component will allow it to intercept hardware key
               events when it (or one of its children) is focused.

   .. rubric:: :heading:`Layout`
      :name: Layout

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``layoutId`` (``layoutId:`` ``String``, ``tag:`` ``String`` ``?)``

               Alternative to ``androidx.compose.ui.layout.layoutId``
               that enables the use of ``tag``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``layoutId`` (``layoutId:`` ``Any`` )

               Tag the element with ``layoutId``
               to identify the element within its parent.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``layout`` (
                        ``measure:`` ``MeasureScope``.( ``Measurable`` , ``Constraints`` ) -> ``MeasureResult``
                    )

               Creates a ``LayoutModifier``
               that allows changing how the wrapped element is measured and laid out.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``onGloballyPositioned`` (
                        ``onGloballyPositioned:``( ``LayoutCoordinates`` ) -> ``Unit``
                    )

               Invoke ``onGloballyPositioned`` with the ``LayoutCoordinates``
               of the element when the global position of the content may have changed.

   .. rubric:: :heading:`Padding`
      :name: Padding

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``paddingFrom`` (
                        ``alignmentLine:`` ``AlignmentLine``,
                        ``before:`` ``Dp``,
                        ``after:`` ``Dp``
                    )

               A ``Modifier``
               that can add padding to position the content according to
               specified distances from its bounds to an ``alignment line``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``paddingFrom`` (
                        ``alignmentLine:`` ``AlignmentLine``,
                        ``before:`` ``TextUnit``,
                        ``after:`` ``TextUnit``
                    )

               A ``Modifier``
               that can add padding to position the content according to
               specified distances from its bounds to an
               ``alignment line``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``paddingFromBaseline`` (
                        ``top:`` ``Dp``
                        ``bottom:`` ``Dp``
                    )

               A ``Modifier``
               that positions the content in a layout such that the distance
               from the top of the layout to the
               ``baseline of the first line of text in the content``
               is ``top``, and the distance from the
               ``baseline of the last line of text in the content``
               to the bottom of the layout is ``bottom``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``paddingFromBaseline`` (
                        ``top:`` ``TextUnit``,
                        ``bottom:`` ``TextUnit``
                    )

               A ``Modifier``
               that positions the content in a layout such that the distance
               from the top of the layout to the
               ``baseline of the first line of text in the content``
               is ``top``, and the distance from the
               ``baseline of the last line of text in the content``
               to the bottom of the layout is ``bottom``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``absolutePadding`` (
                        ``left:`` ``Dp``,
                        ``top:`` ``Dp``,
                        ``right:`` ``Dp``,
                        ``bottom:`` ``Dp``
                    )

               Apply additional space along each edge of the content in
               ``Dp``: ``left``, ``top``, ``right`` and ``bottom``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``padding`` (``all:`` ``Dp`` )

               Apply ``all``
               dp of additional space along each edge of the content, left, top,
               right and bottom.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``padding`` (``paddingValues:`` ``PaddingValues`` )

               Apply ``PaddingValues``
               to the component as additional space along each edge of the
               content's left, top, right and bottom.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``padding`` (``horizontal:`` ``Dp`` ``,vertical:`` ``Dp`` )

               Apply ``horizontal``
               dp space along the left and right edges of the content, and
               ``vertical`` dp space along the top and bottom edges.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``padding`` (
                        ``start:`` ``Dp``,
                        ``top:`` ``Dp``,
                        ``end:`` ``Dp``,
                        ``bottom:`` ``Dp``
                    )

               Apply additional space along each edge of the content in
               ``Dp``: ``start``, ``top``, ``end`` and ``bottom``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``captionBarPadding`` ()

               Adds padding to accommodate the ``caption bar`` insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``displayCutoutPadding`` ()

               Adds padding to accommodate the ``display cutout``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``imePadding`` ()

               Adds padding to accommodate the ``ime`` insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``mandatorySystemGesturesPadding`` ()

               Adds padding to accommodate the ``mandatory system gestures`` insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``navigationBarsPadding`` ()

               Adds padding to accommodate the ``navigation bars`` insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``safeContentPadding`` ()

               Adds padding to accommodate the ``safe content`` insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``safeGesturesPadding`` ()

               Adds padding to accommodate the ``safe gestures`` insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``statusBarsPadding`` ()

               Adds padding to accommodate the ``status bars`` insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``systemBarsPadding`` ()

               Adds padding to accommodate the ``system bars`` insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``systemGesturesPadding`` ()

               Adds padding to accommodate the ``system gestures`` insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``waterfallPadding`` ()

               Adds padding to accommodate the ``waterfall`` insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``windowInsetsPadding`` (``insets:`` ``WindowInsets`` )

               Adds padding so that the content doesn't enter ``insets`` space.

   .. rubric:: :heading:`Pointer`
      :name: Pointer

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``pointerHoverIcon`` (
                        ``icon:`` ``PointerIcon``,
                        ``overrideDescendants:`` ``Boolean``
                    )

               Modifier that lets a developer define a pointer icon to display
               when the cursor is hovered over the element.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``pointerInteropFilter`` (

                        ``requestDisallowInterceptTouchEvent:`` ``RequestDisallowInterceptTouchEvent``?,
                        ``onTouchEvent:``( ``MotionEvent`` ) -> ``Boolean``
                    )

               A special PointerInputModifier that provides access to the
               underlying ``MotionEvent``s originally dispatched to Compose.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``pointerMoveFilter`` (

                        ``onMove:(position:`` ``Offset`` ) -> ``Boolean``,
                        ``onExit:()`` -> ``Boolean``,
                        ``onEnter:()`` -> ``Boolean``
                    )

               Modifier allowing to track pointer (i.e. mouse or trackpad) move
               events.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``pointerInput`` (
                        ``block:suspend`` ``PointerInputScope``.( ) -> ``Unit``
                    )

               **This function is deprecated.** Modifier.pointerInput must
               provide one or more 'key' parameters that define the identity of
               the modifier and determine when its previous input processing
               coroutine should be cancelled and a new effect launched for the
               new key.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``pointerInput`` (
                        ``key1:`` ``Any``?,
                        ``block:suspend`` ``PointerInputScope``.( ) -> ``Unit``
                    )

               Create a modifier for processing pointer input within the region
               of the modified element.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``pointerInput`` (
                        ``varargkeys:`` ``Any``?,
                        ``block:suspend`` ``PointerInputScope``.( ) -> ``Unit``
                    )

               Create a modifier for processing pointer input within the region
               of the modified element.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``pointerInput`` (
                        ``key1:`` ``Any``?,
                        ``key2:`` ``Any``?,
                        ``block:suspend`` ``PointerInputScope``.( ) -> ``Unit``
                    )

               Create a modifier for processing pointer input within the region
               of the modified element.

   .. rubric:: :heading:`Position`
      :name: Position

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``absoluteOffset`` (``offset:`` ``Density``.( ) -> ``IntOffset`` )

               Offset the content by ``offset`` px.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``absoluteOffset`` (``x:`` ``Dp`` ``,y:`` ``Dp`` )

               Offset the content by (``x`` dp, ``y`` dp).

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``offset`` (``offset:`` ``Density``.( ) -> ``IntOffset`` )

               Offset the content by ``offset`` px.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``offset`` (``x:`` ``Dp`` ``,y:`` ``Dp`` )

               Offset the content by (``x`` dp, ``y`` dp).

         - 
            -  Scope: ``TabRowDefaults``
            - 
               .. container::

                  ``Modifier``.``tabIndicatorOffset`` (``currentTabPosition:`` ``TabPosition`` )

               ``Modifier`` that takes up all the available width inside the ``TabRow``,
               and then animates the offset of the indicator it is applied to,
               depending on the ``currentTabPosition``.

         - 
            -  Scope: ``TabRowDefaults``
            - 
               .. container::

                  ``Modifier``.``tabIndicatorOffset`` (``currentTabPosition:`` ``TabPosition`` )

               ``Modifier`` that takes up all the available width inside the ``TabRow``,
               and then animates the offset of the indicator it is applied to,
               depending on the ``currentTabPosition``.

   .. rubric:: :heading:`Semantics`
      :name: Semantics

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``progressSemantics`` ()

               Contains the ``semantics``
               required for an indeterminate progress indicator, that represents
               the fact of the in-progress operation.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``progressSemantics`` (
                        ``value:`` ``Float``,
                        ``valueRange:`` ``ClosedFloatingPointRange`` ``<Float>``,
                        ``steps:@`` ``IntRange`` (``from=0``) ``Int``
                    )

               Contains the ``semantics``
               required for a determinate progress indicator or the progress
               part of a slider, that represents progress within ``valueRange``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``rangeSemantics`` (
                        ``value:`` ``Float``,
                        ``enabled:`` ``Boolean``,
                        ``onValueChange:``( ``Float`` ) -> ``Unit``,
                        ``valueRange:`` ``ClosedFloatingPointRange`` ``<Float>``,
                        ``steps:`` ``Int``
                    )

               Modifier to add semantics signifying progress of the Stepper/Slider.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``clearAndSetSemantics`` (
                        ``properties:`` ``SemanticsPropertyReceiver``.( ) -> ``Unit``
                    )

               Clears the semantics of all the descendant nodes and sets new semantics.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``semantics`` (
                        ``mergeDescendants:`` ``Boolean``,
                        ``properties:`` ``SemanticsPropertyReceiver``.( ) -> ``Unit``
                    )

               Add semantics key/value pairs to the layout node, for use in
               testing, accessibility, etc.

   .. rubric:: :heading:`Scroll`
      :name: Scroll

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``clipScrollableContainer`` (``orientation:`` ``Orientation`` )

               Clips bounds of scrollable container on main axis while leaving
               space for background effects (like shadows) on cross axis.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``mouseScrollFilter`` (
                        ``onMouseScroll:(event:`` ``MouseScrollEvent`` ``, bounds:`` ``IntSize`` ) -> ``Boolean``
                    )

               **This function is deprecated.** Use Modifier.pointerInput +
               PointerEventType.Scroll

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``nestedScroll`` (
                        ``connection:`` ``NestedScrollConnection``,
                        ``dispatcher:`` ``NestedScrollDispatcher``?
                    )

               Modify element to make it participate in the nested scrolling hierarchy.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``overscroll`` (``overscrollEffect:`` ``OverscrollEffect`` )

               Renders overscroll from the provided ``overscrollEffect``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``onPreRotaryScrollEvent`` (
                        ``onPreRotaryScrollEvent:``( ``RotaryScrollEvent`` ) -> ``Boolean``
                    )

               Adding this ``modifier`` to the ``modifier``
               parameter of a component will allow it to intercept
               ``RotaryScrollEvent``s if it (or one of its children) is focused.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``onRotaryScrollEvent`` (
                        ``onRotaryScrollEvent:``( ``RotaryScrollEvent`` ) -> ``Boolean``
                    )

               Adding this ``modifier`` to the ``modifier``
               parameter of a component will allow it to intercept
               ``RotaryScrollEvent``s if it (or one of its children) is focused.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``scrollAway`` (``scrollState:`` ``ScrollState`` ``,offset:`` ``Dp`` )

               Scroll an item vertically in/out of view based on a ``ScrollState``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``scrollAway`` (
                        ``scrollState:`` ``LazyListState``,
                        ``itemIndex:`` ``Int``,
                        ``offset:`` ``Dp``
                    )

               Scroll an item vertically in/out of view based on a ``LazyListState``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``scrollAway`` (
                        ``scrollState:`` ``ScalingLazyListState``,
                        ``itemIndex:`` ``Int``,
                        ``offset:`` ``Dp``
                    )

               Scroll an item vertically in/out of view based on a
               ``ScalingLazyListState``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``scrollAway`` (
                        ``scrollState:`` ``ScalingLazyListState``,
                        ``itemIndex:`` ``Int``,
                        ``offset:`` ``Dp``
                    )

               **This function is deprecated.** This overload is provided for
               backwards compatibility with Compose for Wear OS 1.1.A newer
               overload is available which uses ScalingLazyListState from
               wear.compose.foundation.lazy package

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``horizontalScroll`` (
                        ``state:`` ``ScrollState``,
                        ``enabled:`` ``Boolean``,
                        ``flingBehavior:`` ``FlingBehavior``?,
                        ``reverseScrolling:`` ``Boolean``
                    )

               Modify element to allow to scroll horizontally when width of the
               content is bigger than max constraints allow.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``verticalScroll`` (
                        ``state:`` ``ScrollState``,
                        ``enabled:`` ``Boolean``,
                        ``flingBehavior:`` ``FlingBehavior``?,
                        ``reverseScrolling:`` ``Boolean``
                    )

               Modify element to allow to scroll vertically when height of the
               content is bigger than max constraints allow.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``scrollable`` (
                        ``state:`` ``ScrollableState``,
                        ``orientation:`` ``Orientation``,
                        ``enabled:`` ``Boolean``,
                        ``reverseDirection:`` ``Boolean``,
                        ``flingBehavior:`` ``FlingBehavior``?,
                        ``interactionSource:`` ``MutableInteractionSource``?
                    )

               Configure touch scrolling and flinging for the UI element in a
               single ``Orientation``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``scrollable`` (
                        ``state:`` ``ScrollableState``,
                        ``orientation:`` ``Orientation``,
                        ``overscrollEffect:`` ``OverscrollEffect``?,
                        ``enabled:`` ``Boolean``,
                        ``reverseDirection:`` ``Boolean``,
                        ``flingBehavior:`` ``FlingBehavior``?,
                        ``interactionSource:`` ``MutableInteractionSource``?,
                        ``bringIntoViewSpec:`` ``BringIntoViewSpec``
                    )

               Configure touch scrolling and flinging for the UI element in a
               single
               ``Orientation``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalTvFoundationApi`` ``Modifier``.``scrollableWithPivot`` (
                        ``state:`` ``ScrollableState``,
                        ``orientation:`` ``Orientation``,
                        ``pivotOffsets:`` ``PivotOffsets``,
                        ``enabled:`` ``Boolean``,
                        ``reverseDirection:`` ``Boolean``
                    )

               Configure touch scrolling and flinging for the UI element in a
               single
               ``Orientation``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalLayoutApi`` ``Modifier``.``imeNestedScroll`` ()

               Controls the soft keyboard as a nested scrolling on Android
               ``R`` and later.

   .. rubric:: :heading:`Size`
      :name: Size

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``animateContentSize`` (
                        ``animationSpec:`` ``FiniteAnimationSpec`` ``<IntSize>``,
                        ``finishedListener:((initialValue:`` ``IntSize`` ``, targetValue:`` ``IntSize`` ) -> ``Unit`` )?
                    )

               This modifier animates its own size when its child modifier (or
               the child composable if it is already at the tail of the chain)
               changes size.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``aspectRatio`` (
                        ``ratio:@`` ``FloatRange`` (``from=0.0,fromInclusive=false``) ``Float``,
                        ``matchHeightConstraintsFirst:`` ``Boolean``
                    )

               Attempts to size the content to match a specified aspect ratio by
               trying to match one of the incoming constraints in the following
               order:
               ``Constraints.maxWidth``,
               ``Constraints.maxHeight``,
               ``Constraints.minWidth``,
               ``Constraints.minHeight``
               if ``matchHeightConstraintsFirst`` is ``false`` (which is the default), or
               ``Constraints.maxHeight``,
               ``Constraints.maxWidth``,
               ``Constraints.minHeight``,
               ``Constraints.minWidth``
               if ``matchHeightConstraintsFirst`` is ``true``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``minimumInteractiveComponentSize`` ()

               Reserves at least 48.dp in size to disambiguate touch
               interactions if the element would measure smaller.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``minimumInteractiveComponentSize`` ()

               Reserves at least 48.dp in size to disambiguate touch
               interactions if the element would measure smaller.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``minimumInteractiveComponentSize`` ()

               Reserves at least 48.dp in size to disambiguate touch
               interactions if the element would measure smaller.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``height`` (``intrinsicSize:`` ``IntrinsicSize`` )

               Declare the preferred height of the content to be the same as the
               min or max intrinsic height of the content.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``requiredHeight`` (``intrinsicSize:`` ``IntrinsicSize`` )

               Declare the height of the content to be exactly the same as the
               min or max intrinsic height of the content.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``requiredWidth`` (``intrinsicSize:`` ``IntrinsicSize`` )

               Declare the width of the content to be exactly the same as the
               min or max intrinsic width of the content.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``width`` (``intrinsicSize:`` ``IntrinsicSize`` )

               Declare the preferred width of the content to be the same as the
               min or max intrinsic width of the content.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``onSizeChanged`` (``onSizeChanged:``( ``IntSize`` ) -> ``Unit`` )

               Invoked with the size of the modified Compose UI element when the
               element is first measured or when the size of the element
               changes.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``defaultMinSize`` (``minWidth:`` ``Dp`` ``,minHeight:`` ``Dp`` )

               Constrain the size of the wrapped layout only when it would be
               otherwise unconstrained: the ``minWidth`` and ``minHeight``
               constraints are only applied when the incoming corresponding
               constraint is ``0``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``fillMaxHeight`` (``fraction:@`` ``FloatRange`` (``from=0.0,to=1.0``) ``Float`` )

               Have the content fill (possibly only partially) the
               ``Constraints.maxHeight``
               of the incoming measurement constraints, by setting the
               ``minimum height`` and the ``maximum height``
               to be equal to the ``maximum height`` multiplied by ``fraction``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``fillMaxSize`` (``fraction:@`` ``FloatRange`` (``from=0.0,to=1.0``) ``Float`` )

               Have the content fill (possibly only partially) the
               ``Constraints.maxWidth`` and ``Constraints.maxHeight``
               of the incoming measurement constraints, by setting the
               ``minimum width`` and the ``maximum width``
               to be equal to the ``maximum width`` multiplied by ``fraction``,
               as well as the ``minimum height`` and the ``maximum height``
               to be equal to the ``maximum height`` multiplied by ``fraction``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``fillMaxWidth`` (``fraction:@`` ``FloatRange`` (``from=0.0,to=1.0``) ``Float`` )

               Have the content fill (possibly only partially) the
               ``Constraints.maxWidth``
               of the incoming measurement constraints, by setting the
               ``minimum width`` and the ``maximum width``
               to be equal to the ``maximum width`` multiplied by ``fraction``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``height`` (``height:`` ``Dp`` )

               Declare the preferred height of the content to be exactly ``height`` dp.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``heightIn`` (``min:`` ``Dp`` ``,max:`` ``Dp`` )

               Constrain the height of the content to be between
               ``min`` dp and ``max`` dp
               as permitted by the incoming measurement ``Constraints``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``requiredHeight`` (``height:`` ``Dp`` )

               Declare the height of the content to be exactly ``height`` dp.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``requiredHeightIn`` (``min:`` ``Dp`` ``,max:`` ``Dp`` )

               Constrain the height of the content to be between
               ``min`` dp and ``max`` dp.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``requiredSize`` (``size:`` ``Dp`` )

               Declare the size of the content to be exactly ``size`` dp
               width and height.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``requiredSize`` (``size:`` ``DpSize`` )

               Declare the size of the content to be exactly ``size``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``requiredSize`` (``width:`` ``Dp`` ``,height:`` ``Dp`` )

               Declare the size of the content to be exactly
               ``width`` dp and ``height`` dp.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``requiredSizeIn`` (
                        ``minWidth:`` ``Dp``,
                        ``minHeight:`` ``Dp``,
                        ``maxWidth:`` ``Dp``,
                        ``maxHeight:`` ``Dp``
                    )

               Constrain the width of the content to be between
               ``minWidth`` dp and ``maxWidth`` dp,
               and the height of the content to be between
               ``minHeight`` dp and ``maxHeight`` dp.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``requiredWidth`` (``width:`` ``Dp`` )

               Declare the width of the content to be exactly ``width`` dp.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``requiredWidthIn`` (``min:`` ``Dp`` ``,max:`` ``Dp`` )

               Constrain the width of the content to be between
               ``min`` dp and ``max`` dp.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``size`` (``size:`` ``Dp`` )

               Declare the preferred size of the content to be exactly
               ``size`` dp square.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``size`` (``size:`` ``DpSize`` )

               Declare the preferred size of the content to be exactly ``size``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``size`` (``width:`` ``Dp`` ``,height:`` ``Dp`` )

               Declare the preferred size of the content to be exactly
               ``width`` dp by ``height`` dp.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``sizeIn`` (
                        ``minWidth:`` ``Dp``,
                        ``minHeight:`` ``Dp``,
                        ``maxWidth:`` ``Dp``,
                        ``maxHeight:`` ``Dp``
                    )

               Constrain the width of the content to be between
               ``minWidth`` dp and ``maxWidth`` dp
               and the height of the content to be between
               ``minHeight`` dp and ``maxHeight`` dp
               as permitted by the incoming measurement ``Constraints``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``width`` (``width:`` ``Dp`` )

               Declare the preferred width of the content to be exactly ``width`` dp.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``widthIn`` (``min:`` ``Dp`` ``,max:`` ``Dp`` )

               Constrain the width of the content to be between
               ``min`` dp and ``max`` dp
               as permitted by the incoming measurement
               ``Constraints``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``wrapContentHeight`` (
                        ``align:`` ``Alignment.Vertical``,
                        ``unbounded:`` ``Boolean``
                    )

               Allow the content to measure at its desired height without regard
               for the incoming measurement ``minimum height constraint``,
               and, if ``unbounded``
               is true, also without regard for the incoming measurement
               ``maximum height constraint``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``wrapContentSize`` (``align:`` ``Alignment`` ``,unbounded:`` ``Boolean`` )

               Allow the content to measure at its desired size without regard
               for the incoming measurement
               ``minimum width`` or ``minimum height`` constraints, and, if
               ``unbounded`` is true, also without regard for the incoming maximum
               constraints.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``wrapContentWidth`` (
                        ``align:`` ``Alignment.Horizontal``,
                        ``unbounded:`` ``Boolean``
                    )

               Allow the content to measure at its desired width without regard
               for the incoming measurement
               ``minimum width constraint``, and, if ``unbounded``
               is true, also without regard for the incoming measurement
               ``maximum width constraint``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``touchTargetAwareSize`` (``size:`` ``Dp`` )

               Modifier to set both the size and recommended touch target for
               ``IconButton`` and TextButton.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``windowInsetsBottomHeight`` (``insets:`` ``WindowInsets`` )

               Sets the height to that of ``insets`` at the ``bottom`` of the screen.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``windowInsetsEndWidth`` (``insets:`` ``WindowInsets`` )

               Sets the width to that of ``insets`` at the ``end``
               of the screen, using either ``left`` or ``right``,
               depending on the ``LayoutDirection``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``windowInsetsStartWidth`` (``insets:`` ``WindowInsets`` )

               Sets the width to that of ``insets`` at the ``start``
               of the screen, using either ``left`` or ``right``,
               depending on the ``LayoutDirection``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``windowInsetsTopHeight`` (``insets:`` ``WindowInsets`` )

               Sets the height to that of ``insets`` at the ``top``
               of the screen.

         - 
            -  Scope: ``RowScope``
            - 
               .. container::

                  ``Modifier``.``weight`` (
                        ``weight:@`` ``FloatRange`` (``from=0.0,fromInclusive=false``) ``Float``,
                        ``fill:`` ``Boolean``
                    )

               Size the element's width proportional to its ``weight``
               relative to other weighted sibling elements in the ``Row``.

         - 
            -  Scope: ``ColumnScope``
            - 
               .. container::

                  ``Modifier``.``weight`` (
                        ``weight:@`` ``FloatRange`` (``from=0.0,fromInclusive=false``) ``Float``,
                        ``fill:`` ``Boolean``
                    )

               Size the element's height proportional to its ``weight``
               relative to other weighted sibling elements in the ``Column``.

         - 
            -  Scope: ``BoxScope``
            - 
               .. container::

                  ``Modifier``.``matchParentSize`` ()

               Size the element to match the size of the ``Box``
               after all other content elements have been measured.

         - 
            -  Scope: ``LazyItemScope``
            - 
               .. container::

                  ``Modifier``.``fillParentMaxHeight`` (
                        ``fraction:@`` ``FloatRange`` (``from=0.0,to=1.0``) ``Float``
                    )

               Have the content fill the ``Constraints.maxHeight``
               of the incoming measurement constraints by setting the
               ``minimum height`` to be equal to the ``maximum height``
               multiplied by ``fraction``.

         - 
            -  Scope: ``LazyItemScope``
            - 
               .. container::

                  ``Modifier``.``fillParentMaxSize`` (
                        ``fraction:@`` ``FloatRange`` (``from=0.0,to=1.0``) ``Float``
                    )

               Have the content fill the ``Constraints.maxWidth``
               and ``Constraints.maxHeight``
               of the parent measurement constraints by setting the
               ``minimum width`` to be equal to the
               ``maximum width`` multiplied by ``fraction``
               and the ``minimum height`` to be equal to the
               ``maximum height`` multiplied by ``fraction``.

         - 
            -  Scope: ``LazyItemScope``
            - 
               .. container::

                  ``Modifier``.``fillParentMaxWidth`` (
                        ``fraction:@`` ``FloatRange`` (``from=0.0,to=1.0``) ``Float``
                    )

               Have the content fill the ``Constraints.maxWidth``
               of the parent measurement constraints by setting the
               ``minimum width`` to be equal to the
               ``maximum width`` multiplied by ``fraction``.

         - 
            -  Scope: ``ExposedDropdownMenuBoxScope``
            - 
               .. container::

                  ``Modifier``.``exposedDropdownSize`` (``matchTextFieldWidth:`` ``Boolean`` )

               Modifier which should be applied to an ``ExposedDropdownMenu``
               placed inside the scope.

         - 
            -  Scope: ``ExposedDropdownMenuBoxScope``
            - 
               .. container::

                  ``Modifier``.``exposedDropdownSize`` (``matchTextFieldWidth:`` ``Boolean`` )

               Modifier which should be applied to an ``ExposedDropdownMenu``
               placed inside the scope.

   .. rubric:: :heading:`Testing`
      :name: Testing

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``testTag`` (``tag:`` ``String`` )

               Applies a tag to allow modified element to be found in tests.

   .. rubric:: :heading:`Transformations`
      :name: Transformations

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``rotate`` (``degrees:`` ``Float`` )

               Sets the degrees the view is rotated around the center of the
               composable.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``scale`` (``scale:`` ``Float`` )

               Scale the contents of both the horizontal and vertical axis
               uniformly by the same scale factor.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``scale`` (``scaleX:`` ``Float`` ``,scaleY:`` ``Float`` )

               Scale the contents of the composable by the following scale
               factors along the horizontal and vertical axis respectively.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``transformable`` (
                        ``state:`` ``TransformableState``,
                        ``lockRotationOnZoomPan:`` ``Boolean``,
                        ``enabled:`` ``Boolean``
                    )

               Enable transformation gestures of the modified UI element.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``transformable`` (
                        ``state:`` ``TransformableState``,
                        ``canPan:``( ``Offset`` ) -> ``Boolean``,
                        ``lockRotationOnZoomPan:`` ``Boolean``,
                        ``enabled:`` ``Boolean``
                    )

               Enable transformation gestures of the modified UI element.

   .. rubric:: :heading:`Other`
      :name: Other

   .. container:: devsite-table-wrapper

      .. list-table::
         :widths: 40 40

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``dragAndDropSource`` (``block:suspend`` ``DragAndDropSourceScope``.( ) -> ``Unit`` )

               A Modifier that allows an element it is applied to to be treated
               like a source for drag and drop operations.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``basicMarquee`` (
                        ``iterations:`` ``Int``,
                        ``animationMode:`` ``MarqueeAnimationMode``,
                        ``delayMillis:`` ``Int``,
                        ``initialDelayMillis:`` ``Int``,
                        ``spacing:`` ``MarqueeSpacing``,
                        ``velocity:`` ``Dp``
                    )

               Applies an animated marquee effect to the modified content if
               it's too wide to fit in the available space.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``blur`` (``radius:`` ``Dp`` ``,edgeTreatment:`` ``BlurredEdgeTreatment`` )

               Draw content blurred with the specified radii.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``blur`` (
                        ``radiusX:`` ``Dp``,
                        ``radiusY:`` ``Dp``,
                        ``edgeTreatment:`` ``BlurredEdgeTreatment``
                    )

               Draw content blurred with the specified radii.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``bringIntoViewRequester`` (
                        ``bringIntoViewRequester:`` ``BringIntoViewRequester``
                    )

               Modifier that can be used to send ``bringIntoView`` requests.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``bringIntoViewResponder`` (``responder:`` ``BringIntoViewResponder`` )

               A parent that can respond to ``BringIntoViewRequester``
               requests from its children, and scroll so that the item is
               visible on screen.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``composed`` (
                        ``inspectorInfo:`` ``InspectorInfo``.( ) -> ``Unit``,
                        ``factory:@`` ``Composable`` ``Modifier``.( ) -> ``Modifier``
                    )

               Declare a just-in-time composition of a ``Modifier``
               that will be composed for each element it modifies.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``composed`` (

                        ``fullyQualifiedName:`` ``String``,
                        ``key1:`` ``Any``?,
                        ``inspectorInfo:`` ``InspectorInfo``.( ) -> ``Unit``,
                        ``factory:@`` ``Composable`` ``Modifier``.( ) -> ``Modifier``
                    )

               Declare a just-in-time composition of a ``Modifier``
               that will be composed for each element it modifies.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``composed`` (

                        ``fullyQualifiedName:`` ``String``,
                        ``varargkeys:`` ``Any``?,
                        ``inspectorInfo:`` ``InspectorInfo``.( ) -> ``Unit``,
                        ``factory:@`` ``Composable`` ``Modifier``.( ) -> ``Modifier``
                    )

               Declare a just-in-time composition of a ``Modifier``
               that will be composed for each element it modifies.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``composed`` (

                        ``fullyQualifiedName:`` ``String``,
                        ``key1:`` ``Any``?,
                        ``key2:`` ``Any``?,
                        ``inspectorInfo:`` ``InspectorInfo``.( ) -> ``Unit``,
                        ``factory:@`` ``Composable`` ``Modifier``.( ) -> ``Modifier``
                    )

               Declare a just-in-time composition of a ``Modifier``
               that will be composed for each element it modifies.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``composed`` (

                        ``fullyQualifiedName:`` ``String``,
                        ``key1:`` ``Any``?,
                        ``key2:`` ``Any``?,
                        ``key3:`` ``Any``?,
                        ``inspectorInfo:`` ``InspectorInfo``.( ) -> ``Unit``,
                        ``factory:@`` ``Composable`` ``Modifier``.( ) -> ``Modifier``
                    )

               Declare a just-in-time composition of a ``Modifier``
               that will be composed for each element it modifies.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``dragAndDropSource`` (
                        ``drawDragDecoration:`` ``DrawScope``.( ) -> ``Unit``,
                        ``block:suspend`` ``DragAndDropSourceScope``.( ) -> ``Unit``
                    )

               A Modifier that allows an element it is applied to to be treated
               like a source for drag and drop operations.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalFoundationApi``
                  ``Modifier``.``dragAndDropTarget`` (
                        ``onStarted:(event:`` ``DragAndDropEvent`` ) -> ``Boolean``,
                        ``onDropped:(event:`` ``DragAndDropEvent`` ) -> ``Boolean``,
                        ``onEntered:(event:`` ``DragAndDropEvent`` ) -> ``Unit``,
                        ``onMoved:(event:`` ``DragAndDropEvent`` ) -> ``Unit``,
                        ``onChanged:(event:`` ``DragAndDropEvent`` ) -> ``Unit``,
                        ``onExited:(event:`` ``DragAndDropEvent`` ) -> ``Unit``,
                        ``onEnded:(event:`` ``DragAndDropEvent`` ) -> ``Unit``
                    )

               A modifier that allows for receiving from a drag and drop
               gesture.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``excludeFromSystemGesture`` ()

               **This function is deprecated.** Use systemGestureExclusion

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``excludeFromSystemGesture`` (
                        ``exclusion:``( ``LayoutCoordinates`` ) -> ``Rect``
                    )

               **This function is deprecated.** Use systemGestureExclusion

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``hoverable`` (
                        ``interactionSource:`` ``MutableInteractionSource``,
                        ``enabled:`` ``Boolean``
                    )

               Configure component to be hoverable via pointer enter/exit
               events.

         - 
            -  Scope: **Any** ``inline``
            - 
               .. container::

                  ``Modifier``.``inspectable`` (
                        ``noinlineinspectorInfo:`` ``InspectorInfo``.( ) -> ``Unit``,
                        ``factory:`` ``Modifier``.( ) -> ``Modifier``
                    )

               Use this to group a common set of modifiers and provide
               ``InspectorInfo`` for the resulting modifier.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``intermediateLayout`` (
                        ``measure:`` ``IntermediateMeasureScope``.( 
                            ``measurable:`` ``Measurable``,
                            ``constraints:`` ``Constraints``
                        ) -> ``MeasureResult``
                    )

               Creates an intermediate layout intended to help morph the layout
               from the current layout to the lookahead (i.e. pre-calculated
               future) layout.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``magnifier`` (
                        ``sourceCenter:`` ``Density``.( ) -> ``Offset``,
                        ``magnifierCenter:`` ``Density``.( ) -> ``Offset``,
                        ``onSizeChanged:((`` ``DpSize`` ) -> ``Unit``?, ``zoom:`` ``Float``,
                        ``size:`` ``DpSize``,
                        ``cornerRadius:`` ``Dp``,
                        ``elevation:`` ``Dp``,
                        ``clippingEnabled:`` ``Boolean``
                    )

               Shows a ``Magnifier``
               widget that shows an enlarged version of the content at
               ``sourceCenter`` relative to the current layout node.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``modifierLocalConsumer`` (``consumer:`` ``ModifierLocalReadScope``.( ) -> ``Unit`` )

               A Modifier that can be used to consume ``ModifierLocal``s
               that were provided by other modifiers to the left of this
               modifier, or above this modifier in the layout tree.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``

                  ``<T:Any?>`` ``Modifier``.``modifierLocalProvider`` (
                        ``key:`` ``ProvidableModifierLocal`` ``<T>,`` ``value:()`` -> ``T``
                    )

               A Modifier that can be used to provide ``ModifierLocal``s
               that can be read by other modifiers to the right of this
               modifier, or modifiers that are children of the layout node that
               this modifier is attached to.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``onPlaced`` (``onPlaced:``( ``LayoutCoordinates`` ) -> ``Unit`` )

               Invoke ``onPlaced`` after the parent ``LayoutModifier``
               and parent layout has been placed and before child
               ``LayoutModifier`` is placed.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalWearMaterialApi`` ``@`` ``Composable`` ``Modifier``.``placeholder`` (
                        ``placeholderState:`` ``PlaceholderState``,
                        ``shape:`` ``Shape``,
                        ``color:`` ``Color``
                    )

               Draws a placeholder shape over the top of a composable and
               animates a wipe off effect to remove the placeholder.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalWearMaterialApi`` ``@`` ``Composable`` ``Modifier``.``placeholderShimmer`` (
                        ``placeholderState:`` ``PlaceholderState``,
                        ``shape:`` ``Shape``,
                        ``color:`` ``Color``
                    )

               Modifier to draw a placeholder shimmer over a component.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``motionEventSpy`` (``watcher:(motionEvent:`` ``MotionEvent`` ) -> ``Unit`` )

               Calls ``watcher`` with each ``MotionEvent``
               that the layout area or any child ``pointerInput`` receives.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``preferKeepClear`` ()

               Mark the layout rectangle as preferring to stay clear of floating
               windows.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``preferKeepClear`` (``rectProvider:``( ``LayoutCoordinates`` ) -> ``Rect`` )

               Mark a rectangle within the local layout coordinates preferring
               to stay clear of floating windows.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalMaterialApi``
                  ``Modifier``.``pullRefreshIndicatorTransform`` (
                        ``state:`` ``PullRefreshState``,
                        ``scale:`` ``Boolean``
                    )

               A modifier for translating the position and scaling the size of a
               pull-to-refresh indicator based on the given
               ``PullRefreshState``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalMaterialApi``
                  ``Modifier``.``pullRefresh`` (``state:`` ``PullRefreshState`` ``,enabled:`` ``Boolean`` )

               A nested scroll modifier that provides scroll events to
               ``state``.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalMaterialApi``
                  ``Modifier``.``pullRefresh`` (
                        ``onPull:(pullDelta:`` ``Float`` ) -> ``Float``,
                        ``onRelease:suspend(flingVelocity:`` ``Float`` ) -> ``Float``,
                        ``enabled:`` ``Boolean``
                    )

               A nested scroll modifier that provides ``onPull`` and ``onRelease``
               callbacks to aid building custom pull refresh components.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``onInterceptKeyBeforeSoftKeyboard`` (

                        ``onInterceptKeyBeforeSoftKeyboard:``( ``KeyEvent`` ) -> ``Boolean``
                    )

               Adding this ``modifier`` to the ``modifier``
               parameter of a component will allow it to intercept hardware key
               events before they are sent to the software keyboard.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``@`` ``ExperimentalComposeUiApi``
                  ``Modifier``.``onPreInterceptKeyBeforeSoftKeyboard`` (

                        ``onPreInterceptKeyBeforeSoftKeyboard:``( ``KeyEvent`` ) -> ``Boolean``
                    )

               Adding this ``modifier`` to the ``modifier``
               parameter of a component will allow it to intercept hardware key
               events before they are sent to the software keyboard.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``edgeSwipeToDismiss`` (
                        ``swipeToDismissBoxState:`` ``SwipeToDismissBoxState``,
                        ``edgeWidth:`` ``Dp``
                    )

               Limits swipe to dismiss to be active from the edge of the
               viewport only.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``edgeSwipeToDismiss`` (
                        ``swipeToDismissBoxState:`` ``SwipeToDismissBoxState``,
                        ``edgeWidth:`` ``Dp``
                    )

               **This function is deprecated.** SwipeToDismiss has been migrated
               to androidx.wear.compose.foundation.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``systemGestureExclusion`` ()

               Excludes the layout rectangle from the system gesture.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``systemGestureExclusion`` (``exclusion:``( ``LayoutCoordinates`` ) -> ``Rect`` )

               Excludes a rectangle within the local layout coordinates from the
               system gesture.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``consumeWindowInsets`` (``insets:`` ``WindowInsets`` )

               Consume insets that haven't been consumed yet by other insets
               Modifiers similar to ``windowInsetsPadding`` without adding any padding.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``consumeWindowInsets`` (``paddingValues:`` ``PaddingValues`` )

               Consume ``paddingValues``
               as insets as if the padding was added irrespective of insets.

         - 
            -  Scope: **Any**
            - 
               .. container::

                  ``Modifier``.``onConsumedWindowInsetsChanged`` (
                        ``block:(consumedWindowInsets:`` ``WindowInsets`` ) -> ``Unit``
                    )

               Calls ``block`` with the ``WindowInsets``
               that have been consumed, either by ``consumeWindowInsets``
               or one of the padding Modifiers, such as imePadding.

         - 
            -  Scope: ``TooltipBoxScope``
            - 
               .. container::

                  ``Modifier``.``tooltipTrigger`` ()

               ``Modifier``
               that should be applied to the anchor composable when showing the
               tooltip after long pressing the anchor composable is desired.

         - 
            -  Scope: ``ExposedDropdownMenuBoxScope``
            - 
               .. container::

                  ``Modifier``.``menuAnchor`` ()

               Modifier which should be applied to a
               ``TextField`` (or ``OutlinedTextField``)
               placed inside the scope.

Last updated 2024-03-25 UTC.

/Pager
======

.. https://developer.android.google.cn/develop/ui/compose/layouts/pager?hl=en

.. container:: devsite-article-body clearfix

   To flip through content in a left and right or up and down manner, you can
   use the
   `HorizontalPager  <#HorizontalPager>`__
   and
   `VerticalPager  <#VerticalPager>`__
   composables, respectively. These composables have similar functions to
   `ViewPager  <#ViewPager>`__ in
   the view system. By default, the ``HorizontalPager`` takes up the full width
   of the screen, ``VerticalPager`` takes up the full height, and the pagers
   only fling one page at a time. These defaults are all configurable.

   **Note:**\  Compose Pager is experimental. File any issues on the `issue tracker <https://issuetracker.google.com/issues/new?component=856989&template=1425922>`__.

   .. rubric:: ``HorizontalPager``
      :name: horizontalpager

   To create a pager that scrolls horizontally left and right, use
   ``HorizontalPager``:

   .. container:: float
      :name: image-1

   .. code:: prettyprint

      // Display 10 items
      val pagerState = rememberPagerState(pageCount = {
          10
      })
      HorizontalPager(state = pagerState) { page ->
          // Our page content
          Text(
              text = "Page: $page",
              modifier = Modifier.fillMaxWidth()
          )
      }PagerSnippets.kt

   .. rubric:: ``VerticalPager``
      :name: verticalpager

   To create a pager that scrolls up and down, use ``VerticalPager``:

   .. container:: float
      :name: image-2

   .. code:: prettyprint

      // Display 10 items
      val pagerState = rememberPagerState(pageCount = {
          10
      })
      VerticalPager(state = pagerState) { page ->
          // Our page content
          Text(
              text = "Page: $page",
              modifier = Modifier.fillMaxWidth()
          )
      }PagerSnippets.kt

   .. rubric:: Lazy creation
      :name: lazy-creation

   Pages in both ``HorizontalPager`` and ``VerticalPager`` are `lazily composed  <#lazy>`__ and laid-out when required. As
   the user scrolls through pages, the composable removes any pages which are no
   longer required.

   .. rubric:: Load more pages offscreen
      :name: load-more

   By default, the pager only loads the visible pages on-screen. To load more
   pages offscreen, set ``beyondBoundsPageCount`` to a value higher than zero.

   .. rubric:: Scroll to an item in the pager
      :name: scroll-to-item

   To scroll to a certain page in the pager, create a
   `PagerState  <#PagerState>`__
   object using
   `rememberPagerState()  <#rememberPagerState>`__
   and pass it as the ``state`` parameter to the pager. You can call
   `PagerState#scrollToPage()  <#scrollToPage>`__
   on this state, inside a ``CoroutineScope``:

   .. code:: prettyprint

      val pagerState = rememberPagerState(pageCount = {
          10
      })
      HorizontalPager(state = pagerState) { page ->
          // Our page content
          Text(
              text = "Page: $page",
              modifier = Modifier
                  .fillMaxWidth()
                  .height(100.dp)
          )
      }

      // scroll to page
      val coroutineScope = rememberCoroutineScope()
      Button(onClick = {
          coroutineScope.launch {
              // Call scroll to on pagerState
              pagerState.scrollToPage(5)
          }
      }, modifier = Modifier.align(Alignment.BottomCenter)) {
          Text("Jump to Page 5")
      }PagerSnippets.kt

   If you want to animate to the page, use the
   `PagerState#animateScrollToPage()  <#animateScrollToPage>`__
   function:

   .. code:: prettyprint

      val pagerState = rememberPagerState(pageCount = {
          10
      })

      HorizontalPager(state = pagerState) { page ->
          // Our page content
          Text(
              text = "Page: $page",
              modifier = Modifier
                  .fillMaxWidth()
                  .height(100.dp)
          )
      }

      // scroll to page
      val coroutineScope = rememberCoroutineScope()
      Button(onClick = {
          coroutineScope.launch {
              // Call scroll to on pagerState
              pagerState.animateScrollToPage(5)
          }
      }, modifier = Modifier.align(Alignment.BottomCenter)) {
          Text("Jump to Page 5")
      }PagerSnippets.kt

   .. rubric:: Get notified about page state changes
      :name: get-notified

   `PagerState  <#PagerState>`__
   has three properties with information about pages:
   `currentPage  <#currentPage>`__,
   `settledPage  <#settledPage>`__,
   and
   `targetPage  <#targetPage>`__.

   -  ``currentPage``: The closest page to the snap position. By default, the
      snap position is at the start of the layout.
   -  ``settledPage``: The page number when no animation or scrolling is
      running. This is different from the ``currentPage`` property in that the
      ``currentPage`` immediately updates if the page is close enough to the
      snap position, but ``settledPage`` remains the same until all the
      animations are finished running.
   -  ``targetPage``: The proposed stop position for a scrolling movement.

   You can use the ``snapshotFlow`` function to observe changes to these
   variables and react to them. For example, to send an analytics event on each
   page change, you can do the following:

   .. code:: prettyprint

      val pagerState = rememberPagerState(pageCount = {
          10
      })

      LaunchedEffect(pagerState) {
          // Collect from the a snapshotFlow reading the currentPage
          snapshotFlow { pagerState.currentPage }.collect { page ->
              // Do something with each page change, for example:
              // viewModel.sendPageSelectedEvent(page)
              Log.d("Page change", "Page changed to $page")
          }
      }

      VerticalPager(
          state = pagerState,
      ) { page ->
          Text(text = "Page: $page")
      }PagerSnippets.kt

   .. rubric:: Add a page indicator
      :name: add-page

   To add an indicator to a page, use the ``PagerState`` object to get
   information about which page is selected out of the number of pages, and draw
   your custom indicator.

   For example, if you want a simple circle indicator, you can repeat the number
   of circles and change the circle color based on if the page is selected,
   using ``pagerState.currentPage``:

   .. code:: prettyprint

      val pagerState = rememberPagerState(pageCount = {
          4
      })
      HorizontalPager(
          state = pagerState,
          modifier = Modifier.fillMaxSize()
      ) { page ->
          // Our page content
          Text(
              text = "Page: $page",
          )
      }
      Row(
          Modifier
              .wrapContentHeight()
              .fillMaxWidth()
              .align(Alignment.BottomCenter)
              .padding(bottom = 8.dp),
          horizontalArrangement = Arrangement.Center
      ) {
          repeat(pagerState.pageCount) { iteration ->
              val color = if (pagerState.currentPage == iteration) Color.DarkGray else Color.LightGray
              Box(
                  modifier = Modifier
                      .padding(2.dp)
                      .clip(CircleShape)
                      .background(color)
                      .size(16.dp)
              )
          }
      }PagerSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/pager/indicator.png
      name: image-12
      :alt: Pager showing a circle indicator below the content
      :width: 300px

      **Figure 3**. Pager showing a circle indicator below the content

   .. rubric:: Apply item scroll effects to content
      :name: scroll-effects

   A common use case is to use the scroll position to apply effects to your
   pager items. To find out how far a page is from the currently selected page,
   you can use
   `PagerState.currentPageOffsetFraction  <#currentPageOffsetFraction>`__.
   You can then apply transformation effects to your content based on the
   distance from the selected page.

   .. container:: float
      :name: image-3

   For example, to adjust the opacity of items based on how far they are from
   the center, change the ``alpha`` using
   `Modifier.graphicsLayer  <#graphicsLayer>`__
   on an item inside the pager:

   .. code:: prettyprint

      val pagerState = rememberPagerState(pageCount = {
          4
      })
      HorizontalPager(state = pagerState) { page ->
          Card(
              Modifier
                  .size(200.dp)
                  .graphicsLayer {
                      // Calculate the absolute offset for the current page from the
                      // scroll position. We use the absolute value which allows us to mirror
                      // any effects for both directions
                      val pageOffset = (
                          (pagerState.currentPage - page) + pagerState
                              .currentPageOffsetFraction
                          ).absoluteValue

                      // We animate the alpha, between 50% and 100%
                      alpha = lerp(
                          start = 0.5f,
                          stop = 1f,
                          fraction = 1f - pageOffset.coerceIn(0f, 1f)
                      )
                  }
          ) {
              // Card content
          }
      }PagerSnippets.kt

   .. rubric:: Custom page sizes
      :name: custom-page

   By default, ``HorizontalPager`` and ``VerticalPager`` takes up the full width
   or full height, respectively. You can set the ``pageSize`` variable to either
   have a
   `Fixed  <#PageSize.Fixed>`__,
   `Fill  <#PageSize.Fill>`__
   (default), or a custom size calculation.

   For example, to set a fixed width page of ``100.dp``:

   .. code:: prettyprint

      val pagerState = rememberPagerState(pageCount = {
          4
      })
      HorizontalPager(
          state = pagerState,
          pageSize = PageSize.Fixed(100.dp)
      ) { page ->
          // page content
      }PagerSnippets.kt

   To size the pages based on the viewport size, use a custom page size
   calculation. Create a custom
   `PageSize  <#PageSize>`__
   object and divide the ``availableSpace`` by three, taking into account the
   spacing between the items:

   .. code:: prettyprint

      private val threePagesPerViewport = object : PageSize {
          override fun Density.calculateMainAxisPageSize(
              availableSpace: Int,
              pageSpacing: Int
          ): Int {
              return (availableSpace - 2 * pageSpacing) / 3
          }
      }PagerSnippets.kt

   .. rubric:: Content padding
      :name: content-padding

   ``HorizontalPager`` and ``VerticalPager`` both support changing the content
   padding, which lets you influence the maximum size and alignment of pages.

   For example, setting the ``start`` padding aligns the pages towards the end:

   |Pager with start padding showing the content aligned towards the end|

   .. code:: prettyprint

      val pagerState = rememberPagerState(pageCount = {
          4
      })
      HorizontalPager(
          state = pagerState,
          contentPadding = PaddingValues(start = 64.dp),
      ) { page ->
          // page content
      }PagerSnippets.kt

   Setting both the ``start`` and ``end`` padding to the same value centers the
   item horizontally:

   |Pager with start and end padding showing the content centered|

   .. code:: prettyprint

      val pagerState = rememberPagerState(pageCount = {
          4
      })
      HorizontalPager(
          state = pagerState,
          contentPadding = PaddingValues(horizontal = 32.dp),
      ) { page ->
          // page content
      }PagerSnippets.kt

   Setting the ``end`` padding aligns the pages towards the start:

   |Pager with start and end padding showing the content aligned to the start|

   .. code:: prettyprint

      val pagerState = rememberPagerState(pageCount = {
          4
      })
      HorizontalPager(
          state = pagerState,
          contentPadding = PaddingValues(end = 64.dp),
      ) { page ->
          // page content
      }PagerSnippets.kt

   You can set the ``top`` and ``bottom`` values to achieve similar effects for
   ``VerticalPager``. The value ``32.dp`` is only used here as an example; you
   can set each of the padding dimensions to any value.

   .. rubric:: Customize scroll behavior
      :name: customize-scroll

   The default ``HorizontalPager`` and ``VerticalPager`` composables specify how
   scrolling gestures work with the pager. However, you can customize and change
   the defaults such as the ``pagerSnapDistance`` or the ``flingBehaviour``.

   .. rubric:: Snap distance
      :name: snap_distance

   By default, ``HorizontalPager`` and ``VerticalPager`` set the maximum number
   of pages that a fling gesture can scroll past to one page at a time. To
   change this, set
   `pagerSnapDistance  <#PagerSnapDistance>`__
   on the ``flingBehavior``:

   .. code:: prettyprint

      val pagerState = rememberPagerState(pageCount = { 10 })

      val fling = PagerDefaults.flingBehavior(
          state = pagerState,
          pagerSnapDistance = PagerSnapDistance.atMost(10)
      )

      Column(modifier = Modifier.fillMaxSize()) {
          HorizontalPager(
              state = pagerState,
              pageSize = PageSize.Fixed(200.dp),
              beyondBoundsPageCount = 10,
              flingBehavior = fling
          ) {
              PagerSampleItem(page = it)
          }
      }PagerSnippets.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `ConstraintLayout in Compose  <#constraintlayout>`__
   -  `Graphics Modifiers  <#modifiers>`__
   -  `Migrate ``CoordinatorLayout`` to
      Compose  <#coordinator-layout>`__

Last updated 2024-05-03 UTC.

.. |Pager with start padding showing the content aligned towards the end| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/pager/contentpadding-start.png
   :width: 250px
.. |Pager with start and end padding showing the content centered| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/pager/contentpadding-horizontal.png
   :width: 250px
.. |Pager with start and end padding showing the content aligned to the start| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/pager/contentpadding-end.png
   :width: 250px

/Flow layouts
=============

.. https://developer.android.google.cn/develop/ui/compose/layouts/flow?hl=en

.. container:: devsite-article-body clearfix

   **Beta:**\  ``FlowRow`` and ``FlowColumn`` are experimental. This document is
   for the beta version of the API. File any feedback on the `issue tracker <https://issuetracker.google.com/issues/new?component=856989&template=1425922>`__.
   `FlowRow  <#FlowRow>`__
   and
   `FlowColumn  <#FlowColumn>`__
   are composables that are similar to ``Row`` and ``Column``, but differ in
   that items flow into the next line when the container runs out of space. This
   creates multiple rows or columns. The number of items in a line can also be
   controlled by setting ``maxItemsInEachRow`` or ``maxItemsInEachColumn``. You
   can often use ``FlowRow`` and ``FlowColumn`` to build responsive layouts—
   content will not be cut off if items are too large for one dimension, and
   using a combination of ``maxItemsInEach*`` with ``Modifier.weight(weight)``
   can help build layouts that fill/expand the width of a row or column when
   needed.

   The typical example is for a chip or filtering UI:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_simple.png
      name: image-1
      :alt: 5 chips in a FlowRow, showing the overflow to the next line when
      there is no more space available.
      :width: 50.0%

      **Figure 1.** Example of ``FlowRow``

   .. rubric:: Basic usage
      :name: basic-usage

   To use ``FlowRow`` or ``FlowColumn``, create these composables and place the
   items inside it that should follow the standard flow:

   .. code:: prettyprint

      @Composable
      private fun FlowRowSimpleUsageExample() {
          FlowRow(modifier = Modifier.padding(8.dp)) {
              ChipItem("Price: High to Low")
              ChipItem("Avg rating: 4+")
              ChipItem("Free breakfast")
              ChipItem("Free cancellation")
              ChipItem("£50 pn")
          }
      }FlowLayoutSnippets.kt

   This snippet results in the UI shown above, with items automatically flowing
   to the next row when there is no more space in the first row.

   .. rubric:: Features of flow layout
      :name: features-flow

   Flow layouts have the following features and properties that you can use to
   create different layouts in your app.

   .. rubric:: Main axis arrangement: horizontal or vertical arrangement
      :name: main-axis

   The main axis is the axis on which items are laid out (for example, in
   ``FlowRow``, items are arranged horizontally). The ``horizontalArrangement``
   parameter in ``FlowRow`` controls the way free space is distributed between
   items.

   The following table shows examples of setting ``horizontalArrangement`` on
   items for ``FlowRow``:

   .. list-table::

      - 

         - Horizontal arrangement set on ``FlowRow``
         - Result
      - 

         - `Arrangement.Start  <#Start>`__
            (``Default``)
         - |Items arranged with start|
      - 

         - `Arrangement.SpaceBetween  <#SpaceBetween>`__
         - |Items arrangement with space in between|
      - 

         - `Arrangement.Center  <#Center>`__
         - |Items arranged in the center|
      - 

         - `Arrangement.End  <#End>`__
         - |Items arranged at the end|
      - 

         - `Arrangement.SpaceAround  <#SpaceAround>`__
         - |Items arranged with space around them|
      - 

         - `Arrangement.spacedBy(8.dp)  <#spacedBy>`__
         - |Items spaced by a certain dp|

   For ``FlowColumn``, similar options are available with
   ``verticalArrangement``, with the default of ``Arrangement.Top``.

   .. rubric:: Cross axis arrangement
      :name: cross-axis

   The cross axis is the axis in the opposite direction to the main axis. For
   example, in ``FlowRow``, this is the vertical axis. To change how the overall
   contents inside the container are arranged in the cross axis, use
   ``verticalArrangement`` for ``FlowRow``, and ``horizontalArrangement`` for
   ``FlowColumn``.

   For ``FlowRow``, the following table shows examples of setting different
   ``verticalArrangement`` on the items:

   .. list-table::

      - 

         - **Vertical arrangement set on ``FlowRow``**
         - **Result**
      - 

         - `Arrangement.Top  <#Top>`__
            (``Default``)
         - |Container top arrangement|
      - 

         - `Arrangement.Bottom  <#Bottom>`__
         - |Container bottom arrangement|
      - 

         - `Arrangement.Center  <#Center>`__
         - |Container center arrangement|

   For ``FlowColumn``, similar options are available with
   ``horizontalArrangement``. The default cross axis arrangement is
   ``Arrangement.Start``.

   .. rubric:: Individual item alignment
      :name: individual-item

   You may want to position individual items within the row with different
   alignments. This is different from ``verticalArrangement`` and
   ``horizontalArrangement`` as it aligns items *within the current line*. You
   can apply this with ``Modifier.align()``.

   For example, when items in a ``FlowRow`` are different heights, the row takes
   the height of the biggest item and applies
   ``Modifier.align(alignmentOption)`` to the items:

   .. list-table::

      - 

         - **Vertical alignment set on ``FlowRow``**
         - **Result**
      - 

         - `Alignment.Top  <#Top>`__
            (``Default``)
         - |Items aligned to the top|
      - 

         - `Alignment.Bottom  <#Bottom>`__
         - |Items aligned to the bottom|
      - 

         - `Alignment.CenterVertically  <#CenterVertically>`__
         - |Items aligned to the center|

   For ``FlowColumn``, similar options are available. The default alignment is
   ``Alignment.Start``.

   .. rubric:: Max items in row or column
      :name: max-items

   The parameters ``maxItemsInEachRow`` or ``maxItemsInEachColumn`` define the
   maximum items in the main axis to allow in one line before wrapping to the
   next. The default is ``Int.MAX_INT``, which allows as many items as possible,
   as long as their sizes allow them to fit into the line.

   For example, setting a ``maxItemsInEachRow`` forces the initial layout to
   only have 3 items:

   .. list-table::

      - 

         - No max set
         - ``maxItemsInEachRow = 3``
      - 

         - |No max set on flow row|
         - |Max items set on flow row|

   .. rubric:: Lazy loading flow items
      :name: lazy-flow

   `ContextualFlowRow  <#ContextualFlowRow>`__
   and
   `ContextualFlowColumn  <#ContextualFlowColumn>`__
   are a specialized version of ``FlowRow`` and ``FlowColumn`` that allow you to
   lazy load the contents of your flow row or column. They also provide
   information around the items position (index, row number and available size),
   such as if the item is in the first row. This is useful for large data-sets
   and if you need contextual information about an item.

   The ``maxLines`` parameter limits the number of rows displayed, and the
   ``overflow`` parameter specifies what should be displayed when an overflow of
   items is reached, allowing you to specify a custom ``expandIndicator`` or
   ``collapseIndicator``.

   **Note:**\  ``maxLines`` is available on ``FlowRow`` and ``FlowColumn``,
   however you can access layout information such as ``shownItemCount`` in all
   phases with ``ContextualFlowRow`` and ``ContextualFlowColumn`` as these use
   subcompose to determine layout information. You can only access
   ``shownItemCount`` in ``FlowRow`` when in the draw phase. Consider when and
   if you need this information or not to choose between the two.
   For example, to show a "+ (number of items remaining)" or "Show Less" button:

   .. code:: prettyprint

      val totalCount = 40
      var maxLines by remember {
          mutableStateOf(2)
      }

      val moreOrCollapseIndicator = @Composable { scope: ContextualFlowRowOverflowScope ->
          val remainingItems = totalCount - scope.shownItemCount
          ChipItem(if (remainingItems == 0) "Less" else "+$remainingItems", onClick = {
              if (remainingItems == 0) {
                  maxLines = 2
              } else {
                  maxLines += 5
              }
          })
      }
      ContextualFlowRow(
          modifier = Modifier
              .safeDrawingPadding()
              .fillMaxWidth(1f)
              .padding(16.dp)
              .wrapContentHeight(align = Alignment.Top)
              .verticalScroll(rememberScrollState()),
          verticalArrangement = Arrangement.spacedBy(4.dp),
          horizontalArrangement = Arrangement.spacedBy(8.dp),
          maxLines = maxLines,
          overflow = ContextualFlowRowOverflow.expandOrCollapseIndicator(
              minRowsToShowCollapse = 4,
              expandIndicator = moreOrCollapseIndicator,
              collapseIndicator = moreOrCollapseIndicator
          ),
          itemCount = totalCount
      ) { index ->
          ChipItem("Item $index")
      }FlowLayoutSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_layout_see_more.png
      name: image-2
      :alt: Example of contextual flow rows.
      :width: 50.0%

      **Figure 2.** Example of ``ContextualFlowRow``

   .. rubric:: Item weights
      :name: item-weights

   Weight grows an item based on its factor and the available space on the line
   it was placed in. Importantly, there is a difference between ``FlowRow`` and
   ``Row`` with how weights are used to calculate the width of an item. For
   ``Rows``, weight is based on *all items* in the ``Row``. With ``FlowRow``,
   weight is based on the *items in the line that an item is placed in*, not all
   the items in the ``FlowRow`` container.

   For example, if you have 4 items that all fall on a line, each with different
   weights of ``1f, 2f, 1f``, and ``3f``, the total weight is ``7f``. The
   remaining space in a row or column will be divided by ``7f``. Then, each item
   width will be calculated using: ``weight * (remainingSpace / totalWeight)``.

   You can use a combination of ``Modifier.weight`` and max items with
   ``FlowRow`` or ``FlowColumn`` to create a grid-like layout. This approach is
   useful for creating responsive layouts that adjust to the sizing of your
   device.

   There are a few different examples of what you can achieve using weights. One
   example is a grid where items are equally sized, as shown below:
   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_layout_grid_blue.png
      name: image-2
      :alt: Grid created with flow row
      :width: 50.0%

      **Figure 3.** Using ``FlowRow`` to create a grid

   To create a grid of equal item sizes, you can do the following:

   .. code:: prettyprint

      val rows = 3
      val columns = 3
      FlowRow(
          modifier = Modifier.padding(4.dp),
          horizontalArrangement = Arrangement.spacedBy(4.dp),
          maxItemsInEachRow = rows
      ) {
          val itemModifier = Modifier
              .padding(4.dp)
              .height(80.dp)
              .weight(1f)
              .clip(RoundedCornerShape(8.dp))
              .background(MaterialColors.Blue200)
          repeat(rows * columns) {
              Spacer(modifier = itemModifier)
          }
      }FlowLayoutSnippets.kt

   Importantly, if you add another item and repeat it 10 times instead of 9, the
   last item takes up the entire last column, as the total weight for the whole
   row is ``1f``:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_layout_grid_last_item_large.png
      name: image-3
      :alt: Last item full size on grid
      :width: 50.0%

      **Figure 4.** Using ``FlowRow`` to create a grid with the last item taking
      up full width

   You can combine weights with other ``Modifiers`` such as
   ``Modifier.width(exactDpAmount), Modifier.aspectRatio(aspectRatio)``, or
   ``Modifier.fillMaxWidth(fraction)``. These modifiers all work in conjunction
   to allow for responsive sizing of items within a ``FlowRow`` (or
   ``FlowColumn``).

   You can also create an alternating grid of different item sizes, where two
   items take up half the width each, and one item takes up the full width of
   the next column:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_alternating_grid.png
      name: image-4
      :alt: Alternating grid with flow row
      :width: 50.0%

      **Figure 5.** ``FlowRow`` with alternating sizes of rows

   You can achieve this with the following code:

   .. code:: prettyprint

      FlowRow(
          modifier = Modifier.padding(4.dp),
          horizontalArrangement = Arrangement.spacedBy(4.dp),
          maxItemsInEachRow = 2
      ) {
          val itemModifier = Modifier
              .padding(4.dp)
              .height(80.dp)
              .clip(RoundedCornerShape(8.dp))
              .background(Color.Blue)
          repeat(6) { item ->
              // if the item is the third item, don't use weight modifier, but rather fillMaxWidth
              if ((item + 1) % 3 == 0) {
                  Spacer(modifier = itemModifier.fillMaxWidth())
              } else {
                  Spacer(modifier = itemModifier.weight(0.5f))
              }
          }
      }FlowLayoutSnippets.kt

   .. rubric:: Fractional sizing
      :name: fractional-sizing

   Using ``Modifier.fillMaxWidth(fraction)``, you can specify the size of the
   container that an item should take up. This is different from how
   ``Modifier.fillMaxWidth(fraction)`` works when applied to ``Row`` or
   ``Column``, in that ``Row/Column`` items take up a percentage of the
   remaining width, rather than the whole container's width.

   For example, the following code produces different results when using
   ``FlowRow`` vs ``Row``:

   .. code:: prettyprint

      FlowRow(
          modifier = Modifier.padding(4.dp),
          horizontalArrangement = Arrangement.spacedBy(4.dp),
          maxItemsInEachRow = 3
      ) {
          val itemModifier = Modifier
              .clip(RoundedCornerShape(8.dp))
          Box(modifier = itemModifier.height(200.dp).width(60.dp).background(Color.Red))
          Box(modifier = itemModifier.height(200.dp).fillMaxWidth(0.7f).background(Color.Blue))
          Box(modifier = itemModifier.height(200.dp).weight(1f).background(Color.Magenta))
      }FlowLayoutSnippets.kt

   .. list-table::

      - 

         - **``FlowRow``**: Middle item with 0.7 fraction of whole container
            width.
         - |Fractional width with flow row|
      - 

         - **``Row``**: Middle item taking up 0.7 percent of remaining ``Row``
            width.
         - |Fractional width with row|

   .. rubric:: ``fillMaxColumnWidth()`` and ``fillMaxRowHeight()``
      :name: fillmaxheight

   Applying either
   `Modifier.fillMaxColumnWidth()  <#fillMaxColumnWidth>`__
   or
   `Modifier.fillMaxRowHeight()  <#fillMaxRowHeight>`__
   to an item inside a ``FlowColumn`` or ``FlowRow`` ensures that items in the
   same column or row take up the same width or height as the biggest item in
   the column/row.

   For example, this example uses ``FlowColumn`` to display the list of Android
   desserts. You can see the difference in each items widths when
   ``Modifier.fillMaxColumnWidth()`` is applied to the items versus when its not
   and the items wrap.

   .. code:: prettyprint

      FlowColumn(
          Modifier
              .padding(20.dp)
              .fillMaxHeight()
              .fillMaxWidth(),
          horizontalArrangement = Arrangement.spacedBy(8.dp),
          verticalArrangement = Arrangement.spacedBy(8.dp),
          maxItemsInEachColumn = 5,
      ) {
          repeat(listDesserts.size) {
              Box(
                  Modifier
                      .fillMaxColumnWidth()
                      .border(1.dp, Color.DarkGray, RoundedCornerShape(8.dp))
                      .padding(8.dp)
              ) {

                  Text(
                      text = listDesserts[it],
                      fontSize = 18.sp,
                      modifier = Modifier.padding(3.dp)
                  )
              }
          }
      }FlowLayoutSnippets.kt

   .. list-table::

      - 

         - **``Modifier.fillMaxColumnWidth()``** applied to each item
         - |fillMaxColumnWidth|
      - 

         - No width changes set (wrapping items)
         - |No fill max column width set|

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Compose layout basics  <#basics>`__
   -  `ConstraintLayout in Compose  <#constraintlayout>`__
   -  `Editor actions {:#editor-actions}  <#editor-actions>`__

Last updated 2024-05-03 UTC.

.. |Items arranged with start| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_arrangement_start_default.png
.. |Items arrangement with space in between| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_arrangement_space_between.png
.. |Items arranged in the center| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_arrangement_space_center.png
.. |Items arranged at the end| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_arrangement_end.png
.. |Items arranged with space around them| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_arrangement_space_around.png
.. |Items spaced by a certain dp| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_arrangement_spaced_by.png
.. |Container top arrangement| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_container_arrangement_top.png
.. |Container bottom arrangement| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_container_arrangement_bottom.png
.. |Container center arrangement| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_container_arrangement_center.png
.. |Items aligned to the top| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_item_alignment_top.png
.. |Items aligned to the bottom| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_item_alignment_bottom.png
.. |Items aligned to the center| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_item_alignment_center.png
.. |No max set on flow row| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_no_max.png
.. |Max items set on flow row| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_max_items.png
.. |Fractional width with flow row| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_fractional_width_flow.png
.. |Fractional width with row| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_row_fractional_width_row.png
.. |fillMaxColumnWidth| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_max_column_width.png
.. |No fill max column width set| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/flow/flow_no_fill_max_width.png

/Custom layouts
===============

.. https://developer.android.google.cn/develop/ui/compose/layouts/custom?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   In Compose, UI elements are represented by the composable functions that emit
   a piece of UI when invoked, that is then added to a UI tree that gets
   rendered on the screen. Each UI element has one parent and potentially many
   children. Each element is also located within its parent, specified as an (x,
   y) position, and a size, specified as a ``width`` and a ``height``.

   Parents define the constraints for their child elements. An element is asked
   to define its size within those constraints. Constraints restrict the minimum
   and maximum ``width`` and ``height`` of an element. If an element has child
   elements, it may measure each child to help determine its size. Once an
   element determines and reports its own size, it has an opportunity to define
   how to place its child elements relative to itself, as described in detail in
   `Creating custom layouts <#create-custom>`__.

   Laying out each node in the UI tree is a three step process. Each node must:

   #. Measure any children
   #. Decide its own size
   #. Place its children

   |Three steps of node layout: measure children, decide size, place children|

   **Note:**\  Compose UI does not permit multi-pass measurement. This means
   that a layout element may not measure any of its children more than once in
   order to try different measurement configurations.
   The use of scopes defines *when* you can measure and place your children.
   Measuring a layout can only be done during the measurement and layout passes,
   and a child can only be placed during the layout passes (and only after it
   has been measured). Due to Compose scopes such as
   `MeasureScope  <#MeasureScope>`__,
   and
   `PlacementScope  <#Placeable.PlacementScope>`__,
   this is enforced at compile time.

   .. rubric:: Use the layout modifier
      :name: layout-modifier

   .. container:: video-wrapper

   You can use the ``layout`` modifier to modify how an element is measured and
   laid out. ``Layout`` is a lambda; its parameters include the element you can
   measure, passed as ``measurable``, and that composable's incoming
   constraints, passed as ``constraints``. A custom layout modifier can look
   like this:

   .. code:: prettyprint

      fun Modifier.customLayoutModifier() =
          layout { measurable, constraints ->
              // ...
          }CustomLayoutSnippets.kt

   Let's display a ``Text`` on the screen and control the distance from the top
   to the baseline of the first line of text. This is exactly what the
   ``paddingFromBaseline`` modifier does, we’re implementing it here as an
   example. To do that, use the ``layout`` modifier to manually place the
   composable on the screen. Here's the desired behavior where the ``Text`` top
   padding is set ``24.dp``:

   |Shows the difference between normal UI padding, which sets the space between
   elements, and text padding that sets the space from one baseline to the next|

   Here's the code to produce that spacing:

   .. code:: prettyprint

      fun Modifier.firstBaselineToTop(
          firstBaselineToTop: Dp
      ) = layout { measurable, constraints ->
          // Measure the composable
          val placeable = measurable.measure(constraints)

          // Check the composable has a first baseline
          check(placeable[FirstBaseline] != AlignmentLine.Unspecified)
          val firstBaseline = placeable[FirstBaseline]

          // Height of the composable with padding - first baseline
          val placeableY = firstBaselineToTop.roundToPx() - firstBaseline
          val height = placeable.height + placeableY
          layout(placeable.width, height) {
              // Where the composable gets placed
              placeable.placeRelative(0, placeableY)
          }
      }CustomLayoutSnippets.kt

   Here's what's going on in that code:

   #. In the ``measurable`` lambda parameter, you measure the ``Text``
      represented by the measurable parameter by calling
      ``measurable.measure(constraints)``.
   #. You specify the size of the composable by calling the
      ``layout(width, height)`` method, which also gives a lambda used for
      placing the wrapped elements. In this case, it's the height between the
      last baseline and added top padding.
   #. You position the wrapped elements on the screen by calling
      ``placeable.place(x, y)``. If the wrapped elements aren't placed, they
      won't be visible. The ``y``\ position corresponds to the top padding - the
      position of the first baseline of the text.

   To verify this works as expected, use this modifier on a ``Text``:

   .. code:: prettyprint

      @Preview
      @Composable
      fun TextWithPaddingToBaselinePreview() {
          MyApplicationTheme {
              Text("Hi there!", Modifier.firstBaselineToTop(32.dp))
          }
      }

      @Preview
      @Composable
      fun TextWithNormalPaddingPreview() {
          MyApplicationTheme {
              Text("Hi there!", Modifier.padding(top = 32.dp))
          }
      }CustomLayoutSnippets.kt

   |Multiple previews of text elements; one shows ordinary padding between
   elements, the other shows padding from one baseline to the next|

   .. rubric:: Create custom layouts
      :name: create-custom

   The ``layout`` modifier only changes the calling composable. To measure and
   layout multiple composables, use the
   `Layout  <#Layout>`__
   composable instead. This composable allows you to measure and lay out
   children manually. All higher-level layouts like ``Column`` and ``Row`` are
   built with the ``Layout`` composable.

   **Note:**\  In the View system, creating a custom layout required extending
   ``ViewGroup`` and implementing measure and layout functions. In Compose you
   simply write a function using the ``Layout`` composable.
   Let's build a very basic version of ``Column``. Most custom layouts follow
   this pattern:

   .. code:: prettyprint

      @Composable
      fun MyBasicColumn(
          modifier: Modifier = Modifier,
          content: @Composable () -> Unit
      ) {
          Layout(
              modifier = modifier,
              content = content
          ) { measurables, constraints ->
              // measure and position children given constraints logic here
              // ...
          }
      }CustomLayoutSnippets.kt

   Similarly to the ``layout`` modifier, ``measurables`` is the list of children
   that need to be measured and ``constraints`` are the constraints from the
   parent. Following the same logic as before, ``MyBasicColumn`` can be
   implemented like this:

   .. code:: prettyprint

      @Composable
      fun MyBasicColumn(
          modifier: Modifier = Modifier,
          content: @Composable () -> Unit
      ) {
          Layout(
              modifier = modifier,
              content = content
          ) { measurables, constraints ->
              // Don't constrain child views further, measure them with given constraints
              // List of measured children
              val placeables = measurables.map { measurable ->
                  // Measure each children
                  measurable.measure(constraints)
              }

              // Set the size of the layout as big as it can
              layout(constraints.maxWidth, constraints.maxHeight) {
                  // Track the y co-ord we have placed children up to
                  var yPosition = 0

                  // Place children in the parent layout
                  placeables.forEach { placeable ->
                      // Position item on the screen
                      placeable.placeRelative(x = 0, y = yPosition)

                      // Record the y co-ord placed up to
                      yPosition += placeable.height
                  }
              }
          }
      }CustomLayoutSnippets.kt

   The child composables are constrained by the ``Layout`` constraints (without
   the ``minHeight`` constraints), and they're placed based on the ``yPosition``
   of the previous composable.

   Here's how that custom composable would be used:

   .. code:: prettyprint

      @Composable
      fun CallingComposable(modifier: Modifier = Modifier) {
          MyBasicColumn(modifier.padding(8.dp)) {
              Text("MyBasicColumn")
              Text("places items")
              Text("vertically.")
              Text("We've done it by hand!")
          }
      }CustomLayoutSnippets.kt

   |Several text elements stacked one above the next in a column.|

   .. rubric:: Layout direction
      :name: layout-direction

   Change the layout direction of a composable by changing the
   `LocalLayoutDirection  <#LocalLayoutDirection>`__
   composition local.

   If you're placing composables manually on the screen, the ``LayoutDirection``
   is part of the ``LayoutScope`` of the ``layout`` modifier or ``Layout``
   composable.

   When using ``layoutDirection``, place composables using
   `place  <#place>`__.
   Unlike the
   `placeRelative  <#placeRelative>`__
   method, ``place`` doesn't change based on the layout direction (left-to-right
   versus right-to-left).

   .. rubric:: Custom layouts in action
      :name: layouts-in-action

   Learn more about layouts and modifiers in the `Basic layouts in Compose  <#jetpack-compose-layouts>`__, and see custom layouts in
   action in the `Compose samples that create custom layouts <https://github.com/android/compose-samples/search?q=androidx.compose.ui.layout.Layout>`__.

   .. rubric:: Learn more
      :name: additional-resources

   To learn more about custom layouts in Compose, consult the following
   additional resources.

   .. rubric:: Videos
      :name: videos

   -  `A deep dive into Jetpack Compose Layouts <https://www.youtube.com/watch?v=zMKMwh9gZuI>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Intrinsic measurements in Compose layouts  <#intrinsic-measurements>`__
   -  `Graphics in Compose  <#overview>`__
   -  `Compose modifiers  <#modifiers>`__

Last updated 2024-05-03 UTC.

.. |Three steps of node layout: measure children, decide size, place children| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-three-step-process.svg
.. |Shows the difference between normal UI padding, which sets the space between elements, and text padding that sets the space from one baseline to the next| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-padding-baseline.png
   :width: 400px
.. |Multiple previews of text elements; one shows ordinary padding between elements, the other shows padding from one baseline to the next| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-previews-showing-text-baseline-padding.png
.. |Several text elements stacked one above the next in a column.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-complex-by-hand.png
   :width: 250px

/Build adaptive layouts
=======================

.. https://developer.android.google.cn/develop/ui/compose/layouts/adaptive?hl=en

.. container:: devsite-article-body clearfix

   The UI for your app should be responsive to account for different screen
   sizes, orientations and form factors. An adaptive layout changes based on the
   screen space available to it. These changes range from simple layout
   adjustments to fill up space, to changing layouts completely to make use of
   additional room.

   As a declarative UI toolkit, Jetpack Compose is well suited for designing and
   implementing layouts that adjust themselves to render content differently
   across a variety of sizes. This document contains some guidelines for how you
   can use Compose to make your UI responsive.

   .. rubric:: Make large layout changes for screen-level composables explicit
      :name: explicit-layout-changes

   When using Compose to lay out an entire application, app-level and
   screen-level composables occupy all of the space your app is given to render.
   At this level in your design, it might make sense to change the overall
   layout of a screen to take advantage of larger screens.

   **Key terms:**

   -  **App-level composable:** The single, root composable that occupies all
      space given to your app, and contain all other composables.
   -  **Screen-level composable:** A composable contained within the app-level
      composable thats occupies all space given to your app. Each screen-level
      composable generally represents a particular destination when navigating
      around the app.
   -  **Individual composables:** All other composables. These could be
      individual elements, reusable groups of content, or composables hosted
      within screen-level composables.

   **Avoid using physical, hardware values for making layout decisions.** It
   might be tempting to make decisions based on a fixed tangible value (Is the
   device a tablet? Does the physical screen have a certain aspect ratio?), but
   the answers to these questions may not be useful for determining the space
   your UI can work with.

   |A diagram showing several different device form factors -- a phone, a
   foldable, a tablet, and a laptop|

   On tablets, an app might be running in multi-window mode, which means the app
   may be splitting the screen with another app. On ChromeOS, an app might be in
   a resizable window. There might even be more than one physical screen, such
   as with a foldable device. In all of these cases, the physical screen size
   isn’t relevant for deciding how to display content.

   Instead, you should make decisions based on the actual portion of the screen
   that is allocated to your app, such as the current window metrics provided by
   the Jetpack `WindowManager  <#window>`__ library. To
   see how to use WindowManager in a Compose app, check out the
   `JetNews <https://github.com/android/compose-samples/tree/main/JetNews>`__
   sample.

   Following this approach makes your app more flexible, as it will behave well
   in all of the scenarios above. Making your layouts adaptive to the screen
   space available to them also reduces the amount of special handling to
   support platforms like ChromeOS, and form factors like tablets and foldables.

   Once you are observing the relevant space available for your app, it is
   helpful to convert the raw size into a meaningful size class, as described in
   `Window Size Classes  <#window_size_classes>`__.
   This groups sizes into standard size buckets, which are breakpoints that are
   designed to balance simplicity with the flexibility to optimize your app for
   most unique cases. These size classes refer to the overall window of your
   app, so use these classes for layout decisions that affect your overall
   screen layout. You can pass these size classes down as state, or you can
   perform additional logic to create derived state to pass down to nested
   composables.

   .. code:: prettyprint

      @OptIn(ExperimentalMaterial3AdaptiveApi::class)
      @Composable
      fun MyApp(
          windowSizeClass: WindowSizeClass = currentWindowAdaptiveInfo().windowSizeClass
      ) {
          // Perform logic on the size class to decide whether to show the top app bar.
          val showTopAppBar = windowSizeClass.windowHeightSizeClass != WindowHeightSizeClass.COMPACT

          // MyScreen knows nothing about window sizes, and performs logic based on a Boolean flag.
          MyScreen(
              showTopAppBar = showTopAppBar,
              /* ... */
          )
      }AdaptiveLayoutSnippets.kt

   This layered approach confines screen size logic to a single location,
   instead of scattering it across your app in many places that need to be kept
   in sync. This single location produces state, which can be explicitly passed
   down to other composables just like you would for any other app state.
   Explicitly passing state simplifies individual composables, since they will
   just be normal composable functions that take the size class or specified
   configuration along with other data.

   .. rubric:: Flexible nested composables are reusable
      :name: flexible-nested-reusable

   Composables are more reusable when they can be placed in a wide variety of
   places. If a composable assumes that it will always be placed in a certain
   location with a specific size, then it will be harder to reuse it elsewhere
   in a different location, or with a different amount of space available. This
   also means that **individual, reusable composables should avoid implicitly
   depending on “global” size information**.

   Let’s look at an example: Imagine a nested composable that implements a
   `list-detail layout <https://m3.material.io/foundations/adaptive-design/foldables/compositions>`__,
   which may show one pane or two panes side-by-side.

   |Screenshot of an app showing two panes side-by-side|

   **Figure 1.** Screenshot of an app showing a typical list/detail layout.
   **1** is the list area, and **2** is the detail area.

   We want this decision to be part of the overall layout for the app, so we
   pass down the decision from a screen-level composable as we saw above:

   .. code:: prettyprint

      @Composable
      fun AdaptivePane(
          showOnePane: Boolean,
          /* ... */
      ) {
          if (showOnePane) {
              OnePane(/* ... */)
          } else {
              TwoPane(/* ... */)
          }
      }AdaptiveLayoutSnippets.kt

   What if we instead want a composable to independently change its layout based
   on the space available? For instance, a card that wants to show additional
   details if space allows. We want to perform some logic based on some
   available size, but which size specifically?

   |Examples of two different cards: a narrow card showing just an icon and
   title, and a wider card showing the icon, title, and short description|

   As we saw above, we should avoid trying to use the size of the device’s
   actual screen. This won’t be accurate for multiple screens, and also won’t be
   accurate if the app isn’t fullscreen.

   Because the composable is not a screen-level composable, we also should not
   use the current window metrics directly, in order to maximize reusability. If
   the component is being placed with padding (such as for insets), or if there
   are components like navigation rails or app bars, the amount of space
   available to the composable may differ significantly from the overall space
   available to the app.

   Therefore, we should use the width that the composable is actually given to
   render itself. We have two options to get that width:

   If you want to change **where** or **how** content is displayed, you can use
   a collection of modifiers or a `custom layout  <#custom>`__ to make the layout responsive.
   This could be as simple as having some child fill all of the available space,
   or laying out children with multiple columns if there is enough room.

   If you want to change **what** you show, you can use ``BoxWithConstraints``
   as a more powerful alternative. This composable provides `measurement constraints  <#BoxWithConstraintsScope>`__
   that you can use to call different composables based on the space that is
   available. However, this comes at some expense, as ``BoxWithConstraints``
   defers composition until the Layout phase, when these constraints are known,
   causing more work to be performed during layout.

   .. code:: prettyprint

      @Composable
      fun Card(/* ... */) {
          BoxWithConstraints {
              if (maxWidth < 400.dp) {
                  Column {
                      Image(/* ... */)
                      Title(/* ... */)
                  }
              } else {
                  Row {
                      Column {
                          Title(/* ... */)
                          Description(/* ... */)
                      }
                      Image(/* ... */)
                  }
              }
          }
      }AdaptiveLayoutSnippets.kt

   .. rubric:: Ensure all data is available for different sizes
      :name: data-avail-multiple-sizes

   When taking advantage of additional screen space, on a large screen you might
   have room to show more content to the user than on a small screen. When
   implementing a composable with this behavior, it might be tempting to be
   efficient, and load data as a side effect of the current size.

   However, this goes against the principles of unidirectional data flow, where
   data can be hoisted and simply provided to composables to render
   appropriately. Enough data should be provided to the composable so that the
   composable always has what it needs to display across any size, even if some
   portion of the data might not always be used.

   .. code:: prettyprint

      @Composable
      fun Card(
          imageUrl: String,
          title: String,
          description: String
      ) {
          BoxWithConstraints {
              if (maxWidth < 400.dp) {
                  Column {
                      Image(imageUrl)
                      Title(title)
                  }
              } else {
                  Row {
                      Column {
                          Title(title)
                          Description(description)
                      }
                      Image(imageUrl)
                  }
              }
          }
      }AdaptiveLayoutSnippets.kt

   Building on the ``Card`` example, note that we always pass the
   ``description`` to the ``Card``. Even though the ``description`` is only used
   when the width permits displaying it, ``Card`` always requires it, regardless
   of the available width.

   Always passing data makes adaptive layouts simpler by making them less
   stateful, and avoids triggering side-effects when switching between sizes
   (which may occur due to a window resize, orientation change, or folding and
   unfolding a device).

   This principle also allows preserving state across layout changes. By
   hoisting information that may not be used at all sizes, we can preserve the
   user’s state as the layout size changes. For example, we can hoist a
   ``showMore`` Boolean flag so that the user’s state is preserved when resizes
   cause the layout to switch between hiding and showing the description:

   .. code:: prettyprint

      @Composable
      fun Card(
          imageUrl: String,
          title: String,
          description: String
      ) {
          var showMore by remember { mutableStateOf(false) }

          BoxWithConstraints {
              if (maxWidth < 400.dp) {
                  Column {
                      Image(imageUrl)
                      Title(title)
                  }
              } else {
                  Row {
                      Column {
                          Title(title)
                          Description(
                              description = description,
                              showMore = showMore,
                              onShowMoreToggled = { newValue ->
                                  showMore = newValue
                              }
                          )
                      }
                      Image(imageUrl)
                  }
              }
          }
      }AdaptiveLayoutSnippets.kt

   .. rubric:: Learn more
      :name: additional-resources

   To learn more about custom layouts in Compose, consult the following
   additional resources.

   .. rubric:: Sample apps
      :name: sample_apps

   -  `Large screen canonical layouts <https://github.com/android/user-interface-samples/tree/main/CanonicalLayouts>`__
      is a repository of proven design patterns that provide an optimal user
      experience on large screen devices
   -  `JetNews <https://github.com/android/compose-samples/tree/main/JetNews>`__
      shows how to design an app that adapts its UI to make use of available
      space
   -  `Reply <https://github.com/android/compose-samples/tree/main/Reply>`__ is
      an adaptive sample for supporting mobile, tablets and foldables
   -  `Now in Android <https://github.com/android/nowinandroid>`__ is an app
      that uses adaptive layouts to support different screen sizes

   .. rubric:: Videos
      :name: videos

   -  `Build Android UIs for any screen size <https://www.youtube.com/watch/ir3LztqbeRI>`__
   -  `Form Factors \| Android Dev Summit '22 <https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9jBnpl83LH6oZc7nFIVSRq>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Mapping components to existing code  <#mapping-components-to-existing-code>`__
   -  `Compose layout basics  <#basics>`__
   -  `Jetpack Compose Phases  <#phases>`__

Last updated 2024-05-03 UTC.

.. |A diagram showing several different device form factors -- a phone, a foldable, a tablet, and a laptop| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/adaptive-many-screens.png
.. |Screenshot of an app showing two panes side-by-side| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/adaptive-list-detail.png
.. |Examples of two different cards: a narrow card showing just an icon and title, and a wider card showing the icon, title, and short description| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/adaptive-card-title-desc.png

/Build a list-detail layout
===========================

.. https://developer.android.google.cn/develop/ui/compose/layouts/list-detail?hl=en

.. container:: devsite-article-body clearfix

   List-detail is a UI pattern that consists of a dual-pane layout where one
   pane presents a list of items and another pane displays the details of items
   selected from the list.

   The pattern is particularly useful for applications that provide in-depth
   information about elements of large collections, for example, an email client
   that has a list of emails and the detailed content of each email message.
   List-detail can also be used for less critical paths such as dividing app
   preferences into a list of categories with the preferences for each category
   in the detail pane.

   .. rubric:: Implement UI pattern with ``ListDetailPaneScaffold``
      :name: implement_ui_pattern_with_listdetailpanescaffold

   ``ListDetailPaneScaffold`` is a composable that simplifies the implementation
   of the list-detail pattern in your app. A list-detail scaffold can consist of
   up to three panes: a list pane, a detail pane, and an optional extra pane.
   The scaffold handles screen space calculations. When sufficient screen size
   is available, the detail pane is displayed alongside the list pane. On small
   screen sizes, the scaffold automatically switches to displaying either the
   list or detail pane full screen.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/list-detail-2.png
      name: image-1
      :alt: A detail pane shown alongside the list page.
      :figclass: invert

      **Figure 1.** When enough screen size is available, the detail pane is
      shown alongside the list pane.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/list-detail-1.png
      name: image-2
      :alt: After an item is selected, the detail pane takes over the whole
      screen.
      :figclass: invert

      **Figure 2.** When screen size is limited, the detail pane (since an item
      has been selected) takes over the whole space.

   .. rubric:: Declare dependencies
      :name: declare-dependencies

   **Note:**\  The ``material3-adaptive`` library is in alpha and is subject to
   change. The library does not yet support integration with the navigation
   library; however, integration is under development.
   ``ListDetailPaneScaffold`` is part of the `Material 3 adaptive layout library  <#package-summary>`__.

   Your app must include dependencies for three related Material 3 libraries:

   -  **adaptive** — Low-level building blocks such as
      `HingeInfo  <#HingeInfo>`__
      and
      `Posture  <#Posture>`__
   -  **adaptive-layout** — Adaptive layouts such as ``ListDetailPaneScaffold``
      and
      `SupportingPaneScaffold  <#SupportingPaneScaffold>`__
   -  **adaptive-navigation** — Composables for navigating within and between
      panes

   Add the dependencies to the ``build.gradle`` file of your app or module:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint


               implementation("androidx.compose.material3.adaptive:adaptive:1.0.0-alpha12")
               implementation("androidx.compose.material3.adaptive:adaptive-layout:1.0.0-alpha12")
               implementation("androidx.compose.material3.adaptive:adaptive-navigation:1.0.0-alpha12")

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint


               implementation 'androidx.compose.material3.adaptive:adaptive:1.0.0-alpha12'
               implementation 'androidx.compose.material3.adaptive:adaptive-layout:1.0.0-alpha12'
               implementation 'androidx.compose.material3.adaptive:adaptive-navigation:1.0.0-alpha12'

   .. rubric:: Basic usage
      :name: basic-usage

   Implement ``ListDetailPaneScaffold`` as follows:

   #. **Use a class that represents the content to be selected.** This class
      should be `Parcelable  <#Parcelable>`__ to support
      saving and restoring the selected list item. Use the `kotlin-parcelize plugin  <#parcelize>`__ to generate the code for you.

      .. code:: prettyprint

         @Parcelize
         class MyItem(val id: Int) : ParcelableSampleListDetailPaneScaffold.kt

   #. **Create a ``ThreePaneScaffoldNavigator`` with
      ``rememberListDetailPaneScaffoldNavigator`` and add a ``BackHandler``.**
      This navigator is used to move between the list, detail, and extra panes.
      By declaring a generic type, the navigator also tracks the state of the
      scaffold (that is, which ``MyItem`` is being displayed). Since this type
      is parcelable, the state can be saved and restored by the navigator to
      automatically handle configuration changes. The
      `BackHandler  <#BackHandler>`__
      provides support for navigating back using the system back gesture or
      button. The expected behavior of the back button for a
      ``ListDetailPaneScaffold`` depends on the window size and current scaffold
      value. If the ``ListDetailPaneScaffold`` can support going back with the
      current state, then ``canNavigateBack()`` is ``true``, enabling the
      ``BackHandler``.

      .. code:: prettyprint

         val navigator = rememberListDetailPaneScaffoldNavigator<MyItem>()

         BackHandler(navigator.canNavigateBack()) {
             navigator.navigateBack()
         }SampleListDetailPaneScaffold.kt

   #. **Pass the ``scaffoldState`` from the ``navigator`` to the
      ``ListDetailPaneScaffold`` composable.**

      .. code:: prettyprint

         ListDetailPaneScaffold(
             directive = navigator.scaffoldDirective,
             value = navigator.scaffoldValue,
             // ...
         )SampleListDetailPaneScaffold.kt

   #. **Supply your list pane implementation to the
      ``ListDetailPaneScaffold``.** Use
      `AnimatedPane  <#AnimatedPane>`__
      to apply the default pane animations during navigation. Then use
      ``ThreePaneScaffoldNavigator`` to navigate to the detail pane,
      ``ListDetailPaneScaffoldRole.Detail``, and display the passed item.

      .. code:: prettyprint

         ListDetailPaneScaffold(
             directive = navigator.scaffoldDirective,
             value = navigator.scaffoldValue,
             listPane = {
                 AnimatedPane {
                     MyList(
                         onItemClick = { item ->
                             // Navigate to the detail pane with the passed item
                             navigator.navigateTo(ListDetailPaneScaffoldRole.Detail, item)
                         }
                     )
                 }
             },
             // ...
         )SampleListDetailPaneScaffold.kt

   #. **Include your detail pane implementation in ``ListDetailPaneScaffold``.**
      When navigation has completed, ``currentDestination`` contains the pane
      your app has navigated to, including the content displayed in the pane.
      The ``content`` property is the same type specified in the original
      remember call (``MyItem`` in this example), so you can also access the
      property for any data that you need to display.

      .. code:: prettyprint

         ListDetailPaneScaffold(
             directive = navigator.scaffoldDirective,
             value = navigator.scaffoldValue,
             listPane =
             // ...
             detailPane = {
                 AnimatedPane {
                     navigator.currentDestination?.content?.let {
                         MyDetails(it)
                     }
                 }
             },
         )SampleListDetailPaneScaffold.kt

   After you implement the above steps, your code should look similar to this:

   .. code:: prettyprint

      val navigator = rememberListDetailPaneScaffoldNavigator<MyItem>()

      BackHandler(navigator.canNavigateBack()) {
          navigator.navigateBack()
      }

      ListDetailPaneScaffold(
          directive = navigator.scaffoldDirective,
          value = navigator.scaffoldValue,
          listPane = {
              AnimatedPane {
                  MyList(
                      onItemClick = { item ->
                          // Navigate to the detail pane with the passed item
                          navigator.navigateTo(ListDetailPaneScaffoldRole.Detail, item)
                      },
                  )
              }
          },
          detailPane = {
              AnimatedPane {
                  // Show the detail pane content if selected item is available
                  navigator.currentDestination?.content?.let {
                      MyDetails(it)
                  }
              }
          },
      )SampleListDetailPaneScaffold.kt

Last updated 2024-05-06 UTC.

/Alignment lines
================

.. https://developer.android.google.cn/develop/ui/compose/layouts/alignment-lines?hl=en

.. container:: devsite-article-body clearfix

   The Compose layout model lets you use
   `AlignmentLine  <#AlignmentLine>`__
   to create custom alignment lines that can be used by parent layouts to align
   and position their children. For example,
   `Row  <#Row>`__
   can use its children's custom alignment lines to align them.

   When a layout provides a value for a particular ``AlignmentLine``, the
   layout's parents can read this value after measuring, using the
   `Placeable.get  <#get>`__
   operator on the corresponding
   `Placeable  <#Placeable>`__
   instance. Based on the position of the ``AlignmentLine``, the parents can
   then decide the positioning of the children.

   Some composables in Compose already come with alignment lines. For example,
   the
   `BasicText  <#BasicText>`__
   composable exposes the ``FirstBaseline`` and ``LastBaseline`` alignment
   lines.

   In the example below, a custom
   `LayoutModifier  <#LayoutModifier>`__
   called ``firstBaselineToTop`` reads the ``FirstBaseline`` to add padding to
   the ``Text`` starting from its first baseline.

   |image-alignmentlines-text|

   **Figure 1.** Shows the difference between adding normal padding to an
   element, and applying padding to a Text element's baseline.

   .. code:: prettyprint

      fun Modifier.firstBaselineToTop(
          firstBaselineToTop: Dp,
      ) = layout { measurable, constraints ->
          // Measure the composable
          val placeable = measurable.measure(constraints)

          // Check the composable has a first baseline
          check(placeable[FirstBaseline] != AlignmentLine.Unspecified)
          val firstBaseline = placeable[FirstBaseline]

          // Height of the composable with padding - first baseline
          val placeableY = firstBaselineToTop.roundToPx() - firstBaseline
          val height = placeable.height + placeableY
          layout(placeable.width, height) {
              // Where the composable gets placed
              placeable.placeRelative(0, placeableY)
          }
      }

      @Preview
      @Composable
      private fun TextWithPaddingToBaseline() {
          MaterialTheme {
              Text("Hi there!", Modifier.firstBaselineToTop(32.dp))
          }
      }AlignmentLinesSnippets.kt

   In order to read the ``FirstBaseline`` in the example,
   ``placeable [FirstBaseline]`` is used in the measurement phase.

   **Note:**\  The ``firstBaselineToTop`` modifier is shown for educational
   purposes. The Compose library provides a
   `paddingFrom  <#paddingFrom>`__
   modifier that allows you to specify padding relative to any alignment line
   defined in that layout.

   .. rubric:: Create custom alignment lines
      :name: custom-alignment-lines

   When creating a custom
   `Layout  <#Layout>`__
   composable or a custom
   `LayoutModifier  <#LayoutModifier>`__,
   you can provide custom alignment lines so that other parent composables can
   use them to align and position their children accordingly.

   **Note:**\  If you want to learn more about creating custom
   `Layout  <#Layout>`__
   composables and layout modifiers, check out the `Custom layouts  <#custom>`__ documentation.
   The following example shows a custom ``BarChart`` composable that exposes two
   alignment lines, ``MaxChartValue`` and ``MinChartValue``, so that other
   composables can align to the maximum and minimum data value of the chart. Two
   text elements, *Max* and *Min*, have been aligned to the center of the custom
   alignment lines.

   |image-alignmentlines-chart|

   **Figure 2.** ``BarChart`` composable with Text aligned to the maximum and
   minimum data value.

   Custom alignment lines are defined as top level variables in your project.

   .. code:: prettyprint

      /**
       * AlignmentLine defined by the maximum data value in a [BarChart]
       */
      private val MaxChartValue = HorizontalAlignmentLine(merger = { old, new ->
          min(old, new)
      })

      /**
       * AlignmentLine defined by the minimum data value in a [BarChart]
       */
      private val MinChartValue = HorizontalAlignmentLine(merger = { old, new ->
          max(old, new)
      })AlignmentLinesSnippets.kt

   The custom alignment lines to create our example are of type
   `HorizontalAlignmentLine  <#HorizontalAlignmentLine>`__,
   as they're used to align children vertically. A merge policy is passed as a
   parameter in case multiple layouts provide a value for these alignment lines.
   As the Compose layout system coordinates and the
   `Canvas  <#Canvas>`__
   coordinates represent ``[0, 0]``, the top left corner and the ``x`` and ``y``
   axis are positive downwards, so the ``MaxChartValue`` value will always be
   smaller than ``MinChartValue``. Therefore, the merger policy is ``min`` for
   the maximum chart data value baseline, and ``max`` for the minimum chart data
   value baseline.

   When creating a custom ``Layout`` or ``LayoutModifier``, specify custom
   alignment lines in the
   `MeasureScope.layout  <#layout>`__
   method, which takes an ``alignmentLines: Map<AlignmentLine, Int>`` parameter.

   .. code:: prettyprint

      @Composable
      private fun BarChart(
          dataPoints: List<Int>,
          modifier: Modifier = Modifier,
      ) {
          val maxValue: Float = remember(dataPoints) { dataPoints.maxOrNull()!! * 1.2f }

          BoxWithConstraints(modifier = modifier) {
              val density = LocalDensity.current
              with(density) {
                  // ...
                  // Calculate baselines
                  val maxYBaseline = // ...
                  val minYBaseline = // ...
                  Layout(
                      content = {},
                      modifier = Modifier.drawBehind {
                          // ...
                      }
                  ) { _, constraints ->
                      with(constraints) {
                          layout(
                              width = if (hasBoundedWidth) maxWidth else minWidth,
                              height = if (hasBoundedHeight) maxHeight else minHeight,
                              // Custom AlignmentLines are set here. These are propagated
                              // to direct and indirect parent composables.
                              alignmentLines = mapOf(
                                  MinChartValue to minYBaseline.roundToInt(),
                                  MaxChartValue to maxYBaseline.roundToInt()
                              )
                          ) {}
                      }
                  }
              }
          }
      }AlignmentLinesSnippets.kt

   **Direct and indirect parents of this composable can consume the alignment
   lines**. The following composable creates a custom layout that takes as a
   parameter two ``Text`` slots and data points, and aligns the two texts to the
   maximum and minimum chart data values. The preview of this composable is
   what's shown in Figure 2.

   .. code:: prettyprint

      @Composable
      private fun BarChartMinMax(
          dataPoints: List<Int>,
          maxText: @Composable () -> Unit,
          minText: @Composable () -> Unit,
          modifier: Modifier = Modifier,
      ) {
          Layout(
              content = {
                  maxText()
                  minText()
                  // Set a fixed size to make the example easier to follow
                  BarChart(dataPoints, Modifier.size(200.dp))
              },
              modifier = modifier
          ) { measurables, constraints ->
              check(measurables.size == 3)
              val placeables = measurables.map {
                  it.measure(constraints.copy(minWidth = 0, minHeight = 0))
              }

              val maxTextPlaceable = placeables[0]
              val minTextPlaceable = placeables[1]
              val barChartPlaceable = placeables[2]

              // Obtain the alignment lines from BarChart to position the Text
              val minValueBaseline = barChartPlaceable[MinChartValue]
              val maxValueBaseline = barChartPlaceable[MaxChartValue]
              layout(constraints.maxWidth, constraints.maxHeight) {
                  maxTextPlaceable.placeRelative(
                      x = 0,
                      y = maxValueBaseline - (maxTextPlaceable.height / 2)
                  )
                  minTextPlaceable.placeRelative(
                      x = 0,
                      y = minValueBaseline - (minTextPlaceable.height / 2)
                  )
                  barChartPlaceable.placeRelative(
                      x = max(maxTextPlaceable.width, minTextPlaceable.width) + 20,
                      y = 0
                  )
              }
          }
      }
      @Preview
      @Composable
      private fun ChartDataPreview() {
          MaterialTheme {
              BarChartMinMax(
                  dataPoints = listOf(4, 24, 15),
                  maxText = { Text("Max") },
                  minText = { Text("Min") },
                  modifier = Modifier.padding(24.dp)
              )
          }
      }AlignmentLinesSnippets.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Graphics in Compose  <#overview>`__
   -  `Custom layouts {:#custom-layouts }  <#custom>`__
   -  `Intrinsic measurements in Compose layouts  <#intrinsic-measurements>`__

Last updated 2024-05-03 UTC.

.. |image-alignmentlines-text| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/alignmentlines-text.png
   :width: 500px
.. |image-alignmentlines-chart| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/alignmentlines-chart.png
   :width: 500px

/Intrinsic measurements
=======================

.. https://developer.android.google.cn/develop/ui/compose/layouts/intrinsic-measurements?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   One of the rules of Compose is that you should only measure your children
   once; measuring children twice throws a runtime exception. However, there are
   times when you need some information about your children before measuring
   them.

   **Intrinsics lets you query children before they're actually measured.**

   To a composable, you can ask for its ``intrinsicWidth`` or
   ``intrinsicHeight``:

   -  ``(min|max)IntrinsicWidth``: Given this height, what's the minimum/maximum
      width you can paint your content properly?
   -  ``(min|max)IntrinsicHeight``: Given this width, what's the minimum/maximum
      height you can paint your content properly?

   For example, if you ask the ``minIntrinsicHeight`` of a ``Text`` with
   infinite ``width``, it'll return the ``height`` of the ``Text`` as if the
   text was drawn in a single line.

   **Note:**\  Asking for intrinsics measurements doesn't measure the children
   twice. Children are queried for their intrinsic measurements before they're
   measured and then, based on that information the parent calculates the
   constraints to measure its children with.

   .. rubric:: Intrinsics in action
      :name: intrinsics-in-action

   Imagine that we want to create a composable that displays two texts on the
   screen separated by a divider like this:

   |Two text elements side by side, with a vertical divider between them|

   How can we do this? We can have a ``Row`` with two ``Text``\ s inside that
   expands as much as they can and a ``Divider`` in the middle. We want the
   ``Divider`` to be as tall as the tallest ``Text`` and thin
   (``width = 1.dp``).

   .. code:: prettyprint

      @Composable
      fun TwoTexts(modifier: Modifier = Modifier, text1: String, text2: String) {
          Row(modifier = modifier) {
              Text(
                  modifier = Modifier
                      .weight(1f)
                      .padding(start = 4.dp)
                      .wrapContentWidth(Alignment.Start),
                  text = text1
              )
              Divider(
                  color = Color.Black,
                  modifier = Modifier.fillMaxHeight().width(1.dp)
              )
              Text(
                  modifier = Modifier
                      .weight(1f)
                      .padding(end = 4.dp)
                      .wrapContentWidth(Alignment.End),

                  text = text2
              )
          }
      }IntrinsicSnippets.kt

   If we preview this, we see that the ``Divider`` expands to the whole screen
   and that's not what we want:

   |Two text elements side by side, with a divider between them, but the divider
   stretches down below the bottom of the text|

   This happens because ``Row`` measures each child individually and the height
   of ``Text`` cannot be used to constraint the ``Divider``. We want the
   ``Divider`` to fill the available space with a given height. For that, we can
   use the ``height(IntrinsicSize.Min)`` modifier .

   ``height(IntrinsicSize.Min)`` sizes its children being forced to be as tall
   as their minimum intrinsic height. As it's recursive, it'll query ``Row`` and
   its children ``minIntrinsicHeight``.

   Applying that to our code, it'll work as expected:

   .. code:: prettyprint

      @Composable
      fun TwoTexts(modifier: Modifier = Modifier, text1: String, text2: String) {
          Row(modifier = modifier.height(IntrinsicSize.Min)) {
              Text(
                  modifier = Modifier
                      .weight(1f)
                      .padding(start = 4.dp)
                      .wrapContentWidth(Alignment.Start),
                  text = text1
              )
              Divider(
                  color = Color.Black,
                  modifier = Modifier.fillMaxHeight().width(1.dp)
              )
              Text(
                  modifier = Modifier
                      .weight(1f)
                      .padding(end = 4.dp)
                      .wrapContentWidth(Alignment.End),

                  text = text2
              )
          }
      }

      // @Preview
      @Composable
      fun TwoTextsPreview() {
          MaterialTheme {
              Surface {
                  TwoTexts(text1 = "Hi", text2 = "there")
              }
          }
      }IntrinsicSnippets.kt

   With preview:

   |Two text elements side by side, with a vertical divider between them|

   The ``Row`` composable's ``minIntrinsicHeight`` will be the maximum
   ``minIntrinsicHeight`` of its children. The ``Divider`` element's
   ``minIntrinsicHeight`` is 0 as it doesn't occupy space if no constraints are
   given; the ``Text`` ``minIntrinsicHeight`` will be that of the text given a
   specific ``width``. Therefore, the ``Row`` element's ``height`` constraint
   will be the max ``minIntrinsicHeight`` of the ``Text``\ s. ``Divider`` will
   then expand its ``height`` to the ``height`` constraint given by the ``Row``.

   .. rubric:: Intrinsics in your custom layouts
      :name: intrinsics-in-layouts

   When creating a custom ``Layout`` or ``layout`` modifier, intrinsic
   measurements are calculated automatically based on approximations. Therefore,
   the calculations might not be correct for all layouts. These APIs offer
   options to override these defaults.

   To specify the intrinsics measurements of your custom ``Layout``, override
   the ``minIntrinsicWidth``, ``minIntrinsicHeight``, ``maxIntrinsicWidth``, and
   ``maxIntrinsicHeight`` of the
   `MeasurePolicy  <#MeasurePolicy>`__
   interface when creating it.

   .. code:: prettyprint

      @Composable
      fun MyCustomComposable(
          modifier: Modifier = Modifier,
          content: @Composable () -> Unit
      ) {
          Layout(
              content = content,
              modifier = modifier,
              measurePolicy = object : MeasurePolicy {
                  override fun MeasureScope.measure(
                      measurables: List<Measurable>,
                      constraints: Constraints
                  ): MeasureResult {
                      // Measure and layout here
                      // ...
                  }

                  override fun IntrinsicMeasureScope.minIntrinsicWidth(
                      measurables: List<IntrinsicMeasurable>,
                      height: Int
                  ): Int {
                      // Logic here
                      // ...
                  }

                  // Other intrinsics related methods have a default value,
                  // you can override only the methods that you need.
              }
          )
      }IntrinsicSnippets.kt

   When creating your custom ``layout`` modifier, override the related methods
   in the ``LayoutModifier`` interface.

   .. code:: prettyprint

      fun Modifier.myCustomModifier(/* ... */) = this then object : LayoutModifier {

          override fun MeasureScope.measure(
              measurable: Measurable,
              constraints: Constraints
          ): MeasureResult {
              // Measure and layout here
              // ...
          }

          override fun IntrinsicMeasureScope.minIntrinsicWidth(
              measurable: IntrinsicMeasurable,
              height: Int
          ): Int {
              // Logic here
              // ...
          }

          // Other intrinsics related methods have a default value,
          // you can override only the methods that you need.
      }IntrinsicSnippets.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Custom layouts {:#custom-layouts }  <#custom>`__
   -  `Alignment lines in Jetpack Compose  <#alignment-lines>`__
   -  `Jetpack Compose Phases  <#phases>`__

Last updated 2024-05-03 UTC.

.. |Two text elements side by side, with a vertical divider between them| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-text-with-divider.png
   :width: 500px
.. |Two text elements side by side, with a divider between them, but the divider stretches down below the bottom of the text| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-text-with-divider-too-long.png
   :width: 500px

/ConstraintLayout
=================

.. https://developer.android.google.cn/develop/ui/compose/layouts/constraintlayout?hl=en

.. container:: devsite-article-body clearfix

   `ConstraintLayout  <#ConstraintLayout>`__
   is a layout that allows you to place composables relative to other
   composables on the screen. It is an alternative to using multiple nested
   ``Row``, ``Column``, ``Box`` and `other custom layout elements  <#Row>`__.
   ``ConstraintLayout`` is useful when implementing larger layouts with more
   complicated alignment requirements.

   Consider using ``ConstraintLayout`` in the following scenarios:

   -  To avoid nesting multiple ``Column``\ s and ``Row``\ s for positioning
      elements on screen to improve readability of code.
   -  To position composables relative to other composables or to position
      composables based on guidelines, barriers or chains.

   In the View system, ``ConstraintLayout`` was the recommended way to create
   large and complex layouts, as a flat view hierarchy was better for
   performance than nested views are. However, this is not a concern in Compose,
   which is able to efficiently handle deep layout hierarchies.

   .. rubric:: Get started with ``ConstraintLayout``
      :name: get-started

   To use ``ConstraintLayout`` in Compose, you need to add this dependency in
   your ``build.gradle`` (in addition to the `Compose setup  <#setup>`__):

   .. code:: kotlin

      implementation "androidx.constraintlayout:constraintlayout-compose:1.0.1"

   **Note:**\  The ``constraintLayout-compose`` artifact has a different
   versioning than Jetpack Compose. Check the latest version in the
   `ConstraintLayout release page  <#constraintlayout>`__.
   ``ConstraintLayout`` in Compose works in the following way using a
   `DSL <https://kotlinlang.org/docs/reference/type-safe-builders.html>`__:

   -  Create references for each composable in the ``ConstraintLayout`` using
      the
      `createRefs()  <#createrefs>`__
      or
      `createRefFor()  <#createreffor>`__
   -  Constraints are provided using the ``constrainAs()`` modifier, which takes
      the reference as a parameter and lets you specify its constraints in the
      body lambda.
   -  Constraints are specified using ``linkTo()`` or other helpful methods.
   -  ``parent`` is an existing reference that can be used to specify
      constraints towards the ``ConstraintLayout`` composable itself.

   Here's an example of a composable using a ``ConstraintLayout``:

   .. code:: prettyprint

      @Composable
      fun ConstraintLayoutContent() {
          ConstraintLayout {
              // Create references for the composables to constrain
              val (button, text) = createRefs()

              Button(
                  onClick = { /* Do something */ },
                  // Assign reference "button" to the Button composable
                  // and constrain it to the top of the ConstraintLayout
                  modifier = Modifier.constrainAs(button) {
                      top.linkTo(parent.top, margin = 16.dp)
                  }
              ) {
                  Text("Button")
              }

              // Assign reference "text" to the Text composable
              // and constrain it to the bottom of the Button composable
              Text(
                  "Text",
                  Modifier.constrainAs(text) {
                      top.linkTo(button.bottom, margin = 16.dp)
                  }
              )
          }
      }ConstraintLayoutSnippets.kt

   This code constrains the top of the ``Button`` to the parent with a margin of
   ``16.dp`` and a ``Text`` to the bottom of the ``Button`` also with a margin
   of ``16.dp``.

   |Shows a button and a text element arranged in a ConstraintLayout|

   .. rubric:: Decoupled API
      :name: decoupled

   In the ``ConstraintLayout`` example, constraints are specified inline, with a
   modifier in the composable they're applied to. However, there are situations
   when it's preferable to decouple the constraints from the layouts they apply
   to. For example, you might want to change the constraints based on the screen
   configuration, or animate between two constraint sets.

   For cases like these, you can use ``ConstraintLayout`` in a different way:

   #. Pass in a
      `ConstraintSet  <#ConstraintSet>`__
      as a parameter to ``ConstraintLayout``.
   #. Assign references created in the ``ConstraintSet`` to composables using
      the
      `layoutId  <#layoutId>`__
      modifier.

   .. code:: prettyprint

      @Composable
      fun DecoupledConstraintLayout() {
          BoxWithConstraints {
              val constraints = if (minWidth < 600.dp) {
                  decoupledConstraints(margin = 16.dp) // Portrait constraints
              } else {
                  decoupledConstraints(margin = 32.dp) // Landscape constraints
              }

              ConstraintLayout(constraints) {
                  Button(
                      onClick = { /* Do something */ },
                      modifier = Modifier.layoutId("button")
                  ) {
                      Text("Button")
                  }

                  Text("Text", Modifier.layoutId("text"))
              }
          }
      }

      private fun decoupledConstraints(margin: Dp): ConstraintSet {
          return ConstraintSet {
              val button = createRefFor("button")
              val text = createRefFor("text")

              constrain(button) {
                  top.linkTo(parent.top, margin = margin)
              }
              constrain(text) {
                  top.linkTo(button.bottom, margin)
              }
          }
      }ConstraintLayoutSnippets.kt

   Then, when you need to change the constraints, you can just pass a different
   ``ConstraintSet``.

   .. rubric:: ``ConstraintLayout`` concepts
      :name: concepts

   ``ConstraintLayout`` contains concepts such as guidelines, barriers and
   chains that can help with positioning elements inside your Composable.

   .. rubric:: Guidelines
      :name: guidelines

   Guidelines are small visual helpers to design layouts with. Composables can
   be constrained to a guideline. Guidelines are useful for positioning elements
   at a certain `dp  <#Dp>`__ or
   `percentage  <#setGuidelinePercent>`__
   inside the parent composable.

   There are two different kinds of
   `guidelines  <#Guideline>`__,
   vertical and horizontal. The two horizontal ones are ``top`` and ``bottom``,
   and the two vertical are ``start`` and ``end``.

   .. code:: prettyprint

      ConstraintLayout {
          // Create guideline from the start of the parent at 10% the width of the Composable
          val startGuideline = createGuidelineFromStart(0.1f)
          // Create guideline from the end of the parent at 10% the width of the Composable
          val endGuideline = createGuidelineFromEnd(0.1f)
          //  Create guideline from 16 dp from the top of the parent
          val topGuideline = createGuidelineFromTop(16.dp)
          //  Create guideline from 16 dp from the bottom of the parent
          val bottomGuideline = createGuidelineFromBottom(16.dp)
      }ConstraintLayoutSnippets.kt

   To create a guideline, use ``createGuidelineFrom*`` with the type of
   guideline required. This creates a reference that can be used in the
   ``Modifier.constrainAs()`` block.

   **Note:**\  Consider using the ``Spacer`` composable to achieve a similar
   effect with ``Rows`` and ``Columns``.

   .. rubric:: Barriers
      :name: barriers

   `Barriers  <#Barrier>`__ reference
   multiple composables to create a virtual guideline based on the most extreme
   widget on the specified side.

   To create a barrier, use ``createTopBarrier()`` (or:
   ``createBottomBarrier()``, ``createEndBarrier()``, ``createStartBarrier()``),
   and provide the references that should make up the barrier.

   .. code:: prettyprint

      ConstraintLayout {
          val constraintSet = ConstraintSet {
              val button = createRefFor("button")
              val text = createRefFor("text")

              val topBarrier = createTopBarrier(button, text)
          }
      }ConstraintLayoutSnippets.kt

   The barrier can then be used in a ``Modifier.constrainAs()`` block.

   **Note:**\  Consider using `Intrinsic measurements  <#intrinsic-measurements>`__ to
   achieve a similar effect with Rows and Columns.

   .. rubric:: Chains
      :name: chains

   Chains provide group-like behavior in a single axis (horizontally or
   vertically) . The other axis can be constrained independently.

   To create a chain, use either
   `createVerticalChain  <#createVerticalChain>`__
   or
   `createHorizontalChain  <#createHorizontalChain>`__:

   .. code:: prettyprint

      ConstraintLayout {
          val constraintSet = ConstraintSet {
              val button = createRefFor("button")
              val text = createRefFor("text")

              val verticalChain = createVerticalChain(button, text, chainStyle = ChainStyle.Spread)
              val horizontalChain = createHorizontalChain(button, text)
          }
      }ConstraintLayoutSnippets.kt

   The chain can then be used in the ``Modifier.constrainAs()`` block.

   A chain can be configured with different
   `ChainStyles  <#ChainStyle>`__,
   which decide how to deal with the space surrounding a composable, such as:

   -  ``ChainStyle.Spread``: Space is distributed evenly across all the
      composables, including free space before the first composable and after
      the last composable.
   -  ``ChainStyle.SpreadInside``: Space is distributed evenly across the all
      composables, without any free space before the first composable or after
      the last composable.
   -  ``ChainStyle.Packed``: Space is distributed before the first and after the
      last composable, composables are packed together without space in between
      each other.

   **Note:**\  Consider using traditional Rows and Columns with different
   `Arrangements  <#Arrangement>`__
   to achieve a similar effect to Chains in ConstraintLayout.

   .. rubric:: Learn more
      :name: nextsteps-constraintlayout

   Learn more about ``ConstraintLayout`` in Compose from the APIs in action in
   the `Compose samples that use ConstraintLayout <https://github.com/android/compose-samples/search?q=ConstraintLayout>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Focus in Compose  <#focus>`__
   -  `Kotlin for Jetpack Compose  <#kotlin>`__
   -  `Compose layout basics  <#basics>`__

Last updated 2024-05-03 UTC.

.. |Shows a button and a text element arranged in a ConstraintLayout| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-button-text.png
   :width: 200px

/Overview: Components
=====================

.. https://developer.android.google.cn/develop/ui/compose/components?hl=en

.. container:: devsite-article-body clearfix

   .. container:: section

      .. rubric:: Material components in Compose
         :name: material-components-in-compose

         Jetpack Compose offers an implementation of Material
         Design, a comprehensive design system for creating
         digital interfaces. You can use composable functions to
         implement Material components.

         .. figure::
            https://developer.android.google.cn/static/develop/ui/compose/images/components/hero.svg

   .. container:: section

      .. rubric:: Layouts
         :name: layouts

         |image-scaffold-landing|

         .. rubric:: `Scaffold <https://developer.android.google.cn/develop/ui/compose/components/scaffold>`__
            :name: scaffold

            Use the ``Scaffold`` composable to provide structure for
            your screens.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/components/scaffold>`__

            |image-appbar-landing|


         .. rubric:: `App bars <https://developer.android.google.cn/develop/ui/compose/components/app-bars>`__
            :name: app-bars

            Various composables let you create app bars along the
            top and bottom of your screens.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/components/app-bars>`__

   .. container:: section

      .. rubric:: User input
         :name: user-input

      .. container:: section

         |image-buttons-landing|

         .. rubric:: `Common buttons <https://developer.android.google.cn/develop/ui/compose/components/button>`__
            :name: common-buttons

            Use ``Button`` and similar composables to create a range
            of common buttons.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/components/button>`__


      .. container:: section

         |image-switch-landing|

         .. rubric:: `Switch <https://developer.android.google.cn/develop/ui/compose/components/switch>`__
            :name: switch

            Switches to let the user to toggle options in your app.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/components/switch>`__

      .. container:: section

         |image-slider-landing|

         .. rubric:: `Slider <https://developer.android.google.cn/develop/ui/compose/components/slider>`__
            :name: slider

            The user can use sliders to select a value within a range.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/components/slider>`__

      .. container:: section

         |image-chip-landing|

         .. rubric:: `Chip <https://developer.android.google.cn/develop/ui/compose/components/chip>`__
            :name: chip

            Chips allow you to surface information to and handle
            input from the user.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/components/chip>`__

   .. container:: section

      |image-fab-landing|

      .. rubric:: `Floating action buttons <https://developer.android.google.cn/develop/ui/compose/components/fab>`__
         :name: floating-action-buttons

         Use ``FloatingActionButton`` and similar composables to
         create a range of floating action buttons.

         `Learn more <https://developer.android.google.cn/develop/ui/compose/components/fab>`__

   .. container:: section

      .. rubric:: Other components
         :name: other-components

         .. container:: float devsite-landing-row-item-image

            |image-progress-landing|

            .. rubric:: `Progress indicators <https://developer.android.google.cn/develop/ui/compose/components/progress>`__
               :name: progress-indicators

               Progress indicators provide the user with visual
               information regarding the progress of processing.

               `Learn more <https://developer.android.google.cn/develop/ui/compose/components/progress>`__

   .. container:: section

      .. container:: float devsite-landing-row-item-image

         |image-card-landing|

         .. rubric:: `Card <https://developer.android.google.cn/develop/ui/compose/components/card>`__
            :name: card

            Use cards to contain a single set of information on a
            screen.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/components/card>`__

      .. container:: float devsite-landing-row-item-image

         |image-dialog-landing0|

         .. rubric:: `Dialog <https://developer.android.google.cn/develop/ui/compose/components/dialog>`__
            :name: dialog

            The ``Dialog`` to surface messages and options to the
            user.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/components/dialog>`__

   .. container:: section

      .. container:: float devsite-landing-row-item-image

         |image-snackbar-landing1|

         .. rubric:: `Snackbars <https://developer.android.google.cn/develop/ui/compose/components/snackbar>`__
            :name: snackbars

            Use a Snackbar to display brief message in a small popup
            at the bottom of the screen.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/components/snackbar>`__

      .. container:: float devsite-landing-row-item-image

         |image-drawers-landing2|

         .. rubric:: `Drawers <https://developer.android.google.cn/develop/ui/compose/components/drawer>`__
            :name: drawers

            A drawer is a slide-out sidebar for navigation or
            additional content

            `Learn more <https://developer.android.google.cn/develop/ui/compose/components/drawer>`__

   .. container:: section

         list_alt

      .. rubric:: `Lists and grids <https://developer.android.google.cn/develop/ui/compose/lists>`__
         :name: lists-and-grids

         Learn how to use basic layouts in Compose.

         `Learn more <https://developer.android.google.cn/develop/ui/compose/lists>`__


         folder_open

      .. rubric:: `Resources <https://developer.android.google.cn/develop/ui/compose/resources>`__
         :name: resources

         Learn how to manage resources such as strings and
         images.

         `Learn more <https://developer.android.google.cn/develop/ui/compose/resources>`__

Last updated 2024-03-25 UTC.

.. |image-scaffold-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/scaffold-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/scaffold
.. |image-appbar-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/app-bars
.. |image-buttons-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/buttons-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/button
.. |image-switch-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/switch-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/switch
.. |image-slider-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/slider-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/slider
.. |image-chip-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/chip-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/chip
.. |image-fab-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/fab-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/fab
.. |image-progress-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/progress-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/progress
.. |image-card-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/card-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/card
.. |image-dialog-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/dialog-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/dialog
.. |image-snackbar-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/snackbar-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/snackbar
.. |image-drawers-landing| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/drawers-landing.svg
   :target: https://developer.android.google.cn/develop/ui/compose/components/drawer

/Scaffold
=========

.. https://developer.android.google.cn/develop/ui/compose/components/scaffold?hl=en

.. container:: devsite-article-body clearfix

   In Material Design, a scaffold is a fundamental structure that provides a
   standardized platform for complex user interfaces. It holds together
   different parts of the UI, such as app bars and floating action buttons,
   giving apps a coherent look and feel.

   .. rubric:: Example
      :name: example

   The
   `Scaffold  <#ScaffoldState>`__
   composable provides a straightforward API you can use to quickly assemble
   your app's structure according to Material Design guidelines. ``Scaffold``
   accepts several composables as parameters. Among these are the following:

   -  ``topBar``: The app bar across the top of the screen.
   -  ``bottomBar``: The app bar across the bottom of the screen.
   -  ``floatingActionButton``: A button that hovers over the bottom-right
      corner of the screen that you can use to expose key actions.

   For more detailed examples on how you can implement both top and bottom app
   bars, see the app bars page.

   You can also pass ``Scaffold`` content as you would to other containers. It
   passes an ``innerPadding`` value to the ``content`` lambda that you can then
   use in child composables.

   The following example provides a full example of how you might implement
   ``Scaffold``. It contains a top app bar, bottom app bar, and a floating
   action button that interacts with ``Scaffold``'s internal state.

   .. code:: prettyprint

      @Composable
      fun ScaffoldExample() {
          var presses by remember { mutableIntStateOf(0) }

          Scaffold(
              topBar = {
                  TopAppBar(
                      colors = topAppBarColors(
                          containerColor = MaterialTheme.colorScheme.primaryContainer,
                          titleContentColor = MaterialTheme.colorScheme.primary,
                      ),
                      title = {
                          Text("Top app bar")
                      }
                  )
              },
              bottomBar = {
                  BottomAppBar(
                      containerColor = MaterialTheme.colorScheme.primaryContainer,
                      contentColor = MaterialTheme.colorScheme.primary,
                  ) {
                      Text(
                          modifier = Modifier
                              .fillMaxWidth(),
                          textAlign = TextAlign.Center,
                          text = "Bottom app bar",
                      )
                  }
              },
              floatingActionButton = {
                  FloatingActionButton(onClick = { presses++ }) {
                      Icon(Icons.Default.Add, contentDescription = "Add")
                  }
              }
          ) { innerPadding ->
              Column(
                  modifier = Modifier
                      .padding(innerPadding),
                  verticalArrangement = Arrangement.spacedBy(16.dp),
              ) {
                  Text(
                      modifier = Modifier.padding(8.dp),
                      text =
                      """
                          This is an example of a scaffold. It uses the Scaffold composable's 
                          parameters to create a screen with a simple top app bar, 
                          bottom app bar, and floating action button.

                          It also contains some basic inner content, such as this text.

                          You have pressed the floating action button $presses times.
                      """.trimIndent(),
                  )
              }
          }
      }Scaffold.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/scaffold.png
      name: image-1
      :alt: An implementation of scaffold that contains simple top and bottom
      app bars, as well as a floating action button that iterates a counter. The
      inner content of the scaffold is simple text that explains the component.
      :width: 100.0%

      **Figure 1.** An implementation of scaffold.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `App bars  <#app-bars>`__

Last updated 2024-05-03 UTC.

/App bars
=========

.. https://developer.android.google.cn/develop/ui/compose/components/app-bars?hl=en

.. container:: devsite-article-body clearfix

   App bars are containers that provide the user access to key features and
   navigation items. There are two types of app bars, top app bars and bottom
   app bars. Their respective appearance and purpose are as follows:

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Appearance
         - Purpose
      - 

         - Top app bar
         - Across the top of the screen.
         - Provides access to key tasks and information. Generally hosts a
            title, core action items, and certain navigation items.
      - 

         - Bottom app bar
         - Across the bottom of the screen.
         - Typically includes core navigation items. May also provide access to
            other key actions, such as through a contained floating action
            button.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbars.svg
      name: image-1
      :alt: An example of a top and bottom app bar.
      :width: 100.0%

      **Figure 1.** A top app bar (left) and a bottom app bar (right).

   To implement a top app bar and bottom app bar, use the
   `TopAppBar  <#TopAppBar>`__
   and
   `BottomAppBar  <#BottomAppBar>`__
   composables, respectively. They let you create consistent interfaces that
   encapsulate navigation and action controls, and which are aligned with
   Material Design principles.

   **Important:**\  App bars are generally passed to the ``Scaffold``
   composable, which has specific parameters to receive them. For more
   information about how ``Scaffold`` provides a convenient way of structuring
   your app, visit the `Scaffold page  <#scaffold>`__.

   .. rubric:: Top app bars
      :name: top-bar

   The following table outlines the four types of top app bars:

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Example
      - 

         - **Small**: For screens that don't require a lot of navigation or
            actions.
         - |Small top app bar|
      - 

         - **Center aligned**: For screens that have a single, primary action.
         - |Center aligned top app bar|
      - 

         - **Medium**: For screens that require a moderate amount of navigation
            and actions.
         - |Medium top app bar|
      - 

         - **Large**: For screens that require a lot of navigation and actions.
         - |Large top app bar|

   .. rubric:: API surface
      :name: api

   The various composables that allow you to implement the four different top
   app bars are quite similar. They share several key parameters:

   -  ``title``: The text that appears across the app bar.
   -  ``navigationIcon``: The primary icon for navigation. Appears on the left
      of the app bar.
   -  ``actions``: Icons that provide the user access to key actions. They
      appear on the right of the app bar.
   -  ``scrollBehavior``: Determines how the top app bar responds to scrolling
      of the scaffold's inner content.
   -  ``colors``: Determines how the app bar appears.

   .. rubric:: Scroll behavior
      :name: scroll

   You can control how the app bar responds when the user scrolls the given
   scaffold's inner content. To do so, create an instance of
   `TopAppBarScrollBehavior  <#TopAppBarScrollBehavior>`__
   and pass it to your top app bar for the ``scrollBehavior`` parameter.

   There are three types of ``TopAppBarScrollBehavior``. They are as follows:

   -  ``enterAlwaysScrollBehavior``: When the user pulls up the scaffold's inner
      content, the top app bar collapses. The app bar expands when the user then
      pulls down the inner content.
   -  ``exitUntilCollapsedScrollBehavior``: Similar to
      ``enterAlwaysScrollBehavior``, though the app bar additionally expands
      when the user reaches the end of the scaffold's inner content.
   -  ``pinnedScrollBehavior``: The app bar remains in place and does not react
      to scrolling.

   The following examples implement several of these options.

   .. rubric:: Examples
      :name: examples

   The following sections provide implementations for the four different types
   of top app bars, including varying examples of how you can control scroll
   behavior.

   .. rubric:: Small
      :name: small

   To create a small top app bar, use the
   `TopAppBar  <#TopAppBar>`__
   composable. This is the simplest possible top app bar and in this example
   just contains a title.

   The following example does not pass ``TopAppBar`` a value for
   ``scrollBehavior`` and it therefore does not react to scrolling of the inner
   content.

   .. code:: prettyprint

      @Composable
      fun SmallTopAppBarExample() {
          Scaffold(
              topBar = {
                  TopAppBar(
                      colors = TopAppBarDefaults.topAppBarColors(
                          containerColor = MaterialTheme.colorScheme.primaryContainer,
                          titleContentColor = MaterialTheme.colorScheme.primary,
                      ),
                      title = {
                          Text("Small Top App Bar")
                      }
                  )
              },
          ) { innerPadding ->
              ScrollContent(innerPadding)
          }
      }AppBar.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-small.png
      name: image-2
      :alt: An example of a small top app bar.
      :width: 100.0%

      **Figure 2.** A small top app bar.

   .. rubric:: Center aligned
      :name: center

   The center aligned top app bar is essentially the same as the small app bar,
   though the title is centered within the component. To implement it, use the
   dedicated
   `CenterAlignedTopAppBar  <#CenterAlignedTopAppBar>`__
   composable.

   This example uses ``enterAlwaysScrollBehavior()`` to get the value that it
   passes for ``scrollBehavior``. As such, the bar collapses when the user
   scrolls the scaffold's inner content.

   .. code:: prettyprint

      @Composable
      fun CenterAlignedTopAppBarExample() {
          val scrollBehavior = TopAppBarDefaults.pinnedScrollBehavior(rememberTopAppBarState())

          Scaffold(
              modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),

              topBar = {
                  CenterAlignedTopAppBar(
                      colors = TopAppBarDefaults.topAppBarColors(
                          containerColor = MaterialTheme.colorScheme.primaryContainer,
                          titleContentColor = MaterialTheme.colorScheme.primary,
                      ),
                      title = {
                          Text(
                              "Centered Top App Bar",
                              maxLines = 1,
                              overflow = TextOverflow.Ellipsis
                          )
                      },
                      navigationIcon = {
                          IconButton(onClick = { /* do something */ }) {
                              Icon(
                                  imageVector = Icons.Filled.ArrowBack,
                                  contentDescription = "Localized description"
                              )
                          }
                      },
                      actions = {
                          IconButton(onClick = { /* do something */ }) {
                              Icon(
                                  imageVector = Icons.Filled.Menu,
                                  contentDescription = "Localized description"
                              )
                          }
                      },
                      scrollBehavior = scrollBehavior,
                  )
              },
          ) { innerPadding ->
              ScrollContent(innerPadding)
          }
      }AppBar.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-centered.png
      name: image-3
      :alt: Write your alt text here
      :width: 100.0%

      **Figure 3.** A center-aligned top app bar.

   .. rubric:: Medium
      :name: medium

   The medium top app bar places the title beneath any additional icons. To
   create one, use the
   `MediumTopAppBar  <#MediumTopAppBar>`__
   composable.

   Like the previous snippet, this example uses ``enterAlwaysScrollBehavior()``
   to get the value that it passes for ``scrollBehavior``.

   .. code:: prettyprint

      @Composable
      fun MediumTopAppBarExample() {
          val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior(rememberTopAppBarState())

          Scaffold(
              modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),
              topBar = {
                  MediumTopAppBar(
                      colors = TopAppBarDefaults.topAppBarColors(
                          containerColor = MaterialTheme.colorScheme.primaryContainer,
                          titleContentColor = MaterialTheme.colorScheme.primary,
                      ),
                      title = {
                          Text(
                              "Medium Top App Bar",
                              maxLines = 1,
                              overflow = TextOverflow.Ellipsis
                          )
                      },
                      navigationIcon = {
                          IconButton(onClick = { /* do something */ }) {
                              Icon(
                                  imageVector = Icons.Filled.ArrowBack,
                                  contentDescription = "Localized description"
                              )
                          }
                      },
                      actions = {
                          IconButton(onClick = { /* do something */ }) {
                              Icon(
                                  imageVector = Icons.Filled.Menu,
                                  contentDescription = "Localized description"
                              )
                          }
                      },
                      scrollBehavior = scrollBehavior
                  )
              },
          ) { innerPadding ->
              ScrollContent(innerPadding)
          }
      }AppBar.kt

   This implementation appears as follows, with a demonstration of how the
   scroll behavior from ``enterAlwaysScrollBehavior()`` appears:

   .. container:: float
      :name: video-1

   .. rubric:: Large
      :name: large

   A large top app bar is similar to the medium, though the padding between the
   title and the icons is greater and it occupies more space on screen overall.
   To create one, use the
   `LargeTopAppBar  <#LargeTopAppBar>`__
   composable.

   Unlike the preceding snippets, this example uses
   ``exitUntilCollapsedScrollBehavior()`` to get the value that it passes for
   ``scrollBehavior``. As such, the bar collapses when the user scrolls the
   scaffold's inner content, but then expands when the user scrolls to the end
   of the inner content.

   .. code:: prettyprint

      @Composable
      fun LargeTopAppBarExample() {
          val scrollBehavior = TopAppBarDefaults.exitUntilCollapsedScrollBehavior(rememberTopAppBarState())

          Scaffold(
              modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),
              topBar = {
                  LargeTopAppBar(
                      colors = TopAppBarDefaults.topAppBarColors(
                          containerColor = MaterialTheme.colorScheme.primaryContainer,
                          titleContentColor = MaterialTheme.colorScheme.primary,
                      ),
                      title = {
                          Text(
                              "Large Top App Bar",
                              maxLines = 1,
                              overflow = TextOverflow.Ellipsis
                          )
                      },
                      navigationIcon = {
                          IconButton(onClick = { /* do something */ }) {
                              Icon(
                                  imageVector = Icons.Filled.ArrowBack,
                                  contentDescription = "Localized description"
                              )
                          }
                      },
                      actions = {
                          IconButton(onClick = { /* do something */ }) {
                              Icon(
                                  imageVector = Icons.Filled.Menu,
                                  contentDescription = "Localized description"
                              )
                          }
                      },
                      scrollBehavior = scrollBehavior
                  )
              },
          ) { innerPadding ->
              ScrollContent(innerPadding)
          }
      }AppBar.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-large.png
      name: image-4
      :alt: A screen in an app with a bottom app bar that holds for action icons
      on the left side, and a floating action button on the right.
      :width: 100.0%

      **Figure 5.** An example implementation of a large top app bar.

   .. rubric:: Bottom app bar
      :name: bottom

   To create a bottom app bar, use the ``BottomAppBar`` composable. Using this
   composable is quite similar to the top app bar composables described in the
   preceding sections of this page. You pass composables for the following key
   parameters:

   -  ``actions``: A series of icons that appear on the left side of the bar.
      These are commonly either key actions for the given screen, or navigation
      items.
   -  ``floatingActionButton``: The floating action button that appears on the
      right side of the bar.

   .. code:: prettyprint

      @Composable
      fun BottomAppBarExample() {
          Scaffold(
              bottomBar = {
                  BottomAppBar(
                      actions = {
                          IconButton(onClick = { /* do something */ }) {
                              Icon(Icons.Filled.Check, contentDescription = "Localized description")
                          }
                          IconButton(onClick = { /* do something */ }) {
                              Icon(
                                  Icons.Filled.Edit,
                                  contentDescription = "Localized description",
                              )
                          }
                          IconButton(onClick = { /* do something */ }) {
                              Icon(
                                  Icons.Filled.Mic,
                                  contentDescription = "Localized description",
                              )
                          }
                          IconButton(onClick = { /* do something */ }) {
                              Icon(
                                  Icons.Filled.Image,
                                  contentDescription = "Localized description",
                              )
                          }
                      },
                      floatingActionButton = {
                          FloatingActionButton(
                              onClick = { /* do something */ },
                              containerColor = BottomAppBarDefaults.bottomAppBarFabColor,
                              elevation = FloatingActionButtonDefaults.bottomAppBarFabElevation()
                          ) {
                              Icon(Icons.Filled.Add, "Localized description")
                          }
                      }
                  )
              },
          ) { innerPadding ->
              Text(
                  modifier = Modifier.padding(innerPadding),
                  text = "Example of a scaffold with a bottom app bar."
              )
          }
      }AppBar.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-bottom.png
      name: image-5
      :alt: A screen in an app with a bottom app bar that holds for action icons
      on the left side, and a floating action button on the right.
      :width: 100.0%

      **Figure 6.** An example implementation of a bottom app bar.

   **Note:**\  You can also use ``BottomAppBar`` without passing a value for
   ``actions`` and ``floatingActionButton``. In that case, you can create a
   custom bottom app bar by filling ``BottomAppBar`` with content as you would
   other containers.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Material3 docs - Top app bar <https://m3.material.io/components/top-app-bar/overview>`__
   -  `Material3 docs - Bottom app bar <https://m3.material.io/components/bottom-app-bar/overview>`__
   -  `Scaffold  <#scaffold>`__

Last updated 2024-05-03 UTC.

.. |Small top app bar| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-small.svg
.. |Center aligned top app bar| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-center.svg
.. |Medium top app bar| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-medium.svg
.. |Large top app bar| image:: https://developer.android.google.cn/static/develop/ui/compose/images/components/appbar-large.svg

/Button
=======

.. https://developer.android.google.cn/develop/ui/compose/components/button?hl=en

.. container:: devsite-article-body clearfix

   Buttons are fundamental components that allow the user to trigger a defined
   action. There are five types of buttons. The following table describes the
   appearance of each of the five button types, as well as where you should use
   them.

   .. list-table::
      :header-rows: 1

      - 

         - Type
         - Appearance
         - Purpose
      - 

         - Filled
         - Solid background with contrasting text.
         - High-emphasis buttons. These are for primary actions in an
            application, such as "submit" and "save." The shadow effect
            emphasizes the button's importance.
      - 

         - Filled tonal
         - Background color varies to match the surface.
         - Also for primary or significant actions. Filled buttons provide more
            visual weight and suit functions such as "add to cart" and "Sign
            in."
      - 

         - Elevated
         - Stands out by having a shadow.
         - Fits a similar role to tonal buttons. Increase elevation to cause the
            button to appear even more prominently.
      - 

         - Outlined
         - Features a border with no fill.
         - Medium-emphasis buttons, containing actions that are important but
            not primary. They pair well with other buttons to indicate
            alternative, secondary actions like "Cancel" or "Back."
      - 

         - Text
         - Displays text with no background or border.
         - Low-emphasis buttons, ideal for less critical actions such as
            navigational links, or secondary functions like "Learn More" or
            "View details."

   The following image demonstrates the five types of buttons in Material
   Design.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/buttons.svg
      name: image-1
      :alt: An example of each of the five button components, with their unique
      characteristics highlighted.
      :width: 100.0%

      **Figure 1.** The five button components.

   .. rubric:: API surface
      :name: api_surface

   -  ``onClick``: The function called when the user presses the button.
   -  ``enabled``: When false, this parameter causes the button to appear
      unavailable and inactive.
   -  ``colors``: An instance of ``ButtonColors`` that determines the colors
      used in the button.
   -  ``contentPadding``: The padding within the button.

   .. rubric:: Filled button
      :name: filled_button

   The filled button component uses the basic
   `Button  <#Button>`__
   composable. It is filled with a solid color by default. The following snippet
   demonstrates how to implement the component:

   .. code:: prettyprint

      @Composable
      fun FilledButtonExample(onClick: () -> Unit) {
          Button(onClick = { onClick() }) {
              Text("Filled")
          }
      }Button.kt

   **Note:**\  If you would like to build a custom button, use the ``Button``
   composable.
   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/button-filled.png
      name: image-2
      :alt: A filled button with a purple background that reads, 'filled'.
      :width: 200px

      **Figure 2.** A filled button.

   .. rubric:: Filled tonal button
      :name: filled_tonal_button

   The filled tonal button component uses the
   `FilledTonalButton  <#FilledTonalButton>`__
   composable. It is filled with a tonal color by default.

   The following snippet demonstrates how to implement the component:

   .. code:: prettyprint

      @Composable
      fun FilledTonalButtonExample(onClick: () -> Unit) {
          FilledTonalButton(onClick = { onClick() }) {
              Text("Tonal")
          }
      }Button.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/button-tonal.png
      name: image-3
      :alt: A tonal button with a light purple background that reads, 'filled'.
      :width: 200px

      **Figure 3.** A tonal button.

   .. rubric:: Outlined button
      :name: outlined_button

   The outlined button component uses the
   `OutlinedButton  <#OutlinedButton>`__
   composable. It appears with an outline by default.

   The following snippet demonstrates how to implement the component:

   .. code:: prettyprint

      @Composable
      fun OutlinedButtonExample(onClick: () -> Unit) {
          OutlinedButton(onClick = { onClick() }) {
              Text("Outlined")
          }
      }Button.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/button-outlined.png
      name: image-4
      :alt: A transparent outlined button with a dark border that reads,
      'Outlined'.
      :width: 200px

      **Figure 4.** An outlined button.

   .. rubric:: Elevated button
      :name: elevated_button

   The elevated button component uses the
   `ElevatedButton  <#ElevatedButton>`__
   composable. It has a shadow that represents the elevation effect by default.
   Note that it is essentially an outlined button with a shadow.

   The following snippet demonstrates how to implement the component:

   .. code:: prettyprint

      @Composable
      fun ElevatedButtonExample(onClick: () -> Unit) {
          ElevatedButton(onClick = { onClick() }) {
              Text("Elevated")
          }
      }Button.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/button-elevated.png
      name: image-5
      :alt: An elevated button with a gray background that reads, 'Elevated'.
      :width: 200px

      **Figure 5.** An elevated button.

   .. rubric:: Text button
      :name: text_button

   The text button component uses the
   `TextButton  <#TextButton>`__
   composable. Until pressed, it appears as only text. It does not have a solid
   fill or outline by default.

   The following snippet demonstrates how to implement the component:

   .. code:: prettyprint

      @Composable
      fun TextButtonExample(onClick: () -> Unit) {
          TextButton(
              onClick = { onClick() }
          ) {
              Text("Text Button")
          }
      }Button.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/button-text.png
      name: image-6
      :alt: A text button that reads 'Text Button'
      :width: 200px

      **Figure 6.** A text button.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Floating action button  <#fab>`__
   -  `Material UI docs <https://m3.material.io/components/buttons/overview>`__

Last updated 2024-05-03 UTC.

/Floating action button
=======================

.. https://developer.android.google.cn/develop/ui/compose/components/fab?hl=en

.. container:: devsite-article-body clearfix

   A Floating Action Button (FAB) is a high-emphasis button that lets the user
   perform a primary action in an application. It promotes a single, focused
   action that is the most common pathway a user might take and is typically
   found anchored to the bottom right of the screen.

   Consider these three use cases where you might use a FAB:

   -  **Create new item**: In a note-taking app, a FAB might be used to quickly
      create a new note.
   -  **Add new contact**: In a chat app, a FAB could open an interface that
      lets the user add someone to a conversation.
   -  **Center location**: In a map interface, a FAB could center the map on the
      user's current location.

   In Material Design, there are four types of FAB:

   -  **FAB**: A floating action button of ordinary size.
   -  **Small FAB**: A smaller floating action button.
   -  **Large FAB**: A larger floating action button.
   -  **Extended FAB**: A floating action button that contains more than just an
      icon.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/fabs.svg
      name: image-1
      :alt: An example of each of the four floating action button components.
      :width: 100.0%

      **Figure 1.** The four floating action button types.

   .. rubric:: API surface
      :name: api

   Although there are several composables you can use to create floating action
   buttons consistent with Material Design, their parameters don't differ
   greatly. Among the key parameters you should keep in mind are the following:

   -  ``onClick``: The function called when the user presses the button.
   -  ``containerColor``: The color of the button.
   -  ``contentColor``: The color of the icon.

   .. rubric:: Floating action button
      :name: basic

   To create a general floating action button, use the basic
   `FloatingActionButton  <#FloatingActionButton>`__
   composable. The following example demonstrates a basic implementation of a
   FAB:

   .. code:: prettyprint

      @Composable
      fun Example(onClick: () -> Unit) {
          FloatingActionButton(
              onClick = { onClick() },
          ) {
              Icon(Icons.Filled.Add, "Floating action button.")
          }
      }FloatingActionButton.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/fab.png
      name: image-2
      :alt: A standard floating action button with rounded corner, a shadow, and
      an 'add' icon.

      **Figure 2.** A floating action button.

   .. rubric:: Small button
      :name: small

   To create a small floating action button, use the
   `SmallFloatingActionButton  <#SmallFloatingActionButton>`__
   composable. The following example demonstrates how to do so, with the
   addition of custom colors.

   .. code:: prettyprint

      @Composable
      fun SmallExample(onClick: () -> Unit) {
          SmallFloatingActionButton(
              onClick = { onClick() },
              containerColor = MaterialTheme.colorScheme.secondaryContainer,
              contentColor = MaterialTheme.colorScheme.secondary
          ) {
              Icon(Icons.Filled.Add, "Small floating action button.")
          }
      }FloatingActionButton.kt

   **Note:**\  Because the various FAB composables share many parameters, you
   can use the approach in this example to customize colors with other
   composables.
   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/fab-small.png
      name: image-3
      :alt: An implementation of SmallFloatingActionButton that contains an
      'add' icon.

      **Figure 3.** A small floating action button.

   .. rubric:: Large button
      :name: large

   To create a large floating action button, use the
   `LargeFloatingActionButton  <#LargeFloatingActionButton>`__
   composable. This composable is not significantly different from the other
   examples aside from the fact that it results in a bigger button.

   The following is a straightforward implementation of a large FAB.

   **Note:**\  This example passes ``CircleShape`` as the value for the
   ``shape`` parameter, resulting in a round button, rather than a square with
   rounded borders. You can pass any instance of ``Shape``, or set the value of
   ``MaterialTheme.shape.large`` to adjust it across your app.
   .. code:: prettyprint

      @Composable
      fun LargeExample(onClick: () -> Unit) {
          LargeFloatingActionButton(
              onClick = { onClick() },
              shape = CircleShape,
          ) {
              Icon(Icons.Filled.Add, "Large floating action button")
          }
      }FloatingActionButton.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/fab-large.png
      name: image-4
      :alt: An implementation of LargeFloatingActionButton that contains an
      'add' icon.

      **Figure 4.** A large floating action button.

   .. rubric:: Extended button
      :name: extended

   You can create more complex floating action buttons with the
   `ExtendedFloatingActionButton  <#ExtendedFloatingActionButton>`__
   composable. The key difference between it and
   `FloatingActionButton  <#FloatingActionButton>`__
   is that it has dedicated ``icon`` and ``text`` parameters. They let you
   create a button with more complex content that scales to fit its content
   appropriately.

   The following snippet demonstrates how to implement
   ``ExtendedFloatingActionButton``, with example values passed for ``icon`` and
   ``text``.

   .. code:: prettyprint

      @Composable
      fun ExtendedExample(onClick: () -> Unit) {
          ExtendedFloatingActionButton(
              onClick = { onClick() },
              icon = { Icon(Icons.Filled.Edit, "Extended floating action button.") },
              text = { Text(text = "Extended FAB") },
          )
      }FloatingActionButton.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/fab-extended.png
      name: image-5
      :alt: An implementation of ExtendedFloatingActionButton that displays text
      that says 'extended button' and an edit icon.

      **Figure 5.** A floating action button with both text and an icon.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Common buttons  <#button>`__
   -  `Material UI docs <https://m3.material.io/components/floating-action-button/overview>`__

Last updated 2024-05-03 UTC.

/Card
=====

.. https://developer.android.google.cn/develop/ui/compose/components/card?hl=en

.. container:: devsite-article-body clearfix

   The
   `Card  <#Card>`__
   composable acts as a Material Design container for your UI. Cards typically
   present a single coherent piece of content. The following are some examples
   of where you might use a card:

   -  A product in a shopping app.
   -  A news story in a news app.
   -  A message in a communications app.

   It is the focus on portraying a single piece of content that distinguishes
   ``Card`` from other containers. For example, ``Scaffold`` provides general
   structure to a whole screen. Card is generally a smaller UI element inside a
   larger layout, whereas a layout component such as ``Column`` or ``Row``
   provides a simpler and more generic API.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/card.svg
      name: image-1
      :alt: An elevated card populated with text and icons.

      **Figure 1.** An example of a card populated with text and icons.

   .. rubric:: Basic implementation
      :name: basic

   ``Card`` behaves much like other containers in Compose. You declare its
   content by calling other composables within it. For example, consider how
   ``Card`` contains a call to ``Text`` in the following minimal example:

   .. code:: prettyprint

      @Composable
      fun CardMinimalExample() {
          Card() {
              Text(text = "Hello, world!")
          }
      }

   **Note:**\  By default, a ``Card`` wraps its content in a ``Column``
   composable, placing each item inside the card below one another.

   .. rubric:: Advanced implementations
      :name: advanced

   See the
   `reference  <#Card>`__
   for the API definition of ``Card``. It defines several parameters that allow
   you customize the appearance and behavior of the component.

   Some key parameters to note are the following:

   -  **``elevation``**: Adds a shadow to the component that makes it appear
      elevated above the background.
   -  **``colors``**: Uses the ``CardColors`` type to set the default color of
      both the container and any children.
   -  **``enabled``**: If you pass ``false`` for this parameter, the card
      appears as disabled and does not respond to user input.
   -  **``onClick``**: Ordinarily, a ``Card`` does not accept click events. As
      such, the primary overload you would like to note is that which defines an
      ``onClick`` parameter. You should use this overload if you would like your
      implementation of ``Card`` to respond to presses from the user.

   The following example demonstrates how you might use these parameters, as
   well as other common parameters such as ``shape`` and ``modifier``.

   **Beta:**\  The ``Card`` overload that defines the ``onClick`` parameter is
   experimental.

   .. rubric:: Filled card
      :name: filled

   The following is an example of how you can implement a filled card.

   The key here is the use of the ``colors`` property to change the filled
   color.

   .. code:: prettyprint

      @Composable
      fun FilledCardExample() {
          Card(
              colors = CardDefaults.cardColors(
                  containerColor = MaterialTheme.colorScheme.surfaceVariant,
              ),
              modifier = Modifier
                  .size(width = 240.dp, height = 100.dp)
          ) {
              Text(
                  text = "Filled",
                  modifier = Modifier
                      .padding(16.dp),
                  textAlign = TextAlign.Center,
              )
          }
      }Card.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/card-filled.png
      name: image-2
      :alt: A card is filled with the surface variant color from the material
      theme.

      **Figure 2.** Example of a filled card.

   .. rubric:: Elevated Card
      :name: elevated

   The following snippet demonstrates how to implement an elevated card. Use the
   dedicated
   `ElevatedCard  <#ElevatedCard>`__
   composable.

   You can use the ``elevation`` property to control the appearance of elevation
   and the resulting shadow.

   .. code:: prettyprint

      @Composable
      fun ElevatedCardExample() {
          ElevatedCard(
              elevation = CardDefaults.cardElevation(
                  defaultElevation = 6.dp
              ),
              modifier = Modifier
                  .size(width = 240.dp, height = 100.dp)
          ) {
              Text(
                  text = "Elevated",
                  modifier = Modifier
                      .padding(16.dp),
                  textAlign = TextAlign.Center,
              )
          }
      }Card.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/card-elevated.png
      name: image-3
      :alt: A card is elevated above the background of the app, with a shadow.

      **Figure 3.** Example of an elevated card.

   .. rubric:: Outlined Card
      :name: outlined

   The following is an example of an outlined card. Use the dedicated
   `OutlinedCard  <#OutlinedCard>`__
   composable.

   .. code:: prettyprint

      @Composable
      fun OutlinedCardExample() {
          OutlinedCard(
              colors = CardDefaults.cardColors(
                  containerColor = MaterialTheme.colorScheme.surface,
              ),
              border = BorderStroke(1.dp, Color.Black),
              modifier = Modifier
                  .size(width = 240.dp, height = 100.dp)
          ) {
              Text(
                  text = "Outlined",
                  modifier = Modifier
                      .padding(16.dp),
                  textAlign = TextAlign.Center,
              )
          }
      }Card.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/card-outlined.png
      name: image-4
      :alt: A card is outlined with a thin black border.

      **Figure 4.** Example of an outlined card.

   .. rubric:: Limitations
      :name: limitations

   Cards don't come with inherent scroll or dismiss actions, but can integrate
   into composables offering these features. For example, to implement swipe to
   dismiss on a card, integrate it with the
   `SwipeToDismiss  <#SwipeToDismiss>`__
   composable. To integrate with scroll, use scroll modifiers such as
   `verticalScroll  <#verticalScroll>`__.
   See the `Scroll documentation  <#scroll>`__ for
   more information.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Material UI docs <https://m3.material.io/components/cards/overview>`__

Last updated 2024-05-03 UTC.

/Chip
=====

.. https://developer.android.google.cn/develop/ui/compose/components/chip?hl=en

.. container:: devsite-article-body clearfix

   The ``Chip`` component is a compact, interactive UI element. It represents
   complex entities like a contact or tag, often with an icon and label. It can
   be checkable, dismissible, or clickable.

   The four types of chips and where you might use them are as follows:

   -  **Assist**: Guides the user during a task. Often appears as a temporary UI
      element in response to user input.
   -  **Filter**: Allows users to refine content from a set of options. They can
      be selected or deselected, and may include a checkmark icon when selected.
   -  **Input**: Represents user-provided information, such as selections in a
      menu. They can contain an icon and text, and provide an 'X' for removal.
   -  **Suggestion**: Provides recommendations to the user based on their recent
      activity or input. Typically appear beneath an input field to prompt user
      actions.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/chips.svg
      name: image-1
      :alt: An example of each of the four chip components, with their unique
      characteristics highlighted.
      :width: 100.0%

      **Figure 1.** The four chip components.

   .. rubric:: API surface
      :name: api

   There are four composables that correspond to the four types of chips. The
   following sections outline these composables and their differences in detail.
   However, they share the following parameters:

   -  **``label``**: The string that appears on the chip.
   -  **``icon``**: The icon displayed at the start of the chip. Some of the
      specific composables have a separate ``leadingIcon`` and ``trailingIcon``
      parameter.
   -  **``onClick``**: The lambda that the chip calls when the user presses it.

   .. rubric:: Assist chip
      :name: assist

   The
   `AssistChip  <#AssistChip>`__
   composable provides a straightforward way to create an assist chip that
   nudges the user in a particular direction. One distinguishing feature is its
   ``leadingIcon`` parameter that lets you display an icon on the left side of
   the chip. The following example demonstrates how you can implement it:

   .. code:: prettyprint

      @Composable
      fun AssistChipExample() {
          AssistChip(
              onClick = { Log.d("Assist chip", "hello world") },
              label = { Text("Assist chip") },
              leadingIcon = {
                  Icon(
                      Icons.Filled.Settings,
                      contentDescription = "Localized description",
                      Modifier.size(AssistChipDefaults.IconSize)
                  )
              }
          )
      }Chip.kt

   This implementation appears as follows.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/chip-assist.png
      name: image-2
      :alt: A simple assist chip.
      :width: 100.0%

      **Figure 2.** Assist chip.

   .. rubric:: Filter chip
      :name: filter

   The
   `FilterChip  <#FilterChip>`__
   composable requires you to track whether or not the chip is selected. The
   following example demonstrates how you can show a leading checked icon only
   when the user has selected the chip:

   .. code:: prettyprint

      @Composable
      fun FilterChipExample() {
          var selected by remember { mutableStateOf(false) }

          FilterChip(
              onClick = { selected = !selected },
              label = {
                  Text("Filter chip")
              },
              selected = selected,
              leadingIcon = if (selected) {
                  {
                      Icon(
                          imageVector = Icons.Filled.Done,
                          contentDescription = "Done icon",
                          modifier = Modifier.size(FilterChipDefaults.IconSize)
                      )
                  }
              } else {
                  null
              },
          )
      }Chip.kt

   This implementation appears as follows when unselected:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/chip-filter.png
      name: image-3
      :alt: An unselected filter chip, with no check and a plan background.
      :width: 100.0%

      **Figure 3.** Unselected filter chip.

   And appears as follows when selected:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/components/chip-filter-active.png
      name: image-4
      :alt: Selected filter chip, with a check and a coloured background.
      :width: 100.0%

      **Figure 4.** Selected filter chip.

   .. rubric:: Input chip
      :name: input

   You can use the
   `InputChip  <#InputChip>`__
   composable to create chips that result from user interaction. For example, in
   an email client, when the user is writing an email, an input chip might
   represent a person whose address the user has entered into the "to:" field.

   The following implementation demonstrates an input chip that is already in a
   selected state. The user dismisses the chip when they press it.

   **Note:**\  Consider how you might use a chip like this in the preceding
   email use case, with a name passed in for the ``text`` parameter, and a
   function that performs the necessary network calls for ``onDismiss``.
   .. code:: prettyprint

      @Composable
      fun InputChipExample(
          text: String,
          onDismiss: () -> Unit,
      ) {
          var enabled by remember { mutableStateOf(true) }
          if (!enabled) return

          InputChip(
              onClick = {
                  onDismiss()
                  enabled = !enabled
              },
              label = { Text(text) },
              selected = enabled,
              avatar = {
                  Icon(
                      Icons.Filled.Person,
                      contentDescription = "Localized description",
                      Modifier.size(InputChipDefaults.AvatarSize)
                  )
              },
              trailingIcon = {
                  Icon(
                      Icons.Default.Close,
                      contentDescription = "Localized description",
                      Modifier.size(InputChipDefaults.AvatarSize)
                  )
              },
          )
      }Chip.kt

   This implementation appears as follows.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/chip-input.png
      name: image-5
      :alt: An input chip with an avatar and a trailing icon.
      :width: 100.0%

      **Figure 5.** Input chip.

   .. rubric:: Suggestion chip
      :name: suggestion

   The
   `SuggestionChip  <#SuggestionChip>`__
   composable is the most basic of the composables listed on this page, both in
   its API definition and its common use cases. Suggestion chips present
   dynamically generated hints. For example, in an AI chat app, you might use
   suggestion chips to present possible responses to the most recent message.

   Consider this implementation of ``SuggestionChip``:

   .. code:: prettyprint

      @Composable
      fun SuggestionChipExample() {
          SuggestionChip(
              onClick = { Log.d("Suggestion chip", "hello world") },
              label = { Text("Suggestion chip") }
          )
      }Chip.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/chip-suggestion.png
      name: image-6
      :alt: A simple assist chip.
      :width: 100.0%

      **Figure 6.** Assist chip.

   **Note:**\  Although the suggestion chip component is intended for
   informational purposes, it does still take an ``onClick`` lambda that you can
   use to create interactivity.

   .. rubric:: Elevated chip
      :name: elevated

   All the examples in this document use the base composables that take a flat
   appearance. If you want a chip that has an elevated appearance, use one of
   the three following composables:

   -  `ElevatedAssistChip  <#ElevatedAssistChip>`__
   -  `ElevatedFilterChip  <#ElevatedFilterChip>`__
   -  `ElevatedSuggestionChip  <#ElevatedSuggestionChip>`__

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Material UI docs <https://m3.material.io/components/chips/overview>`__

Last updated 2024-05-03 UTC.

/Dialog
=======

.. https://developer.android.google.cn/develop/ui/compose/components/dialog?hl=en

.. container:: devsite-article-body clearfix

   The
   `Dialog  <#Dialog>`__
   component displays pop up messages or requests user input on a layer above
   the main app content. It creates an interruptive UI experience to capture
   user attention.

   Among the use cases for a dialog are the following:

   -  Confirming user action, such as when deleting a file.
   -  Requesting user input, such as in a to-do list app.
   -  Presenting a list of options for user selection, like choosing a country
      in a profile setup.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/dialog.svg
      name: image-1
      :alt: A dialog populated with text and icons.

      **Figure 1.** An example of a dialog populated with text and icons.

   .. rubric:: Alert dialog
      :name: alert

   The
   `AlertDialog  <#AlertDialog>`__
   composable provides a convenient API for creating a Material Design themed
   dialog. ``AlertDialog`` has specific parameters for handling particular
   elements of the dialog. Among them are the following:

   -  ``title``: The text that appears along the top of the dialog.
   -  ``text``: The text that appears centered within the dialog.
   -  ``icon``: The graphic that appears at the top of the dialog.
   -  ``onDismissRequest``: The function called when the user dismisses the
      dialog, such as by tapping outside of it.
   -  ``dismissButton``: A composable that serves as the dismiss button.
   -  ``confirmButton``: A composable that serves as the confirm button.

   The following example implements two buttons in an alert dialog, one that
   dismisses the dialog, and another that confirms its request.

   .. code:: prettyprint

      @OptIn(ExperimentalMaterial3Api::class)
      @Composable
      fun AlertDialogExample(
          onDismissRequest: () -> Unit,
          onConfirmation: () -> Unit,
          dialogTitle: String,
          dialogText: String,
          icon: ImageVector,
      ) {
          AlertDialog(
              icon = {
                  Icon(icon, contentDescription = "Example Icon")
              },
              title = {
                  Text(text = dialogTitle)
              },
              text = {
                  Text(text = dialogText)
              },
              onDismissRequest = {
                  onDismissRequest()
              },
              confirmButton = {
                  TextButton(
                      onClick = {
                          onConfirmation()
                      }
                  ) {
                      Text("Confirm")
                  }
              },
              dismissButton = {
                  TextButton(
                      onClick = {
                          onDismissRequest()
                      }
                  ) {
                      Text("Dismiss")
                  }
              }
          )
      }Dialog.kt

   This implementation implies a parent composable that passes arguments to the
   child composable in this way:

   .. code:: prettyprint

      @Composable
      fun DialogExamples() {
          // ...
          val openAlertDialog = remember { mutableStateOf(false) }

          // ...
              when {
                  // ...
                  openAlertDialog.value -> {
                      AlertDialogExample(
                          onDismissRequest = { openAlertDialog.value = false },
                          onConfirmation = {
                              openAlertDialog.value = false
                              println("Confirmation registered") // Add logic here to handle confirmation.
                          },
                          dialogTitle = "Alert dialog example",
                          dialogText = "This is an example of an alert dialog with buttons.",
                          icon = Icons.Default.Info
                      )
                  }
              }
          }
      }Dialog.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/dialog-alert.png
      name: image-2
      :alt: An open alert dialog that has both a dismiss and confirm button.

      **Figure 2.** An alert dialog with buttons.

   **Note:**\  When the user clicks either of the buttons, the dialog closes.
   When the user clicks confirm, it calls a function that also handles the
   confirmation. In this example, those functions are ``onDismissRequest()`` and
   ``onConfirmRequest()``.
   **Note:**\  In cases where your dialog requires a more complex set of
   buttons, you may benefit from using the ``Dialog`` composable and populating
   it in a more freeform manner.

   .. rubric:: Dialog composable
      :name: dialog-composable

   `Dialog  <#Dialog>`__
   is a basic composable that doesn't provide any styling or predefined slots
   for content. It is a relatively straightforward container that you should
   populate with a container such as ``Card``. The following are some of the key
   parameters of a dialog:

   -  **``onDismissRequest``**: The lambda called when the user closes the
      dialog.
   -  **``properties``**: An instance of
      `DialogProperties  <#DialogProperties>`__
      that provides some additional scope for customization.

   **Caution:**\  Unlike the example of ``AlertDialog`` in the preceding
   section, you need to manually specify the size and shape of ``Dialog``. You
   also need to provide an inner container.

   .. rubric:: Basic example
      :name: basic

   The following example is a basic implementation of the ``Dialog`` composable.
   Note that it uses a ``Card`` as the secondary container. Without the
   ``Card``, the ``Text`` component would appear alone above the main app
   content.

   .. code:: prettyprint

      @Composable
      fun MinimalDialog(onDismissRequest: () -> Unit) {
          Dialog(onDismissRequest = { onDismissRequest() }) {
              Card(
                  modifier = Modifier
                      .fillMaxWidth()
                      .height(200.dp)
                      .padding(16.dp),
                  shape = RoundedCornerShape(16.dp),
              ) {
                  Text(
                      text = "This is a minimal dialog",
                      modifier = Modifier
                          .fillMaxSize()
                          .wrapContentSize(Alignment.Center),
                      textAlign = TextAlign.Center,
                  )
              }
          }
      }Dialog.kt

   This implementation appears as follows. Note that when the dialog is open,
   the main app content beneath it appears darkened and grayed out:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/dialog-minimal.png
      name: image-3
      :alt: A dialog that contains nothing other than a label.

      **Figure 3.** Minimal dialog.

   .. rubric:: Advanced example
      :name: advanced

   The following is a more advanced implemented of the ``Dialog`` composable. In
   this case, the component manually implements a similar interface to the
   ``AlertDialog`` example above.

   **Caution:**\  If you only need to display a two-button dialog as in this
   example, you should use ``AlertDialog`` and its more convenient API. However,
   if you want to create a more complex dialog, perhaps with forms and multiple
   buttons, you should use ``Dialog`` with custom content, as in the following
   example.
   .. code:: prettyprint

      @Composable
      fun DialogWithImage(
          onDismissRequest: () -> Unit,
          onConfirmation: () -> Unit,
          painter: Painter,
          imageDescription: String,
      ) {
          Dialog(onDismissRequest = { onDismissRequest() }) {
              // Draw a rectangle shape with rounded corners inside the dialog
              Card(
                  modifier = Modifier
                      .fillMaxWidth()
                      .height(375.dp)
                      .padding(16.dp),
                  shape = RoundedCornerShape(16.dp),
              ) {
                  Column(
                      modifier = Modifier
                          .fillMaxSize(),
                      verticalArrangement = Arrangement.Center,
                      horizontalAlignment = Alignment.CenterHorizontally,
                  ) {
                      Image(
                          painter = painter,
                          contentDescription = imageDescription,
                          contentScale = ContentScale.Fit,
                          modifier = Modifier
                              .height(160.dp)
                      )
                      Text(
                          text = "This is a dialog with buttons and an image.",
                          modifier = Modifier.padding(16.dp),
                      )
                      Row(
                          modifier = Modifier
                              .fillMaxWidth(),
                          horizontalArrangement = Arrangement.Center,
                      ) {
                          TextButton(
                              onClick = { onDismissRequest() },
                              modifier = Modifier.padding(8.dp),
                          ) {
                              Text("Dismiss")
                          }
                          TextButton(
                              onClick = { onConfirmation() },
                              modifier = Modifier.padding(8.dp),
                          ) {
                              Text("Confirm")
                          }
                      }
                  }
              }
          }
      }Dialog.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/dialog-image.png
      name: image-4
      :alt: A dialog with a photo of Mount Feathertop, Victoria. Below the image
      are a dismiss button and a confirm button.

      **Figure 4.** A dialog that includes an image.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Material UI docs <https://m3.material.io/components/dialogs/overview>`__

Last updated 2024-05-03 UTC.

/Progress indicators
====================

.. https://developer.android.google.cn/develop/ui/compose/components/progress?hl=en

.. container:: devsite-article-body clearfix

   Progress indicators visually surface the status of an operation. They use
   motion to bring to the user's attention how near completion the process is,
   such as loading or processing data. They can also signify that processing is
   taking place, without reference to how close to completion it might be.

   Consider these three use cases where you might use a progress indicator:

   -  **Loading content**: While fetching content from a network, such as
      loading an image or data for a user profile.
   -  **File upload**: Give the user feedback on how long the upload might take.
   -  **Long processing**: While an app is processing a large amount of data,
      convey to the user how much of the total is complete.

   In Material Design, there are two types of progress indicator:

   -  **Determinate**: Displays exactly how much progress has been made.
   -  **Indeterminate**: Animates continually without regard to progress.

   Likewise, a progress indicator can take one of the two following forms:

   -  **Linear**: A horizontal bar that fills from left to right.
   -  **Circular**: A circle whose stroke grows in length until it encompasses
      the full circumference of the circle.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/components/progress-indicators.svg
      name: image-1
      :alt: A linear progress indicator alongside a circular progress indicator.
      :width: 100.0%

      **Figure 1.** The two types of progress indicators.

   .. rubric:: API Surface
      :name: api

   Although there are several composables you can use to create floating action
   buttons consistent with Material Design, their parameters don't differ
   greatly. Among the key parameters you should keep in mind are the following:

   -  ``progress``: The current progress that the indicator displays. Pass a
      ``Float`` between ``0.0`` and ``1.0``.
   -  ``color``: The color of the actual indicator. That is, the part of the
      component that reflects progress and which fully encompasses the component
      when progress is complete.
   -  ``trackColor``: The color of the track over which the indicator is drawn.

   **Note:**\  The APIs for ``LinearProgressIndicator`` and
   ``CircularProgressIndicator`` are essentially the same and the way you use
   either one is identical. You can use the following snippets for either.

   .. rubric:: Determinate indicators
      :name: determinate

   A determinate indicator reflects exactly how complete an action is. Use
   either the
   `LinearProgressIndicator  <#LinearProgressIndicator>`__
   or
   `CircularProgressIndicator  <#CircularProgressIndicator>`__
   composables and pass a value for the ``progress`` parameter.

   The following snippet provides a relatively detailed example. When the user
   presses the button, the app both displays the progress indicator, and
   launches a coroutine that gradually increases the value of ``progress``. This
   causes the progress indicator to iterate up in turn.

   **Note:**\  The following example uses a coroutine to do the work of
   iterating the ``progress`` value because it would otherwise block the UI
   thread.
   .. code:: prettyprint

      @Composable
      fun LinearDeterminateIndicator() {
          var currentProgress by remember { mutableStateOf(0f) }
          var loading by remember { mutableStateOf(false) }
          val scope = rememberCoroutineScope() // Create a coroutine scope

          Column(
              verticalArrangement = Arrangement.spacedBy(12.dp),
              horizontalAlignment = Alignment.CenterHorizontally,
              modifier = Modifier.fillMaxWidth()
          ) {
              Button(onClick = {
                  loading = true
                  scope.launch {
                      loadProgress { progress ->
                          currentProgress = progress
                      }
                      loading = false // Reset loading when the coroutine finishes
                  }
              }, enabled = !loading) {
                  Text("Start loading")
              }

              if (loading) {
                  LinearProgressIndicator(
                      progress = { currentProgress },
                      modifier = Modifier.fillMaxWidth(),
                  )
              }
          }
      }

      /** Iterate the progress value */
      suspend fun loadProgress(updateProgress: (Float) -> Unit) {
          for (i in 1..100) {
              updateProgress(i.toFloat() / 100)
              delay(100)
          }
      }ProgressIndicator.kt

   When loading is partially complete, the linear indicator in the preceding
   example appears as follows:

   Likewise, the circular indicator appears as follows:

   .. rubric:: Indeterminate indicators
      :name: indeterminate

   An indeterminate indicator does not reflect how close to completion an
   operation is. Rather, it uses motion to indicate to the user that processing
   is ongoing, though without specifying any degree of completion.

   To create an indeterminate progress indicator, use the
   ``LinearProgressIndicator`` or ``CircularProgressIndicator`` composable, but
   don't pass in a value for ``progress``. The following example demonstrates
   how you can toggle an indeterminate indicator with a button press.

   **Note:**\  This example also demonstrates how you can pass values for the
   ``color`` and ``trackColor`` parameters to customize the appearance of the
   indicator.
   .. code:: prettyprint

      @Composable
      fun IndeterminateCircularIndicator() {
          var loading by remember { mutableStateOf(false) }

          Button(onClick = { loading = true }, enabled = !loading) {
              Text("Start loading")
          }

          if (!loading) return

          CircularProgressIndicator(
              modifier = Modifier.width(64.dp),
              color = MaterialTheme.colorScheme.secondary,
              trackColor = MaterialTheme.colorScheme.surfaceVariant,
          )
      }ProgressIndicator.kt

   The following is an example of this implementation when the indicator is
   active:

   The following is an example of the same implementation but with
   ``LinearProgressIndicator`` instead of ``CircularProgressIndicator``.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Material UI docs <https://m3.material.io/components/progress-indicators/overview>`__

Last updated 2024-05-03 UTC.

/Slider
=======

.. https://developer.android.google.cn/develop/ui/compose/components/slider?hl=en

.. container:: devsite-article-body clearfix

   The
   `Slider  <#Slider>`__
   composable allows users to make selections from a range of values. You might
   use a slider to let the user do the following:

   -  Adjust settings that use a range of values, such as volume, and
      brightness.
   -  Filter data in a graph, as when setting a price range.
   -  User input, like setting a rating in a review.

   The slider contains a track, thumb, value label, and tick marks:

   -  **Track**: The track is the horizontal bar that represents the range of
      values the slider can take.
   -  **Thumb**: The thumb is a draggable control element on the slider that
      allows the user to select a specific value within the range defined by the
      track.
   -  **Tick marks**: Tick marks are optional visual markers or indicators that
      appear along the track of the slider.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/slider.png
      name: image-1
      :alt: A slider with thumb, track and tick marks.
      :width: 100.0%

      **Figure 1.** An implementation of a slider.

   .. rubric:: Basic implementation
      :name: basic-implementation

   See the
   `Slider  <#Slider>`__
   reference for a full API definition. Some of the key parameters for the
   ``Slider`` composable are the following:

   -  **``value``**: The current value of the slider.
   -  **``onValueChange``**: A lambda that gets called every time the value is
      changed.
   -  **``enabled``**: A boolean value that indicates if the user can interact
      with the slider.

   The following example is a straightforward slider. That allows the user to
   select a value from ``0.0`` to ``1.0``. Because the user can select any value
   in that range, the slider is *continuous*.

   .. code:: prettyprint

      @Preview
      @Composable
      fun SliderMinimalExample() {
          var sliderPosition by remember { mutableFloatStateOf(0f) }
          Column {
              Slider(
                  value = sliderPosition,
                  onValueChange = { sliderPosition = it }
              )
              Text(text = sliderPosition.toString())
          }
      }Slider.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/slider-basic.png
      name: image-2
      :alt: A slider component with a value selected roughly three quarters
      along the track.
      :width: 80.0%

      **Figure 2.** A basic implementation of a slider.

   .. rubric:: Advanced implementation
      :name: advanced-implementation

   When implementing a more complex slider, you can additionally make use of the
   following parameters.

   -  **``colors``**: An instance of ``SliderColors`` that lets you control the
      colors of the slider.
   -  **``valueRange``**: The range of values that the slider can take.
   -  **``steps``**: The number of notches on the slider to which the thumb
      snaps.

   The following snippet implements a slider that has three steps, with a range
   from ``0.0`` to ``50.0``. Because the thumb snaps to each step, this slider
   is *discrete*.

   .. code:: prettyprint

      @Preview
      @Composable
      fun SliderAdvancedExample() {
          var sliderPosition by remember { mutableFloatStateOf(0f) }
          Column {
              Slider(
                  value = sliderPosition,
                  onValueChange = { sliderPosition = it },
                  colors = SliderDefaults.colors(
                      thumbColor = MaterialTheme.colorScheme.secondary,
                      activeTrackColor = MaterialTheme.colorScheme.secondary,
                      inactiveTrackColor = MaterialTheme.colorScheme.secondaryContainer,
                  ),
                  steps = 3,
                  valueRange = 0f..50f
              )
              Text(text = sliderPosition.toString())
          }
      }Slider.kt

   The implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/slider-advanced.png
      name: image-3
      :alt: Write your alt text here
      :width: 80.0%

      **Figure 3.** A slider with steps and a set value range.

   **Note:**\  The very beginning and end of a slider count as "steps". In the
   preceding example where the range is ``0f..50f`` and the number of ``steps``
   is ``3``, each interval along the range is ``12.5`` because the beginning and
   end of the slider are also intervals the user can select.
   **Note:**\  You can also pass ``Slider`` a ``thumb`` and ``track`` composable
   to more thoroughly customize the appearance of the component.

   .. rubric:: Range slider
      :name: range-slider

   You can also use the dedicated ``RangeSlider`` composable. This allows the
   user to select two values. This can be useful in cases such as when the user
   wishes to select a minimum and maximum price.

   The following example is a relatively straightforward example of a continuous
   range slider.

   .. code:: prettyprint

      @Preview
      @Composable
      fun RangeSliderExample() {
          var sliderPosition by remember { mutableStateOf(0f..100f) }
          Column {
              RangeSlider(
                  value = sliderPosition,
                  steps = 5,
                  onValueChange = { range -> sliderPosition = range },
                  valueRange = 0f..100f,
                  onValueChangeFinished = {
                      // launch some business logic update with the state you hold
                      // viewModel.updateSelectedSliderValue(sliderPosition)
                  },
              )
              Text(text = sliderPosition.toString())
          }
      }Slider.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/slider-range.png
      name: image-4
      :alt: A range slider component with two values selected. A label displays
      the upper and lower bounds of the selection.
      :width: 80.0%

      **Figure 4.** An implementation of a range slider.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Material UI docs <https://m3.material.io/components/sliders/overview>`__

Last updated 2024-05-03 UTC.

/Switch
=======

.. https://developer.android.google.cn/develop/ui/compose/components/switch?hl=en

.. container:: devsite-article-body clearfix

   The
   `Switch  <#Switch>`__
   component allows users to toggle between two states: checked and unchecked.
   In your app you may use a switch to let the user to do one of the following:

   -  Toggle a setting on or off.
   -  Enable or disable a feature.
   -  Select an option.

   The component has two parts: the thumb and the track. The thumb is the
   draggable part of the switch, and the track is the background. The user can
   drag the thumb to the left or right to change the state of the switch. They
   can also tap the switch to check and clear it.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/switches.png
      name: image-1
      :alt: Examples of the Switch component in both light and dark mode.
      :width: 100.0%

      **Figure 1.** The switch component.

   .. rubric:: Basic implementation
      :name: basic

   See the
   `Switch  <#Switch>`__
   reference for a full API definition. The following are some of the key
   parameters you might need to use:

   -  **``checked``**: The initial state of the switch.
   -  **``onCheckedChange``**: A callback that is called when the state of the
      switch changes.
   -  **``enabled``**: Whether the switch is enabled or disabled.
   -  **``colors``**: The colors used for the switch.

   The following example is a minimal implementation of the ``Switch``
   composable.

   .. code:: prettyprint

      @Composable
      fun SwitchMinimalExample() {
          var checked by remember { mutableStateOf(true) }

          Switch(
              checked = checked,
              onCheckedChange = {
                  checked = it
              }
          )
      }Switch.kt

   This implementation appears as follows when unchecked:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/components/switch-deactivated.png
      name: image-2
      :alt: A basic switch that is unchecked.

      **Figure 2.** An unchecked switch.

   This is the appearance when checked:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/switch.png
      name: image-3
      :alt: A basic Switch that is checked.

      **Figure 3.** A checked switch.

   .. rubric:: Advanced implementation
      :name: advanced

   The primary parameters you might want to use when implementing a more
   advanced switch are the following:

   -  **``thumbContent``**: Use this to customize the appearance of the thumb
      when it is checked.
   -  **``colors``**: Use this to customize the color of the track and thumb.

   .. rubric:: Custom thumb
      :name: thumb

   You can pass any composable for the ``thumbContent`` parameter to create a
   custom thumb. The following is an example of a switch that uses a custom icon
   for its thumb:

   .. code:: prettyprint

      @Composable
      fun SwitchWithIconExample() {
          var checked by remember { mutableStateOf(true) }

          Switch(
              checked = checked,
              onCheckedChange = {
                  checked = it
              },
              thumbContent = if (checked) {
                  {
                      Icon(
                          imageVector = Icons.Filled.Check,
                          contentDescription = null,
                          modifier = Modifier.size(SwitchDefaults.IconSize),
                      )
                  }
              } else {
                  null
              }
          )
      }Switch.kt

   In this implementation, the unchecked appearance is the same as the example
   in the preceding section. However, when checked, this implementation appears
   as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/switch-icon.png
      name: image-4
      :alt: A switch that uses the thumbContent parameter to display a custom
      icon when checked.

      **Figure 4.** A switch with a custom checked icon.

   .. rubric:: Custom colors
      :name: colors

   The following example demonstrates how you can use the colors parameter to
   change the color of a switch's thumb and track, taking into account whether
   the switch is checked.

   .. code:: prettyprint

      @Composable
      fun SwitchWithCustomColors() {
          var checked by remember { mutableStateOf(true) }

          Switch(
              checked = checked,
              onCheckedChange = {
                  checked = it
              },
              colors = SwitchDefaults.colors(
                  checkedThumbColor = MaterialTheme.colorScheme.primary,
                  checkedTrackColor = MaterialTheme.colorScheme.primaryContainer,
                  uncheckedThumbColor = MaterialTheme.colorScheme.secondary,
                  uncheckedTrackColor = MaterialTheme.colorScheme.secondaryContainer,
              )
          )
      }Switch.kt

   This implementation appears as follows:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/components/switch-colors.png
      name: image-5
      :alt: A switch that uses the colors parameter to display a switch with
      custom colors for both the thumb and tack.

      **Figure 5.** A switch with custom colors.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Material UI docs <https://m3.material.io/components/switch/overview>`__

Last updated 2024-05-03 UTC.

/Bottom sheets
==============

.. https://developer.android.google.cn/develop/ui/compose/components/bottom-sheets?hl=en

.. container:: devsite-article-body clearfix

   |image-m3-bottom-sheet|

   If you want to implement a `bottom sheet <https://m3.material.io/components/bottom-sheets/overview>`__, you can
   use the
   `ModalBottomSheet  <#ModalBottomSheet>`__
   composable.

   You can use the ``content`` slot, which uses a
   `ColumnScope  <#ColumnScope>`__
   to layout sheet content composables in a column:

   .. code:: prettyprint

      ModalBottomSheet(onDismissRequest = { /* Executed when the sheet is dismissed */ }) {
          // Sheet content
      }MaterialLayoutSnippets.kt

   Programmatically expanding and collapsing the sheet is done using
   `SheetState  <#SheetState>`__.
   You can use
   `rememberSheetState  <#rememberSheetState>`__
   to create an instance of ``SheetState`` that should be passed to
   ``ModalBottomSheet`` with the ``sheetState`` parameter. ``SheetState``
   provides access to the
   `show  <#show>`__
   and
   `hide  <#hide>`__
   functions, as well as properties related to the current sheet state. These
   suspending functions require a ``CoroutineScope`` — for example, using
   `rememberCoroutineScope  <#remembercoroutinescope>`__
   — and can be called in response to UI events. Make sure to remove the
   ``ModalBottomSheet`` from composition upon hiding the bottom sheet.

   .. code:: prettyprint

      val sheetState = rememberModalBottomSheetState()
      val scope = rememberCoroutineScope()
      var showBottomSheet by remember { mutableStateOf(false) }
      Scaffold(
          floatingActionButton = {
              ExtendedFloatingActionButton(
                  text = { Text("Show bottom sheet") },
                  icon = { Icon(Icons.Filled.Add, contentDescription = "") },
                  onClick = {
                      showBottomSheet = true
                  }
              )
          }
      ) { contentPadding ->
          // Screen content

          if (showBottomSheet) {
              ModalBottomSheet(
                  onDismissRequest = {
                      showBottomSheet = false
                  },
                  sheetState = sheetState
              ) {
                  // Sheet content
                  Button(onClick = {
                      scope.launch { sheetState.hide() }.invokeOnCompletion {
                          if (!sheetState.isVisible) {
                              showBottomSheet = false
                          }
                      }
                  }) {
                      Text("Hide bottom sheet")
                  }
              }
          }
      }MaterialLayoutSnippets.kt

   |image-modal_bottom_sheet|

Last updated 2024-05-03 UTC.

.. |image-m3-bottom-sheet| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/material/m3-bottom-sheet.png
.. |image-modal_bottom_sheet| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/material/modal_bottom_sheet.png

/Navigation drawer
==================

.. https://developer.android.google.cn/develop/ui/compose/components/drawer?hl=en

.. container:: devsite-article-body clearfix

   The `navigation drawer <https://material.io/components/navigation-drawer>`__
   component is a slide-in menu that lets users navigate to various sections of
   your app. Users can activate it by swiping from the side or tapping a menu
   icon.

   Consider these three use cases for implementing a Navigation Drawer:

   -  **Content organization:** Enable users to switch between different
      categories, such as in news or blogging apps.
   -  **Account management:** Provide quick links to account settings and
      profile sections in apps with user accounts.
   -  **Feature discovery:** Organize multiple features and settings in a single
      menu to facilitate user discovery and access in complex apps.

   In Material Design, there are two types of navigation drawers:

   -  **Standard:** Share space within a screen with other content.
   -  **Modal:** Appears over the top of other content within a screen.

   |image-m3-navigation-drawer|

   .. rubric:: Example
      :name: example

   You can use the
   `ModalNavigationDrawer  <#ModalNavigationDrawer>`__
   composable to implement a navigation drawer.

   Use the ``drawerContent`` slot to provide a
   `ModalDrawerSheet  <#ModalDrawerSheet>`__
   and provide the drawer's contents, as in the following example:

   .. code:: prettyprint

      ModalNavigationDrawer(
          drawerContent = {
              ModalDrawerSheet {
                  Text("Drawer title", modifier = Modifier.padding(16.dp))
                  Divider()
                  NavigationDrawerItem(
                      label = { Text(text = "Drawer Item") },
                      selected = false,
                      onClick = { /*TODO*/ }
                  )
                  // ...other drawer items
              }
          }
      ) {
          // Screen content
      }MaterialLayoutSnippets.kt

   ``ModalNavigationDrawer`` accepts a number of additional drawer parameters.
   For example, you can toggle whether or not the drawer responds to drags with
   the ``gesturesEnabled`` parameter as in the following example:

   .. code:: prettyprint

      ModalNavigationDrawer(
          drawerContent = {
              ModalDrawerSheet {
                  // Drawer contents
              }
          },
          gesturesEnabled = false
      ) {
          // Screen content
      }MaterialLayoutSnippets.kt

   .. rubric:: Control behavior
      :name: control

   To control how the drawer opens and closes, use
   `DrawerState  <#DrawerState>`__.
   You should pass a ``DrawerState`` to ``ModalNavigationDrawer`` using the
   ``drawerState`` parameter.

   ``DrawerState`` provides access to the
   `open  <#open>`__
   and
   `close  <#close>`__
   functions, as well as properties related to the current drawer state. These
   suspending functions require a ``CoroutineScope``, which you can instantiate
   using
   `rememberCoroutineScope  <#remembercoroutinescope>`__.
   You can also call the suspending functions in response to UI events.

   .. code:: prettyprint

      val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)
      val scope = rememberCoroutineScope()
      ModalNavigationDrawer(
          drawerState = drawerState,
          drawerContent = {
              ModalDrawerSheet { /* Drawer content */ }
          },
      ) {
          Scaffold(
              floatingActionButton = {
                  ExtendedFloatingActionButton(
                      text = { Text("Show drawer") },
                      icon = { Icon(Icons.Filled.Add, contentDescription = "") },
                      onClick = {
                          scope.launch {
                              drawerState.apply {
                                  if (isClosed) open() else close()
                              }
                          }
                      }
                  )
              }
          ) { contentPadding ->
              // Screen content
          }
      }MaterialLayoutSnippets.kt

Last updated 2024-05-03 UTC.

.. |image-m3-navigation-drawer| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/material/m3-navigation-drawer.png

/Snackbar
=========

.. https://developer.android.google.cn/develop/ui/compose/components/snackbar?hl=en

.. container:: devsite-article-body clearfix

   The `snackbar component <https://material.io/components/snackbars>`__ serves
   as a brief notification that appears at the bottom of the screen. It provides
   feedback about an operation or action without interrupting the user
   experience. Snackbars disappear after a few seconds. The user can also
   dismiss them with an action, such as tapping a button.

   Consider these three use cases where you might use a snackbar:

   -  **Action Confirmation:** After a user deletes an email or message, a
      snackbar appears to confirm the action and offer an "Undo" option.
   -  **Network Status:** When the app loses its internet connection, a snackbar
      pops up to note that it is now offline.
   -  **Data Submission:** Upon successfully submitting a form or updating
      settings, a snackbar notes that the change has saved successfully.

   |image-m3-snackbar|

   .. rubric:: Basic example
      :name: basic_example

   To implement a snackbar, you first create
   `SnackbarHost  <#SnackbarHost>`__,
   which includes a
   `SnackbarHostState  <#SnackbarHostState>`__
   property. ``SnackbarHostState`` provides access to the
   `showSnackbar()  <#showsnackbar>`__
   function which you can use to display your snackbar.

   This suspending function requires a ``CoroutineScope`` such as with using
   `rememberCoroutineScope  <#remembercoroutinescope>`__
   — and can be called in response to UI events to show a
   `Snackbar  <#snackbar>`__
   within ``Scaffold``.

   .. code:: prettyprint

      val scope = rememberCoroutineScope()
      val snackbarHostState = remember { SnackbarHostState() }
      Scaffold(
          snackbarHost = {
              SnackbarHost(hostState = snackbarHostState)
          },
          floatingActionButton = {
              ExtendedFloatingActionButton(
                  text = { Text("Show snackbar") },
                  icon = { Icon(Icons.Filled.Image, contentDescription = "") },
                  onClick = {
                      scope.launch {
                          snackbarHostState.showSnackbar("Snackbar")
                      }
                  }
              )
          }
      ) { contentPadding ->
          // Screen content
      }MaterialLayoutSnippets.kt

   .. rubric:: Snackbar with action
      :name: snackbar_with_action

   You can provide an optional action and adjust the duration of the
   ``Snackbar``. The ``snackbarHostState.showSnackbar()`` function accepts
   additional ``actionLabel`` and ``duration`` parameters, and returns a
   `SnackbarResult  <#SnackbarResult>`__.

   .. code:: prettyprint

      val scope = rememberCoroutineScope()
      val snackbarHostState = remember { SnackbarHostState() }
      Scaffold(
          snackbarHost = {
              SnackbarHost(hostState = snackbarHostState)
          },
          floatingActionButton = {
              ExtendedFloatingActionButton(
                  text = { Text("Show snackbar") },
                  icon = { Icon(Icons.Filled.Image, contentDescription = "") },
                  onClick = {
                      scope.launch {
                          val result = snackbarHostState
                              .showSnackbar(
                                  message = "Snackbar",
                                  actionLabel = "Action",
                                  // Defaults to SnackbarDuration.Short
                                  duration = SnackbarDuration.Indefinite
                              )
                          when (result) {
                              SnackbarResult.ActionPerformed -> {
                                  /* Handle snackbar action performed */
                              }
                              SnackbarResult.Dismissed -> {
                                  /* Handle snackbar dismissed */
                              }
                          }
                      }
                  }
              )
          }
      ) { contentPadding ->
          // Screen content
      }MaterialLayoutSnippets.kt

   You can provide a custom ``Snackbar`` with the ``snackbarHost`` parameter.
   See the `SnackbarHost API reference
   docs  <#snackbarhost>`__
   for more information.

Last updated 2024-05-03 UTC.

.. |image-m3-snackbar| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/material/m3-snackbar.png

/Lists and grids
================

.. https://developer.android.google.cn/develop/ui/compose/lists?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   Many apps need to display collections of items. This document explains how
   you can efficiently do this in Jetpack Compose.

   If you know that your use case does not require any scrolling, you may wish
   to use a simple
   `Column  <#Column>`__
   or
   `Row  <#Row>`__
   (depending on the direction), and emit each item’s content by iterating over
   a list like so:

   .. code:: prettyprint

      @Composable
      fun MessageList(messages: List<Message>) {
          Column {
              messages.forEach { message ->
                  MessageRow(message)
              }
          }
      }LazyListSnippets.kt

   We can make the
   `Column  <#Column>`__
   scrollable by using the ``verticalScroll()`` modifier. See the
   `Gestures  <#gestures>`__ documentation for more
   information.

   .. rubric:: Lazy lists
      :name: lazy

   If you need to display a large number of items (or a list of an unknown
   length), using a layout such as
   `Column  <#Column>`__
   can cause performance issues, since all the items will be composed and laid
   out whether or not they are visible.

   Compose provides a set of components which only compose and lay out items
   which are visible in the component’s viewport. These components include
   `LazyColumn  <#LazyColumn>`__
   and
   `LazyRow  <#LazyRow>`__.

   **Note:**\  If you've used the `RecyclerView widget  <#recyclerview>`__, these components follow the
   same set of principles.
   As the name suggests, the difference between
   `LazyColumn  <#LazyColumn>`__
   and
   `LazyRow  <#LazyRow>`__
   is the orientation in which they lay out their items and scroll.
   `LazyColumn  <#LazyColumn>`__
   produces a vertically scrolling list, and
   `LazyRow  <#LazyRow>`__
   produces a horizontally scrolling list.

   The Lazy components are different to most layouts in Compose. Instead of
   accepting a ``@Composable`` content block parameter, allowing apps to
   directly emit composables, the Lazy components provide a ``LazyListScope.()``
   block. This
   `LazyListScope  <#LazyListScope>`__
   block offers a DSL which allows apps to *describe* the item contents. The
   Lazy component is then responsible for adding the each item’s content as
   required by the layout and scroll position.

   **Key Term:**\  *DSL* stands for **domain-specific language**. See the
   `Kotlin for Compose  <#dsl>`__ documentation for
   more information on how Compose defines DSLs for some APIs.

   .. rubric:: ``LazyListScope`` DSL
      :name: lazylistscope

   The DSL of
   `LazyListScope  <#LazyListScope>`__
   provides a number of functions for describing items in the layout. At the
   most basic,
   `item()  <#item>`__
   adds a single item, and
   `items(Int)  <#items>`__
   adds multiple items:

   .. code:: prettyprint

      LazyColumn {
          // Add a single item
          item {
              Text(text = "First item")
          }

          // Add 5 items
          items(5) { index ->
              Text(text = "Item: $index")
          }

          // Add another single item
          item {
              Text(text = "Last item")
          }
      }LazyListSnippets.kt

   There are also a number of extension functions which allow you to add
   collections of items, such as a ``List``. These extensions allow us to easily
   migrate our
   `Column  <#Column>`__
   example from above:

   .. code:: prettyprint

      /**
       * import androidx.compose.foundation.lazy.items
       */
      LazyColumn {
          items(messages) { message ->
              MessageRow(message)
          }
      }LazyListSnippets.kt

   There is also a variant of the
   `items()  <#items>`__
   extension function called
   `itemsIndexed()  <#itemsIndexed>`__,
   which provides the index. Please see the
   `LazyListScope  <#LazyListScope>`__
   reference for more details.

   .. rubric:: Lazy grids
      :name: lazy-grids

   The
   `LazyVerticalGrid  <#LazyVerticalGrid>`__
   and
   `LazyHorizontalGrid  <#LazyHorizontalGrid>`__
   composables provide support for displaying items in a grid. A Lazy vertical
   grid will display its items in a vertically scrollable container, spanned
   across multiple columns, while the Lazy horizontal grids will have the same
   behaviour on the horizontal axis.

   Grids have the same powerful API capabilities as lists and they also use a
   very similar DSL -
   `LazyGridScope.()  <#LazyGridScope>`__
   for describing the content.

   |Screenshot of a phone showing a grid of photos|

   The ``columns`` parameter in
   `LazyVerticalGrid  <#LazyVerticalGrid>`__
   and ``rows`` parameter in
   `LazyHorizontalGrid  <#LazyHorizontalGrid>`__
   control how cells are formed into columns or rows. The following example
   displays items in a grid, using
   `GridCells.Adaptive  <#GridCells.Adaptive>`__
   to set each column to be at least ``128.dp`` wide:

   .. code:: prettyprint

      LazyVerticalGrid(
          columns = GridCells.Adaptive(minSize = 128.dp)
      ) {
          items(photos) { photo ->
              PhotoItem(photo)
          }
      }LazyListSnippets.kt

   ``LazyVerticalGrid`` lets you specify a width for items, and then the grid
   will fit as many columns as possible. Any remaining width is distributed
   equally among the columns, after the number of columns is calculated. This
   adaptive way of sizing is especially useful for displaying sets of items
   across different screen sizes.

   If you know the exact number of columns to be used, you can instead provide
   an instance of
   `GridCells.Fixed  <#GridCells.Fixed>`__
   containing the number of required columns.

   If your design requires only certain items to have non-standard dimensions,
   you can use the grid support for providing custom column spans for items.
   Specify the column span with the ``span`` parameter of the
   `LazyGridScope DSL  <#LazyGridScope>`__
   ``item`` and ``items`` methods.
   `maxLineSpan  <#maxLineSpan>`__,
   one of the span scope’s values, is particularly useful when you're using
   adaptive sizing, because the number of columns is not fixed. This example
   shows how to provide a full row span:

   .. code:: prettyprint

      LazyVerticalGrid(
          columns = GridCells.Adaptive(minSize = 30.dp)
      ) {
          item(span = {
              // LazyGridItemSpanScope:
              // maxLineSpan
              GridItemSpan(maxLineSpan)
          }) {
              CategoryCard("Fruits")
          }
          // ...
      }LazyListSnippets.kt

   .. rubric:: Lazy staggered grid
      :name: lazy-staggered-grid

   **Note:**\  ``LazyVerticalStaggeredGrid`` and ``LazyHorizontalStaggeredGrid``
   are experimental. File any feedback on the `issue tracker <https://b.corp.google.com/issues/new?component=856989&template=1425922&pli=1>`__.
   `LazyVerticalStaggeredGrid  <#LazyVerticalStaggeredGrid>`__
   and
   `LazyHorizontalStaggeredGrid  <#LazyHorizontalStaggeredGrid>`__
   are composables that allow you to create a lazy-loaded, staggered grid of
   items. A lazy vertical staggered grid displays its items in a vertically
   scrollable container that spans across multiple columns and allows individual
   items to be different heights. Lazy horizontal grids have the same behavior
   on the horizontal axis with items of different widths.

   **Note:**\  The difference between a lazy staggered grid and a lazy grid is
   that the former can display items of different size widths or heights.
   The following snippet is a basic example of using
   ``LazyVerticalStaggeredGrid`` with a ``200.dp`` width per item:

   .. code:: prettyprint

      LazyVerticalStaggeredGrid(
          columns = StaggeredGridCells.Adaptive(200.dp),
          verticalItemSpacing = 4.dp,
          horizontalArrangement = Arrangement.spacedBy(4.dp),
          content = {
              items(randomSizedPhotos) { photo ->
                  AsyncImage(
                      model = photo,
                      contentScale = ContentScale.Crop,
                      contentDescription = null,
                      modifier = Modifier.fillMaxWidth().wrapContentHeight()
                  )
              }
          },
          modifier = Modifier.fillMaxSize()
      )LazyListSnippets.kt

   .. container:: float
      :name: image-90

   To set a fixed number of columns, you can use
   ``StaggeredGridCells.Fixed(columns)`` instead of
   ``StaggeredGridCells.Adaptive``. This divides the available width by the
   number of columns (or rows for a horizontal grid), and has each item take up
   that width (or height for a horizontal grid):

   .. code:: prettyprint

      LazyVerticalStaggeredGrid(
          columns = StaggeredGridCells.Fixed(3),
          verticalItemSpacing = 4.dp,
          horizontalArrangement = Arrangement.spacedBy(4.dp),
          content = {
              items(randomSizedPhotos) { photo ->
                  AsyncImage(
                      model = photo,
                      contentScale = ContentScale.Crop,
                      contentDescription = null,
                      modifier = Modifier.fillMaxWidth().wrapContentHeight()
                  )
              }
          },
          modifier = Modifier.fillMaxSize()
      )LazyListSnippets.kt

   .. container:: float
      :name: image-91

   .. rubric:: Content padding
      :name: content-padding

   Sometimes you'll need to add padding around the edges of the content. The
   lazy components allow you to pass some
   `PaddingValues  <#PaddingValues>`__
   to the ``contentPadding`` parameter to support this:

   .. code:: prettyprint

      LazyColumn(
          contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),
      ) {
          // ...
      }LazyListSnippets.kt

   In this example, we add ``16.dp`` of padding to the horizontal edges (left
   and right), and then ``8.dp`` to the top and bottom of the content.

   Please note that this padding is applied to the *content*, not to the
   ``LazyColumn`` itself. In the example above, the first item will add ``8.dp``
   padding to it’s top, the last item will add ``8.dp`` to its bottom, and all
   items will have ``16.dp`` padding on the left and the right.

   .. rubric:: Content spacing
      :name: content-spacing

   To add spacing in-between items, you can use
   `Arrangement.spacedBy()  <#spacedBy>`__.
   The example below adds ``4.dp`` of space in-between each item:

   .. code:: prettyprint

      LazyColumn(
          verticalArrangement = Arrangement.spacedBy(4.dp),
      ) {
          // ...
      }LazyListSnippets.kt

   Similarly for
   `LazyRow  <#LazyRow>`__:

   .. code:: prettyprint

      LazyRow(
          horizontalArrangement = Arrangement.spacedBy(4.dp),
      ) {
          // ...
      }LazyListSnippets.kt

   Grids, however, accept both vertical and horizontal arrangements:

   .. code:: prettyprint

      LazyVerticalGrid(
          columns = GridCells.Fixed(2),
          verticalArrangement = Arrangement.spacedBy(16.dp),
          horizontalArrangement = Arrangement.spacedBy(16.dp)
      ) {
          items(photos) { item ->
              PhotoItem(item)
          }
      }LazyListSnippets.kt

   .. rubric:: Item keys
      :name: item-keys

   By default, each item's state is keyed against the position of the item in
   the list or grid. However, this can cause issues if the data set changes,
   since items which change position effectively lose any remembered state. If
   you imagine the scenario of ``LazyRow`` within a ``LazyColumn``, if the row
   changes item position, the user would then lose their scroll position within
   the row.

   **Note:**\  For more information on how Compose remembers state, see the
   `State  <#state>`__ documentation
   To combat this, you can provide a stable and unique key for each item,
   providing a block to the ``key`` parameter. Providing a stable key enables
   item state to be consistent across data-set changes:

   .. code:: prettyprint

      LazyColumn {
          items(
              items = messages,
              key = { message ->
                  // Return a stable + unique key for the item
                  message.id
              }
          ) { message ->
              MessageRow(message)
          }
      }LazyListSnippets.kt

   By providing keys, you help Compose to handle reorderings correctly. For
   example, if your item contains remembered state, setting keys would allow
   Compose to move this state together with the item, when its position changes.

   .. code:: prettyprint

      LazyColumn {
          items(books, key = { it.id }) {
              val rememberedValue = remember {
                  Random.nextInt()
              }
          }
      }LazyListSnippets.kt

   However, there is one limitation on what types you can use as item keys. The
   key's type must be supported by
   `Bundle  <#Bundle>`__, Android’s mechanism for
   keeping the states when the Activity is recreated. ``Bundle`` supports types
   like primitives, enums or Parcelables.

   .. code:: prettyprint

      LazyColumn {
          items(books, key = {
              // primitives, enums, Parcelable, etc.
          }) {
              // ...
          }
      }LazyListSnippets.kt

   The key must be supported by ``Bundle`` so that the ``rememberSaveable``
   inside the item composable can be restored when the Activity is recreated, or
   even when you scroll away from this item and scroll back.

   .. code:: prettyprint

      LazyColumn {
          items(books, key = { it.id }) {
              val rememberedValue = rememberSaveable {
                  Random.nextInt()
              }
          }
      }LazyListSnippets.kt

   .. rubric:: Item animations
      :name: item-animations

   If you’ve used the RecyclerView widget, you’ll know that it `animates item changes  <#animations>`__
   automatically. Lazy layouts provide the same functionality for item
   reorderings. The API is simple - you just need to set the
   `animateItemPlacement  <#animateItemPlacement>`__
   modifier to the item content:

   .. code:: prettyprint

      LazyColumn {
          items(books, key = { it.id }) {
              Row(Modifier.animateItemPlacement()) {
                  // ...
              }
          }
      }LazyListSnippets.kt

   You can even provide custom animation specification, if you need to:

   .. code:: prettyprint

      LazyColumn {
          items(books, key = { it.id }) {
              Row(
                  Modifier.animateItemPlacement(
                      tween(durationMillis = 250)
                  )
              ) {
                  // ...
              }
          }
      }LazyListSnippets.kt

   Make sure you provide keys for your items so it is possible to find the new
   position for the moved element.

   Aside from reorderings, item animations for additions and removals is
   currently in development. You can track the progress in `issue 150812265 <https://issuetracker.google.com/issues/150812265>`__.

   .. rubric:: Sticky headers (experimental)
      :name: sticky-headers

   **Caution:**\  Experimental APIs can change in the future or may be removed
   entirely.
   The ‘sticky header’ pattern is helpful when displaying lists of grouped data.
   Below you can see an example of a ‘contacts list’, grouped by each contact’s
   initial:

   |Video of a phone scrolling up and down through a contacts list|

   To achieve a sticky header with ``LazyColumn``, you can use the experimental
   `stickyHeader() <https://developer.android.google.cn/reference/kotlin/androidx/compose/foundation/lazy/LazyListScope#stickyHeader(kotlin.Any,kotlin.Any,kotlin.Function1)>`__
   function, providing the header content:

   .. code:: prettyprint

      @OptIn(ExperimentalFoundationApi::class)
      @Composable
      fun ListWithHeader(items: List<Item>) {
          LazyColumn {
              stickyHeader {
                  Header()
              }

              items(items) { item ->
                  ItemRow(item)
              }
          }
      }LazyListSnippets.kt

   To achieve a list with multiple headers, like the ‘contacts list’ example
   above, you could do:

   .. code:: prettyprint

      // This ideally would be done in the ViewModel
      val grouped = contacts.groupBy { it.firstName[0] }

      @OptIn(ExperimentalFoundationApi::class)
      @Composable
      fun ContactsList(grouped: Map<Char, List<Contact>>) {
          LazyColumn {
              grouped.forEach { (initial, contactsForInitial) ->
                  stickyHeader {
                      CharacterHeader(initial)
                  }

                  items(contactsForInitial) { contact ->
                      ContactListItem(contact)
                  }
              }
          }
      }LazyListSnippets.kt

   .. rubric:: Reacting to scroll position
      :name: react-to-scroll-position

   Many apps need to react and listen to scroll position and item layout
   changes. The Lazy components support this use-case by hoisting the
   `LazyListState  <#LazyListState>`__:

   .. code:: prettyprint

      @Composable
      fun MessageList(messages: List<Message>) {
          // Remember our own LazyListState
          val listState = rememberLazyListState()

          // Provide it to LazyColumn
          LazyColumn(state = listState) {
              // ...
          }
      }LazyListSnippets.kt

   For simple use-cases, apps commonly only need to know information about the
   first visible item. For this
   `LazyListState  <#LazyListState>`__
   provides the
   `firstVisibleItemIndex  <#firstVisibleItemIndex>`__
   and
   `firstVisibleItemScrollOffset  <#firstVisibleItemScrollOffset>`__
   properties.

   If we use the example of a showing and hiding a button based on if the user
   has scrolled past the first item:

   .. code:: prettyprint

      @OptIn(ExperimentalAnimationApi::class)
      @Composable
      fun MessageList(messages: List<Message>) {
          Box {
              val listState = rememberLazyListState()

              LazyColumn(state = listState) {
                  // ...
              }

              // Show the button if the first visible item is past
              // the first item. We use a remembered derived state to
              // minimize unnecessary compositions
              val showButton by remember {
                  derivedStateOf {
                      listState.firstVisibleItemIndex > 0
                  }
              }

              AnimatedVisibility(visible = showButton) {
                  ScrollToTopButton()
              }
          }
      }LazyListSnippets.kt

   **Note:**\  The example above uses
   `derivedStateOf()  <#derivedStateOf>`__
   to minimize unnecessary compositions. For more information, 
   see the `Side Effects  <#derivedstateof>`__ documentation.
   Reading the state directly in composition is useful when you need to update
   other UI composables, but there are also scenarios where the event does not
   need to be handled in the same composition. A common example of this is
   sending an analytics event once the user has scrolled past a certain point.
   To handle this efficiently, we can use a
   `snapshotFlow()  <#snapshotFlow>`__:

   .. code:: prettyprint

      val listState = rememberLazyListState()

      LazyColumn(state = listState) {
          // ...
      }

      LaunchedEffect(listState) {
          snapshotFlow { listState.firstVisibleItemIndex }
              .map { index -> index > 0 }
              .distinctUntilChanged()
              .filter { it }
              .collect {
                  MyAnalyticsService.sendScrolledPastFirstItemEvent()
              }
      }LazyListSnippets.kt

   ``LazyListState`` also provides information about all of the items currently
   being displayed and their bounds on screen, via the
   `layoutInfo  <#layoutInfo>`__
   property. See the
   `LazyListLayoutInfo  <#LazyListLayoutInfo>`__
   class for more information.

   .. rubric:: Controlling the scroll position
      :name: control-scroll-position

   As well as reacting to scroll position, it’s also useful for apps to be able
   to control the scroll position too.
   `LazyListState  <#LazyListState>`__
   supports this via the
   `scrollToItem()  <#scrollToItem>`__
   function, which ‘immediately’ snaps the scroll position, and
   `animateScrollToItem()  <#animateScrollToItem>`__
   which scrolls using an animation (also known as a smooth scroll):

   **Note:**\  Both
   `scrollToItem()  <#scrollToItem>`__
   and
   `animateScrollToItem()  <#animateScrollToItem>`__
   are suspending functions, which means that we need to invoke them in a
   coroutine. See our `coroutines documentation  <#coroutines>`__ for more information
   on how to do that in Compose.
   .. code:: prettyprint

      @Composable
      fun MessageList(messages: List<Message>) {
          val listState = rememberLazyListState()
          // Remember a CoroutineScope to be able to launch
          val coroutineScope = rememberCoroutineScope()

          LazyColumn(state = listState) {
              // ...
          }

          ScrollToTopButton(
              onClick = {
                  coroutineScope.launch {
                      // Animate scroll to the first item
                      listState.animateScrollToItem(index = 0)
                  }
              }
          )
      }LazyListSnippets.kt

   .. rubric:: Large data-sets (paging)
      :name: large-datasets

   The `Paging library  <#v3-overview>`__
   enables apps to support large lists of items, loading and displaying small
   chunks of the list as necessary. Paging 3.0 and later provides Compose
   support through the ``androidx.paging:paging-compose`` library.

   **Note:**\  Compose support is provided only for Paging 3.0 and later. If
   you're using an earlier version of the Paging library, you need to `migrate to 3.0  <#v3-migration>`__ first.
   To display a list of paged content, we can use the
   `collectAsLazyPagingItems()  <#collectaslazypagingitems>`__
   extension function, and then pass in the returned
   `LazyPagingItems  <#LazyPagingItems>`__
   to ``items()`` in our ``LazyColumn``. Similar to Paging support in views, you
   can display placeholders while data loads by checking if the ``item`` is
   ``null``:

   .. code:: prettyprint

      @Composable
      fun MessageList(pager: Pager<Int, Message>) {
          val lazyPagingItems = pager.flow.collectAsLazyPagingItems()

          LazyColumn {
              items(
                  lazyPagingItems.itemCount,
                  key = lazyPagingItems.itemKey { it.id }
              ) { index ->
                  val message = lazyPagingItems[index]
                  if (message != null) {
                      MessageRow(message)
                  } else {
                      MessagePlaceholder()
                  }
              }
          }
      }LazyListSnippets.kt

   **Warning:**\  If you use a
   `RemoteMediator  <#RemoteMediator>`__ to
   fetch data from a network service, make sure to provide realistically sized
   placeholder items. If you use a ``RemoteMediator``, it will be repeatedly
   invoked to fetch new data, up until the screen has been filled with content.
   If small placeholders are provided (or no placeholder at all), the screen
   might never be filled, and your app will fetch many pages of data.

   .. rubric:: Tips on using Lazy layouts
      :name: lazy-layouts-tips

   There are a few tips you can take into account to ensure your Lazy layouts
   work as intended.

   .. rubric:: Avoid using 0-pixel sized items
      :name: avoid-0-size-items

   This can happen in scenarios where, for example, you expect to asynchronously
   retrieve some data like images, to fill your list’s items at a later stage.
   That would cause the Lazy layout to compose all of its items in the first
   measurement, as their height is 0 pixels and it could fit them all in the
   viewport. Once the items have loaded and their height expanded, Lazy layouts
   would then discard all of the other items that have unnecessarily been
   composed the first time around as they cannot in fact fit the viewport. To
   avoid this, you should set default sizing to your items, so that the Lazy
   layout can do the correct calculation of how many items can in fact fit in
   the viewport:

   .. code:: prettyprint

      @Composable
      fun Item(imageUrl: String) {
          AsyncImage(
              model = rememberAsyncImagePainter(model = imageUrl),
              modifier = Modifier.size(30.dp),
              contentDescription = null
              // ...
          )
      }LazyListSnippets.kt

   When you know the approximate size of your items after the data is
   asynchronously loaded, a good practice is to ensure your items’ sizing
   remains the same before and after loading, for example, by adding some
   placeholders. This will help maintain the correct scroll position.

   .. rubric:: Avoid nesting components scrollable in the same direction
      :name: avoid-nesting-scrollable

   This applies only to cases when nesting scrollable children without a
   predefined size inside another same direction scrollable parent. For example,
   trying to nest a child ``LazyColumn`` without a fixed height inside a
   vertically scrollable ``Column`` parent:

   .. code:: prettyprint

      // throws IllegalStateException
      Column(
          modifier = Modifier.verticalScroll(state)
      ) {
          LazyColumn {
              // ...
          }
      }LazyListSnippets.kt

   Instead, the same result can be achieved by wrapping all of your composables
   inside one parent ``LazyColumn`` and using its DSL to pass in different types
   of content. This enables emitting single items, as well as multiple list
   items, all in one place:

   .. code:: prettyprint

      LazyColumn {
          item {
              Header()
          }
          items(data) { item ->
              PhotoItem(item)
          }
          item {
              Footer()
          }
      }LazyListSnippets.kt

   Keep in mind that cases where you’re nesting different direction layouts, for
   example, a scrollable parent ``Row`` and a child ``LazyColumn``, are allowed:

   .. code:: prettyprint

      Row(
          modifier = Modifier.horizontalScroll(scrollState)
      ) {
          LazyColumn {
              // ...
          }
      }LazyListSnippets.kt

   As well as cases where you still use the same direction layouts, but also set
   a fixed size to the nested children:

   .. code:: prettyprint

      Column(
          modifier = Modifier.verticalScroll(scrollState)
      ) {
          LazyColumn(
              modifier = Modifier.height(200.dp)
          ) {
              // ...
          }
      }LazyListSnippets.kt

   .. rubric:: Beware of putting multiple elements in one item
      :name: multiple-elements-one-item

   In this example, the second item lambda emits 2 items in one block:

   .. code:: prettyprint

      LazyVerticalGrid(
          columns = GridCells.Adaptive(100.dp)
      ) {
          item { Item(0) }
          item {
              Item(1)
              Item(2)
          }
          item { Item(3) }
          // ...
      }LazyListSnippets.kt

   Lazy layouts will handle this as expected - they will lay out elements one
   after another as if they were different items. However, there are a couple of
   problems with doing so.

   When multiple elements are emitted as part of one item, they are handled as
   one entity, meaning that they cannot be composed individually anymore. If one
   element becomes visible on the screen, then all elements corresponding to the
   item have to be composed and measured. This can hurt performance if used
   excessively. In the extreme case of putting all elements in one item, it
   completely defeats the purpose of using Lazy layouts. Apart from potential
   performance issues, putting more elements in one item will also interfere
   with ``scrollToItem()`` & ``animateScrollToItem()``.

   However, there are valid use cases for putting multiple elements in one item,
   like having dividers inside a list. You do not want dividers to change
   scrolling indices, as they shouldn’t be considered independent elements.
   Also, performance will not be affected as dividers are small. A divider will
   likely need to be visible when the item before it is visible, so they can be
   part of the previous item:

   .. code:: prettyprint

      LazyVerticalGrid(
          columns = GridCells.Adaptive(100.dp)
      ) {
          item { Item(0) }
          item {
              Item(1)
              Divider()
          }
          item { Item(2) }
          // ...
      }LazyListSnippets.kt

   .. rubric:: Consider using custom arrangements
      :name: custom-arrangements

   Usually Lazy lists have many items, and they occupy more than the size of the
   scrolling container. However, when your list is populated with few items,
   your design can have more specific requirements for how these should be
   positioned in the viewport.

   To achieve this, you can use custom vertical
   `Arrangement  <#Arrangement>`__
   and pass it to the ``LazyColumn``. In the following example, the
   ``TopWithFooter`` object only needs to implement the ``arrange`` method.
   Firstly, it will position items one after another. Secondly, if the total
   used height is lower than the viewport height, it will position the footer at
   the bottom:

   .. code:: prettyprint

      object TopWithFooter : Arrangement.Vertical {
          override fun Density.arrange(
              totalSize: Int,
              sizes: IntArray,
              outPositions: IntArray
          ) {
              var y = 0
              sizes.forEachIndexed { index, size ->
                  outPositions[index] = y
                  y += size
              }
              if (y < totalSize) {
                  val lastIndex = outPositions.lastIndex
                  outPositions[lastIndex] = totalSize - sizes.last()
              }
          }
      }LazyListSnippets.kt

   .. rubric:: Consider adding ``contentType``
      :name: content-type

   Starting with Compose 1.2, in order to maximize the performance of your Lazy
   layout, consider adding
   `contentType  <#extension-functions-summary>`__
   to your lists or grids. This allows you to specify the content type for each
   item of the layout, in cases where you're composing a list or a grid
   consisting of multiple different types of items:

   .. code:: prettyprint

      LazyColumn {
          items(elements, contentType = { it.type }) {
              // ...
          }
      }LazyListSnippets.kt

   When you provide the
   `contentType  <#extension-functions-summary>`__,
   Compose is able to reuse compositions only between the items of the same
   type. As reusing is more efficient when you compose items of similar
   structure, providing the content types ensures Compose doesn't try to compose
   an item of type A on top of a completely different item of type B. This helps
   maximize the benefits of composition reusing and your Lazy layout
   performance.

   .. rubric:: Measuring performance
      :name: measuring-performance

   You can only reliably measure the performance of a Lazy layout when running
   in release mode and with R8 optimisation enabled. On debug builds, Lazy
   layout scrolling may appear slower. For more information on this, read
   through `Compose performance <https://developer.android.google.cn/develop/ui/compose/performance>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Migrate ``RecyclerView`` to Lazy
      list  <#recycler-view>`__
   -  `Save UI state in Compose  <#state-saving>`__
   -  `Kotlin for Jetpack Compose  <#kotlin>`__

Last updated 2024-05-03 UTC.

.. |Screenshot of a phone showing a grid of photos| image:: https://developer.android.google.cn/static/develop/ui/compose/images/lists-photogrid.png
   :width: 300px
.. |Video of a phone scrolling up and down through a contacts list| image:: https://developer.android.google.cn/static/develop/ui/compose/images/lists-scrolling.gif
   :width: 500px

/Resources
==========

.. https://developer.android.google.cn/develop/ui/compose/resources?hl=en

.. container:: devsite-article-body clearfix

   Jetpack Compose can access the resources defined in your Android project.
   This document explains some of the APIs Compose offers to do so.

   Resources are the additional files and static content that your code uses,
   such as bitmaps, layout definitions, user interface strings, animation
   instructions, and more. If you're not familiar with resources in Android,
   check out the `App resources overview guide  <#providing-resources>`__.

   .. rubric:: Strings
      :name: strings

   The most common type of resource are your Strings. Use the ``stringResource``
   API to retrieve a string statically defined in your XML resources.

   .. code:: prettyprint

      // In the res/values/strings.xml file
      // <string name="compose">Jetpack Compose</string>

      // In your Compose code
      Text(
          text = stringResource(R.string.compose)
      )ResourcesSnippets.kt

   ``stringResource`` also works with positional formatting.

   .. code:: prettyprint

      // In the res/values/strings.xml file
      // <string name="congratulate">Happy %1$s %2$d</string>

      // In your Compose code
      Text(
          text = stringResource(R.string.congratulate, "New Year", 2021)
      )ResourcesSnippets.kt

   .. rubric:: String plurals (experimental)
      :name: string-plurals

   Use the ``pluralStringResource`` API to load up a plural with a certain
   quantity.

   .. code:: prettyprint

      // In the res/strings.xml file
      // <plurals name="runtime_format">
      //    <item quantity="one">%1$d minute</item>
      //    <item quantity="other">%1$d minutes</item>
      // </plurals>

      // In your Compose code
      Text(
          text = pluralStringResource(
              R.plurals.runtime_format,
              quantity,
              quantity
          )
      )ResourcesSnippets.kt

   When using the ``pluralStringResource`` method, you need to pass the count
   twice if your string includes string formatting with a number. For example,
   for the string ``%1$d minutes``, the first count parameter selects the
   appropriate plural string and the second count parameter is inserted into the
   ``%1$d`` placeholder. If your plural strings don't include string formatting,
   you don't need to pass the third parameter to ``pluralStringResource``.

   For more information on plurals, check out the `quantity string documentation  <#Plurals>`__.

   .. rubric:: Dimensions
      :name: dimensions

   Similarly, use the ``dimensionResource`` API to get dimensions from a
   resource XML file.

   .. code:: prettyprint

      // In the res/values/dimens.xml file
      // <dimen name="padding_small">8dp</dimen>

      // In your Compose code
      val smallPadding = dimensionResource(R.dimen.padding_small)
      Text(
          text = "...",
          modifier = Modifier.padding(smallPadding)
      )ResourcesSnippets.kt

   .. rubric:: Colors
      :name: colors

   If you're adopting Compose incrementally in your app, use the
   ``colorResource`` API to get colors from a resource XML file.

   .. code:: prettyprint

      // In the res/colors.xml file
      // <color name="purple_200">#FFBB86FC</color>

      // In your Compose code
      Divider(color = colorResource(R.color.purple_200))ResourcesSnippets.kt

   ``colorResource`` works as expected with static colors, but it flattens
   `color state list resources  <#color-list-resource>`__.

   **Warning:**\  Prefer colors from the theme rather than hard-coded colors.
   Even though it's possible to access colors using the ``colorResource``
   function, it's recommended that the colors of your app are defined in a
   ``MaterialTheme`` which can be accessed from your composables like
   ``MaterialTheme.colors.primary``. Learn more about this in the `Design systems in Compose documentation  <#designsystems>`__.

   .. rubric:: Vector assets and image resources
      :name: vector-assets

   Use the ``painterResource`` API to load either vector drawables or rasterized
   asset formats like PNGs. You don't need to know the type of the drawable,
   simply use ``painterResource`` in ``Image`` composables or ``paint``
   modifiers.

   .. code:: prettyprint

      // Files in res/drawable folders. For example:
      // - res/drawable-nodpi/ic_logo.xml
      // - res/drawable-xxhdpi/ic_logo.png

      // In your Compose code
      Icon(
          painter = painterResource(id = R.drawable.ic_logo),
          contentDescription = null // decorative element
      )ResourcesSnippets.kt

   ``painterResource`` decodes and parses the content of the resource on the
   main thread.

   **Note:**\  Unlike
   `Context.getDrawable  <#getDrawable>`__,
   ``painterResource`` can only load
   `BitmapDrawable  <#BitmapDrawable>`__
   and
   `VectorDrawable  <#VectorDrawable>`__
   platform `Drawable  <#Drawable>`__
   types.

   .. rubric:: Animated Vector Drawables
      :name: animated-vector-drawables

   Use the ``AnimatedImageVector.animatedVectorResource`` API to load an
   animated vector drawable XML. The method returns an ``AnimatedImageVector``
   instance. In order to display the animated image, use the
   ``rememberAnimatedVectorPainter`` method to create a ``Painter`` that can be
   used in ``Image`` and ``Icon`` composables. The boolean ``atEnd`` parameter
   of the ``rememberAnimatedVectorPainter`` method indicates whether the image
   should be drawn at the end of all the animations. If used with a mutable
   state, changes to this value trigger the corresponding animation.

   .. code:: prettyprint

      // Files in res/drawable folders. For example:
      // - res/drawable/ic_hourglass_animated.xml

      // In your Compose code
      val image =
          AnimatedImageVector.animatedVectorResource(R.drawable.ic_hourglass_animated)
      val atEnd by remember { mutableStateOf(false) }
      Icon(
          painter = rememberAnimatedVectorPainter(image, atEnd),
          contentDescription = null // decorative element
      )ResourcesSnippets.kt

   .. rubric:: Icons
      :name: icons

   Jetpack Compose comes with the ``Icons`` object that is the entry point for
   using `Material Icons <https://material.io/resources/icons/?style=baseline>`__ in Compose.
   There are five distinct icon themes:
   `Filled  <#Icons.Filled>`__,
   `Outlined  <#Icons.Outlined>`__,
   `Rounded  <#Icons.Rounded>`__,
   `TwoTone  <#Icons.TwoTone>`__,
   and
   `Sharp  <#Icons.Sharp>`__.
   Each theme contains the same icons, but with a distinct visual style. You
   should typically choose one theme and use it across your application for
   consistency.

   To draw an icon, you can use the
   `Icon  <#Icon>`__
   composable which applies tint and provides layout size matching the icon.

   .. code:: prettyprint

      Icon(Icons.Rounded.Menu, contentDescription = "Localized description")ResourcesSnippets.kt

   Some of the most commonly used icons are available as part of the
   ``androidx.compose.material`` dependency. To use any of the other Material
   icons, add the ``material-icons-extended`` dependency to the ``build.gradle``
   file.

   .. code:: prettyprint

      dependencies {
        def composeBom = platform('androidx.compose:compose-bom:2024.05.00')
        implementation composeBom

        implementation 'androidx.compose.material:material-icons-extended'
      }

   **Note:**\  Icons maintain the same names defined by Material, but with their
   snake_case name converted to PascalCase. For example, add_alarm becomes
   ``AddAlarm``. Icons that start with a number, such as 360, are prefixed with
   ``_``, becoming ``_360``.
   **Warning:**\  ``material-icons-extended`` is a large library and can affect
   your APK size. For that reason, consider using R8/Proguard in production
   builds to remove the resources that aren't used. Furthermore due to the large
   size, your project's build time and Android Studio's previews loading time
   could increase during development. On the other hand,
   ``material-icons-extended`` lets you iterate more rapidly through quick
   access to the latest versions of all icons. You can also use this library to
   copy the source code of the icon to have a fixed copy in your app, or
   alternatively, import the icons using `Android Studio's Import vector asset feature  <#materialicon>`__.

   .. rubric:: Fonts
      :name: fonts

   To use fonts in Compose, download and bundle the font files directly in your
   APKs by placing them in the ``res/font`` folder.

   Load each font using the `Font  <#Font>`__ API and create a
   `FontFamily  <#FontFamily>`__ with them that you can use in
   `TextStyle  <#TextStyle>`__ instances to create your own
   `Typography  <#Typography>`__.
   The following is code taken from the
   `Crane <https://github.com/android/compose-samples/tree/main/Crane>`__
   compose sample and its
   `Typography.kt <https://github.com/android/compose-samples/blob/main/Crane/app/src/main/java/androidx/compose/samples/crane/ui/Typography.kt>`__
   file.

   .. code:: prettyprint

      // Define and load the fonts of the app
      private val light = Font(R.font.raleway_light, FontWeight.W300)
      private val regular = Font(R.font.raleway_regular, FontWeight.W400)
      private val medium = Font(R.font.raleway_medium, FontWeight.W500)
      private val semibold = Font(R.font.raleway_semibold, FontWeight.W600)

      // Create a font family to use in TextStyles
      private val craneFontFamily = FontFamily(light, regular, medium, semibold)

      // Use the font family to define a custom typography
      val craneTypography = Typography(
          titleLarge = TextStyle(
              fontFamily = craneFontFamily
          ) /* ... */
      )

      // Pass the typography to a MaterialTheme that will create a theme using
      // that typography in the part of the UI hierarchy where this theme is used
      @Composable
      fun CraneTheme(content: @Composable () -> Unit) {
          MaterialTheme(typography = craneTypography) {
              content()
          }
      }ResourcesSnippets.kt

   For using downloadable fonts in Compose, see the `Downloadable fonts  <#downloadable-fonts>`__ page.

   Learn more about typography in the `Theming in Compose documentation  <#typography>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Loading images {:#loading-images}  <#loading>`__
   -  `Material Design 2 in Compose  <#material>`__
   -  `Custom design systems in Compose  <#custom>`__

Last updated 2024-05-03 UTC.

/Overview: Theming
==================

.. https://developer.android.google.cn/develop/ui/compose/designsystems?hl=en

.. container:: devsite-article-body clearfix

   Jetpack Compose makes it easy to implement a design system and give your app
   a consistent look and feel with theming, components, and more.

   The following pages provide details on how to design and implement your
   design system:

   -  `Material Design 3  <#material3>`__: Learn
      how to implement Material You with Compose's implementation of `Material Design 3 <https://m3.material.io/>`__.
   -  `Migrating from Material 2 to Material 3  <#material2-material3>`__: Learn how to
      migrate your app from Material Design 2 to Material Design 3 in Compose.
   -  `Material Design 2  <#material>`__: Learn
      how to customize Compose's implementation of `Material Design 2 <https://material.io/>`__ to fit your product's brand.
   -  `Custom design systems  <#custom>`__:
      Learn how to implement a custom design system in Compose, and how to adapt
      existing Material Design composables to handle this.
   -  `Anatomy of a theme  <#anatomy>`__: Learn
      about the lower-level constructs and APIs used by ``MaterialTheme`` and
      custom design systems.
   -  `Migrating XML themes to Compose  <#material2-material3>`__: Learn
      how to migrate your View-based XML themes to Compose using the Accompanist
      theme adapter libraries.

   .. rubric:: Samples
      :name: samples

   The following samples demonstrate design systems in Jetpack Compose:

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Material Design 2 in Compose  <#material>`__
   -  `Custom design systems in Compose  <#custom>`__
   -  `Anatomy of a theme in Compose  <#anatomy>`__

Last updated 2024-05-03 UTC.

/Material Design 3
==================

.. https://developer.android.google.cn/develop/ui/compose/designsystems/material3?hl=en

.. container:: devsite-article-body clearfix

   Jetpack Compose offers an implementation of `Material Design 3 <https://m3.material.io/>`__, the next evolution of Material Design.
   Material 3 includes updated theming, components and Material You
   personalization features like dynamic color, and is designed to be cohesive
   with the new visual style and system UI on Android 12 and above.

   **Note:**\  The terms “Material Design 3”, “Material 3”, and “M3” are
   interchangeable. The existing Material Design spec and corresponding
   androidx.compose.material library are referred to as “Material Design 2”,
   “Material 2”, or “M2”.
   Below, we demonstrate the `Material Design 3 <https://m3.material.io/>`__
   implementation using the `Reply sample app <https://github.com/android/compose-samples/tree/main/Reply>`__ as an
   example. The Reply sample is based entirely on Material Design 3.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-sampleapp.png
      name: image-1
      :alt: Reply sample app using Material Design 3
      :width: 70.0%

      **Figure 1**. Reply sample app using Material Design 3

   .. rubric:: Dependency
      :name: dependency

   To start using Material 3 in your Compose app, add the `Compose Material 3  <#package-summary>`__
   dependency to your ``build.gradle`` files:

   .. code:: prettyprint

      implementation "androidx.compose.material3:material3:$material3_version"

   Once the dependency is added, you can start adding Material Design systems,
   including color, typography, and shape, to your apps.

   .. rubric:: Experimental APIs
      :name: experimental-apis

   Some M3 APIs are considered experimental. In such cases you need to opt in at
   the function or file level using the
   `ExperimentalMaterial3Api  <#ExperimentalMaterial3Api>`__
   annotation:

   .. code:: prettyprint

      // import androidx.compose.material3.ExperimentalMaterial3Api
      @OptIn(ExperimentalMaterial3Api::class)
      @Composable
      fun AppComposable() {
          // M3 composables
      }
      Material3Snippets.kt

   .. rubric:: Material theming
      :name: material-theming

   An M3 theme contains the following subsystems: `color scheme <https://m3.material.io/styles/color/overview>`__,
   `typography <https://m3.material.io/styles/typography/overview>`__ and
   `shapes <https://m3.material.io/styles/shape/overview>`__. When you customize
   these values, your changes are automatically reflected in the M3 components
   you use to build your app.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-theming.png
      name: image-2
      :alt: Subsystems of Material design: Color, Typography and Shapes
      :width: 60.0%

      **Figure 2**. Subsystems of Material Design: color, typography and shapes

   Jetpack Compose implements these concepts with the M3 ``MaterialTheme``
   composable:

   .. code:: prettyprint

      MaterialTheme(
          colorScheme = /* ...
          typography = /* ...
          shapes = /* ...
      ) {
          // M3 app content
      }Material3Snippets.kt

   To theme your application content, define the color scheme, typography, and
   shapes specific to your app.

   .. rubric:: Color scheme
      :name: color-scheme

   The foundation of a color scheme is the set of five key colors. Each of these
   colors relate to a tonal palette of 13 tones, which are used by Material 3
   components. For example, this is the color scheme for light theme for
   `Reply <https://github.com/android/compose-samples/tree/main/Reply>`__:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-light.png
      name: image-3
      :alt: Reply sample app light color scheme
      :width: 70.0%

      **Figure 3**. Reply sample app light color scheme

   Read more about the `Color scheme and color roles <https://m3.material.io/styles/color/the-color-system/key-colors-tones>`__.

   .. rubric:: Generate color schemes
      :name: generate_color_schemes

   While you can create a custom ``ColorScheme`` manually, it’s often easier to
   generate one using source colors from your brand. The `Material Theme Builder <https://material.io/material-theme-builder>`__ tool allows you to do
   this, and optionally export Compose theming code. The following files are
   generated:

   -  ``Color.kt`` contains the colors of your theme with all the roles defined
      for both light and dark theme colors.

   .. code:: prettyprint

      val md_theme_light_primary = Color(0xFF476810)
      val md_theme_light_onPrimary = Color(0xFFFFFFFF)
      val md_theme_light_primaryContainer = Color(0xFFC7F089)
      // ..
      // ..

      val md_theme_dark_primary = Color(0xFFACD370)
      val md_theme_dark_onPrimary = Color(0xFF213600)
      val md_theme_dark_primaryContainer = Color(0xFF324F00)
      // ..
      // ..Material3Snippets.kt

   -  ``Theme.kt`` contains a setup for light and dark color schemes and the app
      theme.

   .. code:: prettyprint

      private val LightColorScheme = lightColorScheme(
          primary = md_theme_light_primary,
          onPrimary = md_theme_light_onPrimary,
          primaryContainer = md_theme_light_primaryContainer,
          // ..
      )
      private val DarkColorScheme = darkColorScheme(
          primary = md_theme_dark_primary,
          onPrimary = md_theme_dark_onPrimary,
          primaryContainer = md_theme_dark_primaryContainer,
          // ..
      )

      @Composable
      fun ReplyTheme(
          darkTheme: Boolean = isSystemInDarkTheme(),
          content: @Composable () -> Unit
      ) {
          val colorScheme =
              if (!darkTheme) {
                  LightColorScheme
              } else {
                  DarkColorScheme
              }
          MaterialTheme(
              colorScheme = colorScheme,
              content = content
          )
      }Material3Snippets.kt

   To support light and dark themes, use ``isSystemInDarkTheme()``. Based on the
   system setting, define which color scheme to use: light or dark.

   .. rubric:: Dynamic color schemes
      :name: dynamic_color_schemes

   `Dynamic color <https://m3.material.io/styles/color/dynamic-color/overview>`__ is the
   key part of Material You, in which an algorithm derives custom colors from a
   user’s wallpaper to be applied to their apps and system UI. This color
   palette is used as the starting point to generate light and dark color
   schemes.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-dynamic.png
      name: image-4
      :alt: Reply sample app dynamic theming from wallpaper (left) and default
      app theming (right)
      :width: 70.0%

      **Figure 4**. Reply sample app dynamic theming from wallpaper (left) and
      default app theming (right)

   Dynamic color is available on Android 12 and above. If dynamic color is
   available, you can set up a dynamic ``ColorScheme``. If not, you should fall
   back to using a custom light or dark ``ColorScheme``.

   ``ColorScheme`` provides builder functions to create a dynamic
   `light  <#dynamiclightcolorscheme>`__
   or
   `dark  <#dynamicdarkcolorscheme>`__
   color scheme:

   .. code:: prettyprint

      // Dynamic color is available on Android 12+
      val dynamicColor = Build.VERSION.SDK_INT >= Build.VERSION_CODES.S
      val colors = when {
          dynamicColor && darkTheme -> dynamicDarkColorScheme(LocalContext.current)
          dynamicColor && !darkTheme -> dynamicLightColorScheme(LocalContext.current)
          darkTheme -> DarkColorScheme
          else -> LightColorScheme
      }Material3Snippets.kt

   .. rubric:: Color usage
      :name: color_usage

   You can access Material theme colors in your app via
   ``MaterialTheme.colorScheme``:

   .. code:: prettyprint

      Text(
          text = "Hello theming",
          color = MaterialTheme.colorScheme.primary
      )Material3Snippets.kt

   Each color role can be used in a variety of places depending on the
   component’s state, prominence, and emphasis.

   -  Primary is the base color, used for main components like prominent
      buttons, active states, and the tint of elevated surfaces.
   -  The secondary key color is used for less prominent components in the UI,
      such as filter chips, and expands the opportunity for color expression.
   -  The tertiary key color is used to derive the roles of contrasting accents
      that can be used to balance primary and secondary colors or bring enhanced
      attention to an element.

   The Reply sample app design uses on-primary-container color on top of
   primary-container to put emphasis on the selected item.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-container.png
      name: image-5
      :alt: Primary container and text fields with on-primary-container color.
      :width: 75.0%

      **Figure 5**. Primary container and text fields with on-primary-container
      color.

   .. code:: prettyprint

      Card(
          colors = CardDefaults.cardColors(
              containerColor =
              if (isSelected) MaterialTheme.colorScheme.primaryContainer
              else
                  MaterialTheme.colorScheme.surfaceVariant
          )
      ) {
          Text(
              text = "Dinner club",
              style = MaterialTheme.typography.bodyLarge,
              color =
              if (isSelected) MaterialTheme.colorScheme.onPrimaryContainer
              else MaterialTheme.colorScheme.onSurface,
          )
      }
      Material3Snippets.kt

   Here you can see in the Reply Navigation drawer how secondary and tertiary
   container colors are used in contrast to create emphasis and accent.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-navdrawer.png
      name: image-6
      :alt: Tertiary-container and on-tertiary-container combination for
      Floating Action button.
      :width: 65.0%

      **Figure 6**. Tertiary-container and on-tertiary-container combination for
      Floating Action button.

   .. rubric:: Typography
      :name: typography

   Material Design 3 defines a `type scale <https://m3.material.io/styles/typography/overview>`__, including text
   styles that have been adapted from Material Design 2. The naming and grouping
   have been simplified to: display, headline, title, body, and label, with
   large, medium, and small sizes for each.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-typography.png
      name: image-7
      :alt: Default typography scale for Material design 3
      :width: 65.0%

      **Figure 7**. Default typography scale for Material Design 3

      ======================  ==================================
      **M3**                  **Default Font Size/Line Height**
      ======================  ==================================
      ``displayLarge``        ``Roboto 57/64``
      ``displayMedium``       ``Roboto 45/52``
      ``displaySmall``        ``Roboto 36/44``
      ``headlineLarge``       ``Roboto 32/40``
      ``headlineMedium``      ``Roboto 28/36``
      ``headlineSmall``       ``Roboto 24/32``
      ``titleLarge``          ``New- Roboto Medium 22/28``
      ``titleMedium``         ``Roboto Medium 16/24``
      ``titleSmall``          ``Roboto Medium 14/20``
      ``bodyLarge``           ``Roboto 16/24``
      ``bodyMedium``          ``Roboto 14/20``
      ``bodySmall``           ``Roboto 12/16``
      ``labelLarge``          ``Roboto Medium 14/20``
      ``labelMedium``         ``Roboto Medium 12/16``
      ``labelSmall``          ``New Roboto Medium, 11/16``
      ======================  ==================================

   **Note:**\  Unlike the M2 ``Typography`` class, the M3 ``Typography`` class
   doesn’t currently include a ``defaultFontFamily`` parameter. You’ll need to
   use the ``fontFamily`` parameter in each of the individual ``TextStyles``
   instead.

   .. rubric:: Define typography
      :name: define_typography

   Compose provides the M3
   `Typography  <#Typography>`__
   class — along with the existing
   `TextStyle  <#TextStyle>`__ and
   `font-related  <#package-summary>`__
   classes — to model the Material 3 type scale. The ``Typography`` constructor
   offers defaults for each style so you can omit any parameters you do not want
   to customize:

   .. code:: prettyprint

      val replyTypography = Typography(
          titleLarge = TextStyle(
              fontWeight = FontWeight.SemiBold,
              fontSize = 22.sp,
              lineHeight = 28.sp,
              letterSpacing = 0.sp
          ),
          titleMedium = TextStyle(
              fontWeight = FontWeight.SemiBold,
              fontSize = 16.sp,
              lineHeight = 24.sp,
              letterSpacing = 0.15.sp
          ),
          // ..
      )
      // ..Material3Snippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-body.png
      name: image-8
      :alt: Body large, body medium and label medium for different typography
      usage.
      :width: 70.0%

      **Figure 8**. Body large, body medium, and label medium for different
      typography usage.

   Your product will likely not need all 15 default styles from the Material
   Design type scale. In this example, five sizes are chosen for a reduced set
   while the rest are omitted.

   You can customize your typography by changing default values of
   `TextStyle  <#TextStyle>`__ and
   `font-related  <#package-summary>`__
   properties like ``fontFamily`` and ``letterSpacing``.

   .. code:: prettyprint

      bodyLarge = TextStyle(
          fontWeight = FontWeight.Normal,
          fontFamily = FontFamily.SansSerif,
          fontStyle = FontStyle.Italic,
          fontSize = 16.sp,
          lineHeight = 24.sp,
          letterSpacing = 0.15.sp,
          baselineShift = BaselineShift.Subscript
      ),Material3Snippets.kt

   Once you have defined your ``Typography``, pass it to the M3
   ``MaterialTheme``:

   .. code:: prettyprint

      MaterialTheme(
          typography = replyTypography,
      ) {
          // M3 app Content
      }Material3Snippets.kt

   .. rubric:: Use text styles
      :name: use_text_styles

   You can retrieve the typography provided to the M3 ``MaterialTheme``
   composable by using ``MaterialTheme.typography``:

   .. code:: prettyprint

      Text(
          text = "Hello M3 theming",
          style = MaterialTheme.typography.titleLarge
      )
      Text(
          text = "you are learning typography",
          style = MaterialTheme.typography.bodyMedium
      )Material3Snippets.kt

   You can read more about the Material guidelines on `applying typography <https://m3.material.io/styles/typography/applying-type>`__.

   .. rubric:: Shapes
      :name: shapes

   Material surfaces can be displayed in different shapes. Shapes direct
   attention, identify components, communicate state, and express brand.

   The shape scale defines the style of container corners, offering a range of
   roundedness from square to fully circular.

   .. rubric:: Define shapes
      :name: define_shapes

   Compose provides the M3
   `Shapes  <#Shapes>`__ class
   with expanded parameters to support new M3 shapes. The M3 shape scale is more
   like the `type scale <https://m3.material.io/styles/typography/>`__, enabling
   an expressive range of shapes across the UI.

   There are different sizes of shapes:

   -  Extra Small
   -  Small
   -  Medium
   -  Large
   -  Extra Large

   By default, each shape has a default value, but you can override those:

   .. code:: prettyprint

      val replyShapes = Shapes(
          extraSmall = RoundedCornerShape(4.dp),
          small = RoundedCornerShape(8.dp),
          medium = RoundedCornerShape(12.dp),
          large = RoundedCornerShape(16.dp),
          extraLarge = RoundedCornerShape(24.dp)
      )Material3Snippets.kt

   Once you have defined your ``Shapes``, you can pass it to the M3
   ``MaterialTheme``:

   .. code:: prettyprint

      MaterialTheme(
          shapes = replyShapes,
      ) {
          // M3 app Content
      }Material3Snippets.kt

   .. rubric:: Use shapes
      :name: use_shapes

   You can customize the shape scale for all components in the ``MaterialTheme``
   or you can do it on a per component basis.

   Apply medium and large shape with default values:

   .. code:: prettyprint

      Card(shape = MaterialTheme.shapes.medium) { /* card content */ }
      FloatingActionButton(
          shape = MaterialTheme.shapes.large,
          onClick = {
          }
      ) {
          /* fab content */
      }Material3Snippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-shape.png
      name: image-9
      :alt: Medium shape for Card and Large shape for Floating action button in
      Reply sample app.
      :width: 65.0%

      **Figure 9**. Medium shape for Card and Large shape for Floating action
      button in Reply sample app

   There are two other shapes — ``RectangleShape`` and ``CircleShape`` — which
   are part of Compose. Rectangle shape is with no border radius and circle
   shape shows full circled edges:

   .. code:: prettyprint

      Card(shape = RectangleShape) { /* card content */ }
      Card(shape = CircleShape) { /* card content */ }Material3Snippets.kt

   The examples below demonstrate some of the components with default shape
   values applied to them:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-shape2.png
      name: image-10
      :alt: Default shapes values for all Material 3 components.

      **Figure 10**. Default shapes values for all Material 3 components.

   You can read more about the Material guidelines on `applying shape <https://m3.material.io/styles/shape/overview>`__.

   .. rubric:: Emphasis
      :name: emphasis

   Emphasis in M3 is provided using variations of color and its on-color
   combinations. In M3, there are two ways to add emphasis to your UI:

   -  Using surface, surface-variant and background alongside on-surface,
      on-surface-variants colors from the expanded M3 color system. For example,
      surface can be used with on-surface-variant and surface-variant can be
      used with on-surface to provide different levels of emphasis.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-emphasis.png
      name: image-11
      :alt: Using neutral color combinations for emphasis.
      :width: 80.0%

      **Figure 11**. Using neutral color combinations for emphasis.

   -  Using different font weights for text. Above, you saw that you can provide
      custom weights to our type scale for providing different emphasis.

   .. code:: prettyprint

      bodyLarge = TextStyle(
          fontWeight = FontWeight.Bold
      ),
      bodyMedium = TextStyle(
          fontWeight = FontWeight.Normal
      )Material3Snippets.kt

   **Note:**\  For disabled states in M3, it’s still acceptable to use “on-x”
   (where x can be primary, secondary, surface etc.) colors with alpha values.

   .. rubric:: Elevation
      :name: elevation

   Material 3 represents elevation mainly using tonal color overlays. This is a
   new way to differentiate containers and surfaces from each other — increasing
   tonal elevation uses a more prominent tone — in addition to shadows.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-elevation.png
      name: image-12
      :alt: Tonal elevation with shadow elevation
      :width: 50.0%

      **Figure 12**. Tonal elevation with shadow elevationE

   Elevation overlays in dark themes have also changed to tonal color overlays
   in Material 3. The overlay color comes from the primary color slot.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-surface.png
      name: image-13
      :alt: Shadow elevation vs Tonal elevation in Material Design 3
      :width: 50.0%

      **Figure 13**. Shadow elevation versus Tonal elevation in Material Design
      3

   The M3
   `Surface <https://developer.android.google.cn/reference/kotlin/androidx/compose/material/package-summary#Surface(androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Shape,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.foundation.BorderStroke,androidx.compose.ui.unit.Dp,kotlin.Function0)>`__
   — the backing composable behind most M3 components — includes support for
   both tonal and shadow elevation:

   .. code:: prettyprint

      Surface(
          modifier = Modifier,
          tonalElevation = /*...
          shadowElevation = /*...
      ) {
          Column(content = content)
      }Material3Snippets.kt

   .. rubric:: Material components
      :name: material-components

   Material Design comes with a rich set of `Material components <https://m3.material.io/components/all-buttons>`__ (such as
   buttons, chips, cards, navigation bar) which already follow Material Theming
   and help you make beautiful Material Design apps. You can start using
   components with default properties right out of the box.

   .. code:: prettyprint

      Button(onClick = { /*..*/ }) {
          Text(text = "My Button")
      }Material3Snippets.kt

   M3 provides many versions of the same components to be used in different
   roles according to emphasis and attention.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-emphasis2.png
      name: image-14
      :alt: Button emphasis from FAB, Primary down to Text button
      :width: 50.0%

      **Figure 14**. Button emphasis from FAB, Primary down to Text button

   -  An extended floating action button for the highest emphasis action:

   .. code:: prettyprint

      ExtendedFloatingActionButton(
          onClick = { /*..*/ },
          modifier = Modifier
      ) {
          Icon(
              imageVector = Icons.Default.Edit,
              contentDescription = stringResource(id = R.string.edit),
          )
          Text(
              text = stringResource(id = R.string.add_entry),
          )
      }Material3Snippets.kt

   -  A filled button for a high emphasis action:

   .. code:: prettyprint

      Button(onClick = { /*..*/ }) {
          Text(text = stringResource(id = R.string.view_entry))
      }Material3Snippets.kt

   -  A text button for a low emphasis action:

   .. code:: prettyprint

      TextButton(onClick = { /*..*/ }) {
          Text(text = stringResource(id = R.string.replated_articles))
      }Material3Snippets.kt

   You can read more about Material `buttons and other components <https://m3.material.io/components/all-buttons>`__. Material 3
   provides a wide variety of component suites such as Buttons, App bars,
   Navigation components that are specifically designed for different use cases
   and screen sizes.

   .. rubric:: Navigation components
      :name: navigation-components

   Material also provides several navigation components that help you implement
   navigation, depending on different screen sizes and states.

   ``NavigationBar`` is used for compact devices when you want to target 5 or
   less destinations:

   .. code:: prettyprint

      NavigationBar(modifier = Modifier.fillMaxWidth()) {
          Destinations.entries.forEach { replyDestination ->
              NavigationBarItem(
                  selected = selectedDestination == replyDestination,
                  onClick = { },
                  icon = { }
              )
          }
      }Material3Snippets.kt

   ``NavigationRail`` is used for small-to-medium size tablets or phones in
   landscape mode. It provides ergonomics to users and improves the user
   experience for those devices.

   .. code:: prettyprint

      NavigationRail(
          modifier = Modifier.fillMaxHeight(),
      ) {
          Destinations.entries.forEach { replyDestination ->
              NavigationRailItem(
                  selected = selectedDestination == replyDestination,
                  onClick = { },
                  icon = { }
              )
          }
      }Material3Snippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-showcasebottom.png
      name: image-15
      :alt: Reply Showcase of BottomNavigationBar(Left) and
      NavigationRail(Right)
      :width: 75.0%

      **Figure 15**. Reply Showcase of ``BottomNavigationBar`` (Left) and
      ``NavigationRail`` (Right)

   Reply using both in default theming to provide immersive user experience for
   all device sizes.

   ``NavigationDrawer`` is used for medium-to-large size tablets where you have
   enough space to show detail. You can use both ``PermanentNavigationDrawer``
   or ``ModalNavigationDrawer`` along with ``NavigationRail``.

   .. code:: prettyprint

      PermanentNavigationDrawer(modifier = Modifier.fillMaxHeight(), drawerContent = {
          Destinations.entries.forEach { replyDestination ->
              NavigationRailItem(
                  selected = selectedDestination == replyDestination,
                  onClick = { },
                  icon = { },
                  label = { }
              )
          }
      }) {
      }Material3Snippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-showcasedrawer.png
      name: image-16
      :alt: Reply Showcase of Permanent navigation drawer
      :width: 50.0%

      **Figure 16**. Reply showcase of permanent navigation drawer

   Navigation options enhance the user experience, ergonomics and reachability.
   You can learn more about Material navigation components in the `Compose adaptive codelab <https://developers.google.cn/codelabs/jetpack-compose-adaptability>`__.

   .. rubric:: Customize a component's theming
      :name: customizing-components

   M3 encourages personalization and flexibility. All components have default
   colors applied to them but expose flexible APIs to customize their colors if
   required.

   Most components, like cards and buttons, provide a default object exposing
   color and elevation interfaces that can be modified to customize your
   component:

   .. code:: prettyprint

      val customCardColors = CardDefaults.cardColors(
          contentColor = MaterialTheme.colorScheme.primary,
          containerColor = MaterialTheme.colorScheme.primaryContainer,
          disabledContentColor = MaterialTheme.colorScheme.surface,
          disabledContainerColor = MaterialTheme.colorScheme.onSurface,
      )
      val customCardElevation = CardDefaults.cardElevation(
          defaultElevation = 8.dp,
          pressedElevation = 2.dp,
          focusedElevation = 4.dp
      )
      Card(
          colors = customCardColors,
          elevation = customCardElevation
      ) {
          // m3 card content
      }Material3Snippets.kt

   You can read more about `customizing Material 3 <https://m3.material.io/foundations/customization>`__.

   .. rubric:: System UI
      :name: system-ui

   Some aspects of Material You come from the new visual style and system UI on
   Android 12 and above. Two key areas where there are changes are ripple and
   overscroll. No additional work is required to implement these changes.

   .. rubric:: Ripple
      :name: ripple

   Ripple now uses a subtle sparkle to illuminate surfaces when pressed.
   `Compose Material Ripple  <#package-summary>`__
   uses a platform RippleDrawable under the hood on Android, so sparkle ripple
   is available on Android 12 and above for all Material components.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-ripple.gif
      name: image-17
      :alt: Ripple in M2 vs M3
      :width: 50.0%

      **Figure 17**. Ripple in M2 versus M3

   .. rubric:: Overscroll
      :name: overscroll

   Overscroll now uses a `stretch effect  <#overscroll>`__ at the edge of
   scrolling containers. Stretch overscroll is on by default in scrolling
   container composables — for example,
   `LazyColumn  <#lazycolumn>`__,
   `LazyRow  <#lazyrow>`__,
   and
   `LazyVerticalGrid  <#lazyverticalgrid>`__
   — in `Compose Foundation  <#compose-foundation>`__
   1.1.0 and above, regardless of API level.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-overscroll.gif
      name: image-18
      :alt: Overscroll using stretch effect at the edge of the container
      :width: 35.0%

      **Figure 18**. Overscroll using stretch effect at the edge of the
      container

   .. rubric:: Accessibility
      :name: accessibility

   Accessibility standards built into Material components are designed to
   provide a foundation for inclusive product design. Understanding your
   product’s accessibility can enhance usability for all users, including those
   with low vision, blindness, hearing impairments, cognitive impairments, motor
   impairments, or situational disabilities (such as a broken arm).

   .. rubric:: Color accessibility
      :name: color-accessibility

   Dynamic color is designed to meet accessibility standards for color contrast.
   The system of tonal palettes is critical to making any color scheme
   accessible by default.

   Material's color system provides standard tone values and measurements that
   can be used to meet accessible contrast ratios.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-colorpallets.png
      name: image-19
      :alt: Reply sample app: Primary, secondary and tertiary tonal pallets (top
      to bottom)
      :width: 65.0%

      **Figure 19**. Reply sample app: Primary, secondary and tertiary tonal
      palettes (top to bottom)

   All Material components and dynamic theming already use the above color roles
   from a set of `tonal palettes <https://m3.material.io/styles/color/the-color-system/key-colors-tones#a828e350-1551-45e5-8430-eb643e6a7713>`__,
   selected to meet accessibility requirements. However, if you are customizing
   components, make sure to use appropriate color roles and avoid mismatch.

   Use on-primary on top of primary, and on-primary-container on top of
   primary-container, and the same for other accent and neutral colors to
   provide accessible contrast to the user.

   The use of a tertiary container on top of primary gives the user a poor
   contrast button:

   .. code:: prettyprint

      // ✅ Button with sufficient contrast ratio
      Button(
          onClick = { },
          colors = ButtonDefaults.buttonColors(
              containerColor = MaterialTheme.colorScheme.primary,
              contentColor = MaterialTheme.colorScheme.onPrimary
          )
      ) {
      }

      // ❌ Button with poor contrast ratio
      Button(
          onClick = { },
          colors = ButtonDefaults.buttonColors(
              containerColor = MaterialTheme.colorScheme.tertiaryContainer,
              contentColor = MaterialTheme.colorScheme.primaryContainer
          )
      ) {
      }Material3Snippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/m3-contrast.png
      name: image-20
      :alt: Sufficient contrast (left) vs Poor contrast (right)
      :width: 50.0%

      **Figure 20**. Sufficient contrast (left) versus poor contrast (right)

   .. rubric:: Typography accessibility
      :name: typography-accessibility

   The M3 type scale updates the static type ramp and values to offer a
   simplified but dynamic framework of size categories that scale across
   devices.

   For example, in M3, Display Small can be assigned different values depending
   upon the device context, such as a phone or a tablet.

   .. rubric:: Large screens
      :name: large-screens

   Material provides guidance on adaptive layouts and foldables to make your
   apps accessible and improve the ergonomics of users holding large devices.

   Material provides different kinds of
   `navigation <https://m3.material.io/components/navigation-bar/overview>`__ to
   help you provide better user experience for large devices.

   You can learn more about android `large screen guidelines  <#adaptive>`__ and see our `Reply sample <https://github.com/android/compose-samples/tree/main/Reply>`__ for
   adaptive and accessible design.

   .. rubric:: Learn more
      :name: learn-more

   To learn more about Material Theming in Compose, check out the following
   resources:

   .. rubric:: Sample apps
      :name: sample-apps

   -  `Reply M3 sample app <https://github.com/android/compose-samples/tree/main/Reply>`__

   .. rubric:: Docs
      :name: docs

   -  `Migrating from Material 2 to Material 3 in Compose  <#material2-material3>`__
   -  `Material design guidelines <https://m3.material.io/>`__

   .. rubric:: API reference and source code
      :name: api-reference

   -  `Compose Material 3 API reference  <#package-summary>`__
   -  `Compose Material 3 samples in source code <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material3/material3/samples/src/main/java/androidx/compose/material3/samples/>`__

   .. rubric:: Videos
      :name: videos

   -  `Material You in Jetpack Compose <https://www.youtube.com/watch?v=jrfuHyMlehc>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Migrate from Material 2 to Material 3 in Compose  <#material2-material3>`__
   -  `Material Design 2 in Compose  <#material>`__
   -  `Custom design systems in Compose  <#custom>`__

Last updated 2024-05-03 UTC.

/Migrate from Material 2 to Material 3
======================================

.. https://developer.android.google.cn/develop/ui/compose/designsystems/material2-material3?hl=en

.. container:: devsite-article-body clearfix

   `Material Design 3 <https://m3.material.io/>`__ is the next evolution of
   Material Design. It includes updated theming, components, and Material You
   personalization features like dynamic color. It’s an update to `Material Design 2 <https://material.io/>`__ and is cohesive with the new visual style
   and system UI on Android 12 and above.

   This guide focuses on migrating from the `Compose Material (androidx.compose.material) Jetpack library  <#compose-material>`__ to the `Compose Material 3 (androidx.compose.material3) Jetpack library  <#compose-material3>`__.

   **Note:**\  This guide uses abbreviation “M3” to refer to the interchangeable
   terms: “Material 3”, “Material Design 3”, “Material You”, and the Compose
   Material 3 (androidx.compose.material3) Jetpack library. The abbreviation
   “M2” is used to refer to the interchangeable terms: “Material 2”, “Material
   Design 2”, and the Compose Material (androidx.compose.material) Jetpack
   library.

   .. rubric:: Approaches
      :name: approaches

   In general **you should not use both M2 and M3 in a single app long-term**.
   This is due to the fact that the two design systems and respective libraries
   differ significantly in terms of their UX/UI designs and Compose
   implementations.

   Your app may use a design system, such as one created using Figma. In such
   cases, we also highly recommend that you or your design team migrate it from
   M2 to M3 *before* starting the Compose migration. It doesn’t make sense to
   migrate an app to M3 if its UX/UI design is based on M2.

   Furthermore, your approach to migration should differ depending on your app’s
   size, complexity, and UX/UI design. Doing so helps you to minimize the impact
   on your codebase. You should take a phased approach to migration.

   **Note:**\  If you're starting a new app instead of migrating an existing app
   from M2 to M3, we recommend using M3 from the beginning.

   .. rubric:: When to migrate
      :name: when-migrate

   You should start the migration as soon as possible. However, it’s important
   to consider whether or not your app is in a realistic position to **fully**
   migrate from M2 to M3. There are some “blocker” scenarios to consider
   investigating before you start:

   .. list-table::
      :header-rows: 1

      - 

         - Scenario
         - Recommended approach
      - 

         - No “blockers”
         - Begin phased migration
      - 

         - A component from M2 is not available in M3 yet. See the `Components and layouts <#heading=h.y07c734ecnau>`__ section below.
         - Begin phased migration
      - 

         - You or your design team haven’t migrated the app’s design system from
            M2 to M3
         - Migrate design system from M2 to M3, then begin phased migration

   Even if you're affected by the above scenarios you should take a phased
   approach to migration before committing and releasing an app update. In these
   cases, you would use M2 and M3 side-by-side, and gradually phase out M2 while
   migrating to M3.

   .. rubric:: Phased approach
      :name: phased-approach

   The general steps to a phased migration are as follows:

   #. Add M3 dependency alongside M2 dependency.
   #. Add M3 version(s) of your app’s theme(s) alongside M2 version(s) of your
      app’s theme(s).
   #. Migrate individual modules, screens, or composables to M3, depending on
      the size and complexity of your app (see below sections for details).
   #. Once fully migrated, remove the M2 version(s) of your app’s theme(s).
   #. Remove M2 dependency.

   .. rubric:: Dependencies
      :name: dependencies

   M3 has a separate package and version to M2:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2

         .. code:: prettyprint

            implementation "androidx.compose.material:material:$m2-version"

      .. container:: section

         .. rubric:: M3
            :name: m3

         .. code:: prettyprint

            implementation "androidx.compose.material3:material3:$m3-version"

   See the latest M3 versions on the `Compose Material 3 releases page  <#compose-material3>`__.

   Other Material dependencies outside of the main M2 and M3 libraries have not
   changed. They use a mix of the M2 and M3 packages and versions, but this has
   no impact on migration. They can be used as-is with M3:

   .. list-table::
      :header-rows: 1

      - 

         - Library
         - Package and version
      - 

         - `Compose Material Icons  <#package-summary>`__
         - ``androidx.compose.material:material-icons-*:$m2-version``
      - 

         - `Compose Material Ripple  <#package-summary>`__
         - ``androidx.compose.material:material-ripple:$m2-version``
      - 

         - `Compose Material 3 Window Size Class  <#package-summary>`__
         - ``androidx.compose.material3:material3-window-size-class:$m3-version``

   .. rubric:: Experimental APIs
      :name: experimental-apis

   Some M3 APIs are considered experimental. In such cases you need to opt in at
   the function or file level using the
   `ExperimentalMaterial3Api  <#ExperimentalMaterial3Api>`__
   annotation:

   .. code:: prettyprint

      import androidx.compose.material3.ExperimentalMaterial3Api

      @OptIn(ExperimentalMaterial3Api::class)
      @Composable
      fun AppComposable() {
          // M3 composables
      }

   .. rubric:: Theming
      :name: theming

   In both M2 and M3, the theme composable is named ``MaterialTheme`` but the
   import packages and parameters differ:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_1

         .. code:: prettyprint

            import androidx.compose.material.MaterialTheme

            MaterialTheme(
                colors = AppColors,
                typography = AppTypography,
                shapes = AppShapes
            ) {
                // M2 content
            }

      .. container:: section

         .. rubric:: M3
            :name: m3_1

         .. code:: prettyprint

            import androidx.compose.material3.MaterialTheme

            MaterialTheme(
                colorScheme = AppColorScheme,
                typography = AppTypography,
                shapes = AppShapes
            ) {
                // M3 content
            }

   **Note:**\  The parameters are different for the two types of
   ``MaterialTheme``. This results in errors after the change. See the
   `Color  <#color>`__,
   `Typography  <#typography>`__
   and `Shape  <#shape>`__
   sections on how to resolve this.

   .. rubric:: Color
      :name: color

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/migration-color-update.png
      name: image-1
      :alt: Comparison of the M2 to M3 color systems
      :width: 100.0%

      **Figure 1**. M2 color system (left) versus M3 color system (right).

   The `color system <https://m3.material.io/styles/color/overview>`__ in M3 is
   significantly different to M2. The number of color parameters has increased,
   they have different names, and they map differently to M3 components. In
   Compose, this applies to the M2
   `Colors  <#Colors>`__ class,
   the M3
   `ColorScheme  <#ColorScheme>`__
   class, and related functions:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_2

         .. code:: prettyprint

            import androidx.compose.material.lightColors
            import androidx.compose.material.darkColors

            val AppLightColors = lightColors(
                // M2 light Color parameters
            )
            val AppDarkColors = darkColors(
                // M2 dark Color parameters
            )
            val AppColors = if (darkTheme) {
                AppDarkColors
            } else {
                AppLightColors
            }

      .. container:: section

         .. rubric:: M3
            :name: m3_2

         .. code:: prettyprint

            import androidx.compose.material3.lightColorScheme
            import androidx.compose.material3.darkColorScheme

            val AppLightColorScheme = lightColorScheme(
                // M3 light Color parameters
            )
            val AppDarkColorScheme = darkColorScheme(
                // M3 dark Color parameters
            )
            val AppColorScheme = if (darkTheme) {
                AppDarkColorScheme
            } else {
                AppLightColorScheme
            }

   Given the significant differences between the M2 and M3 color systems,
   there’s no reasonable mapping for
   `Color  <#isLight>`__
   parameters. Instead, use the `Material Theme Builder tool <https://m3.material.io/theme-builder>`__ to generate an M3 color
   scheme. Use the M2 colors as “core” source colors in the tool, which the tool
   expands into tonal palettes used by the M3 color scheme. The following
   mappings are recommended as a starting point:

   .. list-table::
      :header-rows: 1

      - 

         - M2
         - Material Theme Builder
      - 

         - ``primary``
         - Primary
      - 

         - ``primaryVariant``
         - Secondary
      - 

         - ``secondary``
         - Tertiary
      - 

         - ``surface`` or ``background``
         - Neutral

   **Note:**\  Some M2 and M3 colors are named the same, such as primary and
   secondary. However, their hex code values may not be the same. This is
   because Material Theme Builder uses an algorithm to generate tonal palettes
   from the M2 colors, which the tools use in the M3 color scheme.
   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/migration-colorscheme-update.png
      name: image-2
      :alt: M2 colors used in Material Theme Builder to generate an M3 color
      scheme
      :width: 85.0%

      **Figure 2**. Jetchat's M2 colors used in Material Theme Builder to
      generate an M3 color scheme.

   You can copy the color hex code values for light and dark themes from the
   tool and use them to implement an M3 ColorScheme instance. Alternatively,
   Material Theme Builder can export Compose code.

   .. rubric:: ``isLight``
      :name: islight

   Unlike the M2 ``Colors`` class, the M3 ``ColorScheme`` class doesn’t include
   an
   `isLight  <#isLight>`__
   parameter. In general you should try and model whatever needs this
   information at the theme level. For example:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_3

         .. code:: prettyprint

            import androidx.compose.material.lightColors
            import androidx.compose.material.darkColors
            import androidx.compose.material.MaterialTheme

            @Composable
            private fun AppTheme(
              darkTheme: Boolean = isSystemInDarkTheme(),
              content: @Composable () -> Unit
            ) {
              val colors = if (darkTheme) darkColors(…) else lightColors(…)
              MaterialTheme(
                  colors = colors,
                  content = content
              )
            }

            @Composable
            fun AppComposable() {
                AppTheme {
                    val cardElevation = if (MaterialTheme.colors.isLight) 0.dp else 4.dp
                    …
                }
            }

      .. container:: section

         .. rubric:: M3
            :name: m3_3

         .. code:: prettyprint

            import androidx.compose.material3.lightColorScheme
            import androidx.compose.material3.darkColorScheme
            import androidx.compose.material3.MaterialTheme

            val LocalCardElevation = staticCompositionLocalOf { Dp.Unspecified }
            @Composable
            private fun AppTheme(
               darkTheme: Boolean = isSystemInDarkTheme(),
                content: @Composable () -> Unit
            ) {
               val cardElevation = if (darkTheme) 4.dp else 0.dp
                CompositionLocalProvider(LocalCardElevation provides cardElevation) {
                    val colorScheme = if (darkTheme) darkColorScheme(…) else lightColorScheme(…)
                    MaterialTheme(
                        colorScheme = colorScheme,
                        content = content
                    )
                }
            }

            @Composable
            fun AppComposable() {
                AppTheme {
                    val cardElevation = LocalCardElevation.current
                    …
                }
            }

   See the `Custom design systems in Compose guide  <#custom>`__ for more information.

   .. rubric:: Dynamic color
      :name: dynamic-color

   A new feature in M3 is `dynamic color <https://m3.material.io/styles/color/dynamic-color/overview>`__.
   Instead of using custom colors, an M3 ``ColorScheme`` can make use of device
   wallpaper colors on Android 12 and above, using the following functions:

   -  `dynamicLightColorScheme  <#dynamiclightcolorscheme>`__
   -  `dynamicDarkColorScheme  <#dynamicdarkcolorscheme>`__

   **Note:**\  Even if you choose to use a dynamic color scheme, you almost
   always need a fallback custom color scheme given the Android 12 and above
   restriction. See
   `Jetchat <https://github.com/android/compose-samples/blob/main/Jetchat/app/src/main/java/com/example/compose/jetchat/theme/Themes.kt#L91>`__
   as an example.

   .. rubric:: Typography
      :name: typography

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/migration-typography-update.png
      name: image-3
      :alt: Comparison of M2 and M3 typography systems
      :width: 85.0%

      **Figure 3**. M3 typography system (left) versus M2 typography system
      (right)

   The `typography system <https://m3.material.io/styles/typography/overview>`__
   in M3 is different to M2. The number of typography parameters is roughly the
   same, but they have different names and they map differently to M3
   components. In Compose, this applies to the M2
   `Typography  <#Typography>`__
   class and the M3
   `Typography  <#Typography>`__
   class:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_4

         .. code:: prettyprint

            import androidx.compose.material.Typography

            val AppTypography = Typography(
                // M2 TextStyle parameters
            )

      .. container:: section

         .. rubric:: M3
            :name: m3_4

         .. code:: prettyprint

            import androidx.compose.material3.Typography

            val AppTypography = Typography(
                // M3 TextStyle parameters
            )

   The following
   `TextStyle  <#TextStyle>`__
   parameter mappings are recommended as a starting point:

   .. list-table::
      :header-rows: 1

      - 

         - M2
         - M3
      - 

         - ``h1``
         - ``displayLarge``
      - 

         - ``h2``
         - ``displayMedium``
      - 

         - ``h3``
         - ``displaySmall``
      - 

         - N/A
         - ``headlineLarge``
      - 

         - ``h4``
         - ``headlineMedium``
      - 

         - ``h5``
         - ``headlineSmall``
      - 

         - ``h6``
         - ``titleLarge``
      - 

         - ``subtitle1``
         - ``titleMedium``
      - 

         - ``subtitle2``
         - ``titleSmall``
      - 

         - ``body1``
         - ``bodyLarge``
      - 

         - ``body2``
         - ``bodyMedium``
      - 

         - ``caption``
         - ``bodySmall``
      - 

         - ``button``
         - ``labelLarge``
      - 

         - N/A
         - ``labelMedium``
      - 

         - ``overline``
         - ``labelSmall``

   **Note:**\  Unlike the M2 ``Typography`` class, the M3 ``Typography`` class
   doesn’t currently include a ``defaultFontFamily`` parameter. You’ll need to
   use the ``fontFamily`` parameter in each of the individual ``TextStyles``
   instead.

   .. rubric:: Shape
      :name: shape

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/migration-shape-update.png
      name: image-4
      :alt: Comparison of M2 and M3 shape systems
      :width: 80.0%

      **Figure 4**. M2 shape system (left) vs M3 shape system (right)

   The `shape system <https://m3.material.io/styles/shape/overview>`__ in M3 is
   different to M2. The number of shape parameters has increased, they’re named
   differently and they map differently to M3 components. In Compose, this
   applies to the M2
   `Shapes  <#Shapes>`__ class and
   the M3 `Shapes  <#Shapes>`__
   class:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_5

         .. code:: prettyprint

            import androidx.compose.material.Shapes

            val AppShapes = Shapes(
                // M2 Shape parameters
            )

      .. container:: section

         .. rubric:: M3
            :name: m3_5

         .. code:: prettyprint

            import androidx.compose.material3.Shapes

            val AppShapes = Shapes(
                // M3 Shape parameters
            )

   The following
   `Shape  <#Shape>`__
   parameter mappings are recommended as a starting point:

   .. list-table::
      :header-rows: 1

      - 

         - M2
         - M3
      - 

         - N/A
         - ``extraSmall``
      - 

         - ``small``
         - ``small``
      - 

         - ``medium``
         - ``medium``
      - 

         - ``large``
         - ``large``
      - 

         - N/A
         - ``extraLarge``

   **Note:**\  The M3 shape system also defines “none” and “full” styles which
   are constant and not part of the ``Shapes`` class. Use
   `RectangleShape  <#RectangleShape>`__
   and
   `CircleShape  <#CircleShape>`__
   respectively for these.

   .. rubric:: Components and layouts
      :name: components-and

   Most components and layouts from M2 are available in M3. There are, however,
   some missing as well as new ones that didn’t exist in M2. Furthermore, some
   M3 components have more variations than their equivalents in M2. In general
   the M3 API surfaces attempt to be as similar as possible to their closest
   equivalents in M2.

   Given the updated color, typography and shape systems, M3 components tend to
   map differently to the new theming values. It’s a good idea to check out the
   `tokens directory <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material3/material3/src/commonMain/kotlin/androidx/compose/material3/tokens/>`__
   in the Compose Material 3 source code as a source of truth for these
   mappings.

   While some components require special considerations, the following function
   mappings are recommended as a starting point:

   **Missing APIs**:

   .. list-table::
      :header-rows: 1

      - 

         - M2
         - M3
      - 

         - `androidx.compose.material.swipeable  <#swipeable>`__
         - Not available yet

   **Replaced APIs**:

   .. list-table::
      :header-rows: 1

      - 

         - M2
         - M3
      - 

         - `androidx.compose.material.BackdropScaffold  <#backdropscaffold>`__
         - No M3 equivalent, migrate to
            `Scaffold  <#scaffold>`__
            or
            `BottomSheetScaffold  <#bottomsheetscaffold>`__
            instead
      - 

         - `androidx.compose.material.BottomDrawer  <#bottomdrawer>`__
         - No M3 equivalent, migrate to
            `ModalBottomSheet  <#modalbottomsheet>`__
            instead

   **Renamed APIs**:

   .. list-table::
      :header-rows: 1

      - 

         - M2
         - M3
      - 

         - `androidx.compose.material.BottomNavigation  <#bottomnavigation>`__
         - `androidx.compose.material3.NavigationBar  <#navigationbar>`__
      - 

         - `androidx.compose.material.BottomNavigationItem  <#bottomnavigationitem>`__
         - `androidx.compose.material3.NavigationBarItem  <#navigationbaritem>`__
      - 

         - `androidx.compose.material.Chip  <#chip>`__
         - `androidx.compose.material3.AssistChip  <#assistchip>`__
            or
            `androidx.compose.material3.SuggestionChip  <#suggestionchip>`__
      - 

         - `androidx.compose.material.ModalBottomSheetLayout  <#modalbottomsheetlayout>`__
         - `androidx.compose.material3.ModalBottomSheet  <#modalbottomsheet>`__
      - 

         - `androidx.compose.material.ModalDrawer  <#modaldrawer>`__
         - `androidx.compose.material3.ModalNavigationDrawer  <#modalnavigationdrawer>`__

   **All other APIs**:

   .. list-table::
      :header-rows: 1

      - 

         - M2
         - M3
      - 

         - `androidx.compose.material.AlertDialog  <#alertdialog>`__
         - `androidx.compose.material3.AlertDialog  <#alertdialog>`__
      - 

         - `androidx.compose.material.Badge  <#badge>`__
         - `androidx.compose.material3.Badge  <#badge>`__
      - 

         - `androidx.compose.material.BadgedBox  <#badgedbox>`__
         - `androidx.compose.material3.BadgedBox  <#badgedbox>`__
      - 

         - `androidx.compose.material.BottomAppBar  <#bottomappbar>`__
         - `androidx.compose.material3.BottomAppBar  <#bottomappbar>`__
      - 

         - `androidx.compose.material.BottomSheetScaffold  <#bottomsheetscaffold>`__
         - `androidx.compose.material3.BottomSheetScaffold  <#bottomsheetscaffold>`__
      - 

         - `androidx.compose.material.Button  <#button>`__
         - `androidx.compose.material3.Button  <#button>`__
      - 

         - `androidx.compose.material.Card  <#card>`__
         - `androidx.compose.material3.Card  <#card>`__
      - 

         - `androidx.compose.material.Checkbox  <#checkbox>`__
         - `androidx.compose.material3.Checkbox  <#checkbox>`__
      - 

         - `androidx.compose.material.CircularProgressIndicator  <#circularprogressindicator>`__
         - `androidx.compose.material3.CircularProgressIndicator  <#circularprogressindicator>`__
      - 

         - `androidx.compose.material.Divider  <#divider>`__
         - `androidx.compose.material3.Divider  <#divider>`__
      - 

         - `androidx.compose.material.DropdownMenu  <#dropdownmenu>`__
         - `androidx.compose.material3.DropdownMenu  <#dropdownmenu>`__
      - 

         - `androidx.compose.material.DropdownMenuItem  <#dropdownmenuitem>`__
         - `androidx.compose.material3.DropdownMenuItem  <#dropdownmenuitem>`__
      - 

         - `androidx.compose.material.ExposedDropdownMenuBox  <#exposeddropdownmenubox>`__
         - `androidx.compose.material3.ExposedDropdownMenuBox  <#exposeddropdownmenubox>`__
      - 

         - `androidx.compose.material.ExtendedFloatingActionButton  <#extendedfloatingactionbutton>`__
         - `androidx.compose.material3.ExtendedFloatingActionButton  <#extendedfloatingactionbutton>`__
      - 

         - `androidx.compose.material.FilterChip  <#filterchip>`__
         - `androidx.compose.material3.FilterChip  <#filterchip>`__
      - 

         - `androidx.compose.material.FloatingActionButton  <#floatingactionbutton>`__
         - `androidx.compose.material3.FloatingActionButton  <#floatingactionbutton>`__
      - 

         - `androidx.compose.material.Icon  <#icon>`__
         - `androidx.compose.material3.Icon  <#icon>`__
      - 

         - `androidx.compose.material.IconButton  <#iconbutton>`__
         - `androidx.compose.material3.IconButton  <#iconbutton>`__
      - 

         - `androidx.compose.material.IconToggleButton  <#icontogglebutton>`__
         - `androidx.compose.material3.IconToggleButton  <#icontogglebutton>`__
      - 

         - `androidx.compose.material.LeadingIconTab  <#leadingicontab>`__
         - `androidx.compose.material3.LeadingIconTab  <#leadingicontab>`__
      - 

         - `androidx.compose.material.LinearProgressIndicator  <#linearprogressindicator>`__
         - `androidx.compose.material3.LinearProgressIndicator  <#linearprogressindicator>`__
      - 

         - `androidx.compose.material.ListItem  <#listitem>`__
         - `androidx.compose.material3.ListItem  <#listitem>`__
      - 

         - `androidx.compose.material.NavigationRail  <#navigationrail>`__
         - `androidx.compose.material3.NavigationRail  <#navigationrail>`__
      - 

         - `androidx.compose.material.NavigationRailItem  <#navigationrailitem>`__
         - `androidx.compose.material3.NavigationRailItem  <#navigationrailitem>`__
      - 

         - `androidx.compose.material.OutlinedButton  <#outlinedbutton>`__
         - `androidx.compose.material3.OutlinedButton  <#outlinedbutton>`__
      - 

         - `androidx.compose.material.OutlinedTextField  <#outlinedtextfield>`__
         - `androidx.compose.material3.OutlinedTextField  <#outlinedtextfield>`__
      - 

         - `androidx.compose.material.RadioButton  <#radiobutton>`__
         - `androidx.compose.material3.RadioButton  <#radiobutton>`__
      - 

         - `androidx.compose.material.RangeSlider  <#rangeslider>`__
         - `androidx.compose.material3.RangeSlider  <#rangeslider>`__
      - 

         - `androidx.compose.material.Scaffold  <#scaffold>`__
         - `androidx.compose.material3.Scaffold  <#scaffold>`__
      - 

         - `androidx.compose.material.ScrollableTabRow  <#scrollabletabrow>`__
         - `androidx.compose.material3.ScrollableTabRow  <#scrollabletabrow>`__
      - 

         - `androidx.compose.material.Slider  <#slider>`__
         - `androidx.compose.material3.Slider  <#slider>`__
      - 

         - `androidx.compose.material.Snackbar  <#snackbar>`__
         - `androidx.compose.material3.Snackbar  <#snackbar>`__
      - 

         - `androidx.compose.material.Switch  <#switch>`__
         - `androidx.compose.material3.Switch  <#switch>`__
      - 

         - `androidx.compose.material.Tab  <#tab>`__
         - `androidx.compose.material3.Tab  <#tab>`__
      - 

         - `androidx.compose.material.TabRow  <#tabrow>`__
         - `androidx.compose.material3.TabRow  <#tabrow>`__
      - 

         - `androidx.compose.material.Text  <#text>`__
         - `androidx.compose.material3.Text  <#text>`__
      - 

         - `androidx.compose.material.TextButton  <#textbutton>`__
         - `androidx.compose.material3.TextButton  <#textbutton>`__
      - 

         - `androidx.compose.material.TextField  <#textfield>`__
         - `androidx.compose.material3.TextField  <#textfield>`__
      - 

         - `androidx.compose.material.TopAppBar  <#topappbar>`__
         - `androidx.compose.material3.TopAppBar  <#topappbar>`__
      - 

         - `androidx.compose.material.TriStateCheckbox  <#tristatecheckbox>`__
         - `androidx.compose.material3.TriStateCheckbox  <#tristatecheckbox>`__

   See the latest M3 components and layouts on the `Compose Material 3 API reference overview  <#overview>`__,
   and keep an eye out on the `releases page  <#compose-material3>`__ for new and updated
   APIs.

   .. rubric:: Scaffold, snackbars and navigation drawer
      :name: scaffold,-snackbars

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/migration-scaffold-update.gif
      name: image-5
      :alt: Comparison of M2 and M3 scaffold with snackbar and navigation drawer
      :width: 70.0%

      **Figure 5**. M2 scaffold with snackbar and navigation drawer (left)
      versus M3 scaffold with snackbar and navigation drawer (right).

   Scaffold in M3 is different to M2. In both M2 and M3, the main layout
   composable is named ``Scaffold`` but the import packages and parameters
   differ:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_6

         .. code:: prettyprint

            import androidx.compose.material.Scaffold

            Scaffold(
                // M2 scaffold parameters
            )

      .. container:: section

         .. rubric:: M3
            :name: m3_6

         .. code:: prettyprint

            import androidx.compose.material3.Scaffold

            Scaffold(
                // M3 scaffold parameters
            )

   The M2
   `Scaffold  <#scaffold>`__
   contains a ``backgroundColor`` parameter is now named to ``containerColor``
   in the M3
   `Scaffold  <#scaffold>`__:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_7

         .. code:: prettyprint

            import androidx.compose.material.Scaffold

            Scaffold(
                backgroundColor = …,
                content = { … }
            )

      .. container:: section

         .. rubric:: M3
            :name: m3_7

         .. code:: prettyprint

            import androidx.compose.material3.Scaffold

            Scaffold(
                containerColor = …,
                content = { … }
            )

   The M2
   `ScaffoldState  <#ScaffoldState>`__
   class no longer exists in M3 as it contains a
   `drawerState  <#drawerState>`__
   parameter which is no longer needed. To show snackbars with the M3
   ``Scaffold``, use
   `SnackbarHostState  <#SnackbarHostState>`__
   instead:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_8

         .. code:: prettyprint

            import androidx.compose.material.Scaffold
            import androidx.compose.material.rememberScaffoldState

            val scaffoldState = rememberScaffoldState()
            val scope = rememberCoroutineScope()

            Scaffold(
                scaffoldState = scaffoldState,
                content = {
                    …
                    scope.launch {
                        scaffoldState.snackbarHostState.showSnackbar(…)
                    }
                }
            )

      .. container:: section

         .. rubric:: M3
            :name: m3_8

         .. code:: prettyprint

            import androidx.compose.material3.Scaffold
            import androidx.compose.material3.SnackbarHost
            import androidx.compose.material3.SnackbarHostState

            val snackbarHostState = remember { SnackbarHostState() }
            val scope = rememberCoroutineScope()

            Scaffold(
                snackbarHost = { SnackbarHost(snackbarHostState) },
                content = {
                    …
                    scope.launch {
                        snackbarHostState.showSnackbar(…)
                    }
                }
            )

   **Note:**\  The
   `SnackbarData  <#SnackbarData>`__
   class in M2 has been split into
   `SnackbarData  <#SnackbarData>`__
   and
   `SnackbarVisuals  <#SnackbarVisuals>`__
   in M3.
   All of the ``drawer*`` parameters from the M2 ``Scaffold`` have been removed
   from the M3 ``Scaffold``. These include parameters such as ``drawerShape``
   and ``drawerContent``. To show a drawer with the M3 ``Scaffold``, use a
   navigation drawer composable, such as
   `ModalNavigationDrawer  <#modalnavigationdrawer>`__,
   instead:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_9

         .. code:: prettyprint

            import androidx.compose.material.DrawerValue
            import
            import androidx.compose.material.Scaffold
            import androidx.compose.material.rememberDrawerState
            import androidx.compose.material.rememberScaffoldState

            val scaffoldState = rememberScaffoldState(
                drawerState = rememberDrawerState(DrawerValue.Closed)
            )
            val scope = rememberCoroutineScope()

            Scaffold(
                scaffoldState = scaffoldState,
                drawerContent = { … },
                drawerGesturesEnabled = …,
                drawerShape = …,
                drawerElevation = …,
                drawerBackgroundColor = …,
                drawerContentColor = …,
                drawerScrimColor = …,
                content = {
                    …
                    scope.launch {
                        scaffoldState.drawerState.open()
                    }
                }
            )

      .. container:: section

         .. rubric:: M3
            :name: m3_9

         .. code:: prettyprint

            import androidx.compose.material3.DrawerValue
            import androidx.compose.material3.ModalDrawerSheet
            import androidx.compose.material3.ModalNavigationDrawer
            import androidx.compose.material3.Scaffold
            import androidx.compose.material3.rememberDrawerState

            val drawerState = rememberDrawerState(DrawerValue.Closed)
            val scope = rememberCoroutineScope()

            ModalNavigationDrawer(
                drawerState = drawerState,
                drawerContent = {
                    ModalDrawerSheet(
                        drawerShape = …,
                        drawerTonalElevation = …,
                        drawerContainerColor = …,
                        drawerContentColor = …,
                        content = { … }
                    )
                },
                gesturesEnabled = …,
                scrimColor = …,
                content = {
                    Scaffold(
                        content = {
                            …
                            scope.launch {
                                drawerState.open()
                            }
                        }
                    )
                }
            )

   .. rubric:: Top app bar
      :name: top-app

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/migration-topbar-update.png
      name: image-6
      :alt: Comparison of M2 and M3 scaffold with top app bar and scrolled list
      :width: 70.0%

      **Figure 6**. M2 scaffold with top app bar and scrolled list (left) versus
      M3 scaffold with top app bar and scrolled list (right)

   `Top app bars <https://m3.material.io/components/top-app-bar/overview>`__ in
   M3 are different to those in M2. In both M2 and M3, the main top app bar
   composable is named ``TopAppBar`` but the import packages and parameters
   differ:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_10

         .. code:: prettyprint

            import androidx.compose.material.TopAppBar

            TopAppBar(…)

      .. container:: section

         .. rubric:: M3
            :name: m3_10

         .. code:: prettyprint

            import androidx.compose.material3.TopAppBar

            TopAppBar(…)

   Consider using the M3
   `CenterAlignedTopAppBar  <#centeralignedtopappbar>`__
   if you were previously centering content within the M2 ``TopAppBar``. It’s
   good to be aware of the
   `MediumTopAppBar  <#mediumtopappbar>`__
   and
   `LargeTopAppBar  <#largetopappbar>`__
   as well.

   M3 top app bars contain a new ``scrollBehavior`` parameter to provide
   different functionality on scroll through the
   `TopAppBarScrollBehavior  <#TopAppBarScrollBehavior>`__
   class, such as changing elevation. This works in conjunction with scrolling
   content via
   `Modifer.nestedScroll  <#nestedscroll>`__.
   This was possible in the M2 ``TopAppBar`` by manually changing the
   ``elevation`` parameter:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_11

         .. code:: prettyprint

            import androidx.compose.material.AppBarDefaults
            import androidx.compose.material.Scaffold
            import androidx.compose.material.TopAppBar

            val state = rememberLazyListState()
            val isAtTop by remember {
                derivedStateOf {
                    state.firstVisibleItemIndex == 0 && state.firstVisibleItemScrollOffset == 0
                }
            }

            Scaffold(
                topBar = {
                    TopAppBar(
                        elevation = if (isAtTop) {
                            0.dp
                        } else {
                            AppBarDefaults.TopAppBarElevation
                        },
                        …
                    )
                },
                content = {
                    LazyColumn(state = state) { … }
                }
            )

      .. container:: section

         .. rubric:: M3
            :name: m3_11

         .. code:: prettyprint

            import androidx.compose.material3.Scaffold
            import androidx.compose.material3.TopAppBar
            import androidx.compose.material3.TopAppBarDefaults

            val scrollBehavior = TopAppBarDefaults.pinnedScrollBehavior()

            Scaffold(
                modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),
                topBar = {
                    TopAppBar(
                        scrollBehavior = scrollBehavior,
                        …
                    )
                },
                content = {
                    LazyColumn { … }
                }
            )

   .. rubric:: Bottom navigation / Navigation bar
      :name: bottom-navigation

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/migration-bottomnav-update.png
      name: image-7
      :alt: Comparison of M2 bottom navigation and M3 navigation bar
      :width: 80.0%

      **Figure 7**. M2 bottom navigation (left) versus M3 navigation bar
      (right).

   Bottom navigation in M2 has been renamed to `navigation bar <https://m3.material.io/components/navigation-bar/overview>`__ in M3. In
   M2 there are the
   `BottomNavigation  <#bottomnavigation>`__
   and
   `BottomNavigationItem  <#bottomnavigationitem>`__
   composables, while in M3 there are the
   `NavigationBar  <#navigationbar>`__
   and
   `NavigationBarItem  <#navigationbaritem>`__
   composables:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_12

         .. code:: prettyprint

            import androidx.compose.material.BottomNavigation
            import androidx.compose.material.BottomNavigationItem

            BottomNavigation {
                BottomNavigationItem(…)
                BottomNavigationItem(…)
                BottomNavigationItem(…)
            }

      .. container:: section

         .. rubric:: M3
            :name: m3_12

         .. code:: prettyprint

            import androidx.compose.material3.NavigationBar
            import androidx.compose.material3.NavigationBarItem

            NavigationBar {
                NavigationBarItem(…)
                NavigationBarItem(…)
                NavigationBarItem(…)
            }

   .. rubric:: Buttons, icon buttons and FABs
      :name: buttons,-icon

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/migration-buttons-update.png
      name: image-8
      :alt: Comparison of M2 and M3 buttons
      :width: 70.0%

      **Figure 8**. M2 buttons (left) versus M3 buttons (right)

   `Buttons, icon buttons and floating action buttons (FABs) <https://m3.material.io/components/all-buttons>`__ in M3 are different
   to those in M2. M3 includes all of the M2 button composables:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_13

         .. code:: prettyprint

            import androidx.compose.material.Button
            import androidx.compose.material.ExtendedFloatingActionButton
            import androidx.compose.material.FloatingActionButton
            import androidx.compose.material.IconButton
            import androidx.compose.material.IconToggleButton
            import androidx.compose.material.OutlinedButton
            import androidx.compose.material.TextButton

            // M2 buttons
            Button(…)
            OutlinedButton(…)
            TextButton(…)
            // M2 icon buttons
            IconButton(…)
            IconToggleButton(…)
            // M2 FABs
            FloatingActionButton(…)
            ExtendedFloatingActionButton(…)

      .. container:: section

         .. rubric:: M3
            :name: m3_13

         .. code:: prettyprint

            import androidx.compose.material3.Button
            import androidx.compose.material3.ExtendedFloatingActionButton
            import androidx.compose.material3.FloatingActionButton
            import androidx.compose.material3.IconButton
            import androidx.compose.material3.IconToggleButton
            import androidx.compose.material3.OutlinedButton
            import androidx.compose.material3.TextButton

            // M3 buttons
            Button(…)
            OutlinedButton(…)
            TextButton(…)
            // M3 icon buttons
            IconButton(…)
            IconToggleButton(…)
            // M3 FABs
            FloatingActionButton(…)
            ExtendedFloatingActionButton(…)

   M3 also includes new button variations. Check them out on the `Compose Material 3 API reference overview  <#components>`__.

   .. rubric:: Switch
      :name: switch

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/migration-switch-update.png
      name: image-9
      :alt: Comparison of M2 and M3 switches
      :width: 70.0%

      **Figure 9**. M2 switch (left) versus M3 switch (right).

   `Switch <https://m3.material.io/components/switch/overview>`__ in M3 is
   different to M2. In both M2 and M3, the switch composable is named ``Switch``
   but the import packages differ:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_14

         .. code:: prettyprint

            import androidx.compose.material.Switch

            Switch(…)

      .. container:: section

         .. rubric:: M3
            :name: m3_14

         .. code:: prettyprint

            import androidx.compose.material3.Switch

            Switch(…)

   .. rubric:: Surfaces and elevation
      :name: surfaces-and

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/migration-elevation-update.png
      name: image-10
      :alt: Comparison of M2 surface elevation and M3 surface elevation in light
      and dark themes
      :width: 60.0%

      **Figure 10**. M2 surface elevation versus M3 surface elevation in light
      theme (left) and dark theme (right).

   The surface and elevation systems in M3 are different to M2. There are two
   types of elevation in M3:

   -  Shadow elevation (casts a shadow, same as M2)
   -  Tonal elevation (overlays a color, new to M3)

   In Compose this applies to the M2
   `Surface  <#surface>`__
   function and the M3
   `Surface  <#surface>`__
   function:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_15

         .. code:: prettyprint

            import androidx.compose.material.Surface

            Surface(
                elevation = …
            ) { … }

      .. container:: section

         .. rubric:: M3
            :name: m3_15

         .. code:: prettyprint

            import androidx.compose.material3.Surface

            Surface(
                shadowElevation = …,
                tonalElevation = …
            ) { … }

   You can use the ``elevation``
   `Dp  <#Dp>`__ values in M2 for
   both ``shadowElevation`` and/or ``tonalElevation`` in M3, depending on the
   UX/UI design preference. ``Surface`` is the backing composable behind most
   components, so component composables might also expose elevation parameters
   you must migrate in the same way.

   **Note:**\  The default color used by ``tonalElevation`` in M3 is
   ``primary``. You can override this by using the ``surfaceTint`` parameter in
   the ``ColorScheme`` class.
   Tonal elevation in M3 replaces the concept of elevation overlays in M2 dark
   themes . As a result,
   `ElevationOverlay  <#ElevationOverlay>`__
   and
   `LocalElevationOverlay  <#LocalElevationOverlay>`__
   don’t exist in M3, and
   `LocalAbsoluteElevation  <#LocalAbsoluteElevation>`__
   in M2 has changed to
   `LocalAbsoluteTonalElevation  <#LocalAbsoluteTonalElevation>`__
   in M3.

   .. rubric:: Emphasis and content alpha
      :name: emphasis-and

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/migration-emphasis-update.png
      name: image-11
      :alt: Comparison of M2 and M3 icon and text emphasis
      :width: 55.0%

      **Figure 11**. M2 icon and text emphasis (left) versus M3 icon and text
      emphasis (right)

   Emphasis in M3 is significantly different to M2. In M2 emphasis involved
   using “on” colors with certain alpha values to differentiate content like
   text and icons. In M3, there are now a couple different approaches:

   -  Using “on” colors alongside their “variant on” colors from the expanded M3
      color system.
   -  Using different font weights for text.

   As a result,
   `ContentAlpha  <#ContentAlpha>`__
   and
   `LocalContentAlpha  <#LocalContentAlpha>`__
   don't exist in M3 and need to be replaced.

   **Note:**\  For disabled states in M3, it’s still acceptable to use “on”
   colors with alpha values, like in M2.
   The following mappings are recommended as a starting point:

   .. list-table::
      :header-rows: 1

      - 

         - M2
         - M3
      - 

         - ``onSurface`` with
            `ContentAlpha.high  <#high>`__
         - ``onSurface`` in general,
            `FontWeight.Medium  <#Medium>`__
            -
            `FontWeight.Black  <#Black>`__
            for text
      - 

         - ``onSurface`` with
            `ContentAlpha.medium  <#medium>`__
         - ``onSurfaceVariant`` in general,
            `FontWeight.Thin  <#Thin>`__
            -
            `FontWeight.Normal  <#Normal>`__
            for text
      - 

         - ``onSurface`` with
            `ContentAlpha.disabled  <#high>`__
         - ``onSurface.copy(alpha = 0.38f)``

   Here’s an example of icon emphasis in M2 vs. M3:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_16

         .. code:: prettyprint

            import androidx.compose.material.ContentAlpha
            import androidx.compose.material.LocalContentAlpha

            // High emphasis
            CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.high) {
                Icon(…)
            }
            // Medium emphasis
            CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                Icon(…)
            }
            // Disabled emphasis
            CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.disabled) {
                Icon(…)
            }

      .. container:: section

         .. rubric:: M3
            :name: m3_16

         .. code:: prettyprint

            import androidx.compose.material3.LocalContentColor

            // High emphasis
            CompositionLocalProvider(LocalContentColor provides MaterialTheme.colorScheme.onSurface) {
                Icon(…)
            }
            // Medium emphasis
            CompositionLocalProvider(LocalContentColor provides MaterialTheme.colorScheme.onSurfaceVariant) {
                Icon(…)
            }
            // Disabled emphasis
            CompositionLocalProvider(LocalContentColor provides MaterialTheme.colorScheme.onSurface.copy(alpha = 0.38f)) {
                Icon(…)
            }

   Here’s an example of text emphasis in M2 vs. M3:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_17

         .. code:: prettyprint

            import androidx.compose.material.ContentAlpha
            import androidx.compose.material.LocalContentAlpha

            // High emphasis
            CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.high) {
                Text(…)
            }
            // Medium emphasis
            CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
                Text(…)
            }
            // Disabled emphasis
            CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.disabled) {
                Text(…)
            }

      .. container:: section

         .. rubric:: M3
            :name: m3_17

         .. code:: prettyprint

            import androidx.compose.material3.LocalContentColor

            // High emphasis
            Text(
                …,
                fontWeight = FontWeight.Bold
            )
            // Medium emphasis
            Text(
                …,
                fontWeight = FontWeight.Normal
            )
            // Disabled emphasis
            CompositionLocalProvider(LocalContentColor provides MaterialTheme.colorScheme.onSurface.copy(alpha = 0.38f)) {
                Text(
                    …,
                    fontWeight = FontWeight.Normal
                )
            }

   .. rubric:: Backgrounds and containers
      :name: backgrounds-and

   Backgrounds in M2 are named “containers” in M3. In general, you can replace
   ``background*`` parameters in M2 with ``container*`` in M3, using the same
   values. For example:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_18

         .. code:: prettyprint

            Badge(
                backgroundColor = MaterialTheme.colors.primary
            ) { … }

      .. container:: section

         .. rubric:: M3
            :name: m3_18

         .. code:: prettyprint

            Badge(
                containerColor = MaterialTheme.colorScheme.primary
            ) { … }

   .. rubric:: Views interoperability
      :name: views-interoperability

   If your app includes Views or XML interoperability and uses the `MDC-Android Compose Theme Adapter library <https://github.com/material-components/material-components-android-compose-theme-adapter>`__,
   you need to use the M3 version:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_19

         .. code:: prettyprint

            implementation "com.google.android.material:compose-theme-adapter:$compose-theme-adapter-version"

      .. container:: section

         .. rubric:: M3
            :name: m3_19

         .. code:: prettyprint

            implementation "com.google.android.material:compose-theme-adapter-3:$compose-theme-adapter-3-version"

   See the latest versions on the `MDC-Android Compose Theme Adapter releases page <https://github.com/material-components/material-components-android-compose-theme-adapter/releases>`__.

   The major difference between the M2 and M3 versions is the respective
   ``MdcTheme`` and ``Mdc3Theme`` composables:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: M2
            :name: m2_20

         .. code:: prettyprint

            import com.google.android.material.composethemeadapter.MdcTheme

            MdcTheme {
                // M2 content
            }

      .. container:: section

         .. rubric:: M3
            :name: m3_20

         .. code:: prettyprint

            import com.google.android.material.composethemeadapter3.Mdc3Theme

            Mdc3Theme {
                // M3 content
            }

   See the
   `README <https://github.com/material-components/material-components-android-compose-theme-adapter/blob/develop/README.md>`__
   for more information.

   **Note:**\  The M3 version assumes the XML theme is a descendant of
   ``Theme.Material3.*``, rather than ``Theme.MaterialComponents.*``, so you
   likely need to update this too.
   See the `Migrating to Material Design 3 guide <https://material.io/blog/migrating-material-3>`__ for more information
   on migrating from Material 2 to Material 3 in Views.

   .. rubric:: Useful links
      :name: useful-links

   To learn more about migrating from M2 to M3 in Compose, consult the following
   additional resources.

   .. rubric:: Docs
      :name: docs

   -  `Material Design 3 in Compose  <#material3>`__

   .. rubric:: Sample apps
      :name: sample-apps

   -  `Reply M3 sample app <https://github.com/android/compose-samples/tree/main/Reply>`__
   -  Jetchat sample app M2 to M3 migration

      -  `Initial alpha01 migration <https://github.com/android/compose-samples/pull/690>`__
      -  `Follow-up alpha10 update <https://github.com/android/compose-samples/pull/798>`__

   -  `Jetnews sample app M2 to M3 migration <https://github.com/android/compose-samples/pull/964>`__
   -  `Jetsurvey sample app M2 to M3 migration <https://github.com/android/compose-samples/pull/954>`__
   -  `Now in Android M3 hero app :core-designsystem module <https://github.com/android/nowinandroid/tree/main/core/designsystem>`__

   .. rubric:: Videos
      :name: videos

   -  `Implementing Material You Using Jetpack Compose <https://www.youtube.com/watch?v=jrfuHyMlehc&t=5s>`__

   .. rubric:: API reference and source code
      :name: api-reference

   -  `Compose Material 3 API reference  <#package-summary>`__
   -  `Compose Material 3 samples in source code <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material3/material3/samples/src/main/java/androidx/compose/material3/samples/>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Material Design 2 in Compose  <#material>`__
   -  `Material Design 3 in Compose  <#material3>`__
   -  `Custom design systems in Compose  <#custom>`__

Last updated 2024-05-03 UTC.

/Material Design 2
==================

.. https://developer.android.google.cn/develop/ui/compose/designsystems/material?hl=en

.. container:: devsite-article-body clearfix

   Jetpack Compose offers an implementation of `Material Design <https://material.io/design/introduction>`__, a comprehensive design
   system for creating digital interfaces. The `Material Design components <https://material.io/components>`__ (buttons, cards, switches, and
   so on) are built on top of `Material Theming <https://material.io/design/material-theming/>`__, which is a
   systematic way to customize Material Design to better reflect your product’s
   brand. A Material Theme contains
   `color <https://material.io/design/color/>`__,
   `typography <https://material.io/design/typography/>`__ and
   `shape <https://material.io/design/shape/>`__ attributes. When you customize
   these attributes, your changes are automatically reflected in the components
   you use to build your app.

   Jetpack Compose implements these concepts with the
   `MaterialTheme  <#MaterialTheme>`__
   composable:

   .. code:: prettyprint

      MaterialTheme(
          colors = // ...
          typography = // ...
          shapes = // ...
      ) {
          // app content
      }Material2Snippets.kt

   Configure the parameters you pass to ``MaterialTheme`` to theme your
   application.

   |Two contrasting screenshots. The first uses default MaterialTheme styling,
   the second screenshot uses modified styling.|

   **Figure 1.** The first screenshot shows an app that does not configure
   ``MaterialTheme``, and so it uses default styling. The second screenshot
   shows an app that passes parameters to ``MaterialTheme`` to customize the
   styling.

   .. rubric:: Color
      :name: color

   Colors are modelled in Compose with the
   `Color  <#Color>`__ class, a
   simple data-holding class.

   .. code:: prettyprint

      val Red = Color(0xffff0000)
      val Blue = Color(red = 0f, green = 0f, blue = 1f)Material2Snippets.kt

   While you can organize these however you like (as top-level constants, within
   a singleton, or defined inline), we **strongly** recommend specifying colors
   in your theme and retrieving the colors from there. This approach makes it
   possible to easily support `dark theme  <#darktheme>`__ and nested themes.

   |Example of theme's color palette|

   **Figure 2.** The Material color system.

   Compose provides the
   `Colors  <#Colors>`__ class to
   model the `Material color system <https://material.io/design/color/>`__.
   ``Colors`` provides builder functions to create sets of
   `light  <#lightColors>`__
   or
   `dark  <#darkColors>`__
   colors:

   .. code:: prettyprint

      private val Yellow200 = Color(0xffffeb46)
      private val Blue200 = Color(0xff91a4fc)
      // ...

      private val DarkColors = darkColors(
          primary = Yellow200,
          secondary = Blue200,
          // ...
      )
      private val LightColors = lightColors(
          primary = Yellow500,
          primaryVariant = Yellow400,
          secondary = Blue700,
          // ...
      )Material2Snippets.kt

   Once you have defined your ``Colors`` you can pass them to a
   ``MaterialTheme``:

   .. code:: prettyprint

      MaterialTheme(
          colors = if (darkTheme) DarkColors else LightColors
      ) {
          // app content
      }Material2Snippets.kt

   .. rubric:: Using theme colors
      :name: theme-colors

   You can retrieve the ``Colors`` provided to the ``MaterialTheme`` composable
   by using ``MaterialTheme.colors``.

   .. code:: prettyprint

      Text(
          text = "Hello theming",
          color = MaterialTheme.colors.primary
      )Material2Snippets.kt

   **Note:**\  If you have multiple nested ``MaterialTheme`` then this will
   retrieve the current instance at the point in the tree.

   .. rubric:: Surface and content color
      :name: content-color

   Many components accept a pair of color and content color:

   .. code:: prettyprint

      Surface(
          color = MaterialTheme.colors.surface,
          contentColor = contentColorFor(color),
          // ...
      ) { /* ... */ }

      TopAppBar(
          backgroundColor = MaterialTheme.colors.primarySurface,
          contentColor = contentColorFor(backgroundColor),
          // ...
      ) { /* ... */ }Material2Snippets.kt

   This enables you to not only set the color of a composable, but also to
   provide a default color for the *content,* the composables contained within
   it. Many composables use this content color by default. For example, ``Text``
   bases its color on its parent's content color, and ``Icon`` uses that color
   to set its tint.

   |Two examples of the same banner, with different colors|

   **Figure 3.** Setting different background colors produces different text and
   icon colors.

   The
   `contentColorFor()  <#contentColorFor>`__
   method retrieves the appropriate "on" color for any theme colors. For
   example, if you set a
   `primary  <#primary>`__
   background color on ``Surface``, it uses this function to set
   `onPrimary  <#onPrimary>`__
   as the content color. If you set a non-theme background color, you should
   also specify an appropriate content color. Use
   `LocalContentColor  <#LocalContentColor>`__
   to retrieve the preferred content color for the current background, at a
   given position in the hierarchy.

   **Note:**\  If you need to set the background color of an element, prefer
   using a parent
   `Surface  <#Surface>`__
   to do this, which sets an appropriate content color. Be wary of direct
   `Modifier.background()  <#background>`__
   calls, which do not set an appropriate content color.

   .. rubric:: Content alpha
      :name: emphasis

   Often you want to vary how much you emphasize content to communicate
   importance and provide visual hierarchy. The `Material Design text legibility recommendations <https://material.io/design/color/text-legibility.html>`__
   advise employing different levels of opacity to convey different importance
   levels.

   Jetpack Compose implements this via
   `LocalContentAlpha  <#LocalContentAlpha>`__.
   You can specify a content alpha for a hierarchy by `providing a value  <#CompositionLocalProvider>`__
   for this
   `CompositionLocal  <#CompositionLocal>`__.
   Nested composables can use this value to apply the alpha treatment to their
   content. For example,
   `Text  <#Text>`__
   and
   `Icon  <#Icon>`__
   by default use the combination of
   `LocalContentColor  <#LocalContentColor>`__
   adjusted to use
   `LocalContentAlpha  <#LocalContentAlpha>`__.
   Material specifies some standard alpha values
   (`high  <#high>`__,
   `medium  <#medium>`__,
   `disabled  <#disabled>`__)
   which are modelled by the
   `ContentAlpha  <#ContentAlpha>`__
   object.

   .. code:: prettyprint

      // By default, both Icon & Text use the combination of LocalContentColor &
      // LocalContentAlpha. De-emphasize content by setting content alpha
      CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) {
          Text(
              // ...
          )
      }
      CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.disabled) {
          Icon(
              // ...
          )
          Text(
              // ...
          )
      }Material2Snippets.kt

   **Note:**\ 
   `MaterialTheme  <#MaterialTheme>`__
   defaults
   `LocalContentAlpha  <#LocalContentAlpha>`__
   to
   `ContentAlpha.high  <#high>`__.
   To learn more about ``CompositionLocal``, check out the `Locally scoped data with CompositionLocal guide  <#compositionlocal>`__.

   |Screenshot of an article title, showing different levels of text emphasis|

   **Figure 4.** Apply different levels of emphasis to text to visually
   communicate the information hierarchy. The first line of text is the title
   and has the most important information, and thus uses ``ContentAlpha.high``.
   The second line contains less-important metadata, and thus uses
   ``ContentAlpha.medium``.

   .. rubric:: Dark theme
      :name: dark-theme

   In Compose, you implement light and dark themes by providing different sets
   of ``Colors`` to the ``MaterialTheme`` composable:

   .. code:: prettyprint

      @Composable
      fun MyTheme(
          darkTheme: Boolean = isSystemInDarkTheme(),
          content: @Composable () -> Unit
      ) {
          MaterialTheme(
              colors = if (darkTheme) DarkColors else LightColors,
              /*...*/
              content = content
          )
      }Material2Snippets.kt

   In this example, ``MaterialTheme`` is wrapped in its own composable function,
   which accepts a parameter that specifies whether to use a dark theme or not.
   In this case, the function gets the default value for ``darkTheme`` by
   querying the `device theme setting  <#isSystemInDarkTheme>`__.

   You can use code like this to check if the current ``Colors`` are light or
   dark:

   .. code:: prettyprint

      val isLightTheme = MaterialTheme.colors.isLight
      Icon(
          painterResource(
              id = if (isLightTheme) {
                  R.drawable.ic_sun_24
              } else {
                  R.drawable.ic_moon_24
              }
          ),
          contentDescription = "Theme"
      )Material2Snippets.kt

   .. rubric:: Elevation overlays
      :name: elevation-overlays

   In Material, surfaces in dark themes with higher elevations receive
   `elevation overlays <https://material.io/design/color/dark-theme.html#properties>`__,
   which lightens their background. The higher a surface's elevation (raising it
   closer to an implied light source), the lighter that surface becomes.

   These overlays are applied automatically by the ``Surface`` composable when
   using dark colors, and for any other Material composable which uses a
   surface:

   .. code:: prettyprint

      Surface(
          elevation = 2.dp,
          color = MaterialTheme.colors.surface, // color will be adjusted for elevation
          /*...*/
      ) { /*...*/ }Material2Snippets.kt

   |Screenshot of an app, showing the subtly different colors used for elements
   at different elevation levels|

   **Figure 5.** The cards and bottom navigation are both using the ``surface``
   color as their background. Since the cards and bottom navigation are at
   different elevation levels above the background, they have slightly different
   colors–the cards are lighter than the background and the bottom navigation is
   lighter than the cards.

   For custom scenarios that don’t involve a ``Surface``, use
   `LocalElevationOverlay  <#LocalElevationOverlay>`__,
   a ``CompositionLocal`` containing the
   `ElevationOverlay  <#ElevationOverlay>`__
   used by
   `Surface  <#surface>`__
   components:

   .. code:: prettyprint

      // Elevation overlays
      // Implemented in Surface (and any components that use it)
      val color = MaterialTheme.colors.surface
      val elevation = 4.dp
      val overlaidColor = LocalElevationOverlay.current?.apply(
          color, elevation
      )Material2Snippets.kt

   To disable elevation overlays, provide ``null`` at the desired point in a
   composable hierarchy:

   .. code:: prettyprint

      MyTheme {
          CompositionLocalProvider(LocalElevationOverlay provides null) {
              // Content without elevation overlays
          }
      }Material2Snippets.kt

   .. rubric:: Limited color accents
      :name: limited-accents

   Material recommends applying `limited color accents <https://material.io/design/color/dark-theme.html#anatomy>`__ for
   dark themes by preferring the use of the ``surface`` color over the
   ``primary`` color in most cases. Material composables like ``TopAppBar`` and
   ``BottomNavigation`` implement this behavior by default.

   |image-themes-material-dark-theme|

   **Figure 6.** Material dark theme with limited color accents. The top app bar
   uses the primary color in light theme, and surface color in dark theme.

   For custom scenarios, use the
   `primarySurface  <#primarySurface>`__
   extension property:

   .. code:: prettyprint

      Surface(
          // Switches between primary in light theme and surface in dark theme
          color = MaterialTheme.colors.primarySurface,
          /*...*/
      ) { /*...*/ }Material2Snippets.kt

   .. rubric:: Typography
      :name: typography

   Material defines a `type system <https://material.io/design/typography/the-type-system.html>`__,
   encouraging you to use a small number of semantically-named styles.

   |Example of several different typefaces in various styles|

   **Figure 7.** The Material type system.

   Compose implements the type system with the
   `Typography  <#Typography>`__,
   `TextStyle  <#TextStyle>`__, and
   `font-related  <#package-summary>`__
   classes. The ``Typography`` constructor offers defaults for each style so you
   can omit any you don’t want to customize:

   .. code:: prettyprint

      val raleway = FontFamily(
          Font(R.font.raleway_regular),
          Font(R.font.raleway_medium, FontWeight.W500),
          Font(R.font.raleway_semibold, FontWeight.SemiBold)
      )

      val myTypography = Typography(
          h1 = TextStyle(
              fontFamily = raleway,
              fontWeight = FontWeight.W300,
              fontSize = 96.sp
          ),
          body1 = TextStyle(
              fontFamily = raleway,
              fontWeight = FontWeight.W600,
              fontSize = 16.sp
          )
          /*...*/
      )
      MaterialTheme(typography = myTypography, /*...*/) {
          /*...*/
      }Material2Snippets.kt

   If you want to use the same typeface throughout, specify the
   `defaultFontFamily parameter  <#public-constructors>`__
   and omit the ``fontFamily`` of any ``TextStyle`` elements:

   .. code:: prettyprint

      val typography = Typography(defaultFontFamily = raleway)
      MaterialTheme(typography = typography, /*...*/) {
          /*...*/
      }Material2Snippets.kt

   .. rubric:: Using text styles
      :name: text-styles

   ``TextStyle``\ s are accessed via ``MaterialTheme.typography``. Retrieve the
   ``TextStyle``\ s like so:

   .. code:: prettyprint

      Text(
          text = "Subtitle2 styled",
          style = MaterialTheme.typography.subtitle2
      )Material2Snippets.kt

   |Screenshot showing a mixture of different typefaces for different purposes|

   **Figure 8.** Use a selection of typefaces and styles to express your brand.

   .. rubric:: Shape
      :name: shape

   Material defines a `shape system <https://material.io/design/shape/about-shape.html>`__, allowing you
   to define shapes for large, medium, and small components.

   |Shows a variety of Material Design shapes|

   **Figure 9.** The Material shape system.

   Compose implements the shape system with the
   `Shapes  <#Shapes>`__ class,
   which lets you specify a
   `CornerBasedShape  <#CornerBasedShape>`__
   for each size category:

   .. code:: prettyprint

      val shapes = Shapes(
          small = RoundedCornerShape(percent = 50),
          medium = RoundedCornerShape(0f),
          large = CutCornerShape(
              topStart = 16.dp,
              topEnd = 0.dp,
              bottomEnd = 0.dp,
              bottomStart = 16.dp
          )
      )

      MaterialTheme(shapes = shapes, /*...*/) {
          /*...*/
      }Material2Snippets.kt

   Many components use these shapes by default. For example,
   `Button  <#Button>`__,
   `TextField  <#TextField>`__,
   and
   `FloatingActionButton  <#FloatingActionButton>`__
   default to small,
   `AlertDialog  <#AlertDialog>`__
   defaults to medium, and
   `ModalDrawer  <#ModalDrawer>`__
   defaults to large — see the `shape scheme reference <https://material.io/design/shape/applying-shape-to-ui.html#shape-scheme>`__
   for the complete mapping.

   .. rubric:: Using shapes
      :name: using-shapes

   ``Shape``\ s are accessed via ``MaterialTheme.shapes``. Retrieve the
   ``Shape``\ s with code like this:

   .. code:: prettyprint

      Surface(
          shape = MaterialTheme.shapes.medium, /*...*/
      ) {
          /*...*/
      }Material2Snippets.kt

   |Screenshot of an app that uses Material shapes to convey what state an
   element is in|

   **Figure 10.** Use shapes to express brand or state.

   .. rubric:: Default styles
      :name: component-styles

   There is no equivalent concept in Compose of `default styles  <#Widgets>`__ from Android Views.
   You can provide similar functionality by creating your own ‘overload’
   composable functions that wrap Material components. For example, to create a
   style of button, wrap a button in your own composable function, directly
   setting the parameters you wish to alter, and exposing others as parameters
   to the containing composable.

   .. code:: prettyprint

      @Composable
      fun MyButton(
          onClick: () -> Unit,
          modifier: Modifier = Modifier,
          content: @Composable RowScope.() -> Unit
      ) {
          Button(
              colors = ButtonDefaults.buttonColors(
                  backgroundColor = MaterialTheme.colors.secondary
              ),
              onClick = onClick,
              modifier = modifier,
              content = content
          )
      }Material2Snippets.kt

   .. rubric:: Theme overlays
      :name: theme-overlays

   You can achieve the equivalent of `theme overlays <https://medium.com/androiddevelopers/android-styling-themes-overlay-1ffd57745207>`__
   from Android Views in Compose, by nesting
   `MaterialTheme  <#materialtheme>`__
   composables. Because
   `MaterialTheme  <#materialtheme>`__
   defaults the colors, typography, and shapes to the current theme value, if a
   theme only sets one of those parameters, the other parameters keep their
   default values.

   Furthermore, when migrating View-based screens to Compose, watch out for
   usages of the ``android:theme`` attribute. It's likely you need a new
   `MaterialTheme  <#materialtheme>`__
   in that part of the Compose UI tree.

   In the `Owl sample <https://github.com/android/compose-samples/tree/main/Owl>`__, the
   details screen uses a ``PinkTheme`` for most of the screen, and then a
   ``BlueTheme`` for the related section. See screenshot and code below.

   |image-themes-material-overlays|

   **Figure 11.** Nested themes in the Owl sample.

   .. code:: prettyprint

      @Composable
      fun DetailsScreen(/* ... */) {
          PinkTheme {
              // other content
              RelatedSection()
          }
      }

      @Composable
      fun RelatedSection(/* ... */) {
          BlueTheme {
              // content
          }
      }Material2Snippets.kt

   .. rubric:: Component states
      :name: component-states

   Material components that can be interacted with (clicked, toggled, etc.) can
   be in different visual states. States include enabled, disabled, pressed,
   etc.

   Composables often have an ``enabled`` parameter. Setting it to ``false``
   prevents interaction, and changes properties like color and elevation to
   visually convey the component state.

   |image-themes-material-button-states|

   **Figure 12.** Button with ``enabled = true`` (left) and ``enabled = false``
   (right).

   In most cases you can rely on defaults for values like color and elevation.
   Should you wish to configure values used in different states, there are
   classes and convenience functions available. See the button example below:

   .. code:: prettyprint

      Button(
          onClick = { /* ... */ },
          enabled = true,
          // Custom colors for different states
          colors = ButtonDefaults.buttonColors(
              backgroundColor = MaterialTheme.colors.secondary,
              disabledBackgroundColor = MaterialTheme.colors.onBackground
                  .copy(alpha = 0.2f)
                  .compositeOver(MaterialTheme.colors.background)
              // Also contentColor and disabledContentColor
          ),
          // Custom elevation for different states
          elevation = ButtonDefaults.elevation(
              defaultElevation = 8.dp,
              disabledElevation = 2.dp,
              // Also pressedElevation
          )
      ) { /* ... */ }Material2Snippets.kt

   |image-themes-material-buttons-adjusted|

   **Figure 13.** Button with ``enabled = true`` (left) and ``enabled = false``
   (right), with adjusted color and elevation values.

   .. rubric:: Ripples
      :name: ripples

   Material components use ripples to indicate they're being interacted with. If
   you’re using ``MaterialTheme`` in your hierarchy, a ``Ripple`` will be used
   as the
   default\ `Indication  <#Indication>`__
   inside modifiers such as
   `clickable  <#clickable>`__
   and
   `indication  <#indication>`__.

   In most cases you can rely on the default ``Ripple``. Should you wish to
   configure their appearance, you can use
   `RippleTheme  <#RippleTheme>`__
   to change properties like color and alpha.

   You can extend ``RippleTheme`` and make use of the
   `defaultRippleColor  <#defaultRippleColor>`__
   and
   `defaultRippleAlpha  <#defaultRippleAlpha>`__
   utility functions. You can then provide your custom ripple theme in your
   hierarchy using
   `LocalRippleTheme  <#LocalRippleTheme>`__:

   .. code:: prettyprint

      @Composable
      fun MyApp() {
          MaterialTheme {
              CompositionLocalProvider(
                  LocalRippleTheme provides SecondaryRippleTheme
              ) {
                  // App content
              }
          }
      }

      @Immutable
      private object SecondaryRippleTheme : RippleTheme {
          @Composable
          override fun defaultColor() = RippleTheme.defaultRippleColor(
              contentColor = MaterialTheme.colors.secondary,
              lightTheme = MaterialTheme.colors.isLight
          )

          @Composable
          override fun rippleAlpha() = RippleTheme.defaultRippleAlpha(
              contentColor = MaterialTheme.colors.secondary,
              lightTheme = MaterialTheme.colors.isLight
          )
      }Material2Snippets.kt

   |alt_text|

   **Figure 14.** Buttons with different ripple values provided via
   ``RippleTheme``.

   .. rubric:: Learn more
      :name: additional-resources

   To learn more about Material Theming in Compose, consult the following
   additional resources.

   .. rubric:: Codelabs
      :name: codelabs

   -  `Jetpack Compose theming  <#jetpack-compose-theming>`__

   .. rubric:: Videos
      :name: videos

   -  `Material You in Jetpack Compose <https://www.youtube.com/watch?v=jrfuHyMlehc>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Custom design systems in Compose  <#custom>`__
   -  `Migrate from Material 2 to Material 3 in Compose  <#material2-material3>`__
   -  `Accessibility in Compose  <#accessibility>`__

Last updated 2024-03-25 UTC.

.. |Two contrasting screenshots. The first uses default MaterialTheme styling, the second screenshot uses modified styling.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/theme-two-themes.png
   :width: 500px
.. |Example of theme's color palette| image:: https://developer.android.google.cn/static/develop/ui/compose/images/theme-colors.png
.. |Two examples of the same banner, with different colors| image:: https://developer.android.google.cn/static/develop/ui/compose/images/theme-contrast-styles.png
   :width: 400px
.. |Screenshot of an article title, showing different levels of text emphasis| image:: https://developer.android.google.cn/static/develop/ui/compose/images/theme-emphasis.png
   :width: 400px
.. |Screenshot of an app, showing the subtly different colors used for elements at different elevation levels| image:: https://developer.android.google.cn/static/develop/ui/compose/images/theme-elevation.png
   :width: 300px
.. |image-themes-material-dark-theme| image:: https://developer.android.google.cn/static/develop/ui/compose/images/themes-material-dark-theme.png
.. |Example of several different typefaces in various styles| image:: https://developer.android.google.cn/static/develop/ui/compose/images/theme-typefaces.png
   :width: 500px
.. |Screenshot showing a mixture of different typefaces for different purposes| image:: https://developer.android.google.cn/static/develop/ui/compose/images/theme-typefaces-styles.png
   :width: 500px
.. |Shows a variety of Material Design shapes| image:: https://developer.android.google.cn/static/develop/ui/compose/images/theme-shapes.png
   :width: 500px
.. |Screenshot of an app that uses Material shapes to convey what state an element is in| image:: https://developer.android.google.cn/static/develop/ui/compose/images/theme-shapes-example.png
   :width: 400px
.. |image-themes-material-overlays| image:: https://developer.android.google.cn/static/develop/ui/compose/images/themes-material-overlays.png
   :width: 500px
.. |image-themes-material-button-states| image:: https://developer.android.google.cn/static/develop/ui/compose/images/themes-material-button-states.png
   :width: 500px
.. |image-themes-material-buttons-adjusted| image:: https://developer.android.google.cn/static/develop/ui/compose/images/themes-material-buttons-adjusted.png
   :width: 500px
.. |alt_text| image:: https://developer.android.google.cn/static/develop/ui/compose/images/themes-material-ripples.gif
   :width: 500px

/Custom theming
===============

.. https://developer.android.google.cn/develop/ui/compose/designsystems/custom?hl=en

.. container:: devsite-article-body clearfix

   While Material is our recommended design system and Jetpack Compose ships an
   implementation of Material, you are not forced to use it. Material is built
   entirely on public APIs, so it’s possible to create your own design system in
   the same manner.

   There are several approaches you might take:

   -  `Extending MaterialTheme <#extending-material>`__ with additional
      theming values
   -  `Replacing one or more Material systems <#replacing-systems>`__ —
      ``Colors``, ``Typography``, or ``Shapes`` — with custom implementations,
      while maintaining the others
   -  `Implementing a fully-custom design system <#implementing-fully-custom>`__
      to replace ``MaterialTheme``

   You may also wish to continue using Material components with a custom design
   system. It’s possible to do this but there are things to keep in mind to suit
   the approach you’ve taken.

   To learn more about the lower-level constructs and APIs used by
   ``MaterialTheme`` and custom design systems, check out the `Anatomy of a theme in Compose  <#anatomy>`__ guide.

   .. rubric:: Extending Material Theming
      :name: extending-material

   Compose Material closely models `Material Theming <https://material.io/design/material-theming/>`__ to make it simple
   and type-safe to follow the Material guidelines. However, it’s possible to
   extend the color, typography, and shape sets with additional values.

   The simplest approach is to add extension properties:

   .. code:: prettyprint

      // Use with MaterialTheme.colors.snackbarAction
      val Colors.snackbarAction: Color
          get() = if (isLight) Red300 else Red700

      // Use with MaterialTheme.typography.textFieldInput
      val Typography.textFieldInput: TextStyle
          get() = TextStyle(/* ... */)

      // Use with MaterialTheme.shapes.card
      val Shapes.card: Shape
          get() = RoundedCornerShape(size = 20.dp)CustomDesignSystem.kt

   This provides consistency with ``MaterialTheme`` usage APIs. An example of
   this defined by Compose itself is
   `primarySurface  <#primarySurface>`__,
   which acts as a proxy between ``primary`` and ``surface`` depending on
   ``Colors.isLight``.

   **Note:**\  This approach is only recommended for simple theming value
   additions, or for values that are the same in different themes. If you have
   multiple themes, it’s better to define a class with new properties instead.
   Another approach is to define an extended theme that “wraps”
   ``MaterialTheme`` and its values.

   Suppose you wish to add two additional colors — ``tertiary`` and
   ``onTertiary`` — whilst keeping the existing Material colors:

   |image-custom-extended-theme-colors|

   .. code:: prettyprint

      @Immutable
      data class ExtendedColors(
          val tertiary: Color,
          val onTertiary: Color
      )

      val LocalExtendedColors = staticCompositionLocalOf {
          ExtendedColors(
              tertiary = Color.Unspecified,
              onTertiary = Color.Unspecified
          )
      }

      @Composable
      fun ExtendedTheme(
          /* ... */
          content: @Composable () -> Unit
      ) {
          val extendedColors = ExtendedColors(
              tertiary = Color(0xFFA8EFF0),
              onTertiary = Color(0xFF002021)
          )
          CompositionLocalProvider(LocalExtendedColors provides extendedColors) {
              MaterialTheme(
                  /* colors = ..., typography = ..., shapes = ... */
                  content = content
              )
          }
      }

      // Use with eg. ExtendedTheme.colors.tertiary
      object ExtendedTheme {
          val colors: ExtendedColors
              @Composable
              get() = LocalExtendedColors.current
      }CustomDesignSystem.kt

   This is similar to ``MaterialTheme`` usage APIs. It also supports multiple
   themes as you can nest ``ExtendedTheme``\ s in the same way as
   ``MaterialTheme``.

   .. rubric:: Using Material components
      :name: extending-using-material-components

   When extending Material Theming, existing ``MaterialTheme`` values are
   maintained and Material components still have reasonable defaults.

   If you wish to use extended values in components, wrap them in your own
   composable functions, directly setting the values you wish to alter, and
   exposing others as parameters to the containing composable:

   .. code:: prettyprint

      @Composable
      fun ExtendedButton(
          onClick: () -> Unit,
          modifier: Modifier = Modifier,
          content: @Composable RowScope.() -> Unit
      ) {
          Button(
              colors = ButtonDefaults.buttonColors(
                  containerColor = ExtendedTheme.colors.tertiary,
                  contentColor = ExtendedTheme.colors.onTertiary
                  /* Other colors use values from MaterialTheme */
              ),
              onClick = onClick,
              modifier = modifier,
              content = content
          )
      }CustomDesignSystem.kt

   You would then replace usages of ``Button`` with ``ExtendedButton`` where
   appropriate.

   .. code:: prettyprint

      @Composable
      fun ExtendedApp() {
          ExtendedTheme {
              /*...*/
              ExtendedButton(onClick = { /* ... */ }) {
                  /* ... */
              }
          }
      }CustomDesignSystem.kt

   .. rubric:: Replacing Material systems
      :name: replacing-systems

   Instead of extending Material Theming, you may wish to replace one or more
   systems — ``Colors``, ``Typography``, or ``Shapes`` — with a custom
   implementation, while maintaining the others.

   Suppose you wish to replace the type and shape systems while keeping the
   color system:

   |image-custom-theme-replacement|

   .. code:: prettyprint

      @Immutable
      data class ReplacementTypography(
          val body: TextStyle,
          val title: TextStyle
      )

      @Immutable
      data class ReplacementShapes(
          val component: Shape,
          val surface: Shape
      )

      val LocalReplacementTypography = staticCompositionLocalOf {
          ReplacementTypography(
              body = TextStyle.Default,
              title = TextStyle.Default
          )
      }
      val LocalReplacementShapes = staticCompositionLocalOf {
          ReplacementShapes(
              component = RoundedCornerShape(ZeroCornerSize),
              surface = RoundedCornerShape(ZeroCornerSize)
          )
      }

      @Composable
      fun ReplacementTheme(
          /* ... */
          content: @Composable () -> Unit
      ) {
          val replacementTypography = ReplacementTypography(
              body = TextStyle(fontSize = 16.sp),
              title = TextStyle(fontSize = 32.sp)
          )
          val replacementShapes = ReplacementShapes(
              component = RoundedCornerShape(percent = 50),
              surface = RoundedCornerShape(size = 40.dp)
          )
          CompositionLocalProvider(
              LocalReplacementTypography provides replacementTypography,
              LocalReplacementShapes provides replacementShapes
          ) {
              MaterialTheme(
                  /* colors = ... */
                  content = content
              )
          }
      }

      // Use with eg. ReplacementTheme.typography.body
      object ReplacementTheme {
          val typography: ReplacementTypography
              @Composable
              get() = LocalReplacementTypography.current
          val shapes: ReplacementShapes
              @Composable
              get() = LocalReplacementShapes.current
      }CustomDesignSystem.kt

   .. rubric:: Using Material components
      :name: replacing-using-material-components

   When one or more systems of ``MaterialTheme`` have been replaced, using
   Material components as-is may result in unwanted Material color, type, or
   shape values.

   If you wish to use replacement values in components, wrap them in your own
   composable functions, directly setting the values for the relevant system,
   and exposing others as parameters to the containing composable.

   **Note:**\  Not all values may be exposed as parameters in Material
   composables, in particular with ``CompositionLocal`` composables (such as
   ``LocalTextStyle``). In such cases you may need to wrap ``content`` lambdas
   in provider functions (like ``ProvideTextStyle``).
   .. code:: prettyprint

      @Composable
      fun ReplacementButton(
          onClick: () -> Unit,
          modifier: Modifier = Modifier,
          content: @Composable RowScope.() -> Unit
      ) {
          Button(
              shape = ReplacementTheme.shapes.component,
              onClick = onClick,
              modifier = modifier,
              content = {
                  ProvideTextStyle(
                      value = ReplacementTheme.typography.body
                  ) {
                      content()
                  }
              }
          )
      }CustomDesignSystem.kt

   You would then replace usages of ``Button`` with ``ReplacementButton`` where
   appropriate.

   .. code:: prettyprint

      @Composable
      fun ReplacementApp() {
          ReplacementTheme {
              /*...*/
              ReplacementButton(onClick = { /* ... */ }) {
                  /* ... */
              }
          }
      }CustomDesignSystem.kt

   .. rubric:: Implementing a fully-custom design system
      :name: implementing-fully-custom

   You may wish to replace Material Theming with a fully-custom design system.
   Consider that ``MaterialTheme`` provides the following systems:

   -  ``Colors``, ``Typography``, and ``Shapes``: Material Theming systems
   -  ``ContentAlpha``: Opacity levels to convey emphasis in ``Text`` and
      ``Icon``
   -  ``TextSelectionColors``: Colors used for text selection by ``Text`` and
      ``TextField``
   -  ``Ripple`` and ``RippleTheme``: Material implementation of ``Indication``

   If you want to continue using Material components, you'll need to replace
   some of these systems in your custom theme or themes, or handle the systems
   in your components, to avoid unwanted behavior.

   However, design systems are not limited to the concepts Material relies on.
   You can modify existing systems and introduce entirely new ones — with new
   classes and types — to make other concepts compatible with themes.

   In the following code, we model a custom color system that includes gradients
   (``List<Color>``), include a type system, introduce a new elevation system,
   and exclude other systems provided by ``MaterialTheme``:

   |image-custom-color-gradients|

   .. code:: prettyprint

      @Immutable
      data class CustomColors(
          val content: Color,
          val component: Color,
          val background: List<Color>
      )

      @Immutable
      data class CustomTypography(
          val body: TextStyle,
          val title: TextStyle
      )

      @Immutable
      data class CustomElevation(
          val default: Dp,
          val pressed: Dp
      )

      val LocalCustomColors = staticCompositionLocalOf {
          CustomColors(
              content = Color.Unspecified,
              component = Color.Unspecified,
              background = emptyList()
          )
      }
      val LocalCustomTypography = staticCompositionLocalOf {
          CustomTypography(
              body = TextStyle.Default,
              title = TextStyle.Default
          )
      }
      val LocalCustomElevation = staticCompositionLocalOf {
          CustomElevation(
              default = Dp.Unspecified,
              pressed = Dp.Unspecified
          )
      }

      @Composable
      fun CustomTheme(
          /* ... */
          content: @Composable () -> Unit
      ) {
          val customColors = CustomColors(
              content = Color(0xFFDD0D3C),
              component = Color(0xFFC20029),
              background = listOf(Color.White, Color(0xFFF8BBD0))
          )
          val customTypography = CustomTypography(
              body = TextStyle(fontSize = 16.sp),
              title = TextStyle(fontSize = 32.sp)
          )
          val customElevation = CustomElevation(
              default = 4.dp,
              pressed = 8.dp
          )
          CompositionLocalProvider(
              LocalCustomColors provides customColors,
              LocalCustomTypography provides customTypography,
              LocalCustomElevation provides customElevation,
              content = content
          )
      }

      // Use with eg. CustomTheme.elevation.small
      object CustomTheme {
          val colors: CustomColors
              @Composable
              get() = LocalCustomColors.current
          val typography: CustomTypography
              @Composable
              get() = LocalCustomTypography.current
          val elevation: CustomElevation
              @Composable
              get() = LocalCustomElevation.current
      }CustomDesignSystem.kt

   .. rubric:: Using Material components
      :name: implementing-using-material-components

   When no ``MaterialTheme`` is present, using Material components as-is will
   result in unwanted Material color, type, and shape values and indication
   behavior.

   If you wish to use custom values in components, wrap them in your own
   composable functions, directly setting the values for the relevant system,
   and exposing others as parameters to the containing composable.

   We recommend you access values you set from your custom theme. Alternatively,
   if your theme doesn’t provide ``Color``, ``TextStyle``, ``Shape``, or other
   systems, you can hardcode them.

   .. code:: prettyprint

      @Composable
      fun CustomButton(
          onClick: () -> Unit,
          modifier: Modifier = Modifier,
          content: @Composable RowScope.() -> Unit
      ) {
          Button(
              colors = ButtonDefaults.buttonColors(
                  containerColor = CustomTheme.colors.component,
                  contentColor = CustomTheme.colors.content,
                  disabledContainerColor = CustomTheme.colors.content
                      .copy(alpha = 0.12f)
                      .compositeOver(CustomTheme.colors.component),
                  disabledContentColor = CustomTheme.colors.content
                      .copy(alpha = ContentAlpha.disabled)
              ),
              shape = ButtonShape,
              elevation = ButtonDefaults.elevatedButtonElevation(
                  defaultElevation = CustomTheme.elevation.default,
                  pressedElevation = CustomTheme.elevation.pressed
                  /* disabledElevation = 0.dp */
              ),
              onClick = onClick,
              modifier = modifier,
              content = {
                  ProvideTextStyle(
                      value = CustomTheme.typography.body
                  ) {
                      content()
                  }
              }
          )
      }

      val ButtonShape = RoundedCornerShape(percent = 50)CustomDesignSystem.kt

   **Note:**\  ``Button`` uses ``rememberRipple()`` internally to provide a
   ``Ripple`` ``Indication``. It’s a good idea to check the source code when
   implementing other custom components that wrap existing components.
   If you’ve introduced new class types — such as ``List<Color>`` to represent
   gradients — then it may be better to implement components from scratch
   instead of wrapping them. For an example, take a look at
   `JetsnackButton <https://github.com/android/compose-samples/blob/main/Jetsnack/app/src/main/java/com/example/jetsnack/ui/components/Button.kt>`__
   from the Jetsnack sample.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Material Design 2 in Compose  <#material>`__
   -  `Migrate from Material 2 to Material 3 in Compose  <#material2-material3>`__
   -  `Anatomy of a theme in Compose  <#anatomy>`__

Last updated 2024-05-03 UTC.

.. |image-custom-extended-theme-colors| image:: https://developer.android.google.cn/static/develop/ui/compose/images/themes/custom-extended-theme-colors.png
   :width: 500px
.. |image-custom-theme-replacement| image:: https://developer.android.google.cn/static/develop/ui/compose/images/themes/custom-theme-replacement.png
.. |image-custom-color-gradients| image:: https://developer.android.google.cn/static/develop/ui/compose/images/themes/custom-color-gradients.png

/Anatomy of a theme
===================

.. https://developer.android.google.cn/develop/ui/compose/designsystems/anatomy?hl=en

.. container:: devsite-article-body clearfix

   Themes in Jetpack Compose are made up of a number of lower-level constructs
   and related APIs. These can be seen in the `source code <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material/material/src/commonMain/kotlin/androidx/compose/material/MaterialTheme.kt>`__
   of ``MaterialTheme`` and can also be applied in custom design systems.

   .. rubric:: Theme system classes
      :name: system-classes

   A theme is typically made up of a number of systems that group common visual
   and behavioral concepts. These systems can be modeled with classes which have
   theming values.

   For example, ``MaterialTheme`` includes
   `Colors <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material/material/src/commonMain/kotlin/androidx/compose/material/Colors.kt>`__
   (color system),
   `Typography <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material/material/src/commonMain/kotlin/androidx/compose/material/Typography.kt>`__
   (typography system), and
   `Shapes <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material/material/src/commonMain/kotlin/androidx/compose/material/Shapes.kt>`__
   (shape system).

   **Note:**\  Classes should be annotated with
   `Stable  <#Stable>`__ or
   `@Immutable  <#Immutable>`__ to
   provide information to the Compose compiler. To learn more, check out the
   `Lifecycle of composables guide  <#skipping>`__.
   .. code:: prettyprint

      @Immutable
      data class ColorSystem(
          val color: Color,
          val gradient: List<Color>
          /* ... */
      )

      @Immutable
      data class TypographySystem(
          val fontFamily: FontFamily,
          val textStyle: TextStyle
      )
      /* ... */

      @Immutable
      data class CustomSystem(
          val value1: Int,
          val value2: String
          /* ... */
      )

      /* ... */ThemeAnatomySnippets.kt

   .. rubric:: Theme system composition locals
      :name: system-composition-locals

   Theme system classes are implicitly provided to the composition tree as
   `CompositionLocal  <#CompositionLocal>`__
   instances. This allows theming values to be statically referenced in
   composable functions.

   To learn more about ``CompositionLocal``, check out the `Locally scoped data with CompositionLocal guide  <#compositionlocal>`__.

   **Note:**\  You can create a class's ``CompositionLocal`` with
   `compositionLocalOf  <#compositionlocalof>`__
   or
   `staticCompositionLocalOf  <#staticcompositionlocalof>`__.
   These functions have a ``defaultFactory`` trailing lambda to provide fallback
   values of the same type that they’re providing. It’s a good idea to use
   reasonable defaults like ``Color.Unspecified``, ``TextStyle.Default``, etc.
   .. code:: prettyprint

      val LocalColorSystem = staticCompositionLocalOf {
          ColorSystem(
              color = Color.Unspecified,
              gradient = emptyList()
          )
      }

      val LocalTypographySystem = staticCompositionLocalOf {
          TypographySystem(
              fontFamily = FontFamily.Default,
              textStyle = TextStyle.Default
          )
      }

      val LocalCustomSystem = staticCompositionLocalOf {
          CustomSystem(
              value1 = 0,
              value2 = ""
          )
      }

      /* ... */ThemeAnatomySnippets.kt

   .. rubric:: Theme function
      :name: theme-function

   The theme function is the entry point and primary API. It constructs
   instances of the theme system ``CompositionLocal``\ s — using real values any
   logic required — that are provided to the composition tree with
   `CompositionLocalProvider  <#compositionlocalprovider>`__.
   The ``content`` parameter allows nested composables to access theming values
   relative to the hierarchy.

   .. code:: prettyprint

      @Composable
      fun Theme(
          /* ... */
          content: @Composable () -> Unit
      ) {
          val colorSystem = ColorSystem(
              color = Color(0xFF3DDC84),
              gradient = listOf(Color.White, Color(0xFFD7EFFF))
          )
          val typographySystem = TypographySystem(
              fontFamily = FontFamily.Monospace,
              textStyle = TextStyle(fontSize = 18.sp)
          )
          val customSystem = CustomSystem(
              value1 = 1000,
              value2 = "Custom system"
          )
          /* ... */
          CompositionLocalProvider(
              LocalColorSystem provides colorSystem,
              LocalTypographySystem provides typographySystem,
              LocalCustomSystem provides customSystem,
              /* ... */
              content = content
          )
      }ThemeAnatomySnippets.kt

   .. rubric:: Theme object
      :name: theme-object

   Accessing theme systems is done via an object with convenience properties.
   For consistency, the object tends to be named the same as the theme function.
   The properties simply get the current composition local.

   .. code:: prettyprint

      // Use with eg. Theme.colorSystem.color
      object Theme {
          val colorSystem: ColorSystem
              @Composable
              get() = LocalColorSystem.current
          val typographySystem: TypographySystem
              @Composable
              get() = LocalTypographySystem.current
          val customSystem: CustomSystem
              @Composable
              get() = LocalCustomSystem.current
          /* ... */
      }ThemeAnatomySnippets.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Locally scoped data with CompositionLocal  <#compositionlocal>`__
   -  `Custom design systems in Compose  <#custom>`__
   -  `Material Design 2 in Compose  <#material>`__

Last updated 2024-03-25 UTC.

/Migrating XML themes to Compose
================================

.. https://developer.android.google.cn/develop/ui/compose/designsystems/views-to-compose?hl=en

.. container:: devsite-article-body clearfix

   When you introduce Compose in an existing app, you need to migrate your
   themes in XML to use ``MaterialTheme`` for Compose screens. This means your
   app's theming will have two sources of truth: the View-based theme and the
   Compose theme. Any changes to your styling need to be made in multiple
   places. Once your app is fully migrated to Compose, you can remove your XML
   theming.

   **Note:**\  For non-Material design systems, see `Custom design systems in Compose  <#custom>`__.
   To migrate your XML themes to Compose, use the `Material Theme Builder <https://m3.material.io/theme-builder>`__ to migrate from an XML
   theme to `Material 3  <#material-theming>`__ in
   Compose. You can use your existing color roles, such as primary and secondary
   colors from your XML theme, and pass them to the Material Theme Builder. This
   creates a fully Material 3 theme in Compose and provides downloadable color
   and theme files to use in your app.

   Material Theme Builder generates a ``MaterialTheme`` and light and dark color
   schemes for your app. If your app uses custom shapes or typography, migrate
   your custom shapes and typography by defining a ``Shape`` and ``Typography``,
   respectively. Once defined, provide that information to your
   ``MaterialTheme``. See
   `shapes  <#shapes>`__ and
   `typography  <#typography>`__ to
   learn more.

   **Note:**\  If you are not using Material 3, see `Material Design 2 in Compose  <#material>`__ to learn how to
   create a theme. See `Migrate from Material 2 to Material 3 in Compose  <#material2-material3>`__ when you
   are ready to migrate to Material 3.

Last updated 2024-05-03 UTC.

/Overview: Text and typography
==============================

.. https://developer.android.google.cn/develop/ui/compose/text?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   Text is a central piece of any UI, and Jetpack Compose makes it easier to
   display or write text. Compose leverages composition of its building blocks,
   meaning you don’t need to overwrite properties and methods or extend big
   classes to have a specific composable design and logic working the way you
   want.

   As its base, Compose provides a
   `BasicText  <#BasicText>`__
   and
   `BasicTextField  <#BasicTextField>`__,
   which are the barebones to display text and handle user input. At a higher
   level, Compose provides
   `Text  <#Text>`__
   and
   `TextField  <#TextField>`__,
   which are composables following Material Design guidelines. It’s recommended
   to use them as they have the right look and feel for users on Android, and
   includes other options to simplify their customization without having to
   write a lot of code.

   .. rubric:: Samples
      :name: text-samples

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Display emoji  <#emoji>`__
   -  `Custom design systems in Compose  <#custom>`__
   -  `Material Design 2 in Compose  <#material>`__

Last updated 2024-03-25 UTC.

/Display text from resource
===========================

.. https://developer.android.google.cn/develop/ui/compose/text/display-text?hl=en

.. container:: devsite-article-body clearfix

   The most basic way to display text is to use the ``Text`` composable with a
   ``String`` as an argument:

   .. code:: prettyprint

      @Composable
      fun SimpleText() {
          Text("Hello World")
      }TextSnippets.kt

   |The words|

   .. rubric:: Display text from resource
      :name: text-from-resource

   We recommend you use `string resources  <#strings>`__ instead of hardcoding
   ``Text`` values, as you can share the same strings with your Android Views as
   well as preparing your app for internationalization:

   .. code:: prettyprint

      @Composable
      fun StringResourceText() {
          Text(stringResource(R.string.hello_world))
      }TextSnippets.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Enable user interactions  <#user-interactions>`__
   -  `Thinking in Compose  <#mental-model>`__
   -  `Display emoji  <#emoji>`__

Last updated 2024-05-03 UTC.

.. |The words| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-plain.png

/Style text
===========

.. https://developer.android.google.cn/develop/ui/compose/text/style-text?hl=en

.. container:: devsite-article-body clearfix

   The ``Text`` composable has multiple optional parameters to style its
   content. Below, we’ve listed parameters that cover the most common use cases
   with text. For all the parameters of ``Text``, see the `Compose Text source code <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material/material/src/commonMain/kotlin/androidx/compose/material/Text.kt;l=91>`__.

   Whenever you set one of these parameters, you’re applying the style to the
   whole text value. If you need to apply multiple styles within the same line
   or paragraphs, see the section on `multiple inline styles <#multiple-styles>`__.

   .. rubric:: Common text stylings
      :name: common-stylings

   The following sections describe common ways to style your text.

   .. rubric:: Change text color
      :name: change-color

   .. code:: prettyprint

      @Composable
      fun BlueText() {
          Text("Hello World", color = Color.Blue)
      }TextSnippets.kt

   |The words|

   .. rubric:: Change text size
      :name: change-size

   .. code:: prettyprint

      @Composable
      fun BigText() {
          Text("Hello World", fontSize = 30.sp)
      }TextSnippets.kt

   |image-text-big|

   .. rubric:: Make text italic
      :name: italic

   Use the ``fontStyle`` parameter to italicize text (or set another
   `FontStyle  <#FontStyle>`__).

   .. code:: prettyprint

      @Composable
      fun ItalicText() {
          Text("Hello World", fontStyle = FontStyle.Italic)
      }TextSnippets.kt

   |image-text-italic|

   .. rubric:: Make text bold
      :name: bold

   Use the ``fontWeight`` parameter to bold text (or set another
   `FontWeight  <#FontWeight>`__).

   .. code:: prettyprint

      @Composable
      fun BoldText() {
          Text("Hello World", fontWeight = FontWeight.Bold)
      }TextSnippets.kt

   |image-text-bold|

   .. rubric:: Add shadow
      :name: shadow

   The ``style`` parameter lets you set an object of type
   `TextStyle  <#TextStyle>`__ and
   configure multiple parameters, for example shadow.
   `Shadow  <#Shadow>`__
   receives a color for the shadow, the offset, or where it is located in
   respect of the ``Text`` and the blur radius which is how blurry it looks.

   .. code:: prettyprint

      @Composable
      fun TextShadow() {
          val offset = Offset(5.0f, 10.0f)
          Text(
              text = "Hello world!",
              style = TextStyle(
                  fontSize = 24.sp,
                  shadow = Shadow(
                      color = Color.Blue, offset = offset, blurRadius = 3f
                  )
              )
          )
      }TextSnippets.kt

   |image-text-shadow|

   .. rubric:: Add multiple styles in text
      :name: multiple-styles

   To set different styles within the same
   `Text  <#Text>`__
   composable, use an
   `AnnotatedString  <#AnnotatedString>`__,
   a string that can be annotated with styles of arbitrary annotations.

   ``AnnotatedString`` is a data class containing:

   -  A ``Text`` value
   -  A ``List`` of ``SpanStyleRange``, equivalent to inline styling with
      position range within the text value
   -  A ``List`` of ``ParagraphStyleRange``, specifying text alignment, text
      direction, line height, and text indent styling

   `TextStyle  <#TextStyle>`__ is
   for use in the ``Text`` composable, whereas
   `SpanStyle  <#SpanStyle>`__ and
   `ParagraphStyle  <#ParagraphStyle>`__
   is for use in ``AnnotatedString``. For more information about multiple styles
   in a paragraph, see `Add multiple styles in a paragraph  <#multiple-paragraph-styles>`__.

   ``AnnotatedString`` has a `type-safe builder <https://kotlinlang.org/docs/reference/type-safe-builders.html>`__ to
   make it easier to create:
   `buildAnnotatedString  <#buildAnnotatedString>`__.

   .. code:: prettyprint

      @Composable
      fun MultipleStylesInText() {
          Text(
              buildAnnotatedString {
                  withStyle(style = SpanStyle(color = Color.Blue)) {
                      append("H")
                  }
                  append("ello ")

                  withStyle(style = SpanStyle(fontWeight = FontWeight.Bold, color = Color.Red)) {
                      append("W")
                  }
                  append("orld")
              }
          )
      }TextSnippets.kt

   |image-text-inline-styles|

   .. rubric:: Enable advanced styling with ``Brush``
      :name: brush

   To enable more advanced text styling, you can use the
   `Brush  <#Brush>`__ API with
   `TextStyle  <#TextStyle>`__ and
   `SpanStyle  <#SpanStyle>`__. In
   any place where you would typically use ``TextStyle`` or ``SpanStyle``, you
   can now also use ``Brush``.

   **Caution:**\  The current usage of the Brush API in ``TextStyle`` is
   experimental. Experimental APIs can change in the future.

   .. rubric:: Use a brush for text styling
      :name: use-brush

   Configure your text using a built-in brush within ``TextStyle``. For example,
   you can configure a
   `linearGradient  <#linearGradient>`__
   brush to your text as follows:

   .. code:: prettyprint

      val gradientColors = listOf(Cyan, LightBlue, Purple /*...*/)

      Text(
          text = text,
          style = TextStyle(
              brush = Brush.linearGradient(
                  colors = gradientColors
              )
          )
      )TextSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text-designmain.png
      name: image-2
      :alt: Using Brush API’s \`linearGradient\` function with a defined list of
      colors.
      :width: 45.0%

      **Figure 2.** Using Brush API’s ``linearGradient`` function with a defined
      list of colors.

   You are not limited to this particular color scheme or style of coloring.
   While we have provided a simple example to highlight, use any of the built-in
   `brushes  <#Brush>`__ or even
   just a
   `SolidColor  <#SolidColor>`__
   to enhance your text.

   .. rubric:: Integrations
      :name: brush-integrations

   Since you can use ``Brush`` alongside both ``TextStyle`` and ``SpanStyle``,
   integration with
   `TextField  <#TextField>`__
   and
   `buildAnnotatedString  <#buildAnnotatedString>`__
   is seamless.

   For more information about using the brush API within a ``TextField``, see
   `Style input with Brush API  <#style-input>`__.

   .. rubric:: Additional styling using ``SpanStyle``
      :name: span-style

   .. rubric:: Apply a brush to a span of text
      :name: apply-brush-to-span

   If you only want to apply a brush to parts of your text, use
   `buildAnnotatedString  <#buildAnnotatedString>`__
   and the
   `SpanStyle  <#SpanStyle>`__ API,
   along with your brush and gradient of choice.

   .. code:: prettyprint

      Text(
          text = buildAnnotatedString {
              append("Do not allow people to dim your shine\n")
              withStyle(
                  SpanStyle(
                      brush = Brush.linearGradient(
                          colors = rainbowColors
                      )
                  )
              ) {
                  append("because they are blinded.")
              }
              append("\nTell them to put some sunglasses on.")
          }
      )TextSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text-style.png
      name: image-4
      :alt: Using a default brush with linearGradient as a style for Text.
      :width: 55.0%

      **Figure 4.** Using a default brush with ``linearGradient`` as a style for
      ``Text``.

   .. rubric:: Opacity in a span of text
      :name: text-opacity

   To adjust the opacity of a particular span of text, use
   `SpanStyle  <#SpanStyle>`__'s
   optional ``alpha`` parameter. Use the same brush for both parts of a text,
   and change the alpha parameter in the corresponding span. In the code sample,
   the first span of text displays at half opacity (``alpha =.5f``) while the
   second displays at full opacity (``alpha = 1f``).

   .. code:: prettyprint

      val brush = Brush.linearGradient(colors = rainbowColors)

      buildAnnotatedString {
          withStyle(
              SpanStyle(
                  brush = brush, alpha = .5f
              )
          ) {
              append("Text in ")
          }
          withStyle(
              SpanStyle(
                  brush = brush, alpha = 1f
              )
          ) {
              append("Compose ❤️")
          }
      }TextSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text-opacity.png
      name: image-5
      :alt: Using buildAnnotatedString and SpanStyle’s alpha parameter, along
      with linearGradient to add opacity to a span of text.
      :width: 55.0%

      **Figure 5.** Using ``buildAnnotatedString`` and ``SpanStyle``\ ’s alpha
      parameter, along with ``linearGradient`` to add opacity to a span of text.

   .. rubric:: Additional resources
      :name: additional-resources

   For additional customization examples, see the `Brushing Up on Compose Text Coloring <https://medium.com/androiddevelopers/brushing-up-on-compose-text-coloring-84d7d70dd8fa>`__
   blog post. If you are interested in learning more about how ``Brush``
   integrates with our Animations API, see `Animating brush Text coloring in Compose <https://medium.com/androiddevelopers/animating-brush-text-coloring-in-compose-%EF%B8%8F-26ae99d9b402>`__.

   .. rubric:: Apply marquee effect to text
      :name: apply-marquee

   You can apply the
   `basicMarquee  <#basicMarquee>`__
   modifier to any composable to produce an animated scrolling effect. The
   marquee effect occurs if the content is too wide to fit in the available
   constraints. By default, ``basicMarquee`` has certain configurations (such as
   velocity and initial delay) set, but you can modify these parameters to
   customize the effect.

   The following snippet implements a basic marquee effect on a ``Text``
   composable:

   .. code:: prettyprint

      @OptIn(ExperimentalFoundationApi::class)
      @Composable
      fun BasicMarqueeSample() {
          // Marquee only animates when the content doesn't fit in the max width.
          Column(Modifier.width(400.dp)) {
              Text(
                  "Learn about why it's great to use Jetpack Compose",
                  modifier = Modifier.basicMarquee(),
                  fontSize = 50.sp
              )
          }
      }TextSnippets.kt

   **Figure 6.** The ``basicMarquee`` modifier applied to text.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Style paragraph  <#style-paragraph>`__
   -  `Material Design 2 in Compose  <#material>`__
   -  `Graphics Modifiers  <#modifiers>`__

Last updated 2024-05-03 UTC.

.. |The words| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-blue.png
.. |image-text-big| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-big.png
.. |image-text-italic| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-italic.png
.. |image-text-bold| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-bold.png
.. |image-text-shadow| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-shadow.png
.. |image-text-inline-styles| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-inline-styles.png

/Style paragraph
================

.. https://developer.android.google.cn/develop/ui/compose/text/style-paragraph?hl=en

.. container:: devsite-article-body clearfix

   This page describes how you can style text for your paragraph. To set
   paragraph-level styling, you can configure parameters like ``textAlign`` and
   ``lineHeight`` or define your own ``ParagraphStyle``.

   .. rubric:: Set text alignment
      :name: text-alignment

   The ``textAlign`` parameter lets you set the horizontal
   `alignment  <#TextAlign>`__ of
   the text within a ``Text`` composable surface area.

   By default, ``Text`` will select the natural text alignment depending on its
   content value:

   -  Left edge of the ``Text`` container for left-to-right alphabets such as
      Latin, Cyrillic, or Hangul
   -  Right edge of the ``Text`` container for right-to-left alphabets such as
      Arabic or Hebrew

   .. code:: prettyprint

      @Composable
      fun CenterText() {
          Text(
              "Hello World", textAlign = TextAlign.Center, modifier = Modifier.width(150.dp)
          )
      }TextSnippets.kt

   |The words|

   If you want to manually set the text alignment of a ``Text`` composable,
   prefer using ``TextAlign.Start`` and ``TextAlign.End`` instead of
   ``TextAlign.Left`` and ``TextAlign.Right`` respectively, as they resolve to
   the right edge of the ``Text`` composable depending on the preferred language
   text orientation. For example, ``TextAlign.End`` aligns to the right side for
   French text and to the left side for Arabic text, but ``TextAlign.Right``
   aligns to the right side no matter what alphabet is used.

   **Note:**\  Text alignment is different from layout alignment, which is about
   positioning a Composable within a container such as a ``Row`` or ``Column``.
   For more information, see `Compose layout basics  <#basics>`__.

   .. rubric:: Add multiple styles in a paragraph
      :name: multiple-paragraph-styles

   To add multiple styles in a paragraph, you can use
   `ParagraphStyle  <#ParagraphStyle>`__
   in an
   `AnnotatedString  <#AnnotatedString>`__,
   which can be annotated with styles of arbitrary annotations. Once a portion
   of your text is marked with a ``ParagraphStyle``, that portion is separated
   from the remaining text as if it had line feeds at the beginning and end.

   For more information about adding multiple styles in a text, see `Add multiple styles in text  <#multiple-styles>`__.

   ``AnnotatedString`` has a `type-safe builder <https://kotlinlang.org/docs/reference/type-safe-builders.html>`__ to
   make it easier to create:
   `buildAnnotatedString  <#buildAnnotatedString>`__.
   The following snippet uses ``buildAnnotatedString`` to set
   ``ParagraphStyle``:

   .. code:: prettyprint

      @Composable
      fun ParagraphStyle() {
          Text(
              buildAnnotatedString {
                  withStyle(style = ParagraphStyle(lineHeight = 30.sp)) {
                      withStyle(style = SpanStyle(color = Color.Blue)) {
                          append("Hello\n")
                      }
                      withStyle(
                          style = SpanStyle(
                              fontWeight = FontWeight.Bold, color = Color.Red
                          )
                      ) {
                          append("World\n")
                      }
                      append("Compose")
                  }
              }
          )
      }TextSnippets.kt

   |Three paragraphs in three different styles: Blue, red and bold, and plain
   black|

   .. rubric:: Adjust line height and padding
      :name: adjust-line-height

   `includeFontPadding  <#attr_android:includeFontPadding>`__
   is a legacy property that adds extra padding based on font metrics at the top
   of the first line and bottom of the last line of a text. Starting from
   Compose BOM version ``2024.01.01``, ``includeFontPadding`` is set to
   ``false`` by default, which brings the default text layout more in line with
   common design tools.

   The ability to configure
   `lineHeight  <#attr_android:lineHeight>`__
   is not new– it has been available since Android Q. You can configure
   ``lineHeight`` for ``Text`` using the ``lineHeight`` parameter, which
   distributes the line height in each line of text. You can then use the new
   `LineHeightStyle API  <#LineHeightStyle>`__
   to further configure how this text is aligned within the space, and remove
   whitespace.

   You may want to adjust
   `lineHeight  <#lineHeight>`__
   using the text unit “em” (relative font size) instead of “sp” (scaled pixels)
   for improved precision. For more information about selecting an appropriate
   text unit, see
   `TextUnit  <#TextUnit>`__.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text-lineheightv3.png
      name: image-1
      :alt: Image showing lineHeight as a measurement based on the lines
      directly above and below it.
      :width: 35.0%

      **Figure 1.** Use Alignment and Trim to adjust the text within the set
      ``lineHeight``, and trim extra space if needed.

   .. code:: prettyprint

      Text(
          text = text,
          style = LocalTextStyle.current.merge(
              TextStyle(
                  lineHeight = 2.5.em,
                  platformStyle = PlatformTextStyle(
                      includeFontPadding = false
                  ),
                  lineHeightStyle = LineHeightStyle(
                      alignment = LineHeightStyle.Alignment.Center,
                      trim = LineHeightStyle.Trim.None
                  )
              )
          )
      )TextSnippets.kt

   In addition to adjusting ``lineHeight``, you can now further center and style
   text using configurations with the `LineHeightStyle experimental
   API  <#LineHeightStyle>`__:
   `LineHeightStyle.Alignment  <#LineHeightStyle.Alignment>`__
   and
   `LineHeightStyle.Trim  <#LineHeightStyle.Trim>`__
   (``includeFontPadding`` must be set to ``false`` for Trim to work). Alignment
   and Trim use the measured space in between lines of text to more
   appropriately distribute it to all lines– including a single line of text and
   the top line of a block of text.

   `LineHeightStyle.Alignment  <#LineHeightStyle.Alignment>`__
   defines how to align the line in the space provided by the line height.
   Within each line, you can align the text to the top, bottom, center, or
   proportionally. ``LineHeightStyle.Trim`` then allows you to leave or remove
   the extra space to the top of the first line and bottom of the last line of
   your text, generated from any ``lineHeight`` and Alignment adjustments. The
   following samples show how multi-line text looks with various
   `LineHeightStyle.Trim  <#LineHeightStyle.Trim>`__
   configurations when alignment is centered
   (``LineHeightStyle.Alignment.Center``).

   .. list-table::

      - 

         - |An image demonstrating LineHeightStyle.Trim.None|
         - |An image demonstrating LineHeightStyle.Trim.Both|
      - 

         - *``LineHeightStyle.Trim.None``*
         - *``LineHeightStyle.Trim.Both``*
      - 

         - |An image demonstrating LineHeightStyle.Trim.FirstLineTop|
         - |An image demonstrating LineHeightStyle.Trim.LastLineBottom|
      - 

         - *``LineHeightStyle.Trim.FirstLineTop``*
         - *``LineHeightStyle.Trim.LastLineBottom``*

   **Warning:**\  These adjustments using the ``LineHeightStyle`` API (Trim) can
   only work when you use them along with the configuration
   ``includeFontPadding = false.``
   See the `Fixing Font Padding in Compose Text <http://goo.gle/font-padding-compose>`__ blog post to learn more about
   the context of this change, how ``includeFontPadding`` worked in the View
   system, and the changes made for Compose and the new
   `LineHeightStyle  <#LineHeightStyle>`__
   APIs.

   .. rubric:: Insert line breaks
      :name: insert-line

   The
   `LineBreak  <#LineBreak>`__
   API defines the criteria by which text is split across multiple lines. You
   can specify the type of line breaking you want in the ``TextStyle`` block of
   your ``Text`` composable. The preset line breaking types include the
   following:

   -  ``Simple`` — Fast, basic line breaking. Recommended for text input fields.
   -  ``Heading`` — Line breaking with looser breaking rules. Recommended for
      short text, such as titles.
   -  ``Paragraph`` — Slower, higher-quality line breaking for improved
      readability. Recommended for larger amounts of text, such as paragraphs.

   The following snippet uses both ``Simple`` and ``Paragraph`` to specify
   line-breaking behavior on a long block of text:

   .. code:: prettyprint

      TextSample(
          samples = mapOf(
              "Simple" to {
                  Text(
                      text = SAMPLE_LONG_TEXT,
                      modifier = Modifier
                          .width(130.dp)
                          .border(BorderStroke(1.dp, Color.Gray)),
                      fontSize = 14.sp,
                      style = TextStyle.Default.copy(
                          lineBreak = LineBreak.Simple
                      )
                  )
              },
              "Paragraph" to {
                  Text(
                      text = SAMPLE_LONG_TEXT,
                      modifier = Modifier
                          .width(130.dp)
                          .border(BorderStroke(1.dp, Color.Gray)),
                      fontSize = 14.sp,
                      style = TextStyle.Default.copy(
                          lineBreak = LineBreak.Paragraph
                      )
                  )
              }
          )
      )TextSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text/simple-paragraph.png
      name: image-1
      :alt: A text block that shows a simple line breaking strategy versus a
      text block with a paragraph-optimized breaking strategy. The text block
      with the simple line breaking strategy has more variability in line
      lengths.
      :width: 40.0%

      **Figure 1.** A text block with a simple line breaking strategy (top)
      versus a text block with paragraph-optimized line breaking (bottom).

   In the above output, notice that the ``Paragraph`` line breaking behavior
   produces a more visually balanced result than the ``Simple`` line breaking.

   .. rubric:: Customize line breaks
      :name: customize-line

   You can also construct your own ``LineBreak`` configuration with the
   ``Strategy`` parameter. The ``Strategy`` can be any of the following:

   -  ``Balanced`` — Attempts to balance the line lengths of the text, also
      applying automatic hyphenation if enabled. Recommended for small screens,
      like watches, to maximize the amount of text displayed.
   -  ``HighQuality`` — Optimizes a paragraph for more readable text, including
      hyphenation if enabled. (Should be a default for everything that's not
      ``Balanced`` or ``Simple``.)
   -  ``Simple`` — basic, fast strategy. If enabled, hyphenation is done only
      for words that don't fit on an entire line by themselves. Useful for
      editing text to avoid changing positions while typing.

   **Note:**\  You can also customize your line breaking behavior with the
   ``Strictness`` and ``WordBreak`` parameters. These parameters are designed
   for CJK languages, and you may not see the intended effect if using them for
   non-CJK languages. For more information, see `CJK considerations <#cjk-considerations>`__.
   The following snippet shows the difference between a paragraph with default
   settings and a paragraph optimized for small screens with the ``Balanced``
   line-breaking strategy:

   .. code:: prettyprint

      TextSample(
          samples = mapOf(
              "Balanced" to {
                  val smallScreenAdaptedParagraph =
                      LineBreak.Paragraph.copy(strategy = LineBreak.Strategy.Balanced)
                  Text(
                      text = SAMPLE_LONG_TEXT,
                      modifier = Modifier
                          .width(200.dp)
                          .border(BorderStroke(1.dp, Color.Gray)),
                      fontSize = 14.sp,
                      style = TextStyle.Default.copy(
                          lineBreak = smallScreenAdaptedParagraph
                      )
                  )
              },
              "Default" to {
                  Text(
                      text = SAMPLE_LONG_TEXT,
                      modifier = Modifier
                          .width(200.dp)
                          .border(BorderStroke(1.dp, Color.Gray)),
                      fontSize = 14.sp,
                      style = TextStyle.Default
                  )
              }
          )
      )TextSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text/balanced-default.png
      name: image-2
      :alt: A paragraph with a balanced line breaking strategy and a paragraph
      formatted without a strategy. The paragraph with the balanced line
      breaking strategy has more consistent line lengths than the default.
      :width: 50.0%

      **Figure 2.** A paragraph formatted with a ``Balanced`` line-breaking
      strategy (top) versus a paragraph formatted without a line-breaking
      strategy.

   .. rubric:: CJK considerations
      :name: cjk-considerations

   You can also customize ``LineBreak`` with the
   `Strictness  <#LineBreak.Strictness>`__
   and
   `WordBreak  <#LineBreak.WordBreak>`__
   APIs, which were **designed specifically for CJK languages**. You may not
   always see the effects of these APIs in non-CJK languages. Overall,
   line-breaking rules are defined based on locale.

   ``Strictness`` describes the strictness of the line breaking with the
   following properties:

   **Note:**\  The default recommended value for ``Strictness`` varies based on
   locale.

   -  ``Default`` — Default breaking rules for the locale. May correspond to
      ``Normal`` or ``Strict``.
   -  ``Loose`` — The least restrictive rules. Suitable for short lines.
   -  ``Normal`` — The most common rules for line breaking.
   -  ``Strict`` — The most stringent rules for line breaking.

   ``WordBreak`` defines how line breaks should be inserted within words with
   the following properties:

   -  ``Default`` — Default breaking rules for the locale.
   -  ``Phrase`` — Line breaking is based on phrases.

   The following snippet uses a ``Strict`` strictness and a ``Phrase`` word
   breaking setting for a Japanese text:

   **Note:**\  To test the following snippet, choose the Japanese locale on your
   device (**Settings** > **System** > **Languages & Input** > **Languages** >
   **Japanese**).
   .. code:: prettyprint

      val customTitleLineBreak = LineBreak(
          strategy = LineBreak.Strategy.HighQuality,
          strictness = LineBreak.Strictness.Strict,
          wordBreak = LineBreak.WordBreak.Phrase
      )
      Text(
          text = "あなたに寄り添う最先端のテクノロジー。",
          modifier = Modifier.width(250.dp),
          fontSize = 14.sp,
          style = TextStyle.Default.copy(
              lineBreak = customTitleLineBreak
          )
      )TextSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text/cjk-line-break.png
      name: image-3
      :alt: Japanese text with Strictness and WordBreak settings versus default
      text.
      :width: 30.0%

      **Figure 3.** Text formatted with ``Strictness`` and ``WordBreak``
      settings (top) versus text formatted only with ``LineBreak.Heading``
      (bottom).

   .. rubric:: Hyphenate text split across lines
      :name: hyphenate-text

   The
   `Hyphens  <#Hyphens>`__
   API lets you add hyphenation support to your app. *Hyphenation* refers to
   inserting a dash-like punctuation mark to indicate that a word is divided
   across lines of text. When enabled, hyphenation is added between the
   syllables of a word at appropriate hyphenation points.

   By default, hyphenation is not enabled. To enable hyphenation, add
   ``Hyphens.Auto`` as a parameter in a ``TextStyle`` block:

   .. code:: prettyprint

      TextSample(
          samples = mapOf(
              "Hyphens - None" to {
                  Text(
                      text = SAMPLE_LONG_TEXT,
                      modifier = Modifier
                          .width(130.dp)
                          .border(BorderStroke(1.dp, Color.Gray)),
                      fontSize = 14.sp,
                      style = TextStyle.Default.copy(
                          lineBreak = LineBreak.Paragraph,
                          hyphens = Hyphens.None
                      )
                  )
              },
              "Hyphens - Auto" to {
                  Text(
                      text = SAMPLE_LONG_TEXT,
                      modifier = Modifier
                          .width(130.dp)
                          .border(BorderStroke(1.dp, Color.Gray)),
                      fontSize = 14.sp,
                      style = TextStyle.Default.copy(
                          lineBreak = LineBreak.Paragraph,
                          hyphens = Hyphens.Auto
                      )
                  )
              }
          )
      )TextSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text/hyphens.png
      name: image-4
      :alt: A paragraph without hyphenation enabled and a paragraph with
      hyphenation enabled. When hyphenation is enabled, a word is hyphenated and
      split across two lines.
      :width: 50.0%

      **Figure 4.** A paragraph without hyphenation enabled (top) versus a
      paragraph with hyphenation enabled (bottom).

   When enabled, hyphenation only occurs under the following conditions:

   -  A word does not fit onto a line. If you use a ``Simple`` line breaking
      strategy, the hyphenation of a word occurs only if a line is shorter than
      the single word.
   -  The appropriate locale is set on your device, as appropriate hyphenation
      is determined using dictionaries present on the system.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Style text  <#style-text>`__
   -  `Compose layout basics  <#basics>`__
   -  `Intrinsic measurements in Compose layouts  <#intrinsic-measurements>`__

Last updated 2024-05-03 UTC.

.. |The words| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-centered.png
.. |Three paragraphs in three different styles: Blue, red and bold, and plain black| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-paragraph-styles.png
.. |An image demonstrating LineHeightStyle.Trim.None| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-none.png
   :width: 50.0%
.. |An image demonstrating LineHeightStyle.Trim.Both| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-both.png
   :width: 50.0%
.. |An image demonstrating LineHeightStyle.Trim.FirstLineTop| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-first.png
   :width: 50.0%
.. |An image demonstrating LineHeightStyle.Trim.LastLineBottom| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-last.png
   :width: 50.0%

/Configure text layout
======================

.. https://developer.android.google.cn/develop/ui/compose/text/configure-layout?hl=en

.. container:: devsite-article-body clearfix

   This page describes how to configure your text layout with parameters like
   ``maxLines`` and ``overflow``.

   .. rubric:: Limit visible lines
      :name: limit-visible-lines

   To limit the number of visible lines in a ``Text`` composable, set the
   ``maxLines`` parameter:

   .. code:: prettyprint

      @Composable
      fun LongText() {
          Text("hello ".repeat(50), maxLines = 2)
      }TextSnippets.kt

   |A long text passage truncated after two lines|

   .. rubric:: Indicate text overflow
      :name: text-overflow

   When limiting a long text, you may want to indicate a
   `TextOverflow  <#TextOverflow>`__,
   which is only shown if the displayed text is truncated. To do so, set the
   ``textOverflow`` parameter:

   .. code:: prettyprint

      @Composable
      fun OverflowedText() {
          Text("Hello Compose ".repeat(50), maxLines = 2, overflow = TextOverflow.Ellipsis)
      }TextSnippets.kt

   |A long passage of text truncated after three lines, with an ellipsis at the
   end|

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Graphics in Compose  <#overview>`__
   -  `Style paragraph  <#style-paragraph>`__
   -  `Work with fonts  <#fonts>`__

Last updated 2024-05-03 UTC.

.. |A long text passage truncated after two lines| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-maxlines.png
   :width: 400px
.. |A long passage of text truncated after three lines, with an ellipsis at the end| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-overflow.png
   :width: 400px

/Handle user input
==================

.. https://developer.android.google.cn/develop/ui/compose/text/user-input?hl=en

.. container:: devsite-article-body clearfix

   `TextField  <#TextField>`__
   allows users to enter and modify text. This page describes how you can
   implement ``TextField``, style ``TextField`` input, and configure other
   ``TextField`` options, like keyboard options and visually transforming user
   input.

   .. rubric:: Choose ``TextField`` implementation
      :name: choose-textfield

   There are two levels of ``TextField`` implementation:

   #. ``TextField`` is the Material Design implementation. We recommend you
      choose this implementation as it follows `Material Design guidelines <https://material.io/components/text-fields>`__:

      -  Default styling is
         `filled <https://material.io/components/text-fields#filled-text-field>`__
      -  ``OutlinedTextField`` is the
         `outline <https://material.io/components/text-fields#outlined-text-field>`__
         styling version

   #. `BasicTextField  <#BasicTextField>`__
      enables users to edit text via hardware or software keyboard, but provides
      no decorations like hint or placeholder.

   .. code:: prettyprint

      @Composable
      fun SimpleFilledTextFieldSample() {
          var text by remember { mutableStateOf("Hello") }

          TextField(
              value = text,
              onValueChange = { text = it },
              label = { Text("Label") }
          )
      }TextSnippets.kt

   |An editable text field containing the word|

   .. code:: prettyprint

      @Composable
      fun SimpleOutlinedTextFieldSample() {
          var text by remember { mutableStateOf("") }

          OutlinedTextField(
              value = text,
              onValueChange = { text = it },
              label = { Text("Label") }
          )
      }TextSnippets.kt

   |An editable text field, with a purple border and label.|

   .. rubric:: Style ``TextField``
      :name: style-textfield

   ``TextField`` and ``BasicTextField`` share a lot of common parameters to
   customize them. The complete list for ``TextField`` is available in the
   `TextField source
   code <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material/material/src/commonMain/kotlin/androidx/compose/material/TextField.kt;l=149>`__.
   This is a non-exhaustive list of some of the useful parameters:

   -  ``singleLine``
   -  ``maxLines``
   -  ``textStyle``

   .. code:: prettyprint

      @Composable
      fun StyledTextField() {
          var value by remember { mutableStateOf("Hello\nWorld\nInvisible") }

          TextField(
              value = value,
              onValueChange = { value = it },
              label = { Text("Enter text") },
              maxLines = 2,
              textStyle = TextStyle(color = Color.Blue, fontWeight = FontWeight.Bold),
              modifier = Modifier.padding(20.dp)
          )
      }TextSnippets.kt

   |A multiline TextField, with two editable lines plus the label|

   We recommend ``TextField`` over ``BasicTextField`` when your design calls for
   a Material ``TextField`` or ``OutlineTextField``. However, ``BasicTextField``
   should be used when building designs that don't need the decorations from the
   Material spec.

   .. rubric:: Style input with Brush API
      :name: style-input

   You can use the `Brush API  <#brush>`__ for
   more advanced styling in your ``TextField``. The following section describes
   how you can use a Brush to add a colored gradient to ``TextField`` input.

   For more information about using the Brush API to style text, see `Enable advanced styling with Brush API  <#brush>`__.

   **Caution:**\  The current usage of the Brush API in ``TextStyle`` is
   experimental. Experimental APIs can change in the future.

   .. rubric:: Implement colored gradients using ``TextStyle``
      :name: implement-gradients

   To implement a colored gradient as you type within a ``TextField``, set your
   brush of choice as a
   `TextStyle  <#TextStyle>`__ for
   your ``TextField``. In this example, we use a built-in brush with a
   ``linearGradient`` to view the rainbow gradient effect as text is typed into
   the ``TextField``.

   .. code:: prettyprint

      var text by remember { mutableStateOf("") }
      val brush = remember {
          Brush.linearGradient(
              colors = rainbowColors
          )
      }
      TextField(
          value = text, onValueChange = { text = it }, textStyle = TextStyle(brush = brush)
      )TextSnippets.kt

   **Note:**\  Make sure to use the ``remember`` function to persist the brush
   across recompositions, when the ``TextField`` state changes on each new typed
   character.
   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text-textfieldgradient.gif
      name: image-3
      :alt: Using buildAnnotatedString and SpanStyle, along with linearGradient,
      to customize only a piece of text.
      :width: 55.0%

      **Figure 3.** Using ``buildAnnotatedString`` and ``SpanStyle``, along with
      ``linearGradient``, to customize only a piece of text.

   .. rubric:: Set keyboard options
      :name: keyboard-options

   ``TextField`` lets you set keyboard configurations options, such as the
   keyboard layout, or enable the autocorrect if it’s supported by the keyboard.
   Some options may not be guaranteed if the software keyboard doesn't comply
   with the options provided here. Here is the list of the `supported keyboard options  <#KeyboardOptions>`__:

   -  ``capitalization``
   -  ``autoCorrect``
   -  ``keyboardType``
   -  ``imeAction``

   .. rubric:: Format input
      :name: format-input

   ``TextField`` allows you to set a
   `VisualTransformation  <#VisualTransformation>`__
   on the input value, like replacing characters with ``*`` for passwords, or
   inserting hyphens every 4 digits for a credit card number:

   .. code:: prettyprint

      @Composable
      fun PasswordTextField() {
          var password by rememberSaveable { mutableStateOf("") }

          TextField(
              value = password,
              onValueChange = { password = it },
              label = { Text("Enter password") },
              visualTransformation = PasswordVisualTransformation(),
              keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password)
          )
      }TextSnippets.kt

   |A password text entry field, with the text masked|

   More examples are available in the `VisualTransformationSamples source
   code <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui-text/samples/src/main/java/androidx/compose/ui/text/samples/VisualTransformationSamples.kt>`__.

   .. rubric:: Clean input
      :name: clean-input

   A common task when editing text is to strip leading characters, or otherwise
   transform the input string each time it changes.

   As a model, you should assume that the keyboard may make arbitrary and large
   edits each ``onValueChange``. This may happen, for example, if the user uses
   autocorrect, replaces a word with an emoji, or other smart editing features.
   To correctly handle this, write any transformation logic with the assumption
   that the current text passed to ``onValueChange`` is unrelated to the
   previous or next values that will be passed to ``onValueChange``.

   To implement a text field that disallows leading zeros, you can do this by
   stripping all leading zeroes on every value change.

   .. code:: prettyprint

      @Composable
      fun NoLeadingZeroes() {
          var input by rememberSaveable { mutableStateOf("") }
          TextField(
              value = input,
              onValueChange = { newText ->
                  input = newText.trimStart { it == '0' }
              }
          )
      }TextSnippets.kt

   To control the cursor position while cleaning text, use the
   `TextFieldValue  <#TextFieldValue>`__
   overload of
   `TextField  <#TextField>`__
   as part of the state.

   .. rubric:: Best practices with state
      :name: state-practices

   The following is a series of best practices to define and update
   ``TextField`` state to prevent input issues in your app.

   -  **Use**
      `MutableState  <#MutableState>`__
      **to represent ``TextField`` state**: Avoid using reactive streams like
      `StateFlow <https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/>`__
      to represent ``TextField`` state, as these structures might introduce
      asynchronous delays.

   .. code:: prettyprint

      class SignUpViewModel : ViewModel() {

          var username by mutableStateOf("")
              private set

          /* ... */
      }TextSnippets.kt

   -  **Avoid delays to update the state**: When you call ``onValueChange``,
      update your ``TextField`` synchronously and immediately:

   .. code:: prettyprint

      // SignUpViewModel.kt

      class SignUpViewModel(private val userRepository: UserRepository) : ViewModel() {

          var username by mutableStateOf("")
              private set

          fun updateUsername(input: String) {
              username = input
          }
      }

      // SignUpScreen.kt

      @Composable
      fun SignUpScreen(/*...*/) {

          OutlinedTextField(
              value = viewModel.username,
              onValueChange = { username -> viewModel.updateUsername(username) }
              /*...*/
          )
      }TextSnippets.kt

   -  **Where to define the state**: If your ``TextField`` state requires
      business logic validations as you type, it is correct to hoist the state
      to your ``ViewModel``. If it doesn’t, you can use composables or a state
      holder class as the source of truth. To learn more about where to hoist
      your state, see the `state hoisting  <#state-hoisting>`__ documentation.

   **Note:**\  For more information about these best practices, see the
   `Effective state management for ``TextField`` in
   Compose <https://medium.com/androiddevelopers/effective-state-management-for-textfield-in-compose-d6e5b070fbe5>`__
   blog post.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Architecting your Compose UI  <#architecture>`__
   -  `State and Jetpack Compose  <#state>`__
   -  `Save UI state in Compose  <#state-saving>`__

Last updated 2024-05-03 UTC.

.. |An editable text field containing the word| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-textfield-hello.png
   :width: 400px
.. |An editable text field, with a purple border and label.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-outlinedtextfield.png
   :width: 400px
.. |A multiline TextField, with two editable lines plus the label| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-textfield-multiline.png
   :width: 400px
.. |A password text entry field, with the text masked| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-textfield-password.png
   :width: 400px

/Enable user interactions
=========================

.. https://developer.android.google.cn/develop/ui/compose/text/user-interactions?hl=en

.. container:: devsite-article-body clearfix

   Jetpack Compose enables fine-grained interactivity in ``Text``. Text
   selection is now more flexible and can be done across composable layouts.
   User interactions in text are different from other composable layouts, as you
   can’t add a modifier to a portion of a ``Text`` composable. This page
   highlights the APIs that enable user interactions.

   .. rubric:: Select text
      :name: select-text

   By default, composables aren’t selectable, which means that users can't
   select and copy text from your app. To enable text selection, wrap your text
   elements with a
   `SelectionContainer  <#SelectionContainer>`__
   composable:

   .. code:: prettyprint

      @Composable
      fun SelectableText() {
          SelectionContainer {
              Text("This text is selectable")
          }
      }TextSnippets.kt

   |A short passage of text, selected by the user.|

   You may want to disable selection on specific parts of a selectable area. To
   do so, you need to wrap the unselectable part with a
   `DisableSelection  <#DisableSelection>`__
   composable:

   .. code:: prettyprint

      @Composable
      fun PartiallySelectableText() {
          SelectionContainer {
              Column {
                  Text("This text is selectable")
                  Text("This one too")
                  Text("This one as well")
                  DisableSelection {
                      Text("But not this one")
                      Text("Neither this one")
                  }
                  Text("But again, you can select this one")
                  Text("And this one too")
              }
          }
      }TextSnippets.kt

   |A longer passage of text. The user tried to select the whole passage, but
   since two lines had DisableSelection applied, they were not selected.|

   .. rubric:: Get position of a click on text
      :name: get-click-position

   To listen for clicks on ``Text``, you can add the
   `clickable  <#clickable>`__
   modifier. However, if you want to *get the position of a click* within a
   ``Text`` composable, in the case where you have different actions based on
   different parts of the text, you need to use a
   `ClickableText  <#ClickableText>`__
   instead:

   .. code:: prettyprint

      @Composable
      fun SimpleClickableText() {
          ClickableText(text = AnnotatedString("Click Me"), onClick = { offset ->
              Log.d("ClickableText", "$offset -th character is clicked.")
          })
      }TextSnippets.kt

   .. rubric:: Click with annotation
      :name: click-with-annotation

   When a user clicks on a ``Text`` composable, you may want to attach extra
   information to a part of the ``Text`` value, like a URL attached to a
   specific word to be opened in a browser for example. To do so, you need to
   attach an annotation, which takes a tag (``String``), an item (``String``),
   and a text range as parameters. From an ``AnnotatedString``, these
   annotations can be filtered with their tags or text ranges. Here’s an
   example:

   .. code:: prettyprint

      @Composable
      fun AnnotatedClickableText() {
          val annotatedText = buildAnnotatedString {
              append("Click ")

              // We attach this *URL* annotation to the following content
              // until `pop()` is called
              pushStringAnnotation(
                  tag = "URL", annotation = "https://developer.android.com"
              )
              withStyle(
                  style = SpanStyle(
                      color = Color.Blue, fontWeight = FontWeight.Bold
                  )
              ) {
                  append("here")
              }

              pop()
          }

          ClickableText(text = annotatedText, onClick = { offset ->
              // We check if there is an *URL* annotation attached to the text
              // at the clicked position
              annotatedText.getStringAnnotations(
                  tag = "URL", start = offset, end = offset
              ).firstOrNull()?.let { annotation ->
                  // If yes, we log its value
                  Log.d("Clicked URL", annotation.item)
              }
          })
      }TextSnippets.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Semantics in Compose  <#semantics>`__
   -  `Accessibility in Compose  <#accessibility>`__
   -  `Material Design 2 in Compose  <#material>`__

Last updated 2024-05-03 UTC.

.. |A short passage of text, selected by the user.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-selected.png
   :width: 400px
.. |A longer passage of text. The user tried to select the whole passage, but since two lines had DisableSelection applied, they were not selected.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-partially-selected.png
   :width: 400px

/Work with fonts
================

.. https://developer.android.google.cn/develop/ui/compose/text/fonts?hl=en

.. container:: devsite-article-body clearfix

   This page describes how to set fonts in your Compose app.

   .. rubric:: Set font
      :name: set-font

   ``Text`` has a ``fontFamily`` parameter to allow setting the font used in the
   composable. By default, serif, sans-serif, monospace and cursive font
   families are
   `included  <#summary>`__:

   .. code:: prettyprint

      @Composable
      fun DifferentFonts() {
          Column {
              Text("Hello World", fontFamily = FontFamily.Serif)
              Text("Hello World", fontFamily = FontFamily.SansSerif)
          }
      }TextSnippets.kt

   |The words|

   You can use the ``fontFamily`` attribute to work with custom fonts and
   typefaces defined in the ``res/font`` folder:

   |Graphical depiction of the res > font folder in the development environment|

   This example shows how you would define a ``fontFamily`` based on those font
   files and using the `Font function  <#Font>`__:

   .. code:: prettyprint

      val firaSansFamily = FontFamily(
          Font(R.font.firasans_light, FontWeight.Light),
          Font(R.font.firasans_regular, FontWeight.Normal),
          Font(R.font.firasans_italic, FontWeight.Normal, FontStyle.Italic),
          Font(R.font.firasans_medium, FontWeight.Medium),
          Font(R.font.firasans_bold, FontWeight.Bold)
      )TextSnippets.kt

   You can pass this ``fontFamily`` to your ``Text`` composable. Because a
   ``fontFamily`` can include different weights, you can manually set
   ``fontWeight`` to select the right weight for your text:

   .. code:: prettyprint

      Column {
          Text(text = "text", fontFamily = firaSansFamily, fontWeight = FontWeight.Light)
          Text(text = "text", fontFamily = firaSansFamily, fontWeight = FontWeight.Normal)
          Text(
              text = "text",
              fontFamily = firaSansFamily,
              fontWeight = FontWeight.Normal,
              fontStyle = FontStyle.Italic
          )
          Text(text = "text", fontFamily = firaSansFamily, fontWeight = FontWeight.Medium)
          Text(text = "text", fontFamily = firaSansFamily, fontWeight = FontWeight.Bold)
      }TextSnippets.kt

   |image-text-font-family|

   To learn how to set the typography in your entire app, see `Custom design systems in Compose  <#custom>`__.

   .. rubric:: Downloadable fonts
      :name: downloadable-fonts

   Starting in `Compose 1.2.0  <#1.2.0>`__,
   you can use the downloadable fonts API in your Compose app to download
   `Google fonts <https://fonts.google.com/>`__ asynchronously and use them in
   your app.

   Support for downloadable fonts provided by custom providers is not currently
   available.

   .. rubric:: Use downloadable fonts programmatically
      :name: use-downloadable-fonts

   To download a font programmatically from within your app, follow these steps:

   #. Add the dependency:

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Groovy
                  :name: groovy

               .. code:: prettyprint

                  dependencies {
                      ...
                      implementation "androidx.compose.ui:ui-text-google-fonts:1.6.7"
                  }

            .. container:: section

               .. rubric:: Kotlin
                  :name: kotlin

               .. code:: prettyprint

                  dependencies {
                      ...
                      implementation("androidx.compose.ui:ui-text-google-fonts:1.6.7")
                  }

   #. Initialize the
      `GoogleFont.Provider  <#GoogleFont.Provider>`__
      with the credentials for Google Fonts:

      .. code:: prettyprint

         val provider = GoogleFont.Provider(
             providerAuthority = "com.google.android.gms.fonts",
             providerPackage = "com.google.android.gms",
             certificates = R.array.com_google_android_gms_fonts_certs
         )TextDownloadableFontsSnippets.kt

      The parameters the provider receives are:

      -  The font provider authority for Google Fonts.
      -  The font provider package to verify the identity of the provider.
      -  A list of sets of hashes for the certificates to verify the identity of
         the provider. You can find the hashes required for the Google Fonts
         provider `in the ``font_certs.xml``
         file <https://github.com/android/compose-samples/blob/main/Jetchat/app/src/main/res/values-v23/font_certs.xml>`__
         in the Jetchat sample app.

   #. Define a
      `FontFamily  <#FontFamily>`__:

      .. code:: prettyprint

         // ...
          import androidx.compose.ui.text.googlefonts.GoogleFont
          import androidx.compose.ui.text.font.FontFamily
          import androidx.compose.ui.text.googlefonts.Font
          // ...

         val fontName = GoogleFont("Lobster Two")

         val fontFamily = FontFamily(
             Font(googleFont = fontName, fontProvider = provider)
         )TextDownloadableFontsSnippets.kt

      You can query for other parameters for your font like weight and style
      with
      `FontWeight  <#FontWeight>`__
      and
      `FontStyle  <#FontStyle>`__
      respectively:

      .. code:: prettyprint

         // ...
          import androidx.compose.ui.text.googlefonts.GoogleFont
          import androidx.compose.ui.text.font.FontFamily
          import androidx.compose.ui.text.googlefonts.Font
          // ...

         val fontName = GoogleFont("Lobster Two")

         val fontFamily = FontFamily(
             Font(
                 googleFont = fontName,
                 fontProvider = provider,
                 weight = FontWeight.Bold,
                 style = FontStyle.Italic
             )
         )TextDownloadableFontsSnippets.kt

   #. Configure the ``FontFamily`` to be used in your Text composable function:

   .. code:: prettyprint

      Text(
          fontFamily = fontFamily, text = "Hello World!"
      )TextDownloadableFontsSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text-dl-fontfamily.png
      name: dl-font-family

   You can also define
   `Typography  <#Typography>`__ to
   use your ``FontFamily``:

   .. code:: prettyprint

      val MyTypography = Typography(
          labelMedium = TextStyle(
              fontFamily = fontFamily, fontWeight = FontWeight.Normal, fontSize = 12.sp/*...*/
          ),
          labelLarge = TextStyle(
              fontFamily = fontFamily,
              fontWeight = FontWeight.Bold,
              letterSpacing = 2.sp,
              /*...*/
          ),
          displayMedium = TextStyle(
              fontFamily = fontFamily, fontWeight = FontWeight.SemiBold/*...*/
          ),
          /*...*/
      )TextDownloadableFontsSnippets.kt

   Next, set the Typography to your app’s theme:

   .. code:: prettyprint

      MyAppTheme(
          typography = MyTypography
      )/*...*/TextDownloadableFontsSnippets.kt

   For an example of an app that’s implementing downloadable fonts in Compose
   together with
   `Material3 <https://m3.material.io/styles/typography/overview>`__, see the
   `Jetchat <https://github.com/android/compose-samples/tree/main/Jetchat>`__
   sample app.

   .. rubric:: Add fallback fonts
      :name: fallback-fonts

   You can determine a chain of fallbacks for your font in case the font fails
   to download properly. For instance, if you have your downloadable font
   defined like this:

   .. code:: prettyprint

      // ...
       import androidx.compose.ui.text.googlefonts.Font
       // ...

      val fontName = GoogleFont("Lobster Two")

      val fontFamily = FontFamily(
          Font(googleFont = fontName, fontProvider = provider),
          Font(googleFont = fontName, fontProvider = provider, weight = FontWeight.Bold)
      )TextDownloadableFontsSnippets.kt

   You can define the defaults for your font for both weights like this:

   .. code:: prettyprint

      // ...
       import androidx.compose.ui.text.font.Font
       import androidx.compose.ui.text.googlefonts.Font
       // ...

      val fontName = GoogleFont("Lobster Two")

      val fontFamily = FontFamily(
          Font(googleFont = fontName, fontProvider = provider),
          Font(resId = R.font.my_font_regular),
          Font(googleFont = fontName, fontProvider = provider, weight = FontWeight.Bold),
          Font(resId = R.font.my_font_regular_bold, weight = FontWeight.Bold)
      )TextDownloadableFontsSnippets.kt

   Make sure you’re adding the correct imports.

   Defining the ``FontFamily`` like this creates a ``FontFamily`` containing two
   chains, one per weight. The loading mechanism will try to resolve the online
   font first, and then the font located in your local ``R.font`` resource
   folder.

   .. rubric:: Debug your implementation
      :name: debug-implementation

   To help you verify if the font is being downloaded correctly, you can define
   a debug coroutine handler. Your handle provides the behavior of what to do in
   case the font fails to load asynchronously.

   Start by creating a
   `CoroutineExceptionHandler <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html>`__:

   .. code:: prettyprint

      val handler = CoroutineExceptionHandler { _, throwable ->
          // process the Throwable
          Log.e(TAG, "There has been an issue: ", throwable)
      }TextDownloadableFontsSnippets.kt

   Pass it to the
   `createFontFamilyResolver  <#createFontFamilyResolver>`__
   method to have the resolver use the new handler:

   .. code:: prettyprint

      CompositionLocalProvider(
          LocalFontFamilyResolver provides createFontFamilyResolver(LocalContext.current, handler)
      ) {
          Column {
              Text(
                  text = "Hello World!", style = MaterialTheme.typography.bodyMedium
              )
          }
      }TextDownloadableFontsSnippets.kt

   You can also use the
   `isAvailableOnDevice  <#isAvailableOnDevice>`__
   API from the provider to test if the provider is available and certificates
   are configured correctly. To do this, you can call the
   ``isAvailableOnDevice`` method that returns false if the provider is
   configured incorrectly.

   .. code:: prettyprint

      val context = LocalContext.current
      LaunchedEffect(Unit) {
          if (provider.isAvailableOnDevice(context)) {
              Log.d(TAG, "Success!")
          }
      }TextDownloadableFontsSnippets.kt

   .. rubric:: Caveats
      :name: caveats

   Google Fonts takes several months to make new fonts available on Android.
   There's a gap in time between when a font is added in
   `fonts.google.com <https://fonts.google.com/>`__ and when it's available
   through the downloadable fonts API (either in the View system or in Compose).
   Newly added fonts might fail to load in your app with an
   `IllegalStateException <https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html>`__.
   To help developers identify this error over other types of font loading
   errors, we added descriptive messaging for the exception in Compose `with the changes here <https://android-review.googlesource.com/c/platform/frameworks/support/+/2098457/>`__.
   If you find any issues, report them `using the issue tracker <https://issuetracker.google.com/issues/new?component=779818>`__.

   .. rubric:: Use variable fonts
      :name: variable-fonts

   A variable font is a font format that allows one font file to contain
   different styles. With variable fonts, you can modify axes (or parameters) to
   generate your preferred style. These axes can be standard, such as weight,
   width, slant, and italic, or custom, which differ across variable fonts.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text/vf-configs.png
      name: image-1
      :alt: Five configurations of the same variable font with different axis
      values.
      :figclass: invert
      :width: 70.0%

      **Figure 1.** Text using the same variable font customized with different
      axis values.

   Using variable fonts instead of regular font files allows you to only have
   one font file instead of multiple.

   **Warning:**\  Variable fonts are only supported on Android O and above.
   For more background about variable fonts, see `Google Fonts Knowledge <https://fonts.google.com/knowledge/topics/variable_fonts>`__, the
   `entire catalog <https://fonts.google.com/?vfonly=true>`__ of available
   variable fonts, and a `table <https://fonts.google.com/variablefonts>`__ of
   the supported axes for each font.

   This doc shows you how to implement a variable font in your Compose app.

   .. rubric:: Load a variable font
      :name: load-variable

   #. Download the variable font you want to use (for example `Roboto Flex <https://fonts.google.com/specimen/Roboto+Flex)%7B:.external%7D>`__)
      and place it in the ``app/res/font`` folder in your app. Make sure that
      the .\ ``ttf`` file you add is the *variable font version* of the font,
      and that the name of your font file is all lowercase and doesn't contain
      any special characters.

      **Note:**\  Variable fonts are not currently supported via downloadable
      fonts. See the latest updates in `this bug <https://issuetracker.google.com/issues/223262013>`__.

   #. To load a variable font, define a ``FontFamily`` using the font placed in
      the ``res/font/`` directory:

      .. code:: prettyprint

         // In Typography.kt
         @OptIn(ExperimentalTextApi::class)
         val displayLargeFontFamily =
             FontFamily(
                 Font(
                     R.font.robotoflex_variable,
                     variationSettings = FontVariation.Settings(
                         FontVariation.weight(950),
                         FontVariation.width(30f),
                         FontVariation.slant(-6f),
                     )
                 )
             )VariableFontsSnippets.kt

      The ``FontVariation`` API allows you to configure standard font axes such
      as
      `weight  <#weight>`__,
      `width  <#width>`__,
      and
      `slant  <#slant>`__.
      These are standard axes that are available with any variable font. You can
      create different configurations of the font based on where the font will
      be used.

   #. Variable fonts are only available for Android versions O and above, so add
      a guardrail and configure an appropriate fallback:

      .. code:: prettyprint

         // In Typography.kt
         val default = FontFamily(
             /*
             * This can be any font that makes sense
             */
             Font(
                 R.font.robotoflex_static_regular
             )
         )
         @OptIn(ExperimentalTextApi::class)
         val displayLargeFontFamily = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
             FontFamily(
                 Font(
                     R.font.robotoflex_variable,
                     variationSettings = FontVariation.Settings(
                         FontVariation.weight(950),
                         FontVariation.width(30f),
                         FontVariation.slant(-6f),
                     )
                 )
             )
         } else {
             default
         }VariableFontsSnippets.kt

   #. Extract the settings into a set of constants for easier reuse and replace
      the font settings with these constants:

      .. code:: prettyprint

         // VariableFontDimension.kt
         object DisplayLargeVFConfig {
             const val WEIGHT = 950
             const val WIDTH = 30f
             const val SLANT = -6f
             const val ASCENDER_HEIGHT = 800f
             const val COUNTER_WIDTH = 500
         }

         @OptIn(ExperimentalTextApi::class)
         val displayLargeFontFamily = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
             FontFamily(
                 Font(
                     R.font.robotoflex_variable,
                     variationSettings = FontVariation.Settings(
                         FontVariation.weight(DisplayLargeVFConfig.WEIGHT),
                         FontVariation.width(DisplayLargeVFConfig.WIDTH),
                         FontVariation.slant(DisplayLargeVFConfig.SLANT),
                     )
                 )
             )
         } else {
             default
         }VariableFontsSnippets.kt

   #. Configure the Material Design 3
      `typography  <#typography>`__ to
      use the ``FontFamily``:

      .. code:: prettyprint

         // Type.kt
         val Typography = Typography(
             displayLarge = TextStyle(
                 fontFamily = displayLargeFontFamily,
                 fontSize = 50.sp,
                 lineHeight = 64.sp,
                 letterSpacing = 0.sp,
                 /***/
             )
         )VariableFontsSnippets.kt

      This sample uses ``displayLarge`` `Material 3 typography  <#typography>`__,
      which has different default font settings and recommended uses. For
      example, you should use ``displayLarge`` for short, critical text, as it's
      the largest text on the screen.

      With Material 3, you can change the default values of ``TextStyle`` and
      ``fontFamily`` to customize your typography. In the snippet above, you
      configure instances of ``TextStyle`` to customize font settings for each
      font family.

   #. Now that you've defined your typography, pass it to the M3
      ``MaterialTheme``:

      .. code:: prettyprint

         MaterialTheme(
             colorScheme = MaterialTheme.colorScheme,
             typography = Typography,
             content = content
         )VariableFontsSnippets.kt

   #. Finally, use a ``Text`` composable and specify the style to one of the
      defined typography styles, ``MaterialTheme.typography.displayLarge``:

      .. code:: prettyprint

         @Composable
         @Preview
         fun CardDetails() {
             MyCustomTheme {
                 Card(
                     shape = RoundedCornerShape(8.dp),
                     elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
                     modifier = Modifier
                         .fillMaxWidth()
                         .padding(16.dp)
                 ) {
                     Column(
                         modifier = Modifier.padding(16.dp)
                     ) {
                         Text(
                             text = "Compose",
                             style = MaterialTheme.typography.displayLarge,
                             modifier = Modifier.padding(bottom = 8.dp),
                             maxLines = 1
                         )
                         Text(
                             text = "Beautiful UIs on Android",
                             style = MaterialTheme.typography.headlineMedium,
                             modifier = Modifier.padding(bottom = 8.dp),
                             maxLines = 2
                         )
                         Text(
                             text = "Jetpack Compose is Android’s recommended modern toolkit for building native UI. It simplifies and accelerates UI development on Android. Quickly bring your app to life with less code, powerful tools, and intuitive Kotlin APIs.",
                             style = MaterialTheme.typography.bodyLarge,
                             modifier = Modifier.padding(bottom = 8.dp),
                             maxLines = 3
                         )
                     }
                 }
             }
         }VariableFontsSnippets.kt

      Each ``Text`` composable is configured through its Material theme's style
      and contains a different variable font configuration. You can use
      ``MaterialTheme.typography`` to retrieve the typography provided to the M3
      ``MaterialTheme`` composable.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text/vf-standard-axes.png
      name: image-2
      :alt: Three different texts, all showcasing different font configurations.
      :figclass: invert
      :width: 70.0%

      **Figure 2.** Variable font applied in three different configurations.

   .. rubric:: Use custom axes
      :name: use-custom

   Fonts can also have custom axes. These are defined within the font file
   itself. For example, the Roboto Flex font has the ascender height
   (``"YTAS"``) axis, which adjusts the height of the lowercase ascenders, while
   counter width (``"XTRA"``) adjusts the width of each letter.

   You can change the value of these axes with the ``FontVariation`` settings.

   For more information about the custom axes you can configure for a font, see
   the `table of the supported axes <https://fonts.google.com/variablefonts>`__
   for each font.

   #. To use custom axes, define functions for the custom ``ascenderHeight`` and
      ``counterWidth`` axes:

      .. code:: prettyprint

         fun ascenderHeight(ascenderHeight: Float): FontVariation.Setting {
             require(ascenderHeight in 649f..854f) { "'Ascender Height' must be in 649f..854f" }
             return FontVariation.Setting("YTAS", ascenderHeight)
         }

         fun counterWidth(counterWidth: Int): FontVariation.Setting {
             require(counterWidth in 323..603) { "'Counter width' must be in 323..603" }
             return FontVariation.Setting("XTRA", counterWidth.toFloat())
         }VariableFontsSnippets.kt

      These functions do the following:

      -  Define guardrails for the values they can accept. As you can see in the
         `Variable fonts catalog <https://fonts.google.com/variablefonts?vfquery=roboto+flex>`__,
         ``ascenderHeight (YTAS)`` has a minimum value of ``649f`` and a maximum
         of ``854f``.
      -  Return the font setting, so the configuration is ready to add to the
         font. In the ``FontVariation.Setting()`` method, the axis name
         (``YTAS, XTRA``) is hardcoded, and it takes the value as a parameter.

   #. Using the axes with the font configuration, pass additional parameters to
      each ``Font`` that is loaded:

      .. code:: prettyprint

         @OptIn(ExperimentalTextApi::class)
         val displayLargeFontFamily = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
             FontFamily(
                 Font(
                     R.font.robotoflex_variable,
                     variationSettings = FontVariation.Settings(
                         FontVariation.weight(DisplayLargeVFConfig.WEIGHT),
                         FontVariation.width(DisplayLargeVFConfig.WIDTH),
                         FontVariation.slant(DisplayLargeVFConfig.SLANT),
                         ascenderHeight(DisplayLargeVFConfig.ASCENDER_HEIGHT),
                         counterWidth(DisplayLargeVFConfig.COUNTER_WIDTH)
                     )
                 )
             )
         } else {
             default
         }VariableFontsSnippets.kt

      Notice that the height of the lowercase ascenders is now increased, and
      the other text is wider:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/text/vf-custom-axes.png
      name: image-3
      :alt: Three different texts showing different configurations for variable
      fonts, with custom axes set— some have higher lowercase ascenders and are
      wider than before.
      :figclass: invert
      :width: 70.0%

      **Figure 3.** Text showing custom axes set on variable fonts.

   .. rubric:: Additional resources
      :name: additional-resources

   For more information, see the following blog post about variable fonts:

   -  `Just your type: Variable fonts in Compose <https://medium.com/androiddevelopers/just-your-type-variable-fonts-in-compose-5bf63b357994>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Resources in Compose  <#resources>`__
   -  `Style text  <#style-text>`__
   -  `Material Design 2 in Compose  <#material>`__

Last updated 2024-05-03 UTC.

.. |The words| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-different-fonts.png
.. |Graphical depiction of the res > font folder in the development environment| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-font-folder.png
   :width: 400px
.. |image-text-font-family| image:: https://developer.android.google.cn/static/develop/ui/compose/images/text-font-family.png

/Display emoji
==============

.. https://developer.android.google.cn/develop/ui/compose/text/emoji?hl=en

.. container:: devsite-article-body clearfix

   The standard set of emoji is `refreshed annually by Unicode <https://emojipedia.org/new/>`__, as emoji usage is increasing
   rapidly for all types of apps.

   If your app displays internet content or provides text input, *we strongly
   recommend supporting the latest emoji fonts.* Otherwise, later emoji might be
   displayed as a small square box called *tofu* (☐) or other incorrectly
   rendered emoji sequences.

   Android versions 11 (API level 30) and lower can't update the emoji font, so
   apps that display them on those versions must be updated manually.

   The following are examples of modern emoji.

   .. list-table::
      :header-rows: 1

      - 

         - Examples
         - Version
      - 

         - 🫠 🫱🏼‍🫲🏿 🫰🏽
         - `14.0 <https://emojipedia.org/emoji-14.0/>`__ (September 2021)
      - 

         - 😶‍🌫️ 🧔🏻‍♀️ 🧑🏿‍❤️‍🧑🏾
         - `13.1 <https://emojipedia.org/emoji-13.1/>`__ (September 2020)
      - 

         - 🥲 🥷🏿 🐻‍❄️
         - `13.0 <https://emojipedia.org/unicode-13.0/>`__ (March 2020)
      - 

         - 🧑🏻‍🦰 🧑🏿‍🦯 👩🏻‍🤝‍👩🏼
         - `12.1 <https://emojipedia.org/emoji-12.1/>`__ (October 2019)
      - 

         - 🦩 🦻🏿 👩🏼‍🤝‍👩🏻
         - `12.0 <https://emojipedia.org/emoji-12.0/>`__ (February 2019)

   `BOM March 2023  <#bom>`__ (`Compose UI
   1.4  <#version_14_2)>`__) brings support
   for the `latest emoji version  <#emoji2>`__,
   including backwards compatibility with older Android versions down to API 21.

   *This support requires no changes to your app*— if you use ``Text`` and
   ``TextField`` (Material 2 or Material 3) or
   `BasicText  <#BasicText>`__
   and
   `BasicTextField  <#BasicTextField>`__,
   you get modern emoji support out of the box.

   The best way to test the `latest emojis <https://unicode.org/emoji/charts/emoji-versions.html>`__ in your app
   is by using a real device on API 30 or below.

   If you're using a custom emoji solution, or need to disable the default emoji
   resolution in Compose for any other reason, you can use
   `PlatformTextStyle(emojiSupportMatch) <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui-text/src/androidMain/kotlin/androidx/compose/ui/text/AndroidTextStyle.android.kt;l=85?q=emojisupportmatch>`__:

   .. code:: prettyprint

      Text(
          text = "Hello $EMOJI_TEXT",
          style = TextStyle(
              platformStyle = PlatformTextStyle(
                  emojiSupportMatch = EmojiSupportMatch.None
              )/* ... */
          )
      )EmojiSnippets.kt

   .. rubric:: Interoperatibility
      :name: interoperatibility

   If your app uses both Views and Compose in the same ``Activity``, make sure
   you are using the appropriate APIs to configure emojis correctly. The
   following sections describe when to use each API.

   .. rubric:: Extending from ``ComponentActivity``
      :name: extending-componentactivity

   If your ``Activity`` extends from Compose
   `ComponentActivity  <#ComponentActivity>`__
   instead of
   `AppCompatActivity  <#AppCompatActivity>`__,
   follow the `Support emoji without AppCompat  <#support-without-appcompat>`__
   instructions.

   Because you are not extending
   `AppCompatActivity  <#AppCompatActivity>`__,
   add the `Emoji2 library  <#emoji2>`__ to your
   dependencies and use
   `EmojiTextView  <#EmojiTextView>`__ in
   your views instead of the
   `TextView  <#TextView>`__ widget, as shown in the
   following snippet:

   .. code:: prettyprint

      class MainActivity : ComponentActivity() {

          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContentView(R.layout.activity_main)

              val emojiTextView: EmojiTextView = findViewById(R.id.emoji_text_view)
              emojiTextView.text = getString(R.string.emoji_text_view, EMOJI_TEXT)

              val composeView: ComposeView = findViewById(R.id.compose_view)

              composeView.apply {
                  setContent {
                      // compose code
                  }
              }
          }
      }EmojiSnippets.kt

   Then, in your XML file:

   .. code:: prettyprint

      <androidx.emoji2.widget.EmojiTextView
          android:id="@+id/emoji_text_view"
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          />example_view.xml

   .. rubric:: Extending from ``AppCompatActivity``
      :name: extending-appcompatactivity

   If your ``Activity`` extends from ``AppCompatActivity``, you can use
   `ComposeView  <#ComposeView>`__
   to call composable functions. Emojis render correctly across Android versions
   when you use Text composables.

   If you are extending from ``AppCompatActivity``, inflate
   `TextView  <#TextView>`__ from XML to have emojis
   rendered correctly.

   This applies if you are inflating the XML:

   -  outside ``ComposeView``, in the ``Activity``. Notice the usage of
      ``AppCompatActivity`` and ``TextView`` in the following snippet:

   .. code:: prettyprint

      class MyActivity : AppCompatActivity() {

          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContentView(R.layout.activity_main)

              val emojiTextView: TextView = findViewById(R.id.emoji_text_view)
              emojiTextView.text = getString(R.string.emoji_text_view, EMOJI_TEXT)

              val composeView: ComposeView = findViewById(R.id.compose_view)

              composeView.apply {
                  setContent {
                      // compose code
                  }
              }
          }
      }EmojiSnippets.kt

   -  inside ``ComposeView``, via `view binding  <#view-binding>`__ using
      `AndroidViewBinding  <#AndroidViewBinding>`__,
      like in the following snippet:

   .. code:: prettyprint

      class MyActivity : AppCompatActivity() {

          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)

              setContentView(
                  ComposeView(this).apply {
                      setContent {
                          Column {
                              Text(EMOJI_TEXT)

                              AndroidViewBinding(ExampleViewBinding::inflate) {
                                  emojiTextView.text = EMOJI_TEXT
                              }
                          }
                      }
                  }
              )
          }
      }EmojiSnippets.kt

   To inflate a text with
   `AndroidView  <#AndroidView>`__
   inside ``ComposeView``, use
   `AppCompatTextView  <#AppCompatTextView>`__
   to render emojis properly:

   .. code:: prettyprint

      class MyActivity : AppCompatActivity() {

          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)

              setContentView(
                  ComposeView(this).apply {
                      setContent {
                          Column {
                              Text(EMOJI_TEXT)

                              AndroidView(
                                  factory = { context -> AppCompatTextView(context) },
                                  update = { it.text = EMOJI_TEXT }
                              )
                          }
                      }
                  }
              )
          }
      }EmojiSnippets.kt

   See the `Interoperability APIs  <#interoperability-apis>`__ documentation for
   details.

   .. rubric:: Troubleshooting
      :name: troubleshooting

   If you're seeing *tofu* (☐) instead of the emoji, first check if the problem
   is your specific test device. There are few main things you can check:

   -  You might be using a `recently flashed device or a new emulator  <#appcompat-displays-tofu-new-or-flashed-device>`__.
      If possible, try another real test device you use often that is signed
      into your Google account. Remember that API should be 30 or below to
      ensure emojis work in the correct versions.
   -  The test phone `doesn't support downloadable fonts  <#appcompat-displays-tofu-no-downloadable-font-support>`__.
   -  Check the `correct Google Play services version  <#appcompat-displays-tofu-earlier-emulator-has-early-google-play-services>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Other considerations  <#other-considerations>`__
   -  `Text in Compose  <#text>`__
   -  `Scroll  <#scroll>`__

Last updated 2024-05-03 UTC.

/Overview: Images and graphics
==============================

.. https://developer.android.google.cn/develop/ui/compose/graphics?hl=en

.. container:: devsite-article-body clearfix

   Using bright, engaging visuals in your Android apps can help improve the look
   and feel of your application. In Android, there are a few different ways in
   which you can render something visually on screen- using either a vector,
   bitmap, or directly drawing with a canvas on screen. In this section, learn
   how to work these different kinds of graphics.

   Learn how to work with images using these details:

   -  `Loading images  <#loading>`__: Learn
      how to load an image from disk or the internet
   -  `ImageBitmap versus ImageVector  <#compare>`__: Learn how to
      work with the two most common image formats, raster and vector.
   -  `Material icons  <#material>`__: Learn
      about a convenient way to draw a single color icon on the screen,
      following Material Design 3 guidelines.
   -  `Customize an image  <#customize>`__:
      Learn how to customize an image using properties of an Image composable.
   -  `Custom painter  <#custompainter>`__:
      Learn about custom painter objects to additionally customize your image.
   -  `Optimizing performance  <#optimization>`__: Learn
      about how to best work with images to avoid performance issues.

   You can also learn more about working with Graphics
   `here  <#graphics-sub>`__.

Last updated 2024-05-03 UTC.

/Overview: Images
=================

.. https://developer.android.google.cn/develop/ui/compose/graphics/images?hl=en

.. container:: devsite-article-body clearfix

   Learn how to work with images using these details:

   -  `Loading images  <#loading>`__: Learn
      how to load an image from disk or the internet
   -  `ImageBitmap versus ImageVector  <#compare>`__: Learn how to
      work with the two most common image formats, raster and vector.
   -  `Material icons  <#material>`__: Learn
      about a convenient way to draw a single color icon on the screen,
      following Material Design 3 guidelines.
   -  `Customize an image  <#customize>`__:
      Learn how to customize an image using properties of an Image composable.
   -  `Custom painter  <#custompainter>`__:
      Learn about custom painter objects to additionally customize your image.
   -  `Optimizing performance  <#optimization>`__: Learn
      about how to best work with images to avoid performance issues.

Last updated 2024-05-03 UTC.

/Loading images
===============

.. https://developer.android.google.cn/develop/ui/compose/graphics/images/loading?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: Load an image from the disk
      :name: disk-loading

   Use the
   `Image  <#Image>`__
   composable to display a graphic on screen. To load an image (for example:
   PNG, JPEG, WEBP) or vector resource from the disk, use the
   `painterResource  <#painterresource>`__
   API with your image reference. You don't need to know the type of the asset,
   just use ``painterResource`` in ``Image`` or ``paint`` modifiers.

   ``DrawScope``:

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description)
      )LoadingImagesSnippets.kt

   To ensure that your app is
   `accessible  <#accessibility>`__, supply a
   ``contentDescription`` for visual elements on screen. TalkBack reads out the
   content description, so you must ensure that the text is meaningful if read
   out loud and translated. In the above example, a ``stringResource()`` is used
   to load up the translated content description from the ``strings.xml`` file.
   If your visual element on screen is purely for visual decoration, set your
   ``contentDescription`` to ``null`` for the screen reader to ignore it.

   If you need lower-level ``ImageBitmap`` specific functionality, you can use
   ``ImageBitmap.imageResource()`` to load up a Bitmap. For more information on
   ImageBitmaps, read the `ImageBitmap versus ImageVector  <#compare>`__ section.

   .. rubric:: Drawable support
      :name: drawable-support

   ``painterResource`` currently supports the following drawable types:

   -  `AnimatedVectorDrawable  <#AnimatedVectorDrawable>`__
   -  `BitmapDrawable  <#BitmapDrawable>`__
      (PNG, JPG, WEBP)
   -  `ColorDrawable  <#ColorDrawable>`__
   -  `VectorDrawable  <#VectorDrawable>`__

   .. rubric:: Load an image from the internet
      :name: internet-loading

   To load an image from the internet, there are several third-party libraries
   available to help you handle the process. Image loading libraries do a lot of
   the heavy lifting for you; they handle both caching (so you don't download
   the image multiple times) and networking logic to download the image and
   display it on screen.

   For example, to load an image with
   `Coil <https://github.com/coil-kt/coil#jetpack-compose>`__ from Instacart,
   add the library to your gradle file, and use an ``AsyncImage`` to load an
   image from a URL:

   .. code:: prettyprint

      AsyncImage(
          model = "https://example.com/image.jpg",
          contentDescription = "Translated description of what the image contains"
      )LoadingImagesSnippets.kt

   .. container:: devsite-card-group

      .. container:: devsite-card

         .. container:: devsite-card-content-wrapper

            .. container:: devsite-card-content

               ` <https://github.com/coil-kt/coil#jetpack-compose>`__
               .. rubric:: Coil
                  :name: coil

               An image loading library backed by Kotlin Coroutines (Instacart).

            .. container:: devsite-card-content-buttons

               |Maven version for Coil|

      .. container:: devsite-card

         .. container:: devsite-card-content-wrapper

            .. container:: devsite-card-content

               ` <https://bumptech.github.io/glide/int/compose.html>`__
               .. rubric:: Glide
                  :name: glide

               A fast and efficient image loading library for Android focused on
               smooth scrolling (Google).

            .. container:: devsite-card-content-buttons

               |Maven version for Glide|

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Resources in Compose  <#resources>`__
   -  `Accessibility in Compose  <#accessibility>`__
   -  `Graphics in Compose  <#overview>`__

Last updated 2024-05-03 UTC.

.. |Maven version for Coil| imagehttps://img.shields.io/maven-central/v/io.coil-kt/coil-compose
   :target: https://search.maven.org/artifact/io.coil-kt/coil-compose
.. |Maven version for Glide| imagehttps://img.shields.io/maven-central/v/com.github.bumptech.glide/compose
   :target: https://search.maven.org/artifact/com.github.bumptech.glide/compose

/ImageBitmap vs ImageVector
===========================

.. https://developer.android.google.cn/develop/ui/compose/graphics/images/compare?hl=en

.. container:: devsite-article-body clearfix

   The two most common kinds of image formats are raster and vector images.

   A raster graphic format contains pixels: tiny individual squares that contain
   a color (made up of red, green, blue, and alpha values). When placing a lot
   of pixels together, a very detailed image can be formed, such as a
   photograph. A raster graphic has a fixed resolution (fixed number of pixels).
   This means that when you increase the size of the image, it loses detail, and
   pixelation can occur. Examples of raster graphic formats are JPEG, PNG, and
   WEBP.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-sourceimage.jpg
      name: image-1
      :alt: JPEG file example
      :width: 25.0%

      **Figure 1**: JPEG file example

   Vector images, on the other hand, are scalable mathematical representations
   of a visual element on screen. A vector is a set of commands describing how
   to draw the image on screen- for instance, a line, point, or fill. When
   scaling a vector on screen, it will not lose quality as the mathematical
   formula will maintain the relationship between the different commands. A good
   example of ImageVector are the Material
   `Symbols <https://fonts.google.com/icons>`__, as they can all be defined with
   mathematical formulas.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-shopping.png
      name: image-2
      :alt: Vector example (file extensions are .xml or defined in Kotlin code)
      :width: 15.0%

      **Figure 2**: Vector example (file extensions are .xml or defined in
      Kotlin code)

   .. rubric:: ``ImageBitmap``
      :name: image-bitmap

   In Compose, a raster image (often referred to as a ``Bitmap``) can be loaded
   up into an ``ImageBitmap`` instance, and a ``BitmapPainter`` is what is
   responsible for drawing the bitmap to screen.

   For simple use cases, the ``painterResource()`` can be used which takes care
   of creating an ``ImageBitmap`` and returns a ``Painter`` object (in this case
   - a ``BitmapPainter``):

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description)
      )VectorVsBitmapSnippets.kt

   If you require further customization (for instance a `custom painter implementation  <#custompainter>`__) and
   need access to the ``ImageBitmap`` itself, you can load it in the following
   way:

   .. code:: prettyprint

      val imageBitmap = ImageBitmap.imageResource(R.drawable.dog)VectorVsBitmapSnippets.kt

   .. rubric:: ``ImageVector``
      :name: image-vector

   A ``VectorPainter`` is responsible for drawing an ``ImageVector`` to screen.
   ``ImageVector`` supports a subset of SVG commands. Not all images can be
   represented as vectors (for example, the photos you take with your camera
   cannot be transformed into a vector).

   You can create a custom ``ImageVector`` either by importing an existing
   vector drawable XML file (imported into Android Studio using the `import tool  <#running>`__) or implementing the
   class and issuing path commands manually.

   For simple use cases, the same way in which ``painterResource()`` works for
   the ``ImageBitmap`` class, it also works for ``ImageVectors``, returning a
   ``VectorPainter`` as the result. ``painterResource()`` handles the loading of
   ``VectorDrawables`` and ``BitmapDrawables`` into ``VectorPainter`` and
   ``BitmapPainter`` respectively. To load a ``VectorDrawable`` into an image,
   use:

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.baseline_shopping_cart_24),
          contentDescription = stringResource(id = R.string.shopping_cart_content_desc)
      )VectorVsBitmapSnippets.kt

   If you’d require further customization and need to access to the
   ``ImageVector`` itself, you can load it in the following way:

   .. code:: prettyprint

      val imageVector = ImageVector.vectorResource(id = R.drawable.baseline_shopping_cart_24)VectorVsBitmapSnippets.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Custom painter {:#custom-painter}  <#custompainter>`__
   -  `Resources in Compose  <#resources>`__
   -  `Loading images {:#loading-images}  <#loading>`__

Last updated 2024-05-03 UTC.

/Material icons
===============

.. https://developer.android.google.cn/develop/ui/compose/graphics/images/material?hl=en

.. container:: devsite-article-body clearfix

   The ``Icon`` composable is a convenient way to draw a single color icon on
   screen that follows `Material Design guidelines <https://material.io/design/iconography/system-icons.html#grid-and-keyline-shapes>`__.
   To use ``Icon``, include the `Compose Material  <#compose-material>`__ library (or the
   `Compose Material 3  <#compose-material3>`__
   library).

   For example, if you had a vector drawable that you wanted to load up with
   Material defaults, you can use the ``Icon`` composable as follows:

   .. code:: prettyprint

      Icon(
          painter = painterResource(R.drawable.baseline_directions_bus_24),
          contentDescription = stringResource(id = R.string.bus_content_description)
      )MaterialIconsSnippets.kt

   By default, the ``Icon`` composable is tinted with
   ``LocalContentColor.current`` and is ``24.dp`` in size. It also exposes a
   ``tint`` color parameter (which leverages the same mechanism for tinting as
   described in the `Image tint  <#tint-image>`__ section).
   The ``Icon`` composable is intended for use for small icon elements. You
   should use the ``Image`` composable for more customization options.

   The `Material Icon library  <#package-summary>`__
   also includes a set of predefined ``Icons`` that can be used in Compose
   without needing to import an SVG manually. To draw the rounded version of the
   `shopping cart icon <https://fonts.google.com/icons?icon.query=shopping+cart>`__:

   .. code:: prettyprint

      Icon(
          Icons.Rounded.ShoppingCart,
          contentDescription = stringResource(id = R.string.shopping_cart_content_desc)
      )MaterialIconsSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-shopping.png
      name: image-1
      :alt: Shopping cart vector with Icon
      :width: 10.0%

      **Figure 1**: Shopping cart vector with Icon

   It's worth noting that it's not required to use ``Icon`` to render a
   ``VectorDrawable`` on screen, under the hood, ``Icon`` uses
   ``Modifier.paint(painterResource(R.drawable.ic_bus_stop)``) to draw the
   ``Icon`` on screen. For more information on all the available icons, take a
   look at the `Icons documentation  <#package-summary>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Resources in Compose  <#resources>`__
   -  `Accessibility in Compose  <#accessibility>`__
   -  `Loading images {:#loading-images}  <#loading>`__

Last updated 2024-05-03 UTC.

/Customize an image
===================

.. https://developer.android.google.cn/develop/ui/compose/graphics/images/customize?hl=en

.. container:: devsite-article-body clearfix

   Images can be customized using properties on an ``Image`` composable
   (``contentScale``, ``colorFilter``). You can also apply the existing
   `Modifiers  <#modifiers-list>`__ to apply different
   effects to your ``Image``. Modifiers can be used on **any Composable**, not
   just the ``Image`` composable, whereas ``contentScale`` and ``colorFilter``
   are explicit parameters on the ``Image`` composable.

   .. rubric:: Content scale
      :name: content-scale

   Specify a ``contentScale`` option to crop or change how an image is scaled
   inside its bounds. By default, if you don't specify a ``contentScale``
   option, ``ContentScale.Fit`` will be used.

   In the example below, the Image composable is restricted to a 150dp size with
   a border and the background is set to yellow on the ``Image`` composable to
   showcase the different ``ContentScale`` options in the table below.

   .. code:: prettyprint

      val imageModifier = Modifier
          .size(150.dp)
          .border(BorderStroke(1.dp, Color.Black))
          .background(Color.Yellow)
      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          contentScale = ContentScale.Fit,
          modifier = imageModifier
      )CustomizeImageSnippets.kt

   Setting different ``ContentScale`` options will result in different outputs.
   Below is a table that can help in choosing the correct ``ContentScale`` mode
   you require:

   .. list-table::

      - 

         - **Source image**
         - |Portrait source image|
         - |Source image landscape|
      - 

         - ``ContentScale``
         - Result - Portrait Image:
         - Result - Landscape Image:
      - 

         - ``ContentScale.Fit``: Scale the image uniformly, keeping the aspect
            ratio (default). If content is smaller than the size, the image is
            scaled up to fit the bounds.
         - |ContentScale.Fit portrait|
         - |ContentScale.Fit landscape|
      - 

         - ``ContentScale.Crop``: Center crop the image into the available
            space.
         - |ContentScale.Crop portrait|
         - |ContentScale.Crop landscape|
      - 

         - ``ContentScale.FillHeight``: Scale the source maintaining the aspect
            ratio so that the bounds match the destination height.
         - |ContentScale.FillHeight portrait|
         - |ContentScale.FillHeight landscape|
      - 

         - ``ContentScale.FillWidth``: Scale the source maintaining the aspect
            ratio so that the bounds match the destination width.
         - |ContentScale.FillWidth portrait|
         - |ContentScale.FillWidth landscape|
      - 

         - ``ContentScale.FillBounds``: Scale the content vertically and
            horizontally **non-uniformly** to fill the destination bounds.
            (Note: This will distort images if you place them in containers that
            do not match the exact ratio of the image)
         - |ContentScale.FillBounds portrait|
         - |ContentScale.FillBounds landscape|
      - 

         - ``ContentScale.Inside``: Scale the source to maintain the aspect
            ratio inside the destination bounds. If the source is smaller than
            or equal to the destination in both dimensions, it behaves similarly
            to \`None\`. Content will always be contained within the bounds. If
            content is smaller than bounds, no scaling will apply.
         - Source image bigger than bounds: |ContentScale.Inside portrait,
            source image larger than bounds| Source image smaller than bounds:
            |ContentScale.Inside portrait, source image smaller than bounds|
         - Source image bigger than bounds: |ContentScale.Inside landscape,
            source image larger than bounds| Source image smaller than bounds:
            |ContentScale.Inside landscape, source image smaller than bounds|
      - 

         - ``ContentScale.None``: Don't apply any scaling to the source. If the
            content is smaller than destination bounds, it won't be scaled up to
            fit the area.
         - Source image bigger than bounds: |ContentScale.None portrait, source
            image larger than bounds| Source image smaller than bounds:
            |ContentScale.None portrait, source image smaller than bounds|
         - Source image bigger than bounds: |ContentScale.None landscape, source
            image larger than bounds| Source image smaller than bounds:
            |ContentScale.None landscape, source image smaller than bounds|

   .. rubric:: Clip an ``Image`` composable to a shape
      :name: clip-image-shape

   To make an image fit into a shape, use the built-in ``clip`` modifier. To
   crop an image into a circle shape, use ``Modifier.clip(CircleShape)``:

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          contentScale = ContentScale.Crop,
          modifier = Modifier
              .size(200.dp)
              .clip(CircleShape)
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-clipcircle.png
      name: image-1
      :alt: Clipping an image with CircleShape
      :figclass: screenshot
      :width: 25.0%

      **Figure 1**: Clipping an image with CircleShape

   Rounded corner shape - use ``Modifier.clip(RoundedCornerShape(16.dp)``) with
   the size of the corners you want to be rounded:

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          contentScale = ContentScale.Crop,
          modifier = Modifier
              .size(200.dp)
              .clip(RoundedCornerShape(16.dp))
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-roundedcorners.png
      name: image-2
      :alt: Clipping an image with RoundedCornerShape
      :width: 25.0%

      **Figure 2**: Clipping an image with RoundedCornerShape

   You can also create your own clipping shape by extending ``Shape``, and
   providing a ``Path`` for the shape to clip around:

   .. code:: prettyprint

      class SquashedOval : Shape {
          override fun createOutline(
              size: Size,
              layoutDirection: LayoutDirection,
              density: Density
          ): Outline {
              val path = Path().apply {
                  // We create an Oval that starts at ¼ of the width, and ends at ¾ of the width of the container.
                  addOval(
                      Rect(
                          left = size.width / 4f,
                          top = 0f,
                          right = size.width * 3 / 4f,
                          bottom = size.height
                      )
                  )
              }
              return Outline.Generic(path = path)
          }
      }

      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          contentScale = ContentScale.Crop,
          modifier = Modifier
              .size(200.dp)
              .clip(SquashedOval())
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-customcrop.png
      name: image-3
      :alt: Clipping an image with custom path shape
      :figclass: screenshot
      :width: 25.0%

      **Figure 3**: Clipping an image with custom path shape

   .. rubric:: Add a border to an ``Image`` composable
      :name: border-image

   A common operation is to combine the ``Modifier.border()`` with
   ``Modifier.clip()`` to create a border around an image:

   .. code:: prettyprint

      val borderWidth = 4.dp
      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          contentScale = ContentScale.Crop,
          modifier = Modifier
              .size(150.dp)
              .border(
                  BorderStroke(borderWidth, Color.Yellow),
                  CircleShape
              )
              .padding(borderWidth)
              .clip(CircleShape)
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-border.png
      name: image-4
      :alt: Clip an image and provide a border around it
      :figclass: screenshot
      :width: 25.0%

      **Figure 4**: Clip an image and provide a border around it

   If you wish to create a gradient border, you can use the
   `Brush  <#Brush>`__ API to
   draw a rainbow gradient border around the image:

   .. code:: prettyprint

      val rainbowColorsBrush = remember {
          Brush.sweepGradient(
              listOf(
                  Color(0xFF9575CD),
                  Color(0xFFBA68C8),
                  Color(0xFFE57373),
                  Color(0xFFFFB74D),
                  Color(0xFFFFF176),
                  Color(0xFFAED581),
                  Color(0xFF4DD0E1),
                  Color(0xFF9575CD)
              )
          )
      }
      val borderWidth = 4.dp
      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          contentScale = ContentScale.Crop,
          modifier = Modifier
              .size(150.dp)
              .border(
                  BorderStroke(borderWidth, rainbowColorsBrush),
                  CircleShape
              )
              .padding(borderWidth)
              .clip(CircleShape)
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-gradientborder.png
      name: image-5
      :alt: Rainbow gradient circle border
      :figclass: screenshot
      :width: 25.0%

      **Figure 5**: Rainbow gradient circle border

   .. rubric:: Set a custom aspect ratio
      :name: custom-aspect-ratio

   To transform an image into a custom aspect ratio, use
   ``Modifier.aspectRatio(16f/9f)`` to provide a custom ratio for an image (or
   any composable for that matter).

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          modifier = Modifier.aspectRatio(16f / 9f)
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-aspectratio.png
      name: image-6
      :alt: Using Modifier.aspectRatio(16f/9f) on Image
      :width: 25.0%

      **Figure 6**: Using ``Modifier.aspectRatio(16f/9f)`` on Image

   .. rubric:: Color filter - Transform pixel colors of image
      :name: color-filter

   The Image composable has a ``colorFilter`` parameter that can change the
   output of individual pixels of your image.

   .. rubric:: Tinting an image
      :name: tint-image

   Using ``ColorFilter.tint(color, blendMode)`` will apply a blend mode with the
   given color onto your ``Image`` composable.
   ``ColorFilter.tint(color, blendMode)`` uses ``BlendMode.SrcIn`` to tint
   content, meaning that the color supplied will be shown, where the image is
   displayed on screen. This is useful for icons and vectors that need to be
   themed differently.

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.baseline_directions_bus_24),
          contentDescription = stringResource(id = R.string.bus_content_description),
          colorFilter = ColorFilter.tint(Color.Yellow)
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-bus.png
      name: image-7
      :alt: ColorFilter.tint applied with BlendMode.SrcIn
      :figclass: screenshot
      :width: 25.0%

      **Figure 7**: ColorFilter.tint applied with BlendMode.SrcIn

   Other ``BlendMode``\ ’s result in different effects. For example, setting
   ``BlendMode.Darken`` with a ``Color.Green`` on an image produces the
   following result:

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          colorFilter = ColorFilter.tint(Color.Green, blendMode = BlendMode.Darken)
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-blendmode.png
      name: image-8
      :alt: Color.Green tint with BlendMode.Darken
      :width: 25.0%

      **Figure 8**: Color.Green tint with BlendMode.Darken

   See `BlendMode reference documentation  <#BlendMode>`__
   for more information on the different blend modes available.

   .. rubric:: Applying an ``Image`` filter with color matrix
      :name: color-matrix

   Transform your image using the color matrix ``ColorFilter`` option. For
   example, to apply a black and white filter onto your images you could use the
   `ColorMatrix  <#ColorMatrix>`__
   and set the saturation to ``0f``.

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          colorFilter = ColorFilter.colorMatrix(ColorMatrix().apply { setToSaturation(0f) })
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-bw.png
      name: image-9
      :alt: Color Matrix with saturation 0 (black and white image)
      :width: 25.0%

      **Figure 9**: Color Matrix with saturation 0 (black and white image)

   .. rubric:: Adjust contrast or brightness of an ``Image`` composable
      :name: adjust_contrast_or_brightness_of_an_image_composable

   To change the contrast and brightness of an image, you can use the
   `ColorMatrix  <#ColorMatrix>`__
   to change the values:

   .. code:: prettyprint

      val contrast = 2f // 0f..10f (1 should be default)
      val brightness = -180f // -255f..255f (0 should be default)
      val colorMatrix = floatArrayOf(
          contrast, 0f, 0f, 0f, brightness,
          0f, contrast, 0f, 0f, brightness,
          0f, 0f, contrast, 0f, brightness,
          0f, 0f, 0f, 1f, 0f
      )
      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          colorFilter = ColorFilter.colorMatrix(ColorMatrix(colorMatrix))
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-colormatrix.png
      name: image-10
      :alt: Adjusted image brightness and contrast using ColorMatrix
      :width: 25.0%

      **Figure 10**: Adjusted image brightness and contrast using ColorMatrix

   .. rubric:: Invert colors of an ``Image`` composable
      :name: invert_colors_of_an_image_composable

   To invert the colors of an image, set the
   `ColorMatrix  <#ColorMatrix>`__
   to invert the colors:

   .. code:: prettyprint

      val colorMatrix = floatArrayOf(
          -1f, 0f, 0f, 0f, 255f,
          0f, -1f, 0f, 0f, 255f,
          0f, 0f, -1f, 0f, 255f,
          0f, 0f, 0f, 1f, 0f
      )
      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          colorFilter = ColorFilter.colorMatrix(ColorMatrix(colorMatrix))
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-inverted.png
      name: image-11
      :alt: Inverted colors on image
      :width: 25.0%

      **Figure 11**: Inverted colors on image

   .. rubric:: Blur an ``Image`` composable
      :name: blur_an_image_composable

   To blur an image, use ``Modifier.blur()``, supplying the ``radiusX`` and
   ``radiusY``, which specifies the blur radius in the horizontal and vertical
   direction respectively.

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          contentScale = ContentScale.Crop,
          modifier = Modifier
              .size(150.dp)
              .blur(
                  radiusX = 10.dp,
                  radiusY = 10.dp,
                  edgeTreatment = BlurredEdgeTreatment(RoundedCornerShape(8.dp))
              )
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-blur.png
      name: image-12
      :alt: BlurEffect applied to image
      :width: 25.0%

      **Figure 12**: BlurEffect applied to image

   When blurring ``Images``, it is recommended to use
   ``BlurredEdgeTreatment(Shape)``, instead of
   ``BlurredEdgeTreatment.Unbounded``, as the latter is used for blurring of
   arbitrary renderings that are expected to render outside the bounds of the
   original content. For images, it is likely that they won’t render outside the
   bounds of the content; whereas blurring a rounded rectangle may require this
   distinction.

   For example, if we set the ``BlurredEdgeTreatment`` to Unbounded on the above
   image, the edges of the image appear blurred instead of sharp:

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.dog),
          contentDescription = stringResource(id = R.string.dog_content_description),
          contentScale = ContentScale.Crop,
          modifier = Modifier
              .size(150.dp)
              .blur(
                  radiusX = 10.dp,
                  radiusY = 10.dp,
                  edgeTreatment = BlurredEdgeTreatment.Unbounded
              )
              .clip(RoundedCornerShape(8.dp))
      )CustomizeImageSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-unbounded.png
      name: image-13
      :alt: BlurEdgeTreatment.Unbounded
      :width: 25.0%

      **Figure 13**: BlurEdgeTreatment.Unbounded

   **Note:**\  The blur effect is only supported on Android 12 and above.
   Attempts to use this Modifier on older Android versions are ignored.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Graphics Modifiers  <#modifiers>`__
   -  `Loading images {:#loading-images}  <#loading>`__
   -  `Material icons {:#material-icons}  <#material>`__

Last updated 2024-05-03 UTC.

.. |Portrait source image| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-sourceimagesmall.jpg
.. |Source image landscape| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-sourceimageland.jpg
.. |ContentScale.Fit portrait| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-CSF-Portrait.png
.. |ContentScale.Fit landscape| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-CSF-Land.png
.. |ContentScale.Crop portrait| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-CSC-Portrait.png
.. |ContentScale.Crop landscape| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-CSC-Land.png
.. |ContentScale.FillHeight portrait| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-CSFH-Portrait.png
.. |ContentScale.FillHeight landscape| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-CSFH-Land.png
.. |ContentScale.FillWidth portrait| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-CSFW-Portrait.png
.. |ContentScale.FillWidth landscape| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-CSFW-Land.png
.. |ContentScale.FillBounds portrait| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-CSFB-Portrait.png
.. |ContentScale.FillBounds landscape| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-CSFB-Land.png
.. |ContentScale.Inside portrait, source image larger than bounds| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-biggerbounds-Portrait.png
.. |ContentScale.Inside portrait, source image smaller than bounds| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-smallerbounds-Portrait.png
.. |ContentScale.Inside landscape, source image larger than bounds| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-biggerbounds-Land.png
.. |ContentScale.Inside landscape, source image smaller than bounds| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-smallerbounds-Land.png
.. |ContentScale.None portrait, source image larger than bounds| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-none-Portrait.png
.. |ContentScale.None portrait, source image smaller than bounds| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-smallerbounds-Portrait.png
.. |ContentScale.None landscape, source image larger than bounds| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-none-Land.png
.. |ContentScale.None landscape, source image smaller than bounds| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-smallerbounds-Land.png

/Custom painter
===============

.. https://developer.android.google.cn/develop/ui/compose/graphics/images/custompainter?hl=en

.. container:: devsite-article-body clearfix

   In Compose, a ``Painter`` object is used to represent something that can be
   drawn (a replacement to the ``Drawable`` APIs defined in Android) and
   influence measurement and layout of the corresponding composable that is
   using it . A ``BitmapPainter`` takes an ``ImageBitmap`` that can draw a
   ``Bitmap`` on screen.

   For most use cases, using the ``painterResource()`` above returns the correct
   painter for the asset (i.e. ``BitmapPainter`` or ``VectorPainter``). For more
   information on the differences between the two - read the `ImageBitmap vs ImageVector  <#compare>`__ section.

   A ``Painter`` is different from a ``DrawModifier``, which strictly draws
   within the bounds that are given to it and has no influence on the
   measurement or layout of the composable.

   To create a custom painter, extend the ``Painter`` class, and implement the
   ``onDraw`` method, which allows access to the ``DrawScope`` to draw custom
   graphics. You can also override the ``intrinsicSize``, which will be used to
   influence the Composable that it is contained in:

   .. code:: prettyprint

      class OverlayImagePainter constructor(
          private val image: ImageBitmap,
          private val imageOverlay: ImageBitmap,
          private val srcOffset: IntOffset = IntOffset.Zero,
          private val srcSize: IntSize = IntSize(image.width, image.height),
          private val overlaySize: IntSize = IntSize(imageOverlay.width, imageOverlay.height)
      ) : Painter() {

          private val size: IntSize = validateSize(srcOffset, srcSize)
          override fun DrawScope.onDraw() {
              // draw the first image without any blend mode
              drawImage(
                  image,
                  srcOffset,
                  srcSize,
                  dstSize = IntSize(
                      this@onDraw.size.width.roundToInt(),
                      this@onDraw.size.height.roundToInt()
                  )
              )
              // draw the second image with an Overlay blend mode to blend the two together
              drawImage(
                  imageOverlay,
                  srcOffset,
                  overlaySize,
                  dstSize = IntSize(
                      this@onDraw.size.width.roundToInt(),
                      this@onDraw.size.height.roundToInt()
                  ),
                  blendMode = BlendMode.Overlay
              )
          }

          /**
           * Return the dimension of the underlying [ImageBitmap] as it's intrinsic width and height
           */
          override val intrinsicSize: Size get() = size.toSize()

          private fun validateSize(srcOffset: IntOffset, srcSize: IntSize): IntSize {
              require(
                  srcOffset.x >= 0 &&
                      srcOffset.y >= 0 &&
                      srcSize.width >= 0 &&
                      srcSize.height >= 0 &&
                      srcSize.width <= image.width &&
                      srcSize.height <= image.height
              )
              return srcSize
          }
      }CustomPainterSnippets.kt

   Now that we have our custom ``Painter``, we can overlay any image on top of
   our source image as follows:

   .. code:: prettyprint

      val rainbowImage = ImageBitmap.imageResource(id = R.drawable.rainbow)
      val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)
      val customPainter = remember {
          OverlayImagePainter(dogImage, rainbowImage)
      }
      Image(
          painter = customPainter,
          contentDescription = stringResource(id = R.string.dog_content_description),
          contentScale = ContentScale.Crop,
          modifier = Modifier.wrapContentSize()
      )CustomPainterSnippets.kt

   The output of combining the two images with a custom painter can be seen
   below:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics-rainbowoverlay.jpg
      name: image-1
      :alt: Custom Painter that overlays two images on top of each other
      :figclass: screenshot
      :width: 25.0%

      **Figure 1**: Custom Painter that overlays two images on top of each other

   A custom painter can also be used with the
   `Modifier.paint(customPainter)  <#paint>`__
   to draw the content to a composable as follows:

   .. code:: prettyprint

      val rainbowImage = ImageBitmap.imageResource(id = R.drawable.rainbow)
      val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)
      val customPainter = remember {
          OverlayImagePainter(dogImage, rainbowImage)
      }
      Box(
          modifier =
          Modifier.background(color = Color.Gray)
              .padding(30.dp)
              .background(color = Color.Yellow)
              .paint(customPainter)
      ) { /** intentionally empty **/ }CustomPainterSnippets.kt

   **Note:**\  The above custom Painter can also be implemented using a
   ``DrawModifier``. If you need to influence measurement or layout, then you
   should use a ``Painter``. If you are only expecting to render in the bounds
   you are given, then you should use a ``DrawModifier`` instead.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `ImageBitmap vs ImageVector {:#bitmap-vs-vector}  <#compare>`__
   -  `Graphics in Compose  <#overview>`__
   -  `Loading images {:#loading-images}  <#loading>`__

Last updated 2024-05-03 UTC.

/Optimizing performance
=======================

.. https://developer.android.google.cn/develop/ui/compose/graphics/images/optimization?hl=en

.. container:: devsite-article-body clearfix

   Working with images can quickly introduce performance issues if you aren't
   careful. You can quite easily run into an ``OutOfMemoryError`` when working
   with large bitmaps. Follow these best practices to ensure your app performs
   at its best.

   .. rubric:: Only load the size of the bitmap you need
      :name: bitmap-size

   Most smartphones have high resolution cameras that produce large image files.
   If you're showing an image on screen, you must either reduce the resolution
   of the image or only load the image up to the size of your image container.
   The constant loading of larger than needed images can exhaust GPU caches,
   leading to less performant UI rendering.

   To manage image sizes:

   -  Scale down your image files to be as small as possible (without affecting
      output image).
   -  Consider `converting your images to WEBP  <#convert-webp>`__
      format instead of JPEG or PNGs.
   -  Supply smaller images for different screen resolutions (see `Tip #3  <#screen-sizes>`__),
   -  Use an `image loading library  <#load_an_image_from_the_internet>`__,
      which scales down your image to fit the size of your view on screen. This
      can help improve the loading performance of your screen.

   **Caution:**\  Using ``painterResource`` will **not** scale your image to the
   size of the Composable that is visible on screen. If you have a large image
   in a small Composable, be sure to use an image loading library which scales
   the image down for you to fit the bounds.

   .. rubric:: Use vectors over bitmaps where possible
      :name: vectors-bitmap

   When representing something visually on screen, you need to decide if it can
   be represented as a vector or not. Prefer vector images over bitmaps, as they
   don’t pixelate when you scale them to different sizes. However, not
   everything can be represented as a vector - images taken with a camera can’t
   be converted into a vector.

   .. rubric:: Supply alternative resources for different screen sizes
      :name: screen-sizes

   If you are shipping images with your app, consider supplying different sized
   assets for different device resolutions. This can help reduce the download
   size of your app on devices, and improve performance as it’ll load up a lower
   resolution image on a lower resolution device. For more information on
   providing alternative bitmaps for different device sizes, `check out the alternative bitmap documentation  <#TaskProvideAltBmp>`__.

   .. rubric:: When using ``ImageBitmap``, call ``prepareToDraw`` before drawing
      :name: preparetodraw

   When using ``ImageBitmap``, to start the process of uploading the texture to
   the GPU, call
   `ImageBitmap#prepareToDraw()  <#prepareToDraw>`__
   before actually drawing it. This helps the GPU prepare the texture and
   improve the performance of showing a visual on screen. Most image loading
   libraries already do this optimization, but if you are working with the
   ``ImageBitmap`` class yourself, it is something to keep in mind.

   .. rubric:: Prefer passing a ``Int`` ``DrawableRes`` or URL as parameters
      into your composable instead of ``Painter``
      :name: pass-url

   Due to the complexities of dealing with images (for example, writing an
   equals function for ``Bitmaps`` would be computationally expensive), the
   ``Painter`` API is explicitly not marked as a
   `Stable <https://medium.com/androiddevelopers/jetpack-compose-stability-explained-79c10db270c8>`__
   class. Unstable classes can lead to unnecessary recompositions because the
   compiler cannot easily infer if the data has changed.

   Therefore, it is preferable to pass a URL or drawable resource ID as
   parameters to your composable, instead of passing a ``Painter`` as a
   parameter.

   .. code:: prettyprint

      // Prefer this:
      @Composable
      fun MyImage(url: String) {

      }
      // Over this:
      @Composable
      fun MyImage(painter: Painter) {

      }

   .. rubric:: Don’t store a bitmap in memory longer than you need it
      :name: bitmap-storage

   The more bitmaps you load into memory, the more likely it is that you could
   run out of memory on the device. For instance, if loading a large list of
   Image composables on screen, use ``LazyColumn`` or ``LazyRow`` to ensure that
   memory is freed up when scrolling a large list.

   .. rubric:: Don’t package large images with your AAB/APK file
      :name: image-packaging

   One of the top causes for large app download size is due to graphics that are
   packaged inside the AAB or APK file. Use the `APK analyzer  <#apk-analyzer>`__ tool to ensure that you aren't
   packaging larger than required image files. Reduce the sizes or consider
   placing the images on a server and only downloading them when required.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `ImageBitmap vs ImageVector {:#bitmap-vs-vector}  <#compare>`__
   -  `Save UI state in Compose  <#state-saving>`__
   -  `Jetpack Compose Phases  <#phases>`__

Last updated 2024-05-03 UTC.

/Overview: Graphics
===================

.. https://developer.android.google.cn/develop/ui/compose/graphics/draw/overview?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   Many apps need to be able to precisely control exactly what's drawn on the
   screen. This might be as small as putting a box or a circle on the screen in
   just the right place, or it might be an elaborate arrangement of graphic
   elements in many different styles.

   .. rubric:: Basic drawing with modifiers and ``DrawScope``
      :name: basic-drawing

   The core way to draw something custom in Compose is with modifiers, such as
   `Modifier.drawWithContent  <#drawWithContent>`__,
   `Modifier.drawBehind  <#drawBehind>`__,
   and
   `Modifier.drawWithCache  <#drawWithCache>`__.

   For example, to draw something behind your composable, you can use the
   ``drawBehind`` modifier to start executing drawing commands:

   .. code:: prettyprint

      Spacer(
          modifier = Modifier
              .fillMaxSize()
              .drawBehind {
                  // this = DrawScope
              }
      )CanvasSnippets.kt

   If all you need is a composable that draws, you can use the
   `Canvas  <#Canvas>`__
   composable. The ``Canvas`` composable is a convenient wrapper around
   `Modifier.drawBehind  <#drawbehind>`__.
   You place the ``Canvas`` in your layout the same way you would with any other
   Compose UI element. Within the ``Canvas``, you can draw elements with precise
   control over their style and location.

   **Note:**\  Under the hood, Compose relies on the view-based UI's `Canvas and other associated objects  <#drawables>`__. However,
   Compose simplifies many of the more confusing aspects of ``Canvas``. For
   example, most of the view-based graphics elements rely on a ``Paint`` helper
   object. You need to know which configuration options you set in the
   ``Paint``, and which you set in the method call. You also need to be careful
   to create your ``Paint`` objects in a way that won't harm performance.
   Compose takes care of those details for you.
   All drawing modifiers expose a
   `DrawScope  <#DrawScope>`__,
   a scoped drawing environment that maintains its own state. This lets you set
   the parameters for a group of graphical elements. The ``DrawScope`` provides
   several useful fields, like ``size``, a ``Size`` object specifying the
   current dimensions of the ``DrawScope``.

   To draw something, you can use one of the many draw functions on
   ``DrawScope``. For example, the following code draws a rectangle in the top
   left corner of the screen:

   .. code:: prettyprint

      Canvas(modifier = Modifier.fillMaxSize()) {
          val canvasQuadrantSize = size / 2F
          drawRect(
              color = Color.Magenta,
              size = canvasQuadrantSize
          )
      }CanvasSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_draw_rect.png
      name: image-1
      :alt: Pink rectangle drawn on a white background that takes up a quarter
      of the screen
      :width: 300px

      **Figure 1**. Rectangle drawn using Canvas in Compose.

   To learn more about different drawing modifiers, see the `Graphics Modifiers  <#modifiers>`__ documentation.

   .. rubric:: Coordinate system
      :name: coordinate-system

   To draw something on screen, you need to know the offset (``x`` and ``y``)
   and size of your item. With many of the draw methods on ``DrawScope``, the
   position and size are provided by `default parameter values  <#default-args>`__. The default parameters
   generally position the item at the ``[0, 0]`` point on the canvas, and
   provide a default ``size`` that fills the entire drawing area, as in the
   example above - you can see the rectangle is positioned in the top left. To
   adjust the size and position of your item, you need to understand the
   coordinate system in Compose.

   The origin of the coordinate system (``[0,0]``) is at the top leftmost pixel
   in the drawing area. ``x`` increases as it moves right and ``y`` increases as
   it moves downwards.

   **Note:**\  All drawing operations are performed using pixel sizing. To
   ensure consistent sizing of your items across different device densities and
   screen sizes, be sure to either convert from ``dp`` using
   `.toPx()  <#toPx>`__
   or work in fractions of the size.
   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_coordinate_system_drawing.png
      name: image-2
      :alt: A grid showing the coordinate system showing the top left [0, 0] and
      bottom right [width, height]
      :width: 300px

      **Figure 2**. Drawing coordinate system / drawing grid.

   For example, if you want to draw a diagonal line from the top-right corner of
   the canvas area to the bottom-left corner, you can use the
   `DrawScope.drawLine()  <#drawLine>`__
   function, and specify a start and end offset with the corresponding x and y
   positions:

   .. code:: prettyprint

      Canvas(modifier = Modifier.fillMaxSize()) {
          val canvasWidth = size.width
          val canvasHeight = size.height
          drawLine(
              start = Offset(x = canvasWidth, y = 0f),
              end = Offset(x = 0f, y = canvasHeight),
              color = Color.Blue
          )
      }CanvasSnippets.kt

   .. rubric:: Basic transformations
      :name: basic-transformations

   ``DrawScope`` offers transformations to change where or how the drawing
   commands are executed.

   **Note:**\  These transformations only apply in the `draw phase of the Composable lifecycle  <#phase3-drawing>`__ - any
   changes to size or position won't change the layout size and position.
   Elements may draw over other elements if they are moved out of their layout
   size and position.

   .. rubric:: Scale
      :name: scale

   Use
   `DrawScope.scale()  <#scale>`__
   to increase the size of your drawing operations by a factor. Operations like
   ``scale()`` apply to all drawing operations within the corresponding lambda.
   For example, the following code increases the ``scaleX`` 10 times and
   ``scaleY`` 15 times:

   .. code:: prettyprint

      Canvas(modifier = Modifier.fillMaxSize()) {
          scale(scaleX = 10f, scaleY = 15f) {
              drawCircle(Color.Blue, radius = 20.dp.toPx())
          }
      }CanvasSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_scale.png
      name: image-3
      :alt: A circle scaled non-uniformly
      :width: 300px

      **Figure 3**. Applying a scale operation to a circle on Canvas.

   .. rubric:: Translate
      :name: translate

   Use
   `DrawScope.translate()  <#translate>`__
   to move your drawing operations up, down, left, or right. For example, the
   following code moves the drawing 100 px to the right and 300 px up:

   .. code:: prettyprint

      Canvas(modifier = Modifier.fillMaxSize()) {
          translate(left = 100f, top = -300f) {
              drawCircle(Color.Blue, radius = 200.dp.toPx())
          }
      }CanvasSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_translate.png
      name: image-4
      :alt: A circle that has moved off center
      :width: 300px

      **Figure 4**. Applying a translate operation to a circle on Canvas.

   .. rubric:: Rotate
      :name: rotate

   Use
   `DrawScope.rotate()  <#rotate>`__
   to rotate your drawing operations around a pivot point. For example, the
   following code rotates a rectangle 45 degrees:

   .. code:: prettyprint

      Canvas(modifier = Modifier.fillMaxSize()) {
          rotate(degrees = 45F) {
              drawRect(
                  color = Color.Gray,
                  topLeft = Offset(x = size.width / 3F, y = size.height / 3F),
                  size = size / 3F
              )
          }
      }CanvasSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_rotate.png
      name: image-5
      :alt: A phone with a rectangle rotated by 45 degrees in the center of the
      screen
      :width: 300px

      **Figure 5**. We use ``rotate()`` to apply a rotation to the current
      drawing scope, which rotates the rectangle by 45 degrees.

   .. rubric:: Inset
      :name: inset

   Use
   `DrawScope.inset()  <#inset>`__
   to adjust the default parameters of the current ``DrawScope``, changing the
   drawing boundaries and translating the drawings accordingly:

   .. code:: prettyprint

      Canvas(modifier = Modifier.fillMaxSize()) {
          val canvasQuadrantSize = size / 2F
          inset(horizontal = 50f, vertical = 30f) {
              drawRect(color = Color.Green, size = canvasQuadrantSize)
          }
      }CanvasSnippets.kt

   This code effectively adds padding to the drawing commands:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_inset.png
      name: image-6
      :alt: A rectangle that has been padded all around it
      :width: 300px

      **Figure 6**. Applying an inset to drawing commands.

   .. rubric:: Multiple transformations
      :name: multiple-transformations

   To apply multiple transformations to your drawings, use the
   `DrawScope.withTransform()  <#withTransform>`__
   function, which creates and applies a single transformation that combines all
   your desired changes. Using ``withTransform()`` is more efficient than making
   nested calls to individual transformations, because all the transformations
   are performed together in a single operation, instead of Compose needing to
   calculate and save each of the nested transformations.

   For example, the following code applies both a translation and a rotation to
   the rectangle:

   .. code:: prettyprint

      Canvas(modifier = Modifier.fillMaxSize()) {
          withTransform({
              translate(left = size.width / 5F)
              rotate(degrees = 45F)
          }) {
              drawRect(
                  color = Color.Gray,
                  topLeft = Offset(x = size.width / 3F, y = size.height / 3F),
                  size = size / 3F
              )
          }
      }CanvasSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_multiple_transforms.png
      name: image-7
      :alt: A phone with a rotated rectangle shifted to the side of the screen
      :width: 300px

      **Figure 7**. Use ``withTransform`` to apply both a rotation and a
      translation, rotating the rectangle and shifting it to the left.

   .. rubric:: Common drawing operations
      :name: common-drawing

   .. rubric:: Draw text
      :name: draw-text

   To draw text in Compose, you can typically use the ``Text`` composable.
   However, if you are in a ``DrawScope`` or you want to draw your text manually
   with customization, you can use the
   `DrawScope.drawText()  <#drawText>`__
   method.

   To draw text, create a
   `TextMeasurer  <#TextMeasurer>`__
   using
   `rememberTextMeasurer  <#rememberTextMeasurer>`__
   and call ``drawText`` with the measurer:

   .. code:: prettyprint

      val textMeasurer = rememberTextMeasurer()

      Canvas(modifier = Modifier.fillMaxSize()) {
          drawText(textMeasurer, "Hello")
      }CanvasSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_draw_text.png
      name: image-8
      :alt: Showing a Hello drawn on Canvas
      :width: 300px

      **Figure 8**. Drawing text on Canvas.

   .. rubric:: Measure text
      :name: measure-text

   Drawing text works a bit differently from other drawing commands. Normally,
   you give the drawing command the size (width and height) to draw the
   shape/image as. With text, there are a few parameters that control the size
   of the rendered text, such as font size, font, ligatures, and letter spacing.

   With Compose, you can use a
   `TextMeasurer  <#TextMeasurer>`__
   to get access to the measured size of text, depending on the above factors.
   If you want to draw a background behind the text, you can use the measured
   information to get the size of the area that the text takes up:

   .. code:: prettyprint

      val textMeasurer = rememberTextMeasurer()

      Spacer(
          modifier = Modifier
              .drawWithCache {
                  val measuredText =
                      textMeasurer.measure(
                          AnnotatedString(longTextSample),
                          constraints = Constraints.fixedWidth((size.width * 2f / 3f).toInt()),
                          style = TextStyle(fontSize = 18.sp)
                      )

                  onDrawBehind {
                      drawRect(pinkColor, size = measuredText.size.toSize())
                      drawText(measuredText)
                  }
              }
              .fillMaxSize()
      )CanvasSnippets.kt

   **Note:**\  The above example uses ``Modifier.drawWithCache``, since drawing
   text is an expensive operation. Using ``drawWithCache`` helps cache the
   created objects until the size of the drawing area changes. For more
   information, see the `Modifier.drawWithCache documentation  <#drawwithcache>`__.
   This code snippet produces a pink background on the text:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_draw_text_measured.png
      name: image-9
      :alt: Multi-line text taking up ⅔ size of the full area, with a background
      rectangle
      :width: 300px

      **Figure 9**. Multi-line text taking up ⅔ size of the full area, with a
      background rectangle.

   Adjusting the constraints, font size, or any property that affects measured
   size results in a new size reported. You can set a fixed size for both the
   ``width`` and ``height``, and the text then follows the set
   `TextOverflow  <#TextOverflow>`__.
   For example, the following code renders text in ⅓ of the height and ⅓ of the
   width of the composable area, and sets the ``TextOverflow`` to
   ``TextOverflow.Ellipsis``:

   .. code:: prettyprint

      val textMeasurer = rememberTextMeasurer()

      Spacer(
          modifier = Modifier
              .drawWithCache {
                  val measuredText =
                      textMeasurer.measure(
                          AnnotatedString(longTextSample),
                          constraints = Constraints.fixed(
                              width = (size.width / 3f).toInt(),
                              height = (size.height / 3f).toInt()
                          ),
                          overflow = TextOverflow.Ellipsis,
                          style = TextStyle(fontSize = 18.sp)
                      )

                  onDrawBehind {
                      drawRect(pinkColor, size = measuredText.size.toSize())
                      drawText(measuredText)
                  }
              }
              .fillMaxSize()
      )CanvasSnippets.kt

   The text is now drawn in the constraints with an ellipsis at the end:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_draw_text_ellipsis.png
      name: image-10
      :alt: Text drawn on pink background, with ellipsis cutting off the text.
      :width: 300px

      **Figure 10**. ``TextOverflow.Ellipsis`` with fixed constraints on
      measuring text.

   **Note:**\  For more information on text, see the
   `Text  <#text>`__ documentation.

   .. rubric:: Draw image
      :name: draw-image

   To draw an
   `ImageBitmap  <#ImageBitmap>`__
   with ``DrawScope``, load up the image using ``ImageBitmap.imageResource()``
   and then call ``drawImage``:

   .. code:: prettyprint

      val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)

      Canvas(modifier = Modifier.fillMaxSize(), onDraw = {
          drawImage(dogImage)
      })CanvasSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_image.png
      name: image-11
      :alt: An image of a dog drawn on Canvas
      :width: 300px

      **Figure 11**. Drawing an ``ImageBitmap`` on Canvas.

   **Note:**\  See the `Image customization documentation  <#customize>`__ for more
   information on how to apply filters to your images.

   .. rubric:: Draw basic shapes
      :name: draw-basic-shapes

   There are many shape drawing functions on ``DrawScope``. To draw a shape, use
   one of the predefined draw functions, such as ``drawCircle``:

   .. code:: prettyprint

      val purpleColor = Color(0xFFBA68C8)
      Canvas(
          modifier = Modifier
              .fillMaxSize()
              .padding(16.dp),
          onDraw = {
              drawCircle(purpleColor)
          }
      )CanvasSnippets.kt

   .. list-table::

      - 

         - API
         - Output
      - 

         - `drawCircle()  <#drawCircle>`__
         - |draw circle|
      - 

         - `drawRect()  <#drawRect>`__
         - |draw rect|
      - 

         - `drawRoundedRect()  <#drawRoundRect>`__
         - |draw rounded rect|
      - 

         - `drawLine()  <#drawLine>`__
         - |draw line|
      - 

         - `drawOval()  <#drawOval>`__
         - |draw oval|
      - 

         - `drawArc()  <#drawArc>`__
         - |draw arc|
      - 

         - `drawPoints()  <#drawPoints>`__
         - |draw points|

   .. rubric:: Draw path
      :name: draw-path

   A path is a series of mathematical instructions that result in a drawing once
   executed. ``DrawScope`` can draw a path using the ``DrawScope.drawPath()``
   method.

   For example, say you wanted to draw a triangle. You can generate a path with
   functions such as ``lineTo()`` and ``moveTo()`` using the size of the drawing
   area. Then, call ``drawPath()`` with this newly created path to get a
   triangle.

   .. code:: prettyprint

      Spacer(
          modifier = Modifier
              .drawWithCache {
                  val path = Path()
                  path.moveTo(0f, 0f)
                  path.lineTo(size.width / 2f, size.height / 2f)
                  path.lineTo(size.width, 0f)
                  path.close()
                  onDrawBehind {
                      drawPath(path, Color.Magenta, style = Stroke(width = 10f))
                  }
              }
              .fillMaxSize()
      )CanvasSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_draw_path.png
      name: image-12
      :alt: An upside-down purple path triangle drawn on Compose
      :width: 300px

      **Figure 12**. Creating and drawing a ``Path`` in Compose.

   .. rubric:: Accessing ``Canvas`` object
      :name: accessing-canvas

   With ``DrawScope``, you don't have direct access to a ``Canvas`` object. You
   can use
   `DrawScope.drawIntoCanvas()  <#drawIntoCanvas>`__
   to get access to the ``Canvas`` object itself that you can call functions on.

   For example, if you have a custom ``Drawable`` that you'd like to draw onto
   the canvas, you can access the canvas and call ``Drawable#draw()``, passing
   in the ``Canvas`` object:

   .. code:: prettyprint

      val drawable = ShapeDrawable(OvalShape())
      Spacer(
          modifier = Modifier
              .drawWithContent {
                  drawIntoCanvas { canvas ->
                      drawable.setBounds(0, 0, size.width.toInt(), size.height.toInt())
                      drawable.draw(canvas.nativeCanvas)
                  }
              }
              .fillMaxSize()
      )CanvasSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_draw_into_canvas.png
      name: image-13
      :alt: An oval black ShapeDrawable taking up full size
      :width: 300px

      **Figure 13**. Accessing canvas to draw a ``Drawable``.

   .. rubric:: Learn more
      :name: learn-more

   For more information on Drawing in Compose, take a look at the following
   resources:

   -  `Graphics Modifiers  <#modifiers>`__ -
      Learn about the different types of drawing modifiers.
   -  `Brush  <#brush>`__ - Learn how to
      customize the painting of your content.
   -  `Custom Layouts and Graphics in Compose - Android Dev Summit 2022 <https://www.youtube.com/watch?v=xcfEQO0k_gU&ab_channel=AndroidDevelopers>`__
      - Learn how to build a custom UI in Compose with Layouts and Graphics.
   -  `JetLagged Sample <https://github.com/android/compose-samples/tree/main/JetLagged>`__
      - Compose Sample that shows how to draw a custom graph.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Graphics Modifiers  <#modifiers>`__
   -  `Graphics in Compose  <#graphics>`__
   -  `Alignment lines in Jetpack Compose  <#alignment-lines>`__

Last updated 2024-05-03 UTC.

.. |draw circle| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_draw_circle.png
   :width: 150px
.. |draw rect| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_draw_rect.png
   :width: 150px
.. |draw rounded rect| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_draw_rounded_rect.png
   :width: 150px
.. |draw line| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_draw_line.png
   :width: 150px
.. |draw oval| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_draw_oval.png
   :width: 150px
.. |draw arc| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_draw_arc.png
   :width: 150px
.. |draw points| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_draw_points.png
   :width: 150px

/Graphics Modifiers
===================

.. https://developer.android.google.cn/develop/ui/compose/graphics/draw/modifiers?hl=en

.. container:: devsite-article-body clearfix

   In addition to the ``Canvas`` composable, Compose has several useful graphics
   ``Modifiers`` which aid in drawing custom content. These modifiers are useful
   because they can be applied to any composable.

   .. rubric:: Drawing modifiers
      :name: drawing-modifiers

   All drawing commands are done with a drawing modifier in Compose. There are
   three main drawing modifiers in Compose:

   -  `drawWithContent  <#drawWithContent>`__
   -  `drawBehind  <#drawBehind>`__
   -  `drawWithCache  <#drawWithCache>`__

   The base modifier for drawing is ``drawWithContent``, where you can decide
   the drawing order of your Composable and the drawing commands issued inside
   the modifier. ``drawBehind`` is a convenient wrapper around
   ``drawWithContent`` which has the drawing order set to behind the content of
   the composable. ``drawWithCache`` calls either ``onDrawBehind`` or
   ``onDrawWithContent`` inside of it - and provides a mechanism for caching the
   objects created in them.

   .. rubric:: ``Modifier.drawWithContent``: Choose drawing order
      :name: drawwithcontent

   `Modifier.drawWithContent  <#drawWithContent>`__
   lets you execute
   `DrawScope  <#DrawScope>`__
   operations before or after the content of the composable. Be sure to call
   ``drawContent`` to then render the actual content of the composable. With
   this modifier, you can decide the order of operations, if you want your
   content to be drawn before or after your custom drawing operations.

   For example, if you wished to render a radial gradient on top of your content
   to create a flashlight keyhole effect on the UI, you could do the following:

   .. code:: prettyprint

      var pointerOffset by remember {
          mutableStateOf(Offset(0f, 0f))
      }
      Column(
          modifier = Modifier
              .fillMaxSize()
              .pointerInput("dragging") {
                  detectDragGestures { change, dragAmount ->
                      pointerOffset += dragAmount
                  }
              }
              .onSizeChanged {
                  pointerOffset = Offset(it.width / 2f, it.height / 2f)
              }
              .drawWithContent {
                  drawContent()
                  // draws a fully black area with a small keyhole at pointerOffset that’ll show part of the UI.
                  drawRect(
                      Brush.radialGradient(
                          listOf(Color.Transparent, Color.Black),
                          center = pointerOffset,
                          radius = 100.dp.toPx(),
                      )
                  )
              }
      ) {
          // Your composables here
      }GraphicsModifiersSnippets.kt

   .. container:: float
      :name: image-1

   .. rubric:: ``Modifier.drawBehind``: Drawing behind a composable
      :name: drawbehind

   `Modifier.drawBehind  <#drawBehind>`__
   lets you perform ``DrawScope`` operations behind the composable content that
   is drawn on screen. If you take a look at the implementation of
   `Canvas  <#Canvas>`__, you
   might notice that it is just a convenient wrapper around
   ``Modifier.drawBehind``.

   To draw a rounded rectangle behind ``Text``:

   .. code:: prettyprint

      Text(
          "Hello Compose!",
          modifier = Modifier
              .drawBehind {
                  drawRoundRect(
                      Color(0xFFBBAAEE),
                      cornerRadius = CornerRadius(10.dp.toPx())
                  )
              }
              .padding(4.dp)
      )GraphicsModifiersSnippets.kt

   Which produces the following result:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/modifier_draw_behind.png
      name: image-2
      :alt: Text and a background drawn using Modifier.drawBehind
      :width: 100.0%

      **Figure 2**: Text and a background drawn using Modifier.drawBehind

   .. rubric:: ``Modifier.drawWithCache``: Drawing and caching draw objects
      :name: drawwithcache

   `Modifier.drawWithCache  <#drawWithCache>`__
   keeps the objects that are created inside of it cached. The objects are
   cached as long as the size of the drawing area is the same, or any state
   objects that are read have not changed. This modifier is useful for improving
   performance of drawing calls as it avoids the need to reallocate objects
   (such as: ``Brush, Shader, Path`` etc.) that are created on draw.

   Alternatively, you could also cache objects using ``remember``, outside of
   the modifier. However, this is not always possible as you don't always have
   access to the composition. It can be more performant to use ``drawWithCache``
   if the objects are only used for drawing.

   **Note:**\  Only use ``Modifier.drawWithCache`` when you’re creating objects
   that must be cached. Using this modifier without needing to cache objects,
   can result in unnecessary lambda allocations.
   For example, if you create a ``Brush`` to draw a gradient behind a ``Text``,
   using ``drawWithCache`` caches the ``Brush`` object until the size of the
   drawing area changes:

   .. code:: prettyprint

      Text(
          "Hello Compose!",
          modifier = Modifier
              .drawWithCache {
                  val brush = Brush.linearGradient(
                      listOf(
                          Color(0xFF9E82F0),
                          Color(0xFF42A5F5)
                      )
                  )
                  onDrawBehind {
                      drawRoundRect(
                          brush,
                          cornerRadius = CornerRadius(10.dp.toPx())
                      )
                  }
              }
      )GraphicsModifiersSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/modifier_draw_with_cache.png
      name: image-3
      :alt: Caching the Brush object with drawWithCache
      :width: 100.0%

      **Figure 3**: Caching the Brush object with drawWithCache

   .. rubric:: Graphics modifiers
      :name: graphics-modifiers

   .. rubric:: ``Modifier.graphicsLayer``: Apply transformations to composables
      :name: graphicsLayer

   `Modifier.graphicsLayer  <#>`__
   is a modifier that makes the content of the composable draw into a draw
   layer. A layer provides a few different functions, such as:

   -  Isolation for its drawing instructions (similar to
      `RenderNode  <#RenderNode>`__). Drawing
      instructions captured as part of a layer can be re-issued efficiently by
      the rendering pipeline without re-executing application code.
   -  Transformations that apply to all the drawing instructions contained
      within a layer.
   -  Rasterization for composition capabilities. When a layer is rasterized,
      its drawing instructions are executed and the output is captured into an
      offscreen buffer. `Compositing <#heading=%7B:compositing-strategy%7D>`__
      such a buffer for subsequent frames is faster than executing the
      individual instructions, but it will behave as a bitmap when transforms
      like scaling or rotation are applied.

   .. rubric:: Transformations
      :name: graphics-modifier-transformations

   ``Modifier.graphicsLayer`` provides isolation for its drawing instructions;
   for instance, various transformations can be applied using
   ``Modifier.graphicsLayer``. These can be animated or modified without needing
   to re-execute the drawing lambda.

   ``Modifier.graphicsLayer`` does not change the measured size or placement of
   your composable, as it only affects the draw phase. This means that your
   composable might overlap others if it ends up drawing outside of its layout
   bounds.

   **Note:**\  You should prefer the lambda version of this modifier when
   performing animations or using a ``State`` object to update a
   ``graphicsLayer`` property.
   The following transformations can be applied with this modifier:

   .. rubric:: Scale - increase size
      :name: graphics-modifier-scale

   ``scaleX`` and ``scaleY`` enlarges or shrinks content in the horizontal or
   vertical direction, respectively. A value of ``1.0f`` indicates no change in
   scale, a value of ``0.5f`` means half of the dimension.

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.sunset),
          contentDescription = "Sunset",
          modifier = Modifier
              .graphicsLayer {
                  this.scaleX = 1.2f
                  this.scaleY = 0.8f
              }
      )GraphicsModifiersSnippets.kt

   .. container:: float
      :name: image-4

   .. rubric:: Translation
      :name: graphics-modifier-translate

   ``translationX`` and ``translationY`` can be changed with ``graphicsLayer``,
   ``translationX`` moves the composable left or right. ``translationY`` moves
   the composable up or down.

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.sunset),
          contentDescription = "Sunset",
          modifier = Modifier
              .graphicsLayer {
                  this.translationX = 100.dp.toPx()
                  this.translationY = 10.dp.toPx()
              }
      )GraphicsModifiersSnippets.kt

   .. container:: float
      :name: image-5

   .. rubric:: Rotation
      :name: graphics-modifier-rotate

   Set ``rotationX`` to rotate horizontally, ``rotationY`` to rotate vertically
   and ``rotationZ`` to rotate on the Z axis (standard rotation). This value is
   specified in degrees (0-360).

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.sunset),
          contentDescription = "Sunset",
          modifier = Modifier
              .graphicsLayer {
                  this.rotationX = 90f
                  this.rotationY = 275f
                  this.rotationZ = 180f
              }
      )GraphicsModifiersSnippets.kt

   .. container:: float
      :name: image-6

   .. rubric:: Origin
      :name: graphics-modifier-origin

   A ``transformOrigin`` can be specified. It is then used as the point from
   which transformations take place. All the examples so far have used
   ``TransformOrigin.Center``, which is at ``(0.5f, 0.5f)``. If you specify the
   origin at ``(0f, 0f)``, the transformations then start from the top-left
   corner of the composable.

   If you change the origin with a ``rotationZ`` transformation, you can see
   that the item rotates around the top left of the composable:

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.sunset),
          contentDescription = "Sunset",
          modifier = Modifier
              .graphicsLayer {
                  this.transformOrigin = TransformOrigin(0f, 0f)
                  this.rotationX = 90f
                  this.rotationY = 275f
                  this.rotationZ = 180f
              }
      )GraphicsModifiersSnippets.kt

   .. container:: float
      :name: image-7

   .. rubric:: Clip and Shape
      :name: graphics-modifier-clip-shape

   Shape specifies the outline that the content clips to when ``clip = true``.
   In this example, we set two boxes to have two different clips - one using
   ``graphicsLayer`` clip variable, and the other using the convenient wrapper
   ``Modifier.clip``.

   .. code:: prettyprint

      Column(modifier = Modifier.padding(16.dp)) {
          Box(
              modifier = Modifier
                  .size(200.dp)
                  .graphicsLayer {
                      clip = true
                      shape = CircleShape
                  }
                  .background(Color(0xFFF06292))
          ) {
              Text(
                  "Hello Compose",
                  style = TextStyle(color = Color.Black, fontSize = 46.sp),
                  modifier = Modifier.align(Alignment.Center)
              )
          }
          Box(
              modifier = Modifier
                  .size(200.dp)
                  .clip(CircleShape)
                  .background(Color(0xFF4DB6AC))
          )
      }GraphicsModifiersSnippets.kt

   The contents of the first box (the text saying “Hello Compose”) are clipped
   to the circle shape:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/clip_applied.png
      name: image-8
      :alt: Clip applied to Box composable
      :width: 300px

      **Figure 8**: Clip applied to Box composable

   If you then apply a ``translationY`` to the top pink circle, you see that the
   bounds of the Composable are still the same, but the circle draws underneath
   the bottom circle (and outside of its bounds).

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/clip_applied_red_border.png
      name: image-9
      :alt: Clip applied with translationY, and red border for outline
      :width: 300px

      **Figure 9**: Clip applied with translationY, and red border for outline

   To clip the composable to the region it's drawn in, you can add another
   ``Modifier.clip(RectangleShape)`` at the start of the modifier chain. The
   content then remains inside of the original bounds.

   .. code:: prettyprint

      Column(modifier = Modifier.padding(16.dp)) {
          Box(
              modifier = Modifier
                  .clip(RectangleShape)
                  .size(200.dp)
                  .border(2.dp, Color.Black)
                  .graphicsLayer {
                      clip = true
                      shape = CircleShape
                      translationY = 50.dp.toPx()
                  }
                  .background(Color(0xFFF06292))
          ) {
              Text(
                  "Hello Compose",
                  style = TextStyle(color = Color.Black, fontSize = 46.sp),
                  modifier = Modifier.align(Alignment.Center)
              )
          }

          Box(
              modifier = Modifier
                  .size(200.dp)
                  .clip(RoundedCornerShape(500.dp))
                  .background(Color(0xFF4DB6AC))
          )
      }GraphicsModifiersSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/clip_applied_everything.png
      name: image-10
      :alt: Clip applied on top of graphicsLayer transformation
      :width: 300px

      **Figure 10**: Clip applied on top of graphicsLayer transformation

   .. rubric:: Alpha
      :name: graphics-modifier-alpha

   ``Modifier.graphicsLayer`` can be used to set an ``alpha`` (opacity) for the
   whole layer. ``1.0f`` is fully opaque and ``0.0f`` is invisible.

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.sunset),
          contentDescription = "clock",
          modifier = Modifier
              .graphicsLayer {
                  this.alpha = 0.5f
              }
      )GraphicsModifiersSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/image_alpha.png
      name: image-11
      :alt: Image with alpha applied
      :width: 300px

      **Figure 11**: Image with alpha applied

   **Note:**\  When an alpha is set to less than 1.0f, the entire contents of
   the layer are drawn to an offscreen buffer (if the
   `CompositingStrategy  <#CompositingStrategy>`__
   is not set to
   `ModulateAlpha  <#ModulateAlpha>`__).
   See the ``CompositingStrategy`` section for more information.

   .. rubric:: Compositing strategy
      :name: compositing-strategy

   Working with alpha and transparency might not be as simple as changing a
   single alpha value. In addition to changing an alpha, there is also the
   option to set a
   `CompositingStrategy  <#CompositingStrategy>`__
   on a ``graphicsLayer``. A ``CompositingStrategy`` determines how the content
   of the composable is composited (put together) with the other content already
   drawn on screen.

   **Note:**\  ``CompositingStrategy`` was introduced in Compose
   ``1.4.0-alpha02``.
   The different strategies are:

   .. rubric:: Auto (default)
      :name: compositing-strategy-auto

   The `compositing strategy  <#Auto>`__
   is determined by the rest of the ``graphicsLayer`` parameters. It renders the
   layer into an offscreen buffer if alpha is less than 1.0f or a
   ``RenderEffect`` is set. Whenever the alpha is less than 1f, a compositing
   layer is created automatically to render the contents and then draw this
   offscreen buffer to the destination with the corresponding alpha. Setting a
   `RenderEffect  <#RenderEffect>`__ or overscroll
   always renders content into an offscreen buffer regardless of the
   ``CompositingStrategy`` set.

   .. rubric:: Offscreen
      :name: compositing-strategy-offscreen

   The contents of the composable are **always** rasterized to an offscreen
   texture or bitmap before rendering to the destination. This is useful for
   applying
   `BlendMode  <#BlendMode>`__
   operations to mask content, and for performance when rendering complex sets
   of drawing instructions.

   An example of using
   `CompositingStrategy.Offscreen  <#Offscreen>`__
   is with ``BlendModes``. Taking a look at the example below, say you want to
   remove parts of an ``Image`` composable by issuing a draw command that uses
   ``BlendMode.Clear``. If you do not set the ``compositingStrategy`` to
   ``CompositingStrategy.Offscreen``, the ``BlendMode`` interacts with all the
   contents below it.

   .. code:: prettyprint

      Image(painter = painterResource(id = R.drawable.dog),
         contentDescription = "Dog",
         contentScale = ContentScale.Crop,
         modifier = Modifier
             .size(120.dp)
             .aspectRatio(1f)
             .background(
                 Brush.linearGradient(
                     listOf(
                         Color(0xFFC5E1A5),
                         Color(0xFF80DEEA)
                     )
                 )
             )
             .padding(8.dp)
             .graphicsLayer {
                 compositingStrategy = CompositingStrategy.Offscreen
             }
             .drawWithCache {
                 val path = Path()
                 path.addOval(
                     Rect(
                         topLeft = Offset.Zero,
                         bottomRight = Offset(size.width, size.height)
                     )
                 )
                 onDrawWithContent {
                     clipPath(path) {
                         // this draws the actual image - if you don't call drawContent, it wont
                         // render anything
                         this@onDrawWithContent.drawContent()
                     }
                     val dotSize = size.width / 8f
                     // Clip a white border for the content
                     drawCircle(
                         Color.Black,
                         radius = dotSize,
                         center = Offset(
                             x = size.width - dotSize,
                             y = size.height - dotSize
                         ),
                         blendMode = BlendMode.Clear
                     )
                     // draw the red circle indication
                     drawCircle(
                         Color(0xFFEF5350), radius = dotSize * 0.8f,
                         center = Offset(
                             x = size.width - dotSize,
                             y = size.height - dotSize
                         )
                     )
                 }

             }
      )GraphicsModifiersSnippets.kt

   By setting the ``CompositingStrategy`` to ``Offscreen``, it creates an
   offscreen texture to execute the commands to (applying the ``BlendMode`` only
   to the contents of this composable). It then renders it on top of what is
   already rendered on screen, not affecting the content already drawn.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/complex_modifier_example_drawWithCache_background.png
      name: image-12
      :alt: Modifier.drawWithContent on an Image showing a circle indication,
      with the BlendMode.Clear inside app
      :width: 300px

      **Figure 12**: Modifier.drawWithContent on an Image showing a circle
      indication, with the BlendMode.Clear and CompositingStrategy.Offscreen
      inside app

   If you didn't use ``CompositingStrategy.Offscreen``, the results of applying
   ``BlendMode.Clear`` clears all the pixels in the destination, regardless of
   what was already set– leaving the window’s rendering buffer (black) visible.
   Many of the ``BlendModes`` that involve alpha won't work as expected without
   an offscreen buffer. Note the black ring around the red circle indicator:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/blendmode_without_compositing_strategy.png
      name: image-13
      :alt: Modifier.drawWithContent on an Image showing a circle indication,
      with the BlendMode.Clear and no CompositingStrategy set
      :width: 300px

      **Figure 13**: Modifier.drawWithContent on an Image showing a circle
      indication, with the BlendMode.Clear and no CompositingStrategy set

   To understand this a bit further: if the app had a translucent window
   background, and you did not use the ``CompositingStrategy.Offscreen``, the
   ``BlendMode`` would interact with the whole app. It would clear all of the
   pixels to show the app or wallpaper underneath, as in this example:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/compositing_strategy_punch_through_to_wallpaper.png
      name: image-14
      :alt: No CompositingStrategy set and using BlendMode.Clear with an app
      that has a translucent window background. The pink wallpaper is shown
      through the area around the red status circle.
      :width: 300px

      **Figure 14**: No CompositingStrategy set and using BlendMode.Clear with
      an app that has a translucent window background. Notice how the pink
      wallpaper is shown through the area around the red status circle.

   It's worth noting that when using ``CompositingStrategy.Offscreen``, an
   offscreen texture that is the size of the drawing area is created and
   rendered back on screen. Any drawing commands that are done with this
   strategy, are by default be clipped to this region. The below code snippet
   illustrates the differences when switching to using offscreen textures:

   .. code:: prettyprint

      @Composable
      fun CompositingStrategyExamples() {
         Column(
             modifier = Modifier
                 .fillMaxSize()
                 .wrapContentSize(Alignment.Center)
         ) {
             /** Does not clip content even with a graphics layer usage here. By default, graphicsLayer
             does not allocate + rasterize content into a separate layer but instead is used
             for isolation. That is draw invalidations made outside of this graphicsLayer will not
             re-record the drawing instructions in this composable as they have not changed **/
             Canvas(
                 modifier = Modifier
                     .graphicsLayer()
                     .size(100.dp) // Note size of 100 dp here
                     .border(2.dp, color = Color.Blue)
             ) {
                 // ... and drawing a size of 200 dp here outside the bounds
                 drawRect(color = Color.Magenta, size = Size(200.dp.toPx(), 200.dp.toPx()))
             }

             Spacer(modifier = Modifier.size(300.dp))

             /** Clips content as alpha usage here creates an offscreen buffer to rasterize content
             into first then draws to the original destination **/
             Canvas(
                 modifier = Modifier
                     // force to an offscreen buffer
                     .graphicsLayer(compositingStrategy = CompositingStrategy.Offscreen)
                     .size(100.dp) // Note size of 100 dp here
                     .border(2.dp, color = Color.Blue)
             ) {
                 /** ... and drawing a size of 200 dp. However, because of the CompositingStrategy.Offscreen usage above, the
                 content gets clipped **/
                 drawRect(color = Color.Red, size = Size(200.dp.toPx(), 200.dp.toPx()))
             }
         }
      }GraphicsModifiersSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/graphics_compositing_strategy.png
      name: image-15
      :alt: CompositingStrategy.Auto vs CompositingStrategy.Offscreen -
      offscreen clips to the region, where auto doesn’t
      :width: 300px

      **Figure 15**: CompositingStrategy.Auto vs CompositingStrategy.Offscreen -
      offscreen clips to the region, where auto doesn’t

   .. rubric:: ``ModulateAlpha``
      :name: modulatealpha

   This `composition strategy  <#ModulateAlpha>`__
   modulates the alpha for each of the drawing instructions recorded within the
   ``graphicsLayer``. It won't create an offscreen buffer for alpha below 1.0f
   unless a ``RenderEffect`` is set, so it can be more efficient for alpha
   rendering. However, it can provide different results for overlapping content.
   For use cases where it is known in advance that content is not overlapping,
   this can provide better performance than ``CompositingStrategy.Auto`` with
   alpha values less than 1.

   Another example of different composition strategies is below - applying
   different alphas to different parts of the composables, and applying a
   ``Modulate`` strategy:

   .. code:: prettyprint

      @Preview
      @Composable
      fun CompositingStratgey_ModulateAlpha() {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(32.dp)
        ) {
            // Base drawing, no alpha applied
            Canvas(
                modifier = Modifier.size(200.dp)
            ) {
                drawSquares()
            }

            Spacer(modifier = Modifier.size(36.dp))

            // Alpha 0.5f applied to whole composable
            Canvas(modifier = Modifier
                .size(200.dp)
                .graphicsLayer {
                    alpha = 0.5f
                }) {
                drawSquares()
            }
            Spacer(modifier = Modifier.size(36.dp))

            // 0.75f alpha applied to each draw call when using ModulateAlpha
            Canvas(modifier = Modifier
                .size(200.dp)
                .graphicsLayer {
                    compositingStrategy = CompositingStrategy.ModulateAlpha
                    alpha = 0.75f
                }) {
                drawSquares()
            }
        }
      }

      private fun DrawScope.drawSquares() {

        val size = Size(100.dp.toPx(), 100.dp.toPx())
        drawRect(color = Red, size = size)
        drawRect(
            color = Purple, size = size,
            topLeft = Offset(size.width / 4f, size.height / 4f)
        )
        drawRect(
            color = Yellow, size = size,
            topLeft = Offset(size.width / 4f * 2f, size.height / 4f * 2f)
        )
      }

      val Purple = Color(0xFF7E57C2)
      val Yellow = Color(0xFFFFCA28)
      val Red = Color(0xFFEF5350)GraphicsModifiersSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/modulate_alpha.png
      name: image-16
      :alt: ModulateAlpha applies the alpha set to each individual draw command
      :width: 300px

      **Figure 16**: ModulateAlpha applies the alpha set to each individual draw
      command

   .. rubric:: Write contents of a composable to a bitmap
      :name: composable-to-bitmap

   **Note:**\  The ``rememberGraphicsLayer()`` function used in this snippet is
   only available from Compose 1.7.0-alpha07+.
   A common use case is to create a ``Bitmap`` from a composable. To copy the
   contents of your composable to a ``Bitmap``, create a ``GraphicsLayer`` using
   ``rememberGraphicsLayer()``.

   Redirect the drawing commands to the new layer using ``drawWithContent()``
   and ``graphicsLayer.record{}``. Then draw the layer in the visible canvas
   using ``drawLayer``:

   .. code:: prettyprint

      val coroutineScope = rememberCoroutineScope()
      val graphicsLayer = rememberGraphicsLayer()
      Box(
          modifier = Modifier
              .drawWithContent {
                  // call record to capture the content in the graphics layer
                  graphicsLayer.record {
                      // draw the contents of the composable into the graphics layer
                      this@drawWithContent.drawContent()
                  }
                  // draw the graphics layer on the visible canvas
                  drawLayer(graphicsLayer)
              }
              .clickable {
                  coroutineScope.launch {
                      val bitmap = graphicsLayer.toImageBitmap()
                      // do something with the newly acquired bitmap
                  }
              }
              .background(Color.White)
      ) {
          Text("Hello Android", fontSize = 26.sp)
      }AdvancedGraphicsSnippets.kt

   You can save the bitmap to disk and share it. For more details, see the `full example snippet <https://github.com/android/snippets/blob/latest/compose/snippets/src/main/java/com/example/compose/snippets/graphics/AdvancedGraphicsSnippets.kt#L123>`__.
   Be sure to check for on device permissions before trying to save to disk.

   .. rubric:: Custom drawing modifier
      :name: custom-drawing-modifier

   To create your own custom modifier, implement the ``DrawModifier`` interface.
   This gives you access to a ``ContentDrawScope``, which is the same as what is
   exposed when using ``Modifier.drawWithContent()``. You can then extract
   common drawing operations to custom drawing modifiers to clean up the code
   and provide convenient wrappers; for example, ``Modifier.background()`` is a
   convenient ``DrawModifier``.

   For example, if you wanted to implement a ``Modifier`` that vertically flips
   content, you can create one as follows:

   .. code:: prettyprint

      class FlippedModifier : DrawModifier {
          override fun ContentDrawScope.draw() {
              scale(1f, -1f) {
                  this@draw.drawContent()
              }
          }
      }

      fun Modifier.flipped() = this.then(FlippedModifier())GraphicsModifiersSnippets.kt

   Then use this flipped modifier applied on ``Text``:

   .. code:: prettyprint

      Text(
          "Hello Compose!",
          modifier = Modifier
              .flipped()
      )GraphicsModifiersSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/modifiers/modifier_flipped.png
      name: image-17
      :alt: Custom Flipped Modifier on Text
      :width: 100.0%

      **Figure 17**: Custom Flipped Modifier on Text

   .. rubric:: Additional resources
      :name: additional-resources

   For more examples using ``graphicsLayer`` and custom drawing, check out the
   following resources:

   -  `Making Jellyfish move in Compose <https://medium.com/androiddevelopers/making-jellyfish-move-in-compose-animating-imagevectors-and-applying-agsl-rendereffects-3666596a8888>`__
   -  `ADS 2022 Layouts and Graphics in Compose <https://youtu.be/xcfEQO0k_gU>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Graphics in Compose  <#overview>`__
   -  `Customize an image {:#customize-image}  <#customize>`__
   -  `Kotlin for Jetpack Compose  <#kotlin>`__

Last updated 2024-05-03 UTC.

/Brush
======

.. https://developer.android.google.cn/develop/ui/compose/graphics/draw/brush?hl=en

.. container:: devsite-article-body clearfix

   A `Brush  <#Brush>`__ in
   Compose describes how something is drawn on screen: it determines the
   color(s) that are drawn in the drawing area (i.e. a circle, square, path).
   There are a few built-in Brushes that are useful for drawing, such as
   `LinearGradient  <#LinearGradient>`__,
   `RadialGradient  <#RadialGradient>`__
   or a plain
   `SolidColor  <#SolidColor>`__
   brush.

   Brushes can be used with
   `Modifier.background()  <#>`__,
   `TextStyle  <#TextStyle>`__, or
   `DrawScope  <#DrawScope>`__
   draw calls to apply the painting style to the content being drawn.

   For example, a horizontal gradient brush can be applied to drawing a circle
   in ``DrawScope``:

   .. code:: prettyprint

      val brush = Brush.horizontalGradient(listOf(Color.Red, Color.Blue))
      Canvas(
          modifier = Modifier.size(200.dp),
          onDraw = {
              drawCircle(brush)
          }
      )BrushExampleSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/draw_circle_example.png
      name: image-1
      :alt: Circle drawn with Horizontal Gradient
      :width: 300px

      **Figure 1**: Circle drawn with Horizontal Gradient

   .. rubric:: Gradient brushes
      :name: gradient-brushes

   There are many built-in gradient brushes that can be used to achieve
   different gradient effects. These brushes allow you to specify the list of
   colors that you would like to create a gradient from.

   A list of available gradient brushes and their corresponding output:

   .. list-table::
      :widths: 40 40
      :header-rows: 1

      - 

         - Gradient Brush Type
         - Output
      - 

         - `Brush.horizontalGradient(colorList)  <#horizontalGradient>`__
         - |Horizontal Gradient|
      - 

         - `Brush.linearGradient(colorList)  <#linearGradient>`__
         - |Linear Gradient|
      - 

         - `Brush.verticalGradient(colorList)  <#verticalGradient>`__
         - |Vertical Gradient|
      - 

         - `Brush.sweepGradient(colorList)  <#sweepGradient>`__
            Note: To get a smooth transition between colors - set the last color
            to the start color.
         - |Sweep Gradient|
      - 

         - `Brush.radialGradient(colorList)  <#radialGradient>`__
         - |Radial Gradient|

   .. rubric:: Change distribution of colors with ``colorStops``
      :name: color-stops

   To customize how the colors appear in the gradient, you can tweak the
   ``colorStops`` value for each one. ``colorStops`` should be specified as a
   fraction, between 0 and 1. Values greater than 1 will result in those colors
   not rendering as part of the gradient.

   You can configure the color stops to have different amounts, such as less or
   more of one color:

   .. code:: prettyprint

      val colorStops = arrayOf(
          0.0f to Color.Yellow,
          0.2f to Color.Red,
          1f to Color.Blue
      )
      Box(
          modifier = Modifier
              .requiredSize(200.dp)
              .background(Brush.horizontalGradient(colorStops = colorStops))
      )BrushExampleSnippets.kt

   The colors are dispersed at the provided offset as defined in the
   ``colorStop`` pair, less yellow than red and blue.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/color_stops.png
      name: image-2
      :alt: Brush configured with different color stops
      :width: 300px

      **Figure 2**: Brush configured with different color stops

   .. rubric:: Repeat a pattern with ``TileMode``
      :name: tilemode

   Each gradient brush has the option to set a
   `TileMode  <#TileMode>`__ on
   it. You may not notice the ``TileMode`` if you haven’t set a start and end
   for the gradient, as it’ll default to fill the whole area. A ``TileMode``
   will only tile the gradient if the size of the area is bigger than the Brush
   size.

   The following code will repeat the gradient pattern 4 times, since the
   ``endX`` is set to ``50.dp`` and the size is set to ``200.dp``:

   .. code:: prettyprint

      val listColors = listOf(Color.Yellow, Color.Red, Color.Blue)
      val tileSize = with(LocalDensity.current) {
          50.dp.toPx()
      }
      Box(
          modifier = Modifier
              .requiredSize(200.dp)
              .background(
                  Brush.horizontalGradient(
                      listColors,
                      endX = tileSize,
                      tileMode = TileMode.Repeated
                  )
              )
      )BrushExampleSnippets.kt

   Here is a table detailing what the different Tile Modes do for the
   ``HorizontalGradient`` example above:

   .. list-table::
      :header-rows: 1

      - 

         - TileMode
         - Output
      - 

         - `TileMode.Repeated  <#Repeated>`__:
            Edge is repeated from last color to first.
         - |TileMode Repeated|
      - 

         - `TileMode.Mirror  <#Mirror>`__:
            Edge is mirrored from last color to first.
         - |TileMode Mirror|
      - 

         - `TileMode.Clamp  <#Clamp>`__:
            Edge is clamped to the final color. It’ll then paint the closest
            color for the rest of the region.
         - |Tile Mode Clamp|
      - 

         - `TileMode.Decal  <#Decal>`__:
            Render only up to the size of the bounds. ``TileMode.Decal``
            leverages transparent black to sample content outside the original
            bounds whereas ``TileMode.Clamp`` samples the edge color.
         - |Tile Mode Decal|

   **Note:**\  ``TileMode.Decal`` is only available on API 31+. Use
   ``TileMode.isSupported()`` to determine if a ``TileMode`` is supported on a
   device. If a ``TileMode`` that is not supported is used, the default of
   ``TileMode.Clamp`` is applied.
   ``TileMode`` works in a similar way for the other directional gradients, the
   difference being the direction that the repetition occurs.

   .. rubric:: Change brush Size
      :name: brush-size

   If you know the size of the area in which your brush will be drawn, you can
   set the tile ``endX`` as we’ve seen above in the ``TileMode`` section. If you
   are in a ``DrawScope``, you can use its
   `size  <#size>`__
   property to get the size of the area.

   If you don't know the size of your drawing area (for example if the ``Brush``
   is assigned to Text), you can extend ``Shader`` and utilize the size of the
   drawing area in the ``createShader`` function.

   In this example, divide the size by 4 to repeat the pattern 4 times:

   .. code:: prettyprint

      val listColors = listOf(Color.Yellow, Color.Red, Color.Blue)
      val customBrush = remember {
          object : ShaderBrush() {
              override fun createShader(size: Size): Shader {
                  return LinearGradientShader(
                      colors = listColors,
                      from = Offset.Zero,
                      to = Offset(size.width / 4f, 0f),
                      tileMode = TileMode.Mirror
                  )
              }
          }
      }
      Box(
          modifier = Modifier
              .requiredSize(200.dp)
              .background(customBrush)
      )BrushExampleSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/tile_mode_mirror.png
      name: image-3
      :alt: Shader size divided by 4
      :width: 300px

      **Figure 3**: Shader size divided by 4

   You can also change the brush size of any other gradient, such as radial
   gradients. If you don't specify a size and center, the gradient will occupy
   the full bounds of the ``DrawScope``, and the center of the radial gradient
   defaults to the center of the ``DrawScope`` bounds. This results in the
   radial gradient's center appearing as the center of the smaller dimension
   (either width or height):

   .. code:: prettyprint

      Box(
          modifier = Modifier
              .fillMaxSize()
              .background(
                  Brush.radialGradient(
                      listOf(Color(0xFF2be4dc), Color(0xFF243484))
                  )
              )
      )BrushExampleSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/radial_gradient_default.png
      name: image-4
      :alt: Radial Gradient set without size changes
      :figclass: screenshot
      :width: 300px

      **Figure 4**: Radial Gradient set without size changes

   When the radial gradient is changed to set the radius size to the max
   dimension, you can see that it produces a better radial gradient effect:

   .. code:: prettyprint

      val largeRadialGradient = object : ShaderBrush() {
          override fun createShader(size: Size): Shader {
              val biggerDimension = maxOf(size.height, size.width)
              return RadialGradientShader(
                  colors = listOf(Color(0xFF2be4dc), Color(0xFF243484)),
                  center = size.center,
                  radius = biggerDimension / 2f,
                  colorStops = listOf(0f, 0.95f)
              )
          }
      }

      Box(
          modifier = Modifier
              .fillMaxSize()
              .background(largeRadialGradient)
      )BrushExampleSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/radial_size_biggest_dimension.png
      name: image-5
      :alt: Bigger radius on radial gradient, based on size of area
      :figclass: screenshot
      :width: 300px

      **Figure 5**: Bigger radius on radial gradient, based on size of area

   It is worth noting that the actual size that is passed into the creation of
   the shader is determined from where it is invoked. By default, ``Brush`` will
   reallocate its ``Shader`` internally if the size is different from the last
   creation of the ``Brush``, or if a state object used in creation of the
   shader has changed.

   The following code creates the shader three different times with different
   sizes, as the size of the drawing area changes:

   .. code:: prettyprint

      val colorStops = arrayOf(
          0.0f to Color.Yellow,
          0.2f to Color.Red,
          1f to Color.Blue
      )
      val brush = Brush.horizontalGradient(colorStops = colorStops)
      Box(
          modifier = Modifier
              .requiredSize(200.dp)
              .drawBehind {
                  drawRect(brush = brush) // will allocate a shader to occupy the 200 x 200 dp drawing area
                  inset(10f) {
            /* Will allocate a shader to occupy the 180 x 180 dp drawing area as the
             inset scope reduces the drawing  area by 10 pixels on the left, top, right,
            bottom sides */
                      drawRect(brush = brush)
                      inset(5f) {
              /* will allocate a shader to occupy the 170 x 170 dp drawing area as the
               inset scope reduces the  drawing area by 5 pixels on the left, top,
               right, bottom sides */
                          drawRect(brush = brush)
                      }
                  }
              }
      )BrushExampleSnippets.kt

   .. rubric:: Use an image as a brush
      :name: image-as-brush

   To use an
   `ImageBitmap  <#image-bitmap>`__ as
   a ``Brush``, load up the image as an ``ImageBitmap``, and create an
   ``ImageShader`` brush:

   .. code:: prettyprint

      val imageBrush =
          ShaderBrush(ImageShader(ImageBitmap.imageResource(id = R.drawable.dog)))

      // Use ImageShader Brush with background
      Box(
          modifier = Modifier
              .requiredSize(200.dp)
              .background(imageBrush)
      )

      // Use ImageShader Brush with TextStyle
      Text(
          text = "Hello Android!",
          style = TextStyle(
              brush = imageBrush,
              fontWeight = FontWeight.ExtraBold,
              fontSize = 36.sp
          )
      )

      // Use ImageShader Brush with DrawScope#drawCircle()
      Canvas(onDraw = {
          drawCircle(imageBrush)
      }, modifier = Modifier.size(200.dp))BrushExampleSnippets.kt

   The Brush is applied to a few different types of drawing: a background, the
   Text and Canvas. This outputs the following:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/image_brush.png
      name: image-6
      :alt: ImageShader Brush used in different ways
      :width: 100.0%

      **Figure 6**: Using ImageShader Brush to draw a background, draw Text and
      draw a Circle

   Notice that the text is now also rendered using the ``ImageBitmap`` to paint
   the pixels for the text.

   .. rubric:: Advanced example: Custom brush
      :name: advanced-example

   .. rubric:: AGSL ``RuntimeShader`` brush
      :name: agsl-runtimeshader

   `AGSL  <#agsl>`__ offers a subset of
   `GLSL  <#agsl-vs-glsl>`__ Shader capabilities.
   Shaders can be written in AGSL and used with a Brush in Compose.

   To create a Shader brush, first define the Shader as AGSL shader string:

   .. code:: prettyprint

      @Language("AGSL")
      val CUSTOM_SHADER = """
          uniform float2 resolution;
          layout(color) uniform half4 color;
          layout(color) uniform half4 color2;

          half4 main(in float2 fragCoord) {
              float2 uv = fragCoord/resolution.xy;

              float mixValue = distance(uv, vec2(0, 1));
              return mix(color, color2, mixValue);
          }
      """.trimIndent()BrushExampleSnippets.kt

   The shader above takes two input colors, calculates the distance from the
   bottom left (``vec2(0, 1)``) of the drawing area and does a ``mix`` between
   the two colors based on the distance. This produces a gradient effect.

   Then, create the Shader Brush, and set the uniforms for ``resolution`` - the
   size of the drawing area, and the ``color`` and ``color2`` you want to use as
   input to your custom gradient:

   .. code:: prettyprint

      val Coral = Color(0xFFF3A397)
      val LightYellow = Color(0xFFF8EE94)

      @RequiresApi(Build.VERSION_CODES.TIRAMISU)
      @Composable
      @Preview
      fun ShaderBrushExample() {
          Box(
              modifier = Modifier
                  .drawWithCache {
                      val shader = RuntimeShader(CUSTOM_SHADER)
                      val shaderBrush = ShaderBrush(shader)
                      shader.setFloatUniform("resolution", size.width, size.height)
                      onDrawBehind {
                          shader.setColorUniform(
                              "color",
                              android.graphics.Color.valueOf(
                                  LightYellow.red, LightYellow.green,
                                  LightYellow
                                      .blue,
                                  LightYellow.alpha
                              )
                          )
                          shader.setColorUniform(
                              "color2",
                              android.graphics.Color.valueOf(
                                  Coral.red,
                                  Coral.green,
                                  Coral.blue,
                                  Coral.alpha
                              )
                          )
                          drawRect(shaderBrush)
                      }
                  }
                  .fillMaxWidth()
                  .height(200.dp)
          )
      }BrushExampleSnippets.kt

   Running this, you can see the following rendered on screen:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/shaders.png
      name: image-7
      :alt: Custom AGSL Shader running in Compose
      :width: 100.0%

      **Figure 7**: Custom AGSL Shader running in Compose

   It's worth noting that you can do a lot more with shaders than just
   gradients, as it's all math-based calculations. For more information on AGSL,
   check out the AGSL `documentation  <#agsl>`__.

   **Note:**\  ``RuntimeShaders`` only works on Android 13+. Wrap your
   Composable in an API if-else check and provide a suitable fallback.

   .. rubric:: Additional resources
      :name: additional-resources

   For more examples of using Brush in Compose, check out the following
   resources:

   -  `Animating brush Text coloring in Compose 🖌️ <https://medium.com/androiddevelopers/animating-brush-text-coloring-in-compose-%EF%B8%8F-26ae99d9b402>`__
   -  `Custom Graphics and Layouts in Compose - Android Dev Summit 2022 <https://youtu.be/xcfEQO0k_gU>`__
   -  `JetLagged Sample - RuntimeShader Brush <https://github.com/android/compose-samples/blob/main/JetLagged/app/src/main/java/com/example/jetlagged/Background.kt>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Graphics Modifiers  <#modifiers>`__
   -  `Graphics in Compose  <#overview>`__
   -  `Style text  <#style-text>`__

Last updated 2024-05-03 UTC.

.. |Horizontal Gradient| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/horizontal_gradient.png
.. |Linear Gradient| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/linear_gradient.png
.. |Vertical Gradient| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/vertical_gradient.png
.. |Sweep Gradient| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/sweep_gradient.png
.. |Radial Gradient| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/radial_gradient.png
.. |TileMode Repeated| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/tile_mode_repeated.png
.. |TileMode Mirror| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/tile_mode_mirror.png
.. |Tile Mode Clamp| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/tile_mode_clamp.png
.. |Tile Mode Decal| image:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/brush/tile_mode_decal.png

/Shapes
=======

.. https://developer.android.google.cn/develop/ui/compose/graphics/draw/shapes?hl=en

.. container:: devsite-article-body clearfix

   With Compose, you can create shapes that are made from polygons. For example,
   you can make the following kinds of shapes:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/shape_examples_compose.png
      name: image-1
      :alt: Blue hexagon in the center of the drawing area
      :width: 300px

      **Figure 1**. Examples of different shapes you can make with
      graphics-shapes library

   To create a custom rounded polygon in Compose, add the
   `graphics-shapes  <#graphics>`__ dependency to
   your ``app/build.gradle``:

   .. code:: prettyprint

      implementation "androidx.graphics:graphics-shapes:1.0.0-alpha05"

   This library lets you create shapes that are made from polygons. While
   polygonal shapes have only straight edges and sharp corners, these shapes
   allow for optional rounded corners. It makes it simple to morph between two
   different shapes. Morphing is difficult between arbitrary shapes, and tends
   to be a design-time problem. But this library makes it simple by morphing
   between these shapes with similar polygonal structures.

   **Note:**\  The `graphics-shapes  <#graphics>`__
   library is a separate set of
   `Shapes  <#Shape>`__ from the
   built-in Compose shapes (like
   `RoundedCornerShape  <#RoundedCornerShape>`__).
   ``graphics-shapes`` are designed for use with the Compose or View system.
   Shapes from ``graphics-shapes`` can be converted into Compose shapes by
   converting resulting shapes to ``Path`` objects, as shown in some of the code
   examples below.
   **Caution:**\  This library is not for morphing between arbitrary paths (for
   example, a play icon to a pause icon), but rather only between these polygon
   shapes. When you have an arbitrary path that needs to morph between them, use
   `AnimatedVectorDrawables  <#vectors>`__
   instead, and a third-party tool like
   `shapeshifter.design <https://shapeshifter.design/>`__ to align the path
   points correctly.

   .. rubric:: Create polygons
      :name: create-polygons

   The following snippet creates a basic polygon shape with 6 points in the
   center of the drawing area:

   .. code:: prettyprint

      Box(
          modifier = Modifier
              .drawWithCache {
                  val roundedPolygon = RoundedPolygon(
                      numVertices = 6,
                      radius = size.minDimension / 2,
                      centerX = size.width / 2,
                      centerY = size.height / 2
                  )
                  val roundedPolygonPath = roundedPolygon.toPath().asComposePath()
                  onDrawBehind {
                      drawPath(roundedPolygonPath, color = Color.Blue)
                  }
              }
              .fillMaxSize()
      )ShapesSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/basic_polygon.png
      name: image-2
      :alt: Blue hexagon in the center of the drawing area
      :width: 300px

      **Figure 2**. Blue hexagon in the center of the drawing area.

   In this example, the library creates a ``RoundedPolygon`` which holds the
   geometry representing the requested shape. In order to draw that shape in a
   Compose app, you must get a ``Path`` object from it to get the shape into a
   form which Compose knows how to draw.

   .. rubric:: Round the corners of a polygon
      :name: round-corners

   To round the corners of a polygon, use the ``CornerRounding`` parameter. This
   takes two parameters, ``radius`` and ``smoothing``. Each rounded corner is
   made up of 1-3 cubic curves, the center of which has a circular arc shape
   while the two side ("flanking") curves transition from the shape's edge to
   the center curve.

   .. rubric:: Radius
      :name: radius

   The ``radius`` is the radius of the circle used to round a vertex.

   For example, the following rounded corner triangle is made as follows:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/triangle_rounded_corners.png
      name: image-3
      :alt: Triangle with rounded corners
      :width: 300px

      **Figure 3**. Triangle with rounded corners.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/rounding_corner_polygon.png
      name: image-4
      :alt: The rounding radius r determines the circular rounding size of
      rounded corners
      :width: 300px

      **Figure 4**. The rounding radius ``r`` determines the circular rounding
      size of rounded corners.

   .. rubric:: Smoothing
      :name: smoothing

   Smoothing is a factor which determines how long it takes to get from the
   circular rounding portion of the corner to the edge. A smoothing factor of 0
   (unsmoothed, the default value for ``CornerRounding``) results in purely
   circular corner rounding. A nonzero smoothing factor (up to the max of 1.0)
   results in the corner being rounded by three separate curves.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/smoothing_polygon.png
      name: image-5
      :alt: A smoothing factor of 0 (unsmoothed) produces a single cubic curve
      which follows a circle around the corner with the specified rounding
      radius, as in the earlier example
      :width: 300px

      **Figure 5**. A smoothing factor of 0 (unsmoothed) produces a single cubic
      curve which follows a circle around the corner with the specified rounding
      radius, as in the earlier example.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/smoothing_polygon_non_zero.png
      name: image-6
      :alt: A nonzero smoothing factor produces three cubic curves to round the
      vertex: the inner circular curve (as before) plus two flanking curves that
      transition between the inner curve and the polygon edges.
      :width: 300px

      **Figure 6**. A nonzero smoothing factor produces three cubic curves to
      round the vertex: the inner circular curve (as before) plus two flanking
      curves that transition between the inner curve and the polygon edges.

   For example, the snippet below illustrates the subtle difference in setting
   smoothing to 0 versus 1:

   .. code:: prettyprint

      Box(
          modifier = Modifier
              .drawWithCache {
                  val roundedPolygon = RoundedPolygon(
                      numVertices = 3,
                      radius = size.minDimension / 2,
                      centerX = size.width / 2,
                      centerY = size.height / 2,
                      rounding = CornerRounding(
                          size.minDimension / 10f,
                          smoothing = 0.1f
                      )
                  )
                  val roundedPolygonPath = roundedPolygon.toPath().asComposePath()
                  onDrawBehind {
                      drawPath(roundedPolygonPath, color = Color.Black)
                  }
              }
              .size(100.dp)
      )
      ShapesSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/smoothing_difference.png
      name: image-7
      :alt: Two black triangles showing the difference in smoothing parameter.
      :width: 300px

      **Figure 7**. Two black triangles showing the difference in smoothing
      parameter.

   .. rubric:: Size and position
      :name: size-position

   By default, a shape is created with a radius of ``1`` around the center
   (``0, 0``). This radius represents the distance between the center and the
   exterior vertices of the polygon on which the shape is based. Note that
   rounding the corners results in a smaller shape since the rounded corners
   will be closer to the center than the vertices being rounded. To size a
   polygon, adjust the ``radius`` value. To adjust the position, change the
   ``centerX`` or ``centerY`` of the polygon. Alternatively, transform the
   object to change its size, position, and rotation using standard
   ``DrawScope`` transformation functions such as
   `DrawScope#translate()  <#translate>`__.

   .. rubric:: Morph shapes
      :name: morph-shapes

   A ``Morph`` object is a new shape representing an animation between two
   polygonal shapes. To morph between two shapes, create two ``RoundedPolygons``
   and a ``Morph`` object that takes these two shapes. To calculate a shape
   between the start and end shapes, provide a ``progress`` value between zero
   and one to determine its form between the starting (0) and ending (1) shapes:

   .. code:: prettyprint

      Box(
          modifier = Modifier
              .drawWithCache {
                  val triangle = RoundedPolygon(
                      numVertices = 3,
                      radius = size.minDimension / 2f,
                      centerX = size.width / 2f,
                      centerY = size.height / 2f,
                      rounding = CornerRounding(
                          size.minDimension / 10f,
                          smoothing = 0.1f
                      )
                  )
                  val square = RoundedPolygon(
                      numVertices = 4,
                      radius = size.minDimension / 2f,
                      centerX = size.width / 2f,
                      centerY = size.height / 2f
                  )

                  val morph = Morph(start = triangle, end = square)
                  val morphPath = morph
                      .toPath(progress = 0.5f).asComposePath()

                  onDrawBehind {
                      drawPath(morphPath, color = Color.Black)
                  }
              }
              .fillMaxSize()
      )ShapesSnippets.kt

   In the above example, the progress is exactly halfway between the two shapes
   (rounded triangle and a square), producing the following result:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/morph_between_two_shapes.png
      name: image-8
      :alt: 50% of the way between a rounded triangle and a square
      :width: 300px

      **Figure 8**. 50% of the way between a rounded triangle and a square.

   In most scenarios, morphing is done as part of an animation, and not just a
   static rendering. To animate between these two, you can use the standard
   `Animation APIs in Compose  <#introduction>`__ to
   change the progress value over time. For example, you can infinitely animate
   the morph between these two shapes as follows:

   .. code:: prettyprint

      val infiniteAnimation = rememberInfiniteTransition(label = "infinite animation")
      val morphProgress = infiniteAnimation.animateFloat(
          initialValue = 0f,
          targetValue = 1f,
          animationSpec = infiniteRepeatable(
              tween(500),
              repeatMode = RepeatMode.Reverse
          ),
          label = "morph"
      )
      Box(
          modifier = Modifier
              .drawWithCache {
                  val triangle = RoundedPolygon(
                      numVertices = 3,
                      radius = size.minDimension / 2f,
                      centerX = size.width / 2f,
                      centerY = size.height / 2f,
                      rounding = CornerRounding(
                          size.minDimension / 10f,
                          smoothing = 0.1f
                      )
                  )
                  val square = RoundedPolygon(
                      numVertices = 4,
                      radius = size.minDimension / 2f,
                      centerX = size.width / 2f,
                      centerY = size.height / 2f
                  )

                  val morph = Morph(start = triangle, end = square)
                  val morphPath = morph
                      .toPath(progress = morphProgress.value)
                      .asComposePath()

                  onDrawBehind {
                      drawPath(morphPath, color = Color.Black)
                  }
              }
              .fillMaxSize()
      )ShapesSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/infinite_morph_polygon.gif
      name: image-9
      :alt: Infinitely morphing between a square and a rounded triangle
      :width: 300px

      **Figure 9**. Infinitely morphing between a square and a rounded triangle.

   .. rubric:: Use polygon as clip
      :name: use-polygon

   It's common to use the
   `clip  <#clip>`__
   modifier in Compose to change how a composable is rendered, and to take
   advantage of shadows that draw around the clipping area:

   .. code:: prettyprint

      fun RoundedPolygon.getBounds() = calculateBounds().let { Rect(it[0], it[1], it[2], it[3]) }
      class RoundedPolygonShape(
          private val polygon: RoundedPolygon,
          private var matrix: Matrix = Matrix()
      ) : Shape {
          private var path = Path()
          override fun createOutline(
              size: Size,
              layoutDirection: LayoutDirection,
              density: Density
          ): Outline {
              path.rewind()
              path = polygon.toPath().asComposePath()
              matrix.reset()
              val bounds = polygon.getBounds()
              val maxDimension = max(bounds.width, bounds.height)
              matrix.scale(size.width / maxDimension, size.height / maxDimension)
              matrix.translate(-bounds.left, -bounds.top)

              path.transform(matrix)
              return Outline.Generic(path)
          }
      }ShapesSnippets.kt

   You can then use the polygon as a clip, as shown in the following snippet:

   .. code:: prettyprint

      val hexagon = remember {
          RoundedPolygon(
              6,
              rounding = CornerRounding(0.2f)
          )
      }
      val clip = remember(hexagon) {
          RoundedPolygonShape(polygon = hexagon)
      }
      Box(
          modifier = Modifier
              .clip(clip)
              .background(MaterialTheme.colorScheme.secondary)
              .size(200.dp)
      ) {
          Text(
              "Hello Compose",
              color = MaterialTheme.colorScheme.onSecondary,
              modifier = Modifier.align(Alignment.Center)
          )
      }ShapesSnippets.kt

   This results in the following:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/polygon_clip.png
      name: image-10
      :alt: Hexagon with the text \`hello compose\` in the center.
      :width: 300px

      **Figure 10**. Hexagon with the text "Hello Compose" in the center.

   This may not look that different from what was rendering before, but it
   allows for leveraging other features in Compose. For example, this technique
   can be used to clip an image and apply a shadow around the clipped region:

   .. code:: prettyprint

      val hexagon = remember {
          RoundedPolygon(
              6,
              rounding = CornerRounding(0.2f)
          )
      }
      val clip = remember(hexagon) {
          RoundedPolygonShape(polygon = hexagon)
      }
      Box(
          modifier = Modifier.fillMaxSize(),
          contentAlignment = Alignment.Center
      ) {
          Image(
              painter = painterResource(id = R.drawable.dog),
              contentDescription = "Dog",
              contentScale = ContentScale.Crop,
              modifier = Modifier
                  .graphicsLayer {
                      this.shadowElevation = 6.dp.toPx()
                      this.shape = clip
                      this.clip = true
                      this.ambientShadowColor = Color.Black
                      this.spotShadowColor = Color.Black
                  }
                  .size(200.dp)

          )
      }ShapesSnippets.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/clip_with_shadow.png
      name: image-11
      :alt: Dog in hexagon with shadow applied around the edges
      :width: 300px

      **Figure 11**. Custom shape applied as clip.

   .. rubric:: Morph button on click
      :name: morph-button

   You can use the ``graphics-shape`` library to create a button that morphs
   between two shapes on press. First, create a ``MorphPolygonShape`` that
   extends ``Shape``, scaling and translating it to fit appropriately. Note the
   passing in of the progress so that the shape can be animated:

   .. code:: prettyprint

      class MorphPolygonShape(
          private val morph: Morph,
          private val percentage: Float
      ) : Shape {

          private val matrix = Matrix()
          override fun createOutline(
              size: Size,
              layoutDirection: LayoutDirection,
              density: Density
          ): Outline {
              // Below assumes that you haven't changed the default radius of 1f, nor the centerX and centerY of 0f
              // By default this stretches the path to the size of the container, if you don't want stretching, use the same size.width for both x and y.
              matrix.scale(size.width / 2f, size.height / 2f)
              matrix.translate(1f, 1f)

              val path = morph.toPath(progress = percentage).asComposePath()
              path.transform(matrix)
              return Outline.Generic(path)
          }
      }
      ShapesSnippets.kt

   To use this morph shape, create two polygons, ``shapeA`` and ``shapeB``.
   Create and remember the ``Morph``. Then, apply the morph to the button as a
   clip outline, using the ``interactionSource`` on press as the driving force
   behind the animation:

   .. code:: prettyprint

      val shapeA = remember {
          RoundedPolygon(
              6,
              rounding = CornerRounding(0.2f)
          )
      }
      val shapeB = remember {
          RoundedPolygon.star(
              6,
              rounding = CornerRounding(0.1f)
          )
      }
      val morph = remember {
          Morph(shapeA, shapeB)
      }
      val interactionSource = remember {
          MutableInteractionSource()
      }
      val isPressed by interactionSource.collectIsPressedAsState()
      val animatedProgress = animateFloatAsState(
          targetValue = if (isPressed) 1f else 0f,
          label = "progress",
          animationSpec = spring(dampingRatio = 0.4f, stiffness = Spring.StiffnessMedium)
      )
      Box(
          modifier = Modifier
              .size(200.dp)
              .padding(8.dp)
              .clip(MorphPolygonShape(morph, animatedProgress.value))
              .background(Color(0xFF80DEEA))
              .size(200.dp)
              .clickable(interactionSource = interactionSource, indication = null) {
              }
      ) {
          Text("Hello", modifier = Modifier.align(Alignment.Center))
      }ShapesSnippets.kt

   This results in the following animation when the box is tapped:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/morph_click.gif
      name: image-12
      :alt: Morph applied as a click between two shapes
      :width: 300px

      **Figure 12**. Morph applied as a click between two shapes.

   .. rubric:: Animate shape morphing infinitely
      :name: animate-shape

   To endlessly animate a morph shape, use
   `rememberInfiniteTransition  <#rememberinfinitetransition>`__.
   Below is an example of a profile picture that changes shape (and rotates)
   infinitely over time. This approach uses a small adjustment to the
   ``MorphPolygonShape`` shown above:

   .. code:: prettyprint

      class CustomRotatingMorphShape(
          private val morph: Morph,
          private val percentage: Float,
          private val rotation: Float
      ) : Shape {

          private val matrix = Matrix()
          override fun createOutline(
              size: Size,
              layoutDirection: LayoutDirection,
              density: Density
          ): Outline {
              // Below assumes that you haven't changed the default radius of 1f, nor the centerX and centerY of 0f
              // By default this stretches the path to the size of the container, if you don't want stretching, use the same size.width for both x and y.
              matrix.scale(size.width / 2f, size.height / 2f)
              matrix.translate(1f, 1f)
              matrix.rotateZ(rotation)

              val path = morph.toPath(progress = percentage).asComposePath()
              path.transform(matrix)

              return Outline.Generic(path)
          }
      }

      @Preview
      @Composable
      private fun RotatingScallopedProfilePic() {
          val shapeA = remember {
              RoundedPolygon(
                  12,
                  rounding = CornerRounding(0.2f)
              )
          }
          val shapeB = remember {
              RoundedPolygon.star(
                  12,
                  rounding = CornerRounding(0.2f)
              )
          }
          val morph = remember {
              Morph(shapeA, shapeB)
          }
          val infiniteTransition = rememberInfiniteTransition("infinite outline movement")
          val animatedProgress = infiniteTransition.animateFloat(
              initialValue = 0f,
              targetValue = 1f,
              animationSpec = infiniteRepeatable(
                  tween(2000, easing = LinearEasing),
                  repeatMode = RepeatMode.Reverse
              ),
              label = "animatedMorphProgress"
          )
          val animatedRotation = infiniteTransition.animateFloat(
              initialValue = 0f,
              targetValue = 360f,
              animationSpec = infiniteRepeatable(
                  tween(6000, easing = LinearEasing),
                  repeatMode = RepeatMode.Reverse
              ),
              label = "animatedMorphProgress"
          )
          Box(
              modifier = Modifier.fillMaxSize(),
              contentAlignment = Alignment.Center
          ) {
              Image(
                  painter = painterResource(id = R.drawable.dog),
                  contentDescription = "Dog",
                  contentScale = ContentScale.Crop,
                  modifier = Modifier
                      .clip(
                          CustomRotatingMorphShape(
                              morph,
                              animatedProgress.value,
                              animatedRotation.value
                          )
                      )
                      .size(200.dp)
              )
          }
      }ShapesSnippets.kt

   This code gives the following fun result:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/shape_rotation.gif
      name: image-13
      :alt: Heart shape
      :width: 300px

      **Figure 13**. Profile picture that is clipped by a rotating scalloped
      shape.

   .. rubric:: Custom polygons
      :name: custom-polygons

   If shapes created from regular polygons don't cover your use case, you can
   create a more custom shape with a list of vertices. For example, you may want
   to create a heart shape like this:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/heart_shape.png
      name: image-14
      :alt: Heart shape
      :width: 300px

      **Figure 14**. Heart shape.

   You can specify the individual vertices of this shape using the
   ``RoundedPolygon`` overload that takes a float array of x, y coordinates.

   To break down the heart polygon, notice that the polar coordinate system for
   specifying points makes this easier than using the cartesian (x,y) coordinate
   system, where ``0°`` starts on the right hand side, and proceeds clockwise,
   with ``270°`` at the 12 o'clock position:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/heart_shape_coordinates.png
      name: image-15
      :alt: Heart shape
      :width: 300px

      **Figure 15**. Heart shape with coordinates.

   The shape can now be defined in an easier way by specifying the angle (𝜭) and
   radius from the center at each point:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/heart_no_rounding.png
      name: image-16
      :alt: Heart shape
      :width: 300px

      **Figure 16**. Heart shape with coordinates, without rounding.

   The vertices can now be created and passed to the ``RoundedPolygon``
   function:

   .. code:: prettyprint

      val vertices = remember {
          val radius = 1f
          val radiusSides = 0.8f
          val innerRadius = .1f
          floatArrayOf(
              radialToCartesian(radiusSides, 0f.toRadians()).x,
              radialToCartesian(radiusSides, 0f.toRadians()).y,
              radialToCartesian(radius, 90f.toRadians()).x,
              radialToCartesian(radius, 90f.toRadians()).y,
              radialToCartesian(radiusSides, 180f.toRadians()).x,
              radialToCartesian(radiusSides, 180f.toRadians()).y,
              radialToCartesian(radius, 250f.toRadians()).x,
              radialToCartesian(radius, 250f.toRadians()).y,
              radialToCartesian(innerRadius, 270f.toRadians()).x,
              radialToCartesian(innerRadius, 270f.toRadians()).y,
              radialToCartesian(radius, 290f.toRadians()).x,
              radialToCartesian(radius, 290f.toRadians()).y,
          )
      }ShapesSnippets.kt

   The vertices need to be translated into cartesian coordinates using this
   ``radialToCartesian`` function:

   .. code:: prettyprint

      internal fun Float.toRadians() = this * PI.toFloat() / 180f

      internal val PointZero = PointF(0f, 0f)
      internal fun radialToCartesian(
          radius: Float,
          angleRadians: Float,
          center: PointF = PointZero
      ) = directionVectorPointF(angleRadians) * radius + center

      internal fun directionVectorPointF(angleRadians: Float) =
          PointF(cos(angleRadians), sin(angleRadians))ShapesSnippets.kt

   The preceding code gives you the raw vertices for the heart, but you need to
   round specific corners to get the chosen heart shape. The corners at ``90°``
   and ``270°`` have no rounding, but the other corners do. To achieve custom
   rounding for individual corners, use the ``perVertexRounding`` parameter:

   .. code:: prettyprint

      val rounding = remember {
          val roundingNormal = 0.6f
          val roundingNone = 0f
          listOf(
              CornerRounding(roundingNormal),
              CornerRounding(roundingNone),
              CornerRounding(roundingNormal),
              CornerRounding(roundingNormal),
              CornerRounding(roundingNone),
              CornerRounding(roundingNormal),
          )
      }

      val polygon = remember(vertices, rounding) {
          RoundedPolygon(
              vertices = vertices,
              perVertexRounding = rounding
          )
      }
      Box(
          modifier = Modifier
              .drawWithCache {
                  val roundedPolygonPath = polygon.toPath().asComposePath()
                  onDrawBehind {
                      scale(size.width * 0.5f, size.width * 0.5f) {
                          translate(size.width * 0.5f, size.height * 0.5f) {
                              drawPath(roundedPolygonPath, color = Color(0xFFF15087))
                          }
                      }
                  }
              }
              .size(400.dp)
      )ShapesSnippets.kt

   This results in the pink heart:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/graphics/shapes/heart_shape.png
      name: image-17
      :alt: Heart shape
      :width: 300px

      **Figure 17**. Heart shape result.

   If the preceding shapes don't cover your use case, consider using the
   ``Path`` class to `draw a custom shape  <#draw-path>`__, or loading
   up an
   `ImageVector  <#image-vector>`__
   file from disk. The ``graphics-shapes`` library is not intended for use for
   arbitrary shapes, but is specifically meant to simplify creation of rounded
   polygons and morph animations between them.

   .. rubric:: Additional resources
      :name: additional-resources

   For more information and examples, see the following resources:

   -  `Blog: The Shape of Things to Come - Shapes <https://medium.com/androiddevelopers/the-shape-of-things-to-come-1c7663d9dbc0>`__
   -  `Blog: Shape morphing in Android <https://medium.com/androiddevelopers/shape-morphing-in-android-f5c36416a979>`__
   -  `Shapes Github demonstration <https://github.com/chethaase/ShapesDemo>`__

Last updated 2024-05-03 UTC.

/Overview: Animation
====================

.. https://developer.android.google.cn/develop/ui/compose/animation/introduction?hl=en

.. container:: devsite-article-body clearfix

   .. container:: section

      .. rubric:: `Animations in Compose <https://developer.android.google.cn/develop/ui/compose/animation/quick-guide>`__
         :name: animations-in-compose

         Animations are essential in a modern mobile app in order
         to realize a smooth and understandable user experience.

         `Quick guide <https://developer.android.google.cn/develop/ui/compose/animation/quick-guide>`__

   .. container:: section

      .. rubric:: Animation modifiers and composables
         :name: animation-modifiers-and-composables

         .. container:: float devsite-landing-row-item-image

            |image-animated_visibility_column|

            .. rubric:: `Animate appearance and disappearance <https://developer.android.google.cn/develop/ui/compose/animation/composables-modifiers#animatedvisibility>`__
               :name: animate-appearance-and-disappearance

               The ``AnimatedVisibility`` composable allows you to hide or show content easily.

               `Learn more <https://developer.android.google.cn/develop/ui/compose/animation/composables-modifiers#animatedvisibility>`__

         .. container:: float devsite-landing-row-item-image

            |image-animated_content_size|

            .. rubric:: `Animate content size changes <https://developer.android.google.cn/develop/ui/compose/animation/composables-modifiers#animateContentSize>`__
               :name: animate-content-size-changes

               Use ``animateContentSize()`` to achieve automatic size change animations.

               `Learn more <https://developer.android.google.cn/develop/ui/compose/animation/composables-modifiers#animateContentSize>`__

         .. container:: float devsite-landing-row-item-image

            |image-animated_content_slower|

            .. rubric:: `Animate between different composables <https://developer.android.google.cn/develop/ui/compose/animation/composables-modifiers#animatedcontent>`__
               :name: animate-between-different-composables

               Use ``AnimatedContent`` to animate between composables that have different content.

               `Learn more <https://developer.android.google.cn/develop/ui/compose/animation/composables-modifiers#animatedcontent>`__

   .. container:: section

      .. rubric:: Value-based animations
         :name: value-based-animations

         .. container:: float devsite-landing-row-item-image

            |image-animated_padding|

            .. rubric:: `Animate a single value <https://developer.android.google.cn/develop/ui/compose/animation/value-based#animate-as-state>`__
               :name: animate-a-single-value

               Use ``animate*AsState`` functions to animate an individual property, such as opacity.

               `Learn more <https://developer.android.google.cn/develop/ui/compose/animation/value-based#animate-as-state>`__

         .. container:: float devsite-landing-row-item-image

            |image-multiple_properties|

            .. rubric:: `Animate multiple values together <https://developer.android.google.cn/develop/ui/compose/animation/quick-guide#concurrent-animations>`__
               :name: animate-multiple-values-together

               Use ``Transition`` to animate multiple values at once.

               `Learn more <https://developer.android.google.cn/develop/ui/compose/animation/quick-guide#concurrent-animations>`__

         .. container:: float devsite-landing-row-item-image

            |image-animated_forever|

            .. rubric:: `Animate properties indefinitely <https://developer.android.google.cn/develop/ui/compose/animation/value-based#rememberinfinitetransition>`__
               :name: animate-properties-indefinitely

               Use ``InfiniteTransition`` to animate properties continuously.

               `Learn more <https://developer.android.google.cn/develop/ui/compose/animation/value-based#rememberinfinitetransition>`__

   .. container:: section


      |image-interoperable|

      .. rubric:: `Customize your animations <https://developer.android.google.cn/develop/ui/compose/animation/customize>`__
         :name: customize-your-animations

         Learn how to customize your animations duration, easing
         curve and spring configuration.

         `Customize <https://developer.android.google.cn/develop/ui/compose/animation/customize>`__


      |image-bug-2|

      .. rubric:: `Test animations <https://developer.android.google.cn/develop/ui/compose/animation/testing>`__
         :name: test-animations

         Learn how to write tests for your animations.

         `Testing <https://developer.android.google.cn/develop/ui/compose/animation/testing>`__


      |image-spanner|

      .. rubric:: `Android Studio Tooling <https://developer.android.google.cn/develop/ui/compose/animation/tooling>`__
         :name: android-studio-tooling

         Learn all about how to preview your animations in
         Android Studio.

         `Tooling <https://developer.android.google.cn/develop/ui/compose/animation/tooling>`__

Last updated 2024-04-15 UTC.

.. |image-animated_visibility_column| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_visibility_column.gif
   :target: https://developer.android.google.cn/develop/ui/compose/animation/composables-modifiers#animatedvisibility
.. |image-animated_content_size| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_content_size.gif
   :target: https://developer.android.google.cn/develop/ui/compose/animation/composables-modifiers#animateContentSize
.. |image-animated_content_slower| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_content_slower.gif
   :target: https://developer.android.google.cn/develop/ui/compose/animation/composables-modifiers#animatedcontent
.. |image-animated_padding| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_padding.gif
   :target: https://developer.android.google.cn/develop/ui/compose/animation/value-based#animate-as-state
.. |image-multiple_properties| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/multiple_properties.gif
   :target: https://developer.android.google.cn/develop/ui/compose/animation/quick-guide#concurrent-animations
.. |image-animated_forever| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_forever.gif
   :target: https://developer.android.google.cn/develop/ui/compose/animation/value-based#rememberinfinitetransition
.. |image-interoperable| image:: https://developer.android.google.cn/static/images/picto-icons/interoperable.svg
.. |image-bug-2| image:: https://developer.android.google.cn/static/images/picto-icons/bug-2.svg
.. |image-spanner| image:: https://developer.android.google.cn/static/images/picto-icons/spanner.svg

/Choose an animation API
========================

.. https://developer.android.google.cn/develop/ui/compose/animation/choose-api?hl=en

.. container:: devsite-article-body clearfix

   The diagram below helps you decide what API to use to implement your
   animation.

   |Flowchart describing the decision tree for choosing the appropriate
   animation API|

   |image-compose_animation_decision_tree_v2| 

   **Figure 1.** Decision tree describing how to choose the appropriate animation API

   Follow the decision tree questions below to choose which animation API is
   most appropriate for your use case:

   -  Is my animation more like art, consisting of many visual elements? i.e.
      SVGs or images

      -  Yes: Does it have simple SVGs? i.e. an icon with micro-animations

         -  Yes:
            `AnimatedVectorDrawable  <#avd>`__
         -  No: Third-party animation framework, i.e.
            `Lottie <https://airbnb.design/lottie/>`__

      -  No: Does it need to repeat forever?

         -  Yes:
            `rememberInfiniteTransition  <#rememberinfinitetransition>`__
         -  No: Is this a layout animation?

            -  Yes: Changing between multiple composables that have different
               content?

               -  Yes: With navigation-compose?

                  -  Yes:
                     `composable()  <#composable>`__
                     with\ ``enterTransition`` and ``exitTransition`` set
                  -  No:
                     `AnimatedContent  <#animatedcontent>`__,
                     `Crossfade  <#crossfade>`__
                     or `Pager  <#pager>`__

               -  No: Animating appearance / disappearance?

                  -  Yes:
                     `AnimatedVisibility  <#animatedvisibility>`__
                     or
                     `animateFloatAsState  <#animate-as-state>`__
                     with ``Modifier.alpha()``
                  -  No: Animating size?

                     -  Yes:
                        `Modifier.animateContentSize  <#animatedContentSize>`__
                     -  No: Other layout property? ie offset, padding etc

                        -  Yes: See "Are the properties completely independent
                           of each other?"
                        -  No: List item animations?

                           -  Yes:
                              `animateItemPlacement()  <#item-animations>`__
                              (reorder and delete coming soon)

            -  No: Do you need to animate multiple properties?

               -  Yes: Are the properties completely independent of each other?

                  -  Yes:
                     `animate*AsState  <#animate-as-state>`__,
                     for Text, use
                     `TextMotion.Animated  <#Animated>`__
                  -  No: Start at the same time?

                     -  Yes: Yes:
                        `updateTransition  <#updatetransition>`__
                        with ``AnimatedVisibility``, ``animateFloat``,
                        ``animateInt`` etc
                     -  No:
                        `Animatable  <#animatable>`__
                        with ``animateTo`` called with different timings (using
                        suspend functions)

               -  No: Does the animation have a set of predefined target values?

                  -  Yes:
                     `animate*AsState  <#animate-as-state>`__,
                     for Text, use ``TextMotion.Animated``
                  -  No: Gesture driven animation? Your animation is the only
                     source of truth?

                     -  Yes: ``Animatable`` with ``animateTo`` / ``snapTo``
                     -  No: One shot animation without state management?

                        -  Yes:
                           `AnimationState  <#AnimationState>`__
                           or
                           `animate  <#animate>`__
                        -  No: Answer not here? `File a feature request <https://goo.gle/compose-feedback>`__

   Download the `PDF version of the diagram  <#compose_animation_decision_tree_v2.pdf>`__.

Last updated 2024-05-03 UTC.

.. |Flowchart describing the decision tree for choosing the appropriate animation API| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/compose_animation_decision_tree_v2.jpg
.. |image-compose_animation_decision_tree_v2| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/compose_animation_decision_tree_v2.jpg

/Quick guide
============

.. https://developer.android.google.cn/develop/ui/compose/animation/quick-guide?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   Compose has many built-in animation mechanisms and it can be overwhelming to
   know which one to choose. Below is a list of common animation use cases. For
   more detailed information about the full set of different API options
   available to you, read the full `Compose Animation documentation  <#animation>`__.

   .. rubric:: Animate common composable properties
      :name: animate-common-properties

   Compose provides convenient APIs that allow you to solve for many common
   animation use cases. This section demonstrates how you can animate common
   properties of a composable.

   .. rubric:: Animate appearing / disappearing
      :name: animate-appearing-disappearing

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_visibility_column.gif
      name: image-1
      :alt: Green composable showing and hiding itself
      :width: 100.0%

      **Figure 1.** Animating the appearance and disappearance of an item in a
      Column

   Use
   `AnimatedVisibility  <#animatedvisibility>`__
   to hide or show a Composable. Children inside ``AnimatedVisibility`` can use
   ``Modifier.animateEnterExit()`` for their own enter or exit transition.

   .. code:: prettyprint

      var visible by remember {
          mutableStateOf(true)
      }
      // Animated visibility will eventually remove the item from the composition once the animation has finished.
      AnimatedVisibility(visible) {
          // your composable here
          // ...
      }AnimationQuickGuide.kt

   The enter and exit parameters of ``AnimatedVisibility`` allow you to
   configure how a composable behaves when it appears and disappears. Read the
   `full documentation  <#animatedvisibility>`__
   for more information.

   Another option for animating the visibility of a composable is to animate the
   alpha over time using
   `animateFloatAsState  <#animate-as-state>`__:

   .. code:: prettyprint

      var visible by remember {
          mutableStateOf(true)
      }
      val animatedAlpha by animateFloatAsState(
          targetValue = if (visible) 1.0f else 0f,
          label = "alpha"
      )
      Box(
          modifier = Modifier
              .size(200.dp)
              .graphicsLayer {
                  alpha = animatedAlpha
              }
              .clip(RoundedCornerShape(8.dp))
              .background(colorGreen)
              .align(Alignment.TopCenter)
      ) {
      }AnimationQuickGuide.kt

   However, changing the alpha comes with the caveat that the composable
   **remains in the composition** and continues to occupy the space it's laid
   out in. This could cause screen readers and other accessibility mechanisms to
   still consider the item on screen. On the other hand, ``AnimatedVisibility``
   eventually removes the item from the composition.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_visibility_alpha.gif
      name: image-2
      :alt: Animating the alpha of a composable
      :width: 100.0%

      **Figure 2.** Animating the alpha of a composable

   .. rubric:: Animate background color
      :name: animate-background

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_forever.gif
      name: image-3
      :alt: Composable with background color changing over time as an animation,
      where the colors are fading into one another.
      :width: 100.0%

      **Figure 3.** Animating background color of composable

   .. code:: prettyprint

      val animatedColor by animateColorAsState(
          if (animateBackgroundColor) colorGreen else colorBlue,
          label = "color"
      )
      Column(
          modifier = Modifier.drawBehind {
              drawRect(animatedColor)
          }
      ) {
          // your composable here
      }AnimationQuickGuide.kt

   This option is more performant than using ``Modifier.background()``.
   ``Modifier.background()`` is acceptable for a one-shot color setting, but
   when animating a color over time, this could cause more recompositions than
   necessary.

   For infinitely animating the background color, see `repeating an animation section <#repeat-animation>`__.

   .. rubric:: Animate the size of a composable
      :name: animate-size

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_content_size.gif
      name: image-4
      :alt: Green composable animating its size change smoothly.
      :width: 100.0%

      **Figure 4.** Composable smoothly animating between a small and a larger
      size

   Compose lets you animate the size of composables in a few different ways. Use
   `animateContentSize()  <#animateContentSize>`__
   for animations between composable size changes.

   For example, if you have a box that contains text which can expand from one
   to multiple lines you can use ``Modifier.animateContentSize()`` to achieve a
   smoother transition:

   .. code:: prettyprint

      var expanded by remember { mutableStateOf(false) }
      Box(
          modifier = Modifier
              .background(colorBlue)
              .animateContentSize()
              .height(if (expanded) 400.dp else 200.dp)
              .fillMaxWidth()
              .clickable(
                  interactionSource = remember { MutableInteractionSource() },
                  indication = null
              ) {
                  expanded = !expanded
              }

      ) {
      }AnimationQuickGuide.kt

   **Note:**\  `Ordering of the modifiers  <#order-modifier-matters>`__ matters
   here. Make sure to place it **before** any size modifiers.
   You can also use
   `AnimatedContent  <#animatedcontent>`__,
   with a
   `SizeTransform  <#SizeTransform>`__
   to describe how size changes should take place.

   .. rubric:: Animate position of composable
      :name: animate-position

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_offset.gif
      name: image-5
      :alt: Green composable smoothly animating down and to the right
      :width: 100.0%

      **Figure 5.** Composable moving by an offset

   To animate the position of a composable, use ``Modifier.offset{ }`` combined
   with ``animateIntOffsetAsState()``.

   .. code:: prettyprint

      var moved by remember { mutableStateOf(false) }
      val pxToMove = with(LocalDensity.current) {
          100.dp.toPx().roundToInt()
      }
      val offset by animateIntOffsetAsState(
          targetValue = if (moved) {
              IntOffset(pxToMove, pxToMove)
          } else {
              IntOffset.Zero
          },
          label = "offset"
      )

      Box(
          modifier = Modifier
              .offset {
                  offset
              }
              .background(colorBlue)
              .size(100.dp)
              .clickable(
                  interactionSource = remember { MutableInteractionSource() },
                  indication = null
              ) {
                  moved = !moved
              }
      )AnimationQuickGuide.kt

   **Caution:**\  This does not change where the parent perceives the composable
   to be placed, and therefore does not affect where siblings are placed. This
   may result in siblings drawing over or under one another. The offset only
   influences the position of child layouts of the ``Modifier.offset{}``.
   If you want to ensure that composables are not drawn over or under other
   composables when animating position or size, use ``Modifier.layout{ }``. This
   modifier propagates size and position changes to the parent, which then
   affects other children.

   For example, if you are moving a ``Box`` within a ``Column`` and the other
   children need to move when the ``Box`` moves, include the offset information
   with ``Modifier.layout{ }`` as follows:

   .. code:: prettyprint

      var toggled by remember {
          mutableStateOf(false)
      }
      val interactionSource = remember {
          MutableInteractionSource()
      }
      Column(
          modifier = Modifier
              .padding(16.dp)
              .fillMaxSize()
              .clickable(indication = null, interactionSource = interactionSource) {
                  toggled = !toggled
              }
      ) {
          val offsetTarget = if (toggled) {
              IntOffset(150, 150)
          } else {
              IntOffset.Zero
          }
          val offset = animateIntOffsetAsState(
              targetValue = offsetTarget, label = "offset"
          )
          Box(
              modifier = Modifier
                  .size(100.dp)
                  .background(colorBlue)
          )
          Box(
              modifier = Modifier
                  .layout { measurable, constraints ->
                      val offsetValue = if (isLookingAhead) offsetTarget else offset.value
                      val placeable = measurable.measure(constraints)
                      layout(placeable.width + offsetValue.x, placeable.height + offsetValue.y) {
                          placeable.placeRelative(offsetValue)
                      }
                  }
                  .size(100.dp)
                  .background(colorGreen)
          )
          Box(
              modifier = Modifier
                  .size(100.dp)
                  .background(colorBlue)
          )
      }AnimationQuickGuide.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_layout_modifier.gif
      name: image-6
      :alt: 2 boxes with the 2nd box animating its X,Y position, the third box
      responding by moving itself by Y amount too.
      :width: 100.0%

      **Figure 6.** Animating with ``Modifier.layout{ }``

   .. rubric:: Animate padding of a composable
      :name: animate-padding

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_padding.gif
      name: image-7
      :alt: Green composable getting smaller and bigger on click, with padding
      being animated
      :width: 100.0%

      **Figure 7.** Composable with its padding animating

   To animate the padding of a composable, use ``animateDpAsState`` combined
   with ``Modifier.padding()``:

   .. code:: prettyprint

      var toggled by remember {
          mutableStateOf(false)
      }
      val animatedPadding by animateDpAsState(
          if (toggled) {
              0.dp
          } else {
              20.dp
          },
          label = "padding"
      )
      Box(
          modifier = Modifier
              .aspectRatio(1f)
              .fillMaxSize()
              .padding(animatedPadding)
              .background(Color(0xff53D9A1))
              .clickable(
                  interactionSource = remember { MutableInteractionSource() },
                  indication = null
              ) {
                  toggled = !toggled
              }
      )AnimationQuickGuide.kt

   .. rubric:: Animate elevation of a composable
      :name: animate-elevation

   .. container:: float
      :name: image-8

      .. container::

         **Figure 8.** Composable's elevation animating on click

   To animate the elevation of a composable, use ``animateDpAsState`` combined
   with ``Modifier.graphicsLayer{ }``. For once-off elevation changes, use
   ``Modifier.shadow()``. If you are animating the shadow, using
   ``Modifier.graphicsLayer{ }`` modifier is the more performant option.

   .. code:: prettyprint

      val mutableInteractionSource = remember {
          MutableInteractionSource()
      }
      val pressed = mutableInteractionSource.collectIsPressedAsState()
      val elevation = animateDpAsState(
          targetValue = if (pressed.value) {
              32.dp
          } else {
              8.dp
          },
          label = "elevation"
      )
      Box(
          modifier = Modifier
              .size(100.dp)
              .align(Alignment.Center)
              .graphicsLayer {
                  this.shadowElevation = elevation.value.toPx()
              }
              .clickable(interactionSource = mutableInteractionSource, indication = null) {
              }
              .background(colorGreen)
      ) {
      }AnimationQuickGuide.kt

   Alternatively, use the
   `Card  <#Card>`__
   composable, and set the elevation property to different values per state.

   .. rubric:: Animate text scale, translation or rotation
      :name: animate-text-scale

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_text.gif
      name: image-9
      :alt: Text composable saying
      :width: 100.0%

      **Figure 9.** Text animating smoothly between two sizes

   When animating scale, translation, or rotation of text, set the
   ``textMotion`` parameter on ``TextStyle`` to
   `TextMotion.Animated  <#TextMotion>`__.
   This ensures smoother transitions between text animations. Use
   `Modifier.graphicsLayer{ }  <#graphicsLayer>`__
   to translate, rotate or scale the text.

   .. code:: prettyprint

      val infiniteTransition = rememberInfiniteTransition(label = "infinite transition")
      val scale by infiniteTransition.animateFloat(
          initialValue = 1f,
          targetValue = 8f,
          animationSpec = infiniteRepeatable(tween(1000), RepeatMode.Reverse),
          label = "scale"
      )
      Box(modifier = Modifier.fillMaxSize()) {
          Text(
              text = "Hello",
              modifier = Modifier
                  .graphicsLayer {
                      scaleX = scale
                      scaleY = scale
                      transformOrigin = TransformOrigin.Center
                  }
                  .align(Alignment.Center),
              // Text composable does not take TextMotion as a parameter.
              // Provide it via style argument but make sure that we are copying from current theme
              style = LocalTextStyle.current.copy(textMotion = TextMotion.Animated)
          )
      }
      AnimationQuickGuide.kt

   .. rubric:: Animate text color
      :name: animate-text-color

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_text_color.gif
      name: image-10
      :alt: The words
      :width: 100.0%

      **Figure 10.** Example showing animating text color

   To animate text color, use the ``color`` lambda on the ``BasicText``
   composable:

   .. code:: prettyprint

      val infiniteTransition = rememberInfiniteTransition(label = "infinite transition")
      val animatedColor by infiniteTransition.animateColor(
          initialValue = Color(0xFF60DDAD),
          targetValue = Color(0xFF4285F4),
          animationSpec = infiniteRepeatable(tween(1000), RepeatMode.Reverse),
          label = "color"
      )

      BasicText(
          text = "Hello Compose",
          color = {
              animatedColor
          },
          // ...
      )AnimationQuickGuide.kt

   .. rubric:: Switch between different types of content
      :name: switch-different

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_content_slower.gif
      name: image-11
      :alt: Green screen saying
      :width: 100.0%

      **Figure 11.** Using AnimatedContent to animate changes between different
      composables (slowed down)

   Use
   `AnimatedContent  <#AnimatedContent>`__
   to animate between different composables, if you just want a standard fade
   between composables, use ``Crossfade``.

   .. code:: prettyprint

      var state by remember {
          mutableStateOf(UiState.Loading)
      }
      AnimatedContent(
          state,
          transitionSpec = {
              fadeIn(
                  animationSpec = tween(3000)
              ) togetherWith fadeOut(animationSpec = tween(3000))
          },
          modifier = Modifier.clickable(
              interactionSource = remember { MutableInteractionSource() },
              indication = null
          ) {
              state = when (state) {
                  UiState.Loading -> UiState.Loaded
                  UiState.Loaded -> UiState.Error
                  UiState.Error -> UiState.Loading
              }
          },
          label = "Animated Content"
      ) { targetState ->
          when (targetState) {
              UiState.Loading -> {
                  LoadingScreen()
              }
              UiState.Loaded -> {
                  LoadedScreen()
              }
              UiState.Error -> {
                  ErrorScreen()
              }
          }
      }AnimationQuickGuide.kt

   ``AnimatedContent`` can be customized to show many different kinds of enter
   and exit transitions. For more information, read the documentation on
   `AnimatedContent  <#animatedcontent>`__
   or read this `blog post on <https://medium.com/androiddevelopers/customizing-animatedcontent-in-jetpack-compose-629c67b45894>`__
   `AnimatedContent <https://medium.com/androiddevelopers/customizing-animatedcontent-in-jetpack-compose-629c67b45894>`__.

   .. rubric:: Animate whilst navigating to different destinations
      :name: animate-whilst

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/navigation_compose_animation.gif
      name: image-12
      :alt: Two composables, one green saying Landing and one blue saying
      Detail, animating by sliding the detail composable over the landing
      composable.
      :width: 100.0%

      **Figure 12.** Animating between composables using navigation-compose

   To animate transitions between composables when using the
   `navigation-compose  <#navigation>`__ artifact,
   specify the ``enterTransition`` and ``exitTransition`` on a composable. You
   can also set the default animation to be used for all destinations at the top
   level ``NavHost``:

   .. code:: prettyprint

      val navController = rememberNavController()
      NavHost(
          navController = navController, startDestination = "landing",
          enterTransition = { EnterTransition.None },
          exitTransition = { ExitTransition.None }
      ) {
          composable("landing") {
              ScreenLanding(
                  // ...
              )
          }
          composable(
              "detail/{photoUrl}",
              arguments = listOf(navArgument("photoUrl") { type = NavType.StringType }),
              enterTransition = {
                  fadeIn(
                      animationSpec = tween(
                          300, easing = LinearEasing
                      )
                  ) + slideIntoContainer(
                      animationSpec = tween(300, easing = EaseIn),
                      towards = AnimatedContentTransitionScope.SlideDirection.Start
                  )
              },
              exitTransition = {
                  fadeOut(
                      animationSpec = tween(
                          300, easing = LinearEasing
                      )
                  ) + slideOutOfContainer(
                      animationSpec = tween(300, easing = EaseOut),
                      towards = AnimatedContentTransitionScope.SlideDirection.End
                  )
              }
          ) { backStackEntry ->
              ScreenDetails(
                  // ...
              )
          }
      }AnimationQuickGuide.kt

   There are many different kinds of enter and exit transitions that apply
   different effects to the incoming and outgoing content, see the
   `documentation  <#enter-exit-transition>`__
   for more.

   **Note:**\  Enter and Exit transitions are only available from
   navigation-compose
   `2.7.0-alpha01  <#navigation-2.7.0-alpha01>`__.

   .. rubric:: Repeat an animation
      :name: repeat-animation

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_forever.gif
      name: image-13
      :alt: A green background that transforms into a blue background,
      infinitely by animating between the two colors.
      :width: 100.0%

      **Figure 13.** Background color animating between two values, infinitely

   Use
   `rememberInfiniteTransition  <#InfiniteTransition>`__
   with an ``infiniteRepeatable`` ``animationSpec`` to continuously repeat your
   animation. Change ``RepeatModes`` to specify how it should go back and forth.

   Use ``finiteRepeatable`` to repeat a set number of times.

   .. code:: prettyprint

      val infiniteTransition = rememberInfiniteTransition(label = "infinite")
      val color by infiniteTransition.animateColor(
          initialValue = Color.Green,
          targetValue = Color.Blue,
          animationSpec = infiniteRepeatable(
              animation = tween(1000, easing = LinearEasing),
              repeatMode = RepeatMode.Reverse
          ),
          label = "color"
      )
      Column(
          modifier = Modifier.drawBehind {
              drawRect(color)
          }
      ) {
          // your composable here
      }AnimationQuickGuide.kt

   .. rubric:: Start an animation on launch of a composable
      :name: start-animation

   `LaunchedEffect  <#launchedeffect>`__ runs
   when a composable enters the composition. It starts an animation on launch of
   a composable, you can use this to drive the animation state change. Using
   ``Animatable`` with the ``animateTo`` method to start the animation on
   launch:

   .. code:: prettyprint

      val alphaAnimation = remember {
          Animatable(0f)
      }
      LaunchedEffect(Unit) {
          alphaAnimation.animateTo(1f)
      }
      Box(
          modifier = Modifier.graphicsLayer {
              alpha = alphaAnimation.value
          }
      )AnimationQuickGuide.kt

   **Caution:**\  Be careful when using ``LaunchedEffects`` inside lazy layouts.
   They relaunch when the items re-enter the composition. For example, this can
   occur when scrolling the list offscreen and back on screen. Instead, `hoist your state  <#state-hoisting>`__ outside the lazy
   layout to ensure the animation doesn't happen for each scroll in and out of
   the composition.

   .. rubric:: Create sequential animations
      :name: sequential-animations

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/multiple_properties_sequential.gif
      name: image-14
      :alt: Four circles with green arrows animating between each one, animating
      one by one after one another.
      :width: 100.0%

      **Figure 14.** Diagram indicating how a sequential animation progresses,
      one by one.

   Use the ``Animatable`` coroutine APIs to perform sequential or concurrent
   animations. Calling ``animateTo`` on the ``Animatable`` one after the other
   causes each animation to wait for the previous animations to finish before
   proceeding . This is because it is a suspend function.

   .. code:: prettyprint

      val alphaAnimation = remember { Animatable(0f) }
      val yAnimation = remember { Animatable(0f) }

      LaunchedEffect("animationKey") {
          alphaAnimation.animateTo(1f)
          yAnimation.animateTo(100f)
          yAnimation.animateTo(500f, animationSpec = tween(100))
      }AnimationQuickGuide.kt

   .. rubric:: Create concurrent animations
      :name: concurrent-animations

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/multiple_properties.gif
      name: image-15
      :alt: Three circles with green arrows animating to each one, animating all
      together at the same time.
      :width: 100.0%

      **Figure 15.** Diagram indicating how concurrent animations progress, all
      at the same time.

   Use the coroutine APIs
   (`Animatable#animateTo()  <#animateTo>`__
   or
   `animate  <#animate>`__),
   or the
   `Transition  <#Transition>`__
   API to achieve concurrent animations. If you use multiple launch functions in
   a coroutine context, it launches the animations at the same time:

   .. code:: prettyprint

      val alphaAnimation = remember { Animatable(0f) }
      val yAnimation = remember { Animatable(0f) }

      LaunchedEffect("animationKey") {
          launch {
              alphaAnimation.animateTo(1f)
          }
          launch {
              yAnimation.animateTo(100f)
          }
      }AnimationQuickGuide.kt

   You could use the
   `updateTransition  <#updateTransition>`__
   API to use the same state to drive many different property animations at the
   same time. The example below animates two properties controlled by a state
   change, ``rect`` and ``borderWidth``:

   .. code:: prettyprint

      var currentState by remember { mutableStateOf(BoxState.Collapsed) }
      val transition = updateTransition(currentState, label = "transition")

      val rect by transition.animateRect(label = "rect") { state ->
          when (state) {
              BoxState.Collapsed -> Rect(0f, 0f, 100f, 100f)
              BoxState.Expanded -> Rect(100f, 100f, 300f, 300f)
          }
      }
      val borderWidth by transition.animateDp(label = "borderWidth") { state ->
          when (state) {
              BoxState.Collapsed -> 1.dp
              BoxState.Expanded -> 0.dp
          }
      }AnimationQuickGuide.kt

   .. rubric:: Optimize animation performance
      :name: optimize-performance

   Animations in Compose can cause performance problems. This is due to the
   nature of what an animation is: moving or changing pixels on screen quickly,
   frame-by-frame to create the illusion of movement.

   Consider the `different phases of Compose  <#phases>`__:
   composition, layout and draw. If your animation changes the layout phase, it
   requires all affected composables to relayout and redraw. If your animation
   occurs in the draw phase, it is by default be more performant than if you
   were to run the animation in the layout phase, as it would have less work to
   do overall.

   To ensure your app does as little as possible while animating, choose the
   lambda version of a ``Modifier`` where possible. This skips recomposition and
   performs the animation outside of the composition phase, otherwise use
   `Modifier.graphicsLayer{ }  <#modifiers>`__,
   as this modifier always runs in the draw phase. For more information on this,
   see the `deferring reads  <#defer-reads>`__ section
   in the performance documentation.

   .. rubric:: Change animation timing
      :name: animation-timing

   Compose by default uses **spring** animations for most animations. Springs,
   or physics-based animations, feel more natural. They are also interruptible
   as they take into account the object's current velocity, instead of a fixed
   time. If you want to override the default, all the animation APIs
   demonstrated above have the ability to set an ``animationSpec`` to customize
   how an animation runs, whether you'd like it to execute over a certain
   duration or be more bouncy.

   The following is a summary of the different ``animationSpec`` options:

   -  `spring  <#spring>`__:
      Physics-based animation, the default for all animations. You can change
      the stiffness or dampingRatio to achieve a different animation look and
      feel.
   -  `tween  <#tween>`__ (short for
      **between**): Duration-based animation, animates between two values with
      an ``Easing`` function.
   -  `keyframes  <#keyframes>`__:
      Spec for specifying values at certain key points in an animation.
   -  `repeatable  <#repeatable>`__:
      Duration-based spec that runs a certain number of times, specified by
      ``RepeatMode``.
   -  `infiniteRepeatable  <#infiniterepeatable>`__:
      Duration-based spec that runs forever.
   -  `snap  <#snap>`__: Instantly
      snaps to the end value without any animation.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_spec_set.gif
      name: image-16
      :alt: Write your alt text here
      :width: 100.0%

      **Figure 16.** No spec set vs Custom Spring spec set

   Read the full documentation for more information about
   `animationSpecs  <#animationspec>`__.

   .. rubric:: Additional resources
      :name: additional-resources

   For more examples of fun animations in Compose, take a look at the following:

   -  `5 quick animations in Compose <https://www.youtube.com/watch?v=0mfCbXrYBPE&t=2s&ab_channel=AndroidDevelopers>`__
   -  `Making Jellyfish move in Compose <https://medium.com/androiddevelopers/making-jellyfish-move-in-compose-animating-imagevectors-and-applying-agsl-rendereffects-3666596a8888>`__
   -  `Customizing ``AnimatedContent`` in
      Compose <https://medium.com/androiddevelopers/customizing-animatedcontent-in-jetpack-compose-629c67b45894>`__
   -  `Easing into Easing functions in Compose <https://medium.com/androiddevelopers/easing-in-to-easing-curves-in-jetpack-compose-d72893eeeb4d>`__

Last updated 2024-05-03 UTC.

/Animation modifiers and composables
====================================

.. https://developer.android.google.cn/develop/ui/compose/animation/composables-modifiers?hl=en

.. container:: devsite-article-body clearfix

   Compose comes with built-in composables and modifiers for handling common
   animation use cases.

   .. rubric:: Built-in animated composables
      :name: built-in_animated_composables

   .. rubric:: Animate appearance and disappearance with ``AnimatedVisibility``
      :name: animatedvisibility

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_visibility_column.gif
      name: image-1
      :alt: Green composable showing and hiding itself
      :width: 100.0%

      **Figure 1.** Animating the appearance and disappearance of an item in a
      column

   The
   `AnimatedVisibility  <#AnimatedVisibility>`__
   composable animates the appearance and disappearance of its content.

   .. code:: prettyprint

      var visible by remember {
          mutableStateOf(true)
      }
      // Animated visibility will eventually remove the item from the composition once the animation has finished.
      AnimatedVisibility(visible) {
          // your composable here
          // ...
      }AnimationQuickGuide.kt

   By default, the content appears by fading in and expanding, and it disappears
   by fading out and shrinking. The transition can be customized by specifying
   `EnterTransition  <#EnterTransition>`__
   and
   `ExitTransition  <#ExitTransition>`__.

   .. code:: prettyprint

      var visible by remember { mutableStateOf(true) }
      val density = LocalDensity.current
      AnimatedVisibility(
          visible = visible,
          enter = slideInVertically {
              // Slide in from 40 dp from the top.
              with(density) { -40.dp.roundToPx() }
          } + expandVertically(
              // Expand from the top.
              expandFrom = Alignment.Top
          ) + fadeIn(
              // Fade in with the initial alpha of 0.3f.
              initialAlpha = 0.3f
          ),
          exit = slideOutVertically() + shrinkVertically() + fadeOut()
      ) {
          Text("Hello", Modifier.fillMaxWidth().height(200.dp))
      }AnimationSnippets.kt

   As you can see in the example above, you can combine multiple
   ``EnterTransition`` or ``ExitTransition`` objects with a ``+`` operator, and
   each accepts optional parameters to customize its behavior. See the
   references for more information.

   .. rubric:: ``EnterTransition`` and ``ExitTransition`` examples
      :name: enter-exit-transition

   .. list-table::
      :widths: 40 40
      :header-rows: 1

      - 

         - EnterTransition
         - ExitTransition
      - 

         - `fadeIn  <#fadeIn>`__
            |fade in animation|
         - `fadeOut  <#fadeOut>`__
            |fade out animation|
      - 

         - `slideIn  <#slideIn>`__
            |slide in animation|
         - `slideOut  <#slideOut>`__
            |slide out animation|
      - 

         - `slideInHorizontally  <#slideInHorizontally>`__
            |slide in horizontally animation|
         - `slideOutHorizontally  <#slideOutHorizontally>`__
            |slide out horizontally animation|
      - 

         - `slideInVertically  <#slideInVertically>`__
            |slide in vertically animation|
         - `slideOutVertically  <#slideOutVertically>`__
            |slide out vertically animation|
      - 

         - `scaleIn  <#scaleIn>`__
            |scale in animation|
         - `scaleOut  <#scaleOut>`__
            |scale out animation|
      - 

         - `expandIn  <#expandIn>`__
            |expand in animation|
         - `shrinkOut  <#shrinkOut>`__
            |shrink out animation|
      - 

         - `expandHorizontally  <#expandHorizontally>`__
            |expand horizontally animation|
         - `shrinkHorizontally  <#shrinkHorizontally>`__
            |shrink horizontally animation|
      - 

         - `expandVertically  <#expandVertically>`__
            |expand vertically animation|
         - `shrinkVertically  <#shrinkVertically>`__
            |shrink vertically animation|

   ``AnimatedVisibility`` also offers a variant that takes a
   ``MutableTransitionState``. This allows you to trigger an animation as soon
   as the ``AnimatedVisibility`` is added to the composition tree. It is also
   useful for observing the animation state.

   .. code:: prettyprint

      // Create a MutableTransitionState<Boolean> for the AnimatedVisibility.
      val state = remember {
          MutableTransitionState(false).apply {
              // Start the animation immediately.
              targetState = true
          }
      }
      Column {
          AnimatedVisibility(visibleState = state) {
              Text(text = "Hello, world!")
          }

          // Use the MutableTransitionState to know the current animation state
          // of the AnimatedVisibility.
          Text(
              text = when {
                  state.isIdle && state.currentState -> "Visible"
                  !state.isIdle && state.currentState -> "Disappearing"
                  state.isIdle && !state.currentState -> "Invisible"
                  else -> "Appearing"
              }
          )
      }AnimationSnippets.kt

   .. rubric:: Animate enter and exit for children
      :name: animatedvisibility-enter-exit

   Content within ``AnimatedVisibility`` (direct or indirect children) can use
   the
   `animateEnterExit  <#animateEnterExit>`__
   modifier to specify different animation behavior for each of them. The visual
   effect for each of these children is a combination of the animations
   specified at the ``AnimatedVisibility`` composable and the child's own enter
   and exit animations.

   .. code:: prettyprint

      var visible by remember { mutableStateOf(true) }

      AnimatedVisibility(
          visible = visible,
          enter = fadeIn(),
          exit = fadeOut()
      ) {
          // Fade in/out the background and the foreground.
          Box(Modifier.fillMaxSize().background(Color.DarkGray)) {
              Box(
                  Modifier
                      .align(Alignment.Center)
                      .animateEnterExit(
                          // Slide in/out the inner box.
                          enter = slideInVertically(),
                          exit = slideOutVertically()
                      )
                      .sizeIn(minWidth = 256.dp, minHeight = 64.dp)
                      .background(Color.Red)
              ) {
                  // Content of the notification…
              }
          }
      }AnimationSnippets.kt

   In some cases, you may want to have ``AnimatedVisibility`` apply no
   animations at all so that children can each have their own distinct
   animations by ``animateEnterExit``. To achieve this, specify
   ``EnterTransition.None`` and ``ExitTransition.None`` at the
   ``AnimatedVisibility`` composable.

   .. rubric:: Add custom animation
      :name: animatedvisibility-add-custom-animation

   If you want to add custom animation effects beyond the built-in enter and
   exit animations, access the underlying ``Transition`` instance via the
   ``transition`` property inside the content lambda for ``AnimatedVisibility``.
   Any animation states added to the Transition instance will run simultaneously
   with the enter and exit animations of ``AnimatedVisibility``.
   ``AnimatedVisibility`` waits until all animations in the ``Transition`` have
   finished before removing its content. For exit animations created independent
   of ``Transition`` (such as using ``animate*AsState``), ``AnimatedVisibility``
   would not be able to account for them, and therefore may remove the content
   composable before they finish.

   .. code:: prettyprint

      var visible by remember { mutableStateOf(true) }

      AnimatedVisibility(
          visible = visible,
          enter = fadeIn(),
          exit = fadeOut()
      ) { // this: AnimatedVisibilityScope
          // Use AnimatedVisibilityScope#transition to add a custom animation
          // to the AnimatedVisibility.
          val background by transition.animateColor(label = "color") { state ->
              if (state == EnterExitState.Visible) Color.Blue else Color.Gray
          }
          Box(modifier = Modifier.size(128.dp).background(background))
      }AnimationSnippets.kt

   See
   `updateTransition  <#updatetransition>`__
   for the details about ``Transition``.

   .. rubric:: Animate based on target state with ``AnimatedContent``
      :name: animatedcontent

   The
   `AnimatedContent  <#AnimatedContent>`__
   composable animates its content as it changes based on a target state.

   .. code:: prettyprint

      Row {
          var count by remember { mutableStateOf(0) }
          Button(onClick = { count++ }) {
              Text("Add")
          }
          AnimatedContent(targetState = count) { targetCount ->
              // Make sure to use `targetCount`, not `count`.
              Text(text = "Count: $targetCount")
          }
      }AnimationSnippets.kt

   Note that you should always use the lambda parameter and reflect it to the
   content. The API uses this value as the key to identify the content that's
   currently shown.

   By default, the initial content fades out and then the target content fades
   in (this behavior is called `fade through <https://material.io/design/motion/the-motion-system.html#fade-through>`__).
   You can customize this animation behavior by specifying a
   `ContentTransform  <#ContentTransform>`__
   object to the ``transitionSpec`` parameter. You can create
   ``ContentTransform`` by combining an
   `EnterTransition  <#EnterTransition>`__
   with an
   `ExitTransition  <#ExitTransition>`__
   using the ``with`` infix function. You can apply
   `SizeTransform  <#SizeTransform>`__
   to the ``ContentTransform`` by attaching it with the ``using`` infix
   function.

   .. code:: prettyprint

      AnimatedContent(
          targetState = count,
          transitionSpec = {
              // Compare the incoming number with the previous number.
              if (targetState > initialState) {
                  // If the target number is larger, it slides up and fades in
                  // while the initial (smaller) number slides up and fades out.
                  slideInVertically { height -> height } + fadeIn() with
                      slideOutVertically { height -> -height } + fadeOut()
              } else {
                  // If the target number is smaller, it slides down and fades in
                  // while the initial number slides down and fades out.
                  slideInVertically { height -> -height } + fadeIn() with
                      slideOutVertically { height -> height } + fadeOut()
              }.using(
                  // Disable clipping since the faded slide-in/out should
                  // be displayed out of bounds.
                  SizeTransform(clip = false)
              )
          }
      ) { targetCount ->
          Text(text = "$targetCount")
      }AnimationSnippets.kt

   |image-animation-count|

   ``EnterTransition`` defines how the target content should appear, and
   ``ExitTransition`` defines how the initial content should disappear. In
   addition to all of the ``EnterTransition`` and ``ExitTransition`` functions
   available for ``AnimatedVisibility``, ``AnimatedContent`` offers
   `slideIntoContainer  <#slideIntoContainer>`__
   and
   `slideOutOfContainer  <#slideOutOfContainer>`__.
   These are convenient alternatives to ``slideInHorizontally/Vertically`` and
   ``slideOutHorizontally/Vertically`` that calculate the slide distance based
   on the sizes of the initial content and the target content of the
   ``AnimatedContent`` content.

   `SizeTransform  <#SizeTransform>`__
   defines how the size should animate between the initial and the target
   contents. You have access to both the initial size and the target size when
   you are creating the animation. ``SizeTransform`` also controls whether the
   content should be clipped to the component size during animations.

   .. code:: prettyprint

      var expanded by remember { mutableStateOf(false) }
      Surface(
          color = MaterialTheme.colorScheme.primary,
          onClick = { expanded = !expanded }
      ) {
          AnimatedContent(
              targetState = expanded,
              transitionSpec = {
                  fadeIn(animationSpec = tween(150, 150)) with
                      fadeOut(animationSpec = tween(150)) using
                      SizeTransform { initialSize, targetSize ->
                          if (targetState) {
                              keyframes {
                                  // Expand horizontally first.
                                  IntSize(targetSize.width, initialSize.height) at 150
                                  durationMillis = 300
                              }
                          } else {
                              keyframes {
                                  // Shrink vertically first.
                                  IntSize(initialSize.width, targetSize.height) at 150
                                  durationMillis = 300
                              }
                          }
                      }
              }
          ) { targetExpanded ->
              if (targetExpanded) {
                  Expanded()
              } else {
                  ContentIcon()
              }
          }
      }AnimationSnippets.kt

   |image-animation-sizetransform|

   .. rubric:: Animate child enter and exit transitions
      :name: animatedcontent-enter-exit-for-children

   Just like ``AnimatedVisibility``, the
   `animateEnterExit  <#animateEnterExit>`__
   modifier is available inside the content lambda of ``AnimatedContent``. Use
   this to apply ``EnterAnimation`` and ``ExitAnimation`` to each of the direct
   or indirect children separately.

   .. rubric:: Add custom animation
      :name: animatedcontent-add-custom-animation

   Just like ``AnimatedVisibility``, the ``transition`` field is available
   inside the content lambda of ``AnimatedContent``. Use this to create a custom
   animation effect that runs simultaneously with the ``AnimatedContent``
   transition. See
   `updateTransition  <#updatetransition>`__
   for the details.

   .. rubric:: Animate between two layouts with ``Crossfade``
      :name: crossfade

   ``Crossfade`` animates between two layouts with a crossfade animation. By
   toggling the value passed to the ``current`` parameter, the content is
   switched with a crossfade animation.

   .. code:: prettyprint

      var currentPage by remember { mutableStateOf("A") }
      Crossfade(targetState = currentPage) { screen ->
          when (screen) {
              "A" -> Text("Page A")
              "B" -> Text("Page B")
          }
      }AnimationSnippets.kt

   .. rubric:: Built-in animation modifiers
      :name: animation-modifiers

   .. rubric:: Animate composable size changes with ``animateContentSize``
      :name: animateContentSize

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/animated_content_size.gif
      name: image-4
      :alt: Green composable animating its size change smoothly.
      :width: 100.0%

      **Figure 2.** Composable smoothly animating between a small and a larger
      size

   The ``animateContentSize`` modifier animates a size change.

   **Note:**\  The ordering of where ``animateContentSize`` is placed in your
   modifier chain matters. For smooth animations, ensure you place it *before*
   any size modifiers such as ``size`` or ``defaultMinSize`` to ensure that
   ``animateContentSize`` reports the animated value change to the Layout.
   .. code:: prettyprint

      var expanded by remember { mutableStateOf(false) }
      Box(
          modifier = Modifier
              .background(colorBlue)
              .animateContentSize()
              .height(if (expanded) 400.dp else 200.dp)
              .fillMaxWidth()
              .clickable(
                  interactionSource = remember { MutableInteractionSource() },
                  indication = null
              ) {
                  expanded = !expanded
              }

      ) {
      }AnimationQuickGuide.kt

   .. rubric:: List item animations
      :name: list-item-animations

   If you are looking to animate item reorderings inside a Lazy list or grid,
   take a look at the `Lazy layout item animation documentation  <#item-animations>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Value-based animations  <#value-based>`__
   -  `Animations in Compose  <#introduction>`__
   -  `Animation tooling support {:#tooling}  <#tooling>`__

Last updated 2024-05-03 UTC.

.. |fade in animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-fadein.gif
   :width: 100px
.. |fade out animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-fadeout.gif
   :width: 100px
.. |slide in animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-slidein.gif
   :width: 100px
.. |slide out animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-slideout.gif
   :width: 100px
.. |slide in horizontally animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-slideinhorizontally.gif
   :width: 100px
.. |slide out horizontally animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-slideouthorizontally.gif
   :width: 100px
.. |slide in vertically animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-slideinvertically.gif
   :width: 100px
.. |slide out vertically animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-slideoutvertically.gif
   :width: 100px
.. |scale in animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-scalein.gif
   :width: 100px
.. |scale out animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-scaleout.gif
   :width: 100px
.. |expand in animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-expandin.gif
   :width: 100px
.. |shrink out animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-shrinkout.gif
   :width: 100px
.. |expand horizontally animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-expandhorizontally.gif
   :width: 100px
.. |shrink horizontally animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-shrinkhorizontally.gif
   :width: 100px
.. |expand vertically animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-expandvertically.gif
   :width: 100px
.. |shrink vertically animation| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-shrinkvertically.gif
   :width: 100px
.. |image-animation-count| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-count.gif
   :width: 100px
.. |image-animation-sizetransform| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-sizetransform.gif

/Value-based animations
=======================

.. https://developer.android.google.cn/develop/ui/compose/animation/value-based?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: Animate a single value with ``animate*AsState``
      :name: animate-as-state

   The
   `animate*AsState  <#animateDpAsState>`__
   functions are the simplest animation APIs in Compose for animating a single
   value. You only provide the target value (or end value), and the API starts
   animation from the current value to the specified value.

   Below is an example of animating alpha using this API. By simply wrapping the
   target value in
   `animateFloatAsState  <#animateFloatAsState>`__,
   the alpha value is now an animation value between the provided values (``1f``
   or ``0.5f`` in this case).

   .. code:: prettyprint

      var enabled by remember { mutableStateOf(true) }

      val alpha: Float by animateFloatAsState(if (enabled) 1f else 0.5f)
      Box(
          Modifier.fillMaxSize()
              .graphicsLayer(alpha = alpha)
              .background(Color.Red)
      )AnimationSnippets.kt

   Note that you don't need to create an instance of any animation class, or
   handle interruption. Under the hood, an animation object (namely, an
   ``Animatable`` instance) will be created and remembered at the call site,
   with the first target value as its initial value. From there on, any time you
   supply this composable a different target value, an animation is
   automatically started towards that value. If there's already an animation in
   flight, the animation starts from its current value (and velocity) and
   animates toward the target value. During the animation, this composable gets
   recomposed and returns an updated animation value every frame.

   Out of the box, Compose provides ``animate*AsState`` functions for ``Float``,
   ``Color``, ``Dp``, ``Size``, ``Offset``, ``Rect``, ``Int``, ``IntOffset``,
   and ``IntSize``. You can easily add support for other data types by providing
   a ``TwoWayConverter`` to ``animateValueAsState`` that takes a generic type.

   You can customize the animation specifications by providing an
   `AnimationSpec  <#AnimationSpec>`__.
   See `AnimationSpec  <#animationspec>`__
   for more information.

   .. rubric:: Animate multiple properties simultaneously with a transition
      :name: updateTransition

   `Transition  <#Transition>`__
   manages one or more animations as its children and runs them simultaneously
   between multiple states.

   The states can be of any data type. In many cases, you can use a custom
   ``enum`` type to ensure type safety, as in this example:

   .. code:: prettyprint

      enum class BoxState {
          Collapsed,
          Expanded
      }AnimationSnippets.kt

   `updateTransition  <#updateTransition>`__
   creates and remembers an instance of ``Transition`` and updates its state.

   .. code:: prettyprint

      var currentState by remember { mutableStateOf(BoxState.Collapsed) }
      val transition = updateTransition(currentState, label = "box state")AnimationSnippets.kt

   You can then use one of ``animate*`` extension functions to define a child
   animation in this transition. Specify the target values for each of the
   states. These ``animate*`` functions return an animation value that is
   updated every frame during the animation when the transition state is updated
   with ``updateTransition``.

   .. code:: prettyprint

      val rect by transition.animateRect(label = "rectangle") { state ->
          when (state) {
              BoxState.Collapsed -> Rect(0f, 0f, 100f, 100f)
              BoxState.Expanded -> Rect(100f, 100f, 300f, 300f)
          }
      }
      val borderWidth by transition.animateDp(label = "border width") { state ->
          when (state) {
              BoxState.Collapsed -> 1.dp
              BoxState.Expanded -> 0.dp
          }
      }AnimationSnippets.kt

   Optionally, you can pass a ``transitionSpec`` parameter to specify a
   different ``AnimationSpec`` for each of the combinations of transition state
   changes. See
   `AnimationSpec  <#animationspec>`__ for
   more information.

   .. code:: prettyprint

      val color by transition.animateColor(
          transitionSpec = {
              when {
                  BoxState.Expanded isTransitioningTo BoxState.Collapsed ->
                      spring(stiffness = 50f)
                  else ->
                      tween(durationMillis = 500)
              }
          }, label = "color"
      ) { state ->
          when (state) {
              BoxState.Collapsed -> MaterialTheme.colorScheme.primary
              BoxState.Expanded -> MaterialTheme.colorScheme.background
          }
      }AnimationSnippets.kt

   Once a transition has arrived at the target state,
   ``Transition.currentState`` will be the same as ``Transition.targetState``.
   This can be used as a signal for whether the transition has finished.

   We sometimes want to have an initial state different from the first target
   state. We can use ``updateTransition`` with ``MutableTransitionState`` to
   achieve this. For example, it allows us to start animation as soon as the
   code enters composition.

   .. code:: prettyprint

      // Start in collapsed state and immediately animate to expanded
      var currentState = remember { MutableTransitionState(BoxState.Collapsed) }
      currentState.targetState = BoxState.Expanded
      val transition = updateTransition(currentState, label = "box state")
      // ……AnimationSnippets.kt

   For a more complex transition involving multiple composable functions, you
   can use
   `createChildTransition  <#createChildTransition>`__
   to create a child transition. This technique is useful for separating
   concerns among multiple subcomponents in a complex composable. The parent
   transition will be aware of all the animation values in the child
   transitions.

   .. code:: prettyprint

      enum class DialerState { DialerMinimized, NumberPad }

      @Composable
      fun DialerButton(isVisibleTransition: Transition<Boolean>) {
          // `isVisibleTransition` spares the need for the content to know
          // about other DialerStates. Instead, the content can focus on
          // animating the state change between visible and not visible.
      }

      @Composable
      fun NumberPad(isVisibleTransition: Transition<Boolean>) {
          // `isVisibleTransition` spares the need for the content to know
          // about other DialerStates. Instead, the content can focus on
          // animating the state change between visible and not visible.
      }

      @Composable
      fun Dialer(dialerState: DialerState) {
          val transition = updateTransition(dialerState, label = "dialer state")
          Box {
              // Creates separate child transitions of Boolean type for NumberPad
              // and DialerButton for any content animation between visible and
              // not visible
              NumberPad(
                  transition.createChildTransition {
                      it == DialerState.NumberPad
                  }
              )
              DialerButton(
                  transition.createChildTransition {
                      it == DialerState.DialerMinimized
                  }
              )
          }
      }AnimationSnippets.kt

   .. rubric:: Use transition with ``AnimatedVisibility`` and
      ``AnimatedContent``
      :name: use-transition-with-animatedvisibility-and-animatedcontent

   `AnimatedVisibility  <#AnimatedVisibility>`__
   and
   `AnimatedContent  <#AnimatedContent>`__
   are available as extension functions of ``Transition``. The ``targetState``
   for ``Transition.AnimatedVisibility`` and ``Transition.AnimatedContent`` is
   derived from the ``Transition``, and triggering enter/exit transitions as
   needed when the ``Transition``'s ``targetState`` has changed. These extension
   functions allow all the enter/exit/sizeTransform animations that would
   otherwise be internal to ``AnimatedVisibility``/``AnimatedContent`` to be
   hoisted into the ``Transition``. With these extension functions,
   ``AnimatedVisibility``/``AnimatedContent``'s state change can be observed
   from outside. Instead of a boolean ``visible`` parameter, this version of
   ``AnimatedVisibility`` takes a lambda that converts the parent transition's
   target state into a boolean.

   See
   `AnimatedVisibility  <#animatedvisibility>`__
   and
   `AnimatedContent  <#animatedcontent>`__
   for the details.

   .. code:: prettyprint

      var selected by remember { mutableStateOf(false) }
      // Animates changes when `selected` is changed.
      val transition = updateTransition(selected, label = "selected state")
      val borderColor by transition.animateColor(label = "border color") { isSelected ->
          if (isSelected) Color.Magenta else Color.White
      }
      val elevation by transition.animateDp(label = "elevation") { isSelected ->
          if (isSelected) 10.dp else 2.dp
      }
      Surface(
          onClick = { selected = !selected },
          shape = RoundedCornerShape(8.dp),
          border = BorderStroke(2.dp, borderColor),
          elevation = elevation
      ) {
          Column(modifier = Modifier.fillMaxWidth().padding(16.dp)) {
              Text(text = "Hello, world!")
              // AnimatedVisibility as a part of the transition.
              transition.AnimatedVisibility(
                  visible = { targetSelected -> targetSelected },
                  enter = expandVertically(),
                  exit = shrinkVertically()
              ) {
                  Text(text = "It is fine today.")
              }
              // AnimatedContent as a part of the transition.
              transition.AnimatedContent { targetState ->
                  if (targetState) {
                      Text(text = "Selected")
                  } else {
                      Icon(imageVector = Icons.Default.Phone, contentDescription = "Phone")
                  }
              }
          }
      }AnimationSnippets.kt

   .. rubric:: Encapsulate a transition and make it reusable
      :name: encapsulate-transition

   For simple use cases, defining transition animations in the same composable
   as your UI is a perfectly valid option. When you are working on a complex
   component with a number of animated values, however, you might want to
   separate the animation implementation from the composable UI.

   You can do so by creating a class that holds all the animation values and an
   ‘update’ function that returns an instance of that class. The transition
   implementation can be extracted into the new separate function. This pattern
   is useful when there is a need to centralize the animation logic, or make
   complex animations reusable.

   .. code:: prettyprint

      enum class BoxState { Collapsed, Expanded }

      @Composable
      fun AnimatingBox(boxState: BoxState) {
          val transitionData = updateTransitionData(boxState)
          // UI tree
          Box(
              modifier = Modifier
                  .background(transitionData.color)
                  .size(transitionData.size)
          )
      }

      // Holds the animation values.
      private class TransitionData(
          color: State<Color>,
          size: State<Dp>
      ) {
          val color by color
          val size by size
      }

      // Create a Transition and return its animation values.
      @Composable
      private fun updateTransitionData(boxState: BoxState): TransitionData {
          val transition = updateTransition(boxState, label = "box state")
          val color = transition.animateColor(label = "color") { state ->
              when (state) {
                  BoxState.Collapsed -> Color.Gray
                  BoxState.Expanded -> Color.Red
              }
          }
          val size = transition.animateDp(label = "size") { state ->
              when (state) {
                  BoxState.Collapsed -> 64.dp
                  BoxState.Expanded -> 128.dp
              }
          }
          return remember(transition) { TransitionData(color, size) }
      }AnimationSnippets.kt

   .. rubric:: Create an infinitely repeating animation with
      ``rememberInfiniteTransition``
      :name: rememberinfinitetransition

   `InfiniteTransition  <#InfiniteTransition>`__
   holds one or more child animations like ``Transition``, but the animations
   start running as soon as they enter the composition and do not stop unless
   they are removed. You can create an instance of ``InfiniteTransition`` with
   ``rememberInfiniteTransition``. Child animations can be added with
   ``animateColor``, ``animatedFloat``, or ``animatedValue``. You also need to
   specify an `infiniteRepeatable <#infiniterepeatable>`__ to specify the
   animation specifications.

   .. code:: prettyprint

      val infiniteTransition = rememberInfiniteTransition()
      val color by infiniteTransition.animateColor(
          initialValue = Color.Red,
          targetValue = Color.Green,
          animationSpec = infiniteRepeatable(
              animation = tween(1000, easing = LinearEasing),
              repeatMode = RepeatMode.Reverse
          )
      )

      Box(Modifier.fillMaxSize().background(color))AnimationSnippets.kt

   .. rubric:: Low-level animation APIs
      :name: low-level-apis

   All the high-level animation APIs mentioned in the previous section are built
   on top of the foundation of the low-level animation APIs.

   The ``animate*AsState`` functions are the simplest APIs, that render an
   instant value change as an animation value. It is backed by ``Animatable``,
   which is a coroutine-based API for animating a single value.
   ``updateTransition`` creates a transition object that can manage multiple
   animating values and run them based on a state change.
   ``rememberInfiniteTransition`` is similar, but it creates an infinite
   transition that can manage multiple animations that keep on running
   indefinitely. All of these APIs are composables except for ``Animatable``,
   which means these animations can be created outside of composition.

   All of these APIs are based on the more fundamental ``Animation`` API. Though
   most apps will not interact directly with ``Animation``, some of the
   customization capabilities for ``Animation`` are available through
   higher-level APIs. See `Customize animations  <#customize>`__ for more information
   on ``AnimationVector`` and ``AnimationSpec``.

   |Diagram showing the relationship between the various low-level animation
   APIs|

   .. rubric:: ``Animatable``: Coroutine-based single value animation
      :name: animatable

   `Animatable  <#Animatable>`__
   is a value holder that can animate the value as it is changed via
   ``animateTo``. This is the API backing up the implementation of
   ``animate*AsState``. It ensures consistent continuation and mutual
   exclusiveness, meaning that the value change is always continuous and any
   ongoing animation will be canceled.

   Many features of ``Animatable``, including ``animateTo``, are provided as
   suspend functions. This means that they need to be wrapped in an appropriate
   coroutine scope. For example, you can use the ``LaunchedEffect`` composable
   to create a scope just for the duration of the specified key value.

   .. code:: prettyprint

      // Start out gray and animate to green/red based on `ok`
      val color = remember { Animatable(Color.Gray) }
      LaunchedEffect(ok) {
          color.animateTo(if (ok) Color.Green else Color.Red)
      }
      Box(Modifier.fillMaxSize().background(color.value))AnimationSnippets.kt

   In the example above, we create and remember an instance of ``Animatable``
   with the initial value of ``Color.Gray``. Depending on the value of the
   boolean flag ``ok``, the color animates to either ``Color.Green`` or
   ``Color.Red``. Any subsequent change to the boolean value starts animation to
   the other color. If there's an ongoing animation when the value is changed,
   the animation is canceled, and the new animation starts from the current
   snapshot value with the current velocity.

   This is the animation implementation that backs up the ``animate*AsState``
   API mentioned in the previous section. Compared to ``animate*AsState``, using
   ``Animatable`` directly gives us finer-grained control on several respects.
   First, ``Animatable`` can have an initial value different from its first
   target value. For example, the code example above shows a gray box at first,
   which immediately starts animating to either green or red. Second,
   ``Animatable`` provides more operations on the content value, namely
   ``snapTo`` and ``animateDecay``. ``snapTo`` sets the current value to the
   target value immediately. This is useful when the animation itself is not the
   only source of truth and has to be synced with other states, such as touch
   events. ``animateDecay`` starts an animation that slows down from the given
   velocity. This is useful for implementing fling behavior. See `Gesture and animation  <#advanced>`__ for more information.

   Out of the box, ``Animatable`` supports ``Float`` and ``Color``, but any data
   type can be used by providing a ``TwoWayConverter``. See
   `AnimationVector  <#animationvector>`__
   for more information.

   You can customize the animation specifications by providing an
   ``AnimationSpec``. See
   `AnimationSpec  <#animationspec>`__ for
   more information.

   .. rubric:: ``Animation``: Manually controlled animation
      :name: animation

   `Animation  <#Animation>`__
   is the lowest-level Animation API available. Many of the animations we've
   seen so far build ontop of Animation. There are two ``Animation`` subtypes:
   `TargetBasedAnimation  <#TargetBasedAnimation>`__
   and
   `DecayAnimation  <#DecayAnimation>`__.

   ``Animation`` should only be used to manually control the time of the
   animation. ``Animation`` is stateless, and it does not have any concept of
   lifecycle. It serves as an animation calculation engine that the higher-level
   APIs use.

   **Note:**\  Unless there's a need to control the timing manually, it's
   generally recommended to use higher level animation APIs that build on top of
   these classes.

   .. rubric:: ``TargetBasedAnimation``
      :name: targetbasedanimation

   Other APIs cover most use cases, but using ``TargetBasedAnimation`` directly
   allows you to control the animation play time yourself. In the example below,
   the play time of the ``TargetAnimation`` is manually controlled based on the
   frame time provided by ``withFrameNanos``.

   .. code:: prettyprint

      val anim = remember {
          TargetBasedAnimation(
              animationSpec = tween(200),
              typeConverter = Float.VectorConverter,
              initialValue = 200f,
              targetValue = 1000f
          )
      }
      var playTime by remember { mutableStateOf(0L) }

      LaunchedEffect(anim) {
          val startTime = withFrameNanos { it }

          do {
              playTime = withFrameNanos { it } - startTime
              val animationValue = anim.getValueFromNanos(playTime)
          } while (someCustomCondition())
      }AnimationSnippets.kt

   .. rubric:: ``DecayAnimation``
      :name: decay-animation

   Unlike ``TargetBasedAnimation``,
   `DecayAnimation  <#DecayAnimation>`__
   does not require a ``targetValue`` to be provided. Instead, it calculates its
   ``targetValue`` based on the starting conditions, set by ``initialVelocity``
   and ``initialValue`` and the supplied ``DecayAnimationSpec``.

   Decay animations are often used after a fling gesture to slow elements down
   to a stop. The animation velocity starts at the value set by
   ``initialVelocityVector`` and slows down over time.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Customize animations {:#customize-animations}  <#customize>`__
   -  `Animations in Compose  <#introduction>`__
   -  `Animation modifiers and composables  <#composables-modifiers>`__

Last updated 2024-05-03 UTC.

.. |Diagram showing the relationship between the various low-level animation APIs| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-low-level.svg

/Animated vector images
=======================

.. https://developer.android.google.cn/develop/ui/compose/animation/vectors?hl=en

.. container:: devsite-article-body clearfix

   Animating vectors in Compose is possible in a few different ways. You can use
   any of the following:

   -  ``AnimatedVectorDrawable`` file format
   -  ``ImageVector`` with Compose animation APIs, like in `this Medium article <https://medium.com/androiddevelopers/making-jellyfish-move-in-compose-animating-imagevectors-and-applying-agsl-rendereffects-3666596a8888>`__
   -  A third-party solution like `Lottie <https://airbnb.design/lottie/>`__

   .. rubric:: Animated vector drawables (experimental)
      :name: animated-vector-resources

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/avd_example_compose.gif
      name: image-1
      :alt: Hourglass animating its contents and rotating
      :width: 100.0%

      **Figure 1.** Animated vector drawable in Compose

   To use an
   `AnimatedVectorDrawable  <#AnimatedVectorDrawable>`__
   resource, load up the drawable file using ``animatedVectorResource`` and pass
   in a ``boolean`` to switch between the start and end state of your drawable,
   performing the animation.

   .. code:: prettyprint

      @Composable
      fun AnimatedVectorDrawable() {
          val image = AnimatedImageVector.animatedVectorResource(R.drawable.ic_hourglass_animated)
          var atEnd by remember { mutableStateOf(false) }
          Image(
              painter = rememberAnimatedVectorPainter(image, atEnd),
              contentDescription = "Timer",
              modifier = Modifier.clickable {
                  atEnd = !atEnd
              },
              contentScale = ContentScale.Crop
          )
      }AnimationSnippets.kt

   For more information about the format of your drawable file, see `Animate drawable graphics  <#drawable-animation>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Loading images {:#loading-images}  <#loading>`__

Last updated 2024-05-03 UTC.

/Advanced animation example
===========================

.. https://developer.android.google.cn/develop/ui/compose/animation/advanced?hl=en

.. container:: devsite-article-body clearfix

   There are several things we have to take into consideration when we are
   working with touch events and animations, compared to when we are working
   with animations alone. First of all, we might need to interrupt an ongoing
   animation when touch events begin as user interaction should have the highest
   priority.

   In the example below, we use an ``Animatable`` to represent the offset
   position of a circle component. Touch events are processed with the
   `pointerInput  <#pointerInput>`__
   modifier. When we detect a new tap event, we call ``animateTo`` to animate
   the offset value to the tap position. A tap event can happen during the
   animation too, and in that case, ``animateTo`` interrupts the ongoing
   animation and starts the animation to the new target position while
   maintaining the velocity of the interrupted animation.

   .. code:: prettyprint

      @Composable
      fun Gesture() {
          val offset = remember { Animatable(Offset(0f, 0f), Offset.VectorConverter) }
          Box(
              modifier = Modifier
                  .fillMaxSize()
                  .pointerInput(Unit) {
                      coroutineScope {
                          while (true) {
                              // Detect a tap event and obtain its position.
                              awaitPointerEventScope {
                                  val position = awaitFirstDown().position

                                  launch {
                                      // Animate to the tap position.
                                      offset.animateTo(position)
                                  }
                              }
                          }
                      }
                  }
          ) {
              Circle(modifier = Modifier.offset { offset.value.toIntOffset() })
          }
      }

      private fun Offset.toIntOffset() = IntOffset(x.roundToInt(), y.roundToInt())AdvancedAnimationSnippets.kt

   Another frequent pattern is we need to synchronize animation values with
   values coming from touch events, such as drag. In the example below, we see
   "swipe to dismiss" implemented as a ``Modifier`` (rather than using the
   `SwipeToDismiss  <#SwipeToDismiss>`__
   composable). The horizontal offset of the element is represented as an
   ``Animatable``. This API has a characteristic useful in gesture animation.
   Its value can be changed by touch events as well as the animation. When we
   receive a touch down event, we stop the ``Animatable`` by the ``stop`` method
   so that any ongoing animation is intercepted.

   During a drag event, we use ``snapTo`` to update the ``Animatable`` value
   with the value calculated from touch events. For fling, Compose provides
   ``VelocityTracker`` to record drag events and calculate velocity. The
   velocity can be fed directly to ``animateDecay`` for the fling animation.
   When we want to slide the offset value back to the original position, we
   specify the target offset value of ``0f`` with the ``animateTo`` method.

   .. code:: prettyprint

      fun Modifier.swipeToDismiss(
          onDismissed: () -> Unit
      ): Modifier = composed {
          val offsetX = remember { Animatable(0f) }
          pointerInput(Unit) {
              // Used to calculate fling decay.
              val decay = splineBasedDecay<Float>(this)
              // Use suspend functions for touch events and the Animatable.
              coroutineScope {
                  while (true) {
                      val velocityTracker = VelocityTracker()
                      // Stop any ongoing animation.
                      offsetX.stop()
                      awaitPointerEventScope {
                          // Detect a touch down event.
                          val pointerId = awaitFirstDown().id

                          horizontalDrag(pointerId) { change ->
                              // Update the animation value with touch events.
                              launch {
                                  offsetX.snapTo(
                                      offsetX.value + change.positionChange().x
                                  )
                              }
                              velocityTracker.addPosition(
                                  change.uptimeMillis,
                                  change.position
                              )
                          }
                      }
                      // No longer receiving touch events. Prepare the animation.
                      val velocity = velocityTracker.calculateVelocity().x
                      val targetOffsetX = decay.calculateTargetValue(
                          offsetX.value,
                          velocity
                      )
                      // The animation stops when it reaches the bounds.
                      offsetX.updateBounds(
                          lowerBound = -size.width.toFloat(),
                          upperBound = size.width.toFloat()
                      )
                      launch {
                          if (targetOffsetX.absoluteValue <= size.width) {
                              // Not enough velocity; Slide back.
                              offsetX.animateTo(
                                  targetValue = 0f,
                                  initialVelocity = velocity
                              )
                          } else {
                              // The element was swiped away.
                              offsetX.animateDecay(velocity, decay)
                              onDismissed()
                          }
                      }
                  }
              }
          }
              .offset { IntOffset(offsetX.value.roundToInt(), 0) }
      }AdvancedAnimationSnippets.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Value-based animations  <#value-based>`__
   -  `Drag, swipe, and fling  <#drag-swipe-fling>`__
   -  `Understand gestures  <#understand-gestures>`__

Last updated 2024-05-03 UTC.

/Customize animations
=====================

.. https://developer.android.google.cn/develop/ui/compose/animation/customize?hl=en

.. container:: devsite-article-body clearfix

   Many of the Animation APIs commonly accept parameters for customizing their
   behavior.

   .. rubric:: Customize animations with the ``AnimationSpec`` parameter
      :name: animationspec

   Most animation APIs allow developers to customize animation specifications by
   an optional ``AnimationSpec`` parameter.

   .. code:: prettyprint

      val alpha: Float by animateFloatAsState(
          targetValue = if (enabled) 1f else 0.5f,
          // Configure the animation duration and easing.
          animationSpec = tween(durationMillis = 300, easing = FastOutSlowInEasing)
      )AnimationSnippets.kt

   There are different kinds of ``AnimationSpec`` for creating different types
   of animation.

   .. rubric:: Create physics-based animation with ``spring``
      :name: spring

   ``spring`` creates a physics-based animation between start and end values. It
   takes 2 parameters: ``dampingRatio`` and ``stiffness``.

   ``dampingRatio`` defines how bouncy the spring should be. The default value
   is ``Spring.DampingRatioNoBouncy``.

   **Figure 1.** Setting different spring damping ratios.

   ``stiffness`` defines how fast the spring should move toward the end value.
   The default value is ``Spring.StiffnessMedium``.

   **Figure 2.** Setting different spring stiffness

   .. code:: prettyprint

      val value by animateFloatAsState(
          targetValue = 1f,
          animationSpec = spring(
              dampingRatio = Spring.DampingRatioHighBouncy,
              stiffness = Spring.StiffnessMedium
          )
      )AnimationSnippets.kt

   ``spring`` can handle interruptions more smoothly than duration-based
   ``AnimationSpec`` types because it guarantees the continuity of velocity when
   target value changes amid animations. ``spring`` is used as the default
   AnimationSpec by many animation APIs, such as ``animate*AsState`` and
   ``updateTransition``.

   For example, if we apply a ``spring`` config to the following animation that
   is driven by user touch, when interrupting the animation as its progressing,
   you can see that using ``tween`` doesn't respond as smoothly as using
   ``spring``.

   **Figure 3.** Setting ``tween`` vs ``spring`` specs for animation, and
   interrupting it.

   .. rubric:: Animate between start and end values with easing curve with
      ``tween``
      :name: tween

   ``tween`` animates between start and end values over the specified
   ``durationMillis`` using an easing curve. ``tween`` is short for the word
   between - as it goes *between* two values.

   You can also specify ``delayMillis`` to postpone the start of the animation.

   .. code:: prettyprint

      val value by animateFloatAsState(
          targetValue = 1f,
          animationSpec = tween(
              durationMillis = 300,
              delayMillis = 50,
              easing = LinearOutSlowInEasing
          )
      )AnimationSnippets.kt

   See `Easing <#easing>`__ for more information.

   .. rubric:: Animate to specific values at certain timings with ``keyframes``
      :name: keyframes

   ``keyframes`` animates based on the snapshot values specified at different
   timestamps in the duration of the animation. At any given time, the animation
   value will be interpolated between two keyframe values. For each of these
   keyframes, Easing can be specified to determine the interpolation curve.

   It is optional to specify the values at 0 ms and at the duration time. If you
   do not specify these values, they default to the start and end values of the
   animation, respectively.

   .. code:: prettyprint

      val value by animateFloatAsState(
          targetValue = 1f,
          animationSpec = keyframes {
              durationMillis = 375
              0.0f at 0 with LinearOutSlowInEasing // for 0-15 ms
              0.2f at 15 with FastOutLinearInEasing // for 15-75 ms
              0.4f at 75 // ms
              0.4f at 225 // ms
          }
      )AnimationSnippets.kt

   .. rubric:: Repeat an animation with ``repeatable``
      :name: repeatable

   ``repeatable`` runs a duration-based animation (such as ``tween`` or
   ``keyframes``) repeatedly until it reaches the specified iteration count. You
   can pass the ``repeatMode`` parameter to specify whether the animation should
   repeat by starting from the beginning (``RepeatMode.Restart``) or from the
   end (``RepeatMode.Reverse``).

   .. code:: prettyprint

      val value by animateFloatAsState(
          targetValue = 1f,
          animationSpec = repeatable(
              iterations = 3,
              animation = tween(durationMillis = 300),
              repeatMode = RepeatMode.Reverse
          )
      )AnimationSnippets.kt

   .. rubric:: Repeat an animation infinitely with ``infiniteRepeatable``
      :name: infiniterepeatable

   ``infiniteRepeatable`` is like ``repeatable``, but it repeats for an infinite
   amount of iterations.

   .. code:: prettyprint

      val value by animateFloatAsState(
          targetValue = 1f,
          animationSpec = infiniteRepeatable(
              animation = tween(durationMillis = 300),
              repeatMode = RepeatMode.Reverse
          )
      )AnimationSnippets.kt

   In tests using
   `ComposeTestRule  <#ComposeTestRule>`__,
   animations using ``infiniteRepeatable`` are not run. The component will be
   rendered using the initial value of each animated value.

   .. rubric:: Immediately snap to end value with ``snap``
      :name: snap

   ``snap`` is a special ``AnimationSpec`` that immediately switches the value
   to the end value. You can specify ``delayMillis`` in order to delay the start
   of the animation.

   .. code:: prettyprint

      val value by animateFloatAsState(
          targetValue = 1f,
          animationSpec = snap(delayMillis = 50)
      )AnimationSnippets.kt

   **Note:**\  In the View system, you needed to use ``ObjectAnimator`` for
   duration-based animations, and ``SpringAnimation`` for physics-based
   animation. It was not straightforward to use these two different animation
   APIs simultaneously. ``AnimationSpec`` in Compose allows for to handling
   these in a unified manner.

   .. rubric:: Set a custom easing function
      :name: easing

   Duration-based ``AnimationSpec`` operations (such as ``tween`` or
   ``keyframes``) use ``Easing`` to adjust an animation's fraction. This allows
   the animating value to speed up and slow down, rather than moving at a
   constant rate. Fraction is a value between 0 (start) and 1.0 (end) indicating
   the current point in the animation.

   Easing is in fact a function that takes a fraction value between 0 and 1.0
   and returns a float. The returned value can be outside the boundary to
   represent overshoot or undershoot. A custom Easing can be created like the
   code below.

   .. code:: prettyprint

      val CustomEasing = Easing { fraction -> fraction * fraction }

      @Composable
      fun EasingUsage() {
          val value by animateFloatAsState(
              targetValue = 1f,
              animationSpec = tween(
                  durationMillis = 300,
                  easing = CustomEasing
              )
          )
          // ……
      }AnimationSnippets.kt

   Compose provides several built-in ``Easing`` functions that cover most use
   cases. See `Speed - Material Design <https://m3.material.io/styles/motion/easing-and-duration/applying-easing-and-duration>`__
   for more information about what Easing to use depending on your scenario.

   -  ``FastOutSlowInEasing``
   -  ``LinearOutSlowInEasing``
   -  ``FastOutLinearEasing``
   -  ``LinearEasing``
   -  ``CubicBezierEasing``
   -  `See more  <#Ease>`__

   **Note:**\  Easing objects work the same way as instances of ``Interpolator``
   classes in the platform. Instead of the ``getInterpolation()`` method, it has
   the ``transform()`` method.

   .. rubric:: Animate custom data types by converting to and from
      ``AnimationVector``
      :name: animationvector

   Most Compose animation APIs support ``Float``, ``Color``, ``Dp``, and other
   basic data types as animation values by default, but you sometimes need to
   animate other data types including your custom ones. During animation, any
   animating value is represented as an ``AnimationVector``. The value is
   converted into an ``AnimationVector`` and vice versa by a corresponding
   ``TwoWayConverter`` so that the core animation system can handle them
   uniformly. For example, an ``Int`` is represented as an ``AnimationVector1D``
   that holds a single float value. ``TwoWayConverter`` for ``Int`` looks like
   this:

   .. code:: prettyprint

      val IntToVector: TwoWayConverter<Int, AnimationVector1D> =
          TwoWayConverter({ AnimationVector1D(it.toFloat()) }, { it.value.toInt() })AnimationSnippets.kt

   ``Color`` is essentially a set of 4 values, red, green, blue, and alpha, so
   ``Color`` is converted into an ``AnimationVector4D`` that holds 4 float
   values. In this manner, every data type used in animations is converted to
   either ``AnimationVector1D``, ``AnimationVector2D``, ``AnimationVector3D``,
   or ``AnimationVector4D`` depending on its dimensionality. This allows
   different components of the object to be animated independently, each with
   their own velocity tracking. Built-in converters for basic data types can be
   accessed using converters such as ``Color.VectorConverter`` or
   ``Dp.VectorConverter``.

   When you want to add support for a new data type as an animating value, you
   can create your own ``TwoWayConverter`` and provide it to the API. For
   example, you can use ``animateValueAsState`` to animate your custom data type
   like this:

   .. code:: prettyprint

      data class MySize(val width: Dp, val height: Dp)

      @Composable
      fun MyAnimation(targetSize: MySize) {
          val animSize: MySize by animateValueAsState(
              targetSize,
              TwoWayConverter(
                  convertToVector = { size: MySize ->
                      // Extract a float value from each of the `Dp` fields.
                      AnimationVector2D(size.width.value, size.height.value)
                  },
                  convertFromVector = { vector: AnimationVector2D ->
                      MySize(vector.v1.dp, vector.v2.dp)
                  }
              )
          )
      }AnimationSnippets.kt

   The following list includes some built-in ``VectorConverter``\ s:

   -  `Color.VectorConverter  <#VectorConverter>`__
   -  `Dp.VectorConverter  <#VectorConverter>`__
   -  `Offset.VectorConverter  <#VectorConverter>`__
   -  `Int.VectorConverter  <#VectorConverter>`__
   -  `Float.VectorConverter  <#VectorConverter>`__
   -  `IntSize.VectorConverter  <#VectorConverter>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Value-based animations  <#value-based>`__
   -  `Iterative code development {:#iterative-code-dev }  <#iterative-development>`__
   -  `Animations in Compose  <#introduction>`__

Last updated 2024-05-03 UTC.

/Introduction
=============

.. https://developer.android.google.cn/develop/ui/compose/animation/shared-elements?hl=en

.. container:: devsite-article-body clearfix

   Shared element transitions are a seamless way to transition between
   composables that have content that is consistent between them. They are often
   used for navigation, allowing you to visually connect different screens as a
   user navigates between them.

   For example, in the following video, you can see the image and title of the
   snack are shared from the listing page, to the detail page.

   .. container:: float
      :name: image-1

   In Compose, there are a few high level APIs that help you create shared
   elements:

   -  `SharedTransitionLayout  <#SharedTransitionLayout>`__:
      The outermost layout required to implement shared element transitions. It
      provides a ``SharedTransitionScope``. Composables need to be in a
      ``SharedTransitionScope`` to use the shared element modifiers.
   -  `Modifier.sharedElement() <#basic-usage>`__: The modifier that flags
      to the ``SharedTransitionScope`` the composable that should be matched
      with another composable.
   -  `Modifier.sharedBounds() <#shared-bounds>`__: The modifier that flags
      to the ``SharedTransitionScope`` that this composable's bounds should be
      used as the container bounds for where the transition should take place.
      In contrast to ``sharedElement()``, ``sharedBounds()`` is designed for
      visually different content.

   An important concept when creating shared elements in Compose is how they
   work with overlays and clipping. Take a look at `the clipping and overlays  <#clip-overlays>`__
   section to learn more about this important topic.

   **Experimental:**\  Shared element support is available in Compose
   1.7.0-alpha07+, and is experimental, the APIs may change in future. File bugs
   on the
   `issuetracker <https://issuetracker.google.com/issues/new?component=1070767&template=1626715>`__.

   .. rubric:: Basic Usage
      :name: basic-usage

   The following transition will be built in this section, transitioning from
   the smaller "list" item, to the larger detailed item:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/shared-element/basic_shared_element_jetsnack.gif
      name: image-2
      :width: 300px

      **Figure 2.** Basic example of a shared element transition between two
      composables.

   The best way to use ``Modifier.sharedElement()`` is in conjunction with
   ``AnimatedContent`` or ``AnimatedVisibility`` as this manages the transition
   between composables automatically for you.

   The starting point is an existing basic ``AnimatedContent`` that has a
   ``MainContent``, and ``DetailsContent`` composable before adding shared
   elements:
   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/shared-element/basic_no_animation_jetsnack.gif
      name: image-3
      :width: 300px

      **Figure 3.** Starting ``AnimatedContent`` without any shared element
      transitions.

   #. In order to make the shared elements animate between the two layouts,
      surround the ``AnimatedContent`` composable with
      ``SharedTransitionLayout``. The scopes from
      `SharedTransitionLayout  <#SharedTransitionLayout>`__
      and ``AnimatedContent`` are passed to the ``MainContent`` and
      ``DetailsContent``:

      .. code:: prettyprint

         var showDetails by remember {
             mutableStateOf(false)
         }
         SharedTransitionLayout {
             AnimatedContent(
                 showDetails,
                 label = "basic_transition"
             ) { targetState ->
                 if (!targetState) {
                     MainContent(
                         onShowDetails = {
                             showDetails = true
                         },
                         animatedVisibilityScope = this@AnimatedContent,
                         sharedTransitionScope = this@SharedTransitionLayout
                     )
                 } else {
                     DetailsContent(
                         onBack = {
                             showDetails = false
                         },
                         animatedVisibilityScope = this@AnimatedContent,
                         sharedTransitionScope = this@SharedTransitionLayout
                     )
                 }
             }
         }BasicSharedElementSnippets.kt

   #. Add
      `Modifier.sharedElement()  <#sharedElement>`__
      to your composable modifier chain on the two composables that match.
      Create a ``SharedContentState`` object and remember it with
      `rememberSharedContentState()  <#rememberSharedContentState>`__.
      The ``SharedContentState`` object is storing the unique key which
      determines the elements that are shared. Provide a unique key to identify
      the content, and use ``rememberSharedContentState()`` for the item to be
      remembered. The ``AnimatedContentScope`` is passed into the modifier,
      which is used to coordinate the animation.

      .. code:: prettyprint

         @Composable
         private fun MainContent(
             onShowDetails: () -> Unit,
             modifier: Modifier = Modifier,
             sharedTransitionScope: SharedTransitionScope,
             animatedVisibilityScope: AnimatedVisibilityScope
         ) {
             Row(
                 // ...
             ) {
                 with(sharedTransitionScope) {
                     Image(
                         painter = painterResource(id = R.drawable.cupcake),
                         contentDescription = "Cupcake",
                         modifier = Modifier
                             .sharedElement(
                                 rememberSharedContentState(key = "image"),
                                 animatedVisibilityScope = animatedVisibilityScope
                             )
                             .size(100.dp)
                             .clip(CircleShape),
                         contentScale = ContentScale.Crop
                     )
                     // ...
                 }
             }
         }

         @Composable
         private fun DetailsContent(
             modifier: Modifier = Modifier,
             onBack: () -> Unit,
             sharedTransitionScope: SharedTransitionScope,
             animatedVisibilityScope: AnimatedVisibilityScope
         ) {
             Column(
                 // ...
             ) {
                 with(sharedTransitionScope) {
                     Image(
                         painter = painterResource(id = R.drawable.cupcake),
                         contentDescription = "Cupcake",
                         modifier = Modifier
                             .sharedElement(
                                 rememberSharedContentState(key = "image"),
                                 animatedVisibilityScope = animatedVisibilityScope
                             )
                             .size(200.dp)
                             .clip(CircleShape),
                         contentScale = ContentScale.Crop
                     )
                     // ...
                 }
             }
         }BasicSharedElementSnippets.kt

   To get information on if a shared element match has occurred, extract
   ``rememberSharedContentState()`` into a variable, and query ``isMatchFound``.

   **Important:**\  The `order of where this modifier <#modifier-ordering>`__ is
   placed in the modifier chain is important. Put anything **you don't want to
   be shared before** the **sharedElement()** in the modifier chain.
   Which results in the following automatic animation:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/shared-element/basic_shared_element_jetsnack.gif
      name: image-4
      :width: 300px

      **Figure 4.** Basic example of a shared element transition between two
      composables.

   You may notice that the background color and size of the whole container
   still uses the default ``AnimatedContent`` settings.

   .. rubric:: Shared bounds versus shared element
      :name: shared-bounds

   `Modifier.sharedBounds()  <#sharedBounds>`__
   is similar to ``Modifier.sharedElement()``. However, the modifiers are
   different in the following ways:

   -  ``sharedBounds()`` is for content that is visually different but should
      share the same area between states, whereas ``sharedElement()`` expects
      the content to be the same.
   -  With ``sharedBounds()``, the content entering and exiting the screen is
      visible during the transition between the two states, whereas with
      ``sharedElement()`` only the target content is rendered in the
      transforming bounds. ``Modifier.sharedBounds()`` has ``enter`` and
      ``exit`` parameters for specifying how the content should transition,
      similar to how ``AnimatedContent`` works.
   -  The most common use case for ``sharedBounds()`` is the `container transform pattern <https://m3.material.io/styles/motion/transitions/transition-patterns#b67cba74-6240-4663-a423-d537b6d21187>`__,
      whereas for ``sharedElement()`` the example use case is a hero transition.
   -  When using ``Text`` composables, ``sharedBounds()`` is preferred to
      support font changes such as transitioning between italic and bold or
      color changes.

   From the previous example, adding ``Modifier.sharedBounds()`` onto the
   ``Row`` and ``Column`` in the two different scenarios will allow us to share
   the bounds of the two and perform the transition animation, allowing them to
   grow between each other:

   .. code:: prettyprint

      @Composable
      private fun MainContent(
          onShowDetails: () -> Unit,
          modifier: Modifier = Modifier,
          sharedTransitionScope: SharedTransitionScope,
          animatedVisibilityScope: AnimatedVisibilityScope
      ) {
          with(sharedTransitionScope) {
              Row(
                  modifier = Modifier
                      .padding(8.dp)
                      .sharedBounds(
                          rememberSharedContentState(key = "bounds"),
                          animatedVisibilityScope = animatedVisibilityScope,
                          enter = fadeIn(),
                          exit = fadeOut()
                      )
                      // ...
              ) {
                  // ...
              }
          }
      }

      @Composable
      private fun DetailsContent(
          modifier: Modifier = Modifier,
          onBack: () -> Unit,
          sharedTransitionScope: SharedTransitionScope,
          animatedVisibilityScope: AnimatedVisibilityScope
      ) {
          with(sharedTransitionScope) {
              Column(
                  modifier = Modifier
                      .sharedBounds(
                          rememberSharedContentState(key = "bounds"),
                          animatedVisibilityScope = animatedVisibilityScope,
                          enter = fadeIn(),
                          exit = fadeOut()
                      )
                      // ...

              ) {
                  // ...
              }
          }
      }SharedBoundsSnippets.kt

   .. container:: float
      :name: image-5

      .. container::

   .. rubric:: Unique keys
      :name: unique-keys

   When working with complex shared elements, it is a good practice to create a
   key that is not a string, because strings can be error prone to match. Each
   key must be unique for matches to occur. For example, in Jetsnack we have the
   following shared elements:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/animations/shared-element/unique_keys_shared_elements.jpeg
      name: image-6
      :width: 100.0%

      **Figure 6.** Image showing Jetsnack with annotations for each part of the
      UI.

   You could create an enum to represent the shared element type. In this
   example the whole snack card can also appear from multiple different places
   on the home screen, for example in a "Popular" and a "Recommended" section.
   You can create a key that has the ``snackId``, the ``origin`` ("Popular" /
   "Recommended"), and the ``type`` of the shared element that will be shared:

   .. code:: prettyprint

      data class SnackSharedElementKey(
          val snackId: Long,
          val origin: String,
          val type: SnackSharedElementType
      )

      enum class SnackSharedElementType {
          Bounds,
          Image,
          Title,
          Tagline,
          Background
      }

      @Composable
      fun SharedElementUniqueKey() {
          // ...
                  Box(modifier = Modifier
                      .sharedElement(
                          rememberSharedContentState(
                              key = SnackSharedElementKey(
                                  snackId = 1,
                                  origin = "latest",
                                  type = SnackSharedElementType.Image
                              )
                          ),
                          animatedVisibilityScope = this@AnimatedVisibility
                      ))
                  // ...
      }BasicSharedElementSnippets.kt

   Data classes are recommended for keys since they implement ``hashCode()`` and
   ``isEquals()``.

   **Important:**\  Be careful when working with lists of content - you will
   need to either append the item number to the key, or use a different unique
   identifier.

   .. rubric:: Understand Scopes
      :name: understand-scopes

   To use ``Modifier.sharedElement()``, the composable needs to be in a
   ``SharedTransitionScope``. The ``SharedTransitionLayout`` composable provides
   the ``SharedTransitionScope``. Make sure to place at the same top-level point
   in your UI hierarchy that contains the elements you want to share.

   Generally, the composables should also be placed inside an
   ``AnimatedVisibilityScope``. This is typically provided by using
   ``AnimatedContent`` to switch between composables or when using
   ``AnimatedVisibility`` directly, unless you `manage the visibility manually <#managing-visibility>`__. In order to use multiple scopes, you may
   want to save your required scopes in a
   `CompositionLocal  <#compositionlocal>`__, use `context receivers in Kotlin <https://github.com/Kotlin/KEEP/blob/master/proposals/context-receivers.md>`__,
   or pass the scopes as parameters to your functions.

   Use ``CompositionLocals`` in the scenario where you have multiple scopes to
   keep track of, or a deeply nested hierarchy. A ``CompositionLocal`` lets you
   choose the exact scopes to save and use. On the other hand, when you use
   context receivers, other layouts in your hierarchy might accidentally
   override the provided scopes. For example, if you have multiple nested
   ``AnimatedContent``, the scopes could be overridden.

   .. rubric:: Modifier ordering
      :name: modifier-ordering

   With ``Modifier.sharedElement()`` and ``Modifier.sharedBounds()`` the `order of your modifier  <#order-modifier-matters>`__
   chain matters, as with the rest of Compose. The incorrect placement of
   size-affecting modifiers can cause unexpected visual jumps during shared
   element matching.

   For example, if you place a padding modifier in a different position on two
   shared elements, there is a visual difference in the animation.

   .. code:: prettyprint

      var selectFirst by remember { mutableStateOf(true) }
      val key = remember { Any() }
      SharedTransitionLayout(
          Modifier
              .fillMaxSize()
              .padding(10.dp)
              .clickable {
                  selectFirst = !selectFirst
              }
      ) {
          AnimatedContent(targetState = selectFirst, label = "AnimatedContent") { targetState ->
              if (targetState) {
                  Box(
                      Modifier
                          .padding(12.dp)
                          .sharedBounds(
                              rememberSharedContentState(key = key),
                              animatedVisibilityScope = this@AnimatedContent
                          )
                          .border(2.dp, Color.Red)
                  ) {
                      Text(
                          "Hello",
                          fontSize = 20.sp
                      )
                  }
              } else {
                  Box(
                      Modifier
                          .offset(180.dp, 180.dp)
                          .sharedBounds(
                              rememberSharedContentState(
                                  key = key,
                              ),
                              animatedVisibilityScope = this@AnimatedContent
                          )
                          .border(2.dp, Color.Red)
                          // This padding is placed after sharedBounds, but it doesn't match the
                          // other shared elements modifier order, resulting in visual jumps
                          .padding(12.dp)

                  ) {
                      Text(
                          "Hello",
                          fontSize = 36.sp
                      )
                  }
              }
          }
      }BasicSharedElementSnippets.kt

   .. list-table::
      :header-rows: 1

      - 

         - Matched bounds
         - Unmatched bounds: Notice how the shared element animation appears a
            bit off as it needs to resize to the incorrect bounds
      - 

         - 
         - 

   The modifiers used **before** the shared element modifiers provide
   constraints to the shared element modifiers, which is then used to derive the
   initial and target bounds, and subsequently the bounds animation.

   The modifiers used **after** the shared element modifiers use the constraints
   from before to measure and calculate the child's target size. The shared
   element modifiers create a series of animated constraints to gradually
   transform the child from the initial size to the target size.

   The exception to this is if you use ``enter = scaleToSharedContentBounds()``
   for the animation, or ``Modifier.skipToLookaheadSize()`` on a composable. In
   this case, Compose lays out the child using the target constraints, and
   instead uses a scale factor to perform the animation instead of changing the
   layout size itself.

   **Important:**\  Be consistent with the order of modifiers on the matching
   items. Place size modifiers after the shared element modifiers, except when
   you use ``requiredSize()``. If you use ``requiredSize()`` after shared
   element modifiers, there will be no relayout of children during the
   transform, even if you use ``scaleInSharedContentToBounds()``. On the other
   hand, if ``requiredSize()`` is before shared element modifiers, the parent of
   ``requiredSize()`` can never observe the shared elements ``animatedSize``.

   .. rubric:: Manage the visibility of shared elements manually
      :name: managing-visibility

   In cases where you may not be using ``AnimatedVisibility`` or
   ``AnimatedContent``, you can manage the shared element visibility yourself.
   Use ``Modifier.sharedElementWithCallerManagedVisibility()`` and provide your
   own conditional that determines when an item should be visible or not:

   .. code:: prettyprint

      var selectFirst by remember { mutableStateOf(true) }
      val key = remember { Any() }
      SharedTransitionLayout(
          Modifier
              .fillMaxSize()
              .padding(10.dp)
              .clickable {
                  selectFirst = !selectFirst
              }
      ) {
          Box(
              Modifier
                  .sharedElementWithCallerManagedVisibility(
                      rememberSharedContentState(key = key),
                      !selectFirst
                  )
                  .background(Color.Red)
                  .size(100.dp)
          ) {
              Text(if (!selectFirst) "false" else "true", color = Color.White)
          }
          Box(
              Modifier
                  .offset(180.dp, 180.dp)
                  .sharedElementWithCallerManagedVisibility(
                      rememberSharedContentState(
                          key = key,
                      ),
                      selectFirst
                  )
                  .alpha(0.5f)
                  .background(Color.Blue)
                  .size(180.dp)
          ) {
              Text(if (selectFirst) "false" else "true", color = Color.White)
          }
      }BasicSharedElementSnippets.kt

   **Important:**\  The shared element remains in the UI tree even when
   ``visible == false``. The shared element starts a transition whenever its
   size or position changes as it has an active match. Therefore it is
   recommended to remove the shared element with ``visible == false`` from the
   tree once the transition is finished, by observing
   ``SharedTransitionScope.isTransitionActive``.

   .. rubric:: Current limitations
      :name: current-limitations

   These APIs have a few limitations. Most notably:

   -  No interoperability between Views and Compose is supported.
   -  There is no automatic animation support for the following:

      -  **Shared Image composables**:

         -  ``ContentScale`` is not animated by default. It snaps to the set end
            ``ContentScale``.

      -  **Shape clipping** - There is no built-in support for automatic
         animation between shapes - for example animating from a square to a
         circle as the item transitions.
      -  For the unsupported cases, use ``Modifier.sharedBounds()`` instead of
         ``sharedElement()`` and add ``Modifier.animateEnterExit()`` onto the
         items.

Last updated 2024-05-03 UTC.

/Customize
==========

.. https://developer.android.google.cn/develop/ui/compose/animation/shared-elements/customize?hl=en

.. container:: devsite-article-body clearfix

   To customize how the shared element transition animation runs, there are a
   few parameters that can be used to change how the shared elements transition.

   .. rubric:: Animation spec
      :name: animation-spec

   To change the animation spec used for the size and position movement, you can
   specify a different ``boundsTransform`` parameter on
   ``Modifier.sharedElement()``. This provides the initial ``Rect`` position and
   target ``Rect`` position.

   For example, to make the text in the preceding example to move with an arc
   motion, specify the ``boundsTransform`` parameter to use a
   `keyframes  <#animationspec>`__
   spec:

   .. code:: prettyprint

      val textBoundsTransform = BoundsTransform { initialBounds, targetBounds ->
          keyframes {
              durationMillis = boundsAnimationDurationMillis
              initialBounds at 0 using ArcMode.ArcBelow using FastOutSlowInEasing
              targetBounds at boundsAnimationDurationMillis
          }
      }
      Text(
          "Cupcake", fontSize = 28.sp,
          modifier = Modifier.sharedBounds(
              rememberSharedContentState(key = "title"),
              animatedVisibilityScope = animatedVisibilityScope,
              boundsTransform = textBoundsTransform
          )
      )CustomizeSharedElementsSnippets.kt

   You can use any ``AnimationSpec``. This example uses a ``keyframes`` spec.

   .. container:: float
      :name: image-1

      .. container::

   .. rubric:: Skip to final layout
      :name: skip-final

   By default, when transitioning between two layouts, the layout size animates
   between its start and final state. This may be undesirable behavior when
   animating content such as text.

   The following example illustrates the description text "Lorem Ipsum" entering
   the screen in two different ways. The first example the text reflows as it
   enters as the container grows in size, the second example the text does not
   reflow as it grows. Adding ``Modifier.skipToLookaheadSize()`` prevents the
   reflow as it grows.

   .. list-table::

      - 

         - No Modifier.skipToLookahead() - notice the "Lorem Ipsum" text
            reflowing
         - Modifier.skipToLookahead() - notice the "Lorem Ipsum" text keeps its
            final state at the start of the animation
      - 

         - 
         - 

   .. rubric:: Clip and overlays
      :name: clip-overlays

   An important concept when creating shared elements in Compose is that in
   order for them to share between different composables, **the rendering of the
   composable is elevated** into a layer overlay when the transition is started
   to its match in the destination. The effect of this is that it'll escape the
   parent's bounds and its layer transformations (for example the alpha and
   scale).

   It will render on top of other non-shared UI elements, once the transition is
   finished, the element will be dropped from the overlay to its own
   ``DrawScope``.

   **Important:**\  In order to avoid the shared element fading in or out with
   its parents as it transitions to the target state, the shared element is
   rendered into the ``SharedTransitionScope`` overlay when a match is found.
   To clip a shared element to a shape, use the standard ``Modifier.clip()``
   function. Place it after the ``sharedElement()``:

   .. code:: prettyprint

      Image(
          painter = painterResource(id = R.drawable.cupcake),
          contentDescription = "Cupcake",
          modifier = Modifier
              .size(100.dp)
              .sharedElement(
                  rememberSharedContentState(key = "image"),
                  animatedVisibilityScope = this@AnimatedContent
              )
              .clip(RoundedCornerShape(16.dp)),
          contentScale = ContentScale.Crop
      )CustomizeSharedElementsSnippets.kt

   If you need to ensure that a shared element never renders outside of a parent
   container, you can set ``clipInOverlayDuringTransition`` on
   ``sharedElement()``. By default, for nested shared bounds,
   ``clipInOverlayDuringTransition`` uses the clip path from the parent
   ``sharedBounds()``.

   To support keeping specific UI elements, such as a bottom bar or floating
   action button, always on top during a shared element transition, use
   `Modifier.renderInSharedTransitionScopeOverlay()  <#renderInSharedTransitionScopeOverlay>`__.
   By default, this modifier keeps the content in the overlay during the time
   when the shared transition is active.

   For example, in Jetsnack, the ``BottomAppBar`` needs to be placed on top of
   the shared element until such time as the screen is not visible. Adding the
   modifier onto the composable keeps it elevated.

   .. list-table::

      - 

         - Without ``Modifier.renderInSharedTransitionScopeOverlay()``
         - With ``Modifier.renderInSharedTransitionScopeOverlay()``
      - 

         - 
         - 

   Sometimes you might want your non-shared composable to animate away as well
   as remain on top of the other composables before the transition. In such
   cases, use ``renderInSharedTransitionScopeOverlay().animateEnterExit()`` to
   animate the composable out as the shared element transition runs:

   .. code:: prettyprint

      JetsnackBottomBar(
          modifier = Modifier
              .renderInSharedTransitionScopeOverlay(
                  zIndexInOverlay = 1f,
              )
              .animateEnterExit(
                  enter = fadeIn() + slideInVertically {
                      it
                  },
                  exit = fadeOut() + slideOutVertically {
                      it
                  }
              )
      )CustomizeSharedElementsSnippets.kt

   .. container:: float
      :name: image-1

      .. container::

   In the rare case that you'd like your shared element to not render in an
   overlay, you can set the ``renderInOverlayDuringTransition`` on
   ``sharedElement()`` to false.

   .. rubric:: Notify sibling layouts of changes to shared element size
      :name: notify-sibling

   By default, ``sharedBounds()`` and ``sharedElement()`` don't notify the
   parent container of any size changes as the layout transitions.

   In order to propagate size changes to the parent container as it transitions,
   change the ``placeHolderSize`` parameter to ``PlaceHolderSize.animatedSize``.
   Doing so causes the item to grow or shrink. All other items in the layout
   respond to the change.

   .. list-table::
      :widths: 40 40

      - 

         - ``PlaceholderSize.contentSize`` (default)
         - ``PlaceholderSize.animatedSize``

            (Notice how the other items in the list move down in response to the
            one item growing)
      - 

         - 
         - 

Last updated 2024-05-03 UTC.

/Common use cases
=================

.. https://developer.android.google.cn/develop/ui/compose/animation/shared-elements/common-use-cases?hl=en

.. container:: devsite-article-body clearfix

   When animating shared elements, there are some particular use cases that have
   specific recommendations.

   .. rubric:: Asynchronous images
      :name: async-images

   It's common to use a library to load up an image asynchronously, such as when
   using `Coil's ``AsyncImage``
   composable <https://coil-kt.github.io/coil/compose/>`__. For it to work
   seamlessly between two composables, its recommended to set the
   ``placeholderMemoryCacheKey()`` and ``memoryCacheKey()`` to the same key as a
   string derived from the shared element key, such that the cache key is the
   same for the matched shared elements. The new shared element will be using
   its match's cache as the placeholder until it loads the new image.

   The typical usage for ``AsyncImage`` is as follows:

   .. code:: prettyprint

      AsyncImage(
          model = ImageRequest.Builder(LocalContext.current)
              .data("your-image-url")
              .crossfade(true)
              .placeholderMemoryCacheKey("image-key") //  same key as shared element key
              .memoryCacheKey("image-key") // same key as shared element key
              .build(),
          placeholder = null,
          contentDescription = null,
          modifier = Modifier
              .size(120.dp)
              .sharedBounds(
                  rememberSharedContentState(
                      key = "image-key"
                  ),
                  animatedVisibilityScope = this
              )
      )SharedElementCommonUseCaseSnippets.kt

   .. rubric:: Text
      :name: text

   To animate ``fontSize`` changes, use ``Modifier.sharedBounds()``, with
   ``enter = fadeIn() + scaleInSharedContentToBounds()`` and
   ``exit = fadeOut() + scaleOutSharedContentToBounds()`` transitions makes the
   size change relatively fluid. The ``contentScale`` parameter can be tweaked
   to animate a specific font weight or style.

   .. code:: prettyprint

      Text(
          text = "This is an example of how to share text",
          modifier = Modifier
              .wrapContentWidth()
              .sharedBounds(
                  rememberSharedContentState(
                      key = "shared Text"
                  ),
                  animatedVisibilityScope = this,
                  enter = fadeIn() + scaleInSharedContentToBounds(),
                  exit = fadeOut() + scaleOutSharedContentToBounds()
              )
      )SharedElementCommonUseCaseSnippets.kt

   ``TextAlign`` changes are **not** animated by default. Instead use
   ``Modifier.wrapContentSize() / Modifier.wrapContentWidth()`` over using
   different ``TextAlign`` for shared transitions.

Last updated 2024-05-03 UTC.

/With navigation
================

.. https://developer.android.google.cn/develop/ui/compose/animation/shared-elements/navigation?hl=en

.. container:: devsite-article-body clearfix

   To use shared elements with the `navigation-compose dependency  <#navigation>`__, you can use the same concepts as
   previously shown: Use the ``Modifier.sharedElement()`` that takes an
   ``AnimatedVisibilityScope`` as a parameter. You can use this to decide what
   should be visible and when.

   .. container:: float
      :name: image-1

      .. container::

   The following is an example of using ``navigation-compose`` with shared
   elements:

   .. code:: prettyprint

      @Preview
      @Composable
      fun SharedElement_PredictiveBack() {
          SharedTransitionLayout {
              val navController = rememberNavController()
              NavHost(
                  navController = navController,
                  startDestination = "home"
              ) {
                  composable("home") {
                      HomeScreen(
                          navController,
                          this@SharedTransitionLayout,
                          this@composable
                      )
                  }
                  composable(
                      "details/{item}",
                      arguments = listOf(navArgument("item") { type = NavType.IntType })
                  ) { backStackEntry ->
                      val id = backStackEntry.arguments?.getInt("item")
                      val snack = listSnacks[id!!]
                      DetailsScreen(
                          navController,
                          id,
                          snack,
                          this@SharedTransitionLayout,
                          this@composable
                      )
                  }
              }
          }
      }

      @Composable
      private fun DetailsScreen(
          navController: NavHostController,
          id: Int,
          snack: Snack,
          sharedTransitionScope: SharedTransitionScope,
          animatedContentScope: AnimatedContentScope
      ) {
          with(sharedTransitionScope) {
              Column(
                  Modifier
                      .fillMaxSize()
                      .clickable {
                          navController.navigate("home")
                      }
              ) {
                  Image(
                      painterResource(id = snack.image),
                      contentDescription = snack.description,
                      contentScale = ContentScale.Crop,
                      modifier = Modifier.Companion
                          .sharedElement(
                              sharedTransitionScope.rememberSharedContentState(key = "image-$id"),
                              animatedVisibilityScope = animatedContentScope
                          )
                          .aspectRatio(1f)
                          .fillMaxWidth()
                  )
                  Text(
                      snack.name, fontSize = 18.sp,
                      modifier =
                      Modifier.Companion
                          .sharedElement(
                              sharedTransitionScope.rememberSharedContentState(key = "text-$id"),
                              animatedVisibilityScope = animatedContentScope
                          )
                          .fillMaxWidth()
                  )
              }
          }

      }

      @Composable
      private fun HomeScreen(
          navController: NavHostController,
          sharedTransitionScope: SharedTransitionScope,
          animatedContentScope: AnimatedContentScope
      ) {
          LazyColumn(
              modifier = Modifier
                  .fillMaxSize()
                  .padding(8.dp),
              verticalArrangement = Arrangement.spacedBy(8.dp)
          ) {
              itemsIndexed(listSnacks) { index, item ->
                  Row(
                      Modifier.clickable {
                          navController.navigate("details/$index")
                      }
                  ) {
                      Spacer(modifier = Modifier.width(8.dp))
                      with(sharedTransitionScope) {
                          Image(
                              painterResource(id = item.image),
                              contentDescription = item.description,
                              contentScale = ContentScale.Crop,
                              modifier = Modifier.Companion
                                  .sharedElement(
                                      sharedTransitionScope.rememberSharedContentState(key = "image-$index"),
                                      animatedVisibilityScope = animatedContentScope
                                  )
                                  .size(100.dp)
                          )
                          Spacer(modifier = Modifier.width(8.dp))
                          Text(
                              item.name, fontSize = 18.sp,
                              modifier = Modifier
                                  .align(Alignment.CenterVertically)
                                  .sharedElement(
                                      sharedTransitionScope.rememberSharedContentState(key = "text-$index"),
                                      animatedVisibilityScope = animatedContentScope,
                                  )
                          )
                      }
                  }
              }
          }
      }

      data class Snack(
          val name: String,
          val description: String,
          @DrawableRes val image: Int
      )SharedElementsWithNavigationSnippets.kt

   .. rubric:: Predictive back with shared elements
      :name: predictive-back

   If you want to use `predictive back  <#predictive-back-gesture>`__ with shared
   elements, use the latest `navigation-compose dependency  <#navigation>`__, using the snippet from the
   preceding section.

   Add ``android:enableOnBackInvokedCallback="true"`` to your
   ``AndroidManifest.xml`` file to enable predictive back:

   .. code:: prettyprint

      <manifest xmlns:android="http://schemas.android.com/apk/res/android">
         <uses-permission android:name="android.permission.INTERNET" />
         <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
         <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
             android:maxSdkVersion="28" />

         <application
             android:allowBackup="true"
             android:icon="@mipmap/ic_launcher"
             android:label="@string/app_name"
             android:roundIcon="@mipmap/ic_launcher_round"
             android:supportsRtl="true"
             android:enableOnBackInvokedCallback="true"
             android:theme="@style/Theme.Snippets">

   .. container:: float
      :name: image-1

      .. container::

Last updated 2024-05-03 UTC.

/Additional samples
===================

.. https://developer.android.google.cn/develop/ui/compose/animation/shared-elements/additional-samples?hl=en

.. container:: devsite-article-body clearfix

   .. list-table::
      :widths: 27 27 27
      :header-rows: 1

      - 

         - Sample
         - Demo
         - Link
      - 

         - Basic shared element with caller managed visibility:

            Two boxes moving around
         - 
         - `SharedElementWithCallerManagedVisibility <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation/integration-tests/animation-demos/src/main/java/androidx/compose/animation/demos/sharedelement/CallerManagedVisibilityDemo.kt;l=47>`__
      - 

         - Basic List to Detail

            Shifts remaining content to the left and grows to full size
         - 
         - `ListToDetailsDemo <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation/integration-tests/animation-demos/src/main/java/androidx/compose/animation/demos/sharedelement/ListToDetailsDemo.kt;l=62;drc=c5f36c050e6ec86e8a504031b3cd7602a11f4d9e>`__
      - 

         - Nested shared element
         - 
         - `NestedSharedElementDemo <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation/samples/src/main/java/androidx/compose/animation/samples/SharedTransitionSamples.kt;l=66;drc=c5f36c050e6ec86e8a504031b3cd7602a11f4d9e>`__
      - 

         - Container Transform and a demo from Lazy List to Details with nesting
         - 
         - `ContainerTransformDemo <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/animation/animation/integration-tests/animation-demos/src/main/java/androidx/compose/animation/demos/sharedelement/ContainerTransformDemo.kt;l=78;drc=c5f36c050e6ec86e8a504031b3cd7602a11f4d9e>`__
      - 

         - Complex Example - Jetsnack
         - 
         - `Jetsnack Sample <https://github.com/android/compose-samples/pull/1314>`__

Last updated 2024-05-03 UTC.

/Test animations
================

.. https://developer.android.google.cn/develop/ui/compose/animation/testing?hl=en

.. container:: devsite-article-body clearfix

   Compose offers ``ComposeTestRule`` that allows you to write tests for
   animations in a deterministic manner with full control over the test clock.
   This allows you to verify intermediate animation values. In addition, a test
   can run quicker than the actual duration of the animation.

   ``ComposeTestRule`` exposes its test clock as ``mainClock``. You can set the
   ``autoAdvance`` property to false to control the clock in your test code.
   After initiating the animation you want to test, the clock can be moved
   forward with ``advanceTimeBy``.

   One thing to note here is that ``advanceTimeBy`` doesn't move the clock
   exactly by the specified duration. Rather, it rounds it up to the nearest
   duration that is a multiplier of the frame duration.

   .. code:: prettyprint

      @get:Rule
      val rule = createComposeRule()

      @Test
      fun testAnimationWithClock() {
          // Pause animations
          rule.mainClock.autoAdvance = false
          var enabled by mutableStateOf(false)
          rule.setContent {
              val color by animateColorAsState(
                  targetValue = if (enabled) Color.Red else Color.Green,
                  animationSpec = tween(durationMillis = 250)
              )
              Box(Modifier.size(64.dp).background(color))
          }

          // Initiate the animation.
          enabled = true

          // Let the animation proceed.
          rule.mainClock.advanceTimeBy(50L)

          // Compare the result with the image showing the expected result.
          // `assertAgainGolden` needs to be implemented in your code.
          rule.onRoot().captureToImage().assertAgainstGolden()
      }AnimationTestingSnippets.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Testing your Compose layout  <#testing>`__
   -  `Other considerations  <#other-considerations>`__
   -  `Customize animations {:#customize-animations}  <#customize>`__

Last updated 2024-05-03 UTC.

/Tools
======

.. https://developer.android.google.cn/develop/ui/compose/animation/tooling?hl=en

.. container:: devsite-article-body clearfix

   Android Studio supports inspection of
   `animate*AsState  <#animate-as-state>`__,
   `CrossFade  <#crossfade>`__,
   `rememberInfiniteTransition  <#rememberinfinitetransition>`__,
   `AnimatedContent  <#animatedcontent>`__,
   `updateTransition  <#updateTransition>`__
   and
   `animatedVisibility  <#animatedvisibility>`__
   in `Animation Preview  <#animations>`__. You can do
   the following:

   -  Preview a transition frame by frame
   -  Inspect values for all animations in the transition
   -  Preview a transition between any initial and target state
   -  Inspect and coordinate multiple animations at once

   When you start Animation Preview, you see the "Animations" pane where you can
   run any transition included in the preview. The transition as well as each of
   its animation values is labeled with a default name. You can customize the
   label by specifying the ``label`` parameter in the ``updateTransition`` and
   the ``AnimatedVisibility`` functions. For more information, see `Animation Preview  <#animation-preview>`__.

   |Animation Preview panel|

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Value-based animations  <#value-based>`__
   -  `Animations in Compose  <#introduction>`__
   -  `Animation modifiers and composables  <#composables-modifiers>`__

Last updated 2024-05-03 UTC.

.. |Animation Preview panel| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-preview-overview.png

/Additional resources
=====================

.. https://developer.android.google.cn/develop/ui/compose/animation/resources?hl=en

.. container:: devsite-article-body clearfix

   To learn more about animation in Jetpack Compose, consult the following
   additional resources:

   .. rubric:: Animation cheat sheet
      :name: cheat-sheet

   The Compose animation cheat sheet is a quick reference of some of the most
   useful Compose animation APIs. The cheat sheet is also 
   `downloadable in PDF format <https://storage.googleapis.com/android-stories/compose/Compose_Animation_Cheat_Sheet.pdf>`__.

   |Useful Compose testing APIs|

   .. rubric:: Samples
      :name: samples

   .. rubric:: Blog posts
      :name: blog_posts

   -  `Customizing AnimatedContent in Jetpack Compose <https://medium.com/androiddevelopers/customizing-animatedcontent-in-jetpack-compose-629c67b45894>`__
   -  `Easing into Easing Curves in Compose <https://medium.com/androiddevelopers/easing-in-to-easing-curves-in-jetpack-compose-d72893eeeb4d>`__

   .. rubric:: Codelabs
      :name: codelabs

   -  `Jetpack Compose Animation  <#jetpack-compose-animation>`__

   .. rubric:: Videos
      :name: videos

   -  `Animation Reimagined <https://www.youtube.com/watch?v=Z_T1bVjhMLk>`__

Last updated 2024-03-25 UTC.

.. |Useful Compose testing APIs| image:: https://developer.android.google.cn/static/develop/ui/compose/images/compose_animation_cheat_sheet.png
   :width: 700px
   :target: https://developer.android.google.cn/static/develop/ui/compose/images/compose_animation_cheat_sheet.png

/Overview: Accessibility
========================

.. https://developer.android.google.cn/develop/ui/compose/accessibility?hl=en

.. container:: devsite-article-body clearfix

   Accessibility is crucial for creating inclusive apps that everyone can use.
   Compose provides a foundation for building accessible UIs that make your apps
   usable for everyone everywhere.

   .. rubric:: Key concepts
      :name: key_concepts

   -  **Semantics:** The system of representing the meaning of UI elements for
      accessibility services. This includes properties like descriptions,
      states, and actions a user can take.

   -  **Traversal:** The order in which accessibility services like TalkBack
      navigate through elements on screen. You can customize this order for
      better user experience.

   -  **Accessibility Actions:** Specific actions that a user can perform on a
      UI element, such as click, scroll, and dismiss. Your app communicates them
      to accessibility services.

   **Important:**\  If you are using views rather than Compose, or if you would
   like to know more about accessibility in Android generally, see the
   `accessibility guides  <#accessibility>`__.

   .. rubric:: Get started
      :name: get_started

   The foundation of Compose's accessibility model and tools is *semantics*. See
   the `Semantics in Compose  <#accessibility>`__ guide for
   more information.

   When developing your app, keep in mind from the beginning these key steps to
   improve the accessibility of your Compose app:

   -  `Consider minimum touch target sizes  <#minimum-target-sizes>`__\ **:**
      Make sure clickable and interactive elements are at least 48dp. This
      adheres to Material Design accessibility guidelines.
   -  `Add click labels  <#add-click-labels>`__\ **:**
      Describe the click behavior with the ``clickable`` modifier or
      ``semantics`` modifier if you don't have direct access to ``clickable``.
   -  `Describe visual elements  <#describe-visual>`__\ **:**
      Use the ``contentDescription`` parameter to textually describe icons and
      images. Set ``contentDescription`` to ``null`` for decorative elements.
   -  `Define headings  <#define-headings>`__\ **:**
      Use the ``semantics`` modifier property to mark elements as headings for
      easier navigation.
   -  `Control traversal order  <#traversal>`__\ **:** Use
      ``isTraversalGroup`` to mark groups of elements that should be read
      together. Utilize ``traversalIndex`` to further customize element order
      within those groups.

   For more, see the dedicated `Key steps to improve Compose accessibility  <#key-steps>`__ guide.

   .. rubric:: Tools
      :name: tools

   -  `TalkBack  <#talkback>`__\ **:**
      Google's screen reader for Android. Activate it to test how your app's
      semantics work for users relying on assistive technologies.
   -  `Layout Inspector  <#layout-inspector>`__\ **:**
      Visualize and debug your app's semantics tree.
   -  `Compose testing APIs  <#testing>`__\ **:** Write tests
      that interact with semantic elements to assert the accessibility of your
      Compose UIs.

   .. rubric:: Codelab
      :name: codelab

   To learn more about supporting accessibility in your Compose code, take the
   `Accessibility in Jetpack Compose  <#jetpack-compose-accessibility>`__ codelab.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Accessibility  <#accessibility>`__\ **:** Essential
      concepts and techniques common to all Android app development
   -  `Build Accessible Apps  <#apps>`__\ **:** Key
      steps you can take to make your app more accessible
   -  `Principles for improving app accessibility  <#apps>`__\ **:** Key
      principles to keep in mind when working to make your app more accessible
   -  `Testing for Accessibility  <#testing>`__\ **:** Test
      principles and tools for Android accessibility

Last updated 2024-04-23 UTC.

/Key steps
==========

.. https://developer.android.google.cn/develop/ui/compose/accessibility/key-steps?hl=en

.. container:: devsite-article-body clearfix

   To help people with accessibility needs use your app successfully, design
   your app to support key accessibility requirements.

   .. rubric:: Consider minimum touch target sizes
      :name: minimum-target-sizes

   **Note:**\  Touch target behavior changed in Compose 1.1.0. Earlier versions
   of the library might behave differently.
   Any on-screen element that someone can click, touch, or interact with should
   be large enough for reliable interaction. When sizing these elements, make
   sure to set the minimum size to 48dp to correctly follow the 
   `Material Design accessibility guidelines <https://m3.material.io/foundations/accessible-design/overview>`__.

   Material components—like
   `Checkbox  <#Checkbox>`__,
   `RadioButton  <#RadioButton>`__,
   `Switch  <#Switch>`__,
   `Slider  <#Slider>`__,
   and
   `Surface  <#Surface>`__—set
   this minimum size internally, but only when the component can receive user
   actions. For example, when a ``Checkbox`` has its ``onCheckedChange``
   parameter set to a non-null value, the checkbox includes padding to have a
   width and height of at least 48 dp.

   .. code:: prettyprint

      @Composable
      private fun CheckableCheckbox() {
          Checkbox(checked = true, onCheckedChange = {})
      }AccessibilitySnippets.kt

   |image-a11y-checkbox-padding|

   When the ``onCheckedChange`` parameter is set to null, the padding is not
   included, because the component cannot be interacted with directly.

   .. code:: prettyprint

      @Composable
      private fun NonClickableCheckbox() {
          Checkbox(checked = true, onCheckedChange = null)
      }AccessibilitySnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-checkbox-no-padding.png
      :figclass: screenshot

      Figure 1. A checkbox without padding.

   When implementing selection controls like ``Switch``, ``RadioButton``, or
   ``Checkbox``, you typically lift the clickable behavior to a parent
   container, set the click callback on the composable to ``null``, and add a
   ``toggleable`` or ``selectable`` modifier to the parent composable.

   .. code:: prettyprint

      @Composable
      private fun CheckableRow() {
          MaterialTheme {
              var checked by remember { mutableStateOf(false) }
              Row(
                  Modifier
                      .toggleable(
                          value = checked,
                          role = Role.Checkbox,
                          onValueChange = { checked = !checked }
                      )
                      .padding(16.dp)
                      .fillMaxWidth()
              ) {
                  Text("Option", Modifier.weight(1f))
                  Checkbox(checked = checked, onCheckedChange = null)
              }
          }
      }AccessibilitySnippets.kt

   |image-a11y-parent-clickable|

   When the size of a clickable composable is smaller than the minimum touch
   target size, Compose still increases the touch target size. It does so by
   expanding the touch target size outside of the boundaries of the composable.

   The following example contains a very small clickable ``Box``. The touch
   target area is automatically expanded beyond the boundaries of the ``Box``,
   so tapping next to the ``Box`` still triggers the click event.

   .. code:: prettyprint

      @Composable
      private fun SmallBox() {
          var clicked by remember { mutableStateOf(false) }
          Box(
              Modifier
                  .size(100.dp)
                  .background(if (clicked) Color.DarkGray else Color.LightGray)
          ) {
              Box(
                  Modifier
                      .align(Alignment.Center)
                      .clickable { clicked = !clicked }
                      .background(Color.Black)
                      .size(1.dp)
              )
          }
      }AccessibilitySnippets.kt

   |image-a11y-expanded-target|

   To prevent possible overlap between touch areas of different composables,
   always use a large enough minimum size for the composable. In the example,
   that would mean using the ``sizeIn`` modifier to set the minimum size for the
   inner box:

   .. code:: prettyprint

      @Composable
      private fun LargeBox() {
          var clicked by remember { mutableStateOf(false) }
          Box(
              Modifier
                  .size(100.dp)
                  .background(if (clicked) Color.DarkGray else Color.LightGray)
          ) {
              Box(
                  Modifier
                      .align(Alignment.Center)
                      .clickable { clicked = !clicked }
                      .background(Color.Black)
                      .sizeIn(minWidth = 48.dp, minHeight = 48.dp)
              )
          }
      }AccessibilitySnippets.kt

   |image-a11y-larger-inner-box|

   .. rubric:: Add click labels
      :name: add-click-labels

   You can use a click label to add semantic meaning to the click behavior of a
   composable. Click labels describe what happens when the user interacts with
   the composable. Accessibility services use click labels to help describe the
   app to users with specific needs.

   Set the click label by passing a parameter in the
   `clickable  <#clickable>`__
   modifier:

   .. code:: prettyprint

      @Composable
      private fun ArticleListItem(openArticle: () -> Unit) {
          Row(
              Modifier.clickable(
                  // R.string.action_read_article = "read article"
                  onClickLabel = stringResource(R.string.action_read_article),
                  onClick = openArticle
              )
          ) {
              // ..
          }
      }AccessibilitySnippets.kt

   Alternatively, if you don't have access to the clickable modifier, set the
   click label in the
   `semantics  <#semantics>`__
   modifier:

   .. code:: prettyprint

      @Composable
      private fun LowLevelClickLabel(openArticle: () -> Boolean) {
          // R.string.action_read_article = "read article"
          val readArticleLabel = stringResource(R.string.action_read_article)
          Canvas(
              Modifier.semantics {
                  onClick(label = readArticleLabel, action = openArticle)
              }
          ) {
              // ..
          }
      }AccessibilitySnippets.kt

   .. rubric:: Describe visual elements
      :name: describe-visual

   When you define an
   `Image  <#Image>`__
   or
   `Icon  <#Icon>`__
   composable, there is no automatic way for the Android framework to understand
   what the app is displaying. You need to pass a textual description of the
   visual element.

   Imagine a screen where the user can share the current page with friends. This
   screen contains a clickable share icon:

   |A strip of clickable icons, with the|

   Based on the icon alone, the Android framework can't describe it to a
   visually impaired user. The Android framework needs an additional textual
   description of the icon.

   The ``contentDescription`` parameter describes a visual element. Use a
   localized string, as it is visible to the user.

   .. code:: prettyprint

      @Composable
      private fun ShareButton(onClick: () -> Unit) {
          IconButton(onClick = onClick) {
              Icon(
                  imageVector = Icons.Filled.Share,
                  contentDescription = stringResource(R.string.label_share)
              )
          }
      }AccessibilitySnippets.kt

   Some visual elements are purely decorative and you might not want to
   communicate them to the user. When you set the ``contentDescription``
   parameter to ``null``, you indicate to the Android framework that this
   element does not have associated actions or state.

   .. code:: prettyprint

      @Composable
      private fun PostImage(post: Post, modifier: Modifier = Modifier) {
          val image = post.imageThumb ?: painterResource(R.drawable.placeholder_1_1)

          Image(
              painter = image,
              // Specify that this image has no semantic meaning
              contentDescription = null,
              modifier = modifier
                  .size(40.dp, 40.dp)
                  .clip(MaterialTheme.shapes.small)
          )
      }AccessibilitySnippets.kt

   It is up to you to decide whether a given visual element needs a
   ``contentDescription``. Ask yourself whether the element conveys information
   that the user will need to perform their task. If not, it's better to leave
   the description out.

   .. rubric:: Merge elements
      :name: merge-elements

   Accessibility services like Talkback and Switch Access allow users to move
   focus across elements on the screen. It is important that elements are
   focused at the right granularity. When every single low-level composable in
   your screen is focused independently, users have to interact a lot to move
   across the screen. If elements merge together too aggressively, users might
   not understand which elements belong together

   When you apply a
   `clickable  <#clickable>`__
   modifier to a composable, Compose automatically merges all elements the
   composable contains. This also holds for
   `ListItem  <#ListItem>`__;
   elements within a list item merge together, and accessibility services view
   them as one element.

   It is possible to have a set of composables that form a logical group, but
   that group is not clickable or part of a list item. You'd still want
   accessibility services to view them as one element. For example, imagine a
   composable that shows a user's avatar, their name, and some extra
   information:

   |A group of UI elements including a user's name. The name is selected.|

   You can enable Compose to merge these elements by using the
   ``mergeDescendants`` parameter in the ``semantics`` modifier. This way,
   accessibility services select only the merged element, and all semantics
   properties of the descendants are merged.

   .. code:: prettyprint

      @Composable
      private fun PostMetadata(metadata: Metadata) {
          // Merge elements below for accessibility purposes
          Row(modifier = Modifier.semantics(mergeDescendants = true) {}) {
              Image(
                  imageVector = Icons.Filled.AccountCircle,
                  contentDescription = null // decorative
              )
              Column {
                  Text(metadata.author.name)
                  Text("${metadata.date} • ${metadata.readTimeMinutes} min read")
              }
          }
      }AccessibilitySnippets.kt

   Accessibility services now focus on the whole container at once, merging
   their contents:

   |A group of UI elements including a user's name. All the elements are
   selected together.|

   **Note:**\  Descendants which themselves set ``mergeDescendants`` to ``true``
   aren't included in the merge. This prevents the merging from being too
   aggressive.

   .. rubric:: Add custom actions
      :name: custom-actions

   Take a look at the following list item:

   |A typical list item, containing an article title, author, and bookmark
   icon.|

   When you use a screen reader like Talkback to hear what's displayed on the
   screen, it first selects the whole item, and then the bookmark icon.

   |The list item, with all the elements selected together.|

   |The list item, with just the bookmark icon selected|

   In a long list, this can become very repetitive. A better approach is to
   define a custom action that allows a user to bookmark the item. Keep in mind
   that you also have to explicitly remove the behavior of the bookmark icon
   itself to make sure it isn't selected by the accessibility service. This is
   done with the
   `clearAndSetSemantics  <#clearAndSetSemantics>`__
   modifier:

   .. code:: prettyprint

      @Composable
      private fun PostCardSimple(
          /* ... */
          isFavorite: Boolean,
          onToggleFavorite: () -> Boolean
      ) {
          val actionLabel = stringResource(
              if (isFavorite) R.string.unfavorite else R.string.favorite
          )
          Row(
              modifier = Modifier
                  .clickable(onClick = { /* ... */ })
                  .semantics {
                      // Set any explicit semantic properties
                      customActions = listOf(
                          CustomAccessibilityAction(actionLabel, onToggleFavorite)
                      )
                  }
          ) {
              /* ... */
              BookmarkButton(
                  isBookmarked = isFavorite,
                  onClick = onToggleFavorite,
                  // Clear any semantics properties set on this node
                  modifier = Modifier.clearAndSetSemantics { }
              )
          }
      }AccessibilitySnippets.kt

   .. rubric:: Describe an element's state
      :name: describe_an_elements_state

   A composable can define a
   `stateDescription  <#stateDescription>`__
   for semantics which the Android framework uses to read out the state that the
   composable is in. For example, a toggleable composable can be in either a
   "checked" or an "unchecked" state. In some cases, you might want to override
   the default state description labels that Compose uses. You can do so by
   explicitly specifying the state description labels before defining a
   composable as toggleable:

   .. code:: prettyprint

      @Composable
      private fun TopicItem(itemTitle: String, selected: Boolean, onToggle: () -> Unit) {
          val stateSubscribed = stringResource(R.string.subscribed)
          val stateNotSubscribed = stringResource(R.string.not_subscribed)
          Row(
              modifier = Modifier
                  .semantics {
                      // Set any explicit semantic properties
                      stateDescription = if (selected) stateSubscribed else stateNotSubscribed
                  }
                  .toggleable(
                      value = selected,
                      onValueChange = { onToggle() }
                  )
          ) {
              /* ... */
          }
      }AccessibilitySnippets.kt

   .. rubric:: Define headings
      :name: define-headings

   Apps sometimes show a lot of content on one screen in a scrollable container.
   For example, a screen could show the full contents of an article that the
   user is reading:

   |Screenshot of a blog post, with the article text in a scrollable container.|

   Users with accessibility needs have difficulty navigating such a screen. To
   aid navigation, indicate which elements are headings. In the preceding
   example, each subsection title could be defined as a heading for
   accessibility. Some accessibility services, like Talkback, allow users to
   navigate directly from heading to heading.

   In Compose, you indicate that a composable is a
   `heading  <#heading>`__
   by defining its ``semantics`` property:

   .. code:: prettyprint

      @Composable
      private fun Subsection(text: String) {
          Text(
              text = text,
              style = MaterialTheme.typography.headlineSmall,
              modifier = Modifier.semantics { heading() }
          )
      }AccessibilitySnippets.kt

   .. rubric:: Handle custom composables
      :name: custom

   Whenever you replace certain Material components in your app with custom
   versions, you must keep accessibility considerations in mind.

   Say you're replacing the Material
   `Checkbox  <#Checkbox>`__
   with your own implementation. You could forget to add the
   `triStateToggleable  <#triStateToggleable>`__
   modifier, which handles the accessibility properties for this component.

   As a rule of thumb, look at the implementation of the component in the
   Material library and mimic any accessibility behavior that you can find.
   Additionally, make heavy use of Foundation modifiers, as opposed to UI level
   modifiers, as these include accessibility considerations out of the box.

   Test your custom component implementation with multiple accessibility
   services to verify its behavior.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Accessibility  <#accessibility>`__\ **:** Essential
      concepts and techniques common to all Android app development
   -  `Build Accessible Apps  <#apps>`__\ **:** Key
      steps you can take to make your app more accessible
   -  `Principles for improving app accessibility  <#apps>`__\ **:** Key
      principles to keep in mind when working to make your app more accessible
   -  `Testing for Accessibility  <#testing>`__\ **:** Test
      principles and tools for Android accessibility

Last updated 2024-04-15 UTC.

.. |image-a11y-checkbox-padding| image:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-checkbox-padding.png
.. |image-a11y-parent-clickable| image:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-parent-clickable.gif
.. |image-a11y-expanded-target| image:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-expanded-target.gif
.. |image-a11y-larger-inner-box| image:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-larger-inner-box.png
.. |A strip of clickable icons, with the| image:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-share-icon.png
   :width: 400px
.. |A group of UI elements including a user's name. The name is selected.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-userinfo-name-selected.png
   :width: 400px
.. |A group of UI elements including a user's name. All the elements are selected together.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-userinfo-all-selected.png
   :width: 400px
.. |A typical list item, containing an article title, author, and bookmark icon.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-list-item.png
   :width: 400px
.. |The list item, with all the elements selected together.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-list-item-all-selected.png
   :width: 400px
.. |The list item, with just the bookmark icon selected| image:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-list-item-bookmark-selected.png
   :width: 400px
.. |Screenshot of a blog post, with the article text in a scrollable container.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-blog.png
   :width: 400px

/Semantics
==========

.. https://developer.android.google.cn/develop/ui/compose/accessibility/semantics?hl=en

.. container:: devsite-article-body clearfix

   A composition `describes the UI  <#mental-model>`__ of your
   app and is produced by running composables. The composition is a
   tree-structure that consists of the composables that describe your UI.

   Next to the Composition, there exists a parallel tree, called the *semantics
   tree*. This tree describes your UI in an alternative manner that is
   understandable for `Accessibility  <#accessibility>`__
   services and for the `Testing  <#testing>`__ framework.
   Accessibility services use the tree to describe the app to users with a
   specific need. The testing framework uses the tree to interact with your app
   and make assertions about it. The Semantics tree does not contain the
   information on how to *draw* your composables, but it contains information
   about the **semantic meaning** of your composables.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/semantics-ui-tree.png
      :alt: A typical UI hierarchy and its semantics tree
      :width: 500px

      Figure 1. A typical UI hierarchy and its semantics tree.

   If your app consists of composables and modifiers from the Compose foundation
   and material library, the Semantics tree is automatically filled and
   generated for you. However **when you're adding custom low-level composables,
   you have to manually provide its semantics**. There might also be situations
   where your tree does not correctly or fully represent the meaning of the
   elements on the screen, in which case you can adapt the tree.

   Consider for example this custom calendar composable:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/semantics-calendar.png
      :alt: A custom calendar composable with selectable day elements
      :figclass: screenshot

      Figure 2. A custom calendar composable with selectable day elements.

   In this example, the entire calendar is implemented as a single low-level
   composable, using the ``Layout`` composable and drawing directly to the
   ``Canvas``. If you don't do anything else, accessibility services won't
   receive enough information about the content of the composable and the user's
   selection within the calendar. For example, if a user clicks on the day
   containing 17, the accessibility framework only receives the description
   information for the whole calendar control. In this case, the TalkBack
   accessibility service would announce "Calendar" or, only slightly better,
   "April Calendar" and the user would be left to wonder what day was selected.
   To make this composable more accessible, you'll need to add semantic
   information manually.

   .. rubric:: Semantics properties
      :name: properties

   All nodes in the UI tree with some semantic meaning have a parallel node in
   the Semantics tree. The node in the Semantics tree contains those properties
   that convey the meaning of the corresponding composable. For example, the
   ``Text`` composable contains a semantic property ``text``, because that's the
   *meaning* of that composable. An ``Icon`` contains a ``contentDescription``
   property (if set by the developer) that conveys in text what the meaning of
   the ``Icon`` is. Composables and modifiers that are built on top of the
   Compose `foundation library  <#compose-foundation>`__ already set the
   relevant properties for you. Optionally, set or override the properties
   yourself with the
   `semantics  <#semantics>`__
   and
   `clearAndSetSemantics  <#clearAndSetSemantics>`__
   modifiers. For example, add `custom accessibility actions  <#custom-actions>`__ to a node,
   provide an alternative `state description  <#anchor>`__ for a toggleable
   element, or indicate that a certain text composable should be considered as a
   `heading  <#define-headings>`__.

   To visualize the Semantics tree, use the `Layout Inspector  <#layout-inspector>`__ Tool or use the
   `printToLog()  <#printToLog>`__
   method inside tests. This prints the current Semantics tree inside Logcat.

   .. code:: prettyprint

      class MyComposeTest {

          @get:Rule
          val composeTestRule = createComposeRule()

          @Test
          fun MyTest() {
              // Start the app
              composeTestRule.setContent {
                  MyTheme {
                      Text("Hello world!")
                  }
              }
              // Log the full semantics tree
              composeTestRule.onRoot().printToLog("MY TAG")
          }
      }SemanticsSnippets.kt

   The output of this test would be:

   .. code:: devsite-disable-click-to-copy

          Printing with useUnmergedTree = 'false'
          Node #1 at (l=0.0, t=63.0, r=221.0, b=120.0)px
           |-Node #2 at (l=0.0, t=63.0, r=221.0, b=120.0)px
             Text = '[Hello world!]'
             Actions = [GetTextLayoutResult]

   Consider how semantics properties convey the meaning of a composable.
   Consider a ``Switch``. This is how it looks to the user:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/semantics-switches.png
      :figclass: screenshot
      :width: 500px

      Figure 3. A Switch in its "On" and "Off" state..

   To describe the *meaning* of this element, you could say the following:
   *"This is a Switch, which is a toggleable element in its 'On' state. You can
   click it to interact with it."*

   This is exactly what the semantics properties are used for. The semantics
   node of this Switch element contains the following properties, as visualized
   with the Layout Inspector:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/semantics-layout-inspector-switch.png
      :alt: Layout Inspector showing the Semantics properties of a Switch
      composable
      :figclass: screenshot
      :width: 500px

      Figure 4. Layout Inspector showing the Semantics properties of a Switch
      composable.

   The ``Role`` indicates the type of element. The ``StateDescription``
   describes how the "On" state should be referenced. By default this is a
   localized version of the word "On", but this can be made more specific (for
   example, "Enabled") based on the context. The ``ToggleableState`` is the
   current state of the Switch. The ``OnClick`` property references the method
   used to interact with this element. For a full list of semantics properties,
   check out the
   `SemanticsProperties  <#SemanticsProperties>`__
   object. For a full list of possible Accessibility Actions, check out the
   `SemanticsActions  <#SemanticsActions>`__
   object.

   Keeping track of the semantics properties of each composable in your app
   unlocks a lot of powerful possibilities. Some examples:

   -  Talkback uses the properties to read aloud what's shown on the screen and
      lets the user smoothly interact with it. For the Switch composable,
      Talkback might say: "On; Switch; double tap to toggle". The user can
      double tap their screen to toggle the Switch off.

   -  The Testing framework uses the properties to find nodes, interact with
      them, and make assertions. A sample test for the Switch could be:

      .. code:: prettyprint

         val mySwitch = SemanticsMatcher.expectValue(
             SemanticsProperties.Role, Role.Switch
         )
         composeTestRule.onNode(mySwitch)
             .performClick()
             .assertIsOff()SemanticsSnippets.kt

   **Note:**\  While developing your app, focus on getting the right *meaning*
   across using the semantics properties. Verify you get good results with
   multiple accessibility services. Add accessibility-affecting semantics
   properties only if you are able to test them thoroughly, otherwise rely on
   the semantics added by the Compose foundation library instead.

   .. rubric:: Merged and unmerged Semantics tree
      :name: merged-vs-unmerged

   As mentioned before, each composable in the UI tree might have zero or more
   semantics properties set. When a composable has no semantics properties set,
   it isn't included as part of the Semantics tree. That way, the Semantics tree
   contains only the nodes that actually contain semantic meaning. However,
   sometimes to convey the correct meaning of what is shown on the screen, it is
   also useful to merge certain sub-trees of nodes and treat them as one. That
   way you can reason about a set of nodes as a whole, instead of dealing with
   each descendant node individually. As a rule of thumb, each node in this tree
   represents a focusable element when using Accessibility services.

   An example of such a composable is ``Button``. You can reason about a button
   as a single element, even though it may contain multiple child nodes:

   .. code:: prettyprint

      Button(onClick = { /*TODO*/ }) {
          Icon(
              imageVector = Icons.Filled.Favorite,
              contentDescription = null
          )
          Spacer(Modifier.size(ButtonDefaults.IconSpacing))
          Text("Like")
      }SemanticsSnippets.kt

   In the Semantics tree, the properties of the button's descendants are merged,
   and the button is presented as a single leaf node in the tree:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/semantics-merged-single-leaf.png
      :alt: Merged single leaf semantics representation
      :figclass: screenshot
      :width: 300px

      Figure 5. Merged single leaf semantics representation.

   Composables and modifiers can indicate that they want to merge their
   descendants' semantics properties by calling
   ``Modifier.semantics (mergeDescendants = true) {}``. Setting this property to
   ``true`` indicates that the semantics properties should be merged. In the
   ``Button`` example, the ``Button`` composable uses the ``clickable`` modifier
   internally that includes this ``semantics`` modifier. Therefore, the
   descendant nodes of the button are merged. Read the accessibility
   documentation to learn more about when you should `change merging behavior  <#merge-elements>`__ in your
   composable.

   Several modifiers and composables in the Foundation and Material Compose
   libraries have this property set. For example, the ``clickable`` and
   ``toggleable`` modifiers will automatically merge their descendants. Also,
   the ``ListItem`` composable will merge its descendants.

   .. rubric:: Inspect the trees
      :name: inspecting-trees

   The semantics tree is in fact two different trees. There's a *merged*
   Semantics tree, which merges descendant nodes when ``mergeDescendants`` is
   set to ``true``. There's also an *unmerged* Semantics tree, which does not
   apply the merging, but keeps every node intact. Accessibility services use
   the unmerged tree and apply their own merging algorithms, taking into
   consideration the ``mergeDescendants`` property. The testing framework uses
   the merged tree by default.

   You can inspect both trees with the ``printToLog()`` method. By default, and
   as in the earlier examples, the merged tree is logged. To print the unmerged
   tree instead, set the ``useUnmergedTree`` parameter of the ``onRoot()``
   matcher to ``true``:

   .. code:: prettyprint

      composeTestRule.onRoot(useUnmergedTree = true).printToLog("MY TAG")SemanticsSnippets.kt

   The Layout Inspector lets you display both the merged and the unmerged
   Semantics tree, by selecting the preferred one in the view filter:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/semantics-layout-inspector-menu.png
      :alt: Layout Inspector view options, allowing both the display of the
      merged and the unmerged Semantics tree
      :figclass: screenshot
      :width: 500px

      Figure 6. Layout Inspector view options, allowing both the display of the
      merged and the unmerged Semantics tree.

   For each node in your tree, the Layout Inspector shows both the Merged
   Semantics and the Semantics set on that node in the properties panel:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/semantics-merged-and-set.png
      :alt: Semantics properties merged and set
      :figclass: screenshot
      :width: 300px

      Figure 7. Semantics properties merged and set.

   By default, matchers in the Testing Framework use the merged Semantics tree.
   That's why you can interact with a ``Button`` by matching the text shown
   inside it:

   .. code:: prettyprint

      composeTestRule.onNodeWithText("Like").performClick()SemanticsSnippets.kt

   Override this behavior by setting the ``useUnmergedTree`` parameter of the
   matchers to ``true``, as with the ``onRoot`` matcher.

   .. rubric:: Merge behavior
      :name: merge-behavior

   When a composable indicates that its descendants should be merged, how does
   this merging happen exactly?

   Each semantics property has a defined merging strategy. For example, the
   ``ContentDescription`` property adds all descendant ContentDescription values
   to a list. Check the merging strategy of a semantics property by checking its
   ``mergePolicy`` implementation in
   `SemanticsProperties.kt <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/semantics/SemanticsProperties.kt;l=35?q=semanticsproperties&sq=>`__.
   Properties can take on the parent or child value, merge the values into a
   list or string, not allow merging at all and throw an exception instead, or
   any other custom merging strategy.

   An important note is that descendants that themselves have set
   ``mergeDescendants = true`` are not included in the merge. Take a look at an
   example:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/semantics-dagger.png
      :alt: List item with image, some text, and a bookmark icon
      :figclass: screenshot
      :width: 300px

      Figure 8. List item with image, some text, and a bookmark icon.

   Here is a clickable list item. When the user presses the row, the app
   navigates to the article detail page, where the user can read the article.
   Inside the list item, there is a button to bookmark the article, which forms
   a nested clickable element, so the button shows up separately in the merged
   tree. The rest of the content in the row is merged:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/semantics-merged-vs-unmerged.png
      :alt: The merged tree contains multiple texts in a list inside the Row
      node. The unmerged tree contains separate nodes for each Text composable.
      :figclass: screenshot
      :width: 500px

      Figure 9. The merged tree contains multiple texts in a list inside the Row
      node. The unmerged tree contains separate nodes for each Text composable.

   .. rubric:: Adapt the Semantics tree
      :name: adapt

   As mentioned before, you can override or clear certain semantics properties
   or change the merging behavior of the tree. This is particularly relevant
   when you're creating your own custom components. Without setting the correct
   properties and merge behavior, your app might not be accessible, and tests
   might behave differently than you expect. To read more about some common use
   cases where you should adapt the Semantics tree, read the `accessibility documentation  <#accessibility>`__. If you want to learn
   more about testing, check the `testing guide  <#testing>`__.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Accessibility  <#accessibility>`__\ **:** Essential
      concepts and techniques common to all Android app development
   -  `Build Accessible Apps  <#apps>`__\ **:** Key
      steps you can take to make your app more accessible
   -  `Principles for improving app accessibility  <#apps>`__\ **:** Key
      principles to keep in mind when working to make your app more accessible
   -  `Testing for Accessibility  <#testing>`__\ **:** Test
      principles and tools for Android accessibility

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Accessibility in Compose  <#accessibility>`__
   -  `Material Design 2 in Compose  <#material>`__
   -  `Testing your Compose layout  <#testing>`__

Last updated 2024-04-15 UTC.

/Control traversal order
========================

.. https://developer.android.google.cn/develop/ui/compose/accessibility/traversal?hl=en

.. container:: devsite-article-body clearfix

   By default, accessibility screen reader behavior in a Compose app is
   implemented in expected reading order, which is usually left-to-right, then
   top-to-bottom. However, there are some types of app layouts where the
   algorithm can't determine the actual reading order without additional hints.
   In view-based apps, you can fix such issues using the ``traversalBefore`` and
   ``traversalAfter`` properties. Starting in `Compose 1.5  <#1.5.0-beta01>`__, Compose provides
   an equally flexible API, but with a new conceptual model.

   `isTraversalGroup  <#isTraversalGroup>`__
   and
   `traversalIndex  <#traversalIndex>`__
   are semantic properties that let you control accessibility and TalkBack focus
   order in scenarios where the default sorting algorithm is not appropriate.
   ``isTraversalGroup`` identifies semantically important groups, while
   ``traversalIndex`` adjusts the order of individual elements within those
   groups. You can use ``isTraversalGroup`` alone, or with ``traversalIndex``
   for further customization.

   Use ``isTraversalGroup`` and ``traversalIndex`` in your app to control screen
   reader traversal order.

   .. rubric:: Group elements with ``isTraversalGroup``
      :name: group-elements

   ``isTraversalGroup`` is a boolean property that defines whether a
   `semantics  <#semantics>`__ node is a traversal group. This
   type of node is one whose function is to serve as a boundary or border in
   organizing the node's children.

   Setting ``isTraversalGroup = true`` on a node means that all children of that
   node are visited before moving to other elements. You can set
   ``isTraversalGroup`` on non-screen reader focusable nodes, such as Columns,
   Rows, or Boxes.

   The following example uses ``isTraversalGroup``. It emits four text elements.
   The left two elements belong to one ``CardBox`` element, while the right two
   elements belong to another ``CardBox`` element:

   .. code:: prettyprint

      // CardBox() function takes in top and bottom sample text.
      @Composable
      fun CardBox(
          topSampleText: String,
          bottomSampleText: String,
          modifier: Modifier = Modifier
      ) {
          Box(modifier) {
              Column {
                  Text(topSampleText)
                  Text(bottomSampleText)
              }
          }
      }

      @Composable
      fun TraversalGroupDemo() {
          val topSampleText1 = "This sentence is in "
          val bottomSampleText1 = "the left column."
          val topSampleText2 = "This sentence is "
          val bottomSampleText2 = "on the right."
          Row {
              CardBox(
                  topSampleText1,
                  bottomSampleText1
              )
              CardBox(
                  topSampleText2,
                  bottomSampleText2
              )
          }
      }AccessibilitySnippets.kt

   The code produces output similar to the following:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/a11y-istraversalgroup-example.png
      name: image-1
      :alt: Layout with two columns of text, with the left column reading 'This
      sentence is in the left column' and the right column reading 'This
      sentence is on the right.'
      :width: 80.0%

      **Figure 1.** A layout with two sentences (one in the left column and one
      in the right column).

   Because no semantics have been set, the default behavior of the screen reader
   is to traverse elements from left to right and top to bottom. Because of this
   default, TalkBack reads out the sentence fragments in the wrong order:

   "This sentence is in" → "This sentence is" → "the left column." → "on the
   right."

   To order the fragments correctly, modify the original snippet to set
   ``isTraversalGroup`` to ``true``:

   .. code:: prettyprint

      @Composable
      fun TraversalGroupDemo2() {
          val topSampleText1 = "This sentence is in "
          val bottomSampleText1 = "the left column."
          val topSampleText2 = "This sentence is"
          val bottomSampleText2 = "on the right."
          Row {
              CardBox(
      //      1,
                  topSampleText1,
                  bottomSampleText1,
                  Modifier.semantics { isTraversalGroup = true }
              )
              CardBox(
      //      2,
                  topSampleText2,
                  bottomSampleText2,
                  Modifier.semantics { isTraversalGroup = true }
              )
          }
      }AccessibilitySnippets.kt

   Because ``isTraversalGroup`` is set specifically on each ``CardBox``, the
   ``CardBox`` boundaries apply when sorting their elements. In this case, the
   left ``CardBox`` is read first, followed by the right ``CardBox``.

   Now, TalkBack reads out the sentence fragments in the correct order:

   "This sentence is in" → "the left column." → "This sentence is" → "on the
   right."

   **Note:**\  ``isTraversalGroup`` is ``true`` by default on scroll containers
   (like ``LazyColumn``) and Material surfaces. If needed, you can disable this
   default behavior with ``Modifier.semantics { isTraversalGroup = false`` }.
   Setting ``isTraversalGroup`` to ``false`` reinstates the default traversal
   order.

   .. rubric:: Further customize traversal order
      :name: traversalIndex

   `traversalIndex  <#traversalIndex>`__
   is a float property that lets you customize TalkBack traversal order. If
   grouping elements together is not enough for TalkBack to work correctly, use
   ``traversalIndex`` in conjunction with ``isTraversalGroup`` to further
   customize screen reader ordering.

   The ``traversalIndex`` property has the following characteristics:

   -  Elements with lower ``traversalIndex`` values are prioritized first.
   -  Can be positive or negative.
   -  The default value is ``0f``.
   -  Only affects screen reader-focusable nodes, such as on-screen elements
      like text or buttons. For example, setting only ``traversalIndex`` on a
      column would have no effect, unless the column has ``isTraversalGroup``
      set on it as well.

   The following example shows how you can use ``traversalIndex`` and
   ``isTraversalGroup`` together.

   .. rubric:: Example: Traverse clock face
      :name: clock-face-example

   A clock face is a common scenario where standard traversal ordering does not
   work. The example in this section is a time picker, where a user can traverse
   through the numbers on a clock face and select digits for the hour and minute
   slots.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-clock-face.png
      name: image-2
      :alt: A clock face with a time picker above it.
      :width: 30.0%

      **Figure 2.** An image of a clock face.

   In the following simplified snippet, there is a ``CircularLayout`` in which
   12 numbers are drawn, starting with 12 and moving clockwise around the
   circle:

   .. code:: prettyprint

      @Composable
      fun ClockFaceDemo() {
          CircularLayout {
              repeat(12) { hour ->
                  ClockText(hour)
              }
          }
      }

      @Composable
      private fun ClockText(value: Int) {
          Box(modifier = Modifier) {
              Text((if (value == 0) 12 else value).toString())
          }
      }AccessibilitySnippets.kt

   Because the clock face is not read logically with the default left-to-right
   and top-to-bottom ordering, TalkBack reads the numbers out of order. To
   rectify this, use the incrementing counter value, as shown in the following
   snippet:

   .. code:: prettyprint

      @Composable
      fun ClockFaceDemo() {
          CircularLayout(Modifier.semantics { isTraversalGroup = true }) {
              repeat(12) { hour ->
                  ClockText(hour)
              }
          }
      }

      @Composable
      private fun ClockText(value: Int) {
          Box(modifier = Modifier.semantics { this.traversalIndex = value.toFloat() }) {
              Text((if (value == 0) 12 else value).toString())
          }
      }AccessibilitySnippets.kt

   To properly set the traversal ordering, first make the ``CircularLayout`` a
   traversal group and set ``isTraversalGroup = true``. Then, as each clock text
   is drawn onto the layout, set its corresponding ``traversalIndex`` to the
   counter value.

   Because the counter value continually increases, each clock value's
   ``traversalIndex`` is larger as numbers are added to the screen—the clock
   value 0 has a ``traversalIndex`` of 0, and the clock value 1 has a
   ``traversalIndex`` of 1. In this way, the order that TalkBack reads them in
   is set. Now, the numbers inside the ``CircularLayout`` are read in the
   expected order.

   Because the ``traversalIndexes`` that have been set are only relative to
   other indexes within the same grouping, the rest of the screen ordering has
   been preserved. In other words, the semantic changes shown in the preceding
   code snippet only modify the ordering within the clock face that has
   ``isTraversalGroup = true`` set.

   Note that, without setting ``CircularLayout's`` semantics to
   ``isTraversalGroup = true``, the ``traversalIndex`` changes still apply.
   However, without the ``CircularLayout`` to bind them, the twelve digits of
   the clock face are read last, after all other elements on the screen have
   been visited. This occurs because all other elements have a default
   ``traversalIndex`` of ``0f``, and the clock text elements are read after all
   other ``0f`` elements.

   .. rubric:: Example: Customize traversal order for floating action button
      :name: fab-example

   In this example, ``traversalIndex`` and ``isTraversalGroup`` control the
   traversal ordering of a Material Design floating action button (FAB). The
   basis of this example is the following layout:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/a11y-fab-example.png
      name: image-3
      :alt: A layout with a top app bar, sample text, a floating action button,
      and a bottom app bar.
      :width: 40.0%

      **Figure 3.** Layout with a top app bar, sample text, a floating action
      button, and a bottom app bar.

   By default, the layout in this example has the following TalkBack order:

   Top App Bar → Sample texts 0 through 6 → floating action button (FAB) →
   Bottom App Bar

   You may want the screen reader to first focus on the FAB. To set a
   ``traversalIndex`` on a Material element like a FAB, do the following:

   .. code:: prettyprint

      @Composable
      fun FloatingBox() {
          Box(modifier = Modifier.semantics { isTraversalGroup = true; traversalIndex = -1f }) {
              FloatingActionButton(onClick = {}) {
                  Icon(imageVector = Icons.Default.Add, contentDescription = "fab icon")
              }
          }
      }AccessibilitySnippets.kt

   In this snippet, creating a box with ``isTraversalGroup`` set to ``true`` and
   setting a ``traversalIndex`` on the same box (``-1f`` is lower than the
   default value of ``0f``) means that the floating box comes before all other
   on-screen elements.

   Next, you can put the floating box and other elements into a scaffold, which
   implements a Material Design layout:

   .. code:: prettyprint

      @OptIn(ExperimentalMaterial3Api::class)
      @Composable
      fun ColumnWithFABFirstDemo() {
          Scaffold(
              topBar = { TopAppBar(title = { Text("Top App Bar") }) },
              floatingActionButtonPosition = FabPosition.End,
              floatingActionButton = { FloatingBox() },
              content = { padding -> ContentColumn(padding = padding) },
              bottomBar = { BottomAppBar { Text("Bottom App Bar") } }
          )
      }AccessibilitySnippets.kt

   TalkBack interacts with the elements in the following order:

   FAB → Top App Bar → Sample texts 0 through 6 → Bottom App Bar

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Accessibility  <#accessibility>`__\ **:** Essential
      concepts and techniques common to all Android app development
   -  `Build Accessible Apps  <#apps>`__\ **:** Key
      steps you can take to make your app more accessible
   -  `Principles for improving app accessibility  <#apps>`__\ **:** Key
      principles to keep in mind when working to make your app more accessible
   -  `Testing for Accessibility  <#testing>`__\ **:** Test
      principles and tools for Android accessibility

Last updated 2024-04-15 UTC.

/Testing
========

.. https://developer.android.google.cn/develop/ui/compose/accessibility/testing?hl=en

.. container:: devsite-article-body clearfix

   When customizing your app's semantic properties, for example when following
   the use cases listed in the `semantics guide  <#semantics>`__, verify correctness
   and prevent regressions by using automated UI tests.

   For example, to test that an element's click label is set correctly, use the
   following code:

   .. code:: prettyprint

      @Test
      fun test() {
          composeTestRule
              .onNode(nodeMatcher)
              .assert(
                  SemanticsMatcher("onClickLabel is set correctly") {
                      it.config.getOrNull(SemanticsActions.OnClick)?.label == "My Click Label"
                  }
              )
      }AccessibilitySnippets.kt

   .. rubric:: Compose testing
      :name: compose_testing

   For more information on testing in Compose, see the dedicated `testing guides  <#testing>`__.

   .. rubric:: Additional resources
      :name: additional_resources

   -  `Accessibility  <#accessibility>`__\ **:** Essential
      concepts and techniques common to all Android app development
   -  `Build Accessible Apps  <#apps>`__\ **:** Key
      steps you can take to make your app more accessible
   -  `Principles for improving app accessibility  <#apps>`__\ **:** Key
      principles to keep in mind when working to make your app more accessible
   -  `Testing for Accessibility  <#testing>`__\ **:** Test
      principles and tools for Android accessibility

Last updated 2024-04-15 UTC.

/Overview: Touch and input
==========================

.. https://developer.android.google.cn/develop/ui/compose/touch-input?hl=en

.. container:: devsite-article-body clearfix

   Users interact with Android apps in various ways. For example, they can:

   -  Tap on a button with their finger.
   -  Navigate through a screen using their physical keyboard.
   -  Enter their email address using the on-screen keyboard.

   Compose has a lot of built-in support for these use cases, but in some
   scenarios you need to customize or extend the default behavior. In this
   section, you learn more about `pointer input  <#pointer-input>`__,
   `focus  <#focus>`__, and `handling interactions  <#handling-interactions>`__.

Last updated 2024-05-03 UTC.

/Overview: Pointer input
========================

.. https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input?hl=en

.. container:: devsite-article-body clearfix

   Compose provides a variety of APIs to help you detect gestures that are
   generated from user interactions. The APIs cover a wide range of use cases:

   -  Some of them are **high-level** and designed to cover the most commonly
      used gestures. For example, the
      `clickable  <#clickable>`__
      modifier allows easy detection of a click, and it also provides
      accessibility features and displays visual indicators when tapped (such as
      ripples).

   -  There are also less commonly used gesture detectors that offer more
      flexibility on a **lower level**, like
      `PointerInputScope.detectTapGestures  <#detectTapGestures>`__
      or
      `PointerInputScope.detectDragGestures  <#detectDragGestures>`__
      but don't include the extra features.

   Learn more about pointer input on the following pages:

   -  `Understand gestures  <#understand-gestures>`__
      gives an explanation of the core concepts playing a role when handling
      pointer input.
   -  `Tap and press  <#tap-and-press>`__
      expands on single pointer, single position events.
   -  `Scroll  <#scroll>`__ explains
      how to implement scrolling containers, and handles interoperability
      concerns.
   -  `Drag, swipe, and fling  <#drag-swipe-fling>`__
      shows different types of dragging of a single pointer.
   -  `Multi-touch  <#multi-touch>`__
      dives into situations where more than one pointer is used.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Enable user interactions  <#user-interactions>`__
   -  `Semantics in Compose  <#semantics>`__
   -  `Compose modifiers  <#modifiers>`__

Last updated 2024-03-25 UTC.

/Understand gestures
====================

.. https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/understand-gestures?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   There are several terms and concepts that are important to understand when
   working on gesture handling in an application. This page explains the terms
   pointers, pointer events, and gestures, and introduces the different
   abstraction levels for gestures. It also dives deeper into event consumption
   and propagation.

   .. rubric:: Definitions
      :name: definitions

   To understand the various concepts on this page, you need to understand some
   of the terminology used:

   -  **Pointer**: A physical object you can use to interact with your
      application. For mobile devices, the most common pointer is your finger
      interacting with the touchscreen. Alternatively, you could use a stylus to
      replace your finger. For large screens, you can use a mouse or trackpad to
      indirectly interact with the display. An input device must be able to
      "point" at a coordinate to be considered a pointer, so a keyboard, for
      example, cannot be considered a pointer. In Compose, the pointer type is
      included in pointer changes using
      `PointerType  <#PointerType>`__.
   -  **Pointer event**: Describes a low-level interaction of one or more
      pointers with the application at a given time. Any pointer interaction,
      such as putting a finger on the screen or dragging a mouse, would trigger
      an event. In Compose, all relevant information for such an event is
      contained in the
      `PointerEvent  <#PointerEvent>`__
      class.
   -  **Gesture**: A sequence of pointer events that can be interpreted as a
      single action. For example, a tap gesture can be considered a sequence of
      a down event followed by an up event. There are common gestures that are
      used by many apps, such as tap, drag, or transform, but you can also
      create your own custom gesture when needed.

   .. rubric:: Different levels of abstraction
      :name: different-levels

   Jetpack Compose provides different levels of abstraction for handling
   gestures. On the top level is *component support*. Composables like
   `Button  <#Button>`__
   automatically include gesture support. To add gesture support to custom
   components, you can add *gesture modifiers* like
   `clickable  <#clickable>`__
   to arbitrary composables. Finally, if you need a custom gesture, you can use
   the
   `pointerInput  <#pointerInput>`__
   modifier.

   As a rule, build on the highest level of abstraction that offers the
   functionality you need. This way, you benefit from the best practices
   included in the layer. For example, ``Button`` contains more semantic
   information, used for accessibility, than ``clickable``, which contains more
   information than a raw ``pointerInput`` implementation.

   **Note:**\  Choosing the right level of abstraction is a common theme in
   Compose. Read more in the documentation on `architectural layering  <#layering>`__.

   .. rubric:: Component support
      :name: component-support

   Many out-of-the-box components in Compose include some sort of internal
   gesture handling. For example, a
   `LazyColumn  <#LazyColumn>`__
   responds to drag gestures by scrolling its content, a
   `Button  <#Button>`__
   shows a ripple when you press down on it, and the
   `SwipeToDismiss  <#SwipeToDismiss>`__
   component contains swiping logic to dismiss an element. This type of gesture
   handling works automatically.

   Next to internal gesture handling, many components also require the caller to
   handle the gesture. For example, a
   `Button  <#Button>`__
   automatically detects taps and triggers a click event. You pass an
   ``onClick`` lambda to the ``Button`` to react to the gesture. Similarly, you
   add an ``onValueChange`` lambda to a
   `Slider  <#Slider>`__
   to react to the user dragging the slider handle.

   When it fits your use case, prefer gestures included in components, as they
   include out-of-the-box support for focus and accessibility, and they are
   well-tested. For example, a ``Button`` is marked in a special way so that
   accessibility services correctly describe it as a button, instead of just any
   clickable element:

   .. code:: prettyprint

      // Talkback: "Click me!, Button, double tap to activate"
      Button(onClick = { /* TODO */ }) { Text("Click me!") }
      // Talkback: "Click me!, double tap to activate"
      Box(Modifier.clickable { /* TODO */ }) { Text("Click me!") }UnderstandGesturesSnippets.kt

   To learn more about accessibility in Compose, see `Accessibility in Compose  <#accessibility>`__.

   .. rubric:: Add specific gestures to arbitrary composables with modifiers
      :name: add-specific

   You can apply gesture modifiers to any arbitrary composable to make the
   composable listen to gestures. For example, you can let a generic
   `Box  <#Box>`__
   handle tap gestures by making it
   `clickable  <#clickable>`__,
   or let a
   `Column  <#Column>`__
   handle vertical scroll by applying
   `verticalScroll  <#verticalScroll>`__.

   There are many modifiers to handle different types of gestures:

   -  `Handle taps and presses  <#tap-and-press>`__
      with the
      `clickable  <#clickable>`__,
      `combinedClickable  <#combinedClickable>`__,
      `selectable  <#selectable>`__
      ,
      `toggleable  <#toggleable>`__,
      and
      `triStateToggleable  <#triStateToggleable>`__
      modifiers.
   -  `Handle scrolling  <#scroll-modifiers>`__
      with the
      `horizontalScroll  <#horizontalScroll>`__,
      `verticalScroll  <#verticalScroll>`__,
      and more generic
      `scrollable  <#scrollable>`__
      modifiers.
   -  `Handle dragging  <#dragging>`__
      with the
      `draggable  <#draggable>`__
      and
      `swipeable  <#swipeable>`__
      modifier.
   -  `Handle multi-touch gestures  <#multitouch>`__ such as
      panning, rotating, and zooming, with the
      `transformable  <#transformable>`__
      modifier.

   As a rule, prefer out-of-the-box gesture modifiers over custom gesture
   handling. The modifiers add more functionality on top of the pure pointer
   event handling. For example, the ``clickable`` modifier not only adds
   detection of presses and taps, but also adds semantic information, visual
   indications on interactions, hovering, focus, and keyboard support. You can
   check the `source code of clickable <https://cs.android.com/android/platform/frameworks/support/+/androidx-main:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/Clickable.kt>`__
   to see how the functionality is being added.

   .. rubric:: Add custom gesture to arbitrary composables with ``pointerInput``
      modifier
      :name: add-custom

   Not every gesture is implemented with an out-of-the-box gesture modifier. For
   example, you cannot use a modifier to react to a drag after long-press, a
   control-click, or a three-finger tap. Instead, you can write your own gesture
   handler to identify these custom gestures. You can create a gesture handler
   with the
   `pointerInput  <#pointerInput>`__
   modifier, which gives you access to the raw pointer events.

   The following code listens to raw pointer events:

   .. code:: prettyprint

      @Composable
      private fun LogPointerEvents(filter: PointerEventType? = null) {
          var log by remember { mutableStateOf("") }
          Column {
              Text(log)
              Box(
                  Modifier
                      .size(100.dp)
                      .background(Color.Red)
                      .pointerInput(filter) {
                          awaitPointerEventScope {
                              while (true) {
                                  val event = awaitPointerEvent()
                                  // handle pointer event
                                  if (filter == null || event.type == filter) {
                                      log = "${event.type}, ${event.changes.first().position}"
                                  }
                              }
                          }
                      }
              )
          }
      }UnderstandGesturesSnippets.kt

   If you break this snippet up, the core components are:

   -  The
      `pointerInput  <#pointerInput>`__
      modifier. You pass it one or more *keys*. When the value of one of those
      keys changes, the modifier content lambda is re-executed. The sample
      passes an optional filter to the composable. If the value of that filter
      changes, the pointer event handler should be re-executed to make sure the
      right events are logged.
   -  `awaitPointerEventScope  <#AwaitPointerEventScope>`__
      creates a coroutine scope that can be used to wait for pointer events.
   -  `awaitPointerEvent  <#awaitPointerEvent>`__
      suspends the coroutine until a next pointer event occurs.

   Although listening to raw input events is powerful, it is also complex to
   write a custom gesture based on this raw data. To simplify the creation of
   custom gestures, many utility methods are available.

   .. rubric:: Detect full gestures
      :name: detect_full_gestures

   Instead of handling the raw pointer events, you can listen for specific
   gestures to occur and respond appropriately. The
   `AwaitPointerEventScope  <#AwaitPointerEventScope>`__
   provides methods for listening for:

   -  Press, tap, double tap, and long-press:
      `detectTapGestures  <#detectTapGestures>`__
   -  Drags:
      `detectHorizontalDragGestures  <#detectHorizontalDragGestures>`__,
      `detectVerticalDragGestures  <#detectVerticalDragGestures>`__,
      `detectDragGestures  <#detectDragGestures>`__
      and
      `detectDragGesturesAfterLongPress  <#detectDragGesturesAfterLongPress>`__
   -  Transforms:
      `detectTransformGestures  <#detectTransformGestures>`__

   These are top-level detectors, so you can't add multiple detectors within one
   ``pointerInput`` modifier. The following snippet only detects the taps, not
   the drags:

   .. code:: prettyprint

      var log by remember { mutableStateOf("") }
      Column {
          Text(log)
          Box(
              Modifier
                  .size(100.dp)
                  .background(Color.Red)
                  .pointerInput(Unit) {
                      detectTapGestures { log = "Tap!" }
                      // Never reached
                      detectDragGestures { _, _ -> log = "Dragging" }
                  }
          )
      }UnderstandGesturesSnippets.kt

   Internally, the ``detectTapGestures`` method blocks the coroutine, and the
   second detector is never reached. If you need to add more than one gesture
   listener to a composable, use separate ``pointerInput`` modifier instances
   instead:

   .. code:: prettyprint

      var log by remember { mutableStateOf("") }
      Column {
          Text(log)
          Box(
              Modifier
                  .size(100.dp)
                  .background(Color.Red)
                  .pointerInput(Unit) {
                      detectTapGestures { log = "Tap!" }
                  }
                  .pointerInput(Unit) {
                      // These drag events will correctly be triggered
                      detectDragGestures { _, _ -> log = "Dragging" }
                  }
          )
      }UnderstandGesturesSnippets.kt

   .. rubric:: Handle events per gesture
      :name: handle_events_per_gesture

   By definition, gestures start with a pointer down event. You can use the
   `awaitEachGesture  <#awaitEachGesture>`__
   helper method instead of the ``while(true)`` loop that passes through each
   raw event. The ``awaitEachGesture`` method restarts the containing block when
   all pointers have been lifted, indicating the gesture is completed:

   .. code:: prettyprint

      @Composable
      private fun SimpleClickable(onClick: () -> Unit) {
          Box(
              Modifier
                  .size(100.dp)
                  .pointerInput(onClick) {
                      awaitEachGesture {
                          awaitFirstDown().also { it.consume() }
                          val up = waitForUpOrCancellation()
                          if (up != null) {
                              up.consume()
                              onClick()
                          }
                      }
                  }
          )
      }UnderstandGesturesSnippets.kt

   In practice, you almost always want to use ``awaitEachGesture`` unless you're
   responding to pointer events without identifying gestures. An example of this
   is
   `hoverable  <#hoverable>`__,
   which does not respond to pointer down or up events— it just needs to know
   when a pointer enters or exits its bounds.

   .. rubric:: Wait for a specific event or sub-gesture
      :name: wait_for_a_specific_event_or_sub-gesture

   There's a set of methods that helps identify common parts of gestures:

   -  Suspend until a pointer goes down with
      `awaitFirstDown  <#awaitFirstDown>`__,
      or wait for all pointers to go up with
      `waitForUpOrCancellation  <#waitForUpOrCancellation>`__.
   -  Create a low-level drag listener using
      `awaitTouchSlopOrCancellation  <#awaitTouchSlopOrCancellation>`__
      and
      `awaitDragOrCancellation  <#awaitDragOrCancellation>`__.
      The gesture handler first suspends until the pointer reaches the touch
      slop and then suspends until a first drag event comes through. If you're
      only interested in drags along a single axis, use
      `awaitHorizontalTouchSlopOrCancellation  <#awaitHorizontalTouchSlopOrCancellation>`__
      plus
      `awaitHorizontalDragOrCancellation  <#awaitHorizontalDragOrCancellation>`__,
      or
      `awaitVerticalTouchSlopOrCancellation  <#awaitVerticalTouchSlopOrCancellation>`__
      plus
      `awaitVerticalDragOrCancellation  <#awaitVerticalDragOrCancellation>`__
      instead.
   -  Suspend until a long press happens with
      `awaitLongPressOrCancellation  <#awaitLongPressOrCancellation>`__.
   -  Use the
      `drag  <#drag>`__
      method to continuously listen to drag events, or
      `horizontalDrag  <#horizontalDrag>`__
      or
      `verticalDrag  <#verticalDrag>`__
      to listen to drag events on one axis.

   .. rubric:: Apply calculations for multi-touch events
      :name: apply_calculations_for_multi-touch_events

   When a user is performing a multi-touch gesture using more than one pointer,
   it's complex to understand the required transformation based on the raw
   values. If the
   `transformable  <#transformable>`__
   modifier or the
   `detectTransformGestures  <#detectTransformGestures>`__
   methods aren't giving enough fine-grained control for your use case, you can
   listen to the raw events and apply calculations on those. These helper
   methods are
   `calculateCentroid  <#calculateCentroid>`__,
   `calculateCentroidSize  <#calculateCentroidSize>`__,
   `calculatePan  <#calculatePan>`__,
   `calculateRotation  <#calculateRotation>`__,
   and
   `calculateZoom  <#calculateZoom>`__.

   .. rubric:: Event dispatching and hit-testing
      :name: event-dispatching

   Not every pointer event is sent to every ``pointerInput`` modifier. Event
   dispatching works as follows:

   -  Pointer events are dispatched to a *composable hierarchy*. The moment that
      a new pointer triggers its first pointer event, the system starts
      hit-testing the "eligible" composables. A composable is considered
      eligible when it has pointer input handling capabilities. Hit-testing
      flows from the top of the UI tree to the bottom. A composable is "hit"
      when the pointer event occurred within the bounds of that composable. This
      process results in a *chain of composables* that hit-test positively.
   -  By default, when there are multiple eligible composables on the same level
      of the tree, only the composable with the highest z-index is "hit". For
      example, when you add two overlapping ``Button`` composables to a ``Box``,
      only the one drawn on top receives any pointer events. You can
      theoretically override this behavior by creating your own
      `PointerInputModifierNode  <#sharePointerInputWithSiblings>`__
      implementation and setting
      `sharePointerInputWithSiblings  <#sharePointerInputWithSiblings>`__
      to true.
   -  Further events for the same pointer are dispatched *to that same chain of
      composables*, and flow according to `event propagation logic <#event-propagation>`__. The system does not perform any more
      hit-testing for this pointer. This means that each composable in the chain
      receives all events for that pointer, even when those occur outside of the
      bounds of that composable. Composables that are not in the chain never
      receive pointer events, even when the pointer is inside of their bounds.

   Hover events, triggered by a mouse or stylus hovering, are an exception to
   the rules defined here. Hover events are sent to any composable that they
   hit. So when a user hovers a pointer from the bounds of one composable to the
   next, instead of sending the events to that first composable, events are sent
   to the new composable.

   .. rubric:: Event consumption
      :name: event-consumption

   When more than one composable has a gesture handler assigned to it, those
   handlers shouldn't conflict. For example, take a look at this UI:

   |List item with an Image, a Column with two texts, and a Button.|

   When a user taps the bookmark button, the button's ``onClick`` lambda handles
   that gesture. When a user taps on any other part of the list item, the
   ``ListItem`` handles that gesture and navigates to the article. In terms of
   pointer input, the Button must *consume* this event, so that its parent knows
   not to react to it anymore. Gestures included in out-of-the-box components
   and the common gesture modifiers include this consumption behavior, but if
   you are writing your own custom gesture, you must consume events manually.
   You do this with the
   `PointerInputChange.consume  <#consume>`__
   method:

   .. code:: prettyprint

      Modifier.pointerInput(Unit) {

          awaitEachGesture {
              while (true) {
                  val event = awaitPointerEvent()
                  // consume all changes
                  event.changes.forEach { it.consume() }
              }
          }
      }UnderstandGesturesSnippets.kt

   Consuming an event does not stop the event propagation to other composables.
   A composable needs to explicitly ignore consumed events instead. When writing
   custom gestures, you should check if an event was already consumed by another
   element:

   .. code:: prettyprint

      Modifier.pointerInput(Unit) {
          awaitEachGesture {
              while (true) {
                  val event = awaitPointerEvent()
                  if (event.changes.any { it.isConsumed }) {
                      // A pointer is consumed by another gesture handler
                  } else {
                      // Handle unconsumed event
                  }
              }
          }
      }UnderstandGesturesSnippets.kt

   .. rubric:: Event propagation
      :name: event-propagation

   As mentioned before, pointer changes are passed to each composable that it
   hits. But if more than one such composable exists, in what order do the
   events propagate? If you take the example from the last section, this UI
   translates to the following UI tree, where only the ``ListItem`` and the
   ``Button`` respond to pointer events:

   |Tree structure. Top layer is ListItem, second layer has Image, Column, and
   Button, and the Column splits out into two Texts. ListItem and Button are
   highlighted.|

   Pointer events flow through each of these composables three times, during
   three "passes":

   -  In the **Initial pass**, the event flows from the top of the UI tree to
      the bottom. This flow allows a parent to intercept an event before the
      child can consume it. For example,
      `tooltips <https://m3.material.io/components/tooltips/guidelines#00e87770-86d0-436d-b50b-436ff3cefe75>`__
      need to `intercept a long-press <https://cs.android.com/android/platform/frameworks/support/+/androidx-main:compose/material3/material3/src/commonMain/kotlin/androidx/compose/material3/Tooltip.kt;l=214;drc=a4afaec2343443fe848dc44da26358a809f5d379>`__
      instead of passing it on to their children. In our example, ``ListItem``
      receives the event before the ``Button``.
   -  In the **Main pass**, the event flows from the UI tree's leaf nodes up to
      the root of the UI tree. This phase is where you normally consume
      gestures, and is the default pass when listening to events. Handling
      gestures in this pass means that leaf nodes takes precedence over their
      parents, which is the most logical behavior for most gestures. In our
      example, the ``Button`` receives the event before the ``ListItem``.
   -  In the **Final pass**, the event flows one more time from the top of the
      UI tree to the leaf nodes. This flow allows elements higher in the stack
      to respond to event consumption by their parent. For example, a button
      removes its ripple indication when a press turns into a drag of its
      scrollable parent.

   Visually, the event flow can be represented as follows:

   Once an input change is consumed, this information is passed from that point
   in the flow onwards:

   In code, you can specify the pass that you're interested in:

   .. code:: prettyprint

      Modifier.pointerInput(Unit) {
          awaitPointerEventScope {
              val eventOnInitialPass = awaitPointerEvent(PointerEventPass.Initial)
              val eventOnMainPass = awaitPointerEvent(PointerEventPass.Main) // default
              val eventOnFinalPass = awaitPointerEvent(PointerEventPass.Final)
          }
      }UnderstandGesturesSnippets.kt

   In this code snippet, the same identical event is returned by each of these
   await method calls, although the data about the consumption might have
   changed.

   .. rubric:: Test gestures
      :name: test-gestures

   In your test methods, you can manually send pointer events using the
   `performTouchInput  <#performTouchInput>`__
   method. This lets you perform either higher-level full gestures (such as
   pinch or long click) or low level gestures (such as moving the cursor by a
   certain amount of pixels):

   .. code:: prettyprint

      composeTestRule.onNodeWithTag("MyList").performTouchInput {
          swipeUp()
          swipeDown()
          click()
      }UnderstandGesturesSnippets.kt

   See the
   `performTouchInput  <#performTouchInput>`__
   documentation for more examples.

   .. rubric:: Learn more
      :name: learn-more

   You can learn more about gestures in Jetpack Compose from the following
   resources:

   -  `Types of gestures  <#gestures>`__
   -  `PointerInputChange  <#PointerInputChange>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Accessibility in Compose  <#accessibility>`__
   -  `Scroll  <#scroll>`__
   -  `Tap and press  <#tap-and-press>`__

Last updated 2024-03-25 UTC.

.. |List item with an Image, a Column with two texts, and a Button.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/jetnews_list_item.png
.. |Tree structure. Top layer is ListItem, second layer has Image, Column, and Button, and the Column splits out into two Texts. ListItem and Button are highlighted.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/ui_tree.png

/Tap and press
==============

.. https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/tap-and-press?hl=en

.. container:: devsite-article-body clearfix

   Many composables have built-in support for taps or clicks and include an
   ``onClick`` lambda. For example, you can create a clickable ``Surface`` that
   includes all Material Design behavior appropriate for interaction with
   surfaces:

   .. code:: prettyprint

      Surface(onClick = { /* handle click */ }) {
          Text("Click me!", Modifier.padding(24.dp))
      }TapAndPress.kt

   But clicks are not the only way a user can interact with composables. This
   page focuses on gestures that involve a single pointer, where the position of
   that pointer is not significant for the handling of that event. The following
   table lists these types of gestures:

   .. list-table::

      - 

         - **Gesture**
         - **Description**
      - 

         - Tap (or click)
         - Pointer goes down and then up
      - 

         - Double tap
         - Pointer goes down, up, down, up
      - 

         - Long-press
         - Pointer goes down, and is held for a longer time
      - 

         - Press
         - Pointer goes down

   .. rubric:: Respond to tap or click
      :name: respond-tap

   `clickable  <#clickable>`__
   is a commonly used modifier that makes a composable react to taps or clicks.
   This modifier also adds additional features, such as support for focus, mouse
   and stylus hovering, and a customizable visual indication when pressed. The
   modifier responds to "clicks" in the widest sense of the word-- not only with
   mouse or finger, but also click events through keyboard input or when using
   accessibility services.

   Imagine a grid of images, where an image shows full-screen when a user clicks
   on it:

   You can add the ``clickable`` modifier to each item in the grid to implement
   this behavior:

   .. code:: prettyprint

      @Composable
      private fun ImageGrid(photos: List<Photo>) {
          var activePhotoId by rememberSaveable { mutableStateOf<Int?>(null) }
          LazyVerticalGrid(columns = GridCells.Adaptive(minSize = 128.dp)) {
              items(photos, { it.id }) { photo ->
                  ImageItem(
                      photo,
                      Modifier.clickable { activePhotoId = photo.id }
                  )
              }
          }
          if (activePhotoId != null) {
              FullScreenImage(
                  photo = photos.first { it.id == activePhotoId },
                  onDismiss = { activePhotoId = null }
              )
          }
      }TapAndPress.kt

   The ``clickable`` modifier also adds additional behavior:

   -  ``interactionSource`` and ``indication``, which draw a ripple by default
      when a user taps the composable. Learn how to customize these on the
      `Handling user interactions  <#handling-interactions>`__
      page.
   -  Allows accessibility services to interact with the element by setting the
      semantics information.
   -  Supports keyboard or joystick interaction by allowing focus and pressing
      ``Enter`` or the center of the d-pad to interact.
   -  Make the element hoverable, so it responds to the mouse or stylus hovering
      over it.

   .. rubric:: Long-press to show a contextual context menu
      :name: long-press-show

   `combinedClickable  <#combinedClickable>`__
   lets you add double tap or long-press behavior in addition to normal click
   behavior. You can use ``combinedClickable`` to show a context menu when a
   user touches and holds a grid image:

   .. code:: prettyprint

      var contextMenuPhotoId by rememberSaveable { mutableStateOf<Int?>(null) }
      val haptics = LocalHapticFeedback.current
      LazyVerticalGrid(columns = GridCells.Adaptive(minSize = 128.dp)) {
          items(photos, { it.id }) { photo ->
              ImageItem(
                  photo,
                  Modifier
                      .combinedClickable(
                          onClick = { activePhotoId = photo.id },
                          onLongClick = {
                              haptics.performHapticFeedback(HapticFeedbackType.LongPress)
                              contextMenuPhotoId = photo.id
                          },
                          onLongClickLabel = stringResource(R.string.open_context_menu)
                      )
              )
          }
      }
      if (contextMenuPhotoId != null) {
          PhotoActionsSheet(
              photo = photos.first { it.id == contextMenuPhotoId },
              onDismissSheet = { contextMenuPhotoId = null }
          )
      }TapAndPress.kt

   **Note:**\  ``combinedClickable`` is an **experimental API**, which means the
   API surface might change in a future release of Compose. However, the
   modifier's behavior is considered stable.
   As a best practice, you should include haptic feedback when the user
   long-presses elements, which is why the snippet includes the
   ``performHapticFeedback`` invocation.

   .. rubric:: Dismiss a composable by tapping a scrim
      :name: dismiss-composable

   In the examples above, ``clickable`` and ``combinedClickable`` add useful
   functionality to your composables. They show a visual indication on
   interaction, respond to hovering, and include focus, keyboard, and
   accessibility support. But this extra behavior is not always desirable.

   Let's look at the image detail screen. The background should be
   semi-transparent and the user should be able to tap that background to
   dismiss the detail screen:

   In this case, that background should not have any visual indication on
   interaction, should not respond to hovering, should not be focusable, and its
   response to keyboard and accessibility events differ from that of a typical
   composable. Instead of trying to adapt the ``clickable`` behavior, you can
   drop down to a lower abstraction level and directly use the ``pointerInput``
   modifier in combination with the ``detectTapGestures`` method:

   .. code:: prettyprint

      @OptIn(ExperimentalComposeUiApi::class)
      @Composable
      private fun Scrim(onClose: () -> Unit, modifier: Modifier = Modifier) {
          val strClose = stringResource(R.string.close)
          Box(
              modifier
                  // handle pointer input
                  .pointerInput(onClose) { detectTapGestures { onClose() } }
                  // handle accessibility services
                  .semantics(mergeDescendants = true) {
                      contentDescription = strClose
                      onClick {
                          onClose()
                          true
                      }
                  }
                  // handle physical keyboard input
                  .onKeyEvent {
                      if (it.key == Key.Escape) {
                          onClose()
                          true
                      } else {
                          false
                      }
                  }
                  // draw scrim
                  .background(Color.DarkGray.copy(alpha = 0.75f))
          )
      }TapAndPress.kt

   As the key of the ``pointerInput`` modifier you pass the ``onClose`` lambda.
   This automatically re-executes the lambda, making sure the right callback is
   called when the user taps the scrim.

   .. rubric:: Double tap to zoom
      :name: double-tap

   Sometimes ``clickable`` and ``combinedClickable`` do not include enough
   information to respond to the interaction in the correct way. For example,
   composables might need access to the position within the composable's bounds
   where the interaction took place.

   Let's look at the image detail screen again. A best practice is to make it
   possible to zoom in on the image by double tapping:

   As you can see in the video, zooming in occurs around the position of the tap
   event. The result is different when we zoom in on the left part of the image
   versus the right part. We can use the ``pointerInput`` modifier in
   combination with the ``detectTapGestures`` to incorporate the tap position
   into our calculation:

   .. code:: prettyprint

      var zoomed by remember { mutableStateOf(false) }
      var zoomOffset by remember { mutableStateOf(Offset.Zero) }
      Image(
          painter = rememberAsyncImagePainter(model = photo.highResUrl),
          contentDescription = null,
          modifier = modifier
              .pointerInput(Unit) {
                  detectTapGestures(
                      onDoubleTap = { tapOffset ->
                          zoomOffset = if (zoomed) Offset.Zero else
                              calculateOffset(tapOffset, size)
                          zoomed = !zoomed
                      }
                  )
              }
              .graphicsLayer {
                  scaleX = if (zoomed) 2f else 1f
                  scaleY = if (zoomed) 2f else 1f
                  translationX = zoomOffset.x
                  translationY = zoomOffset.y
              }
      )TapAndPress.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Understand gestures  <#understand-gestures>`__
   -  `Material Design 2 in Compose  <#material>`__
   -  `Kotlin for Jetpack Compose  <#kotlin>`__

Last updated 2024-03-25 UTC.

/Scroll
=======

.. https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/scroll?hl=en

.. container:: devsite-article-body clearfix

   **Note:**\  If you want to show a list of items, consider using
   ``LazyColumn`` and ``LazyRow`` instead of these APIs. ``LazyColumn`` and
   ``LazyRow`` feature scrolling, and they are much more efficient than the
   scrolling modifier because they only compose the items as they're needed. See
   `Lists and grids documentation  <#lists>`__ for more
   information.

   .. rubric:: Scroll modifiers
      :name: scroll-modifiers

   The
   `verticalScroll  <#verticalScroll>`__
   and
   `horizontalScroll  <#horizontalScroll>`__
   modifiers provide the simplest way to allow the user to scroll an element
   when the bounds of its contents are larger than its maximum size constraints.
   With the ``verticalScroll`` and ``horizontalScroll`` modifiers you don't need
   to translate or offset the contents.

   .. code:: prettyprint

      @Composable
      private fun ScrollBoxes() {
          Column(
              modifier = Modifier
                  .background(Color.LightGray)
                  .size(100.dp)
                  .verticalScroll(rememberScrollState())
          ) {
              repeat(10) {
                  Text("Item $it", modifier = Modifier.padding(2.dp))
              }
          }
      }GesturesSnippets.kt

   |A simple vertical list responding to scroll gestures|

   The
   `ScrollState  <#ScrollState>`__
   allows you to change the scroll position or get its current state. To create
   it with default parameters, use
   `rememberScrollState()  <#rememberScrollState>`__.

   .. code:: prettyprint

      @Composable
      private fun ScrollBoxesSmooth() {
          // Smoothly scroll 100px on first composition
          val state = rememberScrollState()
          LaunchedEffect(Unit) { state.animateScrollTo(100) }

          Column(
              modifier = Modifier
                  .background(Color.LightGray)
                  .size(100.dp)
                  .padding(horizontal = 8.dp)
                  .verticalScroll(state)
          ) {
              repeat(10) {
                  Text("Item $it", modifier = Modifier.padding(2.dp))
              }
          }
      }GesturesSnippets.kt

   .. rubric:: Scrollable modifier
      :name: scrollable-modifier

   The
   `scrollable  <#scrollable>`__
   modifier differs from the scroll modifiers in that ``scrollable`` detects the
   scroll gestures, but does not offset its contents. A
   `ScrollableState  <#ScrollableState>`__
   is required for this modifier to work correctly. When constructing
   ``ScrollableState`` you must provide a ``consumeScrollDelta`` function which
   will be invoked on each scroll step (by gesture input, smooth scrolling or
   flinging) with the delta in pixels. This function must return the amount of
   scrolling distance consumed, to ensure the event is properly propagated in
   cases where there are nested elements that have the ``scrollable`` modifier.

   **Note:**\  The ``scrollable`` modifier does not affect the layout of the
   element it is applied to. This means that any changes to the element layout
   or its children must be handled through the delta provided by
   ``ScrollableState``. It is also important to note that ``scrollable`` is not
   opinionated about children's layouts, which means it doesn't need to measure
   the children in order to propagate the scrolling delta.
   The following snippet detects the gestures and displays a numerical value for
   an offset, but does not offset any elements:

   .. code:: prettyprint

      @Composable
      private fun ScrollableSample() {
          // actual composable state
          var offset by remember { mutableStateOf(0f) }
          Box(
              Modifier
                  .size(150.dp)
                  .scrollable(
                      orientation = Orientation.Vertical,
                      // Scrollable state: describes how to consume
                      // scrolling delta and update offset
                      state = rememberScrollableState { delta ->
                          offset += delta
                          delta
                      }
                  )
                  .background(Color.LightGray),
              contentAlignment = Alignment.Center
          ) {
              Text(offset.toString())
          }
      }GesturesSnippets.kt

   |A UI element detecting the finger press and displaying the numeric value for
   the finger's location|

   .. rubric:: Nested scrolling
      :name: nested-scrolling

   Compose supports *nested scrolling,* in which multiple elements react to a
   single scroll gesture. A typical example of nested scrolling is a list inside
   another list, and a more complex case is a `collapsing toolbar <https://material.io/components/app-bars-top#behavior>`__.

   .. rubric:: Automatic nested scrolling
      :name: auto-nested-scrolling

   Simple nested scrolling requires no action on your part. Gestures that
   initiate a scrolling action are propagated from children to parents
   automatically, such that when the child can't scroll any further, the gesture
   is handled by its parent element.

   Automatic nested scrolling is supported and provided out of the box by some
   of Compose's components and modifiers:
   `verticalScroll  <#verticalScroll>`__,
   `horizontalScroll  <#horizontalScroll>`__,
   `scrollable  <#scrollable>`__,
   ``Lazy`` APIs and ``TextField``. This means that when the user scrolls an
   inner child of nested components, the previous modifiers propagate the
   scrolling deltas to the parents that have nested scrolling support.

   The following example shows elements with a
   `verticalScroll  <#verticalScroll>`__
   modifier applied to it inside a container that also has a ``verticalScroll``
   modifier applied to it.

   .. code:: prettyprint

      @Composable
      private fun AutomaticNestedScroll() {
          val gradient = Brush.verticalGradient(0f to Color.Gray, 1000f to Color.White)
          Box(
              modifier = Modifier
                  .background(Color.LightGray)
                  .verticalScroll(rememberScrollState())
                  .padding(32.dp)
          ) {
              Column {
                  repeat(6) {
                      Box(
                          modifier = Modifier
                              .height(128.dp)
                              .verticalScroll(rememberScrollState())
                      ) {
                          Text(
                              "Scroll here",
                              modifier = Modifier
                                  .border(12.dp, Color.DarkGray)
                                  .background(brush = gradient)
                                  .padding(24.dp)
                                  .height(150.dp)
                          )
                      }
                  }
              }
          }
      }GesturesSnippets.kt

   |Two nested vertical scrolling UI elements, responding to gestures inside and
   outside the inner element|

   .. rubric:: Using the ``nestedScroll`` modifier
      :name: nestedscroll-modifier

   If you need to create an advanced coordinated scroll between multiple
   elements, the
   `nestedScroll  <#nestedScroll>`__
   modifier gives you more flexibility by defining a nested scrolling hierarchy.
   As mentioned in the previous section, some components have built-in nested
   scroll support. However, for composables that aren't scrollable
   automatically, such as ``Box`` or ``Column``, scroll deltas on such
   components won't propagate in the nested scroll system and the deltas won't
   reach the ``NestedScrollConnection`` nor the parent component. To resolve
   this, you can use ``nestedScroll`` to confer such support to other
   components, including custom components.

   .. rubric:: Nested scrolling interop (Starting with Compose 1.2.0)
      :name: nested-scrolling-interop

   When you try to nest scrollable ``View`` elements in scrollable composables,
   or the other way around, you might encounter issues. Most noticeable ones
   would happen when you scroll the child and reach its start or end bounds and
   expect the parent to take the scrolling over. However, this expected
   behaviour either might not happen or might not work as expected.

   This issue is a result of the expectations built in scrollable composables.
   Scrollable composables have a "nested-scroll-by-default" rule, which means
   that any scrollable container must participate in the nested scroll chain,
   both as a parent via
   `NestedScrollConnection  <#NestedScrollConnection>`__,
   and as a child via
   `NestedScrollDispatcher  <#NestedScrollDispatcher>`__.
   The child would then drive a nested scroll for the parent when the child is
   at the bound. As an example, this rule allows Compose ``Pager`` and Compose
   ``LazyRow`` to work well together. However, when interoperability scrolling
   is being done with ``ViewPager2`` or ``RecyclerView``, since these don’t
   implement
   `NestedScrollingParent3  <#NestedScrollingParent3>`__,
   the continuous scrolling from child to parent is not possible.

   To enable nested scrolling interop API between scrollable ``View`` elements
   and scrollable composables, nested in both directions, you can use the nested
   scrolling interop API to mitigate these issues, in the following scenarios.

   .. rubric:: A cooperating parent ``View`` containing a child ``ComposeView``
      :name: parent-view-child-compose

   A cooperating parent ``View`` is one that already implements
   `NestedScrollingParent3  <#NestedScrollingParent3>`__
   and therefore is able to receive scrolling deltas from a cooperating nested
   child composable. ``ComposeView`` would act as a child in this case and would
   need to (indirectly) implement
   `NestedScrollingChild3  <#NestedScrollingChild3>`__.
   One example of a cooperating parent is
   ``androidx.coordinatorlayout.widget.CoordinatorLayout``.

   If you need nested scrolling interoperability between scrollable ``View``
   parent containers and nested scrollable child composables, you can use
   `rememberNestedScrollInteropConnection()  <#rememberNestedScrollInteropConnection>`__.

   `rememberNestedScrollInteropConnection()  <#rememberNestedScrollInteropConnection>`__
   allows and remembers the
   `NestedScrollConnection  <#NestedScrollConnection>`__
   that enables nested scroll interoperability between a ``View`` parent that
   implements
   `NestedScrollingParent3  <#NestedScrollingParent3>`__
   and a Compose child. This should be used in conjunction with a
   `nestedScroll  <#nestedScroll>`__
   modifier. Since nested scrolling is enabled by default on the Compose side,
   you can use this connection to enable both nested scroll on the ``View`` side
   and add the necessary glue logic between ``Views`` and composables.

   A frequent use case is using ``CoordinatorLayout``,
   ``CollapsingToolbarLayout`` and a child composable, shown in this example:

   .. code:: prettyprint

      <androidx.coordinatorlayout.widget.CoordinatorLayout
          xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:app="http://schemas.android.com/apk/res-auto"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

          <com.google.android.material.appbar.AppBarLayout
              android:id="@+id/app_bar"
              android:layout_width="match_parent"
              android:layout_height="100dp"
              android:fitsSystemWindows="true">

              <com.google.android.material.appbar.CollapsingToolbarLayout
                  android:id="@+id/collapsing_toolbar_layout"
                  android:layout_width="match_parent"
                  android:layout_height="match_parent"
                  android:fitsSystemWindows="true"
                  app:layout_scrollFlags="scroll|exitUntilCollapsed">

                  <!--...-->

              </com.google.android.material.appbar.CollapsingToolbarLayout>

          </com.google.android.material.appbar.AppBarLayout>

          <androidx.compose.ui.platform.ComposeView
              android:id="@+id/compose_view"
              app:layout_behavior="@string/appbar_scrolling_view_behavior"
              android:layout_width="match_parent"
              android:layout_height="match_parent"/>

      </androidx.coordinatorlayout.widget.CoordinatorLayout>touchinput_gestures_nested_scroll_interop.xml

   In your Activity or Fragment, you need to set up your child composable and
   the required
   `NestedScrollConnection  <#NestedScrollConnection>`__:

   .. code:: prettyprint

      open class MainActivity : ComponentActivity() {
          @OptIn(ExperimentalComposeUiApi::class)
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContentView(R.layout.activity_main)
              findViewById<ComposeView>(R.id.compose_view).apply {
                  setContent {
                      val nestedScrollInterop = rememberNestedScrollInteropConnection()
                      // Add the nested scroll connection to your top level @Composable element
                      // using the nestedScroll modifier.
                      LazyColumn(modifier = Modifier.nestedScroll(nestedScrollInterop)) {
                          items(20) { item ->
                              Box(
                                  modifier = Modifier
                                      .padding(16.dp)
                                      .height(56.dp)
                                      .fillMaxWidth()
                                      .background(Color.Gray),
                                  contentAlignment = Alignment.Center
                              ) {
                                  Text(item.toString())
                              }
                          }
                      }
                  }
              }
          }
      }GesturesSnippets.kt

   .. rubric:: A parent composable containing a child ``AndroidView``
      :name: parent-compose-child-view

   This scenario covers the implementation of nested scrolling interop API on
   the Compose side - when you have a parent composable containing a child
   ``AndroidView``. The ``AndroidView`` implements
   `NestedScrollDispatcher  <#NestedScrollDispatcher>`__,
   since it acts as a child to a Compose scrolling parent, as well as
   `NestedScrollingParent3  <#NestedScrollingParent3>`__
   , since it acts as a parent to a ``View`` scrolling child. Compose parent
   will then be able to receive nested scroll deltas from a nested scrollable
   child ``View``.

   The following example shows how you can achieve nested scrolling interop in
   this scenario, along with a Compose collapsing toolbar:

   .. code:: prettyprint

      @Composable
      private fun NestedScrollInteropComposeParentWithAndroidChildExample() {
          val toolbarHeightPx = with(LocalDensity.current) { ToolbarHeight.roundToPx().toFloat() }
          val toolbarOffsetHeightPx = remember { mutableStateOf(0f) }

          // Sets up the nested scroll connection between the Box composable parent
          // and the child AndroidView containing the RecyclerView
          val nestedScrollConnection = remember {
              object : NestedScrollConnection {
                  override fun onPreScroll(available: Offset, source: NestedScrollSource): Offset {
                      // Updates the toolbar offset based on the scroll to enable
                      // collapsible behaviour
                      val delta = available.y
                      val newOffset = toolbarOffsetHeightPx.value + delta
                      toolbarOffsetHeightPx.value = newOffset.coerceIn(-toolbarHeightPx, 0f)
                      return Offset.Zero
                  }
              }
          }

          Box(
              Modifier
                  .fillMaxSize()
                  .nestedScroll(nestedScrollConnection)
          ) {
              TopAppBar(
                  modifier = Modifier
                      .height(ToolbarHeight)
                      .offset { IntOffset(x = 0, y = toolbarOffsetHeightPx.value.roundToInt()) }
              )

              AndroidView(
                  { context ->
                      LayoutInflater.from(context)
                          .inflate(R.layout.view_in_compose_nested_scroll_interop, null).apply {
                              with(findViewById<RecyclerView>(R.id.main_list)) {
                                  layoutManager = LinearLayoutManager(context, VERTICAL, false)
                                  adapter = NestedScrollInteropAdapter()
                              }
                          }.also {
                              // Nested scrolling interop is enabled when
                              // nested scroll is enabled for the root View
                              ViewCompat.setNestedScrollingEnabled(it, true)
                          }
                  },
                  // ...
              )
          }
      }

      private class NestedScrollInteropAdapter :
          Adapter<NestedScrollInteropAdapter.NestedScrollInteropViewHolder>() {
          val items = (1..10).map { it.toString() }

          override fun onCreateViewHolder(
              parent: ViewGroup,
              viewType: Int
          ): NestedScrollInteropViewHolder {
              return NestedScrollInteropViewHolder(
                  LayoutInflater.from(parent.context)
                      .inflate(R.layout.list_item, parent, false)
              )
          }

          override fun onBindViewHolder(holder: NestedScrollInteropViewHolder, position: Int) {
              // ...
          }

          class NestedScrollInteropViewHolder(view: View) : ViewHolder(view) {
              fun bind(item: String) {
                  // ...
              }
          }
          // ...
      }

   This example shows how you can use the API with a ``scrollable`` modifier:

   .. code:: prettyprint

      @Composable
      fun ViewInComposeNestedScrollInteropExample() {
          Box(
              Modifier
                  .fillMaxSize()
                  .scrollable(rememberScrollableState {
                      // View component deltas should be reflected in Compose
                      // components that participate in nested scrolling
                      it
                  }, Orientation.Vertical)
          ) {
              AndroidView(
                  { context ->
                      LayoutInflater.from(context)
                          .inflate(android.R.layout.list_item, null)
                          .apply {
                              // Nested scrolling interop is enabled when
                              // nested scroll is enabled for the root View
                              ViewCompat.setNestedScrollingEnabled(this, true)
                          }
                  }
              )
          }
      }

   And finally, this example shows how nested scrolling interop API is used with
   `BottomSheetDialogFragment  <#BottomSheetDialogFragment>`__
   to achieve a successful drag and dismiss behaviour:

   .. code:: prettyprint

      class BottomSheetFragment : BottomSheetDialogFragment() {

          override fun onCreateView(
              inflater: LayoutInflater,
              container: ViewGroup?,
              savedInstanceState: Bundle?
          ): View {
              val rootView: View = inflater.inflate(R.layout.fragment_bottom_sheet, container, false)

              rootView.findViewById<ComposeView>(R.id.compose_view).apply {
                  setContent {
                      val nestedScrollInterop = rememberNestedScrollInteropConnection()
                      LazyColumn(
                          Modifier
                              .nestedScroll(nestedScrollInterop)
                              .fillMaxSize()
                      ) {
                          item {
                              Text(text = "Bottom sheet title")
                          }
                          items(10) {
                              Text(
                                  text = "List item number $it",
                                  modifier = Modifier.fillMaxWidth()
                              )
                          }
                      }
                  }
                  return rootView
              }
          }
      }

   Note that
   `rememberNestedScrollInteropConnection()  <#rememberNestedScrollInteropConnection>`__
   will install a
   `NestedScrollConnection  <#NestedScrollConnection>`__
   in the element you attach it to. ``NestedScrollConnection`` is responsible
   for transmitting the deltas from the Compose level to the ``View`` level.
   This enables the element to participate in nested scrolling, but it doesn't
   enabling scrolling of elements automatically. To composables that aren't
   scrollable automatically, such as ``Box`` or ``Column``, scroll deltas on
   such components won't propagate in the nested scroll system and the deltas
   won't reach the ``NestedScrollConnection`` provided by
   ``rememberNestedScrollInteropConnection()``, therefore those deltas won't
   reach the parent ``View`` component. To resolve this, make sure you also set
   scrollable modifiers to these types of nested composables. You can refer to
   the previous section on `Nested scrolling  <#nestedscroll-modifier>`__ for more
   detailed information.

   .. rubric:: A non-cooperating parent ``View`` containing a child
      ``ComposeView``
      :name: non-coop-parent-view-child-compose

   A non-cooperating View is one that does not implement the necessary
   ``NestedScrolling`` interfaces on the ``View`` side. Note that this means
   that nested scrolling interoperability with these ``Views`` doesn't work out
   of the box. Non-cooperating ``Views`` are ``RecyclerView`` and
   ``ViewPager2``.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Understand gestures  <#understand-gestures>`__
   -  `Migrate ``CoordinatorLayout`` to
      Compose  <#coordinator-layout>`__
   -  `Using Views in Compose  <#views-in-compose>`__

Last updated 2024-03-25 UTC.

.. |A simple vertical list responding to scroll gestures| image:: https://developer.android.google.cn/static/develop/ui/compose/images/gestures-simplescroll.gif
.. |A UI element detecting the finger press and displaying the numeric value for the finger's location| image:: https://developer.android.google.cn/static/develop/ui/compose/images/gestures-numeric-offset.gif
.. |Two nested vertical scrolling UI elements, responding to gestures inside and outside the inner element| image:: https://developer.android.google.cn/static/develop/ui/compose/images/gestures-simple-nested-scroll.gif

/Drag, swipe, and fling
=======================

.. https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/drag-swipe-fling?hl=en

.. container:: devsite-article-body clearfix

   The
   `draggable  <#draggable>`__
   modifier is the high-level entry point to drag gestures in a single
   orientation, and reports the drag distance in pixels.

   It's important to note that this modifier is similar to ``scrollable``, in
   that it only detects the gesture. You need to hold the state and represent it
   on screen by, for example, moving the element via the
   `offset  <#offset>`__
   modifier:

   .. code:: prettyprint

      @Composable
      private fun DraggableText() {
          var offsetX by remember { mutableStateOf(0f) }
          Text(
              modifier = Modifier
                  .offset { IntOffset(offsetX.roundToInt(), 0) }
                  .draggable(
                      orientation = Orientation.Horizontal,
                      state = rememberDraggableState { delta ->
                          offsetX += delta
                      }
                  ),
              text = "Drag me!"
          )
      }GesturesSnippets.kt

   If you need to control the whole dragging gesture, consider using the drag
   gesture detector instead, via the
   `pointerInput  <#pointerInput>`__
   modifier.

   .. code:: prettyprint

      @Composable
      private fun DraggableTextLowLevel() {
          Box(modifier = Modifier.fillMaxSize()) {
              var offsetX by remember { mutableStateOf(0f) }
              var offsetY by remember { mutableStateOf(0f) }

              Box(
                  Modifier
                      .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
                      .background(Color.Blue)
                      .size(50.dp)
                      .pointerInput(Unit) {
                          detectDragGestures { change, dragAmount ->
                              change.consume()
                              offsetX += dragAmount.x
                              offsetY += dragAmount.y
                          }
                      }
              )
          }
      }GesturesSnippets.kt

   |A UI element being dragged by a finger press|

   .. rubric:: Swiping
      :name: swiping

   The
   `swipeable  <#swipeable>`__
   modifier lets you drag elements which, when released, animate towards
   typically two or more anchor points defined in an orientation. A common usage
   for this is to implement a ‘swipe-to-dismiss’ pattern.

   **Note:**\  The
   `swipeable  <#swipeable>`__
   APIs have been replaced by Foundation's
   `anchoredDraggable  <#anchoredDraggable>`__
   APIs in Jetpack Compose 1.6.0-alpha01. Read more in the `migration guide  <#migrate-swipeable>`__.
   It's important to note that this modifier does not move the element, it only
   detects the gesture. You need to hold the state and represent it on screen
   by, for example, moving the element via the
   `offset  <#offset>`__
   modifier.

   The swipeable state is required in the ``swipeable`` modifier, and can be
   created and remembered with
   `rememberSwipeableState()  <#rememberSwipeableState>`__.
   This state also provides a set of useful methods to programmatically animate
   to anchors (see
   `snapTo  <#snapTo>`__,
   `animateTo  <#animateTo>`__,
   `performFling  <#performFling>`__,
   and
   `performDrag  <#performDrag>`__)
   as well as properties to observe the dragging progress.

   The swipe gesture can be configured to have different threshold types, such
   as
   `FixedThreshold(Dp)  <#FixedThreshold>`__
   and
   `FractionalThreshold(Float)  <#FractionalThreshold>`__,
   and they can be different for each anchor point from-to combination.

   For more flexibility, you can configure the ``resistance`` when swiping past
   the bounds and, also, the ``velocityThreshold`` which will animate a swipe to
   the next state, even if the positional ``thresholds``\ have not been reached.

   .. code:: prettyprint

      @OptIn(ExperimentalMaterialApi::class)
      @Composable
      private fun SwipeableSample() {
          val width = 96.dp
          val squareSize = 48.dp

          val swipeableState = rememberSwipeableState(0)
          val sizePx = with(LocalDensity.current) { squareSize.toPx() }
          val anchors = mapOf(0f to 0, sizePx to 1) // Maps anchor points (in px) to states

          Box(
              modifier = Modifier
                  .width(width)
                  .swipeable(
                      state = swipeableState,
                      anchors = anchors,
                      thresholds = { _, _ -> FractionalThreshold(0.3f) },
                      orientation = Orientation.Horizontal
                  )
                  .background(Color.LightGray)
          ) {
              Box(
                  Modifier
                      .offset { IntOffset(swipeableState.offset.value.roundToInt(), 0) }
                      .size(squareSize)
                      .background(Color.DarkGray)
              )
          }
      }GesturesSnippets.kt

   |A UI element responding to a swipe gesture|

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Understand gestures  <#understand-gestures>`__
   -  `Advanced animation example: Gestures {:#gesture-and-animation}  <#advanced>`__
   -  `Value-based animations  <#value-based>`__

Last updated 2024-03-25 UTC.

.. |A UI element being dragged by a finger press| image:: https://developer.android.google.cn/static/develop/ui/compose/images/gestures-drag.gif
.. |A UI element responding to a swipe gesture| image:: https://developer.android.google.cn/static/develop/ui/compose/images/gestures-swipe.gif

/Migrate from Swipeable to AnchoredDraggable
============================================

.. https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/migrate-swipeable?hl=en

.. container:: devsite-article-body clearfix

   `Swipeable  <#SwipeableState>`__
   is a Compose Material API that helps you build components that can be swiped
   between discrete states, such as bottom sheets, drawers, or swipe-to-dismiss.
   To better support advanced use cases, such as anchors that depend on the size
   of a component, a successor was published in Compose-Foundation
   1.6.0-alpha01:
   `AnchoredDraggable  <#AnchoredDraggableState>`__.
   ``AnchoredDraggable`` is a Foundation API for building draggable components
   with anchored states, such as bottom sheets, drawers, or swipe-to-dismiss.

   Material's ``Swipeable`` APIs have been deprecated in favor of Foundation's
   ``AnchoredDraggable`` and will be removed in a future release. This guide
   describes how to migrate from ``Swipeable`` APIs to ``AnchoredDraggable``.

   **Note:**\  ``AnchoredDraggable`` is an experimental API. Experimental APIs
   may change in future.

   .. rubric:: Migrate ``SwipeableState`` to ``AnchoredDraggableState``
      :name: migrate-swipeablestate

   Start by identifying changes to your state holder. ``AnchoredDraggableState``
   cannot be inherited from, and the offset is represented as ``Float.NaN``
   before it is initialized.

   .. rubric:: Update your state holder
      :name: update-state-holder

   `AnchoredDraggableState  <#AnchoredDraggableState>`__
   is a final class, meaning it cannot be inherited from. If your existing
   component inherits from
   `SwipeableState  <#SwipeableState>`__,
   update your state holder to hold a reference to the
   ``AnchoredDraggableState`` instead of inheriting from it:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Swipeable
            :name: swipeable

         .. code:: prettyprint

            class MySwitchState: SwipeableState()

      .. container:: section

         .. rubric:: AnchoredDraggable
            :name: anchoreddraggable

         .. code:: prettyprint

            class MySwitchState {
                private val anchoredDraggableState = AnchoredDraggableState(...)
            }

   Since your state holder does not inherit from ``SwipeableState`` anymore, you
   might have to expose APIs yourself. The most common APIs you can use are
   `offset  <#offset>`__,
   `progress  <#progress>`__,
   `currentValue  <#currentValue>`__
   and
   `targetValue  <#targetValue>`__.

   .. rubric:: Access the offset
      :name: access-offset

   Unlike in ``Swipeable``, ``AnchoredDraggableState``'s ``offset`` is
   ``Float.NaN`` before it is initialized. In ``AnchoredDraggable``, the anchors
   can be passed to ``AnchoredDraggableState``'s constructor or updated through
   `AnchoredDraggableState#updateAnchors  <#updateAnchors>`__.
   Passing the anchors to ``AnchoredDraggableState``'s constructor initializes
   the offset immediately.

   If your anchors depend on layout or could change, use
   ``AnchoredDraggableState#updateAnchors`` to avoid recreating the state when
   the anchors change.

   If you use ``updateAnchors``, the offset will be ``Float.NaN`` before passing
   the anchors to ``updateAnchors``. To avoid accidentally passing ``Float.NaN``
   to components, use
   `AnchoredDraggableState#requireOffset  <#requireOffset>`__
   to require that the offset has been initialized when reading it. This helps
   you catch inconsistencies or possible bugs early on.

   .. code:: prettyprint

      @Composable
      fun AnchoredDraggableBox() {
          val state = remember { AnchoredDraggableState(...) }
          val density = LocalDensity.current
          val anchors = remember { DraggableAnchors { ... } }
          SideEffect {
              state.updateAnchors(anchors)
          }
          Box(
              Modifier.offset { IntOffset(x = state.requireOffset(), y = 0) }
          }
      }

   **Note:**\  Overflow support for ``AnchoredDraggable`` is currently being
   implemented. See `b/288084801 <https://issuetracker.google.com/288084801>`__
   for the latest status.

   .. rubric:: Migrate ``Modifier.swipeable`` to ``Modifier.anchoredDraggable``
      :name: migrate-modifier.swipeable

   `Modifier.anchoredDraggable()  <#anchoredDraggable>`__
   replaces
   `Modifier.swipeable  <#swipeable>`__.
   Some of ``Modifier.swipeable()``'s parameters have moved to
   ``AnchoredDraggableState`` directly, as described in the following sections.

   .. rubric:: Define anchors
      :name: define-anchors

   Define the anchors using the
   `DraggableAnchors  <#DraggableAnchors>`__
   builder method. Then, pass them to ``AnchoredDraggableState#updateAnchors``
   or ``AnchoredDraggableState``'s constructor:

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Constructor
            :name: constructor

         .. code:: prettyprint

            enum class DragValue { Start, Center, End }

            @Composable
            fun AnchoredDraggableBox() {
                val anchors = DraggableAnchors {
                    Start at -100.dp.toPx()
                    Center at 0f
                    End at 100.dp.toPx()
                }
                val state = remember {
                    AnchoredDraggableState(anchors = anchors)
                }
                Box(
                    Modifier.offset { IntOffset(x = state.requireOffset(), y = 0) }
                )
            }

      .. container:: section

         .. rubric:: updateAnchors
            :name: updateanchors

         .. code:: prettyprint

            enum class DragValue { Start, Center, End }

            @Composable
            fun AnchoredDraggableBox() {
                val state = remember { AnchoredDraggableState(...) }
                val density = LocalDensity.current
                val anchors = with (density) {
                    DraggableAnchors {
                        Start at -100.dp.toPx()
                        Center at 0f
                        End at 100.dp.toPx()
                    }
                }
                SideEffect {
                    state.updateAnchors(anchors)
                }
                Box(
                    Modifier.offset { IntOffset(x = state.requireOffset(), y = 0) }
                )
            }

   If the anchors are static, pass them to the constructor. If they depend on
   layout, or are not static, use ``updateAnchors``.

   .. rubric:: Define positional thresholds
      :name: define-positional-thresholds

   The type and name of the thresholds parameter has changed. Instead of having
   a separate
   `ThresholdConfig  <#ThresholdConfig>`__
   interface, ``AnchoredDraggableState`` has a ``positionalThreshold`` parameter
   that takes a lambda function that returns the position of the threshold. For
   example, a positional threshold of 50% could be expressed as:

   .. code:: prettyprint

      val anchoredDraggableState = AnchoredDraggableState(
          positionalThreshold = { distance -> distance * 0.5f },
          ...
      )

   A positional threshold of ``56dp`` could be expressed as:

   .. code:: prettyprint

      val density = LocalDensity.current
      val anchoredDraggableState = AnchoredDraggableState(
          positionalThreshold = { with(density) { 56.dp.toPx() } },
          ...
      )

   .. rubric:: Define velocity thresholds
      :name: define-velocity-thresholds

   Velocity thresholds are also passed to ``AnchoredDraggableState``'s
   constructor, and also expressed as a lambda:

   .. code:: prettyprint

      val density = LocalDensity.current
      val anchoredDraggableState = AnchoredDraggableState(
          velocityThreshold = { with(density) { 125.dp.toPx() } },
          ...
      )

   .. rubric:: Changes to the API surface
      :name: changes-api

   Find an overview of changes to the API surface below.

   .. rubric:: ``AnchoredDraggableState``
      :name: changes-api-state

   .. list-table::
      :widths: 40 40
      :header-rows: 1

      - 

         - ``SwipeableState``
         - ``AnchoredDraggableState``
      - 

         - ``open class SwipeableState(initialValue: T, animationSpec: AnimationSpec = …, confirmStateChange: (T) -> Boolean = …)``
         - ``class AnchoredDraggableState( initialValue: T, animationSpec: AnimationSpec = …, confirmValueChange: (T) -> Boolean = …, positionalThreshold: Density.(Float) -> Float = …, velocityThreshold: Dp = …)``
      - 

         - ``offset: State``
         - | ``offset: Float``
            | ``requireOffset()``
      - 

         - ``progress: SwipeProgress``
         - ``progress: Float [0f..1f``]
      - 

         - ``currentValue: T``
         - ``currentValue: T``
      - 

         - ``targetValue: T``
         - ``targetValue: T``
      - 

         - ``direction: Float [-1f, 0f, 1f``]
         - N/A
      - 

         - | ``suspend animateTo(``
            | ``targetValue: T,``
            | ``anim: AnimationSpec = …)``
         - | ``suspend animateTo(``
            | ``targetState: T,``
            | ``velocity: Float =``
            | ``lastVelocity)``
      - 

         - ``suspend snapTo(targetValue: T)``
         - ``suspend snapTo(targetValue: T)``
      - 

         - ``performDrag(delta: Float)``
         - ``dispatchRawDelta(delta: Float)``
      - 

         - ``suspend performFling(velocity: Float)``
         - ``suspend settle(velocity: Float)``
      - 

         - ``isAnimationRunning: Boolean``
         - ``isAnimationRunning: Boolean``
      - 

         - 
         - ``lastVelocity: Float``

   .. rubric:: ``Modifier.anchoredDraggable``
      :name: changes-api-modifier

   .. list-table::
      :widths: 40 40
      :header-rows: 1

      - 

         - ``Modifier.swipeable``
         - ``Modifier.anchoredDraggable``
      - 

         - ``state: SwipeableState``
         - ``state: AnchoredDraggableState``
      - 

         - ``anchors: Map``
         - | ``AnchoredDraggableState#updateAnchors``
            | ``or``

            ``AnchoredDraggableState#constructor``
      - 

         - ``orientation: Orientation``
         - ``orientation: Orientation``
      - 

         - ``enabled: Boolean = true``
         - ``enabled: Boolean = true``
      - 

         - ``reverseDirection: Boolean = false``
         - ``reverseDirection: Boolean = false``
      - 

         - ``interactionSource: MutableInteractionSource? = null``
         - ``interactionSource: MutableInteractionSource? = null``
      - 

         - ``thresholds: (from: T, to: T) -> ThresholdConfig = FixedThreshold(56.dp)``
         - Passed to ``AnchoredDraggableState`` constructor as
            ``positionalThreshold``
      - 

         - ``resistance: ResistanceConfig? = …``
         - Not yet supported. See
            `b/288084801 <https://issuetracker.google.com/288084801>`__ for the
            latest status.
      - 

         - ``velocityThreshold: Dp = 125.dp``
         - Passed to ``AnchoredDraggable`` constructor

Last updated 2024-03-25 UTC.

/Multi-touch gestures
=====================

.. https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/multi-touch?hl=en

.. container:: devsite-article-body clearfix

   To detect multitouch gestures used for panning, zooming and rotating, you can
   use the ``transformable`` modifier. This modifier does not transform elements
   by itself, it only detects the gestures.

   .. code:: prettyprint

      @Composable
      private fun TransformableSample() {
          // set up all transformation states
          var scale by remember { mutableStateOf(1f) }
          var rotation by remember { mutableStateOf(0f) }
          var offset by remember { mutableStateOf(Offset.Zero) }
          val state = rememberTransformableState { zoomChange, offsetChange, rotationChange ->
              scale *= zoomChange
              rotation += rotationChange
              offset += offsetChange
          }
          Box(
              Modifier
                  // apply other transformations like rotation and zoom
                  // on the pizza slice emoji
                  .graphicsLayer(
                      scaleX = scale,
                      scaleY = scale,
                      rotationZ = rotation,
                      translationX = offset.x,
                      translationY = offset.y
                  )
                  // add transformable to listen to multitouch transformation events
                  // after offset
                  .transformable(state = state)
                  .background(Color.Blue)
                  .fillMaxSize()
          )
      }GesturesSnippets.kt

   |A UI element responding to multitouch gestures—panning, zooming, and
   rotating|

   If you need to combine zooming, panning and rotation with other gestures, you
   can use the
   `PointerInputScope.detectTransformGestures  <#detectTransformGestures>`__
   detector.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Understand gestures  <#understand-gestures>`__

Last updated 2024-03-25 UTC.

.. |A UI element responding to multitouch gestures—panning, zooming, and rotating| image:: https://developer.android.google.cn/static/develop/ui/compose/images/gestures-multitouch.gif

/Keyboard Shortcut Helper
=========================

.. https://developer.android.google.cn/develop/ui/compose/touch-input/keyboard-input/keyboard-shortcut-helper?hl=en

.. container:: devsite-article-body clearfix

   Keyboard Shortcut Helper enables users to discover keyboard shortcuts for the
   platform and open apps. Publish your app's shortcuts in Keyboard Shortcut
   Helper to improve user productivity and ease of use.

   Users press Meta+/ to open the keyboard shortcuts screen, which is available
   on `Android 7.0  <#keyboard_shortcuts_helper>`__ (API
   level 24) and higher.

   .. figure::
      https://developer.android.google.cn/static/images/develop/ui/touch-input/keyboard-input/keyboard_shortcut_helper.png
      :figclass: invert

      **Figure 1.** Keyboard Shortcuts Helper.

   **Note:**\  The Meta key is not present on all keyboards. On macOS keyboards,
   the Meta key is the Command key; on Windows keyboards, the Windows key; and
   on ChromeOS keyboards, the Search key.

   .. rubric:: Provide shortcuts to Keyboard Shortcut Helper
      :name: provide_shortcuts_to_helper

   You can provide available keyboard shortcut lists to Keyboard Shortcut Helper
   by overriding the
   `onProvideKeyboardShortcuts()  <#onprovidekeyboardshortcuts>`__
   window callback. The following snippet demonstrates an implementation of
   ``onProvideKeyboardShortcuts()`` to add a group of four shortcuts:

   .. code:: prettyprint

      class MainActivity : ComponentActivity() {
          // Activity codes such as overridden onStart method.

          override fun onProvideKeyboardShortcuts(
              data: MutableList<KeyboardShortcutGroup>?,
              menu: Menu?,
              deviceId: Int
          ) {
              val shortcutGroup = KeyboardShortcutGroup(
                  "Cursor movement",
                  listOf(
                      KeyboardShortcutInfo("Up", KeyEvent.KEYCODE_P, KeyEvent.META_CTRL_ON),
                      KeyboardShortcutInfo("Down", KeyEvent.KEYCODE_N, KeyEvent.META_CTRL_ON),
                      KeyboardShortcutInfo("Forward", KeyEvent.KEYCODE_F, KeyEvent.META_CTRL_ON),
                      KeyboardShortcutInfo("Backward", KeyEvent.KEYCODE_B, KeyEvent.META_CTRL_ON),
                  )
              )
              data?.add(shortcutGroup)
          }
      }

   `KeyboardShortcutInfo  <#KeyboardShortcutInfo>`__
   describes a keyboard shortcut. The list of keyboard shortcuts are wrapped as
   a
   `KeyboardShortcutGroup  <#KeyboardShortcutGroup>`__
   object. Apps notify available keyboard shortcuts to Keyboard Shortcut Helper
   by adding the ``KeyboardShortcutGroup`` objects to the mutable list passed as
   the first parameter of the method.

   .. rubric:: Organize keyboard shortcuts with groups
      :name: organize-shortcuts

   The keyboard shortcut helper displays keyboard shortcuts in separate groups
   so users can find shortcuts by use case or for screens of your app. `Figure 2  <#keyboard_shortcut_group.png>`__
   shows the keyboard shortcuts categorized into two groups: cursor movement and
   message editing.

   .. figure::
      https://developer.android.google.cn/static/images/develop/ui/touch-input/keyboard-input/keyboard_shortcut_group.png
      :figclass: invert

      **Figure 2.** Categories in the Keyboard Shortcuts Helper.

   Your app registers two or more groups of keyboard shortcuts by creating a
   ``KeyboardShortcutGroup`` object for each group. In the following snippet,
   two ``KeyboardShortCutGroup`` objects are added to the mutable list passed to
   the ``onProvideKeyboardShortcuts()`` method. The objects are displayed as
   categories in Keyboard Shortcut Helper as `figure 2  <#keyboard_shortcut_group.png>`__
   shows.

   .. code:: prettyprint

      override fun onProvideKeyboardShortcuts(
          data: MutableList<KeyboardShortcutGroup>?,
          menu: Menu?,
          deviceId: Int
      ) {
          val cursorMovement = KeyboardShortcutGroup(
              "Cursor movement",
              listOf(
                  KeyboardShortcutInfo("Up", KeyEvent.KEYCODE_P, KeyEvent.META_CTRL_ON),
                  KeyboardShortcutInfo("Down", KeyEvent.KEYCODE_N, KeyEvent.META_CTRL_ON),
                  KeyboardShortcutInfo("Forward", KeyEvent.KEYCODE_F, KeyEvent.META_CTRL_ON),
                  KeyboardShortcutInfo("Backward", KeyEvent.KEYCODE_B, KeyEvent.META_CTRL_ON),
              )
          )

          val messageEdit = KeyboardShortcutGroup(
              "Message editing",
              listOf(
                  KeyboardShortcutInfo("Select All", KeyEvent.KEYCODE_A, KeyEvent.META_CTRL_ON),
                  KeyboardShortcutInfo("Send a message", KeyEvent.KEYCODE_ENTER, KeyEvent.META_SHIFT_ON)
              )
          )

          data?.add(cursorMovement)
          data?.add(messageEdit)
      }

   .. rubric:: Open Keyboard Shortcut Helper from code
      :name: open-keyboard-shortcut-helper-from-code

   Apps display the keyboard shortcuts screen by calling the
   `requestShowKeyboardShortcuts()  <#requestshowkeyboardshortcuts>`__
   method. In the following snippet, Keyboard Shortcut Helper opens when users
   tap or click the button or press the Enter key.

   .. code:: prettyprint

      val activity = LocalContext.current as Activity

      Button(onClick = { activity.requestShowKeyboardShortcuts() }) {
          Text(text = "Show keyboard shortcuts")
      }

Last updated 2024-04-23 UTC.

/Overview: Focus
================

.. https://developer.android.google.cn/develop/ui/compose/touch-input/focus?hl=en

.. container:: devsite-article-body clearfix

   When a user interacts with your app, they often do so by touching elements on
   their screen. However, this is not the only form of interaction. Other forms
   of interaction could include the following:

   -  A ChromeOS user might use the *arrow keys* on their physical keyboard to
      navigate the screen.
   -  Someone playing a game could use their attached *game controller* to
      navigate through the game's menu.
   -  A mobile app user might cycle through elements using the *on-screen
      keyboard*.

   In these cases, it is important to track which component is active at any
   given point in time, which is what we call **focus**. Elements on the screen
   should be focused in a logical order. Jetpack Compose has a default way of
   handling focus that is correct in most cases. However, in some cases, you
   might need to modify this default behavior.

   The following pages describe how to use focus in your app:

   -  `Change focus traversal order  <#change-focus-traversal-order>`__:
      Explains how to change the default focus order, add focus groups, and
      disable focus of a composable.
   -  `Change focus behavior  <#change-focus-behavior>`__:
      Describes how to request, capture, and release focus, and how to redirect
      focus upon entering a screen.
   -  `React to focus  <#react-to-focus>`__:
      Explains how to react to focus changes, add visual cues to elements, and
      understand the focus state of an element.

   .. rubric:: Default focus traversal order
      :name: default-focus

   Before we dive into the default behavior of the focus search, it's important
   to understand the concept of *level* in the hierarchy: generally speaking, we
   can say that two ``Composables`` are at the same level when they are
   siblings, meaning that they have the same parents. For instance, elements
   inside a ``Column`` are at the same level. Getting up a level means going
   from a child to its ``Composable`` parent, or, keeping the same example,
   going back from an item to a ``Column`` that contains it. Going down a level
   is the other way around, from the ``Column`` parent to the contained items.
   This concept can be applied to every ``Composable`` that can contain other
   ``Composables``.

   **Note:**\  `Accessibility Services  <#accessibility>`__ use a
   different mechanism to decide focus order. These services simply receive a
   tree of
   `AccessibilityNodeInfo  <#AccessibilityNodeInfo>`__
   nodes and decide their own strategy on how to traverse this tree. Find the
   current discussion about this topic in our `issue tracker <https://issuetracker.google.com/issues/186443263>`__.
   UI navigation can happen in multiple ways, some of which most users will
   already know:

   -  TABs: one-dimensional navigation, going *forward* or *backward*. TAB
      navigation advances focus to the next or previous element in the
      hierarchy. By default, Compose follows the declaration of the
      ``Composables``. One-directional navigation can be achieved through the
      ``tab`` key on a keyboard, or the Rotary Bezel on a watch, and this kind
      of focus search will visit each element on the screen.
   -  Arrow keys: two-dimensional navigation, going *left, right, up*, or
      *down*. Two-dimensional navigation can be achieved through a D-Pad on a TV
      or arrow keys on a keyboard, and its traversal order only visits elements
      at a given level. You can use the D-Pad center and Back button to go down
      and back up to a different level.

   Take as an example the screenshot below, where you have four buttons, one
   below the other, and you want to cycle through them all in order of
   appearance. Jetpack Compose delivers this behavior out of the box: the
   toolkit lets you cycle through each composable in vertical order from top to
   bottom using the ``tab`` key, or move focus by pressing the *up* or *down*
   arrow.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/focus_compact_screen.png
      name: image-1
      :alt: Screenshot of a list of buttons placed vertically one below the
      other in a small form factor.

      **Figure 1**. List of buttons displayed in a small form factor

   When you switch to a different kind of layout, things change a bit. If your
   layout has more than one column, like the layout below, Jetpack Compose lets
   you navigate through them without having to add any code. If you press the
   ``tab`` key, Jetpack Compose automatically highlights the items in order of
   declaration, from First to Fourth. Using arrow keys on your keyboard makes
   the selection follow the desired direction in 2D space.

   .. code:: prettyprint

      Column {
          Row {
              TextButton({ }) { Text("First field") }
              TextButton({ }) { Text("Second field") }
          }
          Row {
              TextButton({ }) { Text("Third field") }
              TextButton({ }) { Text("Fourth field") }
          }
      }FocusSnippets.kt

   The ``Composables`` are declared in two ``Rows``, and the focus elements are
   declared in order, from first to fourth. When you press the ``tab`` key, this
   produces the following focus order:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/focus_horizontal_navigation.gif
      name: image-2
      :alt: Screenshot of a list of buttons placed in two columns side by side
      in a bigger form factor.

      **Figure 2**. List of buttons placed in two columns side by side in a
      bigger form factor

   In the snippet below, you declare the items in ``Columns`` rather than in
   ``Rows``:

   .. code:: prettyprint

      Row {
          Column {
              TextButton({ }) { Text("First field") }
              TextButton({ }) { Text("Second field") }
          }
          Column {
              TextButton({ }) { Text("Third field") }
              TextButton({ }) { Text("Fourth field") }
          }
      }FocusSnippets.kt

   This layout traverses the items vertically, from top to bottom, from the
   start of the screen towards the end:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/focus_vertical_navigation.gif
      name: image-3
      :alt: Screenshot of a list of buttons placed in two columns side by side
      in a bigger form factor.

      **Figure 3**. List of buttons placed in two columns side by side in a
      bigger form factor

   The previous two samples, while differing in one-directional navigation,
   provide the same experience when it comes to two-dimensional navigation. This
   is usually because the items on the screen have the same geographic placement
   in both examples. Navigating right from the first ``Column`` moves the focus
   to the second, and navigating down from the first ``Row`` moves the focus to
   the one below it.

   **Note:**\  Focus properties are a special case, in which the parents always
   win in case of collisions or duplicates.This is something to keep in mind
   when working with focus.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Change focus behavior  <#change-focus-behavior>`__
   -  `ConstraintLayout in Compose  <#constraintlayout>`__
   -  `Flow layouts in Compose  <#flow>`__

Last updated 2024-03-25 UTC.

/Change focus traversal order
=============================

.. https://developer.android.google.cn/develop/ui/compose/touch-input/focus/change-focus-traversal-order?hl=en

.. container:: devsite-article-body clearfix

   The `Default focus traversal order  <#focus>`__
   section described how Compose automatically adds focus traversal behavior to
   your elements, for both one-dimensional (``tab`` key) and two-dimensional
   (arrow keys) navigation. In some cases, you might need to override this
   default behavior and be more explicit about the required traversal order.

   .. rubric:: Override one-dimensional traversal order
      :name: override-one-dimensional

   To change the default focus traversal order for one-dimensional navigation,
   you create a set of references, one for each focusable composable:

   .. code:: prettyprint

      val (first, second, third, fourth) = remember { FocusRequester.createRefs() }FocusSnippets.kt

   Then, use the
   `focusRequester  <#focusRequester>`__
   modifier to associate each of them with a composable:

   .. code:: prettyprint

      Column {
          Row {
              TextButton({}, Modifier.focusRequester(first)) { Text("First field") }
              TextButton({}, Modifier.focusRequester(third)) { Text("Third field") }
          }

          Row {
              TextButton({}, Modifier.focusRequester(second)) { Text("Second field") }
              TextButton({}, Modifier.focusRequester(fourth)) { Text("Fourth field") }
          }
      }FocusSnippets.kt

   You can now use the
   `focusProperties  <#focusProperties>`__
   modifier to specify a custom traversal order:

   .. code:: prettyprint

      Column {
          Row {
              TextButton(
                  {},
                  Modifier
                      .focusRequester(first)
                      .focusProperties { next = second }
              ) {
                  Text("First field")
              }
              TextButton(
                  {},
                  Modifier
                      .focusRequester(third)
                      .focusProperties { next = fourth }
              ) {
                  Text("Third field")
              }
          }

          Row {
              TextButton(
                  {},
                  Modifier
                      .focusRequester(second)
                      .focusProperties { next = third }
              ) {
                  Text("Second field")
              }
              TextButton(
                  {},
                  Modifier
                      .focusRequester(fourth)
                      .focusProperties { next = first }
              ) {
                  Text("Fourth field")
              }
          }
      }FocusSnippets.kt

   .. rubric:: Override two-dimensional traversal order
      :name: override-two-dimensional

   It is also possible to add fine-grained control over the focus traversal
   order for two-dimensional navigation with the arrow keys. For each element,
   you can override the default navigation destination for each of the
   directions by adding the
   `focusProperties  <#focusProperties>`__
   modifier and specifying the item that would come up, down, or any other
   direction:

   .. code:: prettyprint

      TextButton(
          onClick = {},
          modifier = Modifier
              .focusRequester(fourth)
              .focusProperties {
                  down = third
                  right = second
              }
      ) {}FocusSnippets.kt

   This technique not only effectively uses keyboard arrows, but would work with
   D-Pads and sticks on wired and wireless controllers.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Change focus behavior  <#change-focus-behavior>`__
   -  `Focus in Compose  <#focus>`__

Last updated 2024-03-25 UTC.

/Change focus behavior
======================

.. https://developer.android.google.cn/develop/ui/compose/touch-input/focus/change-focus-behavior?hl=en

.. container:: devsite-article-body clearfix

   It is sometimes necessary to override the default focus behavior of the
   elements on your screen. For example, you might want to `group composables <#provide-coherent>`__, `prevent focus <#making-composable-unfocusable>`__ on a certain composable, explicitly
   `request focus <#request-keyboard>`__ on one, `capture or release focus <#capture-release-focus>`__, or `redirect focus <#redirect-focus>`__ on
   entry or exit. This section describes how to change focus behavior when the
   defaults aren't what you need.

   .. rubric:: Provide coherent navigation with focus groups
      :name: provide-coherent

   Sometimes, Jetpack Compose doesn't immediately guess the correct next item
   for tabbed navigation, especially when complex parent ``Composables`` like
   tabs and lists come into play.

   While focus search usually follows the declaration order of the
   ``Composables``, this is impossible in some cases, like when one of the
   ``Composables`` in the hierarchy is a horizontal scrollable that is not fully
   visible. This is shown in the example below.

   Jetpack Compose may decide to focus the next item closest to the start of the
   screen, as shown below, rather than continuing on the path you expect for
   one-directional navigation:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/one_directional_navigation_1.gif
      name: image-1
      :alt: Animation of an app showing a top horizontal navigation and a list
      of items below.

      **Figure 1**. Animation of an app showing a top horizontal navigation and
      a list of items below

   In this example, it is clear that the developers did not intend for the focus
   to jump from the *Chocolates* tab to the first image below, and then back up
   to the *Pastries* tab. Instead, they wanted the focus to continue on the tabs
   until the last tab, and then focus on the inner content:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/one_directional_navigation_2.gif
      name: image-2
      :alt: Animation of an app showing a top horizontal navigation and a list
      of items below.

      **Figure 2**. Animation of an app showing a top horizontal navigation and
      a list of items below

   In situations where it's important that a group of composables gains focus
   sequentially, like in the Tab row from the previous example, you need to wrap
   the ``Composable`` in a parent that has the ``focusGroup()`` modifier:

   .. code:: prettyprint

      LazyVerticalGrid(columns = GridCells.Fixed(4)) {
          item(span = { GridItemSpan(maxLineSpan) }) {
              Row(modifier = Modifier.focusGroup()) {
                  FilterChipA()
                  FilterChipB()
                  FilterChipC()
              }
          }
          items(chocolates) {
              SweetsCard(sweets = it)
          }
      }FocusSnippets.kt

   Bi-directional navigation looks for the closest composable for the given
   direction— if an element from another group is closer than a non-fully
   visible item in the current group, navigation picks the closest one. To avoid
   this behavior, you can apply the ``focusGroup()`` modifier.

   ``FocusGroup`` makes a whole group appear like a single entity in terms of
   focus, but the group itself will not get the focus— instead, the closest
   child will gain focus instead. In this way, navigation knows to go to the
   non-fully visible item before leaving the group.

   In this case, the three instances of ``FilterChip`` will be focused before
   the ``SweetsCard`` items, even when the ``SweetsCards`` are completely
   visible to the user and some ``FilterChip`` might be hidden. This happens
   because the ``focusGroup`` modifier tells the focus manager to adjust the
   order in which items are focused so that navigation is easier and more
   coherent with the UI.

   Without the ``focusGroup`` modifier, if the ``FilterChipC`` was not visible,
   focus navigation would pick it up last. However, adding such a modifier makes
   it not only discoverable, but it will also acquire focus right after
   ``FilterChipB``, as users would expect.

   .. rubric:: Making a composable focusable
      :name: making-composable-focusable

   Some composables are focusable by design, such as a Button or a composable
   with the ``clickable`` modifier attached to it. If you want to specifically
   add focusable behavior to a composable, you use the ``focusable`` modifier:

   .. code:: prettyprint

      var color by remember { mutableStateOf(Green) }
      Box(
          Modifier
              .background(color)
              .onFocusChanged { color = if (it.isFocused) Blue else Green }
              .focusable()
      ) {
          Text("Focusable 1")
      }FocusSnippets.kt

   .. rubric:: Making a composable unfocusable
      :name: making-composable-unfocusable

   There might be situations in which some of your elements should not
   participate in the focus. In these rare occasions, you can leverage the
   ``canFocus property`` to exclude a ``Composable`` from being focusable.

   **Note:**\  While the following code makes the composable unfocusable, it
   does not prevent the composable from responding to touch or click events.
   .. code:: prettyprint

      var checked by remember { mutableStateOf(false) }

      Switch(
          checked = checked,
          onCheckedChange = { checked = it },
          // Prevent component from being focused
          modifier = Modifier
              .focusProperties { canFocus = false }
      )FocusSnippets.kt

   .. rubric:: Request keyboard focus with ``FocusRequester``
      :name: request-keyboard

   In some cases, you might want to explicitly request focus as a response to a
   user interaction. For example, you might ask a user if they want to restart
   filling in a form, and if they press "yes" you want to refocus the first
   field of that form.

   The first thing to do is associate a
   `FocusRequester  <#FocusRequester>`__
   object with the composable you want to move the keyboard focus to. In the
   following code snippet, a ``FocusRequester`` object is associated with a
   ``TextField`` by setting a modifier called
   `Modifier.focusRequester  <#focusRequester>`__:

   .. code:: prettyprint

      val focusRequester = remember { FocusRequester() }
      var text by remember { mutableStateOf("") }

      TextField(
          value = text,
          onValueChange = { text = it },
          modifier = Modifier.focusRequester(focusRequester)
      )FocusSnippets.kt

   You can call `FocusRequester's ``requestFocus``
   method  <#requestFocus>`__
   to send actual focus requests. You should invoke this method outside of a
   ``Composable`` context (otherwise, it is re-executed at every recomposition).
   The following snippet shows how to request the system to move the keyboard
   focus when the button is clicked:

   .. code:: prettyprint

      val focusRequester = remember { FocusRequester() }
      var text by remember { mutableStateOf("") }

      TextField(
          value = text,
          onValueChange = { text = it },
          modifier = Modifier.focusRequester(focusRequester)
      )

      Button(onClick = { focusRequester.requestFocus() }) {
          Text("Request focus on TextField")
      }FocusSnippets.kt

   .. rubric:: Capture and release focus
      :name: capture-release-focus

   You can leverage focus to guide your users to provide the right data your app
   needs to perform its task— for instance, getting a valid email address or
   phone number. Although error states inform your users about what is going on,
   you might need the field with erroneous information to stay focused until it
   gets fixed.

   In order to capture the focus, you can invoke the ``captureFocus()`` method,
   and release it afterwards with the ``freeFocus()`` method instead, as in the
   following example:

   .. code:: prettyprint

      val textField = FocusRequester()

      TextField(
          value = text,
          onValueChange = {
              text = it

              if (it.length > 3) {
                  textField.captureFocus()
              } else {
                  textField.freeFocus()
              }
          },
          modifier = Modifier.focusRequester(textField)
      )FocusSnippets.kt

   **Note:**\  A composable can only capture focus if it is already focused; for
   example, by using ``requestFocus`` or tapping the element.

   .. rubric:: Precedence of focus modifiers
      :name: precedence-focus

   ``Modifiers`` can be seen as elements that only have one child, so when you
   queue them, each ``Modifier`` on the left (or top) wraps the ``Modifier``
   that follows on the right (or below). This means that the second ``Modifier``
   is contained inside the first one, so that when declaring two
   ``focusProperties``, only the topmost one works, as the following ones are
   contained in the topmost.

   To clarify the concept more, see the following code:

   .. code:: prettyprint

      Modifier
          .focusProperties { right = item1 }
          .focusProperties { right = item2 }
          .focusable()FocusSnippets.kt

   In this case, the ``focusProperties`` indicating ``item2`` as the right focus
   will not be used, as it is contained in the preceding one; thus, ``item1``
   will be the one used.

   Leveraging this approach, a parent can also reset the behavior to default by
   using ``FocusRequester.Default``:

   .. code:: prettyprint

      Modifier
          .focusProperties { right = Default }
          .focusProperties { right = item1 }
          .focusProperties { right = item2 }
          .focusable()FocusSnippets.kt

   The parent does not have to be part of the same modifier chain. A parent
   composable can overwrite a focus property of a child composable. For example,
   consider this ``FancyButton`` that makes the button not focusable:

   .. code:: prettyprint

      @Composable
      fun FancyButton(modifier: Modifier = Modifier) {
          Row(modifier.focusProperties { canFocus = false }) {
              Text("Click me")
              Button(onClick = { }) { Text("OK") }
          }
      }FocusSnippets.kt

   A user can make this button focusable again by setting ``canFocus`` to
   ``true``:

   .. code:: prettyprint

      FancyButton(Modifier.focusProperties { canFocus = true })FocusSnippets.kt

   **Note:**\  You can specify that a specific ``Composable`` should receive
   focus with the low-level ``focusTarget()`` Modifier but this is not
   recommended. Instead, use the higher level ``focusable()`` Modifier.
   Like every ``Modifier``, focus-related ones behave differently based on the
   order you declare them. For instance, code like the following makes the
   ``Box`` focusable, but the ``FocusRequester`` isn't associated with this
   focusable since it is declared after the focusable.

   .. code:: prettyprint

      Box(
          Modifier
              .focusable()
              .focusRequester(Default)
              .onFocusChanged {}
      )FocusSnippets.kt

   It's important to remember that a ``focusRequester`` is associated with the
   first focusable below it in the hierarchy, so this ``focusRequester`` points
   to the first focusable child. In case none is available, it won't point to
   anything. However, since the ``Box`` is focusable (thanks to the
   ``focusable()`` modifier), you can navigate to it using two-directional
   navigation.

   As another example, either of the following would work, as the
   ``onFocusChanged()`` modifier refers to the first focusable element that
   appears after the ``focusable()`` or ``focusTarget()`` modifiers.

   .. list-table::
      :widths: 40 40

      - 

         - .. code:: prettyprint

               Box(
                   Modifier
                       .onFocusChanged {}
                       .focusRequester(Default)
                       .focusable()
               )FocusSnippets.kt
         - .. code:: prettyprint

               Box(
                   Modifier
                       .focusRequester(Default)
                       .onFocusChanged {}
                       .focusable()
               )FocusSnippets.kt

   .. rubric:: Redirect focus upon entry or exit
      :name: redirect-focus

   Sometimes, you need to provide a very specific kind of navigation, like the
   one shown in the animation below:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/two_dimensional_navigation_1.gif
      name: image-3
      :alt: Animation of a screen showing two columns of buttons placed side by
      side and animating focus from one column to the other.

      **Figure 3**. Animation of a screen showing two columns of buttons placed
      side by side and animating focus from one column to the other

   Before we dive into how to create this, it's important to understand the
   default behavior of the focus search. Without any modification, once the
   focus search reaches the ``Clickable 3`` item, pressing ``DOWN`` on the D-Pad
   (or the equivalent arrow key) would move the focus to whatever is displayed
   below the ``Column``, exiting the group and ignoring the one on the right. If
   there are no focusable items available, the focus doesn't move anywhere, but
   stays on ``Clickable 3``.

   **Note:**\  We refer to *exit* when the focus search leaves the level in
   which it's exploring, and *enter* otherwise.
   To alter this behavior and provide the intended navigation, you can leverage
   the ``focusProperties`` modifier, which helps you manage what happens when
   the focus search enters or exits the ``Composable``:

   .. code:: prettyprint

      val otherComposable = remember { FocusRequester() }

      Modifier.focusProperties {
          exit = { focusDirection ->
              when (focusDirection) {
                  Right -> Cancel
                  Down -> otherComposable
                  else -> Default
              }
          }
      }FocusSnippets.kt

   It is possible to direct the focus to a specific ``Composable`` whenever it
   enters or exits a certain portion of the hierarchy— for example, when your UI
   has two columns and you want to make sure that whenever the first one is
   processed, focus switches to the second:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/two_dimensional_navigation_2.gif
      name: image-4
      :alt: Animation of a screen showing two columns of buttons placed side by
      side and animating focus from one column to the other.

      **Figure 4**. Animation of a screen showing two columns of buttons placed
      side by side and animating focus from one column to the other

   In this gif, once the focus reaches the ``Clickable 3 Composable`` in
   ``Column`` 1, the next item being focused is ``Clickable 4`` in another
   ``Column``. This behavior can be achieved by combining the ``focusDirection``
   with the ``enter`` and ``exit`` values inside the ``focusProperties``
   modifier. They both need a lambda that takes as a parameter the direction
   from which the focus is coming from and returns a ``FocusRequester``. This
   lambda can behave in three different ways: returning
   ``FocusRequester.Cancel`` stops the focus from continuing, while
   ``FocusRequester.Default`` does not alter its behavior. Providing instead the
   ``FocusRequester`` attached to another ``Composable`` makes the focus jump to
   that specific ``Composable``.

   .. rubric:: Change focus advancing direction
      :name: change-focus

   To advance the focus to the next item or towards a precise direction, you can
   leverage the ``onPreviewKey`` modifier and imply the ``LocalFocusManager`` to
   advance the focus with the ``moveFocus`` Modifier.

   The following example shows the default behavior of the focus mechanism: when
   a ``tab`` keypress is detected, the focus advances to the next element in the
   focus list. While this is not something you usually need to configure, it's
   important to know the inner workings of the system to be able to change the
   default behavior.

   .. code:: prettyprint

      val focusManager = LocalFocusManager.current
      var text by remember { mutableStateOf("") }

      TextField(
          value = text,
          onValueChange = { text = it },
          modifier = Modifier.onPreviewKeyEvent {
              when {
                  KeyEventType.KeyUp == it.type && Key.Tab == it.key -> {
                      focusManager.moveFocus(FocusDirection.Next)
                      true
                  }

                  else -> false
              }
          }
      )FocusSnippets.kt

   In this sample, the ``focusManager.moveFocus()`` function advances the focus
   to the item specified, or to the direction implied in the function parameter.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `React to focus  <#react-to-focus>`__
   -  `Focus in Compose  <#focus>`__
   -  `Change focus traversal order  <#change-focus-traversal-order>`__

Last updated 2024-03-25 UTC.

/React to focus
===============

.. https://developer.android.google.cn/develop/ui/compose/touch-input/focus/react-to-focus?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: Provide visual cues for easier focus visualization
      :name: provide-visual

   While all the focusable elements from Material Theme already have a focus
   style that matches the theme, you might need to add some visual elements to
   make the focused element easier to spot. A good solution would be to change
   the border of your element with a color that has a good contrast with the
   background:

   .. code:: prettyprint

      var color by remember { mutableStateOf(Color.White) }
      Card(
          modifier = Modifier
              .onFocusChanged {
                  color = if (it.isFocused) Red else White
              }
              .border(5.dp, color)
      ) {}FocusSnippets.kt

   In this example, ``remember`` is used to store the color of the border across
   recompositions, and the outline of the element is updated every time the
   element gains or loses focus.

   .. rubric:: Implement advanced visual cues
      :name: advanced-visual-cues

   With Jetpack Compose, you can also create more sophisticated and advanced
   visual cues that match better with your UI.

   #. First, create an ``IndicationInstance`` that visually draws the cue you
      want in your UI:

      .. code:: prettyprint

         private class MyHighlightIndicationInstance(isEnabledState: State<Boolean>) :
             IndicationInstance {
             private val isEnabled by isEnabledState
             override fun ContentDrawScope.drawIndication() {
                 drawContent()
                 if (isEnabled) {
                     drawRect(size = size, color = Color.White, alpha = 0.2f)
                 }
             }
         }FocusSnippets.kt

   #. Next, create an ``Indication`` and remember the focused state:

      .. code:: prettyprint

         class MyHighlightIndication : Indication {
             @Composable
             override fun rememberUpdatedInstance(interactionSource: InteractionSource):
                 IndicationInstance {
                 val isFocusedState = interactionSource.collectIsFocusedAsState()
                 return remember(interactionSource) {
                     MyHighlightIndicationInstance(isEnabledState = isFocusedState)
                 }
             }
         }FocusSnippets.kt

   #. Add both the ``Indication`` and an ``InteractionSource`` to the UI, via
      the ``indication()`` modifier:

      .. code:: prettyprint

         val highlightIndication = remember { MyHighlightIndication() }
         var interactionSource = remember { MutableInteractionSource() }

         Card(
             modifier = Modifier
                 .clickable(
                     interactionSource = interactionSource,
                     indication = highlightIndication,
                     enabled = true,
                     onClick = { }
                 )
         ) {}FocusSnippets.kt

   .. rubric:: Understand the state of the focus
      :name: understand-state

   Generally, every time a state of the focus changes, a ``FocusEvent`` is fired
   up the tree, and the parents of a ``focusable()`` modifier can listen to it
   using the ``onFocusChanged()`` modifier.

   If you need to know the state of the focus,you can use these APIs in
   conjunction with the ``onFocusChanged`` modifier:

   -  ``isFocused`` returns ``true`` if the composable to which the modifier is
      attached is focused
   -  ``hasFocus`` works similarly to ``isFocused``, but with a substantial
      difference: rather than checking only the current, it checks if the
      element or one of its children is focused
   -  ``isCaptured`` returns ``true`` whenever the focus is held. This happens,
      for instance, when a ``TextField`` contains incorrect data, so that trying
      to focus other elements will not clear the focus.

   These fields are shown below:

   .. code:: prettyprint

      Modifier.onFocusChanged {
          val isFocused = it.isFocused
          val hasFocus = it.hasFocus
          val isCaptured= it.isCaptured
      }

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Change focus behavior  <#change-focus-behavior>`__
   -  `Material Design 2 in Compose  <#material>`__
   -  `Handle user input  <#user-input>`__

Last updated 2024-03-25 UTC.

/Handling interactions
======================

.. https://developer.android.google.cn/develop/ui/compose/touch-input/user-interactions/handling-interactions?hl=en

.. container:: devsite-article-body clearfix

   User interface components give feedback to the device user by the way they
   respond to user interactions. Every component has its own way of responding
   to interactions, which helps the user know what their interactions are doing.
   For example, if a user touches a button on a device's touchscreen, the button
   is likely to change in some way, perhaps by adding a highlight color. This
   change lets the user know that they touched the button. If the user didn't
   want to do that, they'll know to drag their finger away from the button
   before releasing--otherwise, the button will activate.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/button-always-enabled.gif
      name: image-1
      :width: 30.0%

      **Figure 1.** Buttons that always appear enabled, with no press ripple.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/button-reflects-state.gif
      name: image-2
      :width: 30.0%

      **Figure 2.** Buttons with press ripples that reflect their enabled state
      accordingly.

   The Compose `Gestures  <#gestures>`__
   documentation covers how Compose components handle low-level pointer event,
   such as pointer moves and clicks. Out of the box, Compose abstracts those
   low-level events into higher-level interactions–for example, a series of
   pointer events might add up to a button press-and-release. Understanding
   those higher-level abstractions can help you customize how your UI responds
   to the user. For example, you might want to customize how a component's
   appearance changes when the user interacts with it, or maybe you just want to
   maintain a log of those user actions. This document gives you the information
   you need to modify the standard UI elements, or design your own.

   **Note:** Some code snippets in this doc require at least the following
   library versions:
   ``androidx.compose.foundation:foundation:1.7.0-alpha01``
   ``androidx.wear.compose:compose-material:1.4.0-alpha01``
   ``androidx.compose.material:material:1.7.0-alpha01``
   ``androidx.wear.compose:compose-material3:1.0.0-alpha16``
   .. rubric:: Interactions
      :name: interactions

   In many cases, you don't need to know just how your Compose component is
   interpreting user interactions. For example, ``Button`` relies on
   `Modifier.clickable  <#clickable>`__
   to figure out whether the user clicked the button. If you're adding a typical
   button to your app, you can define the button's ``onClick`` code, and
   ``Modifier.clickable`` runs that code when appropriate. That means you don't
   need to know whether the user tapped the screen or selected the button with a
   keyboard; ``Modifier.clickable`` figures out that the user performed a click,
   and responds by running your ``onClick`` code.

   However, if you want to customize your UI component's response to user
   behavior, you may need to know more of what's going on under the hood. This
   section gives you some of that information.

   When a user interacts with a UI component, the system represents their
   behavior by generating a number of
   `Interaction  <#Interaction>`__
   events. For example, if a user touches a button, the button generates
   `PressInteraction.Press  <#PressInteraction.Press>`__.
   If the user lifts their finger inside the button, it generates a
   `PressInteraction.Release  <#PressInteraction.Release>`__,
   letting the button know that the click was finished. On the other hand, if
   the user drags their finger outside the button, then lifts their finger, the
   button generates
   `PressInteraction.Cancel  <#PressInteraction.Cancel>`__,
   to indicate that the press on the button was canceled, not completed.

   These interactions are **unopinionated**. That is, these low-level
   interaction events don't intend to interpret the meaning of the user actions,
   or their sequence. They also don't interpret which user actions might take
   priority over other actions.

   These interactions generally come in pairs, with a start and an end. The
   second interaction contains a reference to the first one. For example, if a
   user touches a button then lifts their finger, the touch generates a
   `PressInteraction.Press  <#PressInteraction.Press>`__
   interaction, and the release generates a
   `PressInteraction.Release  <#PressInteraction.Release>`__;
   the ``Release`` has a ``press`` property identifying the initial
   ``PressInteraction.Press``.

   You can see the interactions for a particular component by observing its
   ``InteractionSource``. ``InteractionSource`` is built on top of `Kotlin flows  <#flow>`__, so you can collect the interactions from it the same
   way you'd work with any other flow. For more information about this design
   decision, see the `Illuminating Interactions <https://medium.com/androiddevelopers/illuminating-interactions-visual-state-in-jetpack-compose-188fa041b791>`__
   blog post.

   .. rubric:: Interaction state
      :name: interaction-state

   You might want to extend the built-in functionality of your components by
   also tracking the interactions yourself. For example, perhaps you want a
   button to change color when it's pressed. The simplest way to track the
   interactions is to observe the appropriate interaction *state*.
   ``InteractionSource`` offers a number of methods that reveal various
   interaction statuses as state. For example, if you want to see whether a
   particular button is pressed, you can call its
   `InteractionSource.collectIsPressedAsState()  <#collectIsPressedAsState>`__
   method:

   .. code:: prettyprint

      val interactionSource = remember { MutableInteractionSource() }
      val isPressed by interactionSource.collectIsPressedAsState()

      Button(
          onClick = { /* do something */ },
          interactionSource = interactionSource
      ) {
          Text(if (isPressed) "Pressed!" else "Not pressed")
      }Interactions.kt

   **Note:**\  ``InteractionSource`` provides a read-only flow of the
   interactions, while ``MutableInteractionSource`` lets you add new
   interactions into the flow. When you build your own components, it's a best
   practice to use and expose a ``MutableInteractionSource``, even if you don't
   currently plan on adding interactions yourself.
   Besides ``collectIsPressedAsState()``, Compose also provides
   ``collectIsFocusedAsState()``, ``collectIsDraggedAsState()``, and
   ``collectIsHoveredAsState()``. These methods are actually convenience methods
   built on top of lower-level ``InteractionSource`` APIs. In some cases, you
   may want to use those lower-level functions directly.

   For example, suppose you need to know whether a button is being pressed, and
   *also* whether it's being dragged. If you use both
   ``collectIsPressedAsState()`` and ``collectIsDraggedAsState()``, Compose does
   a lot of duplicate work, and there's no guarantee you'll get all the
   interactions in the right order. For situations like this, you might want to
   work directly with the ``InteractionSource``. For more information about
   tracking the interactions yourself with ``InteractionSource``, 
   see `Work with InteractionSource <#work-with-interactionsource>`__.

   The following section describes how to consume and emit interactions with
   ``InteractionSource`` and ``MutableInteractionSource``, respectively.

   .. rubric:: Consume and emit ``Interaction``
      :name: consume-emit

   ``InteractionSource`` represents a read-only stream of ``Interactions`` — it
   is not possible to emit an ``Interaction`` to an ``InteractionSource``. To
   emit ``Interaction``\ s, you need to use a ``MutableInteractionSource``,
   which extends from ``InteractionSource``.

   Modifiers and components can consume, emit, or consume and emit
   ``Interactions``. The following sections describe how to consume and emit
   interactions from both modifiers and components.

   .. rubric:: Consuming modifier example
      :name: consuming-modifier

   For a modifier that draws a border for focused state, you only need to
   observe ``Interactions``, so you can accept an ``InteractionSource``:

   .. code:: prettyprint

      fun Modifier.focusBorder(interactionSource: InteractionSource): Modifier {
          // ...
      }Interactions.kt

   It is clear from the function signature that this modifier is a *consumer* —
   it can consume ``Interaction``\ s, but cannot emit them.

   .. rubric:: Producing modifier example
      :name: producing-modifier

   For a modifier that handles hover events like
   `Modifier.hoverable  <#hoverable>`__,
   you need to emit ``Interactions``, and accept a ``MutableInteractionSource``
   as a parameter instead:

   .. code:: prettyprint

      fun Modifier.hover(interactionSource: MutableInteractionSource, enabled: Boolean): Modifier {
          // ...
      }Interactions.kt

   This modifier is a *producer* — it can use the provided
   ``MutableInteractionSource`` to emit ``HoverInteractions`` when it is hovered
   or unhovered.

   .. rubric:: Build components that consume and produce
      :name: build-components

   High-level components such as a Material ``Button`` act as both producers and
   consumers. They handle input and focus events, and also change their
   appearance in response to these events, such as showing a ripple or animating
   their elevation. As a result, they directly expose
   ``MutableInteractionSource`` as a parameter, so that you can provide your own
   remembered instance:

   .. code:: prettyprint

      @Composable
      fun Button(
          onClick: () -> Unit,
          modifier: Modifier = Modifier,
          enabled: Boolean = true,

          // exposes MutableInteractionSource as a parameter
          interactionSource: MutableInteractionSource? = null,

          elevation: ButtonElevation? = ButtonDefaults.elevatedButtonElevation(),
          shape: Shape = MaterialTheme.shapes.small,
          border: BorderStroke? = null,
          colors: ButtonColors = ButtonDefaults.buttonColors(),
          contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
          content: @Composable RowScope.() -> Unit
      ) { /* content() */ }Interactions.kt

   **Note:**\  If null is provided, interactions will still happen
   internally—this just controls whether you are hoisting the interaction source
   out of the component. A ``MutableInteractionSource`` will still be created
   internally, if needed.
   This allows `hoisting  <#state-hoisting>`__ the
   ``MutableInteractionSource`` out of the component and observing all the
   ``Interaction``\ s produced by the component. You can use this to control the
   appearance of that component, or any other component in your UI.

   **If you are building your own interactive high level components, we
   recommend that you expose ``MutableInteractionSource`` as a parameter in this
   way**. Besides following state hoisting best practices, this also makes it
   easy to read and control the visual state of a component in the same way that
   any other sort of state (such as enabled state) can be read and controlled.

   Compose follows a `layered architectural approach  <#layering>`__, so high-level Material components
   are built on top of foundational building blocks that produce the
   ``Interaction``\ s they need to control ripples and other visual effects. The
   foundation library provides high-level interaction modifiers such as
   `Modifier.hoverable  <#hoverable>`__,
   `Modifier.focusable  <#focusable>`__,
   and
   `Modifier.draggable  <#draggable>`__.

   To build a component that responds to hover events, you can simply use
   ``Modifier.hoverable`` and pass a ``MutableInteractionSource`` as a
   parameter. Whenever the component is hovered, it emits
   ``HoverInteraction``\ s, and you can use this to change how the component
   appears.

   .. code:: prettyprint

      // This InteractionSource will emit hover interactions
      val interactionSource = remember { MutableInteractionSource() }

      Box(
          Modifier
              .size(100.dp)
              .hoverable(interactionSource = interactionSource),
          contentAlignment = Alignment.Center
      ) {
          Text("Hello!")
      }Interactions.kt

   To also make this component focusable, you can add ``Modifier.focusable`` and
   pass the *same* ``MutableInteractionSource`` as a parameter. Now, both
   ``HoverInteraction.Enter/Exit`` and ``FocusInteraction.Focus/Unfocus`` are
   emitted through the same ``MutableInteractionSource``, and you can customize
   the appearance for both types of interaction in the same place:

   .. code:: prettyprint

      // This InteractionSource will emit hover and focus interactions
      val interactionSource = remember { MutableInteractionSource() }

      Box(
          Modifier
              .size(100.dp)
              .hoverable(interactionSource = interactionSource)
              .focusable(interactionSource = interactionSource),
          contentAlignment = Alignment.Center
      ) {
          Text("Hello!")
      }Interactions.kt

   `Modifier.clickable  <#clickable>`__
   is an even higher level abstraction than ``hoverable`` and ``focusable`` —
   for a component to be clickable, it is implicitly hoverable, and components
   that can be clicked should also be focusable. You can use
   ``Modifier.clickable`` to create a component that handles hover, focus, and
   press interactions, without needing to combine lower level APIs. If you want
   to make your component clickable as well, you can replace ``hoverable`` and
   ``focusable`` with a ``clickable``:

   .. code:: prettyprint

      // This InteractionSource will emit hover, focus, and press interactions
      val interactionSource = remember { MutableInteractionSource() }
      Box(
          Modifier
              .size(100.dp)
              .clickable(
                  onClick = {},
                  interactionSource = interactionSource,

                  // Also show a ripple effect
                  indication = ripple()
              ),
          contentAlignment = Alignment.Center
      ) {
          Text("Hello!")
      }Interactions.kt

   .. rubric:: Work with ``InteractionSource``
      :name: work-with-interactionsource

   If you need low-level information about interactions with a component, you
   can use standard `flow APIs  <#flow>`__ for that component's
   ``InteractionSource``. For example, suppose you want to maintain a list of
   the press and drag interactions for an ``InteractionSource``. This code does
   half the job, adding the new presses to the list as they come in:

   .. code:: prettyprint

      val interactionSource = remember { MutableInteractionSource() }
      val interactions = remember { mutableStateListOf<Interaction>() }

      LaunchedEffect(interactionSource) {
          interactionSource.interactions.collect { interaction ->
              when (interaction) {
                  is PressInteraction.Press -> {
                      interactions.add(interaction)
                  }
                  is DragInteraction.Start -> {
                      interactions.add(interaction)
                  }
              }
          }
      }Interactions.kt

   But besides adding the new interactions, you also have to remove interactions
   when they end (for example, when the user lifts their finger back off the
   component). That's easy to do, since the end interactions always carry a
   reference to the associated start interaction. This code shows how you'd
   remove the interactions that have ended:

   .. code:: prettyprint

      val interactionSource = remember { MutableInteractionSource() }
      val interactions = remember { mutableStateListOf<Interaction>() }

      LaunchedEffect(interactionSource) {
          interactionSource.interactions.collect { interaction ->
              when (interaction) {
                  is PressInteraction.Press -> {
                      interactions.add(interaction)
                  }
                  is PressInteraction.Release -> {
                      interactions.remove(interaction.press)
                  }
                  is PressInteraction.Cancel -> {
                      interactions.remove(interaction.press)
                  }
                  is DragInteraction.Start -> {
                      interactions.add(interaction)
                  }
                  is DragInteraction.Stop -> {
                      interactions.remove(interaction.start)
                  }
                  is DragInteraction.Cancel -> {
                      interactions.remove(interaction.start)
                  }
              }
          }
      }Interactions.kt

   Now, if you want to know if the component is currently being pressed or
   dragged, all you have to do is check whether ``interactions`` is empty:

   .. code:: prettyprint

      val isPressedOrDragged = interactions.isNotEmpty()Interactions.kt

   If you want to know what the most recent interaction was, just look at the
   last item in the list. For example, this is how the Compose ripple
   implementation figures out the appropriate state overlay to use for the most
   recent interaction:

   .. code:: prettyprint

      val lastInteraction = when (interactions.lastOrNull()) {
          is DragInteraction.Start -> "Dragged"
          is PressInteraction.Press -> "Pressed"
          else -> "No state"
      }Interactions.kt

   Because all ``Interaction``\ s follow the same structure, there is not much
   of a difference in code when working with different types of user
   interactions — the overall pattern is the same.

   Note that the previous examples in this section represent the ``Flow`` of
   interactions using
   `State  <#State>`__ — this makes
   it easy to observe updated values, as reading the state value will
   automatically cause recompositions. However, composition is *batched*
   pre-frame. This means that if the state changes, and then changes back within
   the same frame, components observing the state won't see the change.

   This is important for interactions, as interactions can regularly start and
   end within the same frame. For example, using the previous example with
   ``Button``:

   .. code:: prettyprint

      val interactionSource = remember { MutableInteractionSource() }
      val isPressed by interactionSource.collectIsPressedAsState()

      Button(onClick = { /* do something */ }, interactionSource = interactionSource) {
          Text(if (isPressed) "Pressed!" else "Not pressed")
      }Interactions.kt

   If a press starts and ends within the same frame, the text will never display
   as "Pressed!". In most cases, this is not an issue — showing a visual effect
   for such a small amount of time will result in flickering, and won't be very
   noticeable to the user. For some cases, such as showing a ripple effect or a
   similar animation, you may want to show the effect for at least a minimum
   amount of time, instead of immediately stopping if the button is no longer
   pressed. To do this, you can directly start and stop animations from inside
   the collect lambda, instead of writing to a state. There is an example of
   this pattern in the `Build an advanced ``Indication`` with animated
   border <#build-advanced>`__ section.

   .. rubric:: Example: Build component with custom interaction handling
      :name: build-component-handling

   To see how you can build components with a custom response to input, here's
   an example of a modified button. In this case, suppose you want a button that
   responds to presses by changing its appearance:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/handling-interactions-iconbutton.gif
      name: image-3
      :alt: Animation of a button that dynamically adds a grocery cart icon when
      clicked
      :width: 50.0%

      **Figure 3.** A button that dynamically adds an icon when clicked.

   To do this, build a custom composable based on ``Button``, and have it take
   an additional ``icon`` parameter to draw the icon (in this case, a shopping
   cart). You call ``collectIsPressedAsState()`` to track whether the user is
   hovering over the button; when they are, you add the icon. Here's what the
   code looks like:

   .. code:: prettyprint

      @Composable
      fun PressIconButton(
          onClick: () -> Unit,
          icon: @Composable () -> Unit,
          text: @Composable () -> Unit,
          modifier: Modifier = Modifier,
          interactionSource: MutableInteractionSource? = null
      ) {
          val isPressed = interactionSource?.collectIsPressedAsState()?.value ?: false

          Button(
              onClick = onClick,
              modifier = modifier,
              interactionSource = interactionSource
          ) {
              AnimatedVisibility(visible = isPressed) {
                  if (isPressed) {
                      Row {
                          icon()
                          Spacer(Modifier.size(ButtonDefaults.IconSpacing))
                      }
                  }
              }
              text()
          }
      }Interactions.kt

   And here's what it looks like to use that new composable:

   .. code:: prettyprint

      PressIconButton(
          onClick = {},
          icon = { Icon(Icons.Filled.ShoppingCart, contentDescription = null) },
          text = { Text("Add to cart") }
      )Interactions.kt

   Because this new ``PressIconButton`` is built on top of the existing Material
   ``Button``, it reacts to user interactions in all the usual ways. When the
   user presses the button, it changes its opacity slightly, just like an
   ordinary Material ``Button``.

   .. rubric:: Create and apply a reusable custom effect with ``Indication``
      :name: reusable-custom-effect

   In previous sections, you learned how to change part of a component in
   response to different ``Interaction``\ s, such as showing an icon when
   pressed. This same approach can be used for changing the value of parameters
   you provide to a component, or changing the content displayed inside a
   component, but this is only applicable on a per-component basis. Often, an
   application or design system will have a generic system for stateful visual
   effects — an effect that should be applied to all components in a consistent
   manner.

   If you are building this kind of design system, customizing one component and
   reusing this customization for other components can be difficult for the
   following reasons:

   -  Every component in the design system needs the same boilerplate
   -  It's easy to forget to apply this effect to newly built components and
      custom clickable components
   -  It may be difficult to combine the custom effect with other effects

   To avoid these issues and easily scale a custom component across your system,
   you can use
   `Indication  <#Indication>`__.
   ``Indication`` represents a reusable visual effect that can be applied across
   components in an application or design system. ``Indication`` is split into
   two parts:

   -  ``IndicationNodeFactory``: A factory that creates
      `Modifier.Node  <#Modifier.Node>`__
      instances that render visual effects for a component. For simpler
      implementations that do not change across components, this can be a
      singleton (object) and reused across the entire application.

      These instances can be stateful or stateless. Since they are created per
      component, they can retrieve values from a ``CompositionLocal`` to change
      how they appear or behave inside a particular component, as with any other
      ``Modifier.Node``.

   -  `Modifier.indication  <#indication>`__:
      A modifier that draws ``Indication`` for a component.
      ``Modifier.clickable`` and other high level interaction modifiers accept
      an indication parameter directly, so they not only emit
      ``Interaction``\ s, but can also draw visual effects for the
      ``Interaction``\ s they emit. So, for simple cases, you can just use
      ``Modifier.clickable`` without needing ``Modifier.indication``.

   .. rubric:: Replace effect with an ``Indication``
      :name: replace-effect

   This section describes how to replace a manual scale effect applied to one
   specific button with an indication equivalent that can be reused across
   multiple components.

   The following code creates a button that scales downwards on press:

   .. code:: prettyprint

      val interactionSource = remember { MutableInteractionSource() }
      val isPressed by interactionSource.collectIsPressedAsState()
      val scale by animateFloatAsState(targetValue = if (isPressed) 0.9f else 1f, label = "scale")

      Button(
          modifier = Modifier.scale(scale),
          onClick = { },
          interactionSource = interactionSource
      ) {
          Text(if (isPressed) "Pressed!" else "Not pressed")
      }Interactions.kt

   To convert the scale effect in the snippet above to an ``Indication``, follow
   these steps:

   #. **Create the**
      `Modifier.Node  <#modifiernode>`__
      **responsible for applying the scale effect**. When attached, the node
      observes the interaction source, similar to previous examples. The only
      difference here is that it directly launches animations instead of
      converting the incoming Interactions to state.

      The node needs to implement
      `DrawModifierNode  <#DrawModifierNode>`__
      so it can override ``ContentDrawScope#draw()``, and render a scale effect
      using the same drawing commands as with any other graphics API in Compose.

      Calling ``drawContent()`` available from the ``ContentDrawScope`` receiver
      will draw the actual component that the ``Indication`` should be applied
      to, so you just need to call this function within a scale transformation.
      Make sure your ``Indication`` implementations always call
      ``drawContent()`` at some point; otherwise, the component you are applying
      the ``Indication`` to will not be drawn.

      **Note:**\  The ``IndicationInstance`` may be lazily created in cases when
      there is an incoming interaction.

      .. code:: prettyprint

         private class ScaleNode(private val interactionSource: InteractionSource) :
             Modifier.Node(), DrawModifierNode {

             var currentPressPosition: Offset = Offset.Zero
             val animatedScalePercent = Animatable(1f)

             private suspend fun animateToPressed(pressPosition: Offset) {
                 currentPressPosition = pressPosition
                 animatedScalePercent.animateTo(0.9f, spring())
             }

             private suspend fun animateToResting() {
                 animatedScalePercent.animateTo(1f, spring())
             }

             override fun onAttach() {
                 coroutineScope.launch {
                     interactionSource.interactions.collectLatest { interaction ->
                         when (interaction) {
                             is PressInteraction.Press -> animateToPressed(interaction.pressPosition)
                             is PressInteraction.Release -> animateToResting()
                             is PressInteraction.Cancel -> animateToResting()
                         }
                     }
                 }
             }

             override fun ContentDrawScope.draw() {
                 scale(
                     scale = animatedScalePercent.value,
                     pivot = currentPressPosition
                 ) {
                     this@draw.drawContent()
                 }
             }
         }Interactions.kt

   #. **Create the ``IndicationNodeFactory``**. Its only responsibility is to
      create a new node instance for a provided interaction source. As there are
      no parameters to configure the indication, the factory can be an object:

      .. code:: prettyprint

         object ScaleIndication : IndicationNodeFactory {
             override fun create(interactionSource: InteractionSource): DelegatableNode {
                 return ScaleNode(interactionSource)
             }

             override fun equals(other: Any?): Boolean = other === ScaleIndication
             override fun hashCode() = 100
         }Interactions.kt

   #. ``Modifier.clickable`` uses ``Modifier.indication`` internally, so to make
      a clickable component with ``ScaleIndication``, all you need to do is
      **provide the ``Indication`` as a parameter to ``clickable``**:

      .. code:: prettyprint

         Box(
             modifier = Modifier
                 .size(100.dp)
                 .clickable(
                     onClick = {},
                     indication = ScaleIndication,
                     interactionSource = null
                 )
                 .background(Color.Blue),
             contentAlignment = Alignment.Center
         ) {
             Text("Hello!", color = Color.White)
         }Interactions.kt

      This also makes it easy to build high level, reusable components using a
      custom ``Indication`` — a button could look like:

      .. code:: prettyprint

         @Composable
         fun ScaleButton(
             onClick: () -> Unit,
             modifier: Modifier = Modifier,
             enabled: Boolean = true,
             interactionSource: MutableInteractionSource? = null,
             shape: Shape = CircleShape,
             content: @Composable RowScope.() -> Unit
         ) {
             Row(
                 modifier = modifier
                     .defaultMinSize(minWidth = 76.dp, minHeight = 48.dp)
                     .clickable(
                         enabled = enabled,
                         indication = ScaleIndication,
                         interactionSource = interactionSource,
                         onClick = onClick
                     )
                     .border(width = 2.dp, color = Color.Blue, shape = shape)
                     .padding(horizontal = 16.dp, vertical = 8.dp),
                 horizontalArrangement = Arrangement.Center,
                 verticalAlignment = Alignment.CenterVertically,
                 content = content
             )
         }Interactions.kt

   You can then use the button in the following way:

   .. code:: prettyprint

      ScaleButton(onClick = {}) {
          Icon(Icons.Filled.ShoppingCart, "")
          Spacer(Modifier.padding(10.dp))
          Text(text = "Add to cart!")
      }Interactions.kt

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/button-custom-indication.gif
      name: image-4
      :alt: An animation of a button with a grocery cart icon that becomes
      smaller when pressed
      :width: 50.0%

      **Figure 4.** A button built with a custom ``Indication``.

   **Note:**\  Ripples are drawn on the ``RenderThread`` (using the framework
   ``RippleDrawable`` under the hood), which means that they can continue to
   animate smoothly while the UI thread is busy, such as when pressing a button
   causes your app to navigate to a new screen. There are no public APIs to
   allow drawing to the ``RenderThread`` manually, so if you are trying to build
   an ``Indication`` that can still have an animation after a click has finished
   (such as a ripple, or the example in the next section), be aware that this
   can cause jank if the click causes a lot of work to happen on the UI thread.

   .. rubric:: Build an advanced ``Indication`` with animated border
      :name: build-advanced

   ``Indication`` is not just limited to transformation effects, such as scaling
   a component. Because ``IndicationNodeFactory`` returns a ``Modifier.Node``,
   you can draw any kind of effect above or below the content as with other
   drawing APIs. For example, you can draw an animated border around the
   component and an overlay on top of the component when it is pressed:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/touchinput/rainbow-effect.gif
      name: image-5
      :alt: A button with a fancy rainbow effect on press
      :width: 50.0%

      **Figure 5.** An animated border effect drawn with ``Indication``.

   The ``Indication`` implementation here is very similar to the previous
   example — it just creates a node with some parameters. Since the animated
   border depends on the shape and the border of the component the
   ``Indication`` is used for, the ``Indication`` implementation also requires
   shape and border width to be provided as parameters:

   .. code:: prettyprint

      data class NeonIndication(private val shape: Shape, private val borderWidth: Dp) : IndicationNodeFactory {

          override fun create(interactionSource: InteractionSource): DelegatableNode {
              return NeonNode(
                  shape,
                  // Double the border size for a stronger press effect
                  borderWidth * 2,
                  interactionSource
              )
          }
      }Interactions.kt

   The ``Modifier.Node`` implementation is also conceptually the same, even if
   the drawing code is more complicated. As before, it observes
   ``InteractionSource`` when attached, launches animations, and implements
   ``DrawModifierNode`` to draw the effect on top of the content:

   .. code:: prettyprint

      private class NeonNode(
          private val shape: Shape,
          private val borderWidth: Dp,
          private val interactionSource: InteractionSource
      ) : Modifier.Node(), DrawModifierNode {
          var currentPressPosition: Offset = Offset.Zero
          val animatedProgress = Animatable(0f)
          val animatedPressAlpha = Animatable(1f)

          var pressedAnimation: Job? = null
          var restingAnimation: Job? = null

          private suspend fun animateToPressed(pressPosition: Offset) {
              // Finish any existing animations, in case of a new press while we are still showing
              // an animation for a previous one
              restingAnimation?.cancel()
              pressedAnimation?.cancel()
              pressedAnimation = coroutineScope.launch {
                  currentPressPosition = pressPosition
                  animatedPressAlpha.snapTo(1f)
                  animatedProgress.snapTo(0f)
                  animatedProgress.animateTo(1f, tween(450))
              }
          }

          private fun animateToResting() {
              restingAnimation = coroutineScope.launch {
                  // Wait for the existing press animation to finish if it is still ongoing
                  pressedAnimation?.join()
                  animatedPressAlpha.animateTo(0f, tween(250))
                  animatedProgress.snapTo(0f)
              }
          }

          override fun onAttach() {
              coroutineScope.launch {
                  interactionSource.interactions.collect { interaction ->
                      when (interaction) {
                          is PressInteraction.Press -> animateToPressed(interaction.pressPosition)
                          is PressInteraction.Release -> animateToResting()
                          is PressInteraction.Cancel -> animateToResting()
                      }
                  }
              }
          }

          override fun ContentDrawScope.draw() {
              val (startPosition, endPosition) = calculateGradientStartAndEndFromPressPosition(
                  currentPressPosition, size
              )
              val brush = animateBrush(
                  startPosition = startPosition,
                  endPosition = endPosition,
                  progress = animatedProgress.value
              )
              val alpha = animatedPressAlpha.value

              drawContent()

              val outline = shape.createOutline(size, layoutDirection, this)
              // Draw overlay on top of content
              drawOutline(
                  outline = outline,
                  brush = brush,
                  alpha = alpha * 0.1f
              )
              // Draw border on top of overlay
              drawOutline(
                  outline = outline,
                  brush = brush,
                  alpha = alpha,
                  style = Stroke(width = borderWidth.toPx())
              )
          }

          /**
           * Calculates a gradient start / end where start is the point on the bounding rectangle of
           * size [size] that intercepts with the line drawn from the center to [pressPosition],
           * and end is the intercept on the opposite end of that line.
           */
          private fun calculateGradientStartAndEndFromPressPosition(
              pressPosition: Offset,
              size: Size
          ): Pair<Offset, Offset> {
              // Convert to offset from the center
              val offset = pressPosition - size.center
              // y = mx + c, c is 0, so just test for x and y to see where the intercept is
              val gradient = offset.y / offset.x
              // We are starting from the center, so halve the width and height - convert the sign
              // to match the offset
              val width = (size.width / 2f) * sign(offset.x)
              val height = (size.height / 2f) * sign(offset.y)
              val x = height / gradient
              val y = gradient * width

              // Figure out which intercept lies within bounds
              val intercept = if (abs(y) <= abs(height)) {
                  Offset(width, y)
              } else {
                  Offset(x, height)
              }

              // Convert back to offsets from 0,0
              val start = intercept + size.center
              val end = Offset(size.width - start.x, size.height - start.y)
              return start to end
          }

          private fun animateBrush(
              startPosition: Offset,
              endPosition: Offset,
              progress: Float
          ): Brush {
              if (progress == 0f) return TransparentBrush

              // This is *expensive* - we are doing a lot of allocations on each animation frame. To
              // recreate a similar effect in a performant way, it would be better to create one large
              // gradient and translate it on each frame, instead of creating a whole new gradient
              // and shader. The current approach will be janky!
              val colorStops = buildList {
                  when {
                      progress < 1 / 6f -> {
                          val adjustedProgress = progress * 6f
                          add(0f to Blue)
                          add(adjustedProgress to Color.Transparent)
                      }
                      progress < 2 / 6f -> {
                          val adjustedProgress = (progress - 1 / 6f) * 6f
                          add(0f to Purple)
                          add(adjustedProgress * MaxBlueStop to Blue)
                          add(adjustedProgress to Blue)
                          add(1f to Color.Transparent)
                      }
                      progress < 3 / 6f -> {
                          val adjustedProgress = (progress - 2 / 6f) * 6f
                          add(0f to Pink)
                          add(adjustedProgress * MaxPurpleStop to Purple)
                          add(MaxBlueStop to Blue)
                          add(1f to Blue)
                      }
                      progress < 4 / 6f -> {
                          val adjustedProgress = (progress - 3 / 6f) * 6f
                          add(0f to Orange)
                          add(adjustedProgress * MaxPinkStop to Pink)
                          add(MaxPurpleStop to Purple)
                          add(MaxBlueStop to Blue)
                          add(1f to Blue)
                      }
                      progress < 5 / 6f -> {
                          val adjustedProgress = (progress - 4 / 6f) * 6f
                          add(0f to Yellow)
                          add(adjustedProgress * MaxOrangeStop to Orange)
                          add(MaxPinkStop to Pink)
                          add(MaxPurpleStop to Purple)
                          add(MaxBlueStop to Blue)
                          add(1f to Blue)
                      }
                      else -> {
                          val adjustedProgress = (progress - 5 / 6f) * 6f
                          add(0f to Yellow)
                          add(adjustedProgress * MaxYellowStop to Yellow)
                          add(MaxOrangeStop to Orange)
                          add(MaxPinkStop to Pink)
                          add(MaxPurpleStop to Purple)
                          add(MaxBlueStop to Blue)
                          add(1f to Blue)
                      }
                  }
              }

              return linearGradient(
                  colorStops = colorStops.toTypedArray(),
                  start = startPosition,
                  end = endPosition
              )
          }

          companion object {
              val TransparentBrush = SolidColor(Color.Transparent)
              val Blue = Color(0xFF30C0D8)
              val Purple = Color(0xFF7848A8)
              val Pink = Color(0xFFF03078)
              val Orange = Color(0xFFF07800)
              val Yellow = Color(0xFFF0D800)
              const val MaxYellowStop = 0.16f
              const val MaxOrangeStop = 0.33f
              const val MaxPinkStop = 0.5f
              const val MaxPurpleStop = 0.67f
              const val MaxBlueStop = 0.83f
          }
      }Interactions.kt

   The main difference here is that there is now a minimum duration for the
   animation with the ``animateToResting()`` function, so even if the press is
   immediately released, the press animation will continue. There is also
   handling for multiple quick presses at the start of ``animateToPressed`` — if
   a press happens during an existing press or resting animation, the previous
   animation is canceled, and the press animation starts from the beginning. To
   support multiple concurrent effects (such as with ripples, where a new ripple
   animation will draw on top of other ripples), you can track the animations in
   a list, instead of canceling existing animations and starting new ones.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Understand gestures  <#understand-gestures>`__
   -  `Kotlin for Jetpack Compose  <#kotlin>`__
   -  `Material Components and layouts  <#material>`__

Last updated 2024-03-25 UTC.

/Migrate to Indication and Ripple APIs
======================================

.. https://developer.android.google.cn/develop/ui/compose/touch-input/user-interactions/migrate-indication-ripple?hl=en

.. container:: devsite-article-body clearfix

   To improve composition performance of interactive components that use
   ``Modifier.clickable``, we've introduced new APIs. These APIs allow for more
   efficient ``Indication`` implementations, such as ripples.

   ``androidx.compose.foundation:foundation:1.7.0+`` and
   ``androidx.compose.material:material-ripple:1.7.0+`` include the following
   API changes:

   **Deprecated**

   **Replacement**

   ``Indication#rememberUpdatedInstance``

   ``IndicationNodeFactory``

   ``rememberRipple()``

   New ``ripple()`` APIs provided in Material libraries instead.

   Note: In this context, "Material libraries" refers to
   ``androidx.compose.material:material``,
   ``androidx.compose.material3:material3``,
   ``androidx.wear.compose:compose-material`` and
   ``androidx.wear.compose:compose-material3.``

   ``RippleTheme``

   Either:

   -  Use the Material library ``RippleConfiguration`` APIs, or
   -  Build your own design system ripple implementation

   This page describes the behavior change impact and instructions for migrating to
   the new APIs.

   Behavior change
   ---------------

   The following library versions include a ripple behavior change:

   -  ``androidx.compose.material:material:1.7.0+``
   -  ``androidx.compose.material3:material3:1.3.0+``
   -  ``androidx.wear.compose:compose-material:1.4.0+``

   These versions of Material libraries no longer use ``rememberRipple()``;
   instead, they use the new ripple APIs. As a result, they do not query
   ``LocalRippleTheme``. Therefore, if you set ``LocalRippleTheme`` in your
   application, **Material components will not use these values**.

   The following section describes how to temporarily fall back to the old behavior
   without migrating; however, we recommend migrating to the new APIs. For
   migration instructions, 
   see `Migrate from rememberRipple to ripple <#migrate-remember-ripple>`__ 
   and the subsequent sections.

   .. _upgrade-material:

   Upgrade Material library version without migrating
   --------------------------------------------------

   **Caution:**\  The ``LocalUseFallbackRippleImplementation CompositionLocal`` API
   is temporary and will be removed in a future release. Using this API prevents
   any performance improvements associated with migrating APIs--it is only intended
   for upgrading library versions without requiring migration.

   To unblock upgrading library versions, you can use the temporary
   ``LocalUseFallbackRippleImplementation CompositionLocal`` API to configure
   Material components to fall back to the old behavior:

   .. code:: prettyprint

      CompositionLocalProvider(LocalUseFallbackRippleImplementation provides true) {
          MaterialTheme {
              App()
          }
      }UserInteractions.kt

   Make sure to provide this *outside* the ``MaterialTheme`` so the old ripples can
   be provided through ``LocalIndication``.

   The following sections describe how to migrate to the new APIs.

   .. _migrate-remember-ripple:

   Migrate from ``rememberRipple`` to ``ripple``
   ---------------------------------------------

   .. _using-material:

   Using a Material library
   ~~~~~~~~~~~~~~~~~~~~~~~~

   If you are using a Material library, directly replace ``rememberRipple()`` with
   a call to ``ripple()`` from the corresponding library. This API creates a ripple
   using values derived from the Material theme APIs. Then, pass the returned
   object to ``Modifier.clickable`` and/or other components.

   For example, the following snippet uses the deprecated APIs:

   .. code:: prettyprint

      Box(
          Modifier.clickable(
              onClick = {},
              interactionSource = remember { MutableInteractionSource() },
              indication = rememberRipple()
          )
      ) {
          // ...
      }UserInteractions.kt

   You should modify the above snippet to:

   .. code:: prettyprint

      @Composable
      private fun RippleExample() {
          Box(
              Modifier.clickable(
                  onClick = {},
                  interactionSource = remember { MutableInteractionSource() },
                  indication = ripple()
              )
          ) {
              // ...
          }
      }UserInteractions.kt

   Note that ``ripple()`` is no longer a composable function and does not need to
   be remembered. It can also be reused across multiple components, similar to
   modifiers, so consider extracting the ripple creation to a top-level value to
   save allocations.

   .. _implementing-custom:

   Implementing custom design system
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If you're implementing your own design system, and you were previously using
   ``rememberRipple()`` along with a custom ``RippleTheme`` to configure the
   ripple, you should instead provide your own ripple API that delegates to the
   ripple node APIs exposed in ``material-ripple``. Then, your components can use
   your own ripple that consumes your theme values directly. For more information,
   see `Migrate from RippleTheme <#migrate-ripple-theme>`__.

   .. _migrate-ripple-theme:

   Migrate from ``RippleTheme``
   ----------------------------

   .. _temporarily-opt:

   Temporarily opt out of behavior change
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Material libraries have a temporary ``CompositionLocal``,
   ``LocalUseFallbackRippleImplementation``, which you can use to configure all
   Material components to fall back to using ``rememberRipple``. This way,
   ``rememberRipple`` continues to query ``LocalRippleTheme``.

   **Caution:**\  Using this API is discouraged due to the performance cost, and is
   a temporary measure to aid migration that will be removed in the future.

   The following code snippet demonstrates how to use the
   ``LocalUseFallbackRippleImplementation CompositionLocal`` API:

   .. code:: prettyprint

      CompositionLocalProvider(LocalUseFallbackRippleImplementation provides true) {
          MaterialTheme {
              App()
          }
      }UserInteractions.kt

   If you're using a custom app theme that is built on top of Material, you can
   safely provide the composition local as part of your app’s theme:

   .. code:: prettyprint

      @OptIn(ExperimentalMaterialApi::class)
      @Composable
      fun MyAppTheme(content: @Composable () -> Unit) {
          CompositionLocalProvider(LocalUseFallbackRippleImplementation provides true) {
              MaterialTheme(content = content)
          }
      }UserInteractions.kt

   For more information, see the `Upgrade Material library version without migrating <#upgrade-material>`__ section.

   .. _disable-ripple:

   Using ``RippleTheme`` to disable a ripple for a given component
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The ``material`` and ``material3`` libraries expose ``RippleConfiguration`` and
   ``LocalRippleConfiguration``, which allow you to configure the appearance of
   ripples within a subtree. Note that ``RippleConfiguration`` and
   ``LocalRippleConfiguration`` are experimental, and only intended for
   per-component customization. Global/theme-wide customization is not supported
   with these APIs; see `Using ``RippleTheme`` to globally change all ripples in an
   application <#globally-change-ripples>`__ for more information on that use case.

   For example, the following snippet uses the deprecated APIs:

   .. code:: prettyprint

      private object DisabledRippleTheme : RippleTheme {

          @Composable
          override fun defaultColor(): Color = Color.Transparent

          @Composable
          override fun rippleAlpha(): RippleAlpha = RippleAlpha(0f, 0f, 0f, 0f)
      }

      // ...
          CompositionLocalProvider(LocalRippleTheme provides DisabledRippleTheme) {
              Button {
                  // ...
              }
          }UserInteractions.kt

   You should modify the above snippet to:

   .. code:: prettyprint

      @OptIn(ExperimentalMaterialApi::class)
      private val DisabledRippleConfiguration =
          RippleConfiguration(isEnabled = false)

      // ...
          CompositionLocalProvider(LocalRippleConfiguration provides DisabledRippleConfiguration) {
              Button {
                  // ...
              }
          }UserInteractions.kt

   .. _change-color-alpha-ripple:

   Using ``RippleTheme`` to change the color/alpha of a ripple for a given component
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   As described in the previous section, ``RippleConfiguration`` and
   ``LocalRippleConfiguration`` are experimental APIs and are only intended for
   per-component customization.

   For example, the following snippet uses the deprecated APIs:

   .. code:: prettyprint

      private object DisabledRippleThemeColorAndAlpha : RippleTheme {

          @Composable
          override fun defaultColor(): Color = Color.Red

          @Composable
          override fun rippleAlpha(): RippleAlpha = MyRippleAlpha
      }

      // ...
          CompositionLocalProvider(LocalRippleTheme provides DisabledRippleThemeColorAndAlpha) {
              Button {
                  // ...
              }
          }UserInteractions.kt

   You should modify the above snippet to:

   .. code:: prettyprint

      @OptIn(ExperimentalMaterialApi::class)
      private val MyRippleConfiguration =
          RippleConfiguration(color = Color.Red, rippleAlpha = MyRippleAlpha)

      // ...
          CompositionLocalProvider(LocalRippleConfiguration provides MyRippleConfiguration) {
              Button {
                  // ...
              }
          }UserInteractions.kt

   .. _globally-change-ripples:

   Using ``RippleTheme`` to globally change all ripples in an application
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Previously, you could use ``LocalRippleTheme`` to define ripple behavior at a
   theme-wide level. This was essentially an integration point between custom
   design system composition locals and ripple. Instead of exposing a generic
   theming primitive, ``material-ripple`` now exposes a
   ``createRippleModifierNode()`` function. This function allows for design system
   libraries to create higher order ``wrapper`` implementation, that query their
   theme values and then delegate the ripple implementation to the node created by
   this function.

   This allows for design systems to directly query what they need, and expose any
   required user-configurable theming layers on top without having to conform to
   what is provided at the ``material-ripple`` layer. This change also makes more
   explicit what theme/specification the ripple is conforming to, as it is the
   ripple API itself that defines that contract, rather than being implicitly
   derived from the theme.

   For guidance, see the `ripple API implementation <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material3/material3/src/commonMain/kotlin/androidx/compose/material3/Ripple.kt>`__
   in Material libraries, and replace the calls to Material composition locals as
   needed for your own design system.

   .. _migrate-indication:

   Migrate from ``Indication`` to ``IndicationNodeFactory``
   --------------------------------------------------------

   .. _passing-indication:

   Passing around ``Indication``
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   If you are just creating an ``Indication`` to pass around, such as creating a
   ripple to pass to ``Modifier.clickable`` or ``Modifier.indication``, you don't
   need to make any changes. ``IndicationNodeFactory`` inherits from
   ``Indication``, so everything will continue to compile and work.

   Creating ``Indication``
   ~~~~~~~~~~~~~~~~~~~~~~~

   If you are creating your own ``Indication`` implementation, the migration should
   be simple in most cases. For example, consider an ``Indication`` that applies a
   scale effect on press:

   .. code:: prettyprint

      object ScaleIndication : Indication {
          @Composable
          override fun rememberUpdatedInstance(interactionSource: InteractionSource): IndicationInstance {
              // key the remember against interactionSource, so if it changes we create a new instance
              val instance = remember(interactionSource) { ScaleIndicationInstance() }

              LaunchedEffect(interactionSource) {
                  interactionSource.interactions.collectLatest { interaction ->
                      when (interaction) {
                          is PressInteraction.Press -> instance.animateToPressed(interaction.pressPosition)
                          is PressInteraction.Release -> instance.animateToResting()
                          is PressInteraction.Cancel -> instance.animateToResting()
                      }
                  }
              }

              return instance
          }
      }

      private class ScaleIndicationInstance : IndicationInstance {
          var currentPressPosition: Offset = Offset.Zero
          val animatedScalePercent = Animatable(1f)

          suspend fun animateToPressed(pressPosition: Offset) {
              currentPressPosition = pressPosition
              animatedScalePercent.animateTo(0.9f, spring())
          }

          suspend fun animateToResting() {
              animatedScalePercent.animateTo(1f, spring())
          }

          override fun ContentDrawScope.drawIndication() {
              scale(
                  scale = animatedScalePercent.value,
                  pivot = currentPressPosition
              ) {
                  this@drawIndication.drawContent()
              }
          }
      }UserInteractions.kt

   You can migrate this in two steps:

   #. Migrate ``ScaleIndicationInstance`` to be a ``DrawModifierNode``. The API
      surface for ``DrawModifierNode`` is very similar to ``IndicationInstance``:
      it exposes a ``ContentDrawScope#draw()`` function that is functionally
      equivalent to ``IndicationInstance#drawContent()``. You need to change that
      function, and then implement the ``collectLatest`` logic inside the node
      directly, instead of the ``Indication``.

      For example, the following snippet uses the deprecated APIs:

      .. code:: prettyprint

         private class ScaleIndicationInstance : IndicationInstance {
             var currentPressPosition: Offset = Offset.Zero
             val animatedScalePercent = Animatable(1f)

             suspend fun animateToPressed(pressPosition: Offset) {
                 currentPressPosition = pressPosition
                 animatedScalePercent.animateTo(0.9f, spring())
             }

             suspend fun animateToResting() {
                 animatedScalePercent.animateTo(1f, spring())
             }

             override fun ContentDrawScope.drawIndication() {
                 scale(
                     scale = animatedScalePercent.value,
                     pivot = currentPressPosition
                 ) {
                     this@drawIndication.drawContent()
                 }
             }
         }UserInteractions.kt

      You should modify the above snippet to:

      .. code:: prettyprint

         private class ScaleIndicationNode(
             private val interactionSource: InteractionSource
         ) : Modifier.Node(), DrawModifierNode {
             var currentPressPosition: Offset = Offset.Zero
             val animatedScalePercent = Animatable(1f)

             private suspend fun animateToPressed(pressPosition: Offset) {
                 currentPressPosition = pressPosition
                 animatedScalePercent.animateTo(0.9f, spring())
             }

             private suspend fun animateToResting() {
                 animatedScalePercent.animateTo(1f, spring())
             }

             override fun onAttach() {
                 coroutineScope.launch {
                     interactionSource.interactions.collectLatest { interaction ->
                         when (interaction) {
                             is PressInteraction.Press -> animateToPressed(interaction.pressPosition)
                             is PressInteraction.Release -> animateToResting()
                             is PressInteraction.Cancel -> animateToResting()
                         }
                     }
                 }
             }

             override fun ContentDrawScope.draw() {
                 scale(
                     scale = animatedScalePercent.value,
                     pivot = currentPressPosition
                 ) {
                     this@draw.drawContent()
                 }
             }
         }UserInteractions.kt

   #. Migrate ``ScaleIndication`` to implement ``IndicationNodeFactory``. Because
      the collection logic is now moved into the node, this is a very simple
      factory object whose only responsibility is to create a node instance.

      For example, the following snippet uses the deprecated APIs:

      .. code:: prettyprint

         object ScaleIndication : Indication {
             @Composable
             override fun rememberUpdatedInstance(interactionSource: InteractionSource): IndicationInstance {
                 // key the remember against interactionSource, so if it changes we create a new instance
                 val instance = remember(interactionSource) { ScaleIndicationInstance() }

                 LaunchedEffect(interactionSource) {
                     interactionSource.interactions.collectLatest { interaction ->
                         when (interaction) {
                             is PressInteraction.Press -> instance.animateToPressed(interaction.pressPosition)
                             is PressInteraction.Release -> instance.animateToResting()
                             is PressInteraction.Cancel -> instance.animateToResting()
                         }
                     }
                 }

                 return instance
             }
         }UserInteractions.kt

      You should modify the above snippet to:

      .. code:: prettyprint

         object ScaleIndicationNodeFactory : IndicationNodeFactory {
             override fun create(interactionSource: InteractionSource): DelegatableNode {
                 return ScaleIndicationNode(interactionSource)
             }

             override fun hashCode(): Int = -1

             override fun equals(other: Any?) = other === this
         }UserInteractions.kt

   .. _using-indication:

   Using ``Indication`` to create an ``IndicationInstance``
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   In most cases, you should use ``Modifier.indication`` to display ``Indication``
   for a component. However, in the rare case that you are manually creating an
   ``IndicationInstance`` using ``rememberUpdatedInstance``, you need to update
   your implementation to check if the ``Indication`` is an
   ``IndicationNodeFactory`` so you can use a lighter implementation. For example,
   ``Modifier.indication`` will internally delegate to the created node if it is an
   ``IndicationNodeFactory``. If not, it will use ``Modifier.composed`` to call
   ``rememberUpdatedInstance``.

Last updated 2024-03-25 UTC.

/Overview: Performance
======================

.. https://developer.android.google.cn/develop/ui/compose/performance?hl=en

.. container:: devsite-article-body clearfix

   Jetpack Compose delivers excellent performance out of the box. Configure your
   app using best practices to avoid common pitfalls and optimize your Compose
   application's performance.

   .. rubric:: Key concepts
      :name: key_concepts

   These are some of the key concepts for performance in Compose:

   -  `Phases  <#phases>`__\ **:** Understanding
      the composition, layout, and drawing phases is crucial for optimizing how
      Compose updates your UI.
   -  `Baseline Profiles  <#baseline-profiles>`__\ **:**
      These profiles precompile essential code, leading to faster app launches
      and smoother interactions.
   -  `Stability  <#stability>`__\ **:** Increase
      the stability of your app to more efficiently skip unnecessary
      recompositions, improving performance.

   .. rubric:: Properly configure your app
      :name: config

   If your app is performing poorly, there might be a configuration problem. A
   good first step is to check the following configuration options:

   -  **Build in Release Mode with R8:** Try running your app in 
      `release mode  <#changing-variant>`__. Debug mode is useful for spotting
      many problems, but it imposes a performance cost and can make it hard to
      spot other issues. You should also 
      `enable optimizing and shrinking  <#enable>`__ with the R8 compiler to ensure a
      performant and efficient release build.
   -  **Use Baseline Profiles:** Baseline Profiles improve performance by
      precompiling code for critical user journeys. Compose includes a default
      profile, but ideally, you should create an app-specific one as well.
      `Learn more about Baseline Profiles in the general Android performance docs  <#overview>`__

   .. rubric:: Tools
      :name: tools

   Familiarize yourself with the suite of
   `tools  <#tooling>`__ available to help you
   measure and analyze your Compose app's performance.

   .. rubric:: Best Practices
      :name: best_practices

   When developing your app with Compose, keep these best practices in mind:

   -  `Avoid expensive calculations  <#use-remember>`__\ **:**
      Use ``remember`` to cache the results of expensive calculations.
   -  `Help lazy layouts  <#use-lazylist-keys>`__\ **:**
      Provide stable keys to lazy layouts using the ``key`` parameter to
      minimize unnecessary recompositions.
   -  `Limit unnecessary recompositions  <#use-derivedstateof>`__\ **:**
      Use ``derivedStateOf`` to limit recompositions when rapidly changing
      state.
   -  `Defer state reads  <#defer-reads%7D>`__\ **:**
      Defer state reads as long as possible by wrapping them in lambda
      functions.
   -  `Use lambda modifiers for changing state  <#defer-reads>`__\ **:**
      Use lambda-based modifiers like ``Modifier.offset { ... }`` for frequently
      changing state variables.
   -  `Avoid backwards writes  <#avoid-backwards>`__\ **:**
      Never write to state that has already been read in a composable.

   For more details, see the `best practices  <#bestpractices>`__ guide.

   .. rubric:: Views
      :name: views

   If you are working with views instead of Compose, see the dedicated 
   `Improve layout performance  <#improving-layouts>`__ guide.

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `App performance guide  <#overview>`__: Discover best
      practices, libraries, and tools to improve performance on Android.
   -  `Inspect Performance  <#inspecting-overview>`__\ **:**
      Inspect app performance.
   -  `Benchmarking  <#benchmarking-overview>`__\ **:**
      Benchmark app performance.
   -  `App startup  <#analysis-optimization>`__\ **:**
      Optimize app startup.
   -  `Baseline profiles  <https://developer.android.google.cn/baseline-profiles>`__\ **:** Understand baseline
      profiles.

Last updated 2024-04-11 UTC.

/Phases
=======

.. https://developer.android.google.cn/develop/ui/compose/performance/phases?hl=en

.. container:: devsite-article-body clearfix

   When Compose updates a frame, it goes through three phases:

   -  **Composition:** Compose determines *what* to show. It runs composable
      functions and builds the UI tree.
   -  **Layout:** Compose determines the size and placement of each element in
      the UI tree.
   -  **Drawing:** Compose actually *renders* the individual UI elements.

   Compose can intelligently skip any of those phases if they aren't needed. For
   example, suppose a single graphic element swaps between two icons of the same
   size. Since this element isn't changing size, and no elements of the UI tree
   are being added or removed, Compose can skip over the composition and layout
   phases and redraw this one element.

   However, coding mistakes can make it hard for Compose to know which phases it
   can safely skip, in which case Compose runs all three phases, which can slow
   down your UI. So, many of the performance best practices are to help Compose
   skip the phases it doesn't need to do.

   For more information, see the `Jetpack Compose Phases  <#phases>`__ guide.

   .. rubric:: General principles
      :name: general_principles

   There are a couple of broad principles to follow that can improve performance
   in general:

   -  **Whenever possible, move calculations out of your composable functions.**
      Composable functions might need to be rerun whenever the UI changes. Any
      code you put in the composable gets re-executed, potentially for every
      frame of an animation. Limit the composable's code to only what it needs
      to build the UI.
   -  **Defer state reads for as long as possible.** By moving state reading to
      a child composable or a later phase, you can minimize recomposition or
      skip the composition phase entirely. You can do this by passing lambda
      functions instead of the state value for frequently changing state and by
      preferring lambda-based modifiers when you pass in frequently changing
      state. You can see an example of this technique in the 
      `Defer reads as long as possible  <#defer-reads>`__
      section of `Follow best practices  <#bestpractices>`__.

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `App performance guide  <#overview>`__: Discover best
      practices, libraries, and tools to improve performance on Android.
   -  `Inspect Performance  <#inspecting-overview>`__\ **:**
      Inspect app performance.
   -  `Benchmarking  <#benchmarking-overview>`__\ **:**
      Benchmark app performance.
   -  `App startup  <#analysis-optimization>`__\ **:**
      Optimize app startup.
   -  `Baseline profiles  <https://developer.android.google.cn/baseline-profiles>`__\ **:** Understand baseline
      profiles.

Last updated 2024-04-11 UTC.

/Baseline profiles
==================

.. https://developer.android.google.cn/develop/ui/compose/performance/baseline-profiles?hl=en

.. container:: devsite-article-body clearfix

   `Baseline Profiles  <https://developer.android.google.cn/baseline-profiles>`__ improve code execution speed by
   about 30% from the first launch by avoiding interpretation and just-in-time
   (JIT) compilation steps for included code paths. By shipping a Baseline
   Profile in an app or library, you enable Android Runtime (ART) to optimize
   included code paths through ahead-of-time (AOT) compilation, providing
   performance enhancements for every new app install and every app update. This
   profile-guided optimization (PGO) lets apps optimize startup, reduce
   interaction jank, and improve overall runtime performance from the first
   launch for end users.

   .. rubric:: Compose performance considerations
      :name: considerations

   Compose is distributed as a library instead of as part of the Android
   platform. This approach lets the Compose team update Compose frequently and
   support a wide range of Android versions. However, distributing Compose as a
   library imposes a cost.

   Android platform code is already compiled and installed on the device.
   Libraries, however, need to be loaded when the app launches and interpreted
   JIT when needed. This can slow the app on startup and when it uses a library
   feature for the first time.

   .. rubric:: Benefits of baseline profiles
      :name: benefits

   You can improve performance by defining `Baseline Profiles  <#overview>`__. These profiles
   define classes and methods needed on critical user journeys and are
   distributed with your app's APK or AAB. During app installation, ART compiles
   this critical code AOT so that it's ready for use when the app launches.

   A good Baseline Profile definition is not always straightforward, and because
   of this, Compose ships with one by default. You might not have to do any work
   to see this benefit. However, the Baseline Profile that ships with Compose
   only contains optimizations for the code within the Compose library.

   .. rubric:: Macrobenchmark
      :name: macrobenchmark

   To get the best optimization, `create a Baseline Profile  <#create-baselineprofile>`__ for
   your app that uses
   `Macrobenchmark  <#macrobenchmark-overview>`__ to cover
   critical user journeys. When you define your own profile, you must test the
   profile to verify that it's helping. A good way to do that is to write
   `Macrobenchmark  <#macrobenchmark-overview>`__ tests for your
   app and check the test results as you write and revise your Baseline Profile.

   For an example of how to write Macrobenchmark tests for your Compose UI, see
   the `Macrobenchmark Compose sample <https://github.com/android/performance-samples/tree/main/MacrobenchmarkSample>`__.

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `App performance guide  <#overview>`__: Discover best
      practices, libraries, and tools to improve performance on Android.
   -  `Inspect Performance  <#inspecting-overview>`__\ **:**
      Inspect app performance.
   -  `Benchmarking  <#benchmarking-overview>`__\ **:**
      Benchmark app performance.
   -  `App startup  <#analysis-optimization>`__\ **:**
      Optimize app startup.
   -  `Baseline profiles  <https://developer.android.google.cn/baseline-profiles>`__\ **:** Understand baseline
      profiles.

Last updated 2024-04-11 UTC.

/Overview: Stability
====================

.. https://developer.android.google.cn/develop/ui/compose/performance/stability?hl=en

.. container:: devsite-article-body clearfix

   Compose considers types to be either stable or unstable. A type is stable if
   it is immutable, or if it is possible for Compose to know whether its value
   has changed between recompositions. A type is unstable if Compose can't know
   whether its value has changed between recompositions.

   Compose uses the stability of a composable's parameters to determine whether
   it can skip the composable during
   `recomposition  <#recomposition>`__:

   -  **Stable parameters:** If a composable has stable parameters that have not
      changed, Compose skips it.
   -  **Unstable parameters:** If a composable has unstable parameters, Compose
      always recomposes it when it recomposes the component's parent.

   If your app includes many unnecessarily unstable components that Compose
   always recomposes, you might observe performance issues and other problems.

   This document details how you can increase the stability of your app to
   improve performance and overall user experience.

   .. rubric:: Immutable objects
      :name: immutable-objects

   The following snippets demonstrates the general principles behind stability
   and recomposition.

   The ``Contact`` class is an immutable data class. This is because all its
   parameters are primitives defined with the ``val`` keyword. Once you create
   an instance of ``Contact``, you cannot change the value of the object's
   properties. If you attempted to do so, you would create a new object.

   .. code:: prettyprint

      data class Contact(val name: String, val number: String)

   The ``ContactRow`` composable has a parameter of type ``Contact``.

   .. code:: prettyprint

      @Composable
      fun ContactRow(contact: Contact, modifier: Modifier = Modifier) {
         var selected by remember { mutableStateOf(false) }

         Row(modifier) {
            ContactDetails(contact)
            ToggleButton(selected, onToggled = { selected = !selected })
         }
      }

   Consider what happens when the user clicks the toggle button and the
   ``selected`` state changes:

   #. Compose evaluates if it should recompose the code inside ``ContactRow``.
   #. It sees that the only argument for ``ContactDetails`` is of type
      ``Contact``.
   #. Because ``Contact`` is an immutable data class, Compose is sure that none
      of the arguments for ``ContactDetails`` have changed.
   #. As such, Compose skips ``ContactDetails`` and does not recompose it.
   #. On the other hand, the arguments for ``ToggleButton`` have changed, and
      Compose recomposes that component.

   .. rubric:: Mutable objects
      :name: mutable-objects

   While the preceding example uses an immutable object, it is possible to
   create a mutable object. Consider the following snippet:

   .. code:: prettyprint

      data class Contact(var name: String, var number: String)

   As each parameter of ``Contact`` is now a ``var``, the class is no longer
   immutable. If its properties changed, Compose wouldn't become aware. This is
   because Compose only tracks changes to Compose `State objects  <#MutableState>`__.

   Compose considers such a class unstable. Compose doesn't skip recomposition
   of unstable classes. As such, if ``Contact`` were defined in this way,
   ``ContactRow`` in the previous example would recompose any time ``selected``
   changed.

   .. rubric:: Implementation in Compose
      :name: implementation-compose

   It can be helpful, though not crucial, to consider how exactly Compose
   determines which functions to skip during recomposition.

   When the Compose compiler runs on your code, it marks each function and type
   with one of several tags. These tags reflect how Compose handles the function
   or type during recomposition.

   **Note:**\  These tags aren't strictly necessary to understand recomposition
   and stability as described in the preceding sections of this document.
   However, they are broadly useful when
   `debugging  <#diagnose>`__ stability
   issues.

   .. rubric:: Functions
      :name: functions

   Compose can mark functions as ``skippable`` or ``restartable``. Note that it
   may mark a function as one, both, or neither of these:

   -  **Skippable**: If the compiler marks a composable as skippable, Compose
      can skip it during recomposition if all its arguments are equal with their
      previous values.
   -  **Restartable**: A composable that is restartable serves as a "scope"
      where recomposition can start. In other words, the function can be a point
      of entry for where Compose can start re-executing code for recomposition
      after state changes.

   .. rubric:: Types
      :name: types

   Compose marks types as either immutable or stable. Each type is one or the
   other:

   -  **Immutable**: Compose marks a type as immutable if the value of its
      properties can never change and all methods are referentially transparent.

      -  Note that all primitive types are marked as immutable. These include
         ``String``, ``Int``, and ``Float``.

   -  **Stable**: Indicates a type whose properties can change after
      construction. If and when those properties change during runtime, Compose
      becomes aware of those changes.

   **Note:**\  A composable's parameters don't have to be immutable for Compose
   to consider it skippable. They can be mutable as long as the Compose runtime
   is notified of all changes. For most types this would be an impractical
   contract to uphold. However, Compose provides mutable classes that do uphold
   this contract for you, such as ``MutableState``, ``SnapshotStateMap``, and
   ``SnapshotStateList``.

   .. rubric:: Debug stability
      :name: debug-stability

   If your app is recomposing a composable whose parameters have not changed,
   first check its definition for parameters that are clearly mutable. Compose
   always recomposes a component if you pass in a type with ``var`` properties,
   or a ``val`` property that use a known unstable type.

   For detailed information about how to diagnose complex issues with stability
   in Compose, see the `Debug stability  <#diagnose>`__ guide.

   .. rubric:: Fix stability issues
      :name: fix-stability

   For information about how to bring stability to your Compose implementation,
   see the `Fix stability issues  <#fix>`__ guide.

   .. rubric:: Summary
      :name: summary

   Overall, you should note the following points:

   -  **Parameters**: Compose determines the stability of each parameter of your
      composables to determine which composables it should skip during
      recomposition.
   -  **Immediate fixes**: If you notice your composable isn't being skipped
      *and it is causing a performance issue*, you should check the obvious
      causes of instability like ``var`` parameters first.
   -  **Compiler reports**: You can use the `compiler reports  <#diagnose>`__ to
      determine what stability is being inferred about your classes.
   -  **Collections**: Compose always considers collection classes unstable,
      such as ``List, Set`` and ``Map``. This is because it cannot be guaranteed
      that they are immutable. You can use `Kotlinx immutable collections  <#immutable-collections>`__
      instead or annotate your classes as ``@Immutable`` or ``@Stable``.
   -  **Other modules**: Compose always considers unstable where they are from
      modules in which the Compose compiler does not run. Wrap the classes in UI
      model classes if required.

   .. rubric:: Further reading
      :name: further-reading

   -  **Performance**: For more debugging tips on Compose performance, check out
      our `best practices guide <http://goo.gle/compose-performance>`__ and 
      `I/O talk <https://www.youtube.com/watch?v=EOQB8PTLkpY>`__.

Last updated 2024-03-25 UTC.

/Diagnose stability issues
==========================

.. https://developer.android.google.cn/develop/ui/compose/performance/stability/diagnose?hl=en

.. container:: devsite-article-body clearfix

   If you are experiencing performance issues that result from unnecessary or
   excessive recomposition, you should debug the stability of your app. This
   guide outlines several methods for doing so.

   **Important:**\  You should aim to resist unnecessary or premature
   optimization. Before optimizing for stability, ensure you are following our
   `best practices for Compose performance <http://goo.gle/compose-performance>`__.
   **Note:**\  If you would like more information about how to measure
   performance properly, see the `Macrobenchmark guide  <#macrobenchmark-overview>`__.

   .. rubric:: Layout Inspector
      :name: layout-inspector

   The Layout Inspector in Android Studio lets you see which composables are
   recomposing in your app. It displays counts of how many times Compose has
   recomposed or skipped a component.

   |Recomposition and skips counts in the Layout Inspector|

   .. rubric:: Compose compiler reports
      :name: compose-compiler

   The Compose compiler can output the results of its stability inference for
   inspection. Using this output, you can determine which of your composables
   are skippable, and which are not. The follow subsections summarize how to use
   these reports, but for more detailed information see the 
   `technical documentation <https://github.com/androidx/androidx/blob/androidx-main/compose/compiler/design/compiler-metrics.md>`__.

   **Warning:**\  You should only use this technique if you are actually
   experiencing performance issues related to stability. Trying to make your
   entire UI skippable is a premature optimization that could lead to
   maintenance difficulties in the future.

   .. rubric:: Setup
      :name: setup

   Compiler compiler reports are not enabled by default. You can activate them
   with a compiler flag. 
   The `exact setup <https://github.com/androidx/androidx/blob/androidx-main/compose/compiler/design/compiler-metrics.md#enabling-metrics>`__
   varies depending on your project, but for most projects you can paste the
   following script into your root ``build.gradle`` file.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Groovy
            :name: groovy

         .. code:: prettyprint

            subprojects {
              tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
                    kotlinOptions {
                        if (project.findProperty("composeCompilerReports") == "true") {
                            freeCompilerArgs += [
                                    "-P",
                                    "plugin:androidx.compose.compiler.plugins.kotlin:reportsDestination=" +
                                            project.buildDir.absolutePath + "/compose_compiler"
                            ]
                        }
                        if (project.findProperty("composeCompilerMetrics") == "true") {
                            freeCompilerArgs += [
                                    "-P",
                                    "plugin:androidx.compose.compiler.plugins.kotlin:metricsDestination=" +
                                            project.buildDir.absolutePath + "/compose_compiler"
                            ]
                        }
                    }
                }
            }

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            subprojects {
                tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile>().configureEach {
                    kotlinOptions {
                        if (project.findProperty("composeCompilerReports") == "true") {
                            freeCompilerArgs += listOf(
                                "-P",
                                "plugin:androidx.compose.compiler.plugins.kotlin:reportsDestination=${project.buildDir.absolutePath}/compose_compiler"
                            )
                        }
                        if (project.findProperty("composeCompilerMetrics") == "true") {
                            freeCompilerArgs += listOf(
                                "-P",
                                "plugin:androidx.compose.compiler.plugins.kotlin:metricsDestination=${project.buildDir.absolutePath}/compose_compiler"
                            )
                        }
                    }
                }
            }

   .. rubric:: Run the task
      :name: run-task

   To debug the stability of your composables, run the task as follows:

   .. code:: prettyprint

      ./gradlew assembleRelease -PcomposeCompilerReports=true

   **Important:**\  Make sure to always run this on a release build to ensure
   accurate results.

   .. rubric:: Example output
      :name: example_output

   This task outputs three files. The following are example outputs from
   `JetSnack <https://github.com/android/compose-samples/tree/master/Jetsnack>`__.

   -  **``<modulename>-classes.txt``:** A report on the stability of classes in
      this module.
      `Sample <https://gist.github.com/bentrengrove/9b823045a160d8a5d986bb4b31106245>`__.
   -  **``<modulename>-composables.txt``:** A report on how restartable and
      skippable the composables are in the module.
      `Sample <https://gist.github.com/bentrengrove/a8ee3716a7df136144041134575f5fcb>`__.
   -  **``<modulename>-composables.csv``:**\ A ``CSV`` version of the
      composables report that you can import into a spreadsheet or processing
      using a script.
      `Sample <https://gist.github.com/bentrengrove/2beb1b2993f68f61a7ba3ed91a1c75c9>`__

   **Note:**\  The ``composeCompilerMetrics`` task produces overall statistics
   on the number of composables in your project and other similar info.
   **Note:**\  These reports make use of the compiler tags described in the
   `Compose stability  <#stability>`__ guide.

   .. rubric:: Composables report
      :name: composables_report

   The ``composables.txt`` file details each composable functions for the given
   module, including the stability of their parameters, and whether they are
   restartable or skippable. The following is a hypothetical example from
   `JetSnack <https://github.com/android/compose-samples/tree/master/Jetsnack>`__:

   .. code:: prettyprint

      restartable skippable scheme("[androidx.compose.ui.UiComposable]") fun SnackCollection(
        stable snackCollection: SnackCollection
        stable onSnackClick: Function1<Long, Unit>
        stable modifier: Modifier? = @static Companion
        stable index: Int = @static 0
        stable highlight: Boolean = @static true
      )

   This ``SnackCollection`` composable is completely restartable, skippable and
   stable. This is generally preferable, although certainly not mandatory.

   On the other hand, let's take a look at another example.

   .. code:: prettyprint

      restartable scheme("[androidx.compose.ui.UiComposable]") fun HighlightedSnacks(
        stable index: Int
        unstable snacks: List<Snack>
        stable onSnackClick: Function1<Long, Unit>
        stable modifier: Modifier? = @static Companion
      )

   The ``HighlightedSnacks`` composable is not skippable. Compose never skips it
   during recomposition. This occurs even if none of its parameters have
   changed. The reason for this is the ``unstable`` parameter, ``snacks``.

   .. rubric:: Classes report
      :name: classes_report

   The file ``classes.txt`` contains a similar report on the classes in the
   given module. The following snippet is the output for the class ``Snack``:

   .. code:: prettyprint

      unstable class Snack {
        stable val id: Long
        stable val name: String
        stable val imageUrl: String
        stable val price: Long
        stable val tagline: String
        unstable val tags: Set<String>
        <runtime stability> = Unstable
      }

   For reference, the following is the definition of ``Snack``:

   .. code:: prettyprint

      data class Snack(
          val id: Long,
          val name: String,
          val imageUrl: String,
          val price: Long,
          val tagline: String = "",
          val tags: Set<String> = emptySet()
      )

   The Compose compiler has marked ``Snack`` as unstable. This is because the
   type of the ``tags`` parameter is ``Set<String>``. This is an immutable type,
   given that it is not a ``MutableSet``. However, standard collection classes
   such as ``Set, List``, and ``Map`` are ultimately interfaces. As such, the
   underlying implementation may still be mutable.

   For example, you could write ``val set: Set<String> = mutableSetOf("foo")``.
   The variable is constant and its declared type is not mutable, but its
   implementation is *still* mutable. The Compose compiler cannot be sure of the
   immutability of this class as it only sees the declared type. It therefore
   marks ``tags`` as unstable.

   **Important:**\  For information about how to bring stability to an unstable
   class such as this, see the `Fix stability issues  <#fix>`__ guide.

Last updated 2024-03-25 UTC.

.. |Recomposition and skips counts in the Layout Inspector| image:: https://developer.android.google.cn/static/develop/ui/compose/images/performance/stability/layout-inspector.png

/Fix stability issues
=====================

.. https://developer.android.google.cn/develop/ui/compose/performance/stability/fix?hl=en

.. container:: devsite-article-body clearfix

   When faced with an `unstable class  <#diagnose>`__ that causes
   performance issues, you should make it stable. This document outlines several
   techniques you can use to do so.

   **Important:**\  Before you fix stability issues, you should learn to
   properly diagnose them. For information, see the `Diagnose stability issues  <#diagnose>`__ guide.

   .. rubric:: Make the class immutable
      :name: make-class

   You should first try to make an unstable class completely immutable.

   -  **Immutable**: Indicates a type where the value of any properties can
      never change after an instance of that type is constructed, and all
      methods are referentially transparent.

      -  Make sure all the class's properties are both ``val`` rather than
         ``var``, and of immutable types.
      -  Primitive types such as ``String, Int``, and ``Float`` are always
         immutable.
      -  If this is impossible, then you must use Compose state for any mutable
         properties.

   -  **Stable**: Indicates a type that is mutable. The Compose runtime does not
      become aware if and when any of the type's public properties or method
      behavior would yield different results from a previous invocation.

   **Important:**\  In practice, this means you should use Compose state for any
   mutable property. For example, ``mutableStateOf(...)``.

   .. rubric:: Immutable collections
      :name: immutable-collections

   A common reason why Compose considers a class unstable are collections. As
   noted in the `Diagnose stability issues  <#diagnose>`__ page, the
   Compose compiler cannot be completely sure that collections such as
   ``List, Map``, and ``Set`` are truly immutable and therefore marks them as
   unstable.

   To resolve this, you can use immutable collections. The Compose compiler
   includes support for `Kotlinx Immutable Collections <https://github.com/Kotlin/kotlinx.collections.immutable>`__.
   These collections are guaranteed to be immutable, and the Compose compiler
   treats them as such. This library is still in alpha, so expect possible
   changes to its API.

   Consider again this unstable class from the `Diagnose stability issues  <#diagnose>`__ guide:

   .. code:: prettyprint

      unstable class Snack {
        …
        unstable val tags: Set<String>
        …
      }

   **Note:**\  This is snippet is the output from the Compose compiler, not the
   class definition. For more information, see the stability guide.
   You can make ``tags`` stable using an immutable collection. In the class,
   change type of ``tags`` to ``ImmutableSet<String>``:

   .. code:: prettyprint

      data class Snack{
          …
          val tags: ImmutableSet<String> = persistentSetOf()
          …
      }

   After doing so, all the class's parameters are immutable, and the Compose
   compiler marks the class as stable.

   .. rubric:: Annotate with ``Stable`` or ``Immutable``
      :name: annotate-stable

   A possible path to resolving stability issues is to annotate unstable classes
   with either ``@Stable`` or ``@Immutable``.

   **Warning:**\  These annotations don't make a class immutable or stable on
   its own. Instead, by using these annotations you opting in to a contract with
   the compiler. Incorrectly annotating a class could cause recomposition to
   break.
   Annotating a class is overriding what the compiler would otherwise
   `infer  <#stability>`__ about your class. It is
   similar to the
   `!! <https://kotlinlang.org/docs/null-safety.html#the-operator>`__
   `operator in Kotlin <https://kotlinlang.org/docs/null-safety.html#the-operator>`__. You
   should be very careful about how you use these annotations. Overriding the
   compiler behavior could lead you to unforeseen bugs, such as your composable
   not recomposing when you expect it to.

   If it is possible to make your class stable without an annotation, you should
   strive to achieve stability that way.

   The following snippet provides a minimal example of a data class annotated as
   immutable:

   .. code:: prettyprint

      @Immutable
      data class Snack(
      …
      )

   Whether you use the ``@Immutable`` or ``@Stable`` annotation, the Compose
   compiler marks the ``Snack`` class as stable.

   .. rubric:: Annotated classes in collections
      :name: annotated-classes

   Consider a composable that includes a parameter of type ``List<Snack>``:

   .. code:: prettyprint

      restartable scheme("[androidx.compose.ui.UiComposable]") fun HighlightedSnacks(
        …
        unstable snacks: List<Snack>
        …
      )

   Even if you annotate ``Snack`` with ``@Immutable``, the Compose compiler
   still marks the ``snacks`` parameter in ``HighlightedSnacks`` as unstable.

   Parameters face the same problem as classes when it comes to collection
   types, *the Compose compiler always marks a parameter of type ``List`` as
   unstable*, even when it is a collection of stable types.

   You cannot mark an individual parameter as stable, nor can you annotate a
   composable to always be skippable. There are multiple paths forwards.

   There are several ways you can get around the problem of unstable
   collections. The following subsections outline these different approaches.

   .. rubric:: Configuration file
      :name: configuration_file

   If you are happy to abide by the stability contract in your codebase, then
   you can opt in to considering Kotlin collections as stable by adding
   ``kotlin.collections.*`` to your `stability configuration file <#configuration-file>`__.

   .. rubric:: Immutable collection
      :name: immutable_collection

   For compile time safety of immutability, you can use a kotlinx immutable
   collection, instead of ``List``.

   .. code:: prettyprint

      @Composable
      private fun HighlightedSnacks(
          …
          snacks: ImmutableList<Snack>,
          …
      )

   .. rubric:: Wrapper
      :name: wrapper

   If you cannot use an immutable collection, you could make your own. To do so,
   wrap the ``List`` in an annotated stable class. A generic wrapper is likely
   the best choice for this, depending on your requirements.

   .. code:: prettyprint

      @Immutable
      data class SnackCollection(
         val snacks: List<Snack>
      )

   You can then use this as the type of the parameter in your composable.

   .. code:: prettyprint

      @Composable
      private fun HighlightedSnacks(
          index: Int,
          snacks: SnackCollection,
          onSnackClick: (Long) -> Unit,
          modifier: Modifier = Modifier
      )

   .. rubric:: Solution
      :name: solution

   After taking either of these approaches, the Compose compiler now marks the
   ``HighlightedSnacks`` Composable as both ``skippable`` and ``restartable``.

   .. code:: prettyprint

      restartable skippable scheme("[androidx.compose.ui.UiComposable]") fun HighlightedSnacks(
        stable index: Int
        stable snacks: ImmutableList<Snack>
        stable onSnackClick: Function1<Long, Unit>
        stable modifier: Modifier? = @static Companion
      )

   During recomposition, Compose can now skip ``HighlightedSnacks`` if none of
   its inputs have changed.

   .. rubric:: Stability configuration file
      :name: configuration-file

   Beginning with Compose Compiler 1.5.5, a configuration file of classes to
   consider stable can be provided at compile time. This allows for considering
   classes you don't control, such as standard library classes like
   ``LocalDateTime``, as stable.

   **Warning:**\  These configurations don't make a class stable on its own.
   Instead, by using these configurations, you opt in to a contract with the
   compiler. Incorrectly configuring a class could cause recomposition to break.
   The configuration file is a plain text file with one class per row. Comments,
   single, and double wildcards are supported. An example configuration is shown
   below:

   .. code:: kotlin

      // Consider LocalDateTime stable
      java.time.LocalDateTime
      // Consider kotlin collections stable
      kotlin.collections.*
      // Consider my datalayer and all submodules stable
      com.datalayer.**
      // Consider my generic type stable based off it's first type parameter only
      com.example.GenericClass<*,_>

   To enable this feature, pass the path of the configuration file to the
   Compose compiler options.

   .. container:: ds-selector-tabs

      .. container:: section

         .. rubric:: Groovy
            :name: groovy

         .. code:: prettyprint

            kotlinOptions {
                freeCompilerArgs += [
                        "-P",
                        "plugin:androidx.compose.compiler.plugins.kotlin:stabilityConfigurationPath=" +
                                project.absolutePath + "/compose_compiler_config.conf"
                ]
            }

      .. container:: section

         .. rubric:: Kotlin
            :name: kotlin

         .. code:: prettyprint

            kotlinOptions {
              freeCompilerArgs += listOf(
                  "-P",
                  "plugin:androidx.compose.compiler.plugins.kotlin:stabilityConfigurationPath=" +
                  "${project.absolutePath}/compose_compiler_config.conf"
              )
            }

   As the Compose compiler runs on each module in your project separately, you
   can provide different configurations to different modules if needed.
   Alternatively, have one configuration at the root level of your project and
   pass that path to each module.

   .. rubric:: Multiple modules
      :name: multiple-modules

   Another common issue involves multi-module architecture. The Compose compiler
   can only infer whether a class is stable if all of the non-primitive types
   that it references are either explicitly marked as stable or in a module that
   was also built with the Compose compiler.

   If your data layer is in a separate module to your UI layer, which is the
   recommended approach, this may be an issue you encounter.

   .. rubric:: Solution
      :name: modules-solution

   To solve this issue you can take one of the following approaches:

   #. Add the classes to your `Compiler configuration file <#configuration-file>`__.
   #. Enable the Compose compiler on your data layer modules, or tag your
      classes with ``@Stable`` or ``@Immutable`` where appropriate.

      -  This involves adding a Compose dependency to your data layer. However,
         it is just the dependency for the Compose runtime and not for
         ``Compose-UI``.

   #. Within your UI module, wrap your data layer classes in UI-specific wrapper
      classes.

   The same issue also occurs when using external libraries if they don't use
   the Compose compiler.

   .. rubric:: Not every composable should be skippable
      :name: not-composable

   When working to fix issues with stability, you shouldn't attempt to make
   every composable skippable. Attempting to do so can lead to premature
   optimisation that introduces more issues than it fixes.

   There are many situations where being skippable doesn't have any real benefit
   and can lead to hard to maintain code. For example:

   -  A composable that is not recomposed often, or at all.
   -  A composable that in itself just calls skippable composables.
   -  A composable with a large number of parameters with expensive equals
      implementations. In this case, the cost of checking if any parameter has
      changed could outweigh the cost of a cheap recomposition.

   When a composable is skippable it adds a small overhead which may not be
   worth it. You can even annotate your composable to be
   `non-restartable  <#NonRestartableComposable>`__
   in cases where you determine that being restartable is more overhead than
   it's worth.

Last updated 2024-03-25 UTC.

/Tools
======

.. https://developer.android.google.cn/develop/ui/compose/performance/tooling?hl=en

.. container:: devsite-article-body clearfix

   It can be hard to know where a performance issue lies and what code to start
   optimizing. Start by using tools to help narrow down where your issue is.

   .. rubric:: Layout Inspector
      :name: layout-inspector

   .. container:: video-wrapper

   Use the `layout Inspector  <#layout-inspector>`__
   to inspect your layout and see recomposition counts.

   If your UI has poor performance, this is often because of a coding error that
   forces your UI to be recomposed excessively. On the other hand, some coding
   errors can prevent your UI from being recomposed when it needs to be, which
   means UI changes aren't showing up on the screen. Tracking recompositions can
   help find both of these kinds of problems.

   Recomposition in itself is not bad; however, unexpected recomposition can be
   an issue.

   For more information, see the Layout Inspector `recomposition counts  <#recomposition-counts>`__
   documentation.

   .. rubric:: Composition tracing
      :name: tracing

   Use `composition tracing  <#tracing>`__ to trace
   your composable functions in a system trace. Traces are often the best source
   of information when first looking into a performance issue. They allow you to
   form a hypothesis of what the issue is and where to start looking.

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `App performance guide  <#overview>`__: Discover best
      practices, libraries, and tools to improve performance on Android.
   -  `Inspect Performance  <#inspecting-overview>`__\ **:**
      Inspect app performance.
   -  `Benchmarking  <#benchmarking-overview>`__\ **:**
      Benchmark app performance.
   -  `App startup  <#analysis-optimization>`__\ **:**
      Optimize app startup.
   -  `Baseline profiles  <https://developer.android.google.cn/baseline-profiles>`__\ **:** Understand baseline
      profiles.

Last updated 2024-04-11 UTC.

/Best practices
===============

.. https://developer.android.google.cn/develop/ui/compose/performance/bestpractices?hl=en

.. container:: devsite-article-body clearfix

   You might encounter common Compose pitfalls. These mistakes might give you
   code that seems to run well enough, but can hurt your UI performance. Follow
   best practices to optimize your app on Compose.

   .. rubric:: Use ``remember`` to minimize expensive calculations
      :name: use-remember

   Composable functions `can run very frequently  <#frequent>`__, as often as for
   every frame of an animation. For this reason, you should do as little
   calculation in the body of your composable as you can.

   An important technique is to `store the results of calculations  <#state-in-composables>`__ with
   `remember  <#remember>`__.
   That way, the calculation runs once, and you can fetch the results whenever
   they're needed.

   For example, here's some code that displays a sorted list of names, but does
   the sorting in a very expensive way:

   .. code:: prettyprint

      @Composable
      fun ContactList(
          contacts: List<Contact>,
          comparator: Comparator<Contact>,
          modifier: Modifier = Modifier
      ) {
          LazyColumn(modifier) {
              // DON’T DO THIS
              items(contacts.sortedWith(comparator)) { contact ->
                  // ...
              }
          }
      }PerformanceSnippets.kt

   Every time ``ContactsList`` is recomposed, the entire contact list is sorted
   all over again, even though the list hasn't changed. If the user scrolls the
   list, the Composable gets recomposed whenever a new row appears.

   To solve this problem, sort the list outside the ``LazyColumn``, and store
   the sorted list with ``remember``:

   .. code:: prettyprint

      @Composable
      fun ContactList(
          contacts: List<Contact>,
          comparator: Comparator<Contact>,
          modifier: Modifier = Modifier
      ) {
          val sortedContacts = remember(contacts, comparator) {
              contacts.sortedWith(comparator)
          }

          LazyColumn(modifier) {
              items(sortedContacts) {
                  // ...
              }
          }
      }PerformanceSnippets.kt

   Now, the list is sorted once, when ``ContactList`` is first composed. If the
   contacts or comparator change, the sorted list is regenerated. Otherwise, the
   composable can keep using the cached sorted list.

   **Note:**\  If possible, it's best to move calculations outside of the
   composable altogether. In this case, you might want to sort the list
   elsewhere, like in your ``ViewModel``, and provide the sorted list as an
   input to the composable.

   .. rubric:: Use lazy layout keys
      :name: use-lazylist-keys

   `Lazy layouts  <#lazy>`__ efficiently reuse items,
   only regenerating or recomposing them when they have to. However, you can
   help optimize lazy layouts for recomposition.

   Suppose a user operation causes an item to move in the list. For example,
   suppose you show a list of notes sorted by modification time with the most
   recently modified note on top.

   .. code:: prettyprint

      @Composable
      fun NotesList(notes: List<Note>) {
          LazyColumn {
              items(
                  items = notes
              ) { note ->
                  NoteRow(note)
              }
          }
      }PerformanceSnippets.kt

   There's a problem with this code though. Suppose the bottom note is changed.
   It's now the most recently modified note, so it goes to the top of the list,
   and every other note moves down one spot.

   Without your help, Compose doesn't realize that unchanged items are just
   being *moved* in the list. Instead, Compose thinks the old "item 2" was
   deleted and a new one was created for item 3, item 4, and all the way down.
   The result is that Compose recomposes **every item** on the list, even though
   only one of them actually changed.

   The solution here is to **provide** `item keys  <#item-keys>`__\ **.** Providing a stable key
   for each item lets Compose avoid unnecessary recompositions. In this case,
   Compose can determine the item now at spot 3 is the same item that used to be
   at spot 2. Since none of the data for that item has changed, Compose doesn't
   have to recompose it.

   .. code:: prettyprint

      @Composable
      fun NotesList(notes: List<Note>) {
          LazyColumn {
              items(
                  items = notes,
                  key = { note ->
                      // Return a stable, unique key for the note
                      note.id
                  }
              ) { note ->
                  NoteRow(note)
              }
          }
      }PerformanceSnippets.kt

   .. rubric:: Use ``derivedStateOf`` to limit recompositions
      :name: use-derivedstateof

   One risk of using state in your compositions is that, if the state changes
   rapidly, your UI might get recomposed more than you need it to. For example,
   suppose you're displaying a scrollable list. You examine the list's state to
   see which item is the first visible item on the list:

   .. code:: prettyprint

      val listState = rememberLazyListState()

      LazyColumn(state = listState) {
          // ...
      }

      val showButton = listState.firstVisibleItemIndex > 0

      AnimatedVisibility(visible = showButton) {
          ScrollToTopButton()
      }PerformanceSnippets.kt

   The problem here is, if the user scrolls the list, ``listState`` is
   constantly changing as the user drags their finger. That means the list is
   constantly being recomposed. However, you don't actually need to recompose it
   that often—you don't need to recompose until a new item becomes visible at
   the bottom. So, that's a lot of extra computation, which makes your UI
   perform badly.

   The solution is to use `derived state  <#derivedstateof>`__. Derived state
   lets you tell Compose which changes of state actually should trigger
   recomposition. In this case, specify that you care about when the first
   visible item changes. When *that* state value changes, the UI needs to
   recompose, but if the user hasn't yet scrolled enough to bring a new item to
   the top, it doesn't have to recompose.

   .. code:: prettyprint

      val listState = rememberLazyListState()

      LazyColumn(state = listState) {
          // ...
      }

      val showButton by remember {
          derivedStateOf {
              listState.firstVisibleItemIndex > 0
          }
      }

      AnimatedVisibility(visible = showButton) {
          ScrollToTopButton()
      }PerformanceSnippets.kt

   .. rubric:: Defer reads as long as possible
      :name: defer-reads

   When a performance issue has been identified, deferring state reads can help.
   Deferring state reads will ensure that Compose re-runs the minimum possible
   code on recomposition. For example, if your UI has state that is hoisted high
   up in the composable tree and you read the state in a child composable, you
   can wrap the state read in a lambda function. Doing this makes the read occur
   only when it is actually needed. For reference, see the implementation in the
   `Jetsnack sample app <https://github.com/android/compose-samples/pull/778>`__. Jetsnack
   implements a collapsing-toolbar-like effect on its detail screen. To
   understand why this technique works, see the blog post `Jetpack Compose: Debugging Recomposition <https://medium.com/androiddevelopers/jetpack-compose-debugging-recomposition-bfcf4a6f8d37>`__.

   To achieve this effect, the ``Title`` composable needs the scroll offset in
   order to offset itself using a ``Modifier``. Here's a simplified version of
   the Jetsnack code before the optimization is made:

   .. code:: prettyprint

      @Composable
      fun SnackDetail() {
          // ...

          Box(Modifier.fillMaxSize()) { // Recomposition Scope Start
              val scroll = rememberScrollState(0)
              // ...
              Title(snack, scroll.value)
              // ...
          } // Recomposition Scope End
      }

      @Composable
      private fun Title(snack: Snack, scroll: Int) {
          // ...
          val offset = with(LocalDensity.current) { scroll.toDp() }

          Column(
              modifier = Modifier
                  .offset(y = offset)
          ) {
              // ...
          }
      }PerformanceSnippets.kt

   When the scroll state changes, Compose invalidates the nearest parent
   recomposition scope. In this case, the nearest scope is the ``SnackDetail``
   composable. Note that ``Box`` is an inline function, and so is not a
   recomposition scope. So Compose recomposes ``SnackDetail`` and any
   composables inside ``SnackDetail``. If you change your code to only read the
   state where you actually use it, then you could reduce the number of elements
   that need to be recomposed.

   .. code:: prettyprint

      @Composable
      fun SnackDetail() {
          // ...

          Box(Modifier.fillMaxSize()) { // Recomposition Scope Start
              val scroll = rememberScrollState(0)
              // ...
              Title(snack) { scroll.value }
              // ...
          } // Recomposition Scope End
      }

      @Composable
      private fun Title(snack: Snack, scrollProvider: () -> Int) {
          // ...
          val offset = with(LocalDensity.current) { scrollProvider().toDp() }
          Column(
              modifier = Modifier
                  .offset(y = offset)
          ) {
              // ...
          }
      }PerformanceSnippets.kt

   The scroll parameter is now a lambda. That means ``Title`` can still
   reference the hoisted state, but the value is only read inside ``Title``,
   where it's actually needed. As a result, when the scroll value changes, the
   nearest recomposition scope is now the ``Title`` composable–Compose no longer
   needs to recompose the whole ``Box``.

   This is a good improvement, but you can do better! **You should be suspicious
   if you are causing recomposition just to re-layout or redraw a Composable.**
   In this case, all you are doing is changing the offset of the ``Title``
   composable, which could be done in the layout phase.

   .. code:: prettyprint

      @Composable
      private fun Title(snack: Snack, scrollProvider: () -> Int) {
          // ...
          Column(
              modifier = Modifier
                  .offset { IntOffset(x = 0, y = scrollProvider()) }
          ) {
              // ...
          }
      }PerformanceSnippets.kt

   Previously, the code used
   `Modifier.offset(x: Dp, y: Dp)  <#offset>`__,
   which takes the offset as a parameter. By switching to the `lambda version of the modifier  <#offset>`__,
   you can make sure the function reads the scroll state in the layout phase. As
   a result, when the scroll state changes, Compose can skip the composition
   phase entirely, and go straight to the layout phase. **When you are passing
   frequently changing State variables into modifiers, you should use the lambda
   versions of the modifiers whenever possible.**

   Here is another example of this approach. This code hasn't been optimized
   yet:

   .. code:: prettyprint

      // Here, assume animateColorBetween() is a function that swaps between
      // two colors
      val color by animateColorBetween(Color.Cyan, Color.Magenta)

      Box(
          Modifier
              .fillMaxSize()
              .background(color)
      )PerformanceSnippets.kt

   Here, the box's background color is switching rapidly between two colors.
   This state is thus changing very frequently. The composable then reads this
   state in the background modifier. As a result, the box has to recompose on
   every frame, since the color is changing on every frame.

   To improve this, use a lambda-based modifier—in this case,
   `drawBehind  <#drawBehind>`__.
   That means the color state is only read during the draw phase. As a result,
   Compose can skip the composition and layout phases entirely—when the color
   changes, Compose goes straight to the draw phase.

   .. code:: prettyprint

      val color by animateColorBetween(Color.Cyan, Color.Magenta)
      Box(
          Modifier
              .fillMaxSize()
              .drawBehind {
                  drawRect(color)
              }
      )PerformanceSnippets.kt

   .. rubric:: Avoid backwards writes
      :name: avoid-backwards

   Compose has a core assumption that you will **never write to state that has
   already been read**. When you do this, it is called a *backwards write* and
   it can cause recomposition to occur on every frame, endlessly.

   The following composable shows an example of this kind of mistake.

   .. code:: prettyprint

      @Composable
      fun BadComposable() {
          var count by remember { mutableStateOf(0) }

          // Causes recomposition on click
          Button(onClick = { count++ }, Modifier.wrapContentSize()) {
              Text("Recompose")
          }

          Text("$count")
          count++ // Backwards write, writing to state after it has been read</b>
      }PerformanceSnippets.kt

   This code updates the count at the end of the composable after reading it on
   the preceding line. If you run this code, you'll see that after you click the
   button, which causes a recomposition, the counter rapidly increases in an
   infinite loop as Compose recomposes this Composable, sees a state read that
   is out of date, and so schedules another recomposition.

   **You can avoid backwards writes altogether by never writing to state in
   Composition.** If at all possible, always write to state in response to an
   event and in a lambda like in the preceding ``onClick`` example.

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `App performance guide  <#overview>`__: Discover best
      practices, libraries, and tools to improve performance on Android.
   -  `Inspect Performance  <#inspecting-overview>`__\ **:**
      Inspect app performance.
   -  `Benchmarking  <#benchmarking-overview>`__\ **:**
      Benchmark app performance.
   -  `App startup  <#analysis-optimization>`__\ **:**
      Optimize app startup.
   -  `Baseline profiles  <https://developer.android.google.cn/baseline-profiles>`__\ **:** Understand baseline
      profiles.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `State and Jetpack Compose  <#state>`__
   -  `Graphics Modifiers  <#modifiers>`__
   -  `Thinking in Compose  <#mental-model>`__

Last updated 2024-04-11 UTC.

/Compose API guidelines
=======================

.. https://developer.android.google.cn/develop/ui/compose/api-guidelines?hl=en

.. container:: devsite-article-body clearfix

   If you're writing Compose code for your app or building Compose libraries and
   APIs, follow best practices to make your code scalable, more performant, and
   consistent with the rest of the ecosystem.

   The following documents provide guidelines for anyone writing code that uses
   Compose:

   -  `API Guidelines for Jetpack Compose <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/compose/docs/compose-api-guidelines.md>`__:
      Outlines patterns, best practices, and prescriptive style guidelines for
      any system using the Jetpack Compose compiler plugin and runtime. It
      includes the following topics:

      -  Kotlin style guidelines for Compose, based on the `Kotlin Coding Conventions <https://kotlinlang.org/docs/coding-conventions.html>`__
      -  Guidance for ``@Composable`` functions and APIs that build on the
         Compose runtime capabilities
      -  Guidelines for APIs that use and extend the Compose UI toolkit
      -  Patterns for addressing use cases when designing a Compose API

   -  `API Guidelines for ``@Composable`` components in Jetpack
      Compose <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/compose/docs/compose-component-api-guidelines.md>`__:
      Provides a set of guidelines and recommendations for creating and using
      ``@Composable`` UI components, including the following topics:

      -  Creating and layering components
      -  Naming a new component
      -  Expressing component dependencies
      -  Parameters in ``@Composable`` components
      -  Following correct patterns for creating component-related classes and
         functions
      -  Documenting ``@Composable`` components
      -  Improving accessibility for components
      -  Updating component APIs while retaining backwards compatibility

   .. rubric:: Audience
      :name: audience

   These guidelines are written for the following three audiences:

   -  **Developers building apps based on Jetpack Compose**. You are in this
      group if you use Jetpack Compose in some part of your app.
   -  **Developers working on Jetpack Compose framework development**. You are
      in this group if you make contributions to the `androidx.compose libraries  <#compose>`__.
   -  **Developers creating libraries based on Jetpack Compose**. You are in
      this group if you create Compose APIs or libraries of Compose UI elements.
      These libraries of Compose components may be publicly available or local
      to your company or team.

   Depending on the group you're in, you have different strictness levels for
   each style guideline. For example, Jetpack Compose framework development
   generally adheres most strictly to these guidelines.

   For more information about the requirements for each developer audience, see
   `RFC2119 <https://www.ietf.org/rfc/rfc2119.txt>`__.

   .. rubric:: Contribute to framework and guidelines
      :name: contribute-framework

   We welcome contributions to select libraries in the ``androidx`` codebase and
   the style guidelines (`Compose API
   guidelines <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/compose/docs/compose-api-guidelines.md>`__
   and `@Composable components
   guidelines <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/compose/docs/compose-component-api-guidelines.md>`__)
   themselves.

   To contribute, follow the instructions in the ``androidx`` `contribution guide <https://android.googlesource.com/platform/frameworks/support/+/androidx-main/CONTRIBUTING.md>`__.

Last updated 2024-05-03 UTC.

/Kotlin for Compose
===================

.. https://developer.android.google.cn/develop/ui/compose/kotlin?hl=en

.. container:: devsite-article-body clearfix

   Jetpack Compose is built around Kotlin. In some cases, Kotlin provides
   special idioms that make it easier to write good Compose code. If you think
   in another programming language and mentally translate that language to
   Kotlin, you're likely to miss out on some of the strength of Compose, and you
   might find it difficult to understand idiomatically-written Kotlin code.
   Gaining more familiarity with Kotlin's style can help you avoid those
   pitfalls.

   .. rubric:: Default arguments
      :name: default-args

   When you write a Kotlin function, you can specify `default values for function arguments <https://kotlinlang.org/docs/reference/functions.html#default-arguments>`__,
   used if the caller doesn't explicitly pass those values. This feature reduces
   the need for overloaded functions.

   For example, suppose you want to write a function that draws a square. That
   function might have a single required parameter, **sideLength**, specifying
   the length of each side. It might have several optional parameters, like
   **thickness**, **edgeColor** and so on; if the caller doesn't specify those,
   the function uses default values. In other languages, you might expect to
   write several functions:

   .. code:: prettyprint

      // We don't need to do this in Kotlin!
      void drawSquare(int sideLength) { }

      void drawSquare(int sideLength, int thickness) { }

      void drawSquare(int sideLength, int thickness, Color edgeColor) { }JavaSnippets.java

   In Kotlin, you can write a single function and specify the default values for
   the arguments:

   .. code:: prettyprint

      fun drawSquare(
          sideLength: Int,
          thickness: Int = 2,
          edgeColor: Color = Color.Black
      ) {
      }KotlinSnippets.kt

   Besides saving you from having to write multiple redundant functions, this
   feature makes your code much clearer to read. If the caller doesn't specify a
   value for an argument, that indicates that they're willing to use the default
   value. In addition, the named parameters make it much easier to see what's
   going on. If you look at the code and see a function call like this, you
   might not know what the parameters mean without checking the ``drawSquare()``
   code:

   .. code:: prettyprint

      drawSquare(30, 5, Color.Red);JavaSnippets.java

   By contrast, this code is self-documenting:

   .. code:: prettyprint

      drawSquare(sideLength = 30, thickness = 5, edgeColor = Color.Red)KotlinSnippets.kt

   Most Compose libraries use default arguments, and it's a good practice to do
   the same for the composable functions that you write. This practice makes
   your composables customizable, but still makes the default behavior simple to
   invoke. So, for example, you might create a simple text element like this:

   .. code:: prettyprint

      Text(text = "Hello, Android!")KotlinSnippets.kt

   That code has the same effect as the following, much more verbose code, in
   which more of the
   `Text  <#Text>`__
   parameters are set explicitly:

   .. code:: prettyprint

      Text(
          text = "Hello, Android!",
          color = Color.Unspecified,
          fontSize = TextUnit.Unspecified,
          letterSpacing = TextUnit.Unspecified,
          overflow = TextOverflow.Clip
      )KotlinSnippets.kt

   Not only is the first code snippet much simpler and easier to read, it's also
   self-documenting. By specifying only the ``text`` parameter, you document
   that for all the other parameters, you want to use the default values. By
   contrast, the second snippet implies that you want to explicitly set the
   values for those other parameters, though the values you set happen to be the
   default values for the function.

   .. rubric:: Higher-order functions and lambda expressions
      :name: higher-order

   Kotlin supports `higher-order functions <https://kotlinlang.org/docs/reference/lambdas.html>`__, functions
   that receive other functions as parameters. Compose builds upon this
   approach. For example, the
   `Button  <#Button>`__
   composable function provides an ``onClick`` lambda parameter. The value of
   that parameter is a function, which the button calls when the user clicks it:

   .. code:: prettyprint

      Button(
          // ...
          onClick = myClickFunction
      )
      // ...KotlinSnippets.kt

   Higher-order functions pair naturally with *lambda expressions*, expressions
   which evaluate to a function. If you only need the function once, you don't
   have to define it elsewhere to pass it to the higher-order function. Instead,
   you can just define the function right there with a lambda expression. The
   previous example assumes that ``myClickFunction()`` is defined elsewhere. But
   if you only use that function here, it's simpler to just define the function
   inline with a lambda expression:

   .. code:: prettyprint

      Button(
          // ...
          onClick = {
              // do something
              // do something else
          }
      ) { /* ... */ }KotlinSnippets.kt

   .. rubric:: Trailing lambdas
      :name: trailing-lambdas

   Kotlin offers a special syntax for calling higher-order functions whose
   *last* parameter is a lambda. If you want to pass a lambda expression as that
   parameter, you can use `trailing lambda syntax <https://kotlinlang.org/docs/lambdas.html#passing-trailing-lambdas>`__.
   Instead of putting the lambda expression within the parentheses, you put it
   afterwards. This is a common situation in Compose, so you need to be familiar
   with how the code looks.

   For example, the last parameter to all layouts, such as the
   `Column()  <#Column>`__
   composable function, is ``content``, a function which emits the child UI
   elements. Suppose you wanted to create a column containing three text
   elements, and you need to apply some formatting. This code would work, but
   it's very cumbersome:

   .. code:: prettyprint

      Column(
          modifier = Modifier.padding(16.dp),
          content = {
              Text("Some text")
              Text("Some more text")
              Text("Last text")
          }
      )KotlinSnippets.kt

   Because the ``content`` parameter is the last one in the function signature,
   and we're passing its value as a lambda expression, we can pull it out of the
   parentheses:

   .. code:: prettyprint

      Column(modifier = Modifier.padding(16.dp)) {
          Text("Some text")
          Text("Some more text")
          Text("Last text")
      }KotlinSnippets.kt

   The two examples have exactly the same meaning. The braces define the lambda
   expression that is passed to the ``content`` parameter.

   In fact, if the *only* parameter you're passing is that trailing lambda—that
   is, if the final parameter is a lambda, and you aren't passing any other
   parameters—you can omit the parentheses altogether. So, for example, suppose
   you didn't need to pass a modifier to the ``Column``. You could write the
   code like this:

   .. code:: prettyprint

      Column {
          Text("Some text")
          Text("Some more text")
          Text("Last text")
      }KotlinSnippets.kt

   This syntax is quite common in Compose, especially for layout elements like
   ``Column``. The last parameter is a lambda expression defining the element's
   children, and those children are specified in braces after the function call.

   .. rubric:: Scopes and receivers
      :name: scopes

   Some methods and properties are only available in a certain scope. The
   limited scope lets you offer functionality where it's needed and avoid
   accidentally using that functionality where it isn't appropriate.

   Consider an example used in Compose. When you call the ``Row`` layout
   composable, your content lambda is automatically invoked within a
   ``RowScope``. This enables ``Row`` to expose functionality which is only
   valid within a ``Row``. The example below demonstrates how ``Row`` has
   exposed a row-specific value for the ``align`` modifier:

   .. code:: prettyprint

      Row {
          Text(
              text = "Hello world",
              // This Text is inside a RowScope so it has access to
              // Alignment.CenterVertically but not to
              // Alignment.CenterHorizontally, which would be available
              // in a ColumnScope.
              modifier = Modifier.align(Alignment.CenterVertically)
          )
      }KotlinSnippets.kt

   Some APIs accept lambdas which are called in *receiver scope*. Those lambdas
   have access to properties and functions that are defined elsewhere, based on
   the parameter declaration:

   .. code:: prettyprint

      Box(
          modifier = Modifier.drawBehind {
              // This method accepts a lambda of type DrawScope.() -> Unit
              // therefore in this lambda we can access properties and functions
              // available from DrawScope, such as the `drawRectangle` function.
              drawRect(
                  /*...*/
                  /* ...
              )
          }
      )KotlinSnippets.kt

   For more information, see `function literals with receiver <https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver>`__
   in the Kotlin documentation.

   .. rubric:: Delegated properties
      :name: delegated

   Kotlin supports `delegated properties <https://kotlinlang.org/docs/reference/delegated-properties.html>`__.
   These properties are called as if they were fields, but their value is
   determined dynamically by evaluating an expression. You can recognize these
   properties by their use of the ``by`` syntax:

   .. code:: prettyprint

      class DelegatingClass {
          var name: String by nameGetterFunction()

          // ...
      }KotlinSnippets.kt

   Other code can access the property with code like this:

   .. code:: prettyprint

      val myDC = DelegatingClass()
      println("The name property is: " + myDC.name)KotlinSnippets.kt

   When ``println()`` executes, ``nameGetterFunction()`` is called to return the
   value of the string.

   These delegated properties are particularly useful when you're working with
   state-backed properties:

   .. code:: prettyprint

      var showDialog by remember { mutableStateOf(false) }

      // Updating the var automatically triggers a state change
      showDialog = trueKotlinSnippets.kt

   **Note:**\  Learn more about ``remember`` and ``mutableStateOf`` in the
   `State in Jetpack Compose documentation  <#state>`__.

   .. rubric:: Destructuring data classes
      :name: destructuring

   If you define a `data class <https://kotlinlang.org/docs/reference/data-classes.html>`__, you can
   easily access the data with a `destructuring declaration <https://kotlinlang.org/docs/reference/multi-declarations.html>`__.
   For example, suppose you define a ``Person`` class:

   .. code:: prettyprint

      data class Person(val name: String, val age: Int)KotlinSnippets.kt

   If you have an object of that type, you can access its values with code like
   this:

   .. code:: prettyprint

      val mary = Person(name = "Mary", age = 35)

      // ...

      val (name, age) = maryKotlinSnippets.kt

   You'll often see that kind of code in Compose functions:

   .. code:: prettyprint

      Row {

          val (image, title, subtitle) = createRefs()

          // The `createRefs` function returns a data object;
          // the first three components are extracted into the
          // image, title, and subtitle variables.

          // ...
      }KotlinSnippets.kt

   Data classes provide a lot of other useful functionality. For example, when
   you define a data class, the compiler automatically defines useful functions
   like ``equals()`` and ``copy()``. You can find more information in the `data classes <https://kotlinlang.org/docs/reference/data-classes.html>`__
   documentation.

   .. rubric:: Singleton objects
      :name: singletons

   Kotlin makes it easy to declare *singletons*, classes which always have one
   and only one instance. These singletons are declared with the `object keyword <https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations>`__.
   Compose often makes use of such objects. For example,
   `MaterialTheme  <#MaterialTheme>`__
   is defined as a singleton object; the ``MaterialTheme.colors``, ``shapes``,
   and ``typography`` properties all contain the values for the current theme.

   .. rubric:: Type-safe builders and DSLs
      :name: dsl

   Kotlin allows creating `domain-specific languages (DSLs) <https://wikipedia.org/wiki/Domain-specific_language>`__ with
   type-safe builders. DSLs allow building complex hierarchical data structures
   in a more maintainable and readable way.

   Jetpack Compose uses DSLs for some APIs such as
   `LazyRow  <#LazyRow>`__
   and
   `LazyColumn  <#LazyColumn>`__.

   .. code:: prettyprint

      @Composable
      fun MessageList(messages: List<Message>) {
          LazyColumn {
              // Add a single item as a header
              item {
                  Text("Message List")
              }

              // Add list of messages
              items(messages) { message ->
                  Message(message)
              }
          }
      }KotlinSnippets.kt

   Kotlin guarantees type-safe builders using `function literals with receiver <https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver>`__.
   If we take the
   `Canvas  <#Canvas>`__
   composable as example, it takes as a parameter a function with
   `DrawScope  <#DrawScope>`__
   as the receiver, ``onDraw: DrawScope.() -> Unit``, allowing the block of code
   to call member functions defined in ``DrawScope``.

   .. code:: prettyprint

      Canvas(Modifier.size(120.dp)) {
          // Draw grey background, drawRect function is provided by the receiver
          drawRect(color = Color.Gray)

          // Inset content by 10 pixels on the left/right sides
          // and 12 by the top/bottom
          inset(10.0f, 12.0f) {
              val quadrantSize = size / 2.0f

              // Draw a rectangle within the inset bounds
              drawRect(
                  size = quadrantSize,
                  color = Color.Red
              )

              rotate(45.0f) {
                  drawRect(size = quadrantSize, color = Color.Blue)
              }
          }
      }KotlinSnippets.kt

   Learn more about type-safe builders and DSLs in `Kotlin's documentation <https://kotlinlang.org/docs/type-safe-builders.html>`__.

   .. rubric:: Kotlin coroutines
      :name: coroutines

   Coroutines offer asynchronous programming support at the language level in
   Kotlin. Coroutines can *suspend* execution without blocking threads. A
   responsive UI is inherently asynchronous, and Jetpack Compose solves this by
   embracing coroutines at the API level instead of using callbacks.

   Jetpack Compose offers APIs that make using coroutines safe within the UI
   layer. The
   `rememberCoroutineScope  <#rememberCoroutineScope>`__
   function returns a
   `CoroutineScope <https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/>`__
   with which you can create coroutines in event handlers and call Compose
   suspend APIs. See the example below using the
   `ScrollState  <#ScrollState>`__'s
   ``animateScrollTo`` API.

   .. code:: prettyprint

      // Create a CoroutineScope that follows this composable's lifecycle
      val composableScope = rememberCoroutineScope()
      Button(
          // ...
          onClick = {
              // Create a new coroutine that scrolls to the top of the list
              // and call the ViewModel to load data
              composableScope.launch {
                  scrollState.animateScrollTo(0) // This is a suspend function
                  viewModel.loadData()
              }
          }
      ) { /* ... */ }KotlinSnippets.kt

   Coroutines execute the block of code *sequentially* by default. A running
   coroutine that calls a suspend function *suspends* its execution until the
   suspend function returns. This is true even if the suspend function moves the
   execution to a different ``CoroutineDispatcher``. In the previous example,
   ``loadData`` won't be executed until the suspend function ``animateScrollTo``
   returns.

   To execute code concurrently, new coroutines need to be created. In the
   example above, to parallelize scrolling to the top of the screen and loading
   data from ``viewModel``, two coroutines are needed.

   .. code:: prettyprint

      // Create a CoroutineScope that follows this composable's lifecycle
      val composableScope = rememberCoroutineScope()
      Button( // ...
          onClick = {
              // Scroll to the top and load data in parallel by creating a new
              // coroutine per independent work to do
              composableScope.launch {
                  scrollState.animateScrollTo(0)
              }
              composableScope.launch {
                  viewModel.loadData()
              }
          }
      ) { /* ... */ }KotlinSnippets.kt

   Coroutines make it easier to combine asynchronous APIs. In the following
   example, we combine the ``pointerInput`` modifier with the animation APIs to
   animate the position of an element when the user taps on the screen.

   .. code:: prettyprint

      @Composable
      fun MoveBoxWhereTapped() {
          // Creates an `Animatable` to animate Offset and `remember` it.
          val animatedOffset = remember {
              Animatable(Offset(0f, 0f), Offset.VectorConverter)
          }

          Box(
              // The pointerInput modifier takes a suspend block of code
              Modifier
                  .fillMaxSize()
                  .pointerInput(Unit) {
                      // Create a new CoroutineScope to be able to create new
                      // coroutines inside a suspend function
                      coroutineScope {
                          while (true) {
                              // Wait for the user to tap on the screen
                              val offset = awaitPointerEventScope {
                                  awaitFirstDown().position
                              }
                              // Launch a new coroutine to asynchronously animate to
                              // where the user tapped on the screen
                              launch {
                                  // Animate to the pressed position
                                  animatedOffset.animateTo(offset)
                              }
                          }
                      }
                  }
          ) {
              Text("Tap anywhere", Modifier.align(Alignment.Center))
              Box(
                  Modifier
                      .offset {
                          // Use the animated offset as the offset of this Box
                          IntOffset(
                              animatedOffset.value.x.roundToInt(),
                              animatedOffset.value.y.roundToInt()
                          )
                      }
                      .size(40.dp)
                      .background(Color(0xff3c1361), CircleShape)
              )
          }KotlinSnippets.kt

   To learn more about Coroutines, check out the `Kotlin coroutines on Android  <#coroutines>`__ guide.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Material Components and layouts  <#material>`__
   -  `Side-effects in Compose  <#side-effects>`__
   -  `Compose layout basics  <#basics>`__

Last updated 2024-05-03 UTC.

/Overview: UI testing
=====================

.. https://developer.android.google.cn/develop/ui/compose/testing?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   Test your app's UI to verify that behavior of your Compose code is correct.
   This lets you catch errors early and improve the quality of your app.

   Compose provides a set of testing APIs to find elements, verify their
   attributes, and perform user actions. The APIs also include advanced features
   such as time manipulation. Use these APIs to create robust tests that verify
   your app's behavior.

   **Important:**\  For more on testing Android apps in general, including
   testing ``View`` elements, see the `general testing section  <#testing>`__. A good place to start is the `Fundamentals of testing Android apps  <#fundamentals>`__ guide.

   .. rubric:: Views
      :name: views

   If you are working with views instead of Compose, see the general `Test apps on Android  <#testing>`__ section.

   In particular, a good place to start is the `Automate UI tests  <#ui-tests>`__ guide. It lays out
   how you can automate tests that run on-device, including when using views.

   .. rubric:: Key Concepts
      :name: concepts

   The following are some key concepts for testing your Compose code.

   -  `Semantics  <#semantics>`__: Compose tests
      interact with the UI using semantics, which give meaning to pieces of the
      UI and are generated alongside the UI hierarchy.
   -  `Testing APIs  <#apis>`__: Compose provides
      testing APIs for finding elements, making assertions on their state and
      properties, and performing actions to simulate user interactions.
   -  `Synchronization  <#synchronization>`__: By
      default, Compose tests automatically synchronize with the UI, waiting for
      it to be idle before making assertions or performing actions.
   -  `Interoperability  <#interoperability>`__: In
      hybrid apps, tests can interact seamlessly with both Compose and
      View-based elements, and integrate with other testing frameworks.

   .. rubric:: Testing cheatsheet
      :name: cheatsheet

   See the `testing cheatsheet  <#testing-cheatsheet>`__ for an
   overview of all the key topics you should learn about testing in Compose.

   .. rubric:: Setup
      :name: setup

   Set up your app to let you test compose code.

   First, add the following dependencies to the ``build.gradle`` file of the
   module containing your UI tests:

   .. code:: prettyprint

      // Test rules and transitive dependencies:
      androidTestImplementation("androidx.compose.ui:ui-test-junit4:$compose_version")
      // Needed for createComposeRule(), but not for createAndroidComposeRule<YourActivity>():
      debugImplementation("androidx.compose.ui:ui-test-manifest:$compose_version")

   This module includes a
   `ComposeTestRule  <#ComposeTestRule>`__
   and an implementation for Android called
   `AndroidComposeTestRule  <#AndroidComposeTestRule>`__.
   Through this rule you can set Compose content or access the activity. You
   construct the rules using factory functions, either
   `createComposeRule  <#createComposeRule>`__
   or, if you need access to an activity,
   `createAndroidComposeRule  <#createAndroidComposeRule>`__.
   A typical UI test for Compose looks like this:

   .. code:: prettyprint

      // file: app/src/androidTest/java/com/package/MyComposeTest.kt

      class MyComposeTest {

          @get:Rule val composeTestRule = createComposeRule()
          // use createAndroidComposeRule<YourActivity>() if you need access to
          // an activity

          @Test
          fun myTest() {
              // Start the app
              composeTestRule.setContent {
                  MyAppTheme {
                      MainScreen(uiState = fakeUiState, /*...*/)
                  }
              }

              composeTestRule.onNodeWithText("Continue").performClick()

              composeTestRule.onNodeWithText("Welcome").assertIsDisplayed()
          }
      }

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `Test apps on Android  <#testing>`__: The main Android testing
      landing page provides a broader view of testing fundamentals and
      techniques.
   -  `Fundamentals of testing  <#fundamentals>`__\ **:** Learn
      more about the core concepts behind testing an Android app.
   -  `Local tests  <#local-tests>`__\ **:** You can run some
      tests locally, on your own workstation.
   -  `Instrumented tests  <#instrumented-tests>`__\ **:** It is
      good practice to also run instrumented tests. That is, tests that run
      directly on-device.
   -  `Continuous integration  <#continuous-integration>`__\ **:**
      Continuous integration lets you integrate your tests into your deployment
      pipeline.
   -  `Test different screen sizes  <#different-screens>`__\ **:** With some many
      devices available to users, you should test for different screen sizes.
   -  `Espresso  <#espresso>`__: While intended for View-based
      UIs, Espresso knowledge can still be helpful for some aspects of Compose
      testing.

   .. rubric:: Codelab
      :name: codelab

   To learn more, try the `Jetpack Compose Testing codelab  <#jetpack-compose-testing>`__.

   .. rubric:: Samples
      :name: samples

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Semantics in Compose  <#semantics>`__
   -  `Window insets in Compose  <#insets>`__
   -  `Other considerations  <#other-considerations>`__

Last updated 2024-05-03 UTC.

/Cheatsheet
===========

.. https://developer.android.google.cn/develop/ui/compose/testing/testing-cheatsheet?hl=en

.. container:: devsite-article-body clearfix

   The Compose testing cheat sheet is a quick reference of some of the most
   useful Compose test APIs. The cheat sheet is also `downloadable in PDF format  <#compose-testing-cheatsheet.pdf>`__.

   |Useful Compose testing APIs|

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `Test apps on Android  <#testing>`__: The main Android testing
      landing page provides a broader view of testing fundamentals and
      techniques.
   -  `Fundamentals of testing  <#fundamentals>`__\ **:** Learn
      more about the core concepts behind testing an Android app.
   -  `Local tests  <#local-tests>`__\ **:** You can run some
      tests locally, on your own workstation.
   -  `Instrumented tests  <#instrumented-tests>`__\ **:** It is
      good practice to also run instrumented tests. That is, tests that run
      directly on-device.
   -  `Continuous integration  <#continuous-integration>`__\ **:**
      Continuous integration lets you integrate your tests into your deployment
      pipeline.
   -  `Test different screen sizes  <#different-screens>`__\ **:** With some many
      devices available to users, you should test for different screen sizes.
   -  `Espresso  <#espresso>`__: While intended for View-based
      UIs, Espresso knowledge can still be helpful for some aspects of Compose
      testing.

Last updated 2024-05-03 UTC.

.. |Useful Compose testing APIs| image:: https://developer.android.google.cn/static/develop/ui/compose/images/compose-testing-cheatsheet.png
   :width: 700px
   :target: https://developer.android.google.cn/static/develop/ui/compose/images/compose-testing-cheatsheet.png

/Semantics
==========

.. https://developer.android.google.cn/develop/ui/compose/testing/semantics?hl=en

.. container:: devsite-article-body clearfix

   UI tests in Compose use *semantics* to interact with the UI hierarchy.
   Semantics, as the name implies, give meaning to a piece of UI. In this
   context, a "piece of UI" (or element) can mean anything from a single
   composable to a full screen. The *semantics tree* is generated alongside the
   UI hierarchy and describes the hierarchy.

   You can learn more about semantics generally in `Semantics in Compose  <#semantics>`__.

   |Diagram showing a typical UI layout, and the way that layout would map to a
   corresponding semantic tree|

   **Figure 1.** A typical UI hierarchy and its semantics tree.

   The semantics framework is primarily used for accessibility, so tests take
   advantage of the information exposed by semantics about the UI hierarchy.
   Developers decide what and how much to expose.

   |A button containing a graphic and text|

   **Figure 2.** A typical button containing an icon and text.

   For example, given a button like this that consists of an icon and a text
   element, the default semantics tree only contains the text label "Like". This
   is because some composables, such as ``Text``, already expose some properties
   to the semantics tree. You can add properties to the semantics tree by using
   a ``Modifier``.

   .. code:: prettyprint

      MyButton(
          modifier = Modifier.semantics { contentDescription = "Add to favorites" }
      )

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `Test apps on Android  <#testing>`__: The main Android testing
      landing page provides a broader view of testing fundamentals and
      techniques.
   -  `Fundamentals of testing  <#fundamentals>`__\ **:** Learn
      more about the core concepts behind testing an Android app.
   -  `Local tests  <#local-tests>`__\ **:** You can run some
      tests locally, on your own workstation.
   -  `Instrumented tests  <#instrumented-tests>`__\ **:** It is
      good practice to also run instrumented tests. That is, tests that run
      directly on-device.
   -  `Continuous integration  <#continuous-integration>`__\ **:**
      Continuous integration lets you integrate your tests into your deployment
      pipeline.
   -  `Test different screen sizes  <#different-screens>`__\ **:** With some many
      devices available to users, you should test for different screen sizes.
   -  `Espresso  <#espresso>`__: While intended for View-based
      UIs, Espresso knowledge can still be helpful for some aspects of Compose
      testing.

Last updated 2024-05-03 UTC.

.. |Diagram showing a typical UI layout, and the way that layout would map to a corresponding semantic tree| image:: https://developer.android.google.cn/static/develop/ui/compose/images/testing-semantic-tree.png
   :width: 500px
.. |A button containing a graphic and text| image:: https://developer.android.google.cn/static/develop/ui/compose/images/testing-button.png
   :width: 200px

/Testing APIs
=============

.. https://developer.android.google.cn/develop/ui/compose/testing/apis?hl=en

.. container:: devsite-article-body clearfix

   There are three main ways to interact with UI elements:

   -  **Finders** let you select one or multiple elements (or *nodes* in the
      semantics tree) to make assertions or perform actions on them.
   -  **Assertions** are used to verify that the elements exist or have certain
      attributes.
   -  **Actions** inject simulated user events on the elements, such as clicks
      or other gestures.

   Some of these APIs accept a
   `SemanticsMatcher  <#SemanticsMatcher>`__
   to refer to one or more *nodes* in the semantics tree.

   **Note:**\  Testing a Compose UI is different from testing a view-based UI.
   The view-based UI toolkit clearly defines what a view is. A view occupies a
   rectangular space and has properties, like identifiers, position, margin, and
   padding. In Compose, because only some composables *emit* UI into the UI
   hierarchy, you need a different approach to matching UI elements.

   .. rubric:: Finders
      :name: finders

   You can use
   `onNode  <#onNode>`__
   and
   `onAllNodes  <#onAllNodes>`__
   to select one or multiple nodes respectively, but you can also use
   convenience finders for the most common searches, such as
   `onNodeWithText  <#onNodeWithText>`__,
   and
   `onNodeWithContentDescription  <#onNodeWithContentDescription>`__.
   You can browse the complete list in the `Compose Testing cheat sheet  <#testing-cheatsheet>`__.

   .. rubric:: Select a single node
      :name: select-single

   .. code:: prettyprint

      composeTestRule.onNode(<<SemanticsMatcher>>, useUnmergedTree = false): SemanticsNodeInteraction

   .. code:: prettyprint

      // Example
      composeTestRule
          .onNode(hasText("Button")) // Equivalent to onNodeWithText("Button")

   .. rubric:: Select multiple nodes
      :name: select-multiple

   .. code:: prettyprint

      composeTestRule
          .onAllNodes(<<SemanticsMatcher>>): SemanticsNodeInteractionCollection

   .. code:: prettyprint

      // Example
      composeTestRule
          .onAllNodes(hasText("Button")) // Equivalent to onAllNodesWithText("Button")

   .. rubric:: Unmerged tree
      :name: unmerged

   Some nodes merge the semantics information of their children. For example, a
   button with two text elements merges the text element labels:

   .. code:: prettyprint

      MyButton {
          Text("Hello")
          Text("World")
      }

   From a test, use
   `printToLog()  <#printToLog>`__
   to show the semantics tree:

   .. code:: prettyprint

      composeTestRule.onRoot().printToLog("TAG")

   This code prints the following output:

   .. code:: kotlin

      Node #1 at (...)px
       |-Node #2 at (...)px
         Role = 'Button'
         Text = '[Hello, World]'
         Actions = [OnClick, GetTextLayoutResult]
         MergeDescendants = 'true'

   If you need to match a node of what would be the *unmerged* tree, you can set
   ``useUnmergedTree`` to ``true``:

   .. code:: prettyprint

      composeTestRule.onRoot(useUnmergedTree = true).printToLog("TAG")

   This code prints the following output:

   .. code:: kotlin

      Node #1 at (...)px
       |-Node #2 at (...)px
         OnClick = '...'
         MergeDescendants = 'true'
          |-Node #3 at (...)px
          | Text = '[Hello]'
          |-Node #5 at (83.0, 86.0, 191.0, 135.0)px
            Text = '[World]'

   The ``useUnmergedTree`` parameter is available in all finders. For example,
   here it's used in an ``onNodeWithText`` finder.

   .. code:: prettyprint

      composeTestRule
          .onNodeWithText("World", useUnmergedTree = true).assertIsDisplayed()

   .. rubric:: Assertions
      :name: assertions

   Check assertions by calling ``assert()`` on the
   `SemanticsNodeInteraction  <#SemanticsNodeInteraction>`__
   returned by a finder with one or multiple matchers:

   .. code:: prettyprint

      // Single matcher:
      composeTestRule
          .onNode(matcher)
          .assert(hasText("Button")) // hasText is a SemanticsMatcher

      // Multiple matchers can use and / or
      composeTestRule
          .onNode(matcher).assert(hasText("Button") or hasText("Button2"))

   You can also use convenience functions for the most common assertions, such
   as
   `assertExists  <#assertExists>`__,
   `assertIsDisplayed  <#assertIsDisplayed>`__,
   and
   `assertTextEquals  <#assertTextEquals>`__.
   You can browse the complete list in the `Compose Testing cheat sheet  <#testing-cheatsheet>`__.

   There are also functions to check assertions on a collection of nodes:

   .. code:: prettyprint

      // Check number of matched nodes
      composeTestRule
          .onAllNodesWithContentDescription("Beatle").assertCountEquals(4)
      // At least one matches
      composeTestRule
          .onAllNodesWithContentDescription("Beatle").assertAny(hasTestTag("Drummer"))
      // All of them match
      composeTestRule
          .onAllNodesWithContentDescription("Beatle").assertAll(hasClickAction())

   .. rubric:: Actions
      :name: actions

   To inject an action on a node, call a ``perform…()`` function:

   .. code:: prettyprint

      composeTestRule.onNode(...).performClick()

   **Note:**\  You cannot chain actions inside a perform function. Instead, make
   multiple ``perform…()`` calls.
   Here are some examples of actions:

   .. code:: prettyprint

      performClick(),
      performSemanticsAction(key),
      performKeyPress(keyEvent),
      performGesture { swipeLeft() }

   You can browse the complete list in the `Compose Testing cheat sheet  <#testing-cheatsheet>`__.

   .. rubric:: Matchers
      :name: matchers

   A variety of matchers are available for testing your Compose code.

   .. rubric:: Hierarchical matchers
      :name: hierarchical-matchers

   Hierarchical matchers let you go up or down the semantics tree and perform
   matching.

   .. code:: prettyprint

      fun hasParent(matcher: SemanticsMatcher): SemanticsMatcher
      fun hasAnySibling(matcher: SemanticsMatcher): SemanticsMatcher
      fun hasAnyAncestor(matcher: SemanticsMatcher): SemanticsMatcher
      fun hasAnyDescendant(matcher: SemanticsMatcher):  SemanticsMatcher

   Here are some examples of these matchers being used:

   .. code:: prettyprint

      composeTestRule.onNode(hasParent(hasText("Button")))
          .assertIsDisplayed()

   .. rubric:: Selectors
      :name: selectors

   An alternative way to create tests is to use *selectors* which can make some
   tests more readable.

   .. code:: prettyprint

      composeTestRule.onNode(hasTestTag("Players"))
          .onChildren()
          .filter(hasClickAction())
          .assertCountEquals(4)
          .onFirst()
          .assert(hasText("John"))

   You can browse the complete list in the `Compose Testing cheat sheet  <#testing-cheatsheet>`__.

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `Test apps on Android  <#testing>`__: The main Android testing
      landing page provides a broader view of testing fundamentals and
      techniques.
   -  `Fundamentals of testing  <#fundamentals>`__\ **:** Learn
      more about the core concepts behind testing an Android app.
   -  `Local tests  <#local-tests>`__\ **:** You can run some
      tests locally, on your own workstation.
   -  `Instrumented tests  <#instrumented-tests>`__\ **:** It is
      good practice to also run instrumented tests. That is, tests that run
      directly on-device.
   -  `Continuous integration  <#continuous-integration>`__\ **:**
      Continuous integration lets you integrate your tests into your deployment
      pipeline.
   -  `Test different screen sizes  <#different-screens>`__\ **:** With some many
      devices available to users, you should test for different screen sizes.
   -  `Espresso  <#espresso>`__: While intended for View-based
      UIs, Espresso knowledge can still be helpful for some aspects of Compose
      testing.

Last updated 2024-05-03 UTC.

/Synchronize tests
==================

.. https://developer.android.google.cn/develop/ui/compose/testing/synchronization?hl=en

.. container:: devsite-article-body clearfix

   Compose tests are synchronized by default with your UI. When you call an
   assertion or an action with the
   `ComposeTestRule  <#ComposeTestRule>`__,
   the test is synchronized beforehand, waiting until the UI tree is idle.

   Normally, you don't have to take any action. However, there are some edge
   cases you should know about.

   When a test is synchronized, your Compose app is advanced in time using a
   virtual clock. This means Compose tests don't run in real time, so they can
   pass as fast as possible.

   However, if you don't use the methods that synchronize your tests, no
   recomposition will occur and the UI will appear to be paused.

   .. code:: prettyprint

      @Test
      fun counterTest() {
          val myCounter = mutableStateOf(0) // State that can cause recompositions.
          var lastSeenValue = 0 // Used to track recompositions.
          composeTestRule.setContent {
              Text(myCounter.value.toString())
              lastSeenValue = myCounter.value
          }
          myCounter.value = 1 // The state changes, but there is no recomposition.

          // Fails because nothing triggered a recomposition.
          assertTrue(lastSeenValue == 1)

          // Passes because the assertion triggers recomposition.
          composeTestRule.onNodeWithText("1").assertExists()
      }

   Note that this requirement only applies to Compose hierarchies and not to the
   rest of the app.

   .. rubric:: Disable automatic synchronization
      :name: disable-autosync

   When you call an assertion or action through the ``ComposeTestRule`` such as
   ``assertExists()``, your test is synchronized with the Compose UI. In some
   cases you might want to stop this synchronization and control the clock
   yourself. For example, you can control time to take accurate screenshots of
   an animation at a point where the UI would still be busy. To disable
   automatic synchronization, set the ``autoAdvance`` property in the
   ``mainClock`` to ``false``:

   .. code:: prettyprint

      composeTestRule.mainClock.autoAdvance = false

   Typically you will then advance the time yourself. You can advance exactly
   one frame with ``advanceTimeByFrame()`` or by a specific duration with
   ``advanceTimeBy()``:

   .. code:: prettyprint

      composeTestRule.mainClock.advanceTimeByFrame()
      composeTestRule.mainClock.advanceTimeBy(milliseconds)

   **Note:**\ 
   `MainTestClock  <#MainTestClock>`__
   is responsible for driving all the recompositions, animations, and gestures.
   The API doesn't control `Android's measure and draw passes  <#how-android-draws>`__.

   .. rubric:: Idle resources
      :name: idling-resources

   Compose can synchronize tests and the UI so that every action and assertion
   is done in an idle state, waiting or advancing the clock as needed. However,
   some asynchronous operations whose results affect the UI state can be run in
   the background while the test is unaware of them.

   Create and register these *idling resources* in your test so that they're
   taken into account when deciding whether the app under test is busy or idle.
   You don't have to take action unless you need to register additional idling
   resources, for example, if you run a background job that is not synchronized
   with Espresso or Compose.

   This API is very similar to Espresso's `Idling Resources  <#idling-resource>`__ to indicate whether
   the subject under test is idle or busy. Use the Compose test rule to register
   the implementation of the
   `IdlingResource  <#IdlingResource>`__.

   .. code:: prettyprint

      composeTestRule.registerIdlingResource(idlingResource)
      composeTestRule.unregisterIdlingResource(idlingResource)

   .. rubric:: Manual synchronization
      :name: manual-sync

   In certain cases, you have to synchronize the Compose UI with other parts of
   your test or the app you're testing.

   The
   `waitForIdle()  <#waitForIdle>`__
   function waits for Compose to be idle, but the function depends on the
   ``autoAdvance`` property:

   .. code:: prettyprint

      composeTestRule.mainClock.autoAdvance = true // Default
      composeTestRule.waitForIdle() // Advances the clock until Compose is idle.

      composeTestRule.mainClock.autoAdvance = false
      composeTestRule.waitForIdle() // Only waits for idling resources to become idle.

   Note that in both cases, ``waitForIdle()`` also waits for pending 
   `draw and layout passes  <#how-android-draws>`__.

   Also, you can advance the clock until a certain condition is met with
   `advanceTimeUntil()  <#advanceTimeUntil>`__.

   .. code:: prettyprint

      composeTestRule.mainClock.advanceTimeUntil(timeoutMs) { condition }

   Note that the given condition should be checking the state that can be
   affected by this clock (it only works with Compose state).

   .. rubric:: Wait for conditions
      :name: manual-sync-waituntil

   Any condition that depends on external work, such as data loading or
   Android's measure or draw (that is, measure or draw external to Compose),
   should use a more general concept such as
   `waitUntil()  <#waitUntil>`__:

   .. code:: prettyprint

      composeTestRule.waitUntil(timeoutMs) { condition }

   You can also use any of the `waitUntil helpers  <#waitUntilAtLeastOneExists>`__:

   .. code:: prettyprint

      composeTestRule.waitUntilAtLeastOneExists(matcher, timeoutMs)

      composeTestRule.waitUntilDoesNotExist(matcher, timeoutMs)

      composeTestRule.waitUntilExactlyOneExists(matcher, timeoutMs)

      composeTestRule.waitUntilNodeCount(matcher, count, timeoutMs)

   **Warning:**\  In some cases, using mechanisms in a test like an external
   ``CountDownLatch`` instead of the ``waitUntil`` APIs could behave
   unexpectedly, since the test clock won't be advanced.

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `Test apps on Android  <#testing>`__: The main Android testing
      landing page provides a broader view of testing fundamentals and
      techniques.
   -  `Fundamentals of testing  <#fundamentals>`__\ **:** Learn
      more about the core concepts behind testing an Android app.
   -  `Local tests  <#local-tests>`__\ **:** You can run some
      tests locally, on your own workstation.
   -  `Instrumented tests  <#instrumented-tests>`__\ **:** It is
      good practice to also run instrumented tests. That is, tests that run
      directly on-device.
   -  `Continuous integration  <#continuous-integration>`__\ **:**
      Continuous integration lets you integrate your tests into your deployment
      pipeline.
   -  `Test different screen sizes  <#different-screens>`__\ **:** With some many
      devices available to users, you should test for different screen sizes.
   -  `Espresso  <#espresso>`__: While intended for View-based
      UIs, Espresso knowledge can still be helpful for some aspects of Compose
      testing.

Last updated 2024-05-03 UTC.

/Interoperability
=================

.. https://developer.android.google.cn/develop/ui/compose/testing/interoperability?hl=en

.. container:: devsite-article-body clearfix

   Compose integrates with common testing frameworks.

   .. rubric:: Interoperability with Espresso
      :name: interoperability_with_espresso

   In a hybrid app, you can find Compose components inside view hierarchies and
   views inside Compose composables (via the
   `AndroidView  <#AndroidView>`__
   composable).

   There are no special steps needed to match either type. You match views with
   Espresso's
   `onView  <#onView>`__,
   and Compose elements with the
   `ComposeTestRule  <#ComposeTestRule>`__.

   .. code:: prettyprint

      @Test
      fun androidViewInteropTest() {
          // Check the initial state of a TextView that depends on a Compose state.
          Espresso.onView(withText("Hello Views")).check(matches(isDisplayed()))
          // Click on the Compose button that changes the state.
          composeTestRule.onNodeWithText("Click here").performClick()
          // Check the new value.
          Espresso.onView(withText("Hello Compose")).check(matches(isDisplayed()))
      }

   .. rubric:: Interoperability with UiAutomator
      :name: uiautomator-interop

   By default, composables are accessible from
   `UiAutomator  <#ui-automator>`__ only by
   their convenient descriptors (displayed text, content description, etc.). If
   you want to access any composable that uses
   `Modifier.testTag  <#testTag>`__,
   you need to enable the semantic property ``testTagsAsResourceId`` for the
   particular composable's subtree. Enabling this behavior is useful for
   composables that don't have any other unique handle, such as scrollable
   composables (for example, ``LazyColumn``).

   **Note:**\  This feature is available in Jetpack Compose version
   1.2.0-alpha08 and higher.
   Enable the semantic property only once high in your composables hierarchy to
   ensure all nested composables with ``Modifier.testTag`` are accessible from
   UiAutomator.

   .. code:: prettyprint

      Scaffold(
          // Enables for all composables in the hierarchy.
          modifier = Modifier.semantics {
              testTagsAsResourceId = true
          }
      ){
          // Modifier.testTag is accessible from UiAutomator for composables nested here.
          LazyColumn(
              modifier = Modifier.testTag("myLazyColumn")
          ){
              // Content
          }
      }

   Any composable with the ``Modifier.testTag(tag)`` can be accessible with the
   use of
   `By.res(resourceName)  <#res>`__
   using the same ``tag`` as the ``resourceName``.

   **Caution:**\  Make sure you don't use
   `By.res(resourcePackage, resourceId)  <#res_1>`__
   as this formats the argument as ``$resourcePackage:id/$resourceId``, which is
   different from ``Modifier.testTag``.
   .. code:: prettyprint

      val device = UiDevice.getInstance(getInstrumentation())

      val lazyColumn: UiObject2 = device.findObject(By.res("myLazyColumn"))
      // Some interaction with the lazyColumn.

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `Test apps on Android  <#testing>`__: The main Android testing
      landing page provides a broader view of testing fundamentals and
      techniques.
   -  `Fundamentals of testing  <#fundamentals>`__\ **:** Learn
      more about the core concepts behind testing an Android app.
   -  `Local tests  <#local-tests>`__\ **:** You can run some
      tests locally, on your own workstation.
   -  `Instrumented tests  <#instrumented-tests>`__\ **:** It is
      good practice to also run instrumented tests. That is, tests that run
      directly on-device.
   -  `Continuous integration  <#continuous-integration>`__\ **:**
      Continuous integration lets you integrate your tests into your deployment
      pipeline.
   -  `Test different screen sizes  <#different-screens>`__\ **:** With some many
      devices available to users, you should test for different screen sizes.
   -  `Espresso  <#espresso>`__: While intended for View-based
      UIs, Espresso knowledge can still be helpful for some aspects of Compose
      testing.

Last updated 2024-05-03 UTC.

/Common patterns
================

.. https://developer.android.google.cn/develop/ui/compose/testing/common-patterns?hl=en

.. container:: devsite-article-body clearfix

   You can test your Compose app with well-established approaches and patterns.

   .. rubric:: Test in isolation
      :name: isolation

   `ComposeTestRule  <#ComposeTestRule>`__
   lets you start an activity displaying any composable: your full application,
   a single screen, or a small element. It's also a good practice to check that
   your composables are correctly encapsulated and they work independently,
   allowing for easier and more focused UI testing.

   This doesn't mean you should *only* create unit UI tests. UI tests scoping
   larger parts of your UI are also very important.

   .. rubric:: Access the activity and resources after setting your own content
      :name: componentactivity

   Oftentimes you need to set the content under test using
   ``composeTestRule.setContent`` and you also need to access activity
   resources, for example to assert that a displayed text matches a string
   resource. However, you can't call ``setContent`` on a rule created with
   ``createAndroidComposeRule()`` if the activity already calls it.

   A common pattern to achieve this is to create an ``AndroidComposeTestRule``
   using an empty activity such as
   `ComponentActivity  <#ComponentActivity)>`__.

   .. code:: prettyprint

      class MyComposeTest {

          @get:Rule
          val composeTestRule = createAndroidComposeRule<ComponentActivity>()

          @Test
          fun myTest() {
              // Start the app
              composeTestRule.setContent {
                  MyAppTheme {
                      MainScreen(uiState = exampleUiState, /*...*/)
                  }
              }
              val continueLabel = composeTestRule.activity.getString(R.string.next)
              composeTestRule.onNodeWithText(continueLabel).performClick()
          }
      }

   Note that ``ComponentActivity`` needs to be added to your app's
   ``AndroidManifest.xml`` file. Enable that by adding this dependency to your
   module:

   .. code:: prettyprint

      debugImplementation("androidx.compose.ui:ui-test-manifest:$compose_version")

   .. rubric:: Custom semantics properties
      :name: custom-semantics-properties

   You can create custom `semantics  <#semantics>`__
   properties to expose information to tests. To do this, define a new
   ``SemanticsPropertyKey`` and make it available using the
   ``SemanticsPropertyReceiver``.

   .. code:: prettyprint

      // Creates a semantics property of type Long.
      val PickedDateKey = SemanticsPropertyKey<Long>("PickedDate")
      var SemanticsPropertyReceiver.pickedDate by PickedDateKey

   Now use that property in the ``semantics`` modifier:

   .. code:: prettyprint

      val datePickerValue by remember { mutableStateOf(0L) }
      MyCustomDatePicker(
          modifier = Modifier.semantics { pickedDate = datePickerValue }
      )

   From tests, use ``SemanticsMatcher.expectValue`` to assert the value of the
   property:

   .. code:: prettyprint

      composeTestRule
          .onNode(SemanticsMatcher.expectValue(PickedDateKey, 1445378400)) // 2015-10-21
          .assertExists()

   **Warning:**\  You should only use custom Semantics properties when it's hard
   to match a specific item using the given finders and matchers. Using custom
   Semantics properties to expose visual properties such as colors, font size or
   rounded corner radius is not recommended, as it can pollute production code
   and wrong implementations can lead to bugs that are hard to find.

   .. rubric:: Verify state restoration
      :name: verify_state_restoration

   Verify that the state of your Compose elements is correctly restored when the
   activity or process is recreated. Perform such checks without relying on
   activity recreation with the
   `StateRestorationTester  <#StateRestorationTester>`__
   class.

   This class lets you simulate the recreation of a composable. It's especially
   useful to verify the implementation of
   `rememberSaveable  <#rememberSaveable>`__.

   .. code:: prettyprint

      class MyStateRestorationTests {

          @get:Rule
          val composeTestRule = createComposeRule()

          @Test
          fun onRecreation_stateIsRestored() {
              val restorationTester = StateRestorationTester(composeTestRule)

              restorationTester.setContent { MainScreen() }

              // TODO: Run actions that modify the state

              // Trigger a recreation
              restorationTester.emulateSavedInstanceStateRestore()

              // TODO: Verify that state has been correctly restored.
          }
      }

   .. rubric:: Test different device configurations
      :name: test_different_device_configurations

   Android apps need to adapt to many changing conditions: window sizes,
   locales, font sizes, dark and light themes, and more. Most of these
   conditions are derived from device-level values controlled by the user and
   exposed with the current
   `Configuration  <#Configuration>`__
   instance. Testing different configurations directly in a test is difficult
   since the test must configure device-level properties.

   `DeviceConfigurationOverride  <#DeviceConfigurationOverride>`__
   is a test-only API that lets you simulate different device configurations in
   a localized way for the ``@Composable`` content under test.

   **Note:**\  ``DeviceConfigurationOverride`` is available as of Compose
   ``1.7.0-alpha03``
   The companion object of ``DeviceConfigurationOverride`` has the following
   extension functions, which override device-level configuration properties:

   -  `DeviceConfigurationOverride.DarkMode()  <#DarkMode>`__:
      Overrides the system to dark theme or light theme.
   -  `DeviceConfigurationOverride.FontScale()  <#FontScale>`__:
      Overrides the `system font scale  <#TaskUseDP>`__.
   -  `DeviceConfigurationOverride.FontWeightAdjustment()  <#FontWeightAdjustment>`__:
      Overrides the system font weight adjustment.
   -  `DeviceConfigurationOverride.ForcedSize()  <#ForcedSize>`__:
      Forces a specific amount of space regardless of device size.
   -  `DeviceConfigurationOverride.LayoutDirection()  <#LayoutDirection>`__:
      Overrides the `layout direction  <#SupportLayoutMirroring>`__
      (left-to-right or right-to-left).
   -  `DeviceConfigurationOverride.Locales()  <#Locales>`__:
      Overrides the `locale  <#localization>`__.
   -  `DeviceConfigurationOverride.RoundScreen()  <#RoundScreen>`__:
      Overrides if the screen is
      `round  <#design-for-round>`__.

   To apply a specific override, wrap the content under test in a call to the
   `DeviceConfigurationOverride()  <#DeviceConfigurationOverride>`__
   top-level function, passing the override to apply as a parameter.

   For example, the following code applies the
   ``DeviceConfigurationOverride.ForcedSize()`` override to change the density
   locally, forcing the ``MyScreen`` composable to be rendered in a large
   landscape window, even if the device the test is running on doesn't support
   that window size directly:

   .. code:: prettyprint

      composeTestRule.setContent {
          DeviceConfigurationOverride(
              DeviceConfigurationOverride.ForcedSize(DpSize(1280.dp, 800.dp))
          ) {
              MyScreen() // will be rendered in the space for 1280dp by 800dp without clipping
          }
      }DeviceConfigurationOverrideSnippets.kt

   To apply multiple overrides together, use
   `DeviceConfigurationOverride.then()  <#then>`__:

   .. code:: prettyprint

      composeTestRule.setContent {
          DeviceConfigurationOverride(
              DeviceConfigurationOverride.FontScale(1.5f) then
                  DeviceConfigurationOverride.FontWeightAdjustment(200)
          ) {
              Text(text = "text with increased scale and weight")
          }
      }DeviceConfigurationOverrideSnippets.kt

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `Test apps on Android  <#testing>`__: The main Android testing
      landing page provides a broader view of testing fundamentals and
      techniques.
   -  `Fundamentals of testing  <#fundamentals>`__\ **:** Learn
      more about the core concepts behind testing an Android app.
   -  `Local tests  <#local-tests>`__\ **:** You can run some
      tests locally, on your own workstation.
   -  `Instrumented tests  <#instrumented-tests>`__\ **:** It is
      good practice to also run instrumented tests. That is, tests that run
      directly on-device.
   -  `Continuous integration  <#continuous-integration>`__\ **:**
      Continuous integration lets you integrate your tests into your deployment
      pipeline.
   -  `Test different screen sizes  <#different-screens>`__\ **:** With some many
      devices available to users, you should test for different screen sizes.
   -  `Espresso  <#espresso>`__: While intended for View-based
      UIs, Espresso knowledge can still be helpful for some aspects of Compose
      testing.

Last updated 2024-05-03 UTC.

/Debug tests
============

.. https://developer.android.google.cn/develop/ui/compose/testing/debug?hl=en

.. container:: devsite-article-body clearfix

   The main way to solve problems in your tests is to look at the semantics
   tree. Print the tree by calling ``composeTestRule.onRoot().printToLog()`` at
   any point in your test. This function prints a log like this:

   .. code:: kotlin

      Node #1 at (...)px
       |-Node #2 at (...)px
         OnClick = '...'
         MergeDescendants = 'true'
          |-Node #3 at (...)px
          | Text = 'Hi'
          |-Node #5 at (83.0, 86.0, 191.0, 135.0)px
            Text = 'There'

   These logs contain valuable information for tracking bugs down.

   .. rubric:: Additional Resources
      :name: additional_resources

   -  `Test apps on Android  <#testing>`__: The main Android testing
      landing page provides a broader view of testing fundamentals and
      techniques.
   -  `Fundamentals of testing  <#fundamentals>`__\ **:** Learn
      more about the core concepts behind testing an Android app.
   -  `Local tests  <#local-tests>`__\ **:** You can run some
      tests locally, on your own workstation.
   -  `Instrumented tests  <#instrumented-tests>`__\ **:** It is
      good practice to also run instrumented tests. That is, tests that run
      directly on-device.
   -  `Continuous integration  <#continuous-integration>`__\ **:**
      Continuous integration lets you integrate your tests into your deployment
      pipeline.
   -  `Test different screen sizes  <#different-screens>`__\ **:** With some many
      devices available to users, you should test for different screen sizes.
   -  `Espresso  <#espresso>`__: While intended for View-based
      UIs, Espresso knowledge can still be helpful for some aspects of Compose
      testing.

Last updated 2024-05-03 UTC.

/Overview: Migrate to Compose
=============================

.. https://developer.android.google.cn/develop/ui/compose/migrate?hl=en

.. container:: devsite-article-body clearfix

   Jetpack Compose was designed with View interoperability right from the
   start—you can use Compose within Views, and vice versa. This functionality
   allows you to adopt Compose in your existing View-based app without having to
   rewrite it from scratch.

   The following pages describe how to integrate Compose with your existing
   apps:

   -  `Migration strategy  <#strategy>`__: Learn the
      strategy to safely and incrementally introduce Compose into your codebase.
   -  `Interoperability APIs  <#interoperability-apis>`__: Learn about
      Compose's APIs to help you combine Compose with View-based UI.
   -  `Other considerations  <#other-considerations>`__:
      Learn other considerations like theming, architecture, and testing while
      migrating your View-based app to Compose.

   .. rubric:: Samples
      :name: samples

   The following samples demonstrate Jetpack Compose and View interoperability:

Last updated 2024-05-03 UTC.

/Migration strategy
===================

.. https://developer.android.google.cn/develop/ui/compose/migrate/strategy?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   If you have an existing View-based app, you may not want to rewrite its
   entire UI all at once. This page helps you add new Compose components into
   your existing app. To get started with using Compose in your app, see `Set up Compose for an existing app  <#setup-compose>`__.

   Jetpack Compose was designed with View interoperability right from the start.
   This functionality means you can migrate your existing View-based app to
   Compose while still being able to build new features. To migrate to Compose,
   we recommend an incremental migration where Compose and Views co-exist in
   your codebase until your app is fully in Compose.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/interop-stages.png
      name: image-1
      :alt: The stages of a View-based app’s migration to Compose
      :width: 100.0%

      **Figure 1**. The stages of a View-based app’s migration to Compose

   To migrate your app to Compose, follow these steps:

   #. Build new screens with Compose.
   #. As you’re building features, identify reusable elements and start to
      create a library of common UI components.
   #. Replace existing features one screen at a time.

   .. rubric:: Build new screens with Compose
      :name: build-new

   Using Compose to build new features that encompass an entire screen is the
   best way to drive your adoption of Compose. With this strategy, you can add
   features and take advantage of the `benefits of Compose  <#why-adopt>`__ while still catering to your
   company’s business needs.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/interop-newscreen.png
      name: image-2
      :alt: A new screen written in Compose
      :width: 40.0%

      **Figure 2**. A new screen written in Compose

   When you use Compose to build new screens in your existing app, you're still
   working under the constraints of your app’s architecture. If you are using
   Fragments and the Navigation component, then you would have to create a new
   Fragment and have its contents in Compose.

   To use Compose in a Fragment, return a
   `ComposeView  <#ComposeView>`__
   in the ``onCreateView()`` lifecycle method of your Fragment. ``ComposeView``
   has a ``setContent()`` method where you can provide a composable function.

   .. code:: prettyprint

      class NewFeatureFragment : Fragment() {
          override fun onCreateView(
              inflater: LayoutInflater,
              container: ViewGroup?,
              savedInstanceState: Bundle?
          ): View {
              return ComposeView(requireContext()).apply {
                  setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
                  setContent {
                      NewFeatureScreen()
                  }
              }
          }
      }MigrationStrategySnippets.kt

   See `ComposeView in Fragments  <#compose-in-fragments>`__
   to learn more.

   .. rubric:: Add new features in existing screens
      :name: existing-screens

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/interop-existingscreen.png
      name: image-3
      :alt: An existing screen with mixed Views and Compose
      :width: 40.0%

      **Figure 3**. An existing screen with mixed Views and Compose

   You can also use Compose in an existing View-based screen if the new feature
   you are adding is part of an existing screen. To do so, add a ``ComposeView``
   to the View hierarchy, just like any other View.

   For example, say you want to add a child view to a ``LinearLayout``. You can
   do so in XML as follows:

   .. code:: prettyprint

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:orientation="vertical"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

        <TextView
            android:id="@+id/text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" />

        <androidx.compose.ui.platform.ComposeView
            android:id="@+id/compose_view"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />
      </LinearLayout>migration_strategy_existing_screens.xml

   Once the view has been inflated, you can later reference the ``ComposeView``
   in the hierarchy and call ``setContent()``.

   To learn more about ``ComposeView``, check out `Interoperability APIs  <#interoperability-apis>`__.

   .. rubric:: Build a library of common UI components
      :name: build-library

   As you’re building features with Compose, you’ll quickly realize that you end
   up building a library of components. Creating a library of common UI
   components allows you to have a single source of truth for these components
   in your app and promote reusability. Features you build can then depend on
   this library. This technique is especially useful if you are building a
   `custom design system in Compose  <#custom>`__.

   Depending on your app’s size, this library could be a separate package,
   module, or library module. For more information on organizing modules in your
   app, check out the `Guide to Android app modularization  <#modularization>`__.

   .. rubric:: Replace existing features with Compose
      :name: replace-existing

   In addition to using Compose to build new features, you’ll want to gradually
   migrate existing features in your app to take advantage of Compose.

   Having your app be Compose-only can accelerate your development and also
   reduce the APK size and build times of your app. See `Compare Compose and View performance  <#ergonomics>`__ to learn more.

   **Note:**\  Rely on UI testing to ensure you are not introducing regressions
   during migration. See `Test apps on Android  <#testing>`__ and
   `Testing your Compose layout  <#testing>`__ to learn more
   about UI testing.

   .. rubric:: Simple screens
      :name: simple-screens

   The first places to look when migrating existing features to Compose are
   simple screens. Simple screens can be a welcome screen, a confirmation
   screen, or a setting screen wherein the data displayed in the UI is
   relatively static.

   Take the following XML file:

   .. code:: prettyprint

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:orientation="vertical"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

        <TextView
            android:id="@+id/title_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/title"
            android:textAppearance="?attr/textAppearanceHeadline2" />

        <TextView
            android:id="@+id/subtitle_text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/subtitle"
            android:textAppearance="?attr/textAppearanceHeadline6" />

        <TextView
            android:id="@+id/body_text"
            android:layout_width="wrap_content"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:text="@string/body"
            android:textAppearance="?attr/textAppearanceBody1" />

        <Button
            android:id="@+id/confirm_button"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/confirm"/>
      </LinearLayout>migration_strategy_xml_example.xml

   The XML file can be rewritten in Compose in a few lines:

   .. code:: prettyprint

      @Composable
      fun SimpleScreen() {
          Column(Modifier.fillMaxSize()) {
              Text(
                  text = stringResource(R.string.title),
                  style = MaterialTheme.typography.headlineMedium
              )
              Text(
                  text = stringResource(R.string.subtitle),
                  style = MaterialTheme.typography.headlineSmall
              )
              Text(
                  text = stringResource(R.string.body),
                  style = MaterialTheme.typography.bodyMedium
              )
              Spacer(modifier = Modifier.weight(1f))
              Button(onClick = { /* Handle click */ }, Modifier.fillMaxWidth()) {
                  Text(text = stringResource(R.string.confirm))
              }
          }
      }MigrationStrategySnippets.kt

   .. rubric:: Mixed view and Compose screens
      :name: mixed-view

   A screen that already contains a bit of Compose code is another good
   candidate for migrating entirely to Compose. Depending on the complexity of
   the screen, you can either migrate it entirely to Compose, or do it
   piece-by-piece. If the screen started with Compose in a subtree of the UI
   hierarchy, you would continue migrating UI elements until the entire screen
   is in Compose. This approach is also called the *bottom-up* approach.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/interop-animation.gif
      name: image-4
      :alt: Bottom-up approach of migrating a mixed Views and Compose UI to
      Compose
      :width: 100.0%

      **Figure 4**. Bottom-up approach of migrating a mixed Views and Compose UI
      to Compose

   .. rubric:: Removing Fragments and Navigation component
      :name: removing-fragments

   You can migrate to `Navigation Compose  <#navigation>`__
   once you’re able to remove all of your Fragments and replace with
   corresponding screen-level composables. Screen-level composables can contain
   a `mix of Compose and View content  <#views-in-compose>`__,
   but all navigation destinations must be composables to enable Navigation
   Compose migration. Until then, you should continue using `Fragment-based Navigation component  <#navigation-getting-started>`__ in
   your mixed View and Compose codebase. See `Migrate Jetpack Navigation to Navigation Compose  <#navigation>`__ for
   more information.

   **Note:**\  Using Navigation Compose in a Compose-only app is not a
   prerequisite. You can continue using `Fragment-based Navigation component  <#navigation-getting-started>`__, as long as you
   keep Fragments for `hosting your composable content  <#compose-in-views>`__.

   .. rubric:: Additional resources
      :name: additional-resources

   Check out the following additional resources to learn more about migrating
   your existing View-based app to Compose:

   -  Codelab

      -  `Migrating to Jetpack Compose  <#jetpack-compose-navigation>`__: Learn how to
         migrate bits of the
         `Sunflower <https://github.com/android/sunflower>`__ sample app to
         Compose in this codelab.

   -  Sample

      -  `Sunflower <https://github.com/android/sunflower>`__: Dive deep into
         the code of the Sunflower sample app, an app containing both View and
         Compose code.

   -  Blog posts

      -  `Migrating Sunflower to Jetpack Compose <https://medium.com/androiddevelopers/migrating-sunflower-to-jetpack-compose-f840fa3b9985>`__:
         Learn how Sunflower was migrated to Compose using the strategy
         described on this page.
      -  `Jetpack Compose Interop: Using Compose in a RecyclerView <https://medium.com/androiddevelopers/jetpack-compose-interop-using-compose-in-a-recyclerview-569c7ec7a583>`__:
         Learn how to performantly use Compose in a ``RecyclerView``.

   .. rubric:: Next steps
      :name: next-steps

   Now that you know the strategy you can take to migrate your existing
   View-based app, explore the `Interoperability APIs  <#interoperability-apis>`__ to learn more.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Using Compose in Views  <#compose-in-views>`__
   -  `Scroll  <#scroll>`__
   -  `Migrate ``RecyclerView`` to Lazy
      list  <#recycler-view>`__

Last updated 2024-05-03 UTC.

/Overview: Interoperability APIs
================================

.. https://developer.android.google.cn/develop/ui/compose/migrate/interoperability-apis?hl=en

.. container:: devsite-article-body clearfix

   Incrementally migrating your app to Compose means that Compose and Views will
   co-exist in your app.

   The following pages describe the specific APIs you need to use to integrate
   Compose within your existing View-based app:

   -  `Using Compose in Views  <#compose-in-views>`__:
      Learn about ``ComposeView``—the API to use to add Compose in Views.
   -  `Using Views in Compose  <#views-in-compose>`__:
      Learn about ``AndroidView`` and ``AndroidViewBinding``—APIs for using
      Views in Compose.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Display emoji  <#emoji>`__
   -  `Using Views in Compose  <#views-in-compose>`__
   -  `Migrate ``CoordinatorLayout`` to
      Compose  <#coordinator-layout>`__

Last updated 2024-05-03 UTC.

/Using Compose in Views
=======================

.. https://developer.android.google.cn/develop/ui/compose/migrate/interoperability-apis/compose-in-views?hl=en

.. container:: devsite-article-body clearfix

   You can add Compose-based UI into an existing app that uses a View-based
   design.

   To create a new, entirely Compose-based screen, have your activity call the
   ``setContent()`` method, and pass whatever composable functions you like.

   .. code:: prettyprint

      class ExampleActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)

              setContent { // In here, we can call composables!
                  MaterialTheme {
                      Greeting(name = "compose")
                  }
              }
          }
      }

      @Composable
      fun Greeting(name: String) {
          Text(text = "Hello $name!")
      }InteroperabilityAPIsSnippets.kt

   This code looks just like what you'd find in a Compose-only app.

   **Caution:** To use the ``ComponentActivity.setContent`` method, add the
   ``androidx.activity:activity-compose:$latestVersion`` dependency to your
   ``build.gradle`` file.

   See the `Activity releases page  <#activity>`__ to
   find out the latest version.

   .. rubric:: ``ViewCompositionStrategy`` for ``ComposeView``
      :name: composition-strategy

   `ViewCompositionStrategy  <#ViewCompositionStrategy>`__
   defines when the Composition should be disposed. The default,
   `ViewCompositionStrategy.Default  <#Default>`__,
   disposes the Composition when the underlying
   `ComposeView  <#ComposeView>`__
   detaches from the window, unless it is part of a pooling container such as a
   ``RecyclerView``. In a single-Activity Compose-only app, this default
   behavior is what you would want, however, if you are incrementally adding
   Compose in your codebase, this behavior may cause state loss in some
   scenarios.

   To change the ``ViewCompositionStrategy``, call the
   `setViewCompositionStrategy()  <#setViewCompositionStrategy>`__
   method and provide a different strategy.

   The table below summarizes the different scenarios you can use
   ``ViewCompositionStrategy`` in:

   .. list-table::
      :widths: 40 40
      :header-rows: 1

      - 

         - ``ViewCompositionStrategy``
         - Description and Interop Scenario
      - 

         - `DisposeOnDetachedFromWindow  <#DisposeOnDetachedFromWindow>`__
         - The Composition will be disposed when the underlying ``ComposeView``
            is detached from the window. Has since been superseded by
            ``DisposeOnDetachedFromWindowOrReleasedFromPool``.
            Interop scenario:
            \* ``ComposeView`` whether it’s the sole element in the View
            hierarchy, or in the context of a mixed View/Compose screen (not in
            Fragment).
      - 

         - `DisposeOnDetachedFromWindowOrReleasedFromPool  <#DisposeOnDetachedFromWindowOrReleasedFromPool>`__
            (**Default**)
         - Similar to ``DisposeOnDetachedFromWindow``, when the Composition is
            not in a pooling container, such as a ``RecyclerView``. If it is in
            a pooling container, it will dispose when either the pooling
            container itself detaches from the window, or when the item is being
            discarded (i.e. when the pool is full).
            Interop scenario:
            \* ``ComposeView`` whether it's the sole element in the View
            hierarchy, or in the context of a mixed View/Compose screen (not in
            Fragment).
            \* ``ComposeView`` as an item in a pooling container such as
            ``RecyclerView``.
      - 

         - `DisposeOnLifecycleDestroyed  <#DisposeOnLifecycleDestroyed>`__
         - The Composition will be disposed when the provided
            `Lifecycle  <#Lifecycle>`__ is
            destroyed.
            Interop scenario
            \* ``ComposeView`` in a Fragment's View.
      - 

         - `DisposeOnViewTreeLifecycleDestroyed  <#DisposeOnViewTreeLifecycleDestroyed>`__
         - The Composition will be disposed when the ``Lifecycle`` owned by the
            ``LifecycleOwner`` returned by ``ViewTreeLifecycleOwner.get`` of the
            next window the View is attached to is destroyed.
            Interop scenario:
            \* ``ComposeView`` in a Fragment's View.
            \* ``ComposeView`` in a View wherein the Lifecycle is not known yet.

   .. rubric:: ``ComposeView`` in Fragments
      :name: compose-in-fragments

   If you want to incorporate Compose UI content in a fragment or an existing
   View layout, use
   `ComposeView  <#ComposeView>`__
   and call its
   `setContent()  <#setContent>`__
   method. ``ComposeView`` is an Android
   `View  <#View>`__.

   You can put the ``ComposeView`` in your XML layout just like any other
   ``View``:

   .. code:: prettyprint

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          android:orientation="vertical"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

        <TextView
            android:id="@+id/text"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content" />

        <androidx.compose.ui.platform.ComposeView
            android:id="@+id/compose_view"
            android:layout_width="match_parent"
            android:layout_height="match_parent" />
      </LinearLayout>migration_strategy_existing_screens.xml

   In the Kotlin source code, inflate the layout from the `layout resource  <#layout-resource>`__ defined in XML. Then
   get the ``ComposeView`` using the XML ID, set a Composition strategy that
   works best for the host ``View``, and call ``setContent()`` to use Compose.

   .. code:: prettyprint

      class ExampleFragmentXml : Fragment() {

          override fun onCreateView(
              inflater: LayoutInflater,
              container: ViewGroup?,
              savedInstanceState: Bundle?
          ): View {
              val view = inflater.inflate(R.layout.fragment_example, container, false)
              val composeView = view.findViewById<ComposeView>(R.id.compose_view)
              composeView.apply {
                  // Dispose of the Composition when the view's LifecycleOwner
                  // is destroyed
                  setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
                  setContent {
                      // In Compose world
                      MaterialTheme {
                          Text("Hello Compose!")
                      }
                  }
              }
              return view
          }
      }InteroperabilityAPIsSnippets.kt

   Alternatively, you can also use view binding to obtain references to the
   ``ComposeView`` by referencing the generated binding class for your XML
   layout file:

   .. code:: prettyprint

      class ExampleFragment : Fragment() {

          private var _binding: FragmentExampleBinding? = null

          // This property is only valid between onCreateView and onDestroyView.
          private val binding get() = _binding!!

          override fun onCreateView(
              inflater: LayoutInflater,
              container: ViewGroup?,
              savedInstanceState: Bundle?
          ): View {
              _binding = FragmentExampleBinding.inflate(inflater, container, false)
              val view = binding.root
              binding.composeView.apply {
                  // Dispose of the Composition when the view's LifecycleOwner
                  // is destroyed
                  setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
                  setContent {
                      // In Compose world
                      MaterialTheme {
                          Text("Hello Compose!")
                      }
                  }
              }
              return view
          }

          override fun onDestroyView() {
              super.onDestroyView()
              _binding = null
          }
      }InteroperabilityAPIsSnippets.kt

   |Two slightly different text elements, one above the other|

   **Figure 1.** This shows the output of the code that adds Compose elements in
   a View UI hierarchy. The "Hello Android!" text is displayed by a ``TextView``
   widget. The "Hello Compose!" text is displayed by a Compose text element.

   You can also include a ``ComposeView`` directly in a fragment if your full
   screen is built with Compose, which lets you avoid using an XML layout file
   entirely.

   .. code:: prettyprint

      class ExampleFragmentNoXml : Fragment() {

          override fun onCreateView(
              inflater: LayoutInflater,
              container: ViewGroup?,
              savedInstanceState: Bundle?
          ): View {
              return ComposeView(requireContext()).apply {
                  // Dispose of the Composition when the view's LifecycleOwner
                  // is destroyed
                  setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
                  setContent {
                      MaterialTheme {
                          // In Compose world
                          Text("Hello Compose!")
                      }
                  }
              }
          }
      }InteroperabilityAPIsSnippets.kt

   .. rubric:: Multiple ``ComposeView`` instances in the same layout
      :name: multiple-composeviews

   If there are multiple ``ComposeView`` elements in the same layout, each one
   must have a unique ID for ``savedInstanceState`` to work.

   .. code:: prettyprint

      class ExampleFragmentMultipleComposeView : Fragment() {

          override fun onCreateView(
              inflater: LayoutInflater,
              container: ViewGroup?,
              savedInstanceState: Bundle?
          ): View = LinearLayout(requireContext()).apply {
              addView(
                  ComposeView(requireContext()).apply {
                      setViewCompositionStrategy(
                          ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed
                      )
                      id = R.id.compose_view_x
                      // ...
                  }
              )
              addView(TextView(requireContext()))
              addView(
                  ComposeView(requireContext()).apply {
                      setViewCompositionStrategy(
                          ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed
                      )
                      id = R.id.compose_view_y
                      // ...
                  }
              )
          }
      }InteroperabilityAPIsSnippets.kt

   The ``ComposeView`` IDs are defined in the ``res/values/ids.xml`` file:

   .. code:: prettyprint

      <resources>
        <item name="compose_view_x" type="id" />
        <item name="compose_view_y" type="id" />
      </resources>ids.xml

   .. rubric:: Preview composables in Layout Editor
      :name: composable-layout-editor-preview

   You can also preview composables within the Layout Editor for your XML layout
   containing a ``ComposeView``. Doing so lets you see how your composables look
   within a mixed Views and Compose layout.

   Say you want to display the following composable in the Layout Editor. Note
   that composables annotated with ``@Preview`` are good candidates to preview
   in the Layout Editor.

   .. code:: prettyprint

      @Preview
      @Composable
      fun GreetingPreview() {
          Greeting(name = "Android")
      }InteroperabilityAPIsSnippets.kt

   To display this composable, use the ``tools:composableName`` tools attribute
   and set its value to the fully qualified name of the composable to preview in
   the layout.

   .. code:: prettyprint

      <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:tools="http://schemas.android.com/tools"
          android:orientation="vertical"
          android:layout_width="match_parent"
          android:layout_height="match_parent">

        <androidx.compose.ui.platform.ComposeView
            android:id="@+id/my_compose_view"
            tools:composableName="com.example.compose.snippets.interop.InteroperabilityAPIsSnippetsKt.GreetingPreview"
            android:layout_height="match_parent"
            android:layout_width="match_parent"/>

      </LinearLayout>interop_layout_preview_composable.xml

   |Composable displayed within layout editor|

   .. rubric:: Next steps
      :name: next-steps

   Now that you know the interoperability APIs to use Compose in Views, learn
   how to use `Views in Compose  <#views-in-compose>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Other considerations  <#other-considerations>`__
   -  `Migration strategy {:#migration-strategy}  <#strategy>`__
   -  `Compare Compose and View performance  <#ergonomics>`__

Last updated 2024-05-03 UTC.

.. |Two slightly different text elements, one above the other| image:: https://developer.android.google.cn/static/develop/ui/compose/images/interop-hellos.png
.. |Composable displayed within layout editor| image:: https://developer.android.google.cn/static/develop/ui/compose/images/layout-editor-composable-preview.png
   :width: 300px

/Using Views in Compose
=======================

.. https://developer.android.google.cn/develop/ui/compose/migrate/interoperability-apis/views-in-compose?hl=en

.. container:: devsite-article-body clearfix

   You can include an Android View hierarchy in a Compose UI. This approach is
   particularly useful if you want to use UI elements that are not yet available
   in Compose, like
   `AdView <https://developers.google.cn/android/reference/com/google/android/gms/ads/AdView>`__.
   This approach also lets you reuse custom views you may have designed.

   To include a view element or hierarchy, use the
   `AndroidView  <#AndroidView>`__
   composable. ``AndroidView`` is passed a lambda that returns a
   `View  <#View>`__. ``AndroidView`` also provides an
   ``update`` callback that is called when the view is inflated. The
   ``AndroidView`` recomposes whenever a ``State`` read within the callback
   changes. ``AndroidView``, like many other built-in composables, takes a
   ``Modifier`` parameter that can be used, for example, to set its position in
   the parent composable.

   .. code:: prettyprint

      @Composable
      fun CustomView() {
          var selectedItem by remember { mutableStateOf(0) }

          // Adds view to Compose
          AndroidView(
              modifier = Modifier.fillMaxSize(), // Occupy the max size in the Compose UI tree
              factory = { context ->
                  // Creates view
                  MyView(context).apply {
                      // Sets up listeners for View -> Compose communication
                      setOnClickListener {
                          selectedItem = 1
                      }
                  }
              },
              update = { view ->
                  // View's been inflated or state read in this block has been updated
                  // Add logic here if necessary

                  // As selectedItem is read here, AndroidView will recompose
                  // whenever the state changes
                  // Example of Compose -> View communication
                  view.selectedItem = selectedItem
              }
          )
      }

      @Composable
      fun ContentExample() {
          Column(Modifier.fillMaxSize()) {
              Text("Look at this CustomView!")
              CustomView()
          }
      }
      InteroperabilityAPIsSnippets.kt

   **Note:**\  Prefer to construct a View in the ``AndroidView`` ``factory``
   lambda instead of using ``remember`` to hold a View reference outside of
   ``AndroidView``.

   .. rubric:: ``AndroidView`` with view binding
      :name: androidview_with_view_binding

   To embed an XML layout, use the
   `AndroidViewBinding  <#AndroidViewBinding>`__
   API, which is provided by the ``androidx.compose.ui:ui-viewbinding`` library.
   To do this, your project must enable `view binding  <#setup>`__.

   .. code:: prettyprint

      @Composable
      fun AndroidViewBindingExample() {
          AndroidViewBinding(ExampleLayoutBinding::inflate) {
              exampleView.setBackgroundColor(Color.GRAY)
          }
      }InteroperabilityAPIsSnippets.kt

   .. rubric:: ``AndroidView`` in Lazy lists
      :name: androidview_in_lazy_lists

   If you are using an ``AndroidView`` in a Lazy list (``LazyColumn``,
   ``LazyRow``, ``Pager``, etc.), consider using the
   `AndroidView  <#AndroidView>`__
   overload introduced in version 1.4.0-rc01. This overload allows Compose to
   reuse the underlying ``View`` instance when the containing composition is
   reused as is the case for Lazy lists.

   This overload of ``AndroidView`` adds 2 additional parameters:

   -  ``onReset`` - A callback invoked to signal that the ``View`` is about to
      be reused. This must be non-null to enable View reuse.
   -  ``onRelease`` (optional) - A callback invoked to signal that the ``View``
      has exited the composition and will not be reused again.

   .. code:: prettyprint

      @OptIn(ExperimentalComposeUiApi::class)
      @Composable
      fun AndroidViewInLazyList() {
          LazyColumn {
              items(100) { index ->
                  AndroidView(
                      modifier = Modifier.fillMaxSize(), // Occupy the max size in the Compose UI tree
                      factory = { context ->
                          MyView(context)
                      },
                      update = { view ->
                          view.selectedItem = index
                      },
                      onReset = { view ->
                          view.clear()
                      }
                  )
              }
          }
      }InteroperabilityAPIsSnippets.kt

   .. rubric:: Fragments in Compose
      :name: fragments-in-compose

   Use the ``AndroidViewBinding`` composable to add a ``Fragment`` in Compose.
   ``AndroidViewBinding`` has fragment-specific handling such as removing the
   fragment when the composable leaves the composition.

   Do so by inflating an XML containing a
   `FragmentContainerView  <#FragmentContainerView>`__
   as the holder for your ``Fragment``.

   For example, if you have the ``my_fragment_layout.xml`` defined, you could
   use code like this while replacing the ``android:name`` XML attribute with
   your ``Fragment``'s class name:

   .. code:: prettyprint

      <androidx.fragment.app.FragmentContainerView xmlns:android="http://schemas.android.com/apk/res/android"
          android:id="@+id/fragment_container_view"
          android:layout_width="match_parent"
          android:layout_height="match_parent"
          android:name="com.example.compose.snippets.interop.MyFragment" />my_fragment_layout.xml

   Inflate this fragment in Compose as follows:

   .. code:: prettyprint

      @Composable
      fun FragmentInComposeExample() {
          AndroidViewBinding(MyFragmentLayoutBinding::inflate) {
              val myFragment = fragmentContainerView.getFragment<MyFragment>()
              // ...
          }
      }
      InteroperabilityAPIsSnippets.kt

   If you need to use multiple fragments in the same layout, ensure that you
   have defined a unique ID for each ``FragmentContainerView``.

   .. rubric:: Calling the Android framework from Compose
      :name: call-view

   Compose operates within the Android framework classes. For example, it's
   hosted on Android View classes, like ``Activity`` or ``Fragment``, and might
   use Android framework classes like the ``Context``, system resources,
   ``Service``, or ``BroadcastReceiver``.

   To learn more about system resources, see `Resources in Compose  <#resources>`__.

   .. rubric:: Composition Locals
      :name: composition-locals

   `CompositionLocal  <#CompositionLocal>`__
   classes allow passing data implicitly through composable functions. They're
   usually provided with a value in a certain node of the UI tree. That value
   can be used by its composable descendants without declaring the
   ``CompositionLocal`` as a parameter in the composable function.

   ``CompositionLocal`` is used to propagate values for Android framework types
   in Compose such as ``Context``, ``Configuration`` or the ``View`` in which
   the Compose code is hosted with the corresponding
   `LocalContext  <#LocalContext>`__,
   `LocalConfiguration  <#LocalConfiguration>`__,
   or
   `LocalView  <#LocalView>`__.
   Note that ``CompositionLocal`` classes are prefixed with ``Local`` for better
   discoverability with auto-complete in the IDE.

   Access the current value of a ``CompositionLocal`` by using its ``current``
   property. For example, the code below shows a toast message by providing
   ``LocalContext.current`` into the ``Toast.makeToast`` method.

   .. code:: prettyprint

      @Composable
      fun ToastGreetingButton(greeting: String) {
          val context = LocalContext.current
          Button(onClick = {
              Toast.makeText(context, greeting, Toast.LENGTH_SHORT).show()
          }) {
              Text("Greet")
          }
      }InteroperabilityAPIsSnippets.kt

   For a more complete example, take a look at the `Case Study: BroadcastReceivers <#case-study-broadcastreceivers>`__ section at the end of
   this document.

   .. rubric:: Other interactions
      :name: other-interactions

   If there isn't a utility defined for the interaction you need, the best
   practice is to follow the general Compose guideline, *data flows down, events
   flow up* (discussed at more length in `Thinking in Compose  <#mental-model>`__). For example, this composable
   launches a different activity:

   .. code:: prettyprint

      class OtherInteractionsActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              // get data from savedInstanceState
              setContent {
                  MaterialTheme {
                      ExampleComposable(data, onButtonClick = {
                          startActivity(Intent(this, MyActivity::class.java))
                      })
                  }
              }
          }
      }

      @Composable
      fun ExampleComposable(data: DataExample, onButtonClick: () -> Unit) {
          Button(onClick = onButtonClick) {
              Text(data.title)
          }
      }InteroperabilityAPIsSnippets.kt

   .. rubric:: Case study: Broadcast receivers
      :name: case-study-broadcastreceivers

   For a more realistic example of features you might want to migrate or
   implement in Compose, and to showcase ``CompositionLocal`` and `side effects  <#side-effects>`__, let's say a
   `BroadcastReceiver  <#broadcasts>`__ needs to be
   registered from a composable function.

   The solution makes use of ``LocalContext`` to use the current context, and
   ``rememberUpdatedState`` and ``DisposableEffect`` side effects.

   .. code:: prettyprint

      @Composable
      fun SystemBroadcastReceiver(
          systemAction: String,
          onSystemEvent: (intent: Intent?) -> Unit
      ) {
          // Grab the current context in this part of the UI tree
          val context = LocalContext.current

          // Safely use the latest onSystemEvent lambda passed to the function
          val currentOnSystemEvent by rememberUpdatedState(onSystemEvent)

          // If either context or systemAction changes, unregister and register again
          DisposableEffect(context, systemAction) {
              val intentFilter = IntentFilter(systemAction)
              val broadcast = object : BroadcastReceiver() {
                  override fun onReceive(context: Context?, intent: Intent?) {
                      currentOnSystemEvent(intent)
                  }
              }

              context.registerReceiver(broadcast, intentFilter)

              // When the effect leaves the Composition, remove the callback
              onDispose {
                  context.unregisterReceiver(broadcast)
              }
          }
      }

      @Composable
      fun HomeScreen() {

          SystemBroadcastReceiver(Intent.ACTION_BATTERY_CHANGED) { batteryStatus ->
              val isCharging = /* Get from batteryStatus ... */ true
              /* Do something if the device is charging */
          }

          /* Rest of the HomeScreen */
      }InteroperabilityAPIsSnippets.kt

   .. rubric:: Next steps
      :name: next-steps

   Now that you know the interoperability APIs when using Compose in Views and
   vice versa, explore the `Other considerations  <#other-considerations>`__ page to
   learn more.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Other considerations  <#other-considerations>`__
   -  `Side-effects in Compose  <#side-effects>`__
   -  `Locally scoped data with CompositionLocal  <#compositionlocal>`__

Last updated 2024-05-03 UTC.

/Migrate RecyclerView to Compose
================================

.. https://developer.android.google.cn/develop/ui/compose/migrate/migration-scenarios/recycler-view?hl=en

.. container:: devsite-article-body clearfix

   `RecyclerView  <#recyclerview>`__ is a View
   component that makes it easy to efficiently display large sets of data.
   Instead of creating views for each item in the data set, ``RecyclerView``
   improves the performance of your app by keeping a small pool of views and
   recycling through them as you scroll through those items.

   In Compose, you can use `Lazy lists  <#lazy>`__ to
   accomplish the same thing. This page describes how you can migrate your
   ``RecyclerView`` implementation to use Lazy lists in Compose.

   .. rubric:: Migration steps
      :name: migration-steps

   To migrate your ``RecyclerView`` implementation to Compose, follow these
   steps:

   #. Comment out or remove the ``RecyclerView`` from your UI hierarchy and add
      a ``ComposeView`` to replace it if none is present in the hierarchy yet.
      This is the container for the Lazy list that you'll add:

      .. code:: prettyprint

               <FrameLayout
                   android:layout_width="match_parent"
                   android:layout_height="match_parent">

           <!--    <androidx.recyclerview.widget.RecyclerView-->
           <!--            android:id="@+id/recycler_view"-->
           <!--            android:layout_width="match_parent"-->
           <!--            android:layout_height="match_parent />"-->

                   <androidx.compose.ui.platform.ComposeView
                       android:id="@+id/compose_view"
                       android:layout_width="match_parent"
                       android:layout_height="match_parent" />

               </FrameLayout>

   #. Determine what type of Lazy list composable you need based on your
      ``RecyclerView``\ ’s layout manager (see table below). The composable you
      select will be the top-level composable of the ``ComposeView`` you added
      in the previous step.

      .. list-table::
         :header-rows: 1

         - 

            - ``LayoutManager``
            - Composable
         - 

            - ``LinearLayoutManager``
            - ``LazyColumn`` or ``LazyRow``
         - 

            - ``GridLayoutManager``
            - ``LazyVerticalGrid`` or ``LazyHorizontalGrid``
         - 

            - ``StaggeredGridLayoutManager``
            - ``LazyVerticalStaggeredGrid`` or ``LazyHorizontalStaggeredGrid``

      .. code:: prettyprint

         // recyclerView.layoutManager = LinearLayoutManager(context)
         composeView.setContent {
             LazyColumn(Modifier.fillMaxSize()) {
                 // We use a LazyColumn since the layout manager of the RecyclerView is a vertical LinearLayoutManager
             }
         }MigrationCommonScenariosSnippets.kt

   #. Create a corresponding composable for each view type in your
      ``RecyclerView.Adapter`` implementation. Each view type typically maps to
      a ``ViewHolder`` subclass, though this may not always be the case. These
      composables will be used as the UI representation for different types of
      elements in your list:

      .. code:: prettyprint

         @Composable
         fun ListItem(data: MyData, modifier: Modifier = Modifier) {
             Row(modifier.fillMaxWidth()) {
                 Text(text = data.name)
                 // … other composables required for displaying `data`
             }
         }MigrationCommonScenariosSnippets.kt

      The logic in your ``RecyclerView.Adapter``\ ’s ``onCreateViewHolder()``
      and ``onBindViewHolder()`` methods will be replaced by these composables
      and the state that you provide them with. In Compose, there is no
      separation between creating a composable for an item and binding data into
      it—these concepts are coalesced.

   #. Within the ``content`` slot of the Lazy list (the trailing lambda
      parameter), use the ``items()`` function (or an equivalent overload) to
      iterate through the data for your list. In the ``itemContent`` lambda,
      invoke the appropriate composable item for your data:

      .. code:: prettyprint

         val data = listOf<MyData>(/* ... */)
         composeView.setContent {
             LazyColumn(Modifier.fillMaxSize()) {
                 items(data) {
                     ListItem(it)
                 }
             }
         }MigrationCommonScenariosSnippets.kt

   **Tip:**\  Provide additional parameters to ``items()`` to optimize your
   list: use the ``key`` parameter to provide a unique key for the underlying
   data so that scroll position will be maintained when items change, or use the
   ``contentType`` parameter to specify a content type for the underlying data
   (this is a similar concept to ``RecyclerView``'s view types) so you can reuse
   item compositions more efficiently.

   .. rubric:: Common use cases
      :name: use-cases

   .. rubric:: Item decorations
      :name: item-decorations

   ``RecyclerView`` has the concept of an ``ItemDecoration``, which you can use
   to add a special drawing for items in the list. For example, you can add an
   ``ItemDecoration`` to add dividers between items:

   .. code:: prettyprint

      val itemDecoration = DividerItemDecoration(recyclerView.context, LinearLayoutManager.VERTICAL)
      recyclerView.addItemDecoration(itemDecoration)MigrationCommonScenariosSnippets.kt

   Compose does not have an equivalent concept of item decorations. Instead, you
   can add any UI decorations in the list directly in the composition. For
   example, to add dividers to the list, you can use the ``Divider`` composable
   after each item:

   .. code:: prettyprint

      LazyColumn(Modifier.fillMaxSize()) {
          itemsIndexed(data) { index, d ->
              ListItem(d)
              if (index != data.size - 1) {
                  Divider()
              }
          }
      }MigrationCommonScenariosSnippets.kt

   .. rubric:: Item animations
      :name: item-animations

   An ``ItemAnimator`` can be set on a ``RecyclerView`` to animate the
   appearance of items as changes are made to the adapter. By default,
   ``RecyclerView`` uses
   `DefaultItemAnimator  <#DefaultItemAnimator>`__
   which provides basic animations on remove, add, and move events.

   Lazy lists have a similar concept through the ``animateItemPlacement``
   modifier. See `Item animations  <#item-animations>`__
   to learn more.

   .. rubric:: Additional resources
      :name: additional-resources

   For more information about migrating a ``RecyclerView`` to Compose, see the
   following resources:

   -  `Lists and Grids  <#item-animations>`__:
      Documentation for how to implement lists and grids in Compose.
   -  `Jetpack Compose Interop: Using Compose in a RecyclerView <https://medium.com/androiddevelopers/jetpack-compose-interop-using-compose-in-a-recyclerview-569c7ec7a583>`__:
      Blog post for efficiently using Compose within a ``RecyclerView``.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Lists and grids  <#lists>`__
   -  `Migrate ``CoordinatorLayout`` to
      Compose  <#coordinator-layout>`__
   -  `Other considerations  <#other-considerations>`__

Last updated 2024-05-03 UTC.

/Migrate CoordinatorLayout to Compose
=====================================

.. https://developer.android.google.cn/develop/ui/compose/migrate/migration-scenarios/coordinator-layout?hl=en

.. container:: devsite-article-body clearfix

   ``CoordinatorLayout`` is a ``ViewGroup`` that enables complex, overlapping,
   and nested layouts. It's used as a container to enable specific Material
   Design interactions, such as expanding/collapsing toolbars and bottom sheets,
   for Views contained within it.

   In Compose, the closest equivalent of a ``CoordinatorLayout`` is a
   `Scaffold  <#scaffold>`__. A
   ``Scaffold`` provides content slots for combining Material Components into
   common screen patterns and interactions. This page describes how you can
   migrate your ``CoordinatorLayout`` implementation to use ``Scaffold`` in
   Compose.

   .. rubric:: Migration steps
      :name: migration-steps

   To migrate ``CoordinatorLayout`` to ``Scaffold``, follow these steps:

   #. In the snippet below, the ``CoordinatorLayout`` contains an
      ``AppBarLayout`` for containing a ``ToolBar``, a ``ViewPager``, and a
      ``FloatingActionButton``. Comment out the ``CoordinatorLayout`` and its
      children from your UI hierarchy and add a ``ComposeView`` to replace it.

      .. code:: prettyprint

         <!--  <androidx.coordinatorlayout.widget.CoordinatorLayout-->
         <!--      android:id="@+id/coordinator_layout"-->
         <!--      android:layout_width="match_parent"-->
         <!--      android:layout_height="match_parent"-->
         <!--      android:fitsSystemWindows="true">-->

         <!--    <androidx.compose.ui.platform.ComposeView-->
         <!--        android:id="@+id/compose_view"-->
         <!--        android:layout_width="match_parent"-->
         <!--        android:layout_height="match_parent"-->
         <!--        app:layout_behavior="@string/appbar_scrolling_view_behavior" />-->

         <!--    <com.google.android.material.appbar.AppBarLayout-->
         <!--        android:id="@+id/app_bar_layout"-->
         <!--        android:layout_width="match_parent"-->
         <!--        android:layout_height="wrap_content"-->
         <!--        android:fitsSystemWindows="true"-->
         <!--        android:theme="@style/Theme.Sunflower.AppBarOverlay">-->

             <!-- AppBarLayout contents here -->

         <!--    </com.google.android.material.appbar.AppBarLayout>-->

         <!--  </androidx.coordinatorlayout.widget.CoordinatorLayout>-->

         <androidx.compose.ui.platform.ComposeView
             android:id="@+id/compose_view"
             android:layout_width="match_parent"
             android:layout_height="match_parent" />

      **Note:**\  Since ``CoordinatorLayout`` is a ``ViewGroup``, it's best to
      migrate all its child views to Compose at the same time or prior to this
      step, depending on your `migration strategy  <#strategy>`__. However, if you are
      unable to do so, you can add an ``AndroidView`` to use Views within
      Compose. See `Using Views in Compose  <#views-in-compose>`__
      to learn more.

   #. In your Fragment or Activity, obtain a reference to the ``ComposeView``
      you just added and call the ``setContent`` method on it. In the body of
      the method, set a ``Scaffold`` as its content:

      .. code:: prettyprint

         composeView.setContent {
             Scaffold(Modifier.fillMaxSize()) { contentPadding ->
                 // Scaffold contents
                 // ...
             }
         }MigrationCommonScenariosSnippets.kt

   #. In the content of your ``Scaffold``, add your screen's primary content
      within it. Because the primary content in the XML above is a
      ``ViewPager2``, we'll use a ``HorizontalPager``, which is the Compose
      equivalent of it. The ``content`` lambda of the ``Scaffold`` also receives
      an instance of ``PaddingValues`` that should be applied to the content
      root. You can use ``Modifier.padding`` to apply the same ``PaddingValues``
      to the ``HorizontalPager``.

      .. code:: prettyprint

         composeView.setContent {
             Scaffold(Modifier.fillMaxSize()) { contentPadding ->
                 val pagerState = rememberPagerState {
                     10
                 }
                 HorizontalPager(
                     state = pagerState,
                     modifier = Modifier.padding(contentPadding)
                 ) { /* Page contents */ }
             }
         }MigrationCommonScenariosSnippets.kt

   #. Use other content slots that ``Scaffold`` provides to add more screen
      elements and migrate remaining child Views. You can use the ``topBar``
      slot to add a
      `TopAppBar  <#TopAppBar>`__,
      and the ``floatingActionButton`` slot to provide a
      `FloatingActionButton  <#FloatingActionButton>`__.

      .. code:: prettyprint

         composeView.setContent {
             Scaffold(
                 Modifier.fillMaxSize(),
                 topBar = {
                     TopAppBar(
                         title = {
                             Text("My App")
                         }
                     )
                 },
                 floatingActionButton = {
                     FloatingActionButton(
                         onClick = { /* Handle click */ }
                     ) {
                         Icon(
                             Icons.Filled.Add,
                             contentDescription = "Add Button"
                         )
                     }
                 }
             ) { contentPadding ->
                 val pagerState = rememberPagerState {
                     10
                 }
                 HorizontalPager(
                     state = pagerState,
                     modifier = Modifier.padding(contentPadding)
                 ) { /* Page contents */ }
             }
         }MigrationCommonScenariosSnippets.kt

   .. rubric:: Common use cases
      :name: use-cases

   .. rubric:: Collapse and expand toolbars
      :name: collapse-expand-toolbars

   In the View system, to collapse and expand the toolbar with
   ``CoordinatorLayout``, you use an ``AppBarLayout`` as a container for the
   toolbar. You can then specify a
   `Behavior  <#CoordinatorLayout.Behavior>`__
   through ``layout_behavior`` in XML on the associated scrollable View (like
   ``RecyclerView`` or ``NestedScrollView``) to declare how the toolbar
   collapses/expands as you scroll.

   In Compose, you can achieve a similar effect through a
   `TopAppBarScrollBehavior  <#TopAppBarScrollBehavior>`__.
   For example, to implement a collapsing/expanding toolbar so that the toolbar
   appears when you scroll up, follow these steps:

   #. Call ``TopAppBarDefaults.enterAlwaysScrollBehavior()`` to create a
      ``TopAppBarScrollBehavior``.

   #. Provide the created ``TopAppBarScrollBehavior`` to the ``TopAppBar``.

   #. Connect the
      `NestedScrollConnection  <#nestedScrollConnection>`__
      via ``Modifier.nestedScroll`` on the ``Scaffold`` so that the Scaffold can
      receive nested scroll events as the scrollable content scrolls up/down.
      This way, the contained app bar can appropriately collapse/expand as the
      content scrolls.

      .. code:: prettyprint

         // 1. Create the TopAppBarScrollBehavior
         val scrollBehavior = TopAppBarDefaults.enterAlwaysScrollBehavior()

         Scaffold(
             topBar = {
                 TopAppBar(
                     title = {
                         Text("My App")
                     },
                     // 2. Provide scrollBehavior to TopAppBar
                     scrollBehavior = scrollBehavior
                 )
             },
             // 3. Connect the scrollBehavior.nestedScrollConnection to the Scaffold
             modifier = Modifier
                 .fillMaxSize()
                 .nestedScroll(scrollBehavior.nestedScrollConnection)
         ) { contentPadding ->
             /* Contents */
             // ...
         }MigrationCommonScenariosSnippets.kt

   **Note:**\  If you are using Material 2 components, you must manually
   implement the collapsing/expanding toolbar yourself. Alternatively, you can
   use a ``CoordinatorLayout`` as the outer layout to your ``ComposeView``. This
   method is documented in the `Migrating Sunflower to Jetpack Compose <https://medium.com/androiddevelopers/migrating-sunflower-to-jetpack-compose-f840fa3b9985>`__
   blog post.

   .. rubric:: Customize the collapsing/expanding scroll effect
      :name: customize_the_collapsingexpanding_scroll_effect

   You can provide several parameters for
   `enterAlwaysScrollBehavior  <#enterAlwaysScrollBehavior>`__
   to customize the collapsing/expanding animation effect. ``TopAppBarDefaults``
   also provides other ``TopAppBarScrollBehavior`` such as
   `exitUntilCollapsedScrollBehavior  <#exitUntilCollapsedScrollBehavior>`__,
   which only expands the app bar when the content is scrolled all the way down.

   To create a completely custom effect (for example, a parallax effect), you
   can also create your own ``NestedScrollConnection`` and offset the toolbar
   manually as the content scrolls. See the `Nested scroll sample <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/samples/src/main/java/androidx/compose/ui/samples/NestedScrollSamples.kt;l=53?q=NestedScrollConnectionSample>`__
   on AOSP for a code example.

   .. rubric:: Drawers
      :name: drawers

   With Views, you implement a `navigation drawer <https://m3.material.io/components/navigation-drawer/overview>`__ by
   using a
   `DrawerLayout  <#DrawerLayout>`__
   as the root view. In turn, your ``CoordinatorLayout`` is a child view of the
   ``DrawerLayout``. The ``DrawerLayout`` also contains another child view, such
   as a
   `NavigationView  <#NavigationView>`__,
   to display the navigation options in the drawer.

   In Compose, you can implement a navigation drawer using the
   `ModalNavigationDrawer  <#ModalNavigationDrawer>`__
   composable. ``ModalNavigationDrawer`` offers a ``drawerContent`` slot for the
   drawer and a ``content`` slot for the screen's content.

   .. code:: prettyprint

      ModalNavigationDrawer(
          drawerContent = {
              ModalDrawerSheet {
                  Text("Drawer title", modifier = Modifier.padding(16.dp))
                  Divider()
                  NavigationDrawerItem(
                      label = { Text(text = "Drawer Item") },
                      selected = false,
                      onClick = { /*TODO*/ }
                  )
                  // ...other drawer items
              }
          }
      ) {
          Scaffold(Modifier.fillMaxSize()) { contentPadding ->
              // Scaffold content
              // ...
          }
      }MigrationCommonScenariosSnippets.kt

   See
   `Drawers <https://developers.android.com/develop/ui/compose/layouts/material#drawers>`__
   to learn more.

   .. rubric:: Snackbars
      :name: snackbars

   ``Scaffold`` provides a ``snackbarHost`` slot, which can accept a
   ``SnackbarHost`` composable to display a ``Snackbar``.

   .. code:: prettyprint

      val scope = rememberCoroutineScope()
      val snackbarHostState = remember { SnackbarHostState() }
      Scaffold(
          snackbarHost = {
              SnackbarHost(hostState = snackbarHostState)
          },
          floatingActionButton = {
              ExtendedFloatingActionButton(
                  text = { Text("Show snackbar") },
                  icon = { Icon(Icons.Filled.Image, contentDescription = "") },
                  onClick = {
                      scope.launch {
                          snackbarHostState.showSnackbar("Snackbar")
                      }
                  }
              )
          }
      ) { contentPadding ->
          // Screen content
          // ...
      }MigrationCommonScenariosSnippets.kt

   See
   `Snackbars <https://developers.android.com/develop/ui/compose/layouts/material#snackbar>`__
   to learn more.

   .. rubric:: Learn more
      :name: learn-more

   For more information about migrating a ``CoordinatorLayout`` to Compose, see
   the following resources:

   -  `Material Components and layouts  <#material>`__: Documentation on
      Material Design components that are supported in Compose, like
      ``Scaffold``.
   -  `Migrating Sunflower to Jetpack Compose <https://medium.com/androiddevelopers/migrating-sunflower-to-jetpack-compose-f840fa3b9985>`__:
      A blog post that documents the migration journey from Views to Compose of
      the Sunflower sample app, which contains a ``CoordinatorLayout``.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Material Components and layouts  <#material>`__
   -  `Window insets in Compose  <#insets>`__
   -  `Scroll  <#scroll>`__

Last updated 2024-05-03 UTC.

/Migrate Jetpack Navigation to Navigation Compose
=================================================

.. https://developer.android.google.cn/develop/ui/compose/migrate/migration-scenarios/navigation?hl=en

.. container:: devsite-article-body clearfix

   The `Navigation Compose API  <#navigation>`__ allows you to
   navigate between composables in a Compose app, while taking advantage of the
   `Jetpack Navigation's  <#navigation>`__ component, infrastructure, and
   features.

   This page describes how to migrate from a Fragment-based Jetpack Navigation
   to Navigation Compose, as part of the larger, View-based UI migration to
   Jetpack Compose.

   **Note:**\  If you are new to Navigation Compose, see `Navigating with Compose  <#navigation>`__ first. This doc describes the
   basics of Navigation Compose, such as how to pass navigation events or
   complex data and set up composables with arguments.

   .. rubric:: Migration prerequisites
      :name: migration-prerequisites

   You can migrate to Navigation Compose once you're able to *replace all of
   your Fragments with corresponding screen composables*. Screen composables can
   contain a `mix of Compose and View content  <#views-in-compose>`__,
   but *all navigation destinations must be composables* to enable Navigation
   Compose migration. Until then, you should continue using `Fragment-based Navigation component  <#navigation-getting-started>`__ in
   your interop View and Compose codebase. See the `navigation interop documentation  <#interoperability>`__ for more
   information.

   Using Navigation Compose in a Compose-only app is not a prerequisite. You can
   *continue using* `Fragment-based Navigation component  <#navigation-getting-started>`__, as long as you
   keep Fragments for `hosting your composable content  <#compose-in-views>`__.

   **Note:**\  Currently, it's not possible to use any single form of the
   Navigation component to navigate between a mix of Fragment and composable
   destinations. All destinations must be uniformly either Fragments (using
   Jetpack Navigation) or composables (using Navigation Compose).

   .. rubric:: Migration steps
      :name: migration-steps

   Whether you are following our `recommended migration strategy  <#strategy>`__ or taking another
   approach, you'll reach a point where all navigation destinations are screen
   composables, with Fragments acting only as composable containers. At this
   stage, you can migrate to Navigation Compose.

   If your app is already following a `UDF design pattern  <#udf>`__ and our `guide to architecture  <#architecture>`__, migrating to Jetpack Compose and
   Navigation Compose shouldn't require major refactors of other layers of your
   app, apart from the UI layer.

   To migrate to Navigation Compose, follow these steps:

   #. Add the `Navigation Compose dependency  <#setup>`__ to your app.

   #. Create an ``App-level`` composable and add it to your ``Activity`` as your
      Compose entry point, replacing the setup of the View layout:

      .. code:: prettyprint

         class SampleActivity : ComponentActivity() {

             override fun onCreate(savedInstanceState: Bundle?) {
                 super.onCreate(savedInstanceState)
                 // setContentView<ActivitySampleBinding>(this, R.layout.activity_sample)
                 setContent {
                     SampleApp(/* ... */)
                 }
             }
         }MigrationCommonScenariosSnippets.kt

   #. Set up the
      `NavController  <#getting-started>`__ in
      a place where all composables that need to reference it have access to it
      (this is usually inside your ``App`` composable). This approach follows
      the `principles of state hoisting  <#state-hoisting>`__ and allows you to
      use the ``NavController`` as the source of truth for navigating between
      composable screens and maintaining the back stack:

      .. code:: prettyprint

         @Composable
         fun SampleApp() {
             val navController = rememberNavController()
             // ...
         }MigrationCommonScenariosSnippets.kt

   #. Create your app's
      `NavHost  <#create-navhost>`__ inside the
      App composable and pass the ``navController``:

      .. code:: prettyprint

         @Composable
         fun SampleApp() {
             val navController = rememberNavController()

             SampleNavHost(navController = navController)
         }

         @Composable
         fun SampleNavHost(
             navController: NavHostController
         ) {
             NavHost(navController = navController, startDestination = "first") {
                 // ...
             }
         }MigrationCommonScenariosSnippets.kt

   #. Add the ``composable`` destinations to build your navigation graph. If
      each screen has been previously migrated to Compose, this step only
      consists of extracting these screen composables from your Fragments into
      the ``composable`` destinations:

      .. code:: prettyprint

         class FirstFragment : Fragment() {

             override fun onCreateView(
                 inflater: LayoutInflater,
                 container: ViewGroup?,
                 savedInstanceState: Bundle?
             ): View {
                 return ComposeView(requireContext()).apply {
                     setContent {
                         // FirstScreen(...) EXTRACT FROM HERE
                     }
                 }
             }
         }

         @Composable
         fun SampleNavHost(
             navController: NavHostController
         ) {
             NavHost(navController = navController, startDestination = "first") {
                 composable("first") {
                     FirstScreen(/* ... */) // EXTRACT TO HERE
                 }
                 composable("second") {
                     SecondScreen(/* ... */)
                 }
                 // ...
             }
         }MigrationCommonScenariosSnippets.kt

   #. If you followed the guidance on `architecting your Compose UI  <#architecture>`__, specifically how
      ``ViewModel``\ s and navigation events should be passed to composables,
      the next step is to change how you provide the ``ViewModel`` to each
      screen composable. You can often use Hilt injection and its integration
      point with Compose and Navigation via
      `hiltViewModel  <#hilt-navigation>`__:

      .. code:: prettyprint

         @Composable
         fun FirstScreen(
             // viewModel: FirstViewModel = viewModel(),
             viewModel: FirstViewModel = hiltViewModel(),
             onButtonClick: () -> Unit = {},
         ) {
             // ...
         }MigrationCommonScenariosSnippets.kt

   #. Replace all ``findNavController()`` navigation calls with the
      ``navController`` ones and pass these as navigation events to each
      composable screen, rather than passing the entire ``navController``. This
      approach follows the `best practices  <#nav-calls-best-practices>`__ of
      exposing events from composable functions to callers and keeps the
      ``navController`` as the single source of truth.

      #. If you've previously used the `Safe Args plugin  <#ensure_type-safety_by_using_safe_args>`__
         for generating navigation directions and actions, replace it with a
         `route  <#nav-to-composable>`__ — a String
         path to your composable that is unique for each destination.

      #. For replacing Safe Args when passing data, see `Navigate with arguments  <#nav-with-args>`__.

      #. For type safety in Navigation Compose, read the `Safe Args section <#bookmark=id.epbifoyuo1hs>`__ below.

         .. code:: prettyprint

            @Composable
            fun SampleNavHost(
                navController: NavHostController
            ) {
                NavHost(navController = navController, startDestination = "first") {
                    composable("first") {
                        FirstScreen(
                            onButtonClick = {
                                // findNavController().navigate(firstScreenToSecondScreenAction)
                                navController.navigate("second_screen_route")
                            }
                        )
                    }
                    composable("second") {
                        SecondScreen(
                            onIconClick = {
                                // findNavController().navigate(secondScreenToThirdScreenAction)
                                navController.navigate("third_screen_route")
                            }
                        )
                    }
                    // ...
                }
            }MigrationCommonScenariosSnippets.kt

   #. Remove all Fragments, relevant XML layouts, unnecessary navigation and
      other resources, and stale Fragment and Jetpack Navigation dependencies.

   You can find the same steps with more Navigation Compose-related details in
   the `Setup documentation  <#setup>`__.

   .. rubric:: Common use cases
      :name: use-cases

   No matter which Navigation component you're using, the `same principles of navigation apply  <#navigation-principles>`__.

   Common use cases when migrating include the following:

   -  `Navigate to a composable  <#nav-to-composable>`__
   -  `Navigate with arguments  <#nav-with-args>`__
   -  `Deep links  <#deeplinks>`__
   -  `Nested navigation  <#nested-nav>`__
   -  `Integration with the bottom nav bar  <#bottom-nav>`__
   -  `Integration with a custom nav component  <#jetpack-compose-navigation>`__

   For more detailed information about these use cases, see `Navigating with Compose  <#interoperability>`__.

   .. rubric:: Safe Args
      :name: safe-args

   Unlike Jetpack Navigation, Navigation Compose does not support using the
   `Safe Args plugin  <#ensure_type-safety_by_using_safe_args>`__
   for code generation. Instead, you can achieve `type safety with Navigation Compose  <#type-safety>`__ through structuring
   your code to make it type-safe at runtime.

   .. rubric:: Retrieve complex data when navigating
      :name: retrieve-complex-data

   Navigation Compose is String route-based and, unlike Jetpack Navigation,
   `does not support passing custom Parcelables and Serializables as arguments  <#supported_argument_types>`__.

   We strongly recommend not passing around complex data objects when
   navigating. Instead, pass the minimum necessary information, such as a unique
   identifier or other form of ID, as arguments when performing navigation
   actions. You should store complex objects as data in a single source of
   truth, such as the `data layer  <#data-layer>`__. For more
   information, see `Retrieving complex data when navigating  <#retrieving-complex-data>`__.

   If your Fragments are passing complex objects as arguments, consider
   refactoring your code first, in a way that allows storing and fetching these
   objects from the data layer. See the `Now in Android repository <https://github.com/android/nowinandroid>`__ for examples.

   .. rubric:: Limitations
      :name: limitations

   This section describes current limitations for Navigation Compose.

   .. rubric:: Incremental migration to Navigation Compose
      :name: incremental-migration

   Currently, you cannot use Navigation Compose while still using Fragments as
   destinations in your code. To start using Navigation Compose, all of your
   destinations need to be composables. You can track this `feature request on the Issue Tracker <https://issuetracker.google.com/issues/265480755>`__.

   .. rubric:: Transition animations
      :name: transition-animations

   Starting with `Navigation 2.7.0-alpha01  <#navigation-2.7.0-alpha01>`__,
   support for setting custom transitions, previously from
   `AnimatedNavHost <https://google.github.io/accompanist/navigation-animation/>`__,
   is now directly supported in
   `NavHost  <#NavHost>`__. Read through the
   `release notes  <#navigation-2.7.0-alpha01>`__ for
   more information.

   .. rubric:: Learn more
      :name: learn-more

   For more information about migrating to Navigation Compose, see the following
   resources:

   -  `Navigation Compose codelab  <#jetpack-compose-navigation>`__:
      Learn the basics of Navigation Compose with a hands-on codelab.
   -  `Now in Android repository <https://github.com/android/nowinandroid>`__: A
      fully functional Android app built entirely with Kotlin and Jetpack
      Compose, which follows Android design and development best practices and
      includes Navigation Compose.
   -  `Migrating Sunflower to Jetpack Compose <https://medium.com/androiddevelopers/migrating-sunflower-to-jetpack-compose-f840fa3b9985>`__:
      A blog post that documents the migration journey of the Sunflower sample
      app from Views to Compose, which also includes migration to Navigation
      Compose.
   -  `Jetnews for every screen <https://medium.com/androiddevelopers/jetnews-for-every-screen-4d8e7927752>`__:
      A blog post that documents the refactor and migration of the Jetnews
      sample to support all screens with Jetpack Compose and Navigation Compose.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Navigating with Compose  <#navigation>`__
   -  `Compose and other libraries  <#libraries>`__
   -  `Other considerations  <#other-considerations>`__

Last updated 2024-05-03 UTC.

/Other considerations
=====================

.. https://developer.android.google.cn/develop/ui/compose/migrate/other-considerations?hl=en

.. container:: devsite-article-body clearfix

   While migrating from Views to Compose is purely UI-related, there are a lot
   of things to take into account to perform a safe and incremental migration.
   This page contains some considerations while migrating your View-based app to
   Compose.

   .. rubric:: Migrating your app's theme
      :name: theming

   Material Design is the recommended design system for theming Android apps.

   For View-based apps, there are three versions of Material available:

   -  Material Design 1 using the
      `AppCompat  <#appcompat>`__ library (i.e.
      ``Theme.AppCompat.*``)
   -  Material Design 2 using the
      `MDC-Android <https://github.com/material-components/material-components-android>`__
      library (i.e. ``Theme.MaterialComponents.*``)
   -  Material Design 3 using the
      `MDC-Android <https://github.com/material-components/material-components-android>`__
      library (i.e. ``Theme.Material3.*``)

   For Compose apps, there are two versions of Material available:

   -  Material Design 2 using the `Compose Material  <#compose-material>`__ library (i.e.
      ``androidx.compose.material.MaterialTheme``)
   -  Material Design 3 using the `Compose Material 3  <#compose-material3>`__ library (i.e.
      ``androidx.compose.material3.MaterialTheme``)

   We recommend using the latest version (Material 3) if your app's design
   system is in a position to do so. There are migration guides available for
   both Views and Compose:

   -  `Material 1 to Material 2 in Views <https://material.io/blog/migrate-android-material-components>`__
   -  `Material 2 to Material 3 in Views <https://material.io/blog/migrating-material-3>`__
   -  `Material 2 to Material 3 in Compose  <#material2-material3>`__

   When creating new screens in Compose, regardless of which version of Material
   Design you're using, ensure that you apply a ``MaterialTheme`` before any
   composables that emit UI from the Compose Material libraries. The Material
   components (``Button``, ``Text``, etc.) depend on a ``MaterialTheme`` being
   in place and their behaviour is undefined without it.

   All `Jetpack Compose samples <https://github.com/android/compose-samples>`__
   use a custom Compose theme built on top of ``MaterialTheme``.

   See `Design systems in Compose  <#designsystems>`__ and
   `Migrating XML themes to Compose  <#views-to-compose>`__ to learn
   more.

   .. rubric:: Navigation
      :name: navigation

   If you use the `Navigation component  <#get-started>`__ in
   your app, see the `Navigating with Compose - Interoperability  <#interoperability>`__ and
   `Migrate Jetpack Navigation to Navigation Compose  <#navigation>`__ for
   more information.

   .. rubric:: Test your mixed Compose/Views UI
      :name: test-hybrid-ui

   After migrating parts of your app to Compose, testing is critical to make
   sure you haven't broken anything.

   When an activity or fragment uses Compose, you need to use
   `createAndroidComposeRule  <#createAndroidComposeRule>`__
   instead of using ``ActivityScenarioRule``. ``createAndroidComposeRule``
   integrates ``ActivityScenarioRule`` with a ``ComposeTestRule`` that lets you
   test Compose and View code at the same time.

   .. code:: prettyprint

      class MyActivityTest {
          @Rule
          @JvmField
          val composeTestRule = createAndroidComposeRule<MyActivity>()

          @Test
          fun testGreeting() {
              val greeting = InstrumentationRegistry.getInstrumentation()
                  .targetContext.resources.getString(R.string.greeting)

              composeTestRule.onNodeWithText(greeting).assertIsDisplayed()
          }
      }AddingComposeToYourAppSnippets.kt

   See `Testing your Compose layout  <#testing>`__ to learn
   more about testing. For interoperability with UI testing frameworks, see
   `interoperability with Espresso  <#espresso-interop>`__ and
   `interoperability with UiAutomator  <#uiautomator-interop>`__.

   .. rubric:: Integrating Compose with your existing app architecture
      :name: existing-architecture

   `Unidirectional Data Flow  <#udf>`__ (UDF)
   architecture patterns work seamlessly with Compose. If the app uses other
   types of architecture patterns instead, like Model View Presenter (MVP), we
   recommend you migrate that part of the UI to UDF before or whilst adopting
   Compose.

   .. rubric:: Using a ``ViewModel`` in Compose
      :name: viewmodel

   If you use the `Architecture Components ``ViewModel``  <#viewmodel>`__ library, you can
   access a `ViewModel  <#ViewModel>`__ from any
   composable by calling the
   `viewModel()  <#viewmodel>`__
   function, as explained in `Compose and other libraries  <#libraries>`__.

   **Note:**\  Due to their `lifecycle and scoping  <#lifecycle>`__, *you should
   access and call ``ViewModel`` instances at screen-level composables*—that is,
   close to a root composable called from an activity, fragment, or destination
   of a Navigation graph. *You should never pass down ``ViewModel`` instances to
   other composables*. Instead, pass only the data they need and functions that
   perform the required logic as parameters.
   When adopting Compose, be careful about using the same ``ViewModel`` type in
   different composables as ``ViewModel`` elements follow View-lifecycle scopes.
   The scope will be either the host activity, fragment, or the navigation graph
   if the Navigation library is used.

   **Note:**\  The same instance of a ``ViewModel`` type is used in all
   composables unless the composable is a destination of the navigation graph or
   different activity or fragment instances.
   For example, if the composables are hosted in an activity, ``viewModel()``
   always returns the same instance that is only cleared when the activity
   finishes. In the following example, the same user ("user1") is greeted twice
   because the same ``GreetingViewModel`` instance is reused in all composables
   under the host activity. The first ``ViewModel`` instance created is reused
   in other composables.

   .. code:: prettyprint

      class GreetingActivity : ComponentActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)

              setContent {
                  MaterialTheme {
                      Column {
                          GreetingScreen("user1")
                          GreetingScreen("user2")
                      }
                  }
              }
          }
      }

      @Composable
      fun GreetingScreen(
          userId: String,
          viewModel: GreetingViewModel = viewModel(  
              factory = GreetingViewModelFactory(userId)  
          )
      ) {
          val messageUser by viewModel.message.observeAsState("")
          Text(messageUser)
      }

      class GreetingViewModel(private val userId: String) : ViewModel() {
          private val _message = MutableLiveData("Hi $userId")
          val message: LiveData<String> = _message
      }

      class GreetingViewModelFactory(private val userId: String) : ViewModelProvider.Factory {
          @Suppress("UNCHECKED_CAST")
          override fun <T : ViewModel> create(modelClass: Class<T>): T {
              return GreetingViewModel(userId) as T
          }
      }ComposeExistingArchSnippets.kt

   As navigation graphs also scope ``ViewModel`` elements, composables that are
   a destination in a navigation graph have a different instance of the
   ``ViewModel``. In this case, the ``ViewModel`` is scoped to the lifecycle of
   the destination, and it is cleared when the destination is removed from the
   backstack. In the following example, when the user navigates to the *Profile*
   screen, a new instance of ``GreetingViewModel`` is created.

   .. code:: prettyprint

      @Composable
      fun MyApp() {
          NavHost(rememberNavController(), startDestination = "profile/{userId}") {
              /* ... */
              composable("profile/{userId}") { backStackEntry ->
                  GreetingScreen(backStackEntry.arguments?.getString("userId") ?: "")
              }
          }
      }ComposeExistingArchSnippets.kt

   .. rubric:: State source of truth
      :name: state-source-of-truth

   When you adopt Compose in one part of the UI, it's possible that Compose and
   the View system code need to share data. When possible, we recommend you
   encapsulate that shared state in another class that follows UDF best
   practices used by both platforms; for example, in a ``ViewModel`` that
   exposes a stream of the shared data to emit data updates.

   However, that's not always possible if the data to be shared is mutable or is
   tightly bound to a UI element. In that case, one system must be the source of
   truth, and that system needs to share any data updates to the other system.
   As a general rule of thumb, the source of truth should be owned by whichever
   element is closer to the root of the UI hierarchy.

   .. rubric:: Compose as the source of truth
      :name: compose-source-of-truth

   Use the
   `SideEffect  <#SideEffect>`__
   composable to publish Compose state to non-Compose code. In this case, the
   source of truth is kept in a composable, which sends state updates.

   As an example, your analytics library might allow you to segment your user
   population by attaching custom metadata (*user properties* in this example)
   to all subsequent analytics events. To communicate the user type of the
   current user to your analytics library, use ``SideEffect`` to update its
   value.

   .. code:: prettyprint

      @Composable
      fun rememberFirebaseAnalytics(user: User): FirebaseAnalytics {
          val analytics: FirebaseAnalytics = remember {
              FirebaseAnalytics()
          }

          // On every successful composition, update FirebaseAnalytics with
          // the userType from the current User, ensuring that future analytics
          // events have this metadata attached
          SideEffect {
              analytics.setUserProperty("userType", user.userType)
          }
          return analytics
      }MigrationOtherConsiderationsSnippets.kt

   For more information, see `Side-effects in Compose  <#side-effects>`__.

   .. rubric:: View system as the source of truth
      :name: view-source-of-truth

   If the View system owns the state and shares it with Compose, we recommend
   that you wrap the state in ``mutableStateOf`` objects to make it thread-safe
   for Compose. If you use this approach, composable functions are simplified
   because they no longer have the source of truth, but the View system needs to
   update the mutable state and the Views that use that state.

   In the following example, a ``CustomViewGroup`` contains a ``TextView`` and a
   ``ComposeView`` with a ``TextField`` composable inside. The ``TextView``
   needs to show the content of what the user types in the ``TextField``.

   .. code:: prettyprint

      class CustomViewGroup @JvmOverloads constructor(
          context: Context,
          attrs: AttributeSet? = null,
          defStyle: Int = 0
      ) : LinearLayout(context, attrs, defStyle) {

          // Source of truth in the View system as mutableStateOf
          // to make it thread-safe for Compose
          private var text by mutableStateOf("")

          private val textView: TextView

          init {
              orientation = VERTICAL

              textView = TextView(context)
              val composeView = ComposeView(context).apply {
                  setContent {
                      MaterialTheme {
                          TextField(value = text, onValueChange = { updateState(it) })
                      }
                  }
              }

              addView(textView)
              addView(composeView)
          }

          // Update both the source of truth and the TextView
          private fun updateState(newValue: String) {
              text = newValue
              textView.text = newValue
          }
      }ComposeExistingArchSnippets.kt

   .. rubric:: Migrating shared UI
      :name: shared-ui

   If you are migrating gradually to Compose, you might need to use shared UI
   elements in both Compose and the View system. For example, if your app has a
   custom ``CallToActionButton`` component, you might need to use it in both
   Compose and View-based screens.

   In Compose, shared UI elements become composables that can be reused across
   the app, regardless of the element being styled using XML or being a custom
   view. For example, you'd create a ``CallToActionButton`` composable for your
   custom call to action ``Button`` component.

   To use the composable in View-based screens, create a custom view wrapper
   that extends from ``AbstractComposeView``. In its overridden ``Content``
   composable, place the composable you created wrapped in your Compose theme,
   as shown in the example below:

   .. code:: prettyprint

      @Composable
      fun CallToActionButton(
          text: String,
          onClick: () -> Unit,
          modifier: Modifier = Modifier,
      ) {
          Button(
              colors = ButtonDefaults.buttonColors(
                  containerColor = MaterialTheme.colorScheme.secondary
              ),
              onClick = onClick,
              modifier = modifier,
          ) {
              Text(text)
          }
      }

      class CallToActionViewButton @JvmOverloads constructor(
          context: Context,
          attrs: AttributeSet? = null,
          defStyle: Int = 0
      ) : AbstractComposeView(context, attrs, defStyle) {

          var text by mutableStateOf("")
          var onClick by mutableStateOf({})

          @Composable
          override fun Content() {
              YourAppTheme {
                  CallToActionButton(text, onClick)
              }
          }
      }ComposeExistingUISnippets.kt

   Notice that the composable parameters become mutable variables inside the
   custom view. This makes the custom ``CallToActionViewButton`` view inflatable
   and usable, like a traditional view. See an example of this with `View Binding  <#view-binding>`__ below:

   .. code:: prettyprint

      class ViewBindingActivity : ComponentActivity() {

          private lateinit var binding: ActivityExampleBinding

          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              binding = ActivityExampleBinding.inflate(layoutInflater)
              setContentView(binding.root)

              binding.callToAction.apply {
                  text = getString(R.string.greeting)
                  onClick = { /* Do something */ }
              }
          }
      }ComposeExistingUISnippets.kt

   If the custom component contains mutable state, see `State source of truth  <#state-source-of-truth>`__.

   .. rubric:: Prioritize splitting state from presentation
      :name: prioritize-splitting-state

   Traditionally, a ``View`` is stateful. A ``View`` manages fields that
   describe *what* to display, in addition to *how* to display it. When you
   convert a ``View`` to Compose, look to separate the data being rendered to
   achieve a unidirectional data flow, as explained further in `state hoisting  <#state-hoisting>`__.

   For example, a ``View`` has a ``visibility`` property that describes if it is
   visible, invisible, or gone. This is an inherent property of the ``View``.
   While other pieces of code may change the visibility of a ``View``, only the
   ``View`` itself really knows what its current visibility is. The logic for
   ensuring that a ``View`` is visible can be error prone, and is often tied to
   the ``View`` itself.

   By contrast, Compose makes it easy to display entirely different composables
   using conditional logic in Kotlin:

   .. code:: prettyprint

      @Composable
      fun MyComposable(showCautionIcon: Boolean) {
          if (showCautionIcon) {
              CautionIcon(/* ... */)
          }
      }MigrationOtherConsiderationsSnippets.kt

   By design, ``CautionIcon`` doesn’t need to know or care why it is being
   displayed, and there is no concept of ``visibility``: it either is in the
   Composition, or it isn’t.

   By cleanly separating state management and presentation logic, you can more
   freely change how you display content as a conversion of state to UI. Being
   able to hoist state when needed also makes composables more reusable, since
   state ownership is more flexible.

   .. rubric:: Promote encapsulated and reusable components
      :name: promote-encapsulation

   ``View`` elements often have some idea of where they live: inside an
   ``Activity``, a ``Dialog``, a ``Fragment`` or somewhere inside another
   ``View`` hierarchy. Because they are often inflated from static layout files,
   the overall structure of a ``View`` tends to be very rigid. This results in
   tighter coupling, and makes it harder for a ``View`` to be changed or reused.

   For example, a custom ``View`` might assume that it has a child view of a
   certain type with a certain id, and change its properties directly in
   response to some action. This tightly couples those ``View`` elements
   together: the custom ``View`` may crash or be broken if it can’t find the
   child, and the child likely can’t be reused without the custom ``View``
   parent.

   This is less of a problem in Compose with reusable composables. Parents can
   easily specify state and callbacks, so you can write reusable composables
   without having to know the exact place where they'll be used.

   .. code:: prettyprint

      @Composable
      fun AScreen() {
          var isEnabled by rememberSaveable { mutableStateOf(false) }

          Column {
              ImageWithEnabledOverlay(isEnabled)
              ControlPanelWithToggle(
                  isEnabled = isEnabled,
                  onEnabledChanged = { isEnabled = it }
              )
          }
      }MigrationOtherConsiderationsSnippets.kt

   In the example above, all three parts are more encapsulated and less coupled:

   -  ``ImageWithEnabledOverlay`` only needs to know what the current
      ``isEnabled`` state is. It doesn’t need to know that
      ``ControlPanelWithToggle`` exists, or even how it is controllable.

   -  ``ControlPanelWithToggle`` doesn’t know that ``ImageWithEnabledOverlay``
      exists. There could be zero, one, or more ways that ``isEnabled`` is
      displayed, and ``ControlPanelWithToggle`` wouldn’t have to change.

   -  To the parent, it doesn’t matter how deeply nested
      ``ImageWithEnabledOverlay`` or ``ControlPanelWithToggle`` are. Those
      children could be animating changes, swapping out content, or passing
      content on to other children.

   This pattern is known as the *inversion of control*, which you can read more
   about in the `CompositionLocal documentation  <#inversion-of-control>`__.

   .. rubric:: Handling screen size changes
      :name: screen-size-changes

   Having different resources for different window sizes is one of the main ways
   to create responsive ``View`` layouts. While qualified resources are still an
   option for screen-level layout decisions, Compose makes it much easier to
   change layouts entirely in code with normal conditional logic. See `Support different screen sizes  <#support-different-screen-sizes>`__ to
   learn more.

   Additionally, refer to `Build adaptive layouts  <#adaptive>`__ to learn about the
   techniques Compose offers to build adaptive UIs.

   .. rubric:: Nested scrolling with Views
      :name: nested-scrolling

   For more information on how to enable nested scrolling interop between
   scrollable View elements and scrollable composables, nested in both
   directions, read through `Nested scrolling interop  <#nested-scrolling-interop>`__.

   .. rubric:: Compose in ``RecyclerView``
      :name: compose-recyclerview

   Composables in ``RecyclerView`` are performant since ``RecyclerView`` version
   1.3.0-alpha02. Make sure you are on at least version 1.3.0-alpha02 of
   ``RecyclerView`` to see those benefits.

   .. rubric:: ``WindowInsets`` interop with Views
      :name: window-insets-interop

   You may need to override default insets when your screen has both Views and
   Compose code in the same hierarchy. In this case, you need to be explicit in
   which one should consume the insets, and which one should ignore them.

   For example, if your outermost layout is an Android View layout, you should
   consume the insets in the View system and ignore them for Compose.
   Alternatively, if your outermost layout is a composable, you should consume
   the insets in Compose, and pad the ``AndroidView`` composables accordingly.

   By default, each ``ComposeView`` consumes all insets at the
   ``WindowInsetsCompat`` level of consumption. To change this default behavior,
   set
   `ComposeView.consumeWindowInsets  <#consumeWindowInsets>`__
   to ``false``.

   For more information, read the `WindowInsets in
   Compose  <#insets>`__ documentation.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Display emoji  <#emoji>`__
   -  `Material Design 2 in Compose  <#material>`__
   -  `Window insets in Compose  <#insets>`__

Last updated 2024-05-03 UTC.

/Adopt Compose for teams
========================

.. https://developer.android.google.cn/develop/ui/compose/adopt/for-large-teams?hl=en

.. container:: devsite-article-body clearfix

   .. container:: section

      .. figure::
         https://developer.android.google.cn/static/images/spot-icons/jetpack-compose.svg

         .. rubric:: Technical decision makers: Adopt Compose for
            your teams
            :name: technical-decision-makers-adopt-compose-for-your-teams

            Jetpack Compose is a declarative UI toolkit that
            accelerates Android app development, helps developers be
            more productive, eliminates common bugs, and enables
            intuitive app design.

            Android is invested in the continued development of
            Jetpack Compose as many developers love it, including
            Googlers. Several Google teams are using Jetpack
            Compose, including the `Play Store <https://android-developers.googleblog.com/2022/03/play-time-with-jetpack-compose.html>`__.

   .. container:: section

      .. rubric:: How to get started
         :name: how-to-get-started

         A best practice for tool adoption is to learn as a team, and
         to designate a champion to lead this learning effort. This
         person would act as a subject matter expert and would help
         build up the expertise of other team members. Other resources
         for getting started are listed below.


         .. rubric:: `Start with Kotlin <https://developer.android.google.cn/kotlin/adopt-for-large-teams>`__
            :name: start-with-kotlin

            Compose makes heavy use of many of the great language
            benefits of Kotlin, and we suggest starting to migrate
            to Kotlin before jumping in with Compose.


         .. rubric:: `Migrate to a declarative approach <https://developer.android.google.cn/develop/ui/compose/mental-model>`__
            :name: migrate-to-a-declarative-approach

            The industry has been shifting toward declarative UI
            frameworks, such as Jetpack Compose, which eliminate
            common bugs and simplify adding animations.


         .. rubric:: `Start learning as a team <https://developer.android.google.cn/courses/pathways/compose>`__
            :name: start-learning-as-a-team

            Start learning together using our in-depth course that
            covers intermediate and advanced topics, and encourage
            knowledge sharing along the learning journey.


         .. rubric:: `Design to high standards <https://developer.android.google.cn/develop/ui/compose/themes>`__
            :name: design-to-high-standards

            Compose components adhere to Material Design (or to your
            own custom design system), and Compose supports themes.

   .. container:: section

      .. rubric:: Three approaches to integrating Compose
         :name: three-approaches-to-integrating-compose

         Compose is `fully interoperable  <#interop>`__ with
         Android's view system so you don’t have to completely
         rewrite your app to benefit from Compose. This allows
         you to take advantage of your existing resources, and
         gives you flexibility on how to add Compose into an
         existing app. There are three common approaches to
         consider:

   .. container:: section

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/images/adopt-for-teams/new-features.png

         .. rubric:: Write new features in Compose.
            :name: write-new-features-in-compose

            The most common approach is to start by writing new
            features in Compose. This approach has a lot of
            flexibility because you can use Compose for complete new
            screens, all the way down to an individual piece of UI
            such as a button. Twitter took this approach for their
            Communities feature.

            `See Twitter’s Compose story <https://www.youtube.com/watch?v=7N9rKu7l_5U>`__

   .. container:: section

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/images/adopt-for-teams/replace-simple-screens.png

         .. rubric:: Replace simple screens.
            :name: replace-simple-screens

            Identifying a few of the more simple screens in your app
            as a starting point for migration is an easy way to
            start taking advantage of the benefits of Compose. This
            is an approach Monzo took when they were starting to
            dive into Compose.

            `See Monzo’s Compose story <https://developer.android.google.cn/stories/apps/monzo-compose>`__

   .. container:: section

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/images/adopt-for-teams/redesign-ui.png

         .. rubric:: Redesign your UI.
            :name: redesign-your-ui

            If you're already planning a major UI redesign for your
            app, it might make more sense to do the full UI update
            in Compose. Typically teams build out UI components in
            Compose and then create screens from those components.
            The Mercari team took this approach.

            `See Mercari’s Compose story <https://developer.android.google.cn/stories/apps/mercari>`__

   .. container:: section

      .. rubric:: Focus on features
         :name: focus-on-features


         |image-code|

         .. rubric:: `Animate with a few lines of code <https://developer.android.google.cn/develop/ui/compose/animation>`__
            :name: animate-with-a-few-lines-of-code

            Compose supports linear and tweened animations,
            animations with custom keyframes, and even dynamic
            spring animations.

            `Discover Compose animations <https://developer.android.google.cn/develop/ui/compose/animation>`__


         |image-android-studio-adaptive|

         .. rubric:: `Preview in Android Studio <https://developer.android.google.cn/develop/ui/compose/tooling#preview>`__
            :name: preview-in-android-studio

            With composables, you can set and review properties like
            size, locale, or light and dark mode as you work.

            `Learn about Preview <https://developer.android.google.cn/develop/ui/compose/tooling#preview>`__


         |image-phone|

         .. rubric:: `See changes in real time <https://developer.android.google.cn/develop/ui/compose/tooling#live-edit>`__
            :name: see-changes-in-real-time

            With Live Edit, you can see changes you make to a
            composable immediately on an emulator or device –
            there’s no need to rebuild your app.

            `Learn about Live Edit <https://developer.android.google.cn/develop/ui/compose/tooling#live-edit>`__


         |image-test-tube-2|

         .. rubric:: `Test with semantics <https://developer.android.google.cn/develop/ui/compose/testing>`__
            :name: test-with-semantics

            Because Compose defines your UI with functions, you can
            test screens to buttons with the same APIs. Confidently
            significant updates to your app and test to confirm your
            features still work.

            `Test in Compose <https://developer.android.google.cn/develop/ui/compose/testing>`__

Last updated 2024-04-15 UTC.

.. |image-code| image:: https://developer.android.google.cn/static/images/picto-icons/code.svg
.. |image-android-studio-adaptive| image:: https://developer.android.google.cn/static/images/picto-icons/android-studio-adaptive.svg
.. |image-phone| image:: https://developer.android.google.cn/static/images/picto-icons/phone.svg
.. |image-test-tube-2| image:: https://developer.android.google.cn/static/images/picto-icons/test-tube-2.svg

/Compose and other libraries
============================

.. https://developer.android.google.cn/develop/ui/compose/libraries?hl=en

.. container:: devsite-article-body clearfix

   You can use your favorite libraries in Compose. This section describes how to
   incorporate a few of the most useful libraries.

   .. rubric:: Activity
      :name: activity

   To use Compose in an activity, you must use
   `ComponentActivity  <#ComponentActivity>`__,
   a subclass of ``Activity`` that provides the appropriate ``LifecycleOwner``
   and components to Compose. It also provides additional APIs that decouple
   your code from overriding methods in your activity class. `Activity Compose  <#package-summary>`__
   exposes these APIs to composables such that overriding methods outside of
   your composables or retrieving an explicit ``Activity`` instance is no longer
   required. Moreover, these APIs ensure that they are only initialized once,
   survive recomposition, and clean up properly if the composable is removed
   from the composition.

   .. rubric:: Activity Result
      :name: activity_result

   The
   `rememberLauncherForActivityResult()  <#rememberlauncherforactivityresult>`__
   API allows you to `get a result from an activity  <#result>`__ in your composable:

   .. code:: prettyprint

      @Composable
      fun GetContentExample() {
          var imageUri by remember { mutableStateOf<Uri?>(null) }
          val launcher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
              imageUri = uri
          }
          Column {
              Button(onClick = { launcher.launch("image/*") }) {
                  Text(text = "Load Image")
              }
              Image(
                  painter = rememberAsyncImagePainter(imageUri),
                  contentDescription = "My Image"
              )
          }
      }ComposeWithOtherLibraries.kt

   This example demonstrates a simple
   `GetContent()  <#ActivityResultContracts.GetContent>`__
   contract. Tapping the button launches the request. The trailing lambda for
   `rememberLauncherForActivityResult()  <#rememberlauncherforactivityresult>`__
   is invoked once the user selects an image and returns to the launching
   activity. This loads the selected image using Coil’s
   ``rememberImagePainter()`` function.

   Any subclass of
   `ActivityResultContract  <#ActivityResultContract>`__
   can be used as the first argument to
   `rememberLauncherForActivityResult()  <#rememberlauncherforactivityresult>`__.
   This means that you can use this technique to request content from the
   framework and in other common patterns. You can also create your own `custom contracts  <#custom>`__ and use them with this
   technique.

   **Caution:**\  This example shows how to launch a request from a user
   interaction. In this case from an ``onClick()`` listener. If you attempt to
   launch a request from inside the composable you’ll get a runtime error
   because the
   `ActivityResultLauncher  <#ActivityResultLauncher>`__
   has not been initialised at this point. If you need to trigger the launch
   following composition you’ll need to call the
   `launch()  <#launch>`__
   method from inside a
   `LaunchedEffect  <#LaunchedEffect>`__
   or
   `DisposableEffect  <#DisposableEffect>`__
   block.

   .. rubric:: Requesting runtime permissions
      :name: requesting-runtime-permissions

   The same Activity Result API and
   `rememberLauncherForActivityResult()  <#rememberlauncherforactivityresult>`__
   explained above can be used to `request runtime permissions  <#allow-system-manage-request-code>`__
   using the
   `RequestPermission  <#ActivityResultContracts.RequestPermission>`__
   contract for a single permission or
   `RequestMultiplePermissions  <#ActivityResultContracts.RequestMultiplePermissions>`__
   contract for multiple permissions.

   The `Accompanist Permissions library <https://google.github.io/accompanist/permissions/>`__ can also be
   used a layer above those APIs to map the current granted state for
   permissions into State that your Compose UI can use.

   .. rubric:: Handling the system back button
      :name: handling_the_system_back_button

   To `provide custom back navigation  <#navigation-custom-back>`__ and override the
   default behavior of the system back button from within your composable, your
   composable can use a
   `BackHandler  <#backhandler>`__
   to intercept that event:

   .. code:: prettyprint

      var backHandlingEnabled by remember { mutableStateOf(true) }
      BackHandler(backHandlingEnabled) {
          // Handle back press
      }ComposeWithOtherLibraries.kt

   The first argument controls whether the
   `BackHandler  <#backhandler>`__
   is currently enabled; you can use this argument to temporarily disable your
   handler based on the state of your component. The trailing lambda will be
   invoked if the user triggers a system back event, and the
   `BackHandler  <#backhandler>`__
   is currently enabled.

   **Caution:**\  While it is possible to add multiple back handlers to any
   composition, the system back event is handled and consumed by the innermost
   *enabled* ``BackHandler``. In other words, at most one ``BackHandler`` is
   active at any time.

   .. rubric:: ``ViewModel``
      :name: viewmodel

   If you use the `Architecture Components ViewModel  <#viewmodel>`__ library, you can
   access a `ViewModel  <#ViewModel>`__ from any
   composable by calling the
   `viewModel()  <#viewmodel>`__
   function.

   **Note:**\  Due to their `lifecycle and scoping  <#lifecycle>`__, **you should
   access and call ``ViewModel`` instances at screen-level composables**, that
   is, close to a root composable called from an activity, fragment, or
   destination of a Navigation graph. **You should never pass down ViewModel
   instances to other composables**, pass only the data they need and functions
   that perform the required logic as parameters.
   **Caution:** To use the ``viewModel()`` functions, add the
   ``androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1`` dependency to your
   ``build.gradle`` file.

   .. code:: prettyprint

      class MyViewModel : ViewModel() { /*...*/ }

      // import androidx.lifecycle.viewmodel.compose.viewModel
      @Composable
      fun MyScreen(
          viewModel: MyViewModel = viewModel()
      ) {
          // use viewModel here
      }ComposeWithOtherLibraries.kt

   ``viewModel()`` returns an existing ``ViewModel`` or creates a new one in the
   given scope. The ``ViewModel`` is retained as long as the scope is alive. For
   example, if the composable is used in an activity, ``viewModel()`` returns
   the same instance until the activity is finished or the process is killed.

   .. code:: prettyprint

      class MyViewModel : ViewModel() { /*...*/ }
      // import androidx.lifecycle.viewmodel.compose.viewModel
      @Composable
      fun MyScreen(
          // Returns the same instance as long as the activity is alive,
          // just as if you grabbed the instance from an Activity or Fragment
          viewModel: MyViewModel = viewModel()
      ) { /* ... */ }

      @Composable
      fun MyScreen2(
          viewModel: MyViewModel = viewModel() // Same instance as in MyScreen
      ) { /* ... */ }ComposeWithOtherLibraries.kt

   If your ViewModel has dependencies, ``viewModel()`` takes an optional
   `ViewModelProvider.Factory  <#ViewModelProvider.Factory>`__
   as a parameter.

   For more information about ``ViewModel`` in Compose and how instances are
   used with the Navigation Compose library, or activities and fragments, see
   the `Interoperability docs  <#viewmodel>`__.

   .. rubric:: Streams of data
      :name: streams

   Compose comes with extensions for Android's most popular stream-based
   solutions. Each of these extensions is provided by a different artifact:

   -  `LiveData.observeAsState()  <#observeAsState>`__
      included in the
      ``androidx.compose.runtime:runtime-livedata:$composeVersion`` artifact.
   -  `Flow.collectAsState()  <#collectAsState>`__
      doesn't require extra dependencies.
   -  `Observable.subscribeAsState()  <#subscribeAsState>`__
      included in the
      ``androidx.compose.runtime:runtime-rxjava2:$composeVersion`` or
      ``androidx.compose.runtime:runtime-rxjava3:$composeVersion`` artifact.

   These artifacts register as a listener and represent the values as a
   `State  <#State>`__. Whenever a
   new value is emitted, Compose recomposes those parts of the UI where that
   ``state.value`` is used. For example, in this code, ``ShowData`` recomposes
   every time ``exampleLiveData`` emits a new value.

   .. code:: prettyprint

      // import androidx.lifecycle.viewmodel.compose.viewModel
      @Composable
      fun MyScreen(
          viewModel: MyViewModel = viewModel()
      ) {
          val dataExample = viewModel.exampleLiveData.observeAsState()

          // Because the state is read here,
          // MyScreen recomposes whenever dataExample changes.
          dataExample.value?.let {
              ShowData(dataExample)
          }
      }ComposeWithOtherLibraries.kt

   .. rubric:: Asynchronous operations in Compose
      :name: async

   Jetpack Compose lets you execute asynchronous operations using coroutines
   from within your composables.

   See the ``LaunchedEffect``, ``produceState``, and ``rememberCoroutineScope``
   APIs in the `side effects documentation  <#side-effects>`__
   for more information.

   .. rubric:: Navigation
      :name: navigation

   The `Navigation component  <#get-started>`__ provides support
   for Jetpack Compose applications. See `Navigating with Compose  <#navigation>`__ and `Migrate Jetpack Navigation to Navigation Compose  <#navigation>`__ for
   more information.

   .. rubric:: Hilt
      :name: hilt

   Hilt is the recommended solution for dependency injection in Android apps,
   and works seamlessly with Compose.

   The ``viewModel()`` function mentioned in the `ViewModel section  <#viewmodel>`__ automatically uses the
   ViewModel that Hilt constructs with the ``@HiltViewModel`` annotation. We've
   provided documentation with information about `Hilt's ViewModel integration  <#viewmodels>`__.

   .. code:: prettyprint

      @HiltViewModel
      class MyViewModel @Inject constructor(
          private val savedStateHandle: SavedStateHandle,
          private val repository: ExampleRepository
      ) : ViewModel() { /* ... */ }

      // import androidx.lifecycle.viewmodel.compose.viewModel
      @Composable
      fun MyScreen(
          viewModel: MyViewModel = viewModel()
      ) { /* ... */ }
      ComposeWithOtherLibraries.kt

   .. rubric:: Hilt and Navigation
      :name: hilt-navigation

   Hilt also integrates with the Navigation Compose library. Add the following
   additional dependencies to your Gradle file:

   .. container::

      .. container:: ds-selector-tabs

         .. container:: section

            .. rubric:: Groovy
               :name: groovy

            .. code:: prettyprint

               dependencies {
                   implementation 'androidx.hilt:hilt-navigation-compose:1.0.0'
               }

         .. container:: section

            .. rubric:: Kotlin
               :name: kts

            .. code:: prettyprint

               dependencies {
                   implementation("androidx.hilt:hilt-navigation-compose:1.0.0")
               }

   When using Navigation Compose, always use the ``hiltViewModel`` composable
   function to obtain an instance of your ``@HiltViewModel`` annotated
   ``ViewModel``. This works with fragments or activities that are annotated
   with ``@AndroidEntryPoint``.

   For example, if ``ExampleScreen`` is a destination in a navigation graph,
   call ``hiltViewModel()`` to get an instance of ``ExampleViewModel`` scoped to
   the destination as shown in the code snippet below:

   .. code:: prettyprint

      // import androidx.hilt.navigation.compose.hiltViewModel

      @Composable
      fun MyApp() {
          val navController = rememberNavController()
          val startRoute = "example"
          NavHost(navController, startDestination = startRoute) {
              composable("example") { backStackEntry ->
                  // Creates a ViewModel from the current BackStackEntry
                  // Available in the androidx.hilt:hilt-navigation-compose artifact
                  val viewModel = hiltViewModel<MyViewModel>()
                  MyScreen(viewModel)
              }
              /* ... */
          }
      }ComposeWithOtherLibraries.kt

   If you need to retrieve the instance of a ``ViewModel`` scoped to `navigation routes  <#nested-nav>`__ or `the navigation graph  <#share_ui-related_data_between_destinations_with_viewmodel>`__
   instead, use the ``hiltViewModel`` composable function and pass the
   corresponding ``backStackEntry`` as a parameter:

   .. code:: prettyprint

      // import androidx.hilt.navigation.compose.hiltViewModel
      // import androidx.navigation.compose.getBackStackEntry

      @Composable
      fun MyApp() {
          val navController = rememberNavController()
          val startRoute = "example"
          val innerStartRoute = "exampleWithRoute"
          NavHost(navController, startDestination = startRoute) {
              navigation(startDestination = innerStartRoute, route = "Parent") {
                  // ...
                  composable("exampleWithRoute") { backStackEntry ->
                      val parentEntry = remember(backStackEntry) {
                          navController.getBackStackEntry("Parent")
                      }
                      val parentViewModel = hiltViewModel<ParentViewModel>(parentEntry)
                      ExampleWithRouteScreen(parentViewModel)
                  }
              }
          }
      }ComposeWithOtherLibraries.kt

   .. rubric:: Paging
      :name: paging

   The `Paging library  <#paging>`__ makes it easier
   for you to load data gradually and it's supported in Compose. The `Paging release page  <#paging>`__ contains information
   about the extra ``paging-compose`` dependency that needs to be added to the
   project and its version.

   Here's an example of the Paging library's Compose APIs:

   .. code:: prettyprint

      @Composable
      fun MyScreen(flow: Flow<PagingData<String>>) {
          val lazyPagingItems = flow.collectAsLazyPagingItems()
          LazyColumn {
              items(
                  lazyPagingItems.itemCount,
                  key = lazyPagingItems.itemKey { it }
              ) { index ->
                  val item = lazyPagingItems[index]
                  Text("Item is $item")
              }
          }
      }ComposeWithOtherLibraries.kt

   Check out the `Lists and grids documentation  <#lists>`__
   for more information about using Paging in Compose.

   .. rubric:: Maps
      :name: maps

   You can use the `Maps Compose <https://developers.google.cn/maps/documentation/android-sdk/maps-compose>`__
   library to provide Google Maps in your app. Here's a usage example:

   .. code:: prettyprint

      @Composable
      fun MapsExample() {
          val singapore = LatLng(1.35, 103.87)
          val cameraPositionState = rememberCameraPositionState {
              position = CameraPosition.fromLatLngZoom(singapore, 10f)
          }
          GoogleMap(
              modifier = Modifier.fillMaxSize(),
              cameraPositionState = cameraPositionState
          ) {
              Marker(
                  state = MarkerState(position = singapore),
                  title = "Singapore",
                  snippet = "Marker in Singapore"
              )
          }
      }ComposeWithOtherLibraries.kt

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Side-effects in Compose  <#side-effects>`__
   -  `State and Jetpack Compose  <#state>`__
   -  `Save UI state in Compose  <#state-saving>`__

Last updated 2024-05-03 UTC.

/Compare Compose and View metrics
=================================

.. https://developer.android.google.cn/develop/ui/compose/migrate/compare-metrics?hl=en

.. container:: devsite-article-body clearfix

   Jetpack Compose accelerates UI development and `improves Android development  <#why-adopt>`__. However, take into
   consideration how adding Compose to an existing app can affect metrics such
   as an app's APK size, build, and runtime performance.

   .. rubric:: APK size and build times
      :name: apk-and-build

   This section goes over the impact to APK size and build time by looking at
   the
   `Sunflower <https://github.com/android/sunflower/tree/compose_recyclerview>`__
   sample app—an app that demonstrates best practices with migrating a
   View-based app to Compose.

   **Note:**\  The results here are specific to the Sunflower sample app. Your
   metrics may vary as APK size and build time depend on several factors, such
   as number of modules, dependencies and versions you use, etc.

   .. rubric:: APK size
      :name: apk-size

   Adding libraries to your project increases its APK size. The following
   results are for the minified release APK of each project with `resource and code shrinking enabled  <#shrink-resources>`__, using
   R8 full mode, and measured using `APK Analyzer  <#apk-analyzer>`__.

   .. list-table::
      :header-rows: 1

      - 

         - 
         - **Views only**
         - **Mixed Views and Compose**
         - **Compose-only**
      - 

         - Download size
         - 2,252 KB
         - 3,034 KB
         - 2,966 KB

   When first adding Compose to Sunflower, the APK size increased from 2,252 KB
   to 3,034 KB—a **782 KB increase**. The generated APK consisted of the UI
   build with a mix of Views and Compose. This increase is to be expected as
   additional dependencies were added to Sunflower.

   Conversely, when Sunflower was migrated to a Compose-only app, the APK size
   decreased from 3,034 KB to 2,966 KB—a **68 KB decrease**. This decrease was
   due to removing unused View dependencies, such as ``AppCompat`` and
   ``ConstraintLayout``.

   .. rubric:: Build time
      :name: build-time

   Adding Compose increases the build time of your app as the Compose compiler
   processes composables in your app. The following results were obtained using
   the standalone
   `gradle-profiler  <#gradle-profiler>`__ tool,
   which executes a build several times so that a mean build time can be
   obtained for the debug build duration of Sunflower:

   .. code:: prettyprint

      gradle-profiler --benchmark --project-dir . :app:assembleDebug

   .. list-table::
      :header-rows: 1

      - 

         - 
         - **Views only**
         - **Mixed Views and Compose**
         - **Compose-only**
      - 

         - Mean build time
         - 299.47 ms
         - 399.09 ms
         - 342.16 ms

   When first adding Compose to Sunflower, the mean build time increased from
   299 ms to 399 ms—a **100 ms increase**. This duration is due to the Compose
   compiler performing additional tasks to transform Compose code defined in the
   project.

   Conversely, the mean build time dropped to 342 ms, a **57 ms decrease**, when
   Sunflower's migration to Compose was completed. This reduction can be
   attributed to several factors which collectively reduce build time such as
   removing `data binding  <#data-binding>`__, migrating
   dependencies that use `kapt to KSP  <#migrate-to-ksp>`__, and updating
   several dependencies to their latest versions.

   .. rubric:: Summary
      :name: summary

   Adopting Compose will effectively increase the APK size of your app and also
   increase the build time performance of your app due to the compilation
   process of Compose code. These tradeoffs, however, need to be weighed against
   the `benefits of Compose  <#why-adopt>`__, especially
   around developer productivity increases when adopting Compose. For example,
   the `Play Store team <https://android-developers.googleblog.com/2022/03/play-time-with-jetpack-compose.html>`__
   found that **writing UI requires much less code, sometimes up to 50%**,
   thereby increasing productivity and maintainability of code.

   You can read more case studies in `Adopt Compose for Teams  <#for-large-teams>`__.

   .. rubric:: Runtime performance
      :name: runtime-perf

   This section covers topics related to runtime performance in Jetpack Compose
   to help understand how Jetpack Compose compares to the View system's
   performance, and how you can measure it.

   .. rubric:: Smart recompositions
      :name: smart-recomposition

   When portions of the UI are invalid, Compose tries to recompose just the
   portions that need to be updated. Read more about this in the `Lifecycle of composables  <#lifecycle>`__ and `Jetpack Compose phases  <#phases>`__ documentation.

   .. rubric:: Baseline Profiles
      :name: baseline-profiles

   `Baseline Profiles  <#overview>`__ are an
   excellent way of speeding up common user journeys. Including a Baseline
   Profile in your app can improve code execution speed by about 30% from the
   first launch by avoiding interpretation and just-in-time (JIT) compilation
   steps for included code paths.

   The Jetpack Compose library includes its own Baseline Profile and you
   automatically get these optimizations when you use Compose in your app.
   However, these optimizations only affect code paths within the Compose
   library, so we recommend that you `add a Baseline Profile  <#create-baselineprofile>`__ to
   your app to cover code paths outside of Compose.

   .. rubric:: Comparison with the View system
      :name: comparison-with-view

   Jetpack Compose has many improvements over the View system. These
   improvements are described in the following sections.

   .. rubric:: Everything extends View
      :name: everything-extends-view

   Every ``View`` that draws on the screen, such as ``TextView``, ``Button``, or
   ``ImageView``, requires memory allocations, explicit state tracking, and
   various callbacks to support all use cases. Furthermore, the custom ``View``
   owner needs to implement explicit logic to prevent redrawing when it isn't
   necessary—for example, for repetitive data processing.

   Jetpack Compose addresses this in a few ways. Compose doesn't have explicit
   updatable objects for drawing views. UI elements are simple composable
   functions whose information is written to the composition in a replayable
   way. This helps cut down explicit state tracking, memory allocations, and
   callbacks to only the composables that require said features instead of
   requiring them by all extensions of a given ``View`` type.

   Furthermore, Compose provides `smart recompositions <#smart-recomposition>`__, replaying the previously drawn
   result if you don't need to make changes.

   .. rubric:: Multiple layout passes
      :name: multiple-passes

   Traditional ViewGroups have a lot of expressiveness in their measure and
   layout APIs that make them prone to multiple layout passes. These multiple
   layout passes can cause exponential work if done at specific nested points in
   the view hierarchy.

   Jetpack Compose enforces a `single layout pass  <#custom>`__ for all layout composables via
   its API contract. This lets Compose efficiently handle deep UI trees. If
   multiple measurements are needed, Compose has `intrinsic measurements  <#intrinsic-measurements>`__.

   .. rubric:: View startup performance
      :name: view-startup-perf

   The View system needs to inflate XML layouts when showing a particular layout
   for the first time. This cost is saved in Jetpack Compose since layouts are
   written in Kotlin and compiled like the rest of your app.

   .. rubric:: Benchmark Compose
      :name: benchmarking

   In Jetpack Compose 1.0, there are notable differences between the performance
   of an app in ``debug`` and ``release`` modes. For representative timings,
   **always** use the ``release`` build instead of ``debug`` when profiling your
   app.

   To check how your Jetpack Compose code is performing, you can use the
   `Jetpack Macrobenchmark  <#macrobenchmark>`__ library. To learn
   how to use it with Jetpack Compose, see the `MacrobenchmarkSample project <https://github.com/android/performance-samples/tree/main/MacrobenchmarkSample>`__.

   The Jetpack Compose team also uses Macrobenchmark to catch any regressions
   that can happen. For example, see the `benchmark for lazy column <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/integration-tests/macrobenchmark/src/main/java/androidx/compose/integration/macrobenchmark/TrivialListScrollBenchmark.kt>`__
   and its
   `dashboard <https://androidx-perf.skia.org/e/?queries=test%3Dandroidx.benchmark.integration.macrobenchmark.SmallListStartupBenchmark_startup_startup_HOT_compilation_None_%26test%3Dandroidx.benchmark.integration.macrobenchmark.SmallListStartupBenchmark_startup_startup_WARM_compilation_None_%26test%3Dandroidx.benchmark.integration.macrobenchmark.SmallListStartupBenchmark_startup_startup_WARM_compilation_SpeedProfile_iterations_3__%26test%3Dandroidx.benchmark.integration.macrobenchmark.SmallListStartupBenchmark_startup_startup_HOT_compilation_SpeedProfile_iterations_3__%26test%3Dandroidx.benchmark.integration.macrobenchmark.SmallListStartupBenchmark_startup_startup_COLD_compilation_SpeedProfile_iterations_3__%26test%3Dandroidx.benchmark.integration.macrobenchmark.SmallListStartupBenchmark_startup_startup_COLD_compilation_None_>`__
   to track regressions.

   .. rubric:: Compose profile installation
      :name: profile-inst

   Since Jetpack Compose is an unbundled library, it doesn't benefit from
   `Zygote  <#SharingRAM>`__ that preloads the
   View system's UI Toolkit classes and drawables. Jetpack Compose 1.0 utilizes
   profile installation for *release* builds. `Profile installers  <#profileinstaller>`__ let apps specify
   critical code to be ahead-of-time (AOT) compiled at installation time.
   Compose ships profile installation rules which reduce startup time and jank
   in Compose apps.

   **Note:**\  Compose profiles aren't available on Android L or M, since the
   app is compiled AOT by Android Framework on devices running these versions.
   The `Making apps blazing fast with Baseline Profiles video <https://www.youtube.com/watch?v=yJm5On5Gp4c>`__ explains this further.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Other considerations  <#other-considerations>`__
   -  `Using Compose in Views  <#compose-in-views>`__
   -  `Scroll  <#scroll>`__

Last updated 2024-05-03 UTC.

/Overview: Tools
================

.. https://developer.android.google.cn/develop/ui/compose/tooling?hl=en

.. container:: 

   .. rubric:: Tools for Compose
      :name: tools-for-compose

   .. container:: video-wrapper

   Android Studio brings a lot of new features specifically
   for Jetpack Compose. It embraces a code-first approach
   while improving the developer productivity without
   having to choose between using design interface or code
   editor.

   A fundamental difference between View-based UI and
   Jetpack Compose is that Compose doesn't rely on ``View``
   to render its composables. As a consequence of this
   architecture approach, Android Studio offers extended
   features for Jetpack Compose without having to open an
   emulator or connect to a device. Compared to Android
   Views, this allows a faster, iterative process for
   developers to implement their UI designs.

   To enable Android Studio-specific features for Jetpack
   Compose, you need to add these dependencies in your
   application ``build.gradle(.kts)`` file. You can either
   use the `Bill of Materials (BOM)  <#bom>`__ or define
   dependencies individually.


   .. container:: section

      .. rubric:: Bill of Materials
         :name: bom

      .. code:: prettyprint

           val composeBom = platform("androidx.compose:compose-bom:2024.05.00")
           implementation(composeBom)

           debugImplementation("androidx.compose.ui:ui-tooling")
           implementation("androidx.compose.ui:ui-tooling-preview")

   .. container:: section

      .. rubric:: Individually
         :name: individually

      .. code:: prettyprint

           debugImplementation("androidx.compose.ui:ui-tooling:1.6.7")
           implementation("androidx.compose.ui:ui-tooling-preview:1.6.7")

   **Note:** These dependencies are already present when
   you create your project from the Compose template.

   .. container:: section

      .. rubric:: Design
         :name: design

         Create components, design systems, and screens to align with
         design specs.


         .. rubric:: `Preview your UI <https://developer.android.google.cn/develop/ui/compose/tooling/previews>`__
            :name: preview-your-ui

            PreviewParameter Multipreview

            The ``@Preview`` annotation allows you to preview your
            composables. Learn how to preview, organize, and
            interact with them.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/tooling/previews>`__


         .. rubric:: `Preview and debug animations <https://developer.android.google.cn/develop/ui/compose/tooling/animation-preview>`__
            :name: preview-and-debug-animations

            Animation Preview

            Android Studio allows you to design and inspect
            animations using the Animation Preview pane. With this,
            you can preview an animation frame by frame and make
            sure it aligns with required behavior.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/tooling/animation-preview>`__

   .. container:: section

      .. rubric:: Develop
         :name: develop

         Accelerate building the UI and testing the running application
         with less context switching.


         Live Edit

         .. rubric:: `Develop code iteratively <https://developer.android.google.cn/develop/ui/compose/tooling/iterative-development>`__
            :name: develop-code-iteratively

            Learn how to use Live Edit and apply changes to avoid a
            full build and accelerate your development process.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/tooling/iterative-development>`__


            Live templates Gutter icons

         .. rubric:: `Editor actions <https://developer.android.google.cn/develop/ui/compose/tooling/editor-actions>`__
            :name: editor-actions

            Learn how to use features inside the Android Studio
            editor window for improved productivity.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/tooling/editor-actions>`__

   .. container:: section

      .. rubric:: Debug
         :name: debug

         Debug your Compose UI to understand your app. Learn more about
         analyzing layout, recompositions, and composition tracing to
         improve the UI performance of your app.

         Recomposition counts Semantics

         .. rubric:: `Inspect your layout <https://developer.android.google.cn/develop/ui/compose/tooling/layout-inspector>`__
            :name: inspect-your-layout

            Learn how to inspect a Compose layout in an emulator or
            physical device.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/tooling/layout-inspector>`__


            System Tracing

         .. rubric:: `Trace performance <https://developer.android.google.cn/develop/ui/compose/tooling/tracing>`__
            :name: trace-performance

            Use composition tracing to trace your composable
            functions in a system trace.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/tooling/tracing>`__

   .. container:: section

      .. rubric:: Additional Tools
         :name: additional-tools

         .. rubric:: `Relay <https://developer.android.google.cn/develop/ui/compose/tooling/relay>`__
            :name: relay

            Relay provides instant handoff of Android UI components
            between designers and developers. Designers can use the
            Relay for Figma plugin to annotate and package UI
            components for developer use, including information
            about layout, styling, dynamic content, and interaction
            behavior.

            `Learn more <https://developer.android.google.cn/develop/ui/compose/tooling/relay>`__

Last updated 2024-05-03 UTC.

/Preview your UI
================

.. https://developer.android.google.cn/develop/ui/compose/tooling/previews?hl=en

.. container:: devsite-article-body clearfix

   A composable is defined by a function and annotated with ``@Composable``:

   .. code:: prettyprint

      @Composable
      fun SimpleComposable() {
          Text("Hello World")
      }AndroidStudioComposeSnippets.kt

   |A simple text element containing the words "Hello World"|

   To enable a preview of this composable, create another composable, annotated
   with ``@Composable`` and ``@Preview``. This new, annotated composable now
   contains the composable you created initially, ``SimpleComposable``:

   .. code:: prettyprint

      @Preview
      @Composable
      fun SimpleComposablePreview() {
          SimpleComposable()
      }AndroidStudioComposeSnippets.kt

   The
   `@Preview  <#Preview>`__
   annotation tells Android Studio that this composable should be shown in the
   design view of this file. You can see live updates to your composable preview
   as you make your edits.

   |A gif showing real time updates using Compose Preview|

   You can add parameters manually in your code to customize the way Android
   Studio renders ``@Preview``. You can even add the ``@Preview`` annotation to
   the same function multiple times to preview a composable with different
   properties.

   **Note:**\  If you have multiple composable previews but want to focus on one
   preview at a time, we recommend using Gallery Mode to save rendering
   resources. Switch to Grid or List mode when you need to see all the UI
   variants at once. You can toggle between modes by using the menu at the top
   of the **Design** tab.
   One of the primary benefits of using ``@Preview`` composables is to avoid
   reliance on the emulator in Android Studio. You can save the memory-heavy
   startup of the emulator for more final look-and-feel changes, and
   ``@Preview``'s ability to make and test small code changes with ease.

   To leverage ``@Preview`` annotation most effectively, make sure to define
   your screens in terms of the state it receives as input and the events that
   it outputs.

   .. rubric:: Define your ``@Preview``
      :name: preview-definitions

   Android Studio offers some features to extend composable previews. You can
   change their container design, interact with them, or deploy them directly to
   an emulator or device.

   .. rubric:: Dimensions
      :name: preview-dimensions

   By default, ``@Preview`` dimensions are chosen automatically to wrap its
   content. To set the dimensions manually, add ``heightDp`` and ``widthDp``
   parameters. Those values are already interpreted as
   `dp  <#Dp>`__, so you don't need
   to add ``.dp`` to them:

   .. code:: prettyprint

      @Preview(widthDp = 50, heightDp = 50)
      @Composable
      fun SquareComposablePreview() {
          Box(Modifier.background(Color.Yellow)) {
              Text("Hello World")
          }
      }AndroidStudioComposeSnippets.kt

   |A yellow square with the words "Hello World"|

   .. rubric:: Dynamic color preview
      :name: dynamic-color-preview

   If you've enabled `dynamic color <https://m3.material.io/styles/color/dynamic-color/overview>`__ in your
   app, use the ``wallpaper`` attribute to switch wallpapers and see how your UI
   reacts to different users' chosen wallpaper. Select from the different
   wallpaper themes offered by the
   `Wallpaper  <#Wallpapers>`__
   class. This feature requires Compose 1.4.0 or higher.

   .. rubric:: Use with different devices
      :name: different-devices

   In Android Studio Flamingo, you can edit the ``device`` parameter of the
   Preview annotation to define configurations for your composables in different
   devices.

   |Sample Composable function|

   When the device parameter has an empty string (``@Preview(device = "")``),
   you can invoke autocomplete by pressing ``Ctrl`` + ``Space``. Then, you can
   set the values of each parameter.

   |Editing the sample function|

   From autocomplete, you can select any device option from the list–for
   example, ``@Preview(device = "id:pixel_4")``. Alternatively, you can enter a
   custom device by choosing ``spec:width=px,height=px,dpi=int…`` to set the
   individual values of each parameter.

   |Spec list|

   To apply, press ``Enter``, or cancel with ``Esc``.

   If you set an invalid value, the declaration is underlined in red and a fix
   may be available (``Alt`` + ``Enter`` (⌥ + ⏎ for macOS) > **Replace with …**.
   The Inspection attempts to provide a fix that is closest to resembling your
   input.

   |Example of invalid value|

   .. rubric:: Locale
      :name: preview-locale

   To test different user locales, add the ``locale`` parameter:

   .. code:: prettyprint

      @Preview(locale = "fr-rFR")
      @Composable
      fun DifferentLocaleComposablePreview() {
          Text(text = stringResource(R.string.greeting))
      }AndroidStudioComposeSnippets.kt

   |A simple text element containing the word "Bonjour" with a French flag|

   .. rubric:: Set background color
      :name: preview-bg-color

   By default, your composable is displayed with a transparent background. To
   add a background, add the ``showBackground`` and ``backgroundColor``
   parameters. Keep in mind that ``backgroundColor`` is an ARGB
   `Long  <#color-longs>`__, not a ``Color`` value:

   .. code:: prettyprint

      @Preview(showBackground = true, backgroundColor = 0xFF00FF00)
      @Composable
      fun WithGreenBackground() {
          Text("Hello World")
      }AndroidStudioComposeSnippets.kt

   |A green rectangle with the words "Hello World"|

   .. rubric:: System UI
      :name: preview-decoration

   If you need to display the status and action bars inside a preview, add the
   ``showSystemUi`` parameter:

   .. code:: prettyprint

      @Preview(showSystemUi = true)
      @Composable
      fun DecoratedComposablePreview() {
          Text("Hello World")
      }AndroidStudioComposeSnippets.kt

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-decorated-preview.png
      name: image-1
      :alt: A preview window showing an activity with the status and action
      bars.
      :width: 400px

   .. rubric:: UI mode
      :name: ui-mode

   The parameter ``uiMode`` can take any of the
   `Configuration.UI_*  <#UI_MODE_NIGHT_MASK>`__
   constants and allows you to change the behavior of the preview accordingly.
   For example, you can set the preview to Night Mode to see how the theme
   reacts.

   |Compose preview UI|

   .. rubric:: ``LocalInspectionMode``
      :name: localinspectionmode

   You can read from the
   `LocalInspectionMode  <#LocalInspectionMode>`__
   ``CompositionLocal`` to see if the composable is rendered in a preview
   (inside an `inspectable component  <#InspectableValue>`__).
   If the composition is rendered in a preview, ``LocalInspectionMode.current``
   evaluates to ``true``. This information lets you customize your preview; for
   example, you can show a placeholder image in the preview window instead of
   showing real data.

   This way, you can also work around the
   `limitations <#preview-limitations>`__. For example, showing sample data
   instead of calling network request.

   .. code:: prettyprint

      @Composable
      fun GreetingScreen(name: String) {
          if (LocalInspectionMode.current) {
              // Show this text in a preview window:
              Text("Hello preview user!")
          } else {
              // Show this text in the app:
              Text("Hello $name!")
          }
      }AndroidStudioComposeSnippets.kt

   .. rubric:: Interact with your ``@Preview``
      :name: preview-interactions

   Android Studio provides features that allow you to interact with your defined
   previews. This interaction helps you understand your previews' runtime
   behavior and allows you to better navigate your UI with previews.

   .. rubric:: Interactive mode
      :name: preview-interactive

   The interactive mode lets you interact with a preview similarly to how you
   would on a device running your program, like a phone or tablet. The
   interactive mode is isolated in a sandbox environment (meaning, isolated from
   other previews), where you can click elements and enter user input in the
   preview. It's a quick way to test different states, gestures, and even
   animations of your composable.

   |The user clicking the preview's "interactive" button|

   |A video of the user interacting with a preview|

   .. rubric:: Code navigation and composable outlines
      :name: preview-code-nav

   You can hover over a preview to see the outlines of the composables contained
   within. Clicking on a composable outline triggers your editor view to
   navigate to its definition.

   |The user hovering over a preview, causing Studio to display the outlines of
   its composables|

   .. rubric:: Run preview
      :name: run-preview

   You can run a specific ``@Preview`` on an emulator or a physical device. The
   preview is deployed within the same project app as a new ``Activity``, so it
   shares the same context and permissions. It does not require you to write
   boilerplate code asking for a permission if it has already been granted.

   **Note:**\  The arguments applied to the ``@Preview`` annotation (for
   example, ``widthDp``, ``locale``, etc.) aren't applied to the preview that is
   run and deployed.
   Click the **Run Preview** icon |Run Preview icon| next to the ``@Preview``
   annotation or at the top of the preview, and Android Studio deploys that
   ``@Preview`` to your connected device or emulator.

   |The user clicking the preview's "run preview" button|

   |Video of the user deploying a preview to the device|

   .. rubric:: Copy ``@Preview`` render
      :name: preview-copy-render

   Every rendered preview can be copied as an image by right clicking on it.

   |The user clicking on a preview to copy it as an image.|

   .. rubric:: Multiple previews of the same ``@Preview`` annotation
      :name: preview-multiple

   You can showcase multiple versions of the same ``@Preview`` composable with
   different specifications, or different parameters passed to the composable.
   This way, you can reduce the boilerplate code that you would need to write
   otherwise.

   .. rubric:: Multipreview templates
      :name: multipreview-templates

   ``androidx.compose.ui:ui-tooling-preview`` 1.6.0-alpha01+ introduces
   Multipreview API templates: ``@PreviewScreenSizes``, ``@PreviewFontScales``,
   ``@PreviewLightDark``, and ``@PreviewDynamicColors``, so that with one single
   annotation, you can preview your Compose UI in common scenarios.

   |Previewing different fonts and screen sizes using templates|

   .. rubric:: Create custom multipreview annotations
      :name: preview-multipreview

   With multipreview, you can define an annotation class that itself has
   multiple ``@Preview`` annotations with different configurations. Adding this
   annotation to a composable function automatically renders all of the
   different previews at once. For example, you can use this annotation to
   preview multiple devices, font sizes, or themes at the same time without
   repeating those definitions for every single composable.

   Start by creating your own custom annotation class:

   .. code:: prettyprint

      @Preview(
          name = "small font",
          group = "font scales",
          fontScale = 0.5f
      )
      @Preview(
          name = "large font",
          group = "font scales",
          fontScale = 1.5f
      )
      annotation class FontScalePreviewsAndroidStudioComposeSnippets.kt

   You can use this custom annotation for your preview composables:

   .. code:: prettyprint

      @FontScalePreviews
      @Composable
      fun HelloWorldPreview() {
          Text("Hello World")
      }AndroidStudioComposeSnippets.kt

   |Android Studio design tab showing the composable with small and large font|

   You can combine multiple multipreview annotations and normal preview
   annotations to create a more complete set of previews. Combining multipreview
   annotations doesn't mean all the different combinations are shown. Instead,
   each multipreview annotation acts independently and renders only its own
   variants.

   .. code:: prettyprint

      @Preview(
          name = "Spanish",
          group = "locale",
          locale = "es"
      )
      @FontScalePreviews
      annotation class CombinedPreviews

      @CombinedPreviews
      @Composable
      fun HelloWorldPreview2() {
          MaterialTheme { Surface { Text(stringResource(R.string.hello_world)) } }
      }AndroidStudioComposeSnippets.kt

   |Android Studio design tab showing the composable in all configurations|

   The mix-and-match nature of multipreview-- and normal preview!-- lets you
   more comprehensively test many properties of larger scale projects.

   .. rubric:: ``@Preview`` and large data sets
      :name: preview-data

   Very often, a need arises where you must pass a large dataset to your
   composable preview. To do this, simply pass sample data to a Composable
   Preview function by adding a parameter with the
   `@PreviewParameter  <#PreviewParameter>`__
   annotation.

   .. code:: prettyprint

      @Preview
      @Composable
      fun UserProfilePreview(
          @PreviewParameter(UserPreviewParameterProvider::class) user: User
      ) {
          UserProfile(user)
      }
      AndroidStudioComposeSnippets.kt

   To provide the sample data, create a class that implements
   `PreviewParameterProvider  <#PreviewParameterProvider>`__
   and returns the sample data as a sequence.

   .. code:: prettyprint

      class UserPreviewParameterProvider : PreviewParameterProvider<User> {
          override val values = sequenceOf(
              User("Elise"),
              User("Frank"),
              User("Julia")
          )
      }AndroidStudioComposeSnippets.kt

   This renders one preview per data element in the sequence:

   |Previews showing Elise, Frank and Julia composables|

   You can use the same provider class for multiple previews. If necessary,
   limit the number of previews by setting the limit parameter.

   .. code:: prettyprint

      @Preview
      @Composable
      fun UserProfilePreview2(
          @PreviewParameter(UserPreviewParameterProvider::class, limit = 2) user: User
      ) {
          UserProfile(user)
      }AndroidStudioComposeSnippets.kt

   .. rubric:: Limitations and best practices
      :name: best-practices

   Android Studio executes previews code directly in the preview area. It
   doesn't require running an emulator or physical device because it leverages a
   ported part of the Android framework called ``Layoutlib``. ``Layoutlib`` is a
   custom version of the Android framework designed to run outside of Android
   devices. The goal of the library is to provide a preview of a layout in
   Android Studio that is very close to its rendering on devices.

   .. rubric:: Previews limitations
      :name: preview-limitations

   Because of the way previews are rendered within Android Studio, they are
   lightweight and don't require the whole Android framework to render them.
   However, this comes with the following limitations:

   -  No network access
   -  No file access
   -  Some ``Context`` APIs may not be fully available

   .. rubric:: Previews and ``ViewModels``
      :name: preview-viewmodel

   Previews are limited when using `ViewModel  <https://developer.android.google.cn/viewmodel>`__ within a
   composable. The previews system is not capable of constructing all of the
   parameters passed to a ``ViewModel``, such as repositories, use cases,
   managers, or similar. Also, if your ``ViewModel`` participates in dependency
   injection (such as with
   `Hilt  <#hilt-android>`__), the previews system
   can't build the whole dependency graph to construct the ``ViewModel``.

   When you try to preview a composable with ``ViewModel``, Android Studio shows
   an error when rendering the particular composable:

   |Android studio problem pane with Failed to instantiate a \`ViewModel\`
   message|

   **Warning:**\  You shouldn't pass the ``ViewModel`` instances down to other
   composable functions. When you do this, you're coupling the composables with
   the ``ViewModel`` type, which makes them less reusable, harder to test, and
   unable to preview.
   If you want to preview a composable that uses a ``ViewModel``, you should
   create another composable with the parameters from ``ViewModel`` passed as
   arguments of the composable. This way, you don't need to preview the
   composable that uses the ``ViewModel``.

   .. code:: prettyprint

      @Composable
      fun AuthorColumn(viewModel: AuthorViewModel = viewModel()) {
        AuthorColumn(
          name = viewModel.authorName,
          // ViewModel sends the network requests and makes posts available as a state
          posts = viewModel.posts
        )
      }

      @Preview
      @Composable
      fun AuthorScreenPreview(
        // You can use some sample data to preview your composable without the need to construct the ViewModel
        name: String = sampleAuthor.name,
        posts: List<Post> = samplePosts[sampleAuthor]
      ) {
        AuthorColumn(...) {
          name = NameLabel(name),
          posts = PostsList(posts)
        }
      }

   .. rubric:: Annotation class ``@Preview``
      :name: preview-class

   You can always 'ctrl or ⌘ + click' the ``@Preview`` annotation in Android
   Studio for a full list of parameters that can be adjusted when customizing
   your preview.

   .. code:: prettyprint

      annotation class Preview(
          val name: String = "",
          val group: String = "",
          @IntRange(from = 1) val apiLevel: Int = -1,
          val widthDp: Int = -1,
          val heightDp: Int = -1,
          val locale: String = "",
          @FloatRange(from = 0.01) val fontScale: Float = 1f,
          val showSystemUi: Boolean = false,
          val showBackground: Boolean = false,
          val backgroundColor: Long = 0,
          @UiMode val uiMode: Int = 0,
          @Device val device: String = Devices.DEFAULT,
          @Wallpaper val wallpaper: Int = Wallpapers.NONE,
      )AndroidStudioComposeSnippets.kt

   .. rubric:: Additional resources
      :name: preview-resources

   To read more about how Android Studio promotes ``@Preview`` ease of use, and
   learn more Tooling tips, check out the blog `Compose Tooling <https://medium.com/androiddevelopers/compose-tooling-42621bd8719b>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Locally scoped data with CompositionLocal  <#compositionlocal>`__
   -  `Material Design 2 in Compose  <#material>`__
   -  `Using Views in Compose  <#views-in-compose>`__

Last updated 2024-05-03 UTC.

.. |A simple text element containing the words "Hello World"| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-hello-world.png
.. |A gif showing real time updates using Compose Preview| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-preview-live-edit.gif
   :width: 100.0%
.. |A yellow square with the words "Hello World"| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-square-preview.png
.. |Sample Composable function| image:: https://developer.android.google.cn/static/develop/ui/compose/images/preview-devicespec-sample-function.png
.. |Editing the sample function| image:: https://developer.android.google.cn/static/develop/ui/compose/images/preview-devicespec-edit-sample-function.png
.. |Spec list| image:: https://developer.android.google.cn/static/develop/ui/compose/images/preview-devicespec-spec-list.png
   :width: 400px
.. |Example of invalid value| image:: https://developer.android.google.cn/static/develop/ui/compose/images/preview-devicespec-gibberish.png
.. |A simple text element containing the word "Bonjour" with a French flag| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-locale-preview.png
.. |A green rectangle with the words "Hello World"| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-background-preview.png
.. |Compose preview UI| image:: https://developer.android.google.cn/static/studio/images/profile/compose-preview-ui.png
.. |The user clicking the preview's "interactive" button| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-start-interactive.png
   :width: 400px
.. |A video of the user interacting with a preview| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-interactive-preview-demo.gif
.. |The user hovering over a preview, causing Studio to display the outlines of its composables| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-preview-code-nav.png
   :width: 400px
.. |Run Preview icon| image:: https://developer.android.google.cn/static/studio/images/buttons/deploy-to-device-icon.png
.. |The user clicking the preview's "run preview" button| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling/run_preview.png
   :width: 600px
.. |Video of the user deploying a preview to the device| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-deploy-preview-demo.gif
   :width: 100.0%
.. |The user clicking on a preview to copy it as an image.| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-copy-render.png
   :width: 400px
.. |Previewing different fonts and screen sizes using templates| image:: https://developer.android.google.cn/static/studio/images/design/multipreview-template.png
.. |Android Studio design tab showing the composable with small and large font| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling/preview-multipreview-1.png
   :width: 400px
.. |Android Studio design tab showing the composable in all configurations| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling/preview-multipreview-2.png
   :width: 400px
.. |Previews showing Elise, Frank and Julia composables| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-preview-sequence.png
   :width: 100.0%
.. |Android studio problem pane with Failed to instantiate a \`ViewModel\` message| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling/viewmodel_failed.png
   :width: 100.0%

/Preview and debug animations
=============================

.. https://developer.android.google.cn/develop/ui/compose/tooling/animation-preview?hl=en

.. container:: devsite-article-body clearfix

   Android Studio allows you to inspect animations from Animation Preview. If an
   animation is described in a composable preview, you can inspect the exact
   value of each animated value at a given time, pause the animation, loop it,
   fast-forward it, or slow it, to help you debug the animation throughout its
   transitions:

   |Play back, scrub through, and slow down the AnimatedVisibility|

   You can also use Animation Preview to graph visualize animation curves, which
   is useful for making sure that the animation values are choreographed
   properly:

   |Visualization of an animation curve|

   Animation Preview automatically detects inspectable animations, which are
   indicated by the **Start Animation Preview** icon |Run icon|.

   |Start Animation Preview icon in Design window|

   If you have multiple animations, you can use Animation Preview to inspect and
   coordinate them all at once. You can also freeze a specific animation.

   |Gif showing inspection with All Animations UI|

   Use pickers to set non-enum or boolean states to debug your Compose animation
   using precise inputs. For all supported Compose Animation APIs, you can play,
   pause, scrub, control speed, and coordinate.

   |Pick precise values for animation previews|

   Animation Preview currently supports the
   `updateTransition  <#updateTransition>`__,
   `AnimatedVisibility  <#AnimatedVisibility>`__,
   `animate*AsState  <#animate-as-state>`__,
   `CrossFade  <#crossfade>`__,
   `rememberInfiniteTransition  <#rememberinfinitetransition>`__,
   and `AnimatedContent  <#animatedcontent>`__
   APIs. To access the latest features, use Animation Preview with Android
   Studio Jellyfish and ``compose.animation`` 1.6.7 and higher.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Animations in Compose  <#introduction>`__
   -  `Animation tooling support {:#tooling}  <#tooling>`__
   -  `Value-based animations  <#value-based>`__

Last updated 2024-05-03 UTC.

.. |Play back, scrub through, and slow down the AnimatedVisibility| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-preview.gif
.. |Visualization of an animation curve| image:: https://developer.android.google.cn/static/develop/ui/compose/images/animation-preview-curve.gif
.. |Run icon| image:: https://developer.android.google.cn/static/develop/ui/compose/images/start-animation-inspection-icon.png
.. |Start Animation Preview icon in Design window| image:: https://developer.android.google.cn/static/develop/ui/compose/images/start-animation-inspection-highlight.png
.. |Gif showing inspection with All Animations UI| image:: https://developer.android.google.cn/static/studio/images/releases/compose-animation-coordination.gif
.. |Pick precise values for animation previews| image:: https://developer.android.google.cn/static/studio/images/compose-animation-preview-picker.gif

/Develop code iteratively
=========================

.. https://developer.android.google.cn/develop/ui/compose/tooling/iterative-development?hl=en

.. container:: devsite-article-body clearfix

   As a mobile developer, you're often developing your app's UI step by step
   rather than developing everything at once. Android Studio embraces this
   approach with Jetpack Compose by providing tools that don't require a full
   build to inspect, modify values, and verify the final result.

   .. rubric:: Live Edit
      :name: live-edit

   **Important:**\  This feature is in active development, so you might
   experience some unstable behavior. In Android Studio Giraffe and higher it
   requires Jetpack Compose Runtime 1.3.0 or higher and AGP 8.1 or higher.
   Google is continuously working to improve this feature and welcomes your
   feedback. If you find an issue, `please report it <https://issuetracker.google.com/issues/new?component=192708&template=840533>`__.
   Include information from Logcat and a description of the code change you were
   making. You can also check the `list of open issues <https://issuetracker.google.com/issues?q=status:open%20componentid:1189787&s=created_time:desc>`__.
   Live Edit is a feature that lets you update composables in emulators and
   physical devices in real time. This functionality minimizes context switches
   between writing and building your app, letting you focus on writing code
   longer without interruption.

   Live Edit has three modes:

   -  Manual: Code changes are applied when they're manually pushed using
      Control+\\ (Command+\\ on macOS)
   -  Manual on Save: Code changes are applied when they're manually saved using
      Control+S (Command+S on macOS).
   -  Automatic: Changes are applied in your device or emulator when you update
      a composable function.

   Live Edit is focused on UI- and UX-related code changes. Live Edit doesn't
   support changes such as method signature updates, adding new methods, or
   class hierarchy changes. For more information, see the list of `Limitations of Live Edit <#limitations>`__.

   This feature is not a replacement for building and running your app or for
   `Apply Changes <#apply-changes>`__. Instead, it's designed to optimize your
   workflow as you build, deploy, and iterate to develop Compose UI.

   The best practice workflow is as follows:

   #. Set up your application so that it can be run.
   #. Live Edit as much as possible until you need to make a change that Live
      Edit doesn't support, such as adding new methods while the app is running.
   #. After you make an unsupported change, click **Run** |Run icon| to restart
      your app and resume Live Edit.

   .. rubric:: Get started with Live Edit
      :name: live-edit-quickstart

   To get started, follow these steps to create an empty Compose Activity,
   enable Live Edit for your project, and make changes with Live Edit.

   .. rubric:: Set up your new project
      :name: set_up_your_new_project

   #. Before you begin, make sure that you have Android Studio Giraffe or higher
      installed and that the API level of your physical device or emulator is at
      least 30.

   #. Open Android Studio and select **New Project** in the **Welcome to Android
      Studio** dialog. If you already have a project open, you can create a new
      one by navigating to **File** > **New** > **New Project**.

   #. Choose the **Empty Compose Activity** template for **Phone and Tablet**,
      and then click **Next**.

      .. figure:: https://developer.android.google.cn/static/studio/images/run/empty-compose-activity.png
         :alt: Template selection in Android Studio

         **Figure 1.** Templates you can choose from. For Live Edit, choose
         **Empty Compose Activity**.

   #. Complete the **New Project** dialog with the required information: name,
      package name, save location, minimum SDK, and build configuration
      language.

      .. figure:: https://developer.android.google.cn/static/studio/images/run/example-project-settings.png
         :alt: Example project settings from Step 4 entered in Android Studio

         **Figure 2.** Example project settings.

   #. Click **Finish**.

   .. rubric:: Enable Live Edit
      :name: enable_live_edit

   #. Navigate to the settings to enable Live Edit.

      -  On Windows or Linux, navigate to **File** > **Settings** > **Editor** >
         **Live Edit**.
      -  On macOS, navigate to **Android Studio** > **Settings** > **Editor** >
         **Live Edit**.

   #. Select the **Live Edit** option and the mode you want to run from the
      settings.

      In manual mode, your code changes are pushed every time you press
      Control+\\ (Command+\\ on macOS). In manual mode on save, your code
      changes are applied every time you manually save, using Control+S
      (Command+S on macOS). In automatic mode, your code changes are applied in
      your device or emulator as you make your changes.

      .. figure:: https://developer.android.google.cn/static/studio/images/run/live-edit-settings.png
         :alt: Live Edit checkbox UI in Android Studio settings

         **Figure 3.** Live Edit settings.

   #. In the editor, open the ``MainActivity`` file, which is the entry point
      for your app.

   #. Click **Run** |UI button| to deploy your app.

   #. After you turn on Live Edit, the **Up-to-date** green checkmark appears in
      the top right of the **Running Devices** tool window:

      |Live Edit green checkmark UI|

   .. rubric:: Make and review changes
      :name: make_and_review_changes

   As you make supported changes in the editor, the virtual or physical test
   device updates automatically.

   For example, edit the existing ``Greeting`` method in ``MainActivity`` to the
   following:

   .. code:: prettyprint

      @Composable
      fun Greeting(name: String) {
          Text(
              text = "Hello $name!",
              Modifier
                  .padding(80.dp) // Outer padding; outside background
                  .background(color = Color.Cyan) // Solid element background color
                  .padding(16.dp) // Inner padding; inside background, around text)
          )
      }IterativeDevelopmentSnippets.kt

   Your changes appear instantaneously on the test device, as shown in figure 4.

   .. figure:: https://developer.android.google.cn/static/studio/images/run/device-le-example.png
      :alt: Changes to Greeting method applied on a device

      **Figure 4.** Test device displaying Live Edit changes to the ``Greeting``
      method.

   .. rubric:: Troubleshoot Live Edit
      :name: troubleshoot

   If you don't see your edits on the test device, Android Studio might have
   failed to update your edits. Check whether the Live Edit indicator says **Out
   Of Date** as shown in figure 5, which indicates a compilation error. For
   information about the error and suggestions for how to resolve it, click the
   indicator.

   .. figure:: https://developer.android.google.cn/static/studio/images/run/live-edit-out-of-date.png
      :alt: Live Edit out of date icon

      **Figure 5.** Live Edit status indicator.

   .. rubric:: Limitations of Live Edit
      :name: limitations

   The following is a list of current limitations.

   -  [Only applies to Android Studio Giraffe and higher] Live Edit requires
      `Compose Runtime 1.3.0 or higher  <#bom-mapping>`__.
      If your project uses a lower version of Compose, Live Edit is disabled.

   -  [Only applies to Android Studio Giraffe and higher] Live Edit requires AGP
      8.1 or higher. If your project uses a lower version of AGP, Live Edit is
      disabled.

   -  Live Edit requires a physical device or emulator that is running API level
      30 or higher.

   -  Live Edit only supports editing a function body, which means that you
      can't change the function name or the signature, add or remove a function,
      or change non-function fields.

   -  Live Edit resets the app's state the first time you change a Compose
      function in a file. This only happens after the first code change—the app
      state isn't reset by subsequent code changes you make to Compose functions
      in that file.

   -  Live Edit-modified classes might incur some performance penalty. Run your
      app and use a clean release build if you are `evaluating its performance <https://developer.android.google.cn/studio/profile/measuring-performance>`__.

   -  You must perform a full run for the debugger to operate on classes that
      you have modified with Live Edit.

   -  A running app might crash when you edit it with Live Edit. If this
      happens, you can redeploy the app with the **Run** |UI button| button.

   -  Live Edit doesn't perform any bytecode manipulation that's defined in your
      project's build file—for example, bytecode manipulation that would be
      applied when the project is built using the options in the **Build** menu
      or by clicking the **Build** or **Run** buttons.

   -  Non-Composable functions are updated live on the device or emulator, and a
      full recomposition is triggered. The full recomposition might not invoke
      the updated function. For non-composable functions, you must trigger the
      newly updated functions or run the app again.

   -  Live Edit doesn't resume on app restarts. You must run the app again.

   -  Live Edit only supports debuggable processes.

   -  Live Edit does not support projects that use custom values for
      ``moduleName`` under ``kotlinOptions`` in build configuration.

   -  Live Edit doesn't work with multi-deploy deployments. This means that you
      can't deploy to one device, and then to another. Live Edit is only active
      on the last set of devices the app was deployed to.

   -  Live Edit works with multidevice deployments (deployments to multiple
      devices that were created through **Select multiple devices** in the
      target device dropdown). However, it's not officially supported and there
      might be issues. If you experience issues, `please report them <https://issuetracker.google.com/issues/new?component=192708&template=840533>`__.

   -  Apply Changes/Apply Code Changes are not compatible with Live Edit and
      require the running app to be restarted.

   .. rubric:: Frequently asked questions about Live Edit
      :name: faq

   -  **What is the current status of Live Edit?**

      Live Edit is available in Android Studio Giraffe. To turn it on, navigate
      to **File** > **Settings** > **Editor** > **Live Edit** (**Android
      Studio** > **Settings** > **Editor** > **Live Edit** on macOS).

   -  **When should I use Live Edit?**

      Use Live Edit when you want to quickly see the effect of updates to UX
      elements (such as modifier updates and animations) on the overall app
      experience.

   -  **When should I avoid using Live Edit?**

      Live Edit is focused on UI- and UX-related code changes. It doesn't
      support changes such as method signature updates, adding new methods, or
      class hierarchy changes. For more information, see `Limitations of Live Edit <#limitations>`__.

   -  **When should I use Compose Preview?**

      Use Compose Preview when you're developing individual composables. Preview
      visualizes Compose elements and automatically refreshes to display the
      effect of code changes. Preview also supports viewing UI elements under
      different configurations and states, such as dark theme, locales, and font
      scale.

   .. rubric:: Live Edit of literals (deprecated)
      :name: live-edit-literals

   **Deprecated:**\  Live Edit of literals, an earlier version of Live Edit that
   is limited to just a few supported types, is deprecated. We recommend using
   `Live Edit <#live-edit>`__ instead.
   Android Studio can update in real time some constant literals used in
   composables within previews, emulator, and physical device. Here are some
   supported types:

   -  ``Int``
   -  ``String``
   -  ``Color``
   -  ``Dp``
   -  ``Boolean``

   |Video of the user changing literals in the source code, and the preview
   updating dynamically|

   You can view constant literals that trigger real time updates without the
   compilation step by enabling literal decorations through the Live Edit of
   literals UI indicator:

   |Enabling Live Editing of Literals|

   **Note:**\  The Live Edit of literals UI indicator is be displayed next to
   **Code/Split/Design** as long as there is an active connection to the running
   app on an emulator or physical device.

   .. rubric:: Apply Changes
      :name: apply-changes

   `Apply Changes  <#use-apply-changes>`__ lets you update code and
   resources without having to redeploy your app to an emulator or physical
   device (with some `limitations  <#apply-changes-limitations>`__).

   Whenever you add, modify, or delete composables, you can update your app
   without having to redeploy it by clicking on the **Apply Code Changes**
   button:

   |User clicking the "apply changes" button|

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Customize animations {:#customize-animations}  <#customize>`__
   -  `Value-based animations  <#value-based>`__
   -  `Add parameters  <#add-parameters>`__

Last updated 2024-05-03 UTC.

.. |Run icon| image:: https://developer.android.google.cn/static/studio/images/buttons/toolbar-run.png
.. |UI button| image:: https://developer.android.google.cn/static/studio/images/buttons/toolbar-run-darkmode.png
.. |Live Edit green checkmark UI| image:: https://developer.android.google.cn/static/studio/images/run/live-edit-on.png
.. |UI button| image:: https://developer.android.google.cn/static/studio/images/buttons/toolbar-run-darkmode.png
.. |Video of the user changing literals in the source code, and the preview updating dynamically| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-live-literals-demo.gif
   :width: 100.0%
.. |Enabling Live Editing of Literals| image:: https://developer.android.google.cn/static/develop/ui/compose/images/live-editing-of-literals.gif
   :width: 100.0%
.. |User clicking the "apply changes" button| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-apply-changes.png

/Editor actions
===============

.. https://developer.android.google.cn/develop/ui/compose/tooling/editor-actions?hl=en

.. container:: devsite-article-body clearfix

   Android Studio has features inside the editor area to improve your
   productivity with Jetpack Compose.

   .. rubric:: Live templates
      :name: live-templates

   Android Studio comes with these Compose-related live templates, which allow
   you to enter code snippets for fast insertion by typing the corresponding
   template abbreviation:

   -  ``comp`` to set up a ``@Composable`` function
   -  ``prev`` to create a ``@Preview`` composable function
   -  ``paddp`` to add a ``padding`` Modifier in dp
   -  ``weight`` to add a ``weight`` Modifier
   -  ``W``, ``WR``, ``WC`` to surround the current composable with a ``Box``,
      ``Row``, or ``Column``\ container

   .. rubric:: Gutter icons
      :name: gutter-icons

   Gutter icons are contextual actions visible on the sidebar, next to the line
   numbers. Android Studio introduces several gutter icons specific to Jetpack
   Compose to ease your developer experience.

   .. rubric:: Deploy preview
      :name: gutter-deploy-preview

   You can deploy a ``@Preview`` to the emulator or physical device directly
   from the gutter icon:

   |The user clicking a preview function's deploy gutter icon, and deploying the
   preview to the device|

   .. rubric:: Color picker
      :name: color-picker

   Whenever a color is defined inside or outside a composable, its preview is
   shown on the gutter. You can change the color via the color picker by
   clicking on it like this:

   |The user clicking a color in the gutter, bringing up a color picker|

   .. rubric:: Image resource picker
      :name: image-resource-picker

   Whenever a drawable, vector, or image is defined inside or outside a
   composable, its preview is shown on the gutter. You can change it via the
   image resource picker by clicking on it like this:

   |The user clicking an icon in the gutter, bringing up the resource picker|

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Compose layout basics  <#basics>`__
   -  `Compose modifiers  <#modifiers>`__
   -  `Lists and grids  <#lists>`__

Last updated 2024-05-03 UTC.

.. |The user clicking a preview function's deploy gutter icon, and deploying the preview to the device| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-preview-deploy-gutter-icon.gif
   :width: 500px
.. |The user clicking a color in the gutter, bringing up a color picker| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-color-picker.gif
   :width: 500px
.. |The user clicking an icon in the gutter, bringing up the resource picker| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-resource-picker.gif
   :width: 500px

/Inspect your layout
====================

.. https://developer.android.google.cn/develop/ui/compose/tooling/layout-inspector?hl=en

.. container:: devsite-article-body clearfix

   Layout Inspector lets you inspect a Compose layout inside a running app in an
   emulator or physical device. You can use the Layout Inspector to check how
   often a composable is recomposed or skipped, which can help identify issues
   with your app. For example, some coding errors might force your UI to
   recompose excessively, which can cause `poor performance  <#performance>`__. Some coding errors can
   prevent your UI from recomposing and, therefore, prevent your UI changes from
   showing up on the screen. If you're new to Layout inspector, check the
   `guidance  <#layout-inspector>`__ on how to run it.

   **Note:**\  If you're not seeing Compose components in layout inspector, make
   sure you are not removing ``META-INF/androidx.compose.*.version`` files from
   the APK. These are required for layout inspector to work.

   .. rubric:: Get recomposition counts
      :name: recomposition-counts

   When debugging your Compose layouts, knowing when composables
   `recompose  <#recomposition>`__ is important
   in understanding whether your UI is implemented properly. For example, if
   it's recomposing too many times, your app might be doing more work than is
   necessary. On the other hand, components that don't recompose when you
   anticipate them to can lead to unexpected behaviors.

   The Layout Inspector shows you when discrete composables in your layout
   hierarchy have either recomposed or skipped, as you interact with your app.
   In Android Studio Jellyfish, your recompositions are highlighted to help you
   determine where in the UI your composables are recomposing.

   |Recomposition rendering highlights|

   **Figure 1.** Recompositions are highlighted in Layout Inspector.

   The highlighted portion shows a gradient overlay of the composable in the
   image section of the Layout Inspector, and gradually disappears so that you
   can get an idea of where in the UI the composable with the highest
   recompositions can be found. If one composable is recomposing at a higher
   rate than another composable, then the first composable receives a stronger
   gradient overlay color. If you double-click a composable in the layout
   inspector, you're taken to the corresponding code for analysis.

   **Note:**\  To view recomposition counts, make sure your app is using an API
   level of 29 or higher, and ``Compose 1.2.0`` or higher. Then, deploy your app
   as you normally would.
   |Recomposition counts shown in layout inspector|

   **Figure 2**. The composition and skip counter in Layout Inspector.

   Open the **Layout Inspector** window and connect to your app process. In the
   **Component Tree**, there are two columns that appear next to the layout
   hierarchy. The first column shows the number of compositions for each node
   and the second column displays the number of skips for each node. Selecting a
   composable node shows the dimensions and parameters of the composable, unless
   it's an inline function, in which case the parameters can't be shown. You can
   also see similar information in the **Attributes** pane when you select a
   composable from the **Component Tree** or the **Layout Display**.

   Resetting the count can help you understand recompositions or skips during a
   specific interaction with your app. If you want to reset the count, click
   **Reset** near the top of the **Component Tree** pane.

   **Note:**\  If you don't see the new columns in the **Component Tree** pane,
   you can view them by selecting **Show Recomposition Counts** from the **View
   Options** menu |Layout Inspector View Options icon| near the top of the
   **Component Tree** pane, as shown in the following image.
   |Enable the composition and skip counter in Layout Inspector|

   **Figure 3**. Enable the composition and skip counter in Layout Inspector.

   .. rubric:: Compose semantics
      :name: compose-semantics

   In Compose, `Semantics  <#semantics>`__ describe your UI in
   an alternative manner that is understandable for
   `Accessibility  <#accessibility>`__ services and for the
   `Testing  <#testing>`__ framework. You can use the Layout
   Inspector to inspect semantic information in your Compose layouts.

   |Semantic information displayed using the Layout Inspector|

   **Figure 4**. Semantic information displayed using the Layout Inspector.

   When selecting a Compose node, use the **Attributes** pane to check whether
   it declares semantic information directly, merges semantics from its
   children, or both. To quickly identify which nodes include semantics, either
   declared or merged, use select the **View options** drop-down in the
   **Component Tree** pane and select **Highlight Semantics Layers**. This
   highlights only the nodes in the tree that include semantics, and you can use
   your keyboard to quickly navigate between them.

Last updated 2024-05-03 UTC.

.. |Recomposition rendering highlights| image:: https://developer.android.google.cn/static/studio/images/debug/recomposition-rendering-highlights.gif
.. |Recomposition counts shown in layout inspector| image:: https://developer.android.google.cn/static/develop/ui/compose/images/tooling-layout-inspector-recomposition-counts.png
.. |Layout Inspector View Options icon| image:: https://developer.android.google.cn/static/studio/images/buttons/live-layout-inspector-view-options-icon.png
.. |Enable the composition and skip counter in Layout Inspector| image:: https://developer.android.google.cn/static/studio/images/debug/li-show-recomposition-counts.png
.. |Semantic information displayed using the Layout Inspector| image:: https://developer.android.google.cn/static/studio/images/debug/li-semantic-info.png

/Trace app performance
======================

.. https://developer.android.google.cn/develop/ui/compose/tooling/tracing?hl=en

.. container:: devsite-article-body clearfix

   Traces are often the best source of information when first looking into a
   performance issue. They allow you to form a hypothesis of what the issue is
   and where to start looking.

   There are two levels of tracing supported on Android: system tracing and
   method tracing.

   Because system tracing only tracks areas specifically marked for tracing, it
   has low overhead and doesn't affect the performance of your app greatly.
   System tracing is great for seeing how long particular sections of your code
   are taking to run.

   Method tracing tracks every function call in your app. This is very expensive
   and so it greatly affects the performance of your app, but it gives you a
   total picture of what is happening, what functions are being called, and how
   often they are being called.

   By default, system traces **do not** include individual composable functions.
   They are available in method traces.

   We are currently testing new system tracing functionality to show composable
   functions inside system traces. It gives you the low intrusiveness from
   system tracing, with method tracing levels of detail in composition.

   .. rubric:: Set up for composition tracing
      :name: set-composition

   To try out the recomposition tracing in your project, you need to update to
   at least the following versions:

   -  Android Studio Flamingo
   -  Compose UI: 1.3.0
   -  Compose Compiler: 1.3.0

   The device or emulator you run your trace on must also be at minimum API
   level 30.

   Additionally, you need to add a new dependency on Compose Runtime Tracing:

   .. code:: prettyprint

      implementation("androidx.compose.runtime:runtime-tracing:1.0.0-beta01")

   With this dependency, when you take a system trace that includes
   recomposition, you can see the composable functions automatically.

   .. rubric:: Take a system trace
      :name: take-system

   To take a system trace and see the new recomposition tracing in action,
   follow these steps:

   #. Open the profiler:

      .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/performance/tracing-1.png
         name: image-2
         :alt: Android Studio - Start Profiling
         :width: 100.0%

         **Figure 2**. Android Studio - Start Profiling

   #. Click **CPU timeline**

      .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/performance/tracing-2.png
         name: image-3
         :alt: Android Studio Profiler - CPU timeline
         :width: 100.0%

         **Figure 3**. Android Studio Profiler - CPU timeline

   #. Navigate your app to the UI you want to trace and then select **System
      Trace** and **Record**

      .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/performance/tracing-3.png
         name: image-4
         :alt: Trace options - System trace
         :width: 100.0%

         **Figure 4**. Trace options - System trace

   #. Use your app to cause recomposition and stop recording. Once the trace has
      been processed and appears, you should now be able to see the composables
      in the recomposition trace. You can use the keyboard and mouse to zoom and
      pan around the trace; if you are unfamiliar with navigating a trace, see
      the `Record traces  <#ui-shortcuts>`__
      documentation.

      .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/performance/tracing-4.png
         name: image-5
         :alt: System trace
         :width: 100.0%

         **Figure 5**. System trace

      Double-clicking on a composable in the chart takes you to its source code.

   #. You can also see composables in the Flame Chart along with the file and
      line number:

      .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/performance/tracing-5.png
         name: image-6
         :alt: Flame chart
         :width: 100.0%

         **Figure 6**. Flame chart

   .. rubric:: Caveats
      :name: caveats

   .. rubric:: APK size overhead
      :name: apk_size_overhead

   While we aimed to minimize the overhead of the feature as much as possible,
   there is an APK size increase for Compose apps coming from tracing strings
   embedded in the APK by the Compose compiler. This size increase can be
   relatively small if your app isn't using much Compose or larger for full
   Compose apps. These tracing strings are additionally unobfuscated so they can
   appear in tracing tools, as shown earlier. The Compose compiler injects them
   into all apps, starting with version 1.3.0.

   The tracing strings can be removed in your production build by adding the
   following proguard rule:

   .. code:: prettyprint

      -assumenosideeffects public class androidx.compose.runtime.ComposerKt {

         boolean isTraceInProgress();

         void traceEventStart(int,int,int,java.lang.String);

         void traceEventStart(int,java.lang.String);

         void traceEventEnd();

      }

   These functions may change in the future, but any changes will be mentioned
   in the Compose `release notes  <#compose-compiler>`__.

   Note that keeping them in, while incurring some APK size cost, guarantees
   that the APK being profiled is the same one that the app users run.

   .. rubric:: Accurate timing
      :name: accurate_timing

   For accurate profiling, like with any performance testing, you need to make
   the app ``profileable`` and ``non-debuggable`` as per `Profileable applications  <#profileable-apps>`__.

   .. rubric:: Capture a trace from terminal
      :name: terminal

   It is possible to capture a composition trace from terminal. To do so, you
   have to perform the steps that Android Studio normally does for you
   automatically.

   .. rubric:: Add dependencies
      :name: terminal-dependencies

   First, add the additional dependencies to your app.

   .. code:: prettyprint

      implementation("androidx.tracing:tracing-perfetto:1.0.0")
      implementation("androidx.tracing:tracing-perfetto-binary:1.0.0")

   **Warning:**\  Don't ship ``androidx.tracing:tracing-perfetto-binary`` with
   your production app as it has a large effect on your app size.

   .. rubric:: Generate a record command
      :name: generate_a_record_command

   #. Generate a record command using in
      `Perfetto <https://ui.perfetto.dev/#!/record/instructions>`__.

   #. Manually add the ``track_event`` data source section as per following
      example:

      .. code:: prettyprint

         adb shell perfetto \
           -c - --txt \
           -o /data/misc/perfetto-traces/trace \
         <<EOF
         buffers: {
             size_kb: 63488
             fill_policy: RING_BUFFER
         }
         buffers: {
             size_kb: 2048
             fill_policy: RING_BUFFER
         }
         data_sources: {
             config {
                 name: "track_event"
             }
         }
         duration_ms: 10000
         flush_period_ms: 30000
         incremental_state_config {
             clear_period_ms: 5000
         }
         EOF

   .. rubric:: Capture a trace
      :name: capture_a_trace

   #. Launch the app and prepare the section you want to trace.

   #. Enable tracing in the app by issuing a broadcast.

      .. code:: prettyprint

         # set app package variable, e.g. com.google.samples.apps.nowinandroid.debug
         # can be found through `adb shell ps -ef` or `adb shell cmd package list packages`
         package=<your app process>

         # issue a broadcast to enable tracing
         adb shell am broadcast \
         -a androidx.tracing.perfetto.action.ENABLE_TRACING \
         $package/androidx.tracing.perfetto.TracingReceiver

   #. Start your recording command you created previously.

   .. rubric:: Open the trace
      :name: open_the_trace

   #. ``adb pull <location>`` the trace from the device (location specified in
      the record command).

   #. Open in `Perfetto <https://ui.perfetto.dev>`__.

   .. rubric:: Capture a trace with Jetpack Macrobenchmark
      :name: macrobenchmark

   You can measure performance with `Jetpack Macrobenchmark  <https://developer.android.google.cn/macrobenchmark>`__, which provides traces as results. To
   enable composition tracing with macrobenchmarks, you need to:

   #. Add these additional dependencies to the **Macrobenchmark** test module:

      .. code:: prettyprint

         implementation("androidx.tracing:tracing-perfetto:1.0.0")
         implementation("androidx.tracing:tracing-perfetto-binary:1.0.0")

   #. Add ``androidx.benchmark.fullTracing.enable=true`` instrumentation
      argument before running benchmarks. Check `Macrobenchmark instrumentation arguments  <#fulltracing>`__
      for more information about Macrobenchmark instrumentation arguments.

   .. rubric:: Feedback
      :name: feedback

   We would love to hear your feedback on this feature, any bugs you find with
   it, and any requests you have. You can send us feedback via `the issue tracker <https://issuetracker.google.com/issues/new?component=898851&template=1458540>`__.

Last updated 2024-05-03 UTC.

/Overview: Relay designer and developer tooling
===============================================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay?hl=en

.. container:: devsite-article-body clearfix

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/relay/relay-banner-image.png
      name: image-1
      :alt: Relay banner image
      :width: 100.0%

   Relay provides instant handoff of Android UI components between designers and
   developers.

   Designers use the Relay for Figma plugin to annotate and package UI
   components for developer use, including information about layout, styling,
   dynamic content and interaction behavior.

   Developers use the Relay for Android Studio plugin to import UI Packages and
   generate pixel-perfect Jetpack Compose code. This process provides instant
   layout and styling implementation, and speeds up the process of binding data.
   UI Packages can include styles and themes, and reference design system
   components that exist in code.

   Relay removes the need for tedious design specification and comm loops for
   small details. As your product evolves, UI Packages can be updated, extended,
   and adopted incrementally throughout your codebase.

   You first create an UI Package using the `Relay for Figma plugin <https://www.figma.com/community/plugin/1041056822461507786>`__, After
   creating the UI package, you then convert the UI Package to Jetpack Compose
   code using the `Relay for Android Studio plugin <https://plugins.jetbrains.com/plugin/19721>`__.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/relay/relay-for-figma-and-android.png
      name: image-2
      :alt: Relay for Figma and Relay for Android Studio
      :width: 100.0%

   With the Relay for Figma plugin, designers and developers can work together
   to add `content parameters and interaction handlers  <#add-parameters>`__ to capture the
   dynamic elements in design and generate corresponding parameters in
   Composable functions.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/relay/creating-parameters.png
      name: image-3
      :alt: Parameters added in Figma plugin become parameters in Composable
      function
      :width: 100.0%

   The Relay team is developing support for Material Design and other custom
   design systems. Currently, we support two experimental features to help you
   map between your design system and Compose implementation: `Figma style mapping  <#mapping-styles-to-compose-theme>`__
   and `Figma component mapping  <#mapping-components-to-existing-code>`__.

   Relay is currently an alpha product, and we’d love for you to use it and tell
   us how it does and does not meet your needs. We’ll be making regular releases
   that include improvements to performance, functionality, and overall workflow
   based on your `feedback <https://goo.gle/relay-feedback>`__.

   .. rubric:: Next step
      :name: next-step

   The best way to get started with Relay is to work through a
   `tutorial  <#basic-tutorial>`__ to try out
   the full end-to-end workflow. Even though your day-to-day usage of Relay may
   only focus on part of the workflow, it’s helpful to understand how both
   designers and developers use Relay to create Android applications.

   `Install Relay  <#install-relay>`__ to get
   started!

Last updated 2024-03-25 UTC.

/Install Relay
==============

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/install-relay?hl=en

.. container:: devsite-article-body clearfix

   Relay consists of three parts, each of which must be installed separately:

   #. Relay for Figma Plugin
   #. Relay for Android Studio Plugin
   #. Relay Gradle Plugin

   .. rubric:: Prerequisites
      :name: prerequisites

   -  You must be signed into a `Figma Account <https://www.figma.com/signup>`__.
   -  You have installed `Android Studio  <https://developer.android.google.cn/studio>`__ 2022.2.1 Flamingo or
      later.
   -  You have installed the `Java Runtime <https://www.java.com/en/download/>`__.
   -  You are using Jetpack Compose version 1.2 or later.
   -  You are using Gradle Plugin version 8.0 or later.

   **Note:**\  This documentation is written based on Flamingo and the 8.0
   version of Android Gradle Plugin. The details may be slightly different for
   later versions.
   **Note:**\  We assume you have a Figma Professional or Figma Organization
   `license <https://www.figma.com/pricing/>`__. Some of our features utilize
   version history and team libraries, which may not be available in the Starter
   license.

   .. rubric:: Install the Relay for Figma plugin
      :name: install-relay

   The Relay for Figma plugin allows anyone working in Figma to annotate their
   designs and share it with developers who use Android Studio and Jetpack
   Compose.

   The Relay for Figma plugin is published to Figma's community plugin
   marketplace. To install the plugin:

   #. Go to the `Relay for Figma plugin page <https://www.figma.com/community/plugin/1041056822461507786>`__ on
      Figma's website.

   #. On the top right of the page, click **Try it out**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/install-relay/try-it-out.png
         name: image-1
         :alt: Try it out button on Figma plugin page
         :width: 40.0%

   #. You may encounter a dialog asking if you want to use the plugin. In the
      dialog, select your organization. In rare cases, your organization may
      disable public plugins. If so, then select the **External teams** option.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/install-relay/external-teams.png
         name: image-2
         :alt: External teams option in the dialog
         :width: 60.0%

      This opens a Figma file with the plugin information page displayed. Click
      **…** and select **Save** to ensure you can easily reuse the plugin.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/install-relay/save-option.png
         name: image-3
         :alt: Save option in the plugin information page
         :width: 40.0%

   #. Now, click **Run**:

      You can view the plugin running in the Figma canvas:

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/install-relay/relay-for-figma.png
         name: image-4
         :alt: Relay for Figma
         :width: 60.0%

   .. rubric:: Install the Relay for Android Studio plugin
      :name: install-relay

   The Relay for Android Studio plugin enables developers working in Android
   Studio to import designs that have been annotated with design intent
   information using the Relay for Figma plugin. The plugin is published to the
   Android Studio Plugin Marketplace. To install:

   **Note:**\  If this is your first time using Android Studio and you have not
   installed an Android SDK, or you see a welcome screen to setup an Android
   SDK, follow these steps to `setup your Android SDK  <#setup-sdk>`__.

   #. Open Android Studio.

   #. From the main menu:

      -  For macOS, select **Android Studio > Preferences**.
      -  For Windows and Linux, select **File > Settings**.

   #. Select **Plugins**.

   #. Select the Marketplace tab, search for: **“Relay for Android Studio”**,
      and select the plugin published by Google:

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/install-relay/relay-in-marketplace.png
         name: image-5
         :alt: Relay for Android Studio in the marketplace
         :width: 100.0%

   #. Click **Install**.

   #. When the installation is complete, click **Restart IDE**.

   #. To confirm that the installation succeeded, open **Preferences** or
      **Settings**, then go to **Plugins**. You should see **Relay for Android
      Studio** listed in the Installed section.

   .. rubric:: Install the Relay Gradle plugin
      :name: install-relay

   The Relay Gradle plugin ensures that designs in Figma annotated with design
   intent information using the Relay for Figma plugin are correctly converted
   to code during a build.

   The Relay Gradle plugin is published to Google Maven, a server that contains
   many Gradle plugins. Android Studio invokes Gradle operations by default, and
   those operations include downloading and installing any dependencies that
   your project references.

   To ensure that Android Studio, and by extension Gradle itself, downloads and
   installs the Relay Gradle plugin, you need to specify the plugin as a
   dependency in your project, specifically in the ``build.gradle`` file in your
   module’s directory. This is usually in ``app/build.gradle``.

   At the top of the ``app/build.gradle`` file is a section listing all of the
   plugins in use. Add the Relay Gradle plugin in this list, and Gradle handles
   downloading and installing it. For example:

   .. code:: prettyprint

      plugins {
          id 'com.android.application'
          id 'kotlin-android'
          id 'com.google.relay' version '0.3.12'
      }

   Also, make sure your ``settings.gradle`` file has the following section:

   .. code:: prettyprint

      pluginManagement {
          repositories {
              gradlePluginPortal()
              google()
              mavenCentral()
          }
      }

   **Note:**\  Use the latest version of the Relay Gradle plugin to get access
   to all the latest features.
   You can also use a `Pre-Configured Project <#download-and>`__, which includes
   the configuration noted above.

   .. rubric:: Setup Figma access
      :name: setup-figma

   Relay requires a **Figma personal access token** so that it can download your
   Figma designs and convert them to code. If you don’t already have one:

   #. Open Figma and log into Figma.

   #. Go to the file browser .

   #. Click your account icon and select **Settings**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/install-relay/settings.png
         name: image-6
         :alt: Settings under the account icon
         :width: 30.0%

   #. Scroll down to the **Personal access tokens** section.

   #. Enter a token description, for example, “Relay” and type Return. A token
      is generated. Click **Copy this token**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/install-relay/personal-access-tokens.png
         name: image-7
         :alt: Personal access tokens in the settings
         :width: 60.0%

   #. In Android Studio, from the main menu, select **Tools > Relay Settings**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/install-relay/setup-token-under-Tools.png
         name: image-8
         :alt: Relay settings menu option under Tools to setup Figma access
         token
         :width: 60.0%

   #. If you have previously set up a Figma access token on macOS, you may see
      the following dialog. This dialog lets you know that Android Studio is
      using your existing Figma access token. Enter your password, and click
      **Always Allow**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/install-relay/keychain-dialog.png
         name: image-9
         :alt: Keychain system dialog
         :width: 60.0%

   #. Paste your Figma access token into the **Figma Access Token** input. (If
      this is not your first time setting up a Figma access token, you may see
      an **Existing Figma Access Token** input.)

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/install-relay/new-token-input.png
         name: image-10
         :alt: Figma Access Token input
         :width: 40.0%

   #. Click **OK**.

   .. rubric:: Download and setup the pre-configured project
      :name: download-and

   **Note:**\  Steps in this section are optional, but highly recommended if you
   want to go through our tutorials. If you want to know how to manually create
   a Relay project for Android Studio instead of using the pre-configured
   project, see `Android Project Setup  <#android-project-setup>`__.
   To download and setup a pre-configured project:

   #. Download the `project ZIP file <https://relay.material.io/static/assets/tutorial-files/HelloFigma.zip>`__.
   #. Double-click the file to unzip it, which creates a folder called
      **HelloFigma**. Move it to your home folder..
   #. Go back to Android Studio. Go to **File > Open**, navigate to your home
      folder, select **HelloFigma**, and click **Open**.
   #. When you open the project, Android Studio may ask you if you trust the
      project. Click **Trust Project**.

   **Note:**\  This preconfigured project requires Android Studio Flamingo or
   later and Android Gradle Plugin 8.0. It also assumes use of Compose Material.
   If you want to use Compose Material 3, follow instructions
   `here  <#compose-material3>`__ to add the
   appropriate dependencies to your project.

   .. rubric:: Running the pre-configured project
      :name: running-pre-configured

   Run the app on an emulator or device. You should see "Hello, Android!" in a
   blank screen.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/install-relay/emulator.png
      name: image-11
      :alt: The starting state in the emulator
      :width: 30.0%

   .. rubric:: Next step
      :name: next-step

   Now we're ready to create our first designs using Relay.

   `Basic Tutorial  <#basic-tutorial>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Set up your Android project  <#android-project-setup>`__
   -  `Testing your Compose layout  <#testing>`__
   -  `Where to hoist state  <#state-hoisting>`__

Last updated 2024-04-30 UTC.

/Set up your Android project
============================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/android-project-setup?hl=en

.. container:: devsite-article-body clearfix

   **Note:**\  Instructions on this page are written for Android Studio Flamingo
   and may vary for later Android Studio versions.

   .. rubric:: Create a new Compose project
      :name: create-new

   Android Studio projects need configuration to work with Relay. To start,
   create a project that supports Jetpack Compose version 1.2 or newer.

   #. In Android Studio, create a new project (**File** > **New** > **New
      Project…**).

   #. Select **Empty Compose Activity** and click **Next**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/android-project-setup/new-project.png
         name: image-1
         :alt: Create new Compose project in Android Studio
         :width: 60.0%

   #. Give your project a name. Accept all other defaults, including the
      language as Kotlin and the minimum SDK as **API 21: Android 5.0
      (Lollipop)** and click **Finish**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/android-project-setup/new-project-name.png
         name: image-2
         :alt: Android Studio project configuration
         :width: 60.0%

   .. rubric:: Edit module-level Gradle build file
      :name: edit-module-level

   Set up the module-level Gradle build file to use the Relay Gradle plugin.

   #. Open ``build.gradle`` (Module: ``Hello_Figma.app`` — This can vary based
      on the name you entered above). This is the module-level Gradle build
      file.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/android-project-setup/app-gradle.png
         name: image-3
         :alt: Module-level Gradle file in the Android Studio
         :width: 40.0%

   #. Add the Relay plugin in the module's Gradle file as shown below, changing
      the version number as appropriate. Save the file.

      .. container::

         .. container:: ds-selector-tabs

            .. container:: section

               .. rubric:: Groovy
                  :name: groovy

               .. code:: prettyprint

                  plugins {
                    id 'com.android.application'
                    id 'kotlin-android'
                    id 'com.google.relay' version '0.3.12'
                  }

            .. container:: section

               .. rubric:: Kotlin
                  :name: kts

               .. code:: prettyprint

                  plugins {
                    id("com.android.application")
                    id("kotlin-android")
                    id("com.google.relay") version "0.3.12"
                  }

   #. Click **Sync Now**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/android-project-setup/grade-sync.png
         name: image-4
         :alt: Gradle Sync message in the Android Studio
         :width: 100.0%

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Testing your Compose layout  <#testing>`__
   -  `Where to hoist state  <#state-hoisting>`__
   -  `Resources in Compose  <#resources>`__

Last updated 2024-04-30 UTC.

/Overview: Basic tutorial
=========================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/basic-tutorial?hl=en

.. container:: devsite-article-body clearfix

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/basic-tutorial/card-component.png
      name: image-1
      :alt: Card component with image and title
      :width: 100.0%

   This basic tutorial shows you both the designer and developer workflow for
   Relay, providing a complete end-to-end first experience. After the Relay
   plugin setup, you can quickly get to the stage where you can see the UI
   appear in Android Studio. We encourage you to stick with it!

   The tutorial creates a basic card component in Figma, and imports it into
   Android Studio where you can view the generated code. You'll learn how to do
   the following:

   **In Figma:**

   #. Design a UI component in Figma.
   #. Create a UI Package using the Figma plugin.
   #. Save a named version of the design.
   #. Share the Figma URL with the developers.

   **In Android Studio:**

   #. Using the Figma URL, import the UI Package into a project.
   #. Generate Jetpack Compose code by building the project.
   #. Add a reference to the generated composable in the project’s UI code.
   #. Run the project.

   .. rubric:: Next step
      :name: next-step

   First, let's `make our design and create a UI Package in Figma  <#create-ui-package-in-figma>`__.

Last updated 2024-03-25 UTC.

/Create UI Package in Figma
===========================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/create-ui-package-in-figma?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: Download pre-configured Figma file
      :name: download-pre-configured

   Let's start by creating a component in Figma. For this tutorial we'll be
   using an existing Figma file to use as an example. This file contains an
   autolayout frame with an image and title. Make sure you are logged into your
   Figma account.

   #. Download this Figma file to your computer:
      `HelloFigma.fig <https://relay.material.io/static/assets/tutorial-files/HelloFigma.fig>`__.

   #. In Figma's file browser, hover over **Drafts**. A **+** icon appears.
      Click **+**, then **Import…**, and select the **HelloFigma.fig** file that
      you just downloaded.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/create-ui-package-in-figma/import.png
         name: image-1
         :width: 60.0%

   #. Open the imported file in Figma.

   .. rubric:: Create a component
      :name: create-component

   To use the imported design with the Relay for Figma plugin, we'll first need
   to convert it to a component. Select the **Hello Card** frame and from the
   toolbar, click **Create Component**.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/create-ui-package-in-figma/create-component.png
      name: image-2
      :alt: Create component icon in the toolbar
      :width: 100.0%

   .. rubric:: Create a UI Package
      :name: create-ui

   The Relay for Figma plugin adds extra information to the component so you can
   work with your developers who can use the component in their code.

   #. Open the Relay for Figma plugin in your file (In the Figma menu: **Plugins
      > Relay for Figma**). Click **Get Started**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/create-ui-package-in-figma/create-button.png
         name: image-3
         :alt: Create UI Package button in the plugin
         :width: 100.0%

   #. Select the component and click **Create UI Package**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/create-ui-package-in-figma/create-button-in-plugin.png
         name: image-4
         :alt: Create UI Package button in the plugin
         :width: 100.0%

   #. With the UI Package selected, add a description to **Summary**. For
      example: “Hello Card component used to display the image and title
      content”

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/create-ui-package-in-figma/summary.png
         name: image-5
         :alt: Summary box in the plugin
         :width: 100.0%

   #. Click **Share with developer** in the lower right hand corner of the
      dialog to move to the next screen.

   .. rubric:: Share with developer flow
      :name: share-with-developer

   Now that you have created a UI package, prepare your component to share it
   with the development team.

   Create a new named version of the file of the component file. Using named
   versions of the component prevents unwanted changes from affecting the
   production components.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/create-ui-package-in-figma/share-with-developer-dialog.png
      name: image-5
      :alt: Summary box in the plugin
      :width: 70.0%

   #. Enter a name and description for this first version of the component, then
      click **Save**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/create-ui-package-in-figma/share-with-developer-version.png
         name: image-6
         :alt: Summary box in the plugin
         :width: 40.0%

   #. Next, create a shareable component link and copy it to the clipboard by
      typing **CMD-L** on a Mac or **CTRL-L** on Windows.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/create-ui-package-in-figma/share-with-developer-share-link.png
         name: image-7
         :alt: Summary box in the plugin
         :width: 40.0%

   .. rubric:: Next step
      :name: next-step

   Now, you are ready to hand off your UI component to Android Studio.

   Open Android studio to complete the next part of this tutorial.

   `Convert the designs to code in Android Studio  <#convert-designs-android-studio>`__

Last updated 2024-03-25 UTC.

/Convert the designs to code in Android Studio
==============================================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/convert-designs-android-studio?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: Import design from Figma
      :name: import-design

   Now, we are going to incorporate the UI Package created in Figma into the
   Android Studio project. To incorporate the UI Package, copy the share URL
   that we generated in the previous section into Android Studio’s import
   wizard.

   #. Download the `pre-configured Android Studio project ZIP file <https://relay.material.io/static/assets/tutorial-files/HelloFigma.zip>`__
      (which is the same project as in the `Install Relay  <#download-and>`__
      page).

   #. Double-click the file to unzip it, which creates a folder called
      **HelloFigma**. Move it to your home folder..

   #. Go back to Android Studio. Go to **File > Open**, navigate to your home
      folder, select **HelloFigma**, and click **Open**.

   #. When you open the project, Android Studio may ask you if you trust the
      project. Click **Trust Project**.

   #. In Android Studio, select **File > New > Import UI Packages…**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/convert-designs-android-studio/import-action.png
         name: image-2
         :alt: Import UI Packages… option under the File menu
         :width: 100.0%

   #. In the Import UI Packages dialog, paste the URL of your Figma file and
      click **Next**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/convert-designs-android-studio/import-ui-package.png
         name: image-3
         :alt: Import UI Package dialog
         :width: 60.0%

      **Note:**\  If you don’t have your Figma URL, repeat the instructions for
      `getting the URL <#import-design>`__ and come back to this dialog.

      **Note:**\  If you see a keychain prompt, enter your password and click
      **Allow**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/convert-designs-android-studio/keychain-dialog.png
         name: image-4
         :alt: Keychain system dialog
         :width: 60.0%

      **Note:**\  If you instead see a dialog about Figma Access Token, proceed
      with the prompts or repeat instructions to `setup your Figma Access Token  <#setup-figma>`__.

   #. Wait for the file to download. When successfully downloaded, the component
      preview is displayed. Click **Create**.

      **Note:**\  The above button may say **Finish** instead of **Create**,
      depending on the version of Android Studio you are using.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/convert-designs-android-studio/preview-in-import-dialog.png
         name: image-5
         :alt: Preview of the component
         :width: 60.0%

      Notice that new files have been added to your project — these should be
      committed to source control as part of your project. In the Android view
      of your project, you’ll see:

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/convert-designs-android-studio/ui-packages-folder.png
         name: image-6
         :alt: UI-packages folder in the Android view
         :width: 40.0%

      -  | ``app/ui-packages/hello_card/*``
         | All source assets required to describe the component in code. These
           files are used for code generation in the build step.

      -  | ``app/ui-packages/hello_card/hello_card.json``
         | The JSON file which contains the definition of the component
           (including its layout and other properties).

      -  | ``app/ui-packages/hello_card/fonts/*``
         | Any font files required to support the component in Jetpack Compose.

      -  | ``app/ui-packages/hello_card/*.png`` or ``*.jpeg``
         | Any image assets required to support the component.

      -  | ``app/ui-packages/hello_card/VERSION.txt``
         | The version of the Relay for Android Studio plugin used to import the
           UI Package.

      -  | ``app/ui-packages/hello_card/config.json``
         | The theme used for previews.

   .. rubric:: Build & generate code
      :name: build-&

   #. Click on |Make Project button| to build your project.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/convert-designs-android-studio/build-button-in-toolbar.png
         name: image-7
         :alt: Make Project button in the toolbar
         :width: 60.0%

   #. To view the build result, click the **Build** tab.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/convert-designs-android-studio/build-tab-at-bottom.png
         name: image-8
         :alt: Build tab at bottom of the Android Studio
         :width: 60.0%

      **Note:**\  For build issues, see this page for `common troubleshooting  <#limitations-and-troubleshooting>`__.

   #. Generated code is now added to your project. Since this is generated code,
      it should not be committed to source control as part of your project. In
      the Android view of your project, you can view:

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/convert-designs-android-studio/generated-code.png
         name: image-9
         :alt: Generated code in the Android view
         :width: 40.0%

      -  | ``app/java (generated)/com/example/hellofigma/hellocard``
         | Generated Jetpack Compose code and fonts.

      -  | ``app/java (generated)/com/google/relay/compose``
         | Shared runtime code that is used across all UI Packages.

   #. Open
      ``app/java (generated)/com/example/hellofigma/hellocard/HelloCard.kt``.
      This is the generated Jetpack Compose function for the Figma component.
      You can also preview the component.

      The layout, assets, and styling information are now transferred from Figma
      to code.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/convert-designs-android-studio/preview.png
         name: image-10
         :alt: Preview of the component
         :width: 40.0%

      In the code, the summary added in Figma is now translated to a comment
      above the generated composable.

      .. code:: prettyprint

          /**
          * Hello Card component used to display the image and the title content
          *
          * This composable was generated from the UI package ‘ hello_card’
          * Generated code; do not edit directly
          */
         @Composable
         fun HelloCard(modifier: Modifier = Modifier) {...

   .. rubric:: Integrate component & run app
      :name: integrate-component

   Now, let’s integrate the component to the main activity.

   #. In ``app/java/com/example/hellofigma/MainActivity.kt``, add to the import
      section at the top:

      .. code:: prettyprint

         import com.example.hellofigma.hellocard.HelloCard

   #. Further down in the same file, change the following code in the
      ``MainActivity`` class:

      .. code:: prettyprint

         class MainActivity : ComponentActivity() {
             override fun onCreate(savedInstanceState: Bundle?) {
                 super.onCreate(savedInstanceState)
                 setContent {
                     HelloFigmaTheme {
                         // A surface container using the 'background' color from the theme
                         Surface(color = MaterialTheme.colors.background) {
                             // Greeting("Android") // Delete this line
                             HelloCard()  // Add this line
                         }
                     }
                 }
             }
         }

   #. Further down in the same file, in the composable’s preview, change one
      line:

      .. code:: prettyprint

         @Preview(showBackground = true)
         @Composable
         fun DefaultPreview() {
             HelloFigmaTheme {
                 HelloCard() // Change this line
             }
         }

   #. Make sure a device is selected in the toolbar.

   #. Run the project by clicking ▶ in the toolbar.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/convert-designs-android-studio/run-button.png
         name: image-11
         :alt: Run button in the toolbar
         :width: 60.0%

      The emulator will boot up, the project will build, and your app will
      start.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/convert-designs-android-studio/emulator.png
         name: image-12
         :alt: App preview in the emulator
         :width: 40.0%

      Congratulations! You have successfully incorporated your first Figma
      component into a Jetpack Compose app!

   .. rubric:: Next step
      :name: next-step

   `Make and propagate design updates  <#design-updates>`__

   Now that you have an end-to-end working example, let's see how to update the
   original design and regenerate our code.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Content parameters  <#content-parameters>`__
   -  `Make and propagate design updates  <#design-updates>`__
   -  `Handling design variants  <#design-variants>`__

Last updated 2024-03-25 UTC.

.. |Make Project button| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/common/make-project.png

/Make and propagate design updates
==================================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/design-updates?hl=en

.. container:: devsite-article-body clearfix

   In this section, you will learn how to change a component in Figma (in this
   case, change the formatting of the text) and see the changes propagate to the
   codebase in Android Studio, by building on your previous project.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-updates/before-and-after.png
      name: image-1
      :alt: Before and after comparison
      :width: 100.0%

   .. rubric:: Changes in Figma
      :name: changes-figma

   Let's make an update in the Figma component. Back in your Figma file:

   #. Select the **Title** text layer. In the **Text** section change the style
      to **Bold**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-updates/title-text-selected.png
         name: image-2
         :alt: Title text selected and bolded in Figma
         :width: 100.0%

   .. rubric:: Save named version
      :name: save-named

   Now, integrate the updated component into your codebase. To ensure that
   developers use the new version of your component, repeat the steps for saving
   a version.

   #. Open the Figma Relay plugin if it's not already open.

   #. Click **Share with developer**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-updates/share-with-developer-button.png
         name: image-3
         :alt: Save to version history option in the menu
         :width: 25.0%

   #. From the **Share with developer** screen, you can enter a new version name
      and description in the **Save version history** section.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-updates/save-new-version.png
         name: image-4
         :alt: Save to version history option in the menu
         :width: 60.0%

   #. Type **CMD-L** on a Mac or **CTRL-L** on Windows, on the keyboard, to copy
      the new link to the clipboard.

   .. rubric:: Update the component code
      :name: update-component

   Let’s now re-import the component:

   #. In Android Studio, make sure the Project tool window is in **Android
      view**. Then right-click on ``app/ui-packages/hello_card/``, and select
      **Update UI Package**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-updates/update-ui-package-action.png
         name: image-5
         :alt: Update UI Package option in the context menu
         :width: 100.0%

      Wait for the loading bar at the bottom right corner to finish:

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-updates/loading-bar.png
         name: image-6
         :alt: Android Studio loading bar
         :width: 60.0%

   #. Click |Make Project button| to build your project, and see the updated
      component in the preview of
      ``app/java/com/example/hellofigma/MainActivity.kt``. Note that the text is
      now bold.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-updates/build-button.png
         name: image-7
         :alt: Build button in the toolbar
         :width: 60.0%

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-updates/preview.png
         name: image-8
         :alt: Preview of the component
         :width: 60.0%

   #. Run the app to view the same updates in the emulator.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-updates/run-button.png
         name: image-9
         :alt: Run button in the toolbar
         :width: 60.0%

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-updates/emulator.png
         name: image-10
         :alt: App preview in the emulator
         :width: 40.0%

   .. rubric:: Next step
      :name: next-step

   Now that we've updated a design and seen how the resulting code is also
   updated, we can turn our attention to `annotating our design  <#content-parameters>`__ with content
   parameters that allow variable data in our components.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Content parameters  <#content-parameters>`__
   -  `Convert the designs to code in Android Studio  <#convert-designs-android-studio>`__

Last updated 2024-03-25 UTC.

.. |Make Project button| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/common/make-project.png

/Content parameters
===================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/content-parameters?hl=en

.. container:: devsite-article-body clearfix

   When implemented, the content of most components is not static — it changes
   depending on the data that is provided to a component. To reflect this in
   your designs, you can use content parameters. Content parameters let you
   specify which part of a design contains data, without hardcoding the actual
   data.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters/title-parameter.png
      name: image-1
      :alt: Title parameter in the plugin
      :width: 100.0%

   .. rubric:: Add a content parameter
      :name: add-content

   #. In your Figma file, select the component and open the Relay for Figma
      plugin (**Plugins > Relay for Figma**).

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters/figma-plugin.png
         name: image-2
         :alt: The Figma plugin with the hello card selected
         :width: 100.0%

   #. In the main Figma window, select the **Title** layer with **⌘** +
      **click** on Mac, or **Ctrl + click** on Windows and Linux. Then, in the
      plugin, click **+** next to “Parameters” and select **text-content** to
      add a parameter for the layer.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters/parameter-selection-menu.png
         name: image-3
         :alt: The parameter selection menu in the Figma plugin
         :width: 100.0%

   #. To change the name of the Title text content parameter, enter it in
      **Name**. For this tutorial, enter **Title**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters/parameter-details.png
         name: image-4
         :alt: The parameter details in the Figma plugin
         :width: 100.0%

      Besides editing the name, you can select different property types, or add
      a description to generate a comment in code. Work with your developers to
      find the most suitable naming scheme. The names of the content parameters
      translate to the names of the parameters in the generated composable.

   .. rubric:: Save named version
      :name: save-named

   Let’s now mark this version as ready to be imported into code.

   #. Open the Figma Relay plugin, if not already open.

   #. Click **Share with developer**.

   #. On the **Share with developer** screen, enter a name and description for
      the version.

      **Example Title**: Hello World Card V3

      **Example Description**: Added parameters

   .. rubric:: Update the component in Android Studio
      :name: update-component

   Let’s update the component in Android Studio.

   #. In Android Studio, make sure the Project tool window is in **Android
      view**. Then, right-click on ``app/ui-packages/hello_card/``, and click
      **Update UI Package**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters/update-ui-package-action.png
         name: image-6
         :alt: Update UI Package option in the context menu
         :width: 100.0%

   #. Click on |Make Project button| to build your project again.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters/build-button.png
         name: image-7
         :alt: Build button in the toolbar
         :width: 60.0%

      If you open ``app/java/com/example/hellofigma/hellocard/HelloCard.kt``,
      you’ll notice that a parameter has been added: ``title``. The name of the
      parameter is the name of the content parameter that we specified in Figma:

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters/title-parameter-in-generated-code.png
         name: image-8
         :alt: Title parameter in Figma and in the generated code
         :width: 100.0%

   #. Open ``app/java/com/example/hellofigma/MainActivity.kt``.

   #. Change one line in the ``MainActivity`` class to add a value to the
      ``title`` parameter:

      .. code:: prettyprint

         class MainActivity : ComponentActivity() {
             override fun onCreate(savedInstanceState: Bundle?) {
                 super.onCreate(savedInstanceState)
                 setContent {
                     HelloFigmaTheme {
                         // A surface container using the 'background' color from the theme
                         Surface(color = MaterialTheme.colors.background) {
                             HelloCard(title="Balloon World!") // Change this line
                         }
                     }
                 }
             }
         }

   #. Further down in the same file, in the composable’s preview, change one
      line:

      .. code:: prettyprint

         @Preview(showBackground = true)
         @Composable
         fun DefaultPreview() {
             HelloFigmaTheme {
                 HelloCard(title="Balloon World!") // Change this line
             }
         }

   #. Build your project again, and see the updated component in the preview!
      Note that the new parameter value is now visible.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters/preview-with-updated-style.png
         name: image-9
         :alt: Preview of the Hello card with updated text style
         :width: 40.0%

   #. Run the app to see the same updates in the emulator.

      Hooray! You've learned the basics of the Relay workflow.

   .. rubric:: Next step
      :name: next-step

   That concludes the basic tutorial. While you have seen many of the features
   of the Relay workflow, there are several other features available. If you're
   interested in learning how to use features like interaction handlers, working
   with components that have multiple Figma variants and more, jump in to the
   `advanced tutorial  <#advanced-tutorial>`__!

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Convert the designs to code in Android Studio  <#convert-designs-android-studio>`__
   -  `Make and propagate design updates  <#design-updates>`__
   -  `Compose layout basics  <#basics>`__

Last updated 2024-03-25 UTC.

.. |Make Project button| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/common/make-project.png

/Overview: Advanced tutorial
============================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/advanced-tutorial?hl=en

.. container:: devsite-article-body clearfix

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/advanced-tutorial/news-app.png
      name: image-1
      :alt: News App Tutorial overview
      :width: 100.0%

   In this tutorial, we create an interactive news app using a Figma component
   called **News Card** that has variants. We’ll also provide data and logic to
   our components inside of Android Studio. This tutorial includes:

   -  Learning how to use Relay with components that contain variants in Figma.
   -  Adding dynamic data to the component using content parameters. This
      enables the **News Card** to display data with different news content.
   -  Responding to user actions through interaction handlers. This lets Android
      apps react to user taps.

   .. rubric:: Next step
      :name: next-step

   `Handling design variants  <#design-variants>`__

   First, let’s learn how to handle variants in designs.

Last updated 2024-03-25 UTC.

/Handling design variants
=========================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/design-variants?hl=en

.. container:: devsite-article-body clearfix

   In Figma,
   `variants <https://help.figma.com/hc/en-us/articles/360056440594-Create-and-use-variants>`__
   are used to group different variations of the same component together, such
   as different states or sizes. Relay preserves a component’s variants when it
   is translated to code. In this section, we’ll see how Relay handles variants
   in designs.

   .. rubric:: Starting point
      :name: starting-point

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/news-card-with-variants.png
      name: image-1
      :alt: News card with tree variants
      :width: 60.0%

   We'll start with a Figma file that contains a **News Card** component with
   three variants:

   -  **hero-item** is for the most important news article
   -  **article-item** is for a typical article
   -  **audio-item** is for an article that you listen to, instead of read

   .. rubric:: Copy Figma example
      :name: copy-figma

   We’ll be using an existing Figma file as an example for this tutorial. Make
   sure you’re logged into your Figma account.

   #. Download
      `HelloNews.fig <https://relay.material.io/static/assets/tutorial-files/HelloNews.fig>`__
      to your computer.

   #. In Figma, go to the file browser. Along the left-hand side, hover over
      Drafts. A **+** icon will appear — click the **+** icon, then **Import**.
      Select the **HelloNews.fig** file that you just downloaded. This can take
      anywhere from 10 seconds to a minute.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/import-action.png
         name: image-2
         :width: 60.0%

   #. Open the imported file in Figma.

   .. rubric:: Create a UI package
      :name: create-ui

   The Relay for Figma plugin adds extra information to our component, so we can
   work with our developers who will use our component in their code.

   #. Open the Relay for Figma plugin in your file (in menu bar: **Plugins >
      Relay for Figma**). Click **Get Started**.

   #. Select the component and click **Create UI Package**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/create-button.png
         name: image-3
         :alt: Create UI Package button on the plugin
         :width: 100.0%

   #. With the UI Package selected, add a description to the summary box. For
      example: “News card component intended to display news items for a list”.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/summary.png
         name: image-4
         :alt: Summary box on the plugin
         :width: 100.0%

      **Note:**\  This description will propagate to the generated code as a
      comment above the generated composable function.

   .. rubric:: Save named version
      :name: save-named

   Now that you have created a UI package, prepare your component to share it
   with the development team.

   #. Open the Figma Relay plugin, if not already open.

   #. Click **Share with developer**.

   #. From the **Share with developer** screen, you can enter a new version name
      and description in the **Save version history** section.

   #. Click **Save**.

      **Example Title**: Initial New Card

      **Example Description**: First iteration of the news article items

   .. rubric:: Download Android Studio project
      :name: download-android

   For the Android Studio part of this tutorial, we will use a pre-configured
   Android Studio project. This project contains an app that displays news
   articles in a plain text format.

   #. Download the sample
      `HelloNews.zip <https://relay.material.io/static/assets/tutorial-files/HelloNews.zip>`__
      file.
   #. Double-click the file to unzip it, which will create a folder called
      **HelloNews**. Move it to your home folder.
   #. Go back to Android Studio. Go to **File > Open**, navigate to your home
      folder, select **HelloNews**, and click **Open**.
   #. When you open the project, Android Studio will ask you if you trust the
      project. Click **Trust Project**.

   .. rubric:: Import into Android Studio
      :name: import-android

   Let’s import our Figma component into the project.

   #. Back in Figma, copy the URL of the **News Card** Tutorial Figma file.
      We’ll use this URL to import our components. In the upper right-hand
      corner of Figma, click on the **Share** button. In the dialog box that
      opens, click **Copy Link**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/copy-link-action.png
         name: image-6
         :alt: Copy Link option on the file tab
         :width: 100.0%

   #. Switch to the HelloNews project in Android Studio. Go to **File > New >
      Import UI Packages…** from the Android Studio menu bar.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/import-ui-package-action.png
         name: image-7
         :alt: Import UI Packages… option under the File menu
         :width: 100.0%

   #. Paste the URL of your Figma file and click **Next**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/import-ui-package-dialog.png
         name: image-8
         :alt: Import UI Packages dialog
         :width: 60.0%

      **Note:**\  If you don’t have your Figma URL, repeat step one and come
      back to this dialog.

      **Note:**\  If you see a keychain prompt, enter your password and click
      Allow.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/keychain-dialog.png
         name: image-9
         :alt: Keychain system dialog
         :width: 60.0%

      **Note:**\  If you instead see a dialog about Figma Access Token, repeat
      instructions to `set up Figma Access Token in Installation  <#setup-figma>`__

      #. Once the file is done fetching (which may take some time), click
         **Finish**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/preview-in-import-dialog.png
         name: image-10
         :alt: Preview of the component
         :width: 60.0%

   #. Click |Make Project button| to build your project. This may take a minute
      or so.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/build-button.png
         name: image-11
         :alt: Build button in the toolbar
         :width: 60.0%

      **Note:**\  Click on the **Build** tab at the bottom of the app to view
      build results.

   .. rubric:: Preview app & component
      :name: preview-app

   #. In Android view, open
      ``app/java/com/example/hellonews/ui/home/HomeScreen.kt``, you’ll see a
      preview of the app, which displays several news articles in a plain text
      format, with print stories above audio stories.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/preview-of-app.png
         name: image-12
         :alt: Preview of the App
         :width: 100.0%

   #. Open up
      ``app/java (generated)/com/example/hellonews/newscard/NewsCard.kt``. This
      is the generated Jetpack Compose code for our Figma component. From the
      preview, we can see that three variants of the **NewsCard** component have
      been translated from Figma to code. Let’s take a closer look at the code.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/preview-of-newscard.png
         name: image-13
         :alt: Preview of the NewsCard component
         :width: 100.0%

   #. The ``View`` enum allows us to choose which variant to use for this
      component. The name of the enum and its values were derived from the
      variants of our Figma component. This is used in the ``view`` parameter in
      our **NewsCard** composable.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/design-variants/variants-in-figma-and-enum.png
         name: image-14
         :alt: Variants in Figma and corresponding View enum
         :width: 100.0%

   #. The **NewsCard** composable was generated from the UI package. It includes
      a parameter of type ``View``, which sets the variant of the news card to
      instantiate.

      .. code:: prettyprint

         package com.example.myapplication.newscard

         import ...

         // Design to select for NewsCard
         enum class View {
             HeroItem,
             ArticleItem,
             AudioItem
         }

         /**
         * News card component intended to display news items for a list.
         *
         * This composable was generated from the UI Package 'news_card'.
         * Generated code; do not edit directly
         */
         @Composable
         fun NewsCard(
             modifier: Modifier = Modifier,
             view: View = View.HeroItem
         ) {...}

   .. rubric:: Next up
      :name: next-undefined

   We are not quite ready to use **NewsCard** yet. The component doesn’t know
   how to display different news stories, only the same hardcoded one in Figma.
   So, if we were to add the component now, all we would get is the same news
   story repeated. We need a way to specify which parts of **NewsCard** should
   be filled with dynamic data.

   `Content Parameters  <#content-parameters-advanced>`__

   In this section, we'll add content parameters to the **NewsCard** component.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Content parameters  <#content-parameters-advanced>`__
   -  `Scroll  <#scroll>`__
   -  `Using Compose in Views  <#compose-in-views>`__

Last updated 2024-03-25 UTC.

.. |Make Project button| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/common/make-project.png

/Content parameters
===================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/content-parameters-advanced?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: Introduction
      :name: introduction

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters-advanced/update-with-more-parameters.png
      name: image-1
      :alt: Updating the NewsCard with more parameters
      :width: 100.0%

   The content of most UI designs are not static — they change depending on the
   data. In this section, we add data to our design via content parameters,
   which allow designers specify which part of a design should be filled with
   data

   .. rubric:: Add parameters in Figma
      :name: add-parameters

   Let’s add content parameters to our component.

   #. Switch to Figma. In NewsCardTutorial, select the **thumbnail image** layer
      in the **hero-item variant** (⌘ + click on Mac, or Ctrl + click on Windows
      and Linux on the image).

   #. In the Relay for Figma plugin, click **+** and select ``image-content`` in
      the drop down menu, then change the name to “thumbnail”.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters-advanced/figma-plugin-with-thumbnail-parameter.png
         name: image-2
         :alt: The Figma plugin with “thumbnail” parameter added
         :width: 100.0%

   #. Select the **headline text** layer, click + and select ``text-content``.
      Repeat the same steps for the **author**, and **date** text layers in the
      hero-item variant. Name them “headline”, “author”, and “date”
      respectively.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters-advanced/figma-plugin-with-3-more-parameters.png
         name: image-3
         :alt: The Figma plugin with “headline”, “author” and “date” parameters
         added
         :width: 100.0%

   #. Click on the thumbnail parameter in the plugin. Notice that in every
      component variant, the thumbnail layer is an image and is selected.

      Because the three layers have the same name (“thumbnail”) and are the same
      data type (image-content), the content parameter has been connected to it
      in all three variants. This means that one parameter gives the same data
      to multiple variants. This is also true for the headline, author, and date
      parameters.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters-advanced/figma-plugin-with-thumbnails-selected.png
         name: image-4
         :alt: The Figma plugin with all three thumbnail layers selected
         :width: 100.0%

   .. rubric:: Save named version
      :name: save-named

   Let’s now mark this version as ready to be imported into code.

   #. Open the Figma Relay plugin, if not already open.

   #. Click **Share with developer**.

   #. In the **Share with developer** screen, enter a name and description for
      the version.

      **Example Title**: Added Parameters

      **Example Description**: Added content parameters to card

   #. Click **Save**.

   .. rubric:: Update component in Android Studio
      :name: update-component

   Let’s update the **NewsCard** component:

   #. In Android Studio, make sure the Project tool window is in **Android
      view**. Then right-click on ``app/ui-packages/news_card/``, and click
      **Update UI Package**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters-advanced/update-ui-package-action.png
         name: image-6
         :alt: Update UI Package option in the context menu
         :width: 60.0%

   #. Click on |Make Project button| to build your project. This will take the
      updated UI Package and generate an updated version of the composable code.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters-advanced/build-button.png
         name: image-7
         :alt: Build button in the toolbar
         :width: 60.0%

   #. If you look at
      ``app/java (generated)/com/example/hellonews/newscard/NewsCard.kt``,
      you’ll see that the content parameters that we added (``thumbnail``,
      ``headline``, ``author``, ``date``) appear in our composable’s parameter
      list.

      .. code:: prettyprint

         // View to select for NewsCard
         enum class View {
             HeroItem,
             ArticleItem,
             AudioItem
         }

         /**
         * News card component intended to display news items for a list
         *
         * This composable was generated from the UI package 'news_card'.
         * Generated code; don't edit directly.
         */
         @Composable
         fun NewsCard(
             modifier: Modifier = Modifier,
             view: View = View.HeroItem,
             thumbnail: Painter = EmptyPainter(),
             headline: String = "",
             author: String = "",
             date: String = ""
         ) {
         ...

   .. rubric:: Integrate into app
      :name: integrate-app

   Let’s look back at our app, whose UI we haven’t yet modified. It contains a
   list of regular news stories and a list of audio stories. These are the two
   composables we need to add our **NewsCard** component to:

   -  The **PostListArticleStories** composable is responsible for the regular
      news stories.
   -  The **postTop** parameter represents the top story.
   -  The **posts** parameter represents the rest of the stories.
   -  The **PostListAudioStories** composable renders the audio news stories.
      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters-advanced/app-ui-with-3-sections.png
         name: image-8
         :alt: The app UI with three sections
         :width: 60.0%

      Now let’s integrate our **NewsCard** component into the home screen.

   #. In ``app/java/com/example/hellonews/ui/home/HomeScreen.kt``, add the
      following imports next to the other import lines near the top of the file:
      import ``com.example.hellonews.newscard.NewsCard``

      ``import com.example.hellonews.newscard.View``

   #. Still in **HomeScreen.kt**, scroll down to **PostListArticleStories**.

      .. code:: prettyprint

         @Composable
         fun HomeScreen(...)

         @Composable
         private fun PostList(...)

         @Composable
         private fun PostListArticleStoriesSection(...)

         @Composable
         private fun SearchArticlesSection(...)

         @Composable
         private fun PostListArticleStories(
             postTop: Post,
             posts: List<Post>,
             createOnTapped: (String, String) -> () -> Unit
         ) {...}

         @Composable
         private fun AudioStoriesTitle(...)

         @Composable
         private fun PostListAudioStories(...)

         @Composable
         fun Dialog(...)
         ...

   #. For **postTop**, replace the **Text** component with our newly imported
      **NewsCard**, using the **HeroItem** view.

      .. code:: prettyprint

         @Composable
         private fun PostListArticleStories(
             postTop: Post,
             posts: List<Post>,
             createOnTapped: (String, String) -> () -> Unit
         ) {
             ...
             Column(
                 horizontalAlignment = Alignment.Start,
                 modifier = ...
             ) {
                 Spacer(modifier = Modifier.size(12.dp))
                 NewsCard(
                     thumbnail = painterResource(postTop.imageId),
                     headline = postTop.title,
                     author = postTop.metadata.author.name,
                     date = postTop.metadata.date,
                     view = View.HeroItem
                 )
                 Spacer(modifier = Modifier.size(12.dp))
                 ...
             }
         }

   #. For each **post**, replace the Text component with our newly imported
      **NewsCard**, using the **ArticleItem** view.

      .. code:: prettyprint

         @Composable
         private fun PostListArticleStories(
             postTop: Post,
             posts: List<Post>,
             createOnTapped: (String, String) -> () -> Unit
         ) {
             ...
             Column(
                 horizontalAlignment = Alignment.Start,
                 modifier = ...
             ) {
                 ...
                 posts.forEach { post ->
                     NewsCard(
                         thumbnail = painterResource(post.imageId),
                         headline = post.title,
                         author = post.metadata.author.name,
                         date = post.metadata.date,
                         view = View.ArticleItem
                     )
                     Spacer(modifier = Modifier.size(12.dp))
                 }
             }
         }

   #. We can do the same for the audio stories at the bottom. Still in
      ``HomeScreen.kt``, scroll down to **PostListAudioStories**, around line
      260.

      .. code:: prettyprint

         @Composable
         fun HomeScreen(...)

         @Composable
         private fun PostList(...)

         @Composable
         private fun PostListArticleStoriesSection(...)

         @Composable
         private fun SearchArticlesSection(...)

         @Composable
         private fun PostListArticleStories(...)

         @Composable
         private fun AudioStoriesTitle(...)

         @Composable
         private fun PostListAudioStories(
             posts: List<Post>,
             createOnTapped: (String, String) -> () -> Unit
         ) {...}

         @Composable
         fun Dialog(...)
         ...

   #. For each post, replace the **Text** component with our newly imported
      **NewsCard**, using the AudioItem view.

      .. code:: prettyprint

         @Composable
             private fun PostListAudioStories(
             posts: List<Post>,
             createOnTapped: (String, String) -> () -> Unit
         ) {
             Column(
                 horizontalAlignment = ...,
                 modifier = ...
             ) {
                 posts.forEach { post ->
                     NewsCard(
                         thumbnail = painterResource(post.imageId),
                         headline = post.title,
                         author = post.metadata.author.name,
                         date = post.metadata.date,
                         view = View.AudioItem
                     )
                     Spacer(modifier = Modifier.size(12.dp))
                 }
             }
         }

   #. Click on |Make Project button| to build your project again and view the
      result in the preview (split screen view):

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/content-parameters-advanced/preview-of-newsapp.png
         name: image-9
         :alt: Preview of NewsApp
         :width: 60.0%

   .. rubric:: Next Step
      :name: next-step

   Next up, we'll `add some interactions to our app  <#interaction-handlers>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Add interaction handlers to designs  <#interaction-handlers>`__
   -  `Handling design variants  <#design-variants>`__
   -  `Convert the designs to code in Android Studio  <#convert-designs-android-studio>`__

Last updated 2024-03-25 UTC.

.. |Make Project button| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/common/make-project.png

/Add interaction handlers to designs
====================================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/interaction-handlers?hl=en

.. container:: devsite-article-body clearfix

   In this section, we will learn how to add interactions to our design via
   interaction handlers.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/interaction-handlers/newsapp-with-tap-interaction.png
      name: image-1
      :alt: NewsApp with tap interaction
      :width: 40.0%

   Interaction handlers provide a way to specify where a component can be
   interacted with (tapped, double tapped, etc.). Interaction handlers can be
   added to any layer inside of a design.

   .. rubric:: Add handlers
      :name: add-handlers

   Interaction handlers can be added to any layer. This allows designers to
   specify which parts of the component are interactive.

   #. Select the **hero-item** variant (the frame), click **+** next to the
      **Parameter** and select ``tap-handler`` to add an interaction handler.
      This allows developers to write code that reacts to a user tapping on the
      card.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/interaction-handlers/figma-plugin-with-hero-item.png
         name: image-2
         :alt: The Figma plugin with the hero-item variant selected
         :width: 100.0%

   #. Repeat the previous step with the **menu** icon layer in the
      **audio-item** variant. This allows developers to display a menu when a
      user taps on the menu icon.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/interaction-handlers/figma-plugin-with-menu-icon.png
         name: image-3
         :alt: The Figma plugin with the menu icon variant selected
         :width: 100.0%

   #. If you select the **on Menu tapped** handler, you'll notice that it only
      applies to the **audio-item** variant, because the other variants don't
      have a menu icon. However, the **on NewsCard tapped** applies to all three
      variants. This means that you can supply one handler (in code) to run when
      any of the three variants are tapped, removing duplication of code and
      parameters. We'll see how that works in more detail in the following
      `Update component in Android Studio <#update-component>`__ section.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/interaction-handlers/figma-plugin-with-tap-handler.png
         name: image-4
         :alt: The Figma plugin with the tap handler selected
         :width: 100.0%

   .. rubric:: Save named version
      :name: save-named

   Let’s now mark this version as ready to be imported into code.

   #. Open the Figma Relay plugin, if not already open.

   #. Click Share with developer in the lower right-hand corner of the dialog.

   #. On the **Share with developer screen**, enter a name and description for
      the version.

      **Example Title**: Added Interactions

      **Example Description**: Two interaction handlers added to cards

   #. Click **Save**.

   #. Press **CMD-L** on a MAC, **CTRL-L** on Windows to copy the component link
      to the clipboard.

   .. rubric:: Update component in Android Studio
      :name: update-component

   Let’s now update the **NewsCard** component:

   #. In Android Studio, make sure the Project tool window is in **Android**
      view. Then right-click on ``app/ui-packages/news_card/``, and near the
      bottom of the context menu, click **Update UI Package**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/interaction-handlers/update-ui-package.png
         name: image-6
         :alt: Update UI Package option in the context menu
         :width: 100.0%

   #. Click |Make Project button| to build your project. This takes the updated
      UI Package and generates an updated version of the composable code.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/interaction-handlers/build.png
         name: image-8
         :alt: Build button in the toolbar
         :width: 60.0%

      **Note:**\  This results in build warnings in HomeScreen.kt, since it is
      not using the new parameters in NewsCard. This is expected.

   #. Look at ``app/java/com/example/hellonews/newscard/NewsCard.kt`` and see
      that the interaction handlers are added as parameters to **NewsCard**
      (``onNewsCardTapped``, ``onMenuTapped``).

      .. code:: prettyprint

         // Design to select for NewsCard
         enum class View {
           HeroItem, ArticleItem, AudioItem
         }

         /**
         *   Displays a summary of a news article.
         *
         *   This composable was generated from the UI package 'news_card'.
         *   Generated code; do not edit directly
         */
         @Composable
         fun NewsCard(
           modifier: Modifier = Modifier,
           view: View = View.HeroItem,
           thumbnail: Painter = EmptyPainter(),
           headline: String = "",
           author: String = "",
           date: String = "",
           onNewsCardTapped: () -> Unit = {},
           onMenuTapped: () -> Unit = {}
         ) {
         ...

   .. rubric:: Integrate into app
      :name: integrate-app

   Now let's add some handlers to our interactions.

   #. In ``app/java/com/example/hellonews/ui/home/HomeScreen.kt``, scroll down
      to ``PostListArticleStories``, around line 175.

      .. code:: prettyprint

         ...
         @Composable
         fun HomeScreen(...)

         @Composable
         private fun PostList(...)

         @Composable
         private fun PostListArticleStoriesSection(...)

         @Composable
         private fun SearchArticlesSection(...)

         @Composable
         private fun PostListArticleStories(
           postTop: Post,
           posts: List<Post>,
           createOnTapped: (String, String) -> () -> Unit
         ) {...}

         @Composable
         private fun AudioStoriesTitle(...)

         @Composable
         private fun PostListAudioStories(...)

         @Composable
         fun Dialog(...)
         ...

   #. For ``postTop``, add handlers for ``onNewsCardTapped``. ``createOnTapped``
      opens a dialog with its parameters as the title and body.

      .. code:: prettyprint

         @Composable
         private fun PostListArticleStories(
           postTop: Post,
           posts: List<Post>,
           createOnTapped: (String, String) -> () -> Unit
         ) {
           ...
           Column(
               horizontalAlignment = Alignment.Start,
               modifier = ...
           ) {
               Spacer(modifier = Modifier.size(12.dp))
               NewsCard(
                   thumbnail = painterResource(postTop.imageId),
                   headline = postTop.title,
                   author = postTop.metadata.author.name,
                   date = postTop.metadata.date,
                   onNewsCardTapped = createOnTapped("Card Tapped", postTop.title),
                   view = View.HeroItem
               )
               Spacer(modifier = Modifier.size(12.dp))
               ...
           }
         }

   #. For each post, add handlers for ``onNewsCardTapped``.

      .. code:: prettyprint

         @Composable
         private fun PostListArticleStories(
           postTop: Post,
           posts: List<Post>,
           createOnTapped: (String, String) -> () -> Unit
         ) {
           ...
           Column(
               horizontalAlignment = Alignment.Start,
               modifier = ...
           ) {
               ...

               posts.forEach { post ->
                   NewsCard(
                       thumbnail = painterResource(post.imageId),
                       headline = post.title,
                       author = post.metadata.author.name,
                       date = post.metadata.date,
                       onNewsCardTapped = createOnTapped("Card Tapped", post.title),
                       view = View.ArticleItem
                   )
                   Spacer(modifier = Modifier.size(12.dp))
               }
           }
         }

   #. Still in ``HomeScreen.kt``, scroll down to ``PostListAudioStories``,
      around line 260.

      .. code:: prettyprint

         ...
         @Composable
         fun HomeScreen(...)

         @Composable
         private fun PostList(...)

         @Composable
         private fun PostListArticleStoriesSection(...)

         @Composable
         private fun SearchArticlesSection(...)

         @Composable
         private fun PostListArticleStories(...)

         @Composable
         private fun AudioStoriesTitle(...)

         @Composable
         private fun PostListAudioStories(
           posts: List<Post>,
           createOnTapped: (String, String) -> () -> Unit
         ) {...}

         @Composable
         fun Dialog(...)
         ...

   #. For each post, add handlers for ``onNewsCardTapped``. Since the Audio
      variant has a menu, assign ``createOnTapped`` to ``onMenuTapped``.

      .. code:: prettyprint

         @Composable
         private fun PostListAudioStories(
           posts: List<Post>,
           createOnTapped: (String, String) -> () -> Unit
         ) {
           Column(
               horizontalAlignment = ...,
               modifier = ...
           ) {
               posts.forEach { post ->
                   NewsCard(
                       thumbnail = painterResource(post.imageId),
                       headline = post.title,
                       author = post.metadata.author.name,
                       date = post.metadata.date,
                       onNewsCardTapped = createOnTapped("Card Tapped", post.title),
                       onMenuTapped = createOnTapped("Menu Tapped", post.title),
                       view = View.AudioItem
                   )
                   Spacer(modifier = Modifier.size(12.dp))
               }
           }
         }

   #. Click ▶ to build the app and run it in the emulator.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/interaction-handlers/run.png
         name: image-9
         :alt: Run button in toolbar
         :width: 60.0%

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/interaction-handlers/tapped-hero.png
         name: image-10
         :alt: News app in action in preview
         :width: 80.0%

      Hooray! You've learned the advanced features of Relay.

   You can learn more about how to work with Relay in the `Relay Workflow  <#relay-workflow>`__ section. We'd
   also love to hear from you if you have any
   `feedback <https://goo.gle/relay-feedback>`__.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Content parameters  <#content-parameters-advanced>`__
   -  `Handling design variants  <#design-variants>`__

Last updated 2024-03-25 UTC.

.. |Make Project button| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/common/make-project.png

/Overview: Relay workflow
=========================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/relay-workflow?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: Figma workflow
      :name: figma-workflow

   The Relay for Figma plugin allows you to create UI Packages to share with
   developers who use Android Studio and Jetpack Compose.

   With Relay for Figma you can:

   -  `Create UI Packages  <#create-ui-packages>`__
   -  `Add content and interaction parameters  <#add-parameters>`__
   -  `Check for errors  <#check-errors>`__
   -  `Share UI Packages  <#share-ui-packages>`__

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/relay-workflow/relay-for-figma.png
      name: image-1
      :alt: Relay for Figma Plugin
      :width: 60.0%

   .. rubric:: Android Studio workflow
      :name: android-studio

   UI Packages are transformed into production code by the Relay for Android
   Studio plugin.

   -  `Android Studio Workflow  <#android-studio-workflow>`__

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/relay-workflow/relay-for-android.png
      name: image-2
      :alt: Relay for Android Studio plugin - Import UI Packages dialog
      :width: 60.0%

   .. rubric:: UI Package & Generated Code
      :name: ui-package

   To learn more about UI Packages and the code Relay generates, see:

   -  `Understand UI Package & Generated Code  <#understand-ui-package>`__

Last updated 2024-03-25 UTC.

/Create UI Packages
===================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/create-ui-packages?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: UI Packages in Figma
      :name: ui-packages

   **UI Packages** define a shared model for Android UI components. UI Packages
   are created inside Figma and are used to generate production Compose code in
   Android Studio. A UI Package contains the following information:

   -  Layout information
   -  UI Package summary
   -  Content and interaction parameters
   -  Styling information
   -  Font and image assets

   .. rubric:: Create UI Package
      :name: create_ui_package

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/create-ui-packages/relay-for-figma.png
      name: image-1
      :alt: Add a summary to the UI Package
      :width: 60.0%

   To create a UI Package using the Relay for Figma plugin:

   #. Open the plugin and click **Get Started**.
   #. Select a Figma component you'd like to package.
   #. Click **Create UI Package**.

   To create multiple UI packages at the same time:

   #. Select one or more Figma components.
   #. Click **Create UI Packages**. This creates a UI package for each selected
      component.

   You can also refactor existing UI Package elements into new packages:

   #. Select a frame or component layer in an existing UI Package.
   #. Click the **menu icon**.
   #. Select “Create **UI package from selection.”**

   After a UI Package is imported to Android Studio, Relay generates code when
   your Android project builds.

   **Note:**\  Give important layers meaningful names. If two layers have the
   same name and are bound to a parameter, parameter values apply to both
   layers. Each layer is translated into separate render functions in Jetpack
   Compose.
   **Note:**\  UI Packages must not contain unsupported Figma elements or
   properties. See `Figma limitations  <#add-parameters>`__ for more
   information.

   .. rubric:: Add a summary
      :name: add_a_summary

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/create-ui-packages/add-summary.png
      name: image-2
      :alt: Relay for Figma with a component selected
      :width: 100.0%

   After creating, a text field appears so you can add a summary to the UI
   Package. A summary appears as a comment block above the corresponding
   composable function in generated code.

   You can also edit the summary later:

   #. Select **Summary**.
   #. Edit the summary in the text field.

   .. rubric:: Remove UI Packaging
      :name: remove_ui_packaging

   Select the **menu icon**, and then **Remove packaging**. This deletes all
   Relay metadata but does not delete the component in Figma.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/create-ui-packages/remove-packaging-action.png
      name: image-3
      :alt: “Remove packaging” option in the plugin
      :width: 60.0%

Last updated 2024-03-25 UTC.

/Add parameters
===============

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/add-parameters?hl=en

.. container:: devsite-article-body clearfix

   Parameters are the changeable aspects of a UI Package. The Relay workflow
   supports two types of parameters: content parameters and interaction
   handlers.

   -  **Content parameters** allow Compose code to dynamically change elements
      of a UI Package, like content and styling.
   -  **Interaction handlers** allow Compose code to respond to user input, such
      as long presses or double taps.

   You can add parameters to the UI Package or its children. Parameter bindings
   are also shared across Figma variants if their target layers have identical
   names. Each parameter is transformed into composable function parameters in
   generated code.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/add-parameters/parameters.png
      name: image-1
      :alt: Parameters in Figma and the generated code
      :width: 100.0%

   .. rubric:: Parameter properties
      :name: parameter-properties

   The layer type in Figma determines what parameter properties are available:

   .. rubric:: All layers
      :name: layers-undefined

   **tap-handler** (specifies a layer can be tapped)

   -  ``() -> Unit`` parameter is generated in code.

   **doubletap-handler** (specifies a layer can be double tapped)

   -  ``() -> Unit`` parameter is generated in code.

   **longpress-handler** (specifies a layer can be long pressed)

   -  ``() -> Unit`` parameter is generated in code.

   .. rubric:: Frame or group layer
      :name: frame-or

   **children** (layer contents)

   -  `Composable  <#Composable>`__
      parameter is generated in code.
   -  See `Children Parameters  <#children-parameters>`__ for
      more details.

   **background-color**

   -  `Color  <#Color>`__
      parameter is generated in code.

   **padding** (autolayout padding)

   -  `PaddingValues  <#PaddingValues>`__
      parameter is generated in code.

   **border-radius**

   -  ``Double`` parameter is generated in code.

   .. rubric:: Text layer
      :name: text-layer

   **text-content**

   -  ``String`` parameter is generated in code if the text has only one style.
   -  `AnnotatedString  <#AnnotatedString>`__
      parameter is generated in code if the `text has multiple styles  <#multiple-styles-in-text>`__.

   **color** (text color)

   -  `Color  <#Color>`__
      parameter is generated in code.

   .. rubric:: Image layer
      :name: image-layer

   **image-content**

   -  `Painter  <#Painter>`__
      parameter is generated in code.

   .. rubric:: Adding parameters
      :name: adding-parameters

   #. Select a component layer.

   #. Click **+** and select a parameter property.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/add-parameters/parameter-properties.png
         name: image-2
         :alt: Adding a Parameter
         :width: 60.0%

   .. rubric:: Rename parameters
      :name: rename-parameters

   #. Select a parameter.
   #. Edit the **Name** field.

   .. rubric:: Remove parameters
      :name: remove-parameters

   #. Select a parameter.
   #. Click the **Trash Can** icon.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Compose layout basics  <#basics>`__
   -  `Multiple Styles in Text  <#multiple-styles-in-text>`__
   -  `Kotlin for Jetpack Compose  <#kotlin>`__

Last updated 2024-03-25 UTC.

/Check errors
=============

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/check-errors?hl=en

.. container:: devsite-article-body clearfix

   Relay for Figma detects issues that might cause problems in generated code,
   like naming collisions or using unsupported Figma properties. As you work
   with UI Packages, warnings and blocking issues are displayed in the bottom of
   the plugin window.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/check-errors/number-of-issues.png
      name: image-1
      :alt: Number of issues shown at the bottom left of the plugin
      :width: 60.0%

   Click the red message to view more information about the issues.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/check-errors/list-of-issues.png
      name: image-2
      :alt: List of blocking issues and warnings
      :width: 60.0%

   Blocking issues must be resolved before sharing UI Packages with developers.
   Warnings pose a risk of causing blocking issues, but generally do not prevent
   designers from sharing their designs with developers.

   As blocking issues and warnings are addressed, they disappear from the issues
   panel. After all blocking issues and warnings are resolved, the error message
   disappears.

   See `Figma and Translation Limitations  <#limitations-and-troubleshooting>`__
   for the details of supported and unsupported features.

   .. rubric:: Example
      :name: example

   The following UI Package has a name collision between the parent and child
   package: “direction.” Disambiguating these two names prevents errors in the
   generated code.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/check-errors/resolving-the-issue.png
      name: image-3
      :alt: Resolving an issue by renaming the parameter
      :width: 100.0%

   .. rubric:: Checking error from "Share with developer" screen
      :name: checking_error_from_share_with_developer_screen

   The **Share with developer** screen shows any blocking errors that may cause
   import or build errors from the developer.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/check-errors/check-errors-share-with-developer-fig-1.png
      name: image-4
      :alt: Blocking errors that may cause import or build errors
      :width: 100.0%

   If accessed from the UI package screen, this shows you all of the blocking
   errors on all of the UI packages on the page.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/check-errors/check-errors-share-with-developer-fig-2.png
      name: image-5
      :alt: All the blocking errors on all of the UI packages
      :width: 100.0%

Last updated 2024-03-25 UTC.

/Share UI Packages
==================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/share-ui-packages?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: Best practices
      :name: best-practices

   .. rubric:: Check for errors and create named versions before sharing
      :name: check_for_errors_and_create_named_versions_before_sharing

   When you're ready to share a component or a page of components, creating a
   named version keeps UI package definitions stable. This prevents changes to
   the Figma file from affecting production components.

   #. Click on the "Share with developer" option in the plugin.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/share-ui-packages/share-ui-packages-fig-1.png
         name: image-1
         :alt: StatusCard in the Android view
         :width: 100.0%

   #. Errors that prevent your developer from using your component will show up
      as a list. Fix the errors first.

   #. You can save a version history after all blocking errors are fixed. This
      is the same as saving a version history inside of Figma. Enter a title and
      description for your new version. Click **Save**.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/share-ui-packages/share-ui-packages-fig-2.png
         name: image-2
         :alt: StatusCard in the Android view
         :width: 100.0%

   #. Your new version is saved as a version history inside of Figma.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/share-ui-packages/share-ui-packages-version-history.png
         name: image-3
         :alt: StatusCard in the Android view
         :width: 40.0%

   This links the Android Studio project to the latest named version, allowing
   for seamless updates. If the file has no named versions, updates in Android
   Studio always pull the latest auto-saved version. However, we recommended
   using named versions.

   .. rubric:: Sharing Figma Link
      :name: sharing_figma_link

   When you are ready, you can share your UI packages with your developers
   through the Figma URL link.

   .. rubric:: Sharing all UI Packages in a page
      :name: sharing_all_ui_packages_in_a_page

   Right-click on the page in the left panel and select **Copy link to page**

   All of the UI packages on the page are shared. Developers can select to
   import any or all of the UI packages in the Figma page.

   .. rubric:: Sharing a specific UI package
      :name: sharing_a_specific_ui_package

   With the component selected, right-click and select **Copy/Paste as > Copy
   Link**.

   Only the selected UI package is shared through the URL. Developers can only
   import the shared UI package.

   .. rubric:: Sharing all UI Packages in a file
      :name: sharing_all_ui_packages_in_a_file

   In Figma desktop, copy the URL by right-clicking the tab and select **Copy
   link**.

   ``https://www.figma.com/file/sample_file_id/FileName?node-id=1234567``

   Remove everything after the node-id in the URL. Share the new URL with your
   developer.

   ``https://www.figma.com/file/sample_file_id/FileName``

   Developers can import all UI packages in the Figma file.

   .. rubric:: Share all UI packages in a page with a specific version
      :name: share_all_ui_packages_in_a_page_with_a_specific_version

   Open the **Version history panel** in Figma. Right-click and select **Copy
   link**.

   Developers can import all of the UI packages on the page at the specified
   named version.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/share-ui-packages/version-history-to-story-card.png
      name: image-4
      :alt: StatusCard in the Android view
      :width: 100.0%

   .. rubric:: Advanced usage
      :name: advanced-usage

   The Relay workflow supports importing different UI Package versions in the
   same project, but it requires manually forming a Figma file URL.

   #. Copy the direct link to the component you want to import. Select the
      component layer, right click, and select **Copy/Paste as > Copy link**.
      Example:

      ``www.figma.com/file/sample_file_id/FileName?node-id=123%3A45``

   #. Select the version of the component you want to use. Go to **File > Show
      version history** and select a version. Then copy the version’s URL by
      right-clicking and choosing **Copy link**. Example:

      ``www.figma.com/file/sample_file_id/FileName?version-id=7654321&node-id=0%3A1&viewport=2425%2C1794%2C2.99``

   #. Combine the two URLs together to create a versioned URL for the component.
      You can either replace the ``node-id`` value in the versioned link with
      the one from the component link, or insert the ``version-id`` parameter
      into the link for the component, as long as you end up with both
      parameters present in the URL. Example:

      ``www.figma.com/file/sample_file_id/FileName?version-id=7654321&node-id=123%3A45``

Last updated 2024-03-25 UTC.

/Android Studio workflow
========================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/android-studio-workflow?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: Import a UI Package
      :name: import-ui

   Once you create a UI Package in Figma, you can import it into your Android
   Studio project. When the project is built, Relay generates Jetpack Compose
   code.

   To import a UI Package into an Android Studio project:

   #. Select **File > New > Import UI Packages…**

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/android-studio-workflow/import-action.png
         name: image-1
         :alt: Import UI Packages… option under the File menu
         :width: 100.0%

   #. Enter the URL for a Figma file that contains a UI Package.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/android-studio-workflow/import-dialog.png
         name: image-2
         :alt: Import UI Packages dialog
         :width: 60.0%

   #. Click **Next**.

   #. Select the UI Packages you would like to import. The components that are
      shown depend on whether you pasted a component, page, or file link. If a
      UI Package is already imported, it is labeled “UPDATED”. Otherwise, it
      shows as “NEW.”

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/android-studio-workflow/preview-dialog.png
         name: image-3
         :alt: Preview of the components
         :width: 60.0%

      **Note:**\  UI Packages nested under another UI Package are automatically
      imported if the parent is selected.

   #. Click **Finish** to import the selected packages and their dependencies
      into the ``ui-packages`` folder.

   .. rubric:: UI Package import screen
      :name: ui-package

   The import screen includes the following information:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/android-studio-workflow/ui-package-summary.png
      name: image-4
      :alt: UI Package import screen
      :width: 60.0%

   -  A preview image of the component and its variants.
   -  A title and description.
   -  A list of variants and their properties.
   -  A list of content parameters and their types.
   -  A list of interaction handlers and their types.

   .. rubric:: UI Package tool window
      :name: ui-package

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/android-studio-workflow/ui-package-sidebar.png
      name: image-5
      :alt: UI Package Sidebar
      :width: 40.0%

   The Android Studio plugin adds a tool window called **UI Package**. It opens
   whenever you select a file within a UI Package folder (e.g.,
   ``app/src/main/ui-packages/mycomponent/``). The tool window displays a
   summary of the UI Package and its contents.

   .. rubric:: Build your Android Project
      :name: build-android

   When you build an Android Studio project containing a UI Package, the Relay
   Gradle plugin generates code from the UI Package and compiles it. Font assets
   are also downloaded and copied into your project.

   If you wish to build only the imported UI Packages and not your entire
   project, you can run these specific Gradle tasks:

   -  ``generateDebugRelayCode`` or ``generateReleaseRelayCode`` generates debug
      or release versions of code derived from the UI Package.
   -  ``generateRelayRuntimeCode`` creates the runtime library used by the
      generated code.

   During the build process:

   #. Code is generated from the UI Package and stored in separate folders.
   #. Images and fonts are copied into a common generated resource folder.

   The location of the folders are documented in `Understand UI Package & Generated Code  <#understand-ui-package>`__.

   **Warning:**\  Typically, code re-generates on build if the UI Package was
   updated since the last build. However, updating a dependency located outside
   the ``ui-packages`` directory does not force code to be regenerated when you
   build the project. This can occur when the file is a theme mapping file or a
   reference component file.
   **Workaround:** To force an update to the generated code, clean the project
   (go to **Build > Clean Project**) or delete the generated code folder
   associated with the UI Package that needs to be updated. Then, build again.

   .. rubric:: Update a UI Package
      :name: update-ui

   When a new version of a design is ready, the designer should `create a new named version of the Figma file  <#create-named>`__.

   In Android Studio, make sure the Project tool window is in Android view.

   #. Under the ``ui-packages`` folder in your module, right-click the UI
      Package(s) folder you want to update, and then select **Update UI
      Package(s)**. In the following example, we've selected five UI Packages to
      update.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/android-studio-workflow/update-multiple.png
         name: image-6
         :alt: Update 5 UI Packages option in the context menu
         :width: 100.0%

   #. You can also right-click on the ``ui-packages`` folder to update all UI
      packages.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/android-studio-workflow/update-all.png
         name: image-7
         :alt: Update All UI Packages option in the context menu
         :width: 100.0%

   **Note:**\  If you don't see the ``ui-packages`` folder in Android view, go
   to Project view, then within your module, go to ``src/main/ui-packages``. It
   may also help to right-click on the top-level folder and choose "Reload from
   Disk."
   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Understand UI Package & Generated Code  <#understand-ui-package>`__
   -  `Limitations and troubleshooting  <#limitations-and-troubleshooting>`__
   -  `Mapping components to existing code  <#mapping-components-to-existing-code>`__

Last updated 2024-03-25 UTC.

/Understand UI Package & generated code
=======================================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/understand-ui-package?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: UI Package
      :name: ui-package

   UI Packages are a new flexible way to exchange UI information. Designers use
   the Relay for Figma plugin to create UI Packages from components in Figma.
   Doing this declares the design ready for use by developers. Designers then
   provide developers with the URL to their Figma design file.

   Developers use the Android Studio plugin to import UI Packages from the Figma
   design file. In an Android Studio project, a UI Package contains declarative
   descriptions of the imported Figma components along with associated assets,
   including font files, images, and SVGs.

   UI Packages are persistent artifacts and can be committed to source control.
   When a developer imports a Figma package in an Android Studio project, files
   are added to the project within the ``ui-packages`` folder. Here is a sample
   imported UI Package:

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/understand-ui-package/content-of-ui-package.png
      name: image-1
      :alt: Content of a UI Package
      :width: 40.0%

   **Note:**\  If you don't see the ``ui-packages`` folder in Android view, go
   to Project view, then within your module, go to ``src/main/ui-packages``. It
   may also help to right-click on the top-level folder and choose "Reload from
   Disk."
   A project with an imported UI Package contains the following files:

   -  ``[component_name].json`` — A JSON file describing the component (for
      example, ``story_card.json``).
   -  ``config.json`` — Stores metadata for the specific UI Package.
   -  ``fonts/`` — Folder where the font assets used by the component are
      stored, if any.
   -  ``*.png`` — Image assets used in the component (for example,
      ``menu.png``), if any.
   -  ``[component_name]_preview.png`` — Preview image of the component (for
      example, ``story_card_preview.png``).
   -  ``*.svg`` — Vector graphic assets used in the component (for example, a
      triangle), if any.
   -  ``FONTS.txt`` — A list of fonts used, if any.
   -  ``DEPS.txt`` — Names of any child components.
   -  ``VERSION.txt`` — The version of Relay used to create and import the UI
      Package.

   These are stored under ``src/main/ui-packages/[package_name]``.

   .. rubric:: Removing UI Packages
      :name: removing-ui

   To remove a UI Package from the project, you can delete the folder under
   ``ui-packages/``. Re-building the project after removing the folder removes
   its generated code as well.

   **Warning:**\  `In Android Studio, undoing a deleted UI Package folder may fail  <#in_android_studio_undoing_a_deleted_ui_package_folder_may_fail>`__
   If you undo the deletion of a UI Package folder, any file within that folder
   that had not been opened before deletion may not be restored properly.
   If you run into this problem, re-import the version of the Figma file that
   you need using **File > New > Import UI Packages…** You can also click on
   every file within the UI Package folder upon import, to ensure they will be
   restored properly.

   .. rubric:: Generated code folder structure
      :name: generated-code

   When the project builds, these UI Packages are turned into generated code
   containing ``@Composable`` functions that the developer can invoke. These are
   stored under ``build/generated/``. In the Android view, these show up as
   ``java (generated)`` and ``res`` under your module directory (in this case,
   the ``app`` directory).

   **Note:**\  Depending on your version of Android Gradle Plugin, in Android
   view the generated code may be in the ``java`` directory instead of the
   ``java (generated)`` directory.
   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/understand-ui-package/folders-of-generated-files.png
      name: image-2
      :alt: Folders that contain generated files in Android studio
      :width: 40.0%

   The following screenshots walk through the files in this directory:

   -  Resources, such as fonts and images, are copied to
      ``build/generated/res/relay/``.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/understand-ui-package/generated-resources.png
         name: image-3
         :alt: Generated resources under the res folder
         :width: 40.0%

   -  Each UI Package has its generated code placed under
      ``build/generated/source/relay/``. Each UI Package’s generated code folder
      has a single file corresponding to the component that was imported. It
      also contains a single file ending in ``Fonts.kt``, which contains
      references to the font assets used by the component.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/understand-ui-package/generated-kotlin-files.png
         name: image-4
         :alt: Generated Kotlin files under the java(generated) folder
         :width: 40.0%

   -  There is also a runtime library, ``com.google.relay.compose``, which
      provides functionality used by the generated code.

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/understand-ui-package/relay-runtime-library.png
         name: image-5
         :alt: Relay runtime library
         :width: 40.0%

   **Note:**\  If you don't see generated code in Project or Android views,
   right-click on the top-level folder and choose "Reload from Disk."
   .. rubric:: Generated code structure
      :name: generated-code

   .. rubric:: Composables
      :name: composables

   Components in Figma are made up of layers. For example, this design contains
   a frame layer **Hello Card**, which contains two child layers, **Image** (an
   image layer) and **Title** (a text layer):

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/understand-ui-package/hello-card-component.png
      name: image-6
      :alt: Hello Card component with Image and Title layers
      :width: 100.0%

   When this design is translated into code, we create separate composable
   functions for each layer, where the name of the Figma layer is the name of
   the composable function (modified to conform to Kotlin syntax). The layers
   are translated as follows:

   #. **Hello Card** layer:

      .. code:: prettyprint

         @Composable
         fun HelloCard(
           modifier: Modifier = Modifier,
           title: String
         ) {
           TopLevel(modifier = modifier) {
               Image()
               Title(title = title)
           }
         ]

   #. **Image** layer:

      .. code:: prettyprint

         @Composable
         fun Image(modifier: Modifier = Modifier) {
           Image(...)
         }

   #. **Title** layer:

      .. code:: prettyprint

         @Composable
         fun Title(
           title: String,
           modifier: Modifier = Modifier
         ) {
           Text(...)
         }

   .. rubric:: Translated Figma variants and parameters
      :name: translated-figma

   If a Figma component has multiple variants, then the generated code includes
   an enum for each variant property. The values in each variant enum correspond
   to that variant property’s value. The composable includes a parameter for
   each variant enum.

   .. code:: prettyprint

      // Design to select for NewsCard
      enum class View {
          HeroItem,
          ArticleItem,
          AudioItem
      }

      /**
       *   This composable was generated from the UI Package 'news_card'.
       *   Generated code; do not edit directly
       */
      @Composable
      fun NewsCard(
          modifier: Modifier = Modifier,
          view: View = View.HeroItem,
          onNewsCardTapped: () -> Unit = {},
          thumbnail: Painter,
          headline: String,
          author: String,
          date: String,
          onMenuTapped: () -> Unit = {}
      ) {
             when (view) {
                 View.HeroItem -> TopLevelViewHeroItem(...) {
                     ContentViewHeroItem { ... }
                 }
                 View.ArticleItem -> TopLevelViewArticleItem(...) {
                     ContentViewArticleItem { ... }
                 }
                 View.AudioItem -> TopLevelViewAudioItem(...) {
                     ContentViewAudioItem { ... }
                 }
             }
         }
      }

   Each content parameter and interaction handler of a Figma component is
   translated into a parameter of the composable. The ``NewsCard`` composable
   below has four content parameters (one image and three strings) and two
   interaction handlers (the last two parameters).

   .. code:: prettyprint

      /**
       *   This composable was generated from the UI Package 'news_card'.
       *   Generated code; do not edit directly
       */
      @Composable
      fun NewsCard(
          modifier: Modifier = Modifier,
          view: View = View.HeroItem,
          thumbnail: Painter,
          headline: String,
          author: String,
          date: String,
          onNewsCardTapped: () -> Unit = {},
          onMenuTapped: () -> Unit = {}
      ) {...}

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Limitations and troubleshooting  <#limitations-and-troubleshooting>`__
   -  `Android Studio workflow  <#android-studio-workflow>`__
   -  `Preview your UI with Composable previews  <#previews>`__

Last updated 2024-03-25 UTC.

/Figma DevMode
==============

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/figma-devmode?hl=en

.. container:: devsite-article-body clearfix

   The Relay for Figma plugin works in Figma DevMode and provides an
   engineer-friendly view of UI Package data. This lets you browse packages and
   their parameters without the risk of accidentally editing Figma file
   contents.

   |Relay Plugin in DevMode|

   To open Relay in Figma DevMode, follow these steps:

   #. In Figma, click the DevMode switch |DevMode Switch in Figma application|
      in the application toolbar.

   #. Select **Plugins** and run the **Relay for Figma** plugin.

   This opens Relay in the Figma DevMode sidebar at full height. You can also
   resize the sidebar if needed.

   .. rubric:: Read-only limitations
      :name: read-only-limitations

   Relay data is **read-only** in DevMode. As a result, some Relay features are
   either unavailable or function differently.

   The following features function differently in DevMode:

   -  **Packaging**: UI Packages cannot be created or removed.
   -  **Parameters**: parameters cannot be added, modified, or removed.
      Non-visual parameters can't be configured.
   -  **Sharing**: the *share with developers* button isn't available. New
      versions can't be created.
   -  **Errors**: errors and warnings are displayed, but they can't be fixed
      automatically.

   To use these features normally, close DevMode and open the plugin in design
   view.

Last updated 2024-03-25 UTC.

.. |Relay Plugin in DevMode| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/figma-devmode/overview.png
   :width: 100.0%
.. |DevMode Switch in Figma application| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/figma-devmode/devmode-switch.png
   :width: 32px

/Figma Component Properties
===========================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/figma-component-properties?hl=en

.. container:: devsite-article-body clearfix

   Relay recognizes Figma component properties defined on packaged components.
   Conceptually, Figma component properties are similar to Relay parameters,
   though there are some differences.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/figma-component-properties/figma_component_properties.png
      name: figma_component_properties_fig
      :alt: Diagram - Vector layers to VectorDrawable to Image
      :width: 100.0%

   In general, Figma component properties don't require the Relay plugin to
   configure and use, so it's preferable to use them in Relay parameters when
   there is overlap. However, note that Relay parameters allow for a descriptive
   comment, which is carried over to generated code; Figma component properties
   do not.

   See below for more details on different component property types and how
   Relay interprets them.

   .. rubric:: Boolean properties
      :name: boolean-properties

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/figma-component-properties/boolean_properties.png
      name: boolean_properties_fig
      :width: 100.0%

   Boolean properties control if elements are displayed in a particular design.
   They can dramatically reduce the number of variants a component needs to
   define. For example, a button with an optional icon does not need separate
   variants for the icon-shown state and the icon-hidden state.

   Relay respects boolean parameters in packaged components, and generates the
   appropriate @Composable function signature.

   .. rubric:: Text properties
      :name: text-properties

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/figma-component-properties/text_properties.png
      name: text_properties_fig
      :width: 100.0%

   Text properties are nearly identical to Relay text-content parameters; the
   only difference is support for documentation comments. If both Relay
   parameters and text properties are declared on the same layer, Relay uses the
   parameter definition to allow for comments. However, care should be taken in
   this case to avoid confusion by using consistent naming.

   If comments aren’t required for a particular parameter, we recommend using a
   Figma text property for simplicity.

   .. rubric:: Instance swap properties
      :name: instance-swap-properties

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/figma-component-properties/instance_swap_properties.png
      name: instance_swap_properties_fig
      :width: 100.0%

   Instance swap properties allow clients of a component to swap instances
   inside a child. Conceptually, this is similar to Relay children parameters,
   but there are some critical differences:

   *Applicability*: Instance swap properties can only be applied to instance
   layers. Relay children parameters, though, can be applied to instances,
   frames, or groups. As a result, the use of instance swap properties requires
   the swapped content to be itself a component, while Relay allows the content
   to be any sub-hierarchy of layers.

   *Scoping*: Instance swap properties can only have their value set at the top
   level component in a component hierarchy. Relay children parameters, by
   contrast, are set at any level in the hierarchy where the parameter is not
   exposed to the parent level.

   Relay recognizes instance swap properties declared on packaged components,
   and treats them as far as possible equivalently to children parameters (for
   example, emitting the same function signature in generated code). If a Relay
   children parameter is declared on an instance layer, its definition takes
   precedence over the instance swap property (if any) declared on that layer.

   As with text properties, using both a Figma component property and a Relay
   parameter, on the same layer, can cause confusion if naming is inconsistent.
   However, because children parameters have significant differences in
   capability to instance swap properties, we do not have a blanket
   recommendation on which to use, where. Both are possibilities. The intended
   use of the component will inform this decision.

   .. rubric:: Variant properties
      :name: variant-properties

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/figma-component-properties/variant_properties.png
      name: variant_properties_fig
      :width: 100.0%

   `Variant properties <https://help.figma.com/hc/en-us/articles/5579474826519-Explore-component-properties#h_01G2Q5GF4407ZTN7K8FHM2JREZ>`__
   are implicitly created when components have more than one variant. Relay
   supports variant properties by translating them to enum values in generated
   code.

   Designers can also declare Relay parameters that expose the variant
   properties for instance layers in a packaged component.

Last updated 2024-03-25 UTC.

/Children parameters
====================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/children-parameters?hl=en

.. container:: devsite-article-body clearfix

   Any Figma **frame, group, or component** layer can be annotated with a
   content parameter to indicate that its children are dynamic. This can be used
   to design container components, or to create slots in the design where custom
   components can be injected by application code.

   To add a children parameter to a frame or group, select the layer in Figma
   and click the **+** button next to “Parameters”, then select ``children``
   from the menu.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/children-parameters/child-parameter.png
      name: image-1
      :alt: Child parameter in Figma
      :width: 100.0%

   Once the UI Package is imported into Android Studio, the parameter appears in
   the generated ``@Composable`` function signature with type
   ``@Composable RelayContainerScope.() -> Unit`` (in this case, named
   ``customGraphic``).

   .. code:: prettyprint

      @Composable
      fun HelloCardWithCustomChild(
          modifier: Modifier = Modifier,
          customGraphic: @Composable RelayContainerScope.() -> Unit
      ) {
          TopLevel(modifier = modifier) {
              Image()
              CustomGraphic { customGraphic() }
              Title()
          }
      }

   In the ``@Preview`` function, the design from the Figma file is used to fill
   the slot (in this case, the ``customGraphic`` parameter is set).

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/children-parameters/childe-element-in-preview.png
      name: image-2
      :alt: The child element in Figma retained in the preview
      :width: 60.0%

   .. code:: prettyprint

      @Preview(widthDp = 248, heightDp = 265)
      @Composable
      private fun HelloCardWithCustomChildPreview() {
          MaterialTheme {
              HelloCardWithCustomChild(
                  customGraphic = {
                      RelayText(
                          content = "Label",
                          fontSize = 16.0.sp,
                          fontFamily = montserrat,
                          color = Color(
                             alpha = 255,
                             red = 0,
                             green = 0,
                             blue = 0
                          ),
                          textAlign = TextAlign.Left,
                          fontWeight = FontWeight(500.0.toInt())
                      )
                      RelayImage(
                          image = painterResource(
                             R.drawable.hello_card_with_custom_child_custom_graphic_still
                          ),
                          contentScale = ContentScale.Crop,
                          modifier =
                             Modifier.requiredWidth(132.0.dp).requiredHeight(48.0.dp)
                      )
                  }
              )
          }
      }

   Adding a children parameter to a layer also affects the layer in the
   following ways:

   -  Any Relay parameters that were added to the layer before are *not visible*
      in the Relay for Figma plugin UI, and they are *not available* in
      generated code.
   -  In generated code, the content of the layer is no longer rendered by
      default. It becomes the content of the corresponding composable *only in
      the preview*. For the composable to have any content, the developer must
      write code to pass content into the children parameter.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Compose layout basics  <#basics>`__
   -  `Add parameters  <#add-parameters>`__
   -  `Preview your UI with Composable previews  <#previews>`__

Last updated 2024-03-25 UTC.

/Nested package instances
=========================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/nested-package-instances?hl=en

.. container:: devsite-article-body clearfix

   |A UI Package with nested instances|

   UI Packages can contain (or "nest") instances of other UI Packages, with
   support for dynamic content and interactivity at each level—all automatically
   imported using the Relay for Android Studio plugin.

   .. rubric:: Add nested instances and expose nested parameters
      :name: add-nested

   Package instances can be added as you would normally `add component instances in Figma <https://help.figma.com/hc/en-us/articles/360039150173-Create-and-insert-component-instances>`__.

   Once you add a nested package instance to a package, you can add content and
   interaction parameters based on the nested instance parameters, just like the
   properties of any other layer:

   -  Select the packaged instance layer.
   -  Click the **+** add parameter in the Relay for Figma UI.
   -  Select one of the nested package parameters.

   The selected parameter or interaction is exposed by the parent component,
   forming a connection between the nested package parameter and a new parameter
   added to the parent component. In the generated code, you can now provide a
   value to the parent, which is passed through to an instance of the nested
   package's code component.

   If the nested instance is present in multiple Figma variants in the parent
   component, the UI groups variant instances to enable individual
   configuration.

   |Grouping instances per variant|

   By default, nested package instance parameters are not exposed by the parent
   component. Instead, the generated code uses the value you specify in Figma,
   just like regular parameter overrides.

   |Exposing nested instance parameters by their parents|

   Let's look at this example:

   -  The **Chip** package has one text parameter, ``chip-text``.

   -  The **Description Card** package contains a Chip package. Its parameters
      are:

      -  ``title``
      -  ``subchip-text``, which exposes the Chip instance's ``chip-text``
         parameter
      -  ``sub-icon``
      -  ``details``

   -  The **Reservation Card** package contains a Description Card package. Its
      parameters are:

      -  ``hero-image``

      -  ``headline``, which exposes the Description Card instance's ``title``
         parameter.

      -  ``reservation-text``, which exposes the Description Card instance's
         ``chip-text`` parameter.

      -  ``summary``, which exposes the Description Card instance's ``details``
         parameter.

   Note that ``sub-icon`` is the only parameter of the Description Card that is
   not exposed by the Reservation Card. Therefore, every instance of a
   Reservation Card uses the icon that the Description Card provides by default.

   To expose a parameter of a nested component instance:

   #. Select a nested instance of a UI Package that has parameters. You can
      select the instance in the canvas directly or in the Relay for Figma
      plugin under **Relay instances**.

   #. Click **+** next to **Parameters**. The menu shows the parameters from the
      selected instance. Select a parameter.

      This exposes a parameter from the nested instance. In this example, we've
      selected the **Description Card** instance and exposed the **details**
      parameter.

      |Exposing the details parameter of Description Card|

   #. In the pane on the right side of the Relay for Figma plugin, you can
      select a different parameter, or rename the parameter to change how it is
      called in the generated code. In this example, the parameter is renamed to
      **summary**, which still refers to the **details** parameter from our
      nested instance.

      |Renaming the details parameter to summary|

   When you import a parent component (in this case, **Reservation Card**) into
   Android Studio, all nested packages are automatically imported (in this case,
   **Description Card** and **Chip**). When the code is generated, each package
   generates its own composable function.

   |UI Packages and generated code|

   The generated code for the example looks like:

   **ReservationCard.kt**

   .. code:: prettyprint

      ..
      import com.example.hellofigma.descriptioncard.DescriptionCard
      ...

      @Composable
      fun ReservationCard(
          modifier: Modifier = Modifier,
          heroImage: Painter,
          headline: String,
          summary: String,
          reservationText: String
      ) {
          ...
          DescriptionCard(
              title = headline,
              details = summary,
              subchipText = reservationText,
              subIcon = painterResource(R.drawable.reservation_card_bookmark_icon),
              modifier = modifier
          )
          ...
      }

   **DescriptionCard.kt**

   .. code:: prettyprint

      ...
      import com.example.hellofigma.chip.Chip
      ...
      @Composable
      fun DescriptionCard(
          modifier: Modifier = Modifier,
          title: String,
          details: String,
          subchipText: String,
          subIcon: Painter
      ) {
         ...
         Chip(chipText = subchipText)
         ...
      }

   .. rubric:: Override properties of nested package instance
      :name: override-properties

   If you override the value of a nested instance property in Figma, the new
   value is only translated in Compose code if the nested component has added a
   parameter for that property. Otherwise, the new value is dropped, and the
   original value in the nested component is used in code.

   Let's take this example. The **Description Card** component has a **Chip**
   component instance. We've added an override to the **Chip** instance by
   changing the text from "Chip Text" to "Reservation Required":

   |Chip component instance in the Description Card|

   If **Chip** does not have a parameter for its text, then in generated code,
   the **Description Card's** chip still says "Chip Text", not "Reservation
   Required."

   .. code:: prettyprint

      @Composable
      fun DescriptionCard(
          modifier: Modifier = Modifier,
      ) {
          ...
          Chip(
              modifier = modifier
              // No parameter available to override the chip's text
          )
          ...
      }

      @Composable
      fun Chip(
          modifier: Modifier = Modifier,
      ) {...}

   If **Chip** does have a parameter for its text, say, **chip-text**, then in
   generated code, ``DescriptionCard`` calls ``Chip`` with "Reservation
   Required" as the value of the ``chipText`` parameter:

   .. code:: prettyprint

      @Composable
      fun DescriptionCard(
          modifier: Modifier = Modifier,
      ) {
          ...
          Chip(
              modifier = modifier,
              chipText = "Reservation Required"
          )
          ...
      }

      @Composable
      fun Chip(
          modifier: Modifier = Modifier,
          chipText: String
      ) {...}

   If **Description Card** exposes **Chip's chip-text** parameter as
   **subchip-text**, then in generated code, ``DescriptionCard`` has a
   ``subchipText`` parameter and calls ``Chip`` with ``subchipText`` as the
   value of the ``chipText`` parameter:

   .. code:: prettyprint

      @Composable
      fun DescriptionCard(
          modifier: Modifier = Modifier,
          subchipText: String
      ) {
          ...
          Chip(
              modifier = modifier,
              chipText = subchipText
          )
          ...
      }

      @Composable
      fun Chip(
          modifier: Modifier = Modifier,
          chipText: String
      ) {...}

   Furthermore, now that "Reservation Required" is the value of a parameter, it
   shows up in generated code only in the preview of DescriptionCard.

   .. code:: prettyprint

      @Preview
      @Composable
      private fun DescriptionCardPreview() {
          MaterialTheme {
              RelayContainer {
                  DescriptionCard(
                      subchipText = "Reservation Required",
                      modifier = Modifier.rowWeight(1.0f).columnWeight(1.0f)
                  )
              }
          }
      }

   .. rubric:: Limitations
      :name: limitations

   -  `Nested component with same variant properties as parent component fails to compile  <#nested-component-variants>`__
   -  `Updating resources outside ui-packages don't force a new build  <#updating-resources>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Mapping components to existing code  <#mapping-components-to-existing-code>`__
   -  `Content parameters  <#content-parameters>`__
   -  `Compose layout basics  <#basics>`__

Last updated 2024-03-25 UTC.

.. |A UI Package with nested instances| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/nested-package-instances/ui-package-with-nested.png
   :width: 100.0%
.. |Grouping instances per variant| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/nested-package-instances/nested-instance-variants.png
   :width: 65.0%
.. |Exposing nested instance parameters by their parents| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/nested-package-instances/nested-bubbling-up.png
   :width: 80.0%
.. |Exposing the details parameter of Description Card| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/nested-package-instances/bubbling-up.png
   :width: 100.0%
.. |Renaming the details parameter to summary| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/nested-package-instances/renaming-parameter.png
   :width: 100.0%
.. |UI Packages and generated code| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/nested-package-instances/ui-packages-and-generated-code.png
   :width: 60.0%
.. |Chip component instance in the Description Card| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/nested-package-instances/chip-instance.png
   :width: 100.0%

/Vector graphics
================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/vector-graphics?hl=en

.. container:: devsite-article-body clearfix

   Relay supports the translation of Figma’s vector layers to Android’s `vector drawables  <#vector-drawable-resources>`__.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/vector-graphics/diagram.png
      name: image-1
      :alt: Diagram - Vector layers to VectorDrawable to Image
      :width: 100.0%

   Relay converts Figma vector layers to Scalable Vector Graphics (SVG), which
   are then converted into vector drawables. A vector drawable is a vector
   graphic defined in an XML file as a set of points, lines, and curves with
   associated color information. In the generated code, the vector drawable is
   used like an image asset.

   Relay currently supports the following vector format attributes:

   -  All vector types (rectangle, line, arrow, ellipse, polygon, star, generic
      vector)
   -  Vector fill (solid color, linear gradient, radial gradient)
   -  Solid strokes
   -  Stroke fill (solid color, linear gradient, radial gradient)
   -  Stroke width
   -  Stroke end style
   -  Opacity

   .. rubric:: Limitations
      :name: limitations

   Vector-specific attributes that are `not currently supported  <#unsupported-figma>`__
   are:

   -  Features not supported by Android’s VectorDrawable format:

      -  Embedded bitmap images (except rectangles, which are supported as
         images rather than vectors)
      -  Dashed strokes
      -  Blur
      -  Shadow
      -  Pattern
      -  Mask
      -  Group opacity
      -  Radial gradient focal point

   -  Features not supported by the SVG format:

      -  Angular gradients
      -  Diamond gradients

   -  Boolean operations between vector objects (union / subtract / intersect /
      exclude)

      -  A workaround is to combine and flatten into a single vector

Last updated 2024-03-25 UTC.

/Multiple styles in text
========================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/multiple-styles-in-text?hl=en

.. container:: devsite-article-body clearfix

   Figma allows designers to apply multiple text style variations within a
   single text element. For example, the word “Brown” in the packaged Figma
   component below is a single text element that includes a variety of styles,
   including different text sizes within a single word.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/multiple-styles-in-text/mixed-text-styles.png
      name: image-1
      :alt: Mixed text styles in a single text element
      :width: 60.0%

   Relay supports design-to-code translation of multiple text styles applied to
   substrings within a Figma text layer. In the generated source code, Compose’s
   `AnnotatedString  <#multiple-styles>`__ and
   `SpanStyle  <#multiple-styles>`__ are used to
   represent multiple styles in text layers.

   The supported styles are:

   -  typeface
   -  text size
   -  font weight
   -  color
   -  letter spacing
   -  italic
   -  strike through
   -  underline

   In the generated Compose code, Relay’s ``RelayText`` composable can accept
   either ``String`` or ``AnnotatedString``. Relay generates Kotlin code that
   uses the ``AnnotatedString.Builder`` and ``SpanStyle`` classes to render
   multiple styles in text. The code fragment below shows wide letter spacing
   being applied to the word “jumps”, followed by a space with no custom style,
   followed by the word “over” in bold italic.

   .. code:: prettyprint

      RelayText(
         content = buildAnnotatedString {
             append("The ")
             ...
             withStyle(
                 style = SpanStyle(
                     letterSpacing = 8.64.sp,
                 )
             ) { // AnnotatedString.Builder
                 append("jumps")
             }
             append(" ")
             withStyle(
                 style = SpanStyle(
                     fontFamily = inter,
                     fontSize = 32.0.sp,
                     fontWeight = FontWeight(700.0.toInt()),
                     fontStyle = FontStyle.Italic,
                 )
             ) { // AnnotatedString.Builder
                 append("over")
             }
             ...
         },
         ...
      )

   .. rubric:: Limitations
      :name: limitations

   -  `Unsupported Figma Properties  <#unsupported-figma-properties>`__

      -  Paragraph spacing
      -  Paragraph indent
      -  Number styling
      -  Letterforms
      -  Stylistic sets
      -  Strikethrough and underline
      -  Line height (still works when applied to the entire text element)

   -  `Multiple styles are dropped if passed into text parameter with one style  <#multiple-styles>`__

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Style text  <#style-text>`__
   -  `Enable user interactions  <#user-interactions>`__
   -  `Add parameters  <#add-parameters>`__

Last updated 2024-03-25 UTC.

/Absolute positioning within auto layout
========================================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/absolute-positioning?hl=en

.. container:: devsite-article-body clearfix

   Relay supports absolute positioned elements within auto layout frames.
   Absolute positioning allows you to exclude an element from the normal layout
   flow without removing it from the frame itself. The layer order of the
   objects in the frame is preserved.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/absolute-positioning/absolute.png
      name: image-1
      :alt: Autolayout with absolutely positioned elements
      :width: 40.0%

   .. rubric:: Limitations
      :name: limitations

   -  `Partially Supported Figma Properties  <#partially-supported>`__

      -  Positioned objects must be either behind or in front of all of the
         auto-layout elements in the frame. Any absolute positioned objects that
         are layered between auto-layout elements will be pushed to the front of
         these objects.
      -  Nesting auto-layout frames with absolutely positioned objects inside
         other auto-layout frames can result in incorrect layout, since the
         bounding box of the nested frame is affected by the positioned items in
         that frame.

Last updated 2024-03-25 UTC.

/Fill color
===========

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/fill-color?hl=en

.. container:: devsite-article-body clearfix

   Relay supports multiple solid and linear gradient fills.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/fill-color/multiple-fills.png
      name: image-1
      :alt: Multiple fills and linear gradients in Figma
      :width: 60.0%

   Blend modes for fill colors are also supported.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/fill-color/blend-modes.png
      name: image-2
      :alt: Blend modes in Figma
      :width: 60.0%

   .. rubric:: Limitations
      :name: limitations

   -  `Partially Supported Figma Properties  <#partially-supported>`__

      -  Images can only have one image fill, but can have additional fills of
         other types (e.g., gradients).
      -  For gradients, only linear is supported. Future releases will provide
         additional support for the remaining gradient types (radial, diamond,
         and angular).
      -  In the Figma plugin, there isn’t a way to specify that a parameter can
         accept multiple fills. If you want to parameterize a fill color, only
         solid colors are currently supported for parameters.

Last updated 2024-03-25 UTC.

/Effects
========

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/effects?hl=en

.. container:: devsite-article-body clearfix

   Relay only supports drop shadows currently.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/effects/shadow.png
      name: image-1
      :alt: Shadow examples
      :width: 60.0%

   .. rubric:: Limitations
      :name: limitations

   `Drop shadow limitations  <#partially-supported>`__:

   -  Drop shadows currently do not work on the following layers:

      -  Non-rectangular vectors
      -  Rotated rectangular vector

   -  Multiple drop shadows per layer is not supported.
   -  Drop shadow blend modes other than “Normal” are only available on Android
      versions 10+ (ignored otherwise).
   -  Drop shadows on most layers are only available on Android versions 9+
      except Text, which is available on all Android versions supported by
      Compose.
   -  Shadows will always show behind transparent layers in Compose.

Last updated 2024-03-25 UTC.

/Limitations and troubleshooting
================================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/limitations-and-troubleshooting?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: Figma and translation limitations
      :name: figma-and

   .. rubric:: Supported Figma layer types
      :name: supported-figma

   Relay only supports the following layer types:

   -  Text nodes
   -  Image nodes (PNG, JPEG, etc.)
   -  Frame nodes (autolayout and non-autolayout)
   -  Components and variants, component instances
   -  Vector nodes

   .. rubric:: Unsupported Figma layers and features
      :name: unsupported-figma-features

   -  Prototyping features
   -  Masking groups
   -  Slice layers

   .. rubric:: Unsupported Figma properties
      :name: unsupported-figma-properties

   There are several unsupported properties, including:

   -  Inner shadow, layer blur, and background blur
   -  Layer rotation (vector rotation is supported)
   -  Layer or stroke blend modes (fill blend mode is supported)
   -  Text properties:

      -  Paragraph spacing
      -  Paragraph indent
      -  Number styling
      -  Letterforms
      -  Stylistic sets
      -  Strikethrough and underline
      -  Line height (still works when applied to the entire text element)

   -  Vector properties:

      -  Features not supported by Android’s ``VectorDrawable`` format:

         -  Embedded bitmap images

            -  Except for rectangles, which are supported as images rather than
               vectors

         -  Dashed strokes
         -  Blur
         -  Shadow
         -  Pattern
         -  Mask
         -  Group opacity
         -  Radial gradient focal point

      -  Features not supported by the SVG format:

         -  Angular gradients
         -  Diamond gradients

      -  Boolean operations between vector objects (union / subtract / intersect
         / exclude)

         -  A workaround is to combine and flatten into a single vector

   .. rubric:: Partially supported Figma layers and properties
      :name: partially-supported

   -  Text truncation (ellipsis) works most reliably when the text item is only
      one line
   -  Fill color:

      -  Images can only have one image fill, but can have additional fills of
         other types (e.g., gradients)
      -  For gradients, only linear is supported. Future releases will provide
         additional support for the remaining gradient types (radial, diamond,
         and angular).
      -  In the Figma plugin, there isn’t a way to specify that a parameter can
         accept multiple fills. If you want to parameterize a fill color, only
         solid colors are currently supported for parameters

   -  Drop shadows:

      -  Drop shadows currently do not work on the following layers:

         -  Non-rectangular vectors
         -  Rotated rectangular vector

      -  Multiple drop shadows per layer are not supported.
      -  Drop shadow blend modes other than “Normal” are only available on
         Android versions 10+ (ignored otherwise).
      -  Drop shadows on layers are only available on Android versions 9+,
         except text, which is available on all Android versions supported by
         Compose.
      -  Shadows will always show behind transparent layers in Compose.

   -  Absolute positioning within Auto Layout:

      -  Absolutely positioned objects must be either behind or in front of all
         of the auto-layout elements in the frame. Any absolute positioned
         objects that are layered between auto-layout elements will be pushed to
         the front of these objects.
      -  Nesting auto-layout frames with absolutely positioned objects inside
         other auto-layout frames can result in incorrect layout, since the
         bounding box of the nested frame is affected by the positioned items in
         that frame.

   .. rubric:: Multiple styles are dropped if passed into text parameter with
      one style
      :name: multiple-styles

   If a parent component tries to pass text with multiple styles into a nested
   component text parameter with only one style, the multiple styles are lost in
   the generated Compose code. Only the original style of the text parameter is
   kept.

   This degradation is necessary to avoid type mismatches that prevent generated
   code from compiling. If the text in a component has multiple styles, the
   generated composable will have an ``AnnotatedText`` parameter. If the text in
   a component has only one style, the generated composable will have a plain
   ``String`` parameter. In the above scenario, we need to convert the parent
   component’s rich text from ``AnnotatedText`` to ``String``, dropping the
   multiple styles, so that it can be passed to the nested component instance.

   .. rubric:: Nested components with same variant properties as parent
      component fails to compile
      :name: nested-component-variants

   If two components have a [design variant]{:.external} with the same property
   name, and one nests the other, then in generated code, the enums created for
   the two variants will have the same name, and there will be a compile error:

   .. code:: kotlin

      Conflicting import, imported name '(variant property)' is ambiguous

   To work around this, change the variant property name of one of the
   components.

   .. rubric:: Font support
      :name: font-support

   We currently only support fonts from `Google Fonts <https://fonts.google.com/>`__.

   .. rubric:: Android Studio troubleshooting
      :name: android-studio

   .. rubric:: I received an error about converting SVG resources on Windows
      :name: i_received_an_error_about_converting_svg_resources_on_windows

   .. code:: kotlin

      FAILURE: Build failed with an exception.
      *   What went wrong:
      Execution failed for task ':app:generateDebugRelayCode'.
      > A failure occurred while executing com.google.relay.gradle.GenerateCode$GenerateCodeWorkAction
            > Converting SVG files: Exception Converting SVG resources for my_packaged_component
              The syntax of the command is incorrect

   Your Android Studio project name may be too long. On Windows, the full path
   of the Android Studio project must be no more than 70 characters. We are
   working to increase this length in a future release.

   .. rubric:: Updates are not imported into Android Studio
      :name: updates-are

   The plugin will only pull down the latest named version of your Figma file.
   Double check that you have created a new named version of your Figma file
   with the changes.

   .. rubric:: I receive an error about SVG and Java Runtime when building
      :name: svg-java

   .. code:: kotlin

      Converting SVG Files: Exception running shell command 'cd /path-to/relay/bin; path/to/relay/bin/vd-tool -c -in path/to/hello_card -out /var/folders/...'.
      The operation couldn't be completed. Unable to locate a Java Runtime.
      Please visit http://www.java.com for information on installing Java.

   Install `Java Runtime <https://www.java.com/download/>`__, then build again.

   .. rubric:: I receive an error about fonts when building
      :name: fonts-build-error

   You may see an error similar to:

   .. code:: kotlin

      FAILURE: Build failed with an exception.
      *   What went wrong:
      Execution failed for task ':app:generateDebugRelayCode'.
      > Multiple task action failures occurred:
         > A failure occurred while executing com.google.relay.gradle.GenerateCode$GenerateCodeWorkAction
            > /Users/me/AndroidStudioProjects/MyProject/app/build/generated/res/relay/debug/font/relay_inter_bold.ttf
         > A failure occurred while executing com.google.relay.gradle.GenerateCode$GenerateCodeWorkAction
            > /Users/me/AndroidStudioProjects/MyProject/app/build/generated/res/relay/debug/font/relay_inter_bold.ttf

   This is caused by a race condition: multiple components trying to copy the
   same font to the same directory. We are working to fix this problem.
   Meanwhile, simply try building again.

   .. rubric:: In Android Studio, undoing a deleted UI Package folder may fail
      :name: android-studio

   If you delete a UI Package folder within the ``ui-packages`` folder in
   Android Studio, and then undo the deletion, any file within that folder that
   had not been opened before deletion may not be restored properly.

   **Workaround**: Re-import the version of the Figma file that you need using
   **File > New > Import UI Packages…** You can also click on every file within
   the UI Package folder upon import, to ensure they will be restored properly.

   .. rubric:: Updating resources outside ui-packages do not force a new build
      :name: updating-resources

   Updating a dependency located outside the ``ui-packages`` directory (such as
   a theme mapping file or reference component file) does not force code to be
   regenerated when you build the project.

   **Workaround**: To force an update to generated code, clean the project (go
   to **Build > Clean Project**) or delete the generated code folder associated
   with the UI Package that needs to be updated. Then, build again.

   .. rubric:: Generated code or ``ui-packages`` folders are missing in Android
      project browser
      :name: missing-folders

   In some cases, folders generated by the Relay for Android Studio plugin don't
   appear in the Android project browser.

   **Workaround**: To reload project folders, right-click on a top-level folder
   and select "Reload from Disk."

   .. rubric:: App themes for child components are not updated
      :name: app-themes

   When a parent component is re-imported with a new app theme, its child
   components (listed in ``DEPS.txt``) will not pick up the new theme.

   **Workaround**: Copy the preview theme from the parent component's
   ``config.json``, and replace the child components' preview themes with it in
   each respective ``config.json``. After you rebuild, the themes in the child
   components' generated code will be fixed.

   .. rubric:: UI Package name must start with letter
      :name: ui-package

   If a UI Package name does not start with a letter, Relay will generate
   Compose code that does not compile, with an error message that says
   ``The resource name must start with a letter``.

   **Workaround**: In Figma, rename the UI Package name so it starts with a
   letter.

   .. rubric:: Font padding in Compose does not match Figma
      :name: font-padding

   Figma and Compose lay out text within its bounding box differently. Compose
   adds more padding along the top of the bounding box.

   **Workaround**: You will have to move the text location in Figma up a few
   pixels to get it to line up correctly in Compose. We are working on a
   permanent fix.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Understand UI Package & Generated Code  <#understand-ui-package>`__
   -  `Multiple Styles in Text  <#multiple-styles-in-text>`__
   -  `Mapping components to existing code  <#mapping-components-to-existing-code>`__

Last updated 2024-03-25 UTC.

/Mapping styles to Compose theme
================================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/mapping-styles-to-compose-theme?hl=en

.. container:: devsite-article-body clearfix

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/mapping-styles-to-compose-theme/mappding-from-styles-in-figma.png
      name: image-1
      :alt: Mapping from Styles in Figma to Theme in Compose
      :width: 100.0%

   Figma lets designers apply a style to a design element. A style is a reusable
   collection of properties, such as colors or typography. Since it is centrally
   defined, a team can define and update properties across all designs when
   updating a single design element. You can set up Relay so it translates Figma
   styles to Jetpack Compose themes.

   The mapping between Figma styles and Compose themes is specified through a
   configuration file.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/mapping-styles-to-compose-theme/config-file.png
      name: image-2
      :alt: Configuration file maps Figma styles and Compose themes
      :width: 100.0%

   As an example, the Figma design shown below uses styles from Google’s
   Material 3 Design Kit. For the text **Primary - Title large**, the font is
   **M3/title/large** and its color is **M3/sys/light/primary**..

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/mapping-styles-to-compose-theme/m3-styles-in-Figma.png
      name: image-3
      :alt: Material 3 styles in Figma
      :width: 60.0%

   If we import the design with M3 Design Kit styles translation enabled, the
   following code is generated for the **Primary - Title large** text:

   .. code:: prettyprint

      @Composable
      fun PrimaryTitleLarge(modifier: Modifier = Modifier) {
          Text(
              content = "Primary - Title large",
              fontSize = MaterialTheme.typography.titleLarge.fontSize,
              fontFamily = MaterialTheme.typography.titleLarge.fontFamily,
              color = MaterialTheme.colorScheme.primary,
              height = MaterialTheme.typography.titleLarge.lineHeight,
              letterSpacing = MaterialTheme.typography.titleLarge.letterSpacing,
              textAlign = TextAlign.Left,
              fontWeight = MaterialTheme.typography.titleLarge.fontWeight,
              modifier = modifier
          )
      }

   To use this feature, use styles as you normally would in Figma. Then in
   Android Studio, go to the **File > New > Import UI Packages…**, and then
   check **Translate Figma styles to Compose theme**.

   At this point, you must choose a configuration for translating your design’s
   styles:

   -  If they directly come from Google’s `Material 3 Design Kit <https://www.figma.com/community/file/1035203688168086460>`__ for
      Figma (which have the format ``M3/body/medium or M3/sys/light/primary``),
      then select the **Material 3 Design Kit configuration** option.

   -  If they directly come from Google’s `Material 2 Design Kit <https://www.figma.com/community/file/778763161265841481>`__ for Figma
      (which have the format ``01. Primary/500 or Subtitle 1``), then select the
      **Material 2 Design Kit configuration** option.

   -  If you have your own style definitions, then select the **Custom
      configuration** option and choose the file that contains the mappings
      between Figma styles and Compose themes (described `in this section <#configuration-files>`__).

      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/mapping-styles-to-compose-theme/import-dialog.png
         name: image-4
         :alt: Import UI Package dialog
         :width: 60.0%

   If there are styles in the Figma design that are not in the selected
   configuration, the Import dialog shows a warning for each unmapped style.
   Each unmapped style is translated to its literal value instead. The warnings
   are initially collapsed; click on the warnings banner to expand. Each warning
   has a link to the specific layer in the Figma file that causes the warning.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/mapping-styles-to-compose-theme/warning-in-dialog.png
      name: image-5
      :alt: Warnings in the import dialog
      :width: 60.0%

   After importing, the style configuration are located in the Android Studio
   project. Look for them inside the ``ui-package-resources/style-mappings``
   directory.

   .. rubric:: Configuration files for custom translations
      :name: configuration-files

   Translating Figma styles to Compose themes consists of two steps:

   #. A Figma style in a UI Package is translated to a design token in the UI
      Package definition JSON file, within the UI Package folder in your Android
      Studio project.
   #. A design token in a UI Package definition file is translated to a snippet
      of Compose theme code in your Android Studio project.

   The format of the custom configuration file (which is in JSON format)
   reflects these two steps. Here is an example of a simple custom configuration
   file that only handles color styles:

   .. code:: prettyprint

      {
        "figma": {
          "colors": {
            "my-app-theme/sys/light/primary": "myapp.sys.color.primary",
            "my-app-theme/sys/light/primary-container": "myapp.sys.color.primary-container",
            "my-app-theme/sys/light/background": "myapp.sys.color.background",
            "my-app-theme/sys/light/on-background": "myapp.sys.color.on-background",
            "my-app-theme/sys/dark/background": "myapp.sys.color.background",
            "my-app-theme/sys/dark/on-background": "myapp.sys.color.on-background"
          }
        },
        "compose": {
          "colors": {
            "myapp.sys.color.primary": "MaterialTheme.colorScheme.primary",
            "myapp.sys.color.primary-container": "MaterialTheme.colorScheme.primaryContainer",
            "myapp.sys.color.background": "MaterialTheme.colorScheme.background",
            "myapp.sys.color.on-background": "MaterialTheme.colorScheme.onBackground"
          },
          "options": {
            "packages": {
              "MaterialTheme": "androidx.compose.material3"
            }
          }
        }
      }

   There are two top-level sections, ``figma`` (which specifies step 1) and
   ``compose`` (which specifies step 2). Both of them include a ``colors``
   section:

   -  ``figma``\ ’s ``colors`` section specifies a Figma style and the
      corresponding design token that should be written to the UI Package
      definition file.
   -  ``compose``\ ’s ``colors`` section specifies a design token in the UI
      Package definition file and the corresponding code snippet that should be
      written to your Compose code.

   In the example configuration above, anything using the color
   ``my-app-theme/sys/light/primary`` in Figma has its color written as
   ``myapp.sys.color.primary`` in the UI Package definition file. Then, during
   code generation, that color is written as
   ``MaterialTheme.colorScheme.primary`` in Compose.

   The ``compose`` section also contains an ``options`` section, which states
   which package a particular code symbol is in. The example above states that
   ``MaterialTheme`` is in the ``androidx.compose.material3`` package, which
   therefore should be imported in any generated code.

   Mapping typography styles is a little more involved than color styles. Here
   is the same example as above, but with typography styles added:

   .. code:: prettyprint

      {
        "figma": {
          "colors": {
            "my-app-theme/sys/light/primary": "myapp.sys.color.primary",
            "my-app-theme/sys/light/primary-container": "myapp.sys.color.primary-container",
            "my-app-theme/sys/light/background": "myapp.sys.color.background",
            "my-app-theme/sys/light/on-background": "myapp.sys.color.on-background",
            "my-app-theme/sys/dark/background": "myapp.sys.color.background",
            "my-app-theme/sys/dark/on-background": "myapp.sys.color.on-background"
          },
          "typography": {
            "symbols": {
              "my-app-theme/headline/large": "myapp.sys.typescale.headline-large",
              "my-app-theme/body/medium": "myapp.sys.typescale.body-medium"
            },
            "subproperties": {
              "fontFamily": "font",
              "fontWeight": "weight",
              "fontSize": "size",
              "letterSpacing": "tracking",
              "lineHeightPx": "line-height"
            }
          }
        },
        "compose": {
          "colors": {
            "myapp.sys.color.primary": "MaterialTheme.colorScheme.primary",
            "myapp.sys.color.primary-container": "MaterialTheme.colorScheme.primaryContainer",
            "myapp.sys.color.background": "MaterialTheme.colorScheme.background",
            "myapp.sys.color.on-background": "MaterialTheme.colorScheme.onBackground"
          },
          "typography": {
            "symbols": {
              "myapp.sys.typescale.headline-large": "MaterialTheme.typography.headlineLarge",
              "myapp.sys.typescale.body-medium": "MaterialTheme.typography.bodyMedium"
            },
            "subproperties": {
              "font": "fontFamily",
              "weight": "fontWeight",
              "size": "fontSize",
              "tracking": "letterSpacing",
              "line-height": "lineHeight"
            }
          },
          "options": {
            "packages": {
              "MaterialTheme": "androidx.compose.material3"
            }
          }
        }
      }

   The typography sections’ structure reflects the fact that a typography style
   is made up of many sub-properties. In Figma and Compose, a typography style
   includes the typeface’s name, font weight, size, letter spacing, and line
   height, among many others. Instead of needing to map each style’s individual
   sub-properties over and over again, we instead map the overall styles to
   tokens and themes, and then separately map each individual sub-property.

   The example above states that when a Figma text item with the style
   ``my-app-theme/headline/large`` is written to the UI Package definition file,
   the text’s font is ``myapp.sys.typescale.headline-large.font``, its size is
   ``myapp.sys.typescale.headline-large.size``, and so on. Then, when Compose
   code is generated, a ``RelayText`` composable (which wraps the
   `Text  <#text>`__ composable in Compose Material) is
   created, where the ``font`` parameter is
   ``MaterialTheme.typography.headlineLarge.fontFamily``, the ``size`` parameter
   is ``MaterialTheme.typography.headlineLarge.fontSize``, and so on.

   For examples of configuration files, you can look at the built-in Material 3
   and Material 2 Design Kit configurations, which use exactly the same format.
   You can download the files here:

   -  `Material Design Kit configuration <https://relay.material.io/static/assets/tutorial-files/MaterialStyleTranslations.zip>`__

   .. rubric:: Limitations
      :name: limitations

   Currently, there are several situations where styles are not translated to
   themes:

   -  Text styles that are applied to only a part of a text element (as
      described in `Multiple styles in text  <#multiple-styles-in-text>`__)
   -  If there are different styles applied to different variants of a
      component, only one style is translated.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Other considerations  <#other-considerations>`__
   -  `Kotlin for Jetpack Compose  <#kotlin>`__
   -  `Locally scoped data with CompositionLocal  <#compositionlocal>`__

Last updated 2024-03-25 UTC.

/Mapping components to existing code
====================================

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/mapping-components-to-existing-code?hl=en

.. container:: devsite-article-body clearfix

   Developers can customize the code generation process by providing a mapping
   between a UI Package and an existing code component instead of the generated
   code. This is beneficial when the existing implementation has features that
   cannot be achieved by the generated code such as animation or complex
   behavior (such as a drop down menu).

   Developers specify how to map components using a mapping file. A mapping file
   tells the code generator, at minimum, how to reach the target composable
   function so that the right client code can be created.

   |Mapped component overview diagram|

   Here is an example:

   In Figma, a designer creates a **Card** component that `contains an instance  <#nested-package-instances>`__ of a
   **Play Bar** component, packages both components, and sends them to a
   developer.

   When the developer imports the UI Packages from Figma, two directories are
   created in ``ui-packages``: ``card`` and ``play_bar``. When they build the
   project, two composable functions are created: ``Card`` and ``PlayBar``.
   Typically, because **Card** contains a **Play Bar** instance in Figma, in
   code the ``Card`` composable function contains a call to the ``PlayBar``
   composable.

   However, the designer and developer want ``Card`` to instead use an existing
   composable, ``MyExistingPlaybar``, which has functionality that is hard to
   describe in Figma. So the developer adds a mapping file called
   ``play_bar.json`` that maps the ``play_bar`` UI Package to
   ``MyExistingPlaybar``:

   .. code:: prettyprint

      {
          "target": "MyExistingPlaybar",
          "package": "com.example.myApp"
      }

   Now, when the developer builds the project, ``Card`` calls
   ``MyExistingPlaybar`` instead of ``PlayBar``. Note that ``MyExistingPlaybar``
   must have the same parameters as ``PlayBar`` (although there can be a few
   differences, as described in `Additional Directives <#additional-directives>`__ below).

   .. rubric:: Mapping file
      :name: mapping-file

   In your Android Studio projects, mapping files are added under
   ``ui-package-resources/mappings`` next to the ``ui-packages`` folder. Relay
   looks for mapping files during build.

   |Mapping file in the project view|

   .. rubric:: Generate a mapping file
      :name: generate-mapping-file

   Relay can generate a mapping file for any imported UI Package. Follow these
   steps:

   #. Right-click on the package folder or any file inside the target
      ``ui-package`` folder. Select **Generate mapping file**.

      |Generate mapping file affordance|

   #. Configure the following options in the dialog:

      |Dialog for generating mapping files|

      -  **File location:** Sets the location for the generated mapping file.

      -  **Target composable:** Sets the custom composable that is used instead
         in place of the generated composable. You have the option of using an
         existing composable or creating a new one from the dialog. Creating a
         new composable creates a composable with the same parameters as defined
         in the UI package.

      **Note:**\  The target composable should start with a capital letter.

      -  **Generated file:** Sets the ``generateImplementation`` and
         ``generatePreview`` options in the mapping file. See `Mapping file contents <#mapping-file-contents>`__ below for more details.

   #. Click **Generate mapping file**. A new mapping file is created inside of
      ``ui-package-resources/mapping`` folder with the specified configurations.

   You can also open the **Generate mapping file** dialog from the Relay package
   module UI using these steps:

   #. Click any file for a UI package inside the target ``ui-package`` folder.

   #. If the Relay tool window does not open automatically, click the Relay icon
      to open the window.

   #. Click the **Generate mapping file** button under **Package Options**.

      |image-generate-mapping-file-button|

      **Note:**\  If a mapping file exists for the selected UI Package, a link
      to open the file is displayed instead.

   .. rubric:: Mapping file name
      :name: mapping-file-name

   The name of a given mapping file must match the name of the UI Package folder
   for the component it replaces. So ``play_bar.json`` maps the UI Package in
   the ``ui-packages/mappings`` folder to an existing code component.

   .. rubric:: Mapping file contents
      :name: mapping-file-contents

   The mapping file contains the following properties:

   -  **target:** (Required) The name of your custom composable function. By
      default, this is the name of the function created by generated code.

      .. code:: prettyprint

         "target" : "CustomComposableName"

   -  **package:** (Required) Name of the package that your custom composable
      sits in. By default, this is the package of the function created by
      generated code.

      .. code:: prettyprint

         "package" : "com.example.podcastapp.ui.components"

   -  **generateImplementation:** (Optional) true or false. If true, an
      implementation of this UI Package is still created in the generated code
      file. If false, the implementation isn't created. By default, this is
      true.

      .. code:: prettyprint

         "generateImplementation" : true

   -  **generatePreviews:** (Optional) true or false. If true, a preview of the
      mapped custom component is created in the generated code file. If false,
      no preview is created. By default, this is true.

      .. code:: prettyprint

         "generatePreviews" : true

   .. rubric:: Mapped variants
      :name: mapped-variants

   If a Figma component has variants, then the generated composable contains
   enum parameters that encode the variant (as described in the `Handling Design Variants  <#design-variants>`__ tutorial). If
   you want to map a Figma component with variants to existing code, it must be
   mapped to a composable that takes the same parameters as the generated
   composable. For example, for a Figma component called **Chip** with a variant
   whose property is **ChipType, Chip's** generated composable signature looks
   like this:

   .. code:: prettyprint

      @Composable
      fun Chip(
          modifier: Modifier = Modifier,
          chipType: ChipType = ChipType.Red,
          chipText: String
      ) { ... }

   If you want to have the Chip Figma component map to an existing ``MyChip``
   composable, then the signature for ``MyChip`` must have the same signature as
   the generated composable (assuming no `additional directives <#additional-directives>`__ are specified). Conceptually, this
   suggests that the existing code component is capable of the same design
   variants as the Figma component.

   .. rubric:: Additional directives
      :name: additional-directives

   For example, if the composable function you want to target has the following
   signature:

   .. code:: prettyprint

      @Composable
      fun MyChip(
          modifier: Modifier = Modifier,
          chipType: ChipType = ChipType.Red,
          description: String  // instead of chipText
      ) { ... }

   You can add a ``fieldMappings`` block to the mapping file that affects how
   parameters are mapped. In this case, it contains a mapping from the
   ``chipText`` parameter in the ``Chip`` to the ``description`` parameter in
   ``MyChip``.

   .. code:: prettyprint

      {
          "target": "MyChip",
          "package": "com.example.myApp",
          "fieldMappings": [
              {
                  "type": "parameter",
                  "source": "chipText",
                  "target": "description"
              }
          ]
      }

   The types for the ``fieldMappings`` block include:

   -  ``parameter``: Maps a UI Package field to a code parameter.

      -  ``source``: Name of parameter as specified in the UI Package.
      -  ``target``: Name of parameter as specified in the target code
         component.

   -  ``lambda``: Maps a UI Package field to a content lambda.

      -  ``source``: Name of parameter as specified in the UI Package.
      -  ``target``: Name of parameter as specified in the target code
         component.

   -  ``modifier``: Maps a UI Package field to a
      `modifier  <#modifiers>`__ method.

      **Note:**\  This mapping type is being incubated, in particular the
      handling of receiver scopes.

      -  ``source``: Name of parameter as specified in the UI Package.
      -  ``method``: Method on the Modifier object that should be invoked in
         generated code.
      -  ``parameter``: Name of parameter within the specified Modifier method.
      -  ``library``: The qualified package name to import to access the
         Modifier method.
      -  ``scope``: One of two values to indicate the scope of the Modifier:
      -  ``any``: The modifier can be used in any receiver scope.
      -  ``relay``: The modifier must be used in the receiver scope of Relay's
         ``RelayContainer`` object.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off \* `Build adaptive layouts  <#adaptive>`__ \* `Nested package instances  <#nested-package-instances>`__
      \* `Releases  <#releases>`__

Last updated 2024-03-25 UTC.

.. |Mapped component overview diagram| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/mapping-components-to-existing-code/diagram.png
   :width: 100.0%
.. |Mapping file in the project view| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/mapping-components-to-existing-code/mapping-file.png
   :width: 40.0%
.. |Generate mapping file affordance| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/mapping-components-to-existing-code/generate-mapping-file-context.png
   :width: 50.0%
.. |Dialog for generating mapping files| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/mapping-components-to-existing-code/generate-mapping-file-dialog.png
   :width: 75.0%
.. |image-generate-mapping-file-button| image:: https://developer.android.google.cn/static/develop/ui/compose/tooling/relay/images/mapping-components-to-existing-code/generate-mapping-file-button.png
   :width: 50.0%

/Releases
=========

.. https://developer.android.google.cn/develop/ui/compose/tooling/relay/releases?hl=en

.. container:: devsite-article-body clearfix

   .. rubric:: Alpha v0.3.12 (April 2024)
      :name: apr-2024

   **Bug Fixes**

   -  Figma Plugin

      -  Fixed regression where the Figma plugin would take a long time to load.
      -  Fixed issue when the Figma plugin would error if there is an image fill
         in a vector in the file.
      -  Fixed issue where the parameter properties drop-down contained invalid
         entries.
      -  Fixed issue where the "Send usage data to Google" button did not
         re-render after being toggled.
      -  Fixed issue where the Figma plugin would show a blank parameter details
         view if the parameter was updated by a different Figma user.
      -  Fixed issue where the Figma plugin wouldn't respond when there are
         components with certain specific unsupported layer types.
      -  Fixed issue where copying and pasting multiple Figma components while
         the plugin is open would cause an error.

   -  Android Studio Plugin

      -  Added support for Android Studio Iguana and Koala
      -  Added support for Figma's new URL format

   .. rubric:: Alpha v0.3.11 (January 2024)
      :name: jan-2024

   Relay v0.3.11 brings significant performance enhancements to the Figma
   plugin, particularly on large Figma files. Collaborate seamlessly as you can
   now see real time changes instantly made by others in the Figma plugin.
   Additionally, we've added support for scrolling inside rows and columns. This
   release also includes a range of bug fixes to the Figma and Android Studio
   plugins.

   **New Features**

   -  Improved performance - enjoy lightning-fast performance for an
      uninterrupted workflow. You'll especially notice this when working with
      large files.
   -  Multi-Player Editing - See your teammates' changes instantly with our new
      multiplayer feature. No more manual refreshes or waiting your turn. Relay
      now supports real-time, multiplayer collaboration within Figma.
   -  Figma Scroll Property - Relay now supports vertical scrolling on columns
      and horizontal scrolling on rows. The scroll property is now carried over
      to the generated code.

   **Bug Fixes**

   -  Figma Plugin

      -  Fixed issue where values couldn't be set on custom parameters that are
         exposed from nested instances.
      -  Fixed issue where Relay plugin would error if a variant name is invalid
         in Figma.
      -  Fixed splash screen that was missing a title.
      -  Fixed issue where image content parameters couldn't be added to frames
         with image fills.
      -  Fixed issue where when parameters are added to multiple variants, only
         one of the variants is shown in the Layer section of the parameter
         details page. Now all variants bound are shown.
      -  Fixed issue where packages can be removed from Dev Mode, a view only
         mode.
      -  Fixed issue where "share with developer" section is enabled in Dev
         Mode, a view only mode.

   -  Android Studio Plugin and Generated Code

      -  When Android Studio imports fail, Relay now produces more informative
         error messages.
      -  Fixed issue where Relay would cause an IDE error if it couldn't render
         a preview for a UI package.
      -  Fixed issue where variants that start with numbers would generate
         incorrect code.
      -  Fixed error message to be more informative when font fails to download
         from a Figma component
      -  Fixed issue where banner is not responsive to resize.
      -  Fixed issue where mapping targets with lower case causes an error
         during build
      -  Fixed bug where generated code would sometimes not set parameter values
         when calling other generated Composables.
      -  Relay now supports Gradle configuration cache
      -  Relay header now has an accessible label
      -  General stability improvements to the Android Studio plugin

   .. rubric:: Alpha v0.3.10 (October 2023)
      :name: oct-2023

   Relay v0.3.10 includes several bug fixes in the Figma and Android Studio
   plugins.

   **Bug fixes**

   -  Figma Plugin

      -  The Figma plugin now displays all the variants to which a parameter is
         bound.
      -  The share button no longer shows when the Figma plugin is opened in
         developer mode or when there are no packages to be shared.
      -  Packages cannot be removed in the read-only developer mode.
      -  UI package details are no longer shown when a component's parent layer
         is selected.
      -  The errors and warning page title no longer overlaps with the list when
         scrolling.

   -  Android Studio

      -  The preview dimensions are calculated correctly in the generated code.

   .. rubric:: Alpha v0.3.09 (September 2023)
      :name: sep-2023

   Relay v0.3.09 implements a walkthrough for creating UI packages using the
   Figma plugin, and adds support for packaging multiple Figma components at the
   same time. The Figma plugin has improved performance, while the Android
   Studio plugin includes improvements to the mapping workflow.

   This release also includes bug fixes around Figma parameters and Android
   Studio import and build errors.

   **Android Studio compatibility**

   -  Relay now requires Android Studio Flamingo or later. Update if you are
      using an earlier version.
   -  Relay now requires Android Gradle plugin 8.0 or later. `Follow the instructions  <#run-upgrade-assistant>`__ to
      upgrade your Android Gradle plugin.

   **New features**

   -  There's a new instruction walkthrough in the Figma Plugin to guide you
      through the process of creating a UI package in your Figma file.
   -  Using the Figma plugin, you can package multiple Figma components at the
      same time.
   -  In Android Studio, developers can search for available composables to map
      to UI packages in the mapping dialog.
   -  Developers can generate stub ``@Composable`` mapping targets for UI
      packages using the mapping dialog.
   -  The performance of the Figma plugin has been improved. Opening the plugin
      or changing selections is up to 2x faster on large files.
   -  The Relay Figma plugin `declares its network access policy <https://help.figma.com/hc/en-us/articles/360042532714-Use-plugins-in-files#01H8M501RQ5KFB7BSAVSQ48SVV>`__.
      Relay's community page reports "restricted" network access (rather than
      "unknown").

   **Bug fixes**

   -  Figma Plugin

      -  Figma plugin correctly detects and errors if there are duplicate
         parameter names with different parameter types.
      -  Fixed an issue where the Figma plugin would steal keyboard focus from
         the Figma canvas, depending on canvas selection.

   -  Android Studio

      -  Fixed an issue where builds were failing on Linux and macOS if the
         import operation happened on Windows, due to differences in path
         formats.
      -  Fixed an issue where import would fail in Android Studio if a component
         had only numbers in the summary or description field.
      -  Fixed an issue where an import failed in Android Studio if a component
         had a preview image with 0 height or width size.
      -  Fixed an issue where UI packages sometimes couldn't be updated in
         Android Studio on Windows.
      -  Fixed an issue where the Android Studio import dialog would stop
         responding on import when a styles translation file was provided.
      -  Fixed an issue where an import failed if a value was not provided to a
         custom parameter for a nested component instance.

   .. rubric:: Alpha v0.3.08 (July 2023)
      :name: jul-2023

   Relay v0.3.08 makes it even easier to work with mapped components. You can
   now use the Relay for Android Studio plugin UI to generate and manage mapping
   files in your projects. This release also includes multiple bug fixes for
   generated code quality and SVG rendering.

   **Feature Highlights**

   -  We've added a new dialog for generating mapping files in Android Studio.
      This UI makes it simple to set up and configure component mappings for UI
      Packages.

   -  You can now create and open package mapping files from the UI Package
      detail view in Android Studio.

   **Bug Fixes**

   -  Figma Plugin

      -  Fixed issue where duplicate layer errors were not reported correctly.
      -  Added additional UI enhancements in support of `Figma DevMode <https://www.figma.com/dev-mode/>`__.

   -  Android Studio

      -  Fixed an issue where Relay did not build properly on Windows and Linux.
      -  Fixed several issues with SVG rendering.
      -  Fixed an issue where ``null`` sizes caused errors in code generation.
      -  Fixed an issue where ``Images`` were not properly recognized in code
         generation.

   .. rubric:: Alpha 0.3.07 (June 2023)
      :name: jun-2023

   Relay v0.3.07 implements UI support for the new Figma developer mode
   announced at the Figma Config Conference. This release also includes multiple
   bug fixes that further enhance the performance, usability, and stability of
   the Relay Figma plugin and Android Studio plugin.

   **Feature Highlights**

   The Figma plugin now features a developer mode user interface; this
   integrates directly with Figma's new developer view.

   **Bug Fixes**

   -  Figma Plugin

      -  Fixed issue with improper focus after activating the "Create Relay
         Component" button.
      -  Fixed issue that is observed when tab-navigation back to Relay heading
         after navigating away from it.
      -  Menu popup button next to the "Property" field is now announced
         properly as a menu popup, as opposed to selectable text.
      -  The errors and warning link now handles focus appropriately.
      -  Updated error page user interface.

   -  Android Studio Plugin

      -  Scrollable regions have been fixed to have accessible names that
         clearly identify the type of content in those regions. This helps
         screen reader users understand if they want to interact further with
         that region, without actually having to navigate within it.

   .. rubric:: Alpha 0.3.06 (April 2023)
      :name: apr-2023

   For Relay v0.3.06, we've focused on resolving performance and usability
   issues. Changes include UI usability features and improvements that
   streamline the user experience when importing UI component packages. Compose
   1.2 is now the minimum required version for Relay. This change is needed to
   align the interpretation of line height between Figma and Compose.

   **Feature Highlights**

   We've updated the `playground file <https://www.figma.com/community/plugin/1041056822461507786/Relay-for-Figma>`__
   in the Relay plugin for Figma with new exercises and examples to aid
   designers in familiarizing themselves with using Relay.

   **Notes**

   The new minimum version of Compose is now v1.2

   **Bug Fixes**

   -  Reduced incongruity of layouts between Figma and Compose due to different
      interpretations of line height between the two applications.

      -  Relay now requires Compose 1.2 to apply this fix.

   -  "Fix it" button on the Figma plugin is now properly positioned.
   -  The Figma plugin now only checks for duplicate package names on the
      current page, not the entire Figma file.
   -  Resolved issue in Figma plugin where focus does not move to the first
      element in the application on launch.
   -  Improved tooltip accessibility for screen reader and keyboard users when
      importing UI packages with the Android Studio plugin.
   -  Improved launch speed of Figma plugin.
   -  Resolved issue with the Figma plugin's "Fix It" feature not properly
      addressing solid fill areas. It now takes the first color of the gradient
      or alternatively, black, as fallback.
   -  Resolved issue where The "Import UI packages" text was not passed to
      screen readers.
   -  Fixed edge case that caused spurious "file not found" errors during UI
      package import using the Android Studio plugin.
   -  Fixed issue where build warnings were not displayed properly in Android
      Studio.

   .. rubric:: Alpha 0.3.05 (March 2023)
      :name: mar-2023

   **New Features**

   -  Generate mapping files

      -  Developers can now right-click a UI package in Android Studio and
         select "Generate mapping file" to create a default mapping file. This
         file is a starting point which the user can edit to set up their own
         custom component mapping. A README.md file is also generated with
         instructions for how to use mapping files. If a mapping file already
         exists for a UI package then the context menu instead says "Open
         mapping file".
      -  Three new custom parameter types have been added to allow mapped
         components to report when values change.

   -  From the Issues page in the Figma plugin, designers can apply one-click
      fixes to a packaged component for seamless issue resolution. This release
      offers solutions to the following three distinct problems:

      -  Replace unsupported gradients in fills with a solid fill.
      -  Replace unsupported gradients in strokes with a solid fill.
      -  Remove unsupported image in fill.

   **Bug Fixes**

   -  Generated code and translation issues

      -  Fixed cases where Figma auto layout frames with positioned children
         that have opaque or translucent backgrounds would have double
         backgrounds.
      -  Fixed issue with boolean (show/hide) component properties not being
         translated on component instance layers.
      -  Fixed issue where tap handers would respond slowly in generated code.
      -  Fixed issue where interaction handlers in nested Figma components were
         not properly translated.
      -  Fixed issue with nested components not receiving the correct
         layout-related and tap handler values.
      -  Fixed issue with using tap callbacks on multiple Relay components where
         some callbacks would be invoked with the wrong arguments.

   -  Android Studio experience

      -  When changes are made in styles translation files, Android Studio now
         rebuilds all UI packages.
      -  Fixed issue where import could fail due to a missing preview image,
         such as when a network error occurred.
      -  Relay now ignores empty ``ui-packages`` subfolders during builds.
      -  Added the ``ui-package-resources`` folder to Android Studio's Android
         view.

   -  Figma and Figma plugin experience

      -  Fixed issue with components with design variants where custom
         parameters were not reliably be exposed.
      -  Fixed issue where removing packaging in Figma plugin from components
         did not remove all Relay metadata.
      -  Fixed issue where Figma component properties of unpackaged components
         were automatically shown in parent component when added to the parent
         component.

   -  A11y improvements

      -  Fixed issue where "Fetching UI Components" message during import in
         Android Studio was not visible to screen readers.
      -  "Set Figma Access Token" dialog now returns list items when using
         VoiceOver.
      -  Read-only input fields in the Figma plugin now have not-allowed cursors
         to indicate that it's non-editable.

   **Improvements**

   -  Android Studio plugin now remembers theme and style transition
      information, so this doesn't need to be specified on every import.
   -  Improved readability of the Gradle output by outputting all messages
      associated with one operation together; previously, they could be
      interleaved with messages from other operations. In addition, the default
      logging level is now ``INFO`` instead of ``LIFECYCLE``.
   -  Generated composable functions now contain default values for all
      parameters.

   .. rubric:: Alpha 0.3.04 (February 2023)
      :name: feb-2023

   **New Features**

   -  The "Share with developer" page in Figma plugin was revamped to allow you
      to search for any blocking issues on your packaged components. If
      everything checks out, then you can save a new entry in the version
      history from the plugin UI without any hassle! See the `Share UI Packages  <#share-ui-packages>`__ page for
      more details
   -  Relay now supports `Figma component properties <https://help.figma.com/hc/en-us/articles/5579474826519-Explore-component-properties>`__.
      Figma component properties are very similar to `Relay parameters  <#content-parameters>`__;
      Relay now recognizes component properties as their parameter equivalent
      where applicable, and has expanded support for component properties for
      cases where no equivalent parameter exists. See our `Figma component properties documentation  <#figma-component-properties>`__
      for more details.
   -  Conflicting imports in Relay's implementation are now resolved, so Jetpack
      Compose applications can now use both Relay and Material 3 in the same
      project.

   **Bug Fixes**

   -  Improved the performance of the Figma for Relay plugin on large Figma
      documents.
   -  Long layer names correctly wraps in the Relay for Figma plugin.
   -  Several accessibility fixes have been applied to the Android Studio
      plugin:
   -  Persistent labels are now added to Android Studio import dialog.
   -  A11y labels have been added to banner and component images in the Android
      Studio import dialog.
   -  Fixed the translation of text content containing dollar signs. Previously,
      this would cause a build error.
   -  Fixed an issue with fetching a remote component without a named version:
      If a remote component has no named version, the latest remote component is
      fetched.
   -  Fixed the translation of components whose top-level layers are set to auto
      layout with an absolute positioned child. This would previously cause
      import or build errors.
   -  Custom parameters allows "Type" to be edited instead of "Properties"
      (since custom parameters are not associated with a layer property).
   -  Fixed issue in Figma UI representing deeply nested components with
      children parameters.
   -  Fixed issue where deeply nested components with children parameters may
      fail to import.

   .. rubric:: Alpha 0.3.02 (December 2022)
      :name: dec-2022

   **Bug Fixes**

   -  Autolayout frames with positioned children are now handled correctly when
      set to "hug".
   -  Autolayout frames with positioned children are now handled correctly at
      the root of a component.

   .. rubric:: Alpha 0.3.01 (November 2022)
      :name: nov-2022

   Android Studio plugin is now supported on Android Studio Electric Eel.

   **Bug Fixes**

   -  Windows: style mapping files can now be located on different drives than
      Android Studio. This previously blocked the import operation.
   -  The Create UI Package button is now only enabled when a single valid UI
      package is selected in the Figma plugin.
   -  Users using larger font sizes (For example, 16+ in ``AppleSystemUIFont``)
      now no longer see text that is cut off in the Settings dialog of the
      Android Studio plugin.
   -  The Import UI Packages menu item in Android Studio is now always enabled,
      unless your project has more than one module and either no file is
      selected or the selected file is not in any module.
   -  The Figma plugin now correctly handles adding parameters to a component
      that uses variants and contains multiple instances of child components.

   .. rubric:: Alpha 0.3.00 (October 2022)
      :name: oct-2022

   Android Developer Summit Alpha launch

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Understand UI Package & Generated Code  <#understand-ui-package>`__ \*
      `Android Studio workflow  <#android-studio-workflow>`__ \*
      `Limitations and troubleshooting  <#limitations-and-troubleshooting>`__

Last updated 2024-04-30 UTC.

/Window Insets
==============

.. https://developer.android.google.cn/develop/ui/compose/layouts/insets?hl=en

.. container:: devsite-article-body clearfix

   .. container:: video-wrapper

   The Android platform is responsible for drawing the system UI, such as the
   status bar and navigation bar. This system UI is displayed regardless of
   which app the user is using.
   `WindowInsets  <#WindowInsets>`__
   provides information about the system UI to ensure that your app draws in the
   correct area and your UI isn't obscured by the system UI.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/layouts/insets/e2e-intro.gif
      name: image-1
      :alt: Going edge-to-edge to draw behind the system bars
      :width: 310px

      **Figure 1.** Going edge-to-edge to draw behind the system bars

   By default, your app's UI is restricted to being laid out within the system
   UI, like the status bar and navigation bar. This ensures that your app's
   content isn't obscured by system UI elements.

   However, we recommend apps to opt-in to displaying in these areas where
   system UI is also being displayed, which results in a more seamless user
   experience and allows your app to take full advantage of the window space
   available to it. This also allows apps to animate together with the system
   UI, especially when showing and hiding the software keyboard.

   Opting in to displaying in these regions and displaying content behind the
   system UI is called *going edge-to-edge*. On this page, you learn about the
   different type of insets, how to opt-in to going edge-to-edge, and how to use
   the inset APIs to animate your UI and avoid obscuring parts of your app.

   .. rubric:: Inset fundamentals
      :name: inset-fundamentals

   When an app goes edge-to-edge, you need to ensure that important content and
   interactions are not obscured by the system UI. For example, if a button is
   placed behind the navigation bar, the user may not be able to click it.

   The size of the system UI and information about where it is placed is
   specified via *insets*.

   Each portion of the system UI has a corresponding type of inset that
   describes its size and where it is placed. For example, status bar insets
   provide the size and position of the status bar, whereas the navigation bar
   insets provide the size and position of the navigation bar. Each type of
   inset consists of four pixel dimensions: top, left, right, and bottom. These
   dimensions specify how far the system UI extends from the corresponding sides
   of the app's window. To avoid overlapping with that type of system UI,
   therefore, app UI must be inset by that amount.

   These built-in Android inset types are available through
   `WindowInsets  <#WindowInsets>`__:

   .. list-table::

      - 

         - `WindowInsets.statusBars  <#statusBars>`__
         - The insets describing the status bars. These are the top system UI
            bars containing notification icons and other indicators.
      - 

         - `WindowInsets.statusBarsIgnoringVisibility  <#statusBarsIgnoringVisibility>`__
         - The status bar insets for when they are visible. If the status bars
            are currently hidden (due to entering immersive full screen mode),
            then the main status bar insets will be empty, but these insets will
            be non-empty.
      - 

         - `WindowInsets.navigationBars  <#navigationBars>`__
         - The insets describing the navigation bars. These are the system UI
            bars on the left, right, or bottom side of the device, describing
            the taskbar or navigation icons. These can change at runtime based
            on the user's preferred navigation method and interacting with the
            taskbar.
      - 

         - `WindowInsets.navigationBarsIgnoringVisibility  <#navigationBarsIgnoringVisibility>`__
         - The navigation bar insets for when they are visible. If the
            navigation bars are currently hidden (due to entering immersive full
            screen mode), then the main navigation bar insets will be empty, but
            these insets will be non-empty.
      - 

         - `WindowInsets.captionBar  <#captionBar>`__
         - The inset describing the system UI window decoration if in a freeform
            window, like top title bar.
      - 

         - `WindowInsets.captionBarIgnoringVisibility  <#captionBarIgnoringVisibility>`__
         - The caption bar insets for when they are visible. If the caption bars
            are currently hidden, then the main caption bar insets will be
            empty, but these insets will be non-empty.
      - 

         - `WindowInsets.systemBars  <#systemBars>`__
         - The union of the system bar insets, which include the status bars,
            navigation bars, and caption bar.
      - 

         - `WindowInsets.systemBarsIgnoringVisibility  <#systemBarsIgnoringVisibility>`__
         - The system bar insets for when they are visible. If the system bars
            are currently hidden (due to entering immersive full screen mode),
            then the main system bar insets will be empty, but these insets will
            be non-empty.
      - 

         - `WindowInsets.ime  <#ime>`__
         - The insets describing the amount of space on the bottom that the
            software keyboard occupies.
      - 

         - `WindowInsets.imeAnimationSource  <#imeAnimationSource>`__
         - The insets describing the amount of space that the software keyboard
            occupied *before* the current keyboard animation.
      - 

         - `WindowInsets.imeAnimationTarget  <#imeAnimationTarget>`__
         - The insets describing the amount of space that the software keyboard
            will occupy *after* the current keyboard animation.
      - 

         - `WindowInsets.tappableElement  <#tappableElement>`__
         - A type of insets describing more detailed information about the
            navigation UI, giving the amount of space where "taps" will be
            handled by the system, and not the app. For transparent navigation
            bars with gesture navigation, some app elements can be tappable
            through the system navigation UI.
      - 

         - `WindowInsets.tappableElementIgnoringVisibility  <#tappableElementIgnoringVisibility>`__
         - The tappable element insets for when they are visible. If the
            tappable elements are currently hidden (due to entering immersive
            full screen mode), then the main tappable element insets will be
            empty, but these insets will be non-empty.
      - 

         - `WindowInsets.systemGestures  <#systemGestures>`__
         - The insets representing the amount of insets where the system will
            intercept gestures for navigation. Apps can manually specify
            handling a limited amount of these gestures via
            `Modifier.systemGestureExclusion  <#systemGestureExclusion>`__.
      - 

         - `WindowInsets.mandatorySystemGestures  <#mandatorySystemGestures>`__
         - A subset of the system gestures that will always be handled by the
            system, and which can't be opted out via
            `Modifier.systemGestureExclusion  <#systemGestureExclusion>`__.
      - 

         - `WindowInsets.displayCutout  <#displayCutout>`__
         - The insets representing the amount of spacing needed to avoid
            overlapping with a display cutout (notch or pinhole).
      - 

         - `WindowInsets.waterfall  <#waterfall>`__
         - The insets representing the curved areas of a waterfall display. A
            waterfall display has curved areas along the edges of the screen
            where the screen begins to wrap along the sides of the device.

   These types are summarized by three "safe" inset types that ensure content
   isn't obscured:

   -  `WindowInsets.safeDrawing  <#safeDrawing>`__
   -  `WindowInsets.safeGestures  <#safeGestures>`__
   -  `WindowInsets.safeContent  <#safeContent>`__

   These "safe" inset types protect content in different ways, based on the
   underlying platform insets:

   -  Use
      `WindowInsets.safeDrawing  <#safeDrawing>`__
      to protect content that shouldn't be drawn underneath any system UI. This
      is the most common usage of insets: to prevent drawing content that is
      obscured by the system UI (either partially or completely).
   -  Use
      `WindowInsets.safeGestures  <#safeGestures>`__
      to protect content with gestures. This avoids system gestures clashing
      with app gestures (such as those for bottom sheets, carousels, or in
      games).
   -  Use
      `WindowInsets.safeContent  <#safeContent>`__
      as a combination of
      `WindowInsets.safeDrawing  <#safeDrawing>`__
      and
      `WindowInsets.safeGestures  <#safeGestures>`__
      to ensure content has no visual overlap and no gesture overlap.

   .. rubric:: Insets setup
      :name: insets-setup

   To allow your app full control over where it draws content, follow these
   setup steps. Without these steps, your app may draw black or solid colors
   behind the system UI, or not animate synchronously with the software
   keyboard.

   #. Call
      `enableEdgeToEdge()  <#enableEdgeToEdge>`__
      in
      `Activity.onCreate  <#onCreate>`__.
      This call requests that your app display behind the system UI. Your app
      will then be in control of how those insets are used to adjust the UI.

   #. Set ``android:windowSoftInputMode="adjustResize"`` in your Activity's
      ``AndroidManifest.xml`` entry. This setting allows your app to receive the
      size of the software IME as insets, which you can use to pad and lay out
      content appropriately when the IME appears and disappears in your app.

      .. code:: prettyprint

         <!-- in your AndroidManifest.xml file: -->
         <activity
           android:name=".ui.MainActivity"
           android:label="@string/app_name"
           android:windowSoftInputMode="adjustResize"
           android:theme="@style/Theme.MyApplication"
           android:exported="true">

   .. rubric:: Compose APIs
      :name: compose-apis

   Once your Activity has taken control of handling all insets, you can use
   Compose APIs to ensure that content isn't obscured and interactable elements
   don't overlap with the system UI. These APIs also synchronize your app's
   layout with inset changes.

   For example, this is the most basic method of applying the insets to the
   content of your entire app:

   .. code:: prettyprint

      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)

          enableEdgeToEdge()

          setContent {
              Box(Modifier.safeDrawingPadding()) {
                  // the rest of the app
              }
          }
      }InsetsSnippets.kt

   This snippet applies the
   `safeDrawing  <#safeDrawing>`__
   window insets as padding around the entire content of the app. While this
   ensures that interactable elements don't overlap with the system UI, it also
   means that none of the app will draw behind the system UI to achieve an
   edge-to-edge effect. To make full use of the entire window, you need to
   fine-tune where the insets are applied on a screen-by-screen or
   component-by-component basis.

   All of these inset types are animated automatically with IME animations
   backported to API 21. By extension, all of your layouts using these insets
   are also automatically animated as the inset values change.

   There are two primary ways to use these inset types to adjust your Composable
   layouts: padding modifiers and inset size modifiers.

   .. rubric:: Padding modifiers
      :name: padding-modifiers

   `Modifier.windowInsetsPadding(windowInsets: WindowInsets)  <#windowInsetsPadding>`__
   applies the given window insets as padding, acting just like
   `Modifier.padding  <#padding>`__
   would. For example,
   ``Modifier.windowInsetsPadding(WindowInsets.safeDrawing)`` applies the safe
   drawing insets as padding on all 4 sides.

   There are also several built-in utility methods for the most common inset
   types.
   `Modifier.safeDrawingPadding()  <#safeDrawingPadding>`__
   is one such method, equivalent to
   ``Modifier.windowInsetsPadding(WindowInsets.safeDrawing)``. There are
   analogous modifiers for the other inset types.

   .. rubric:: Inset size modifiers
      :name: inset-size

   The following modifiers apply an amount of window insets by setting the size
   of the component to be the size of the insets:

   .. list-table::

      - 

         - `Modifier.windowInsetsStartWidth(windowInsets: WindowInsets)  <#windowInsetsStartWidth>`__
         - Applies the start side of windowInsets as the width (like
            ``Modifier.width``)
      - 

         - `Modifier.windowInsetsEndWidth(windowInsets: WindowInsets)  <#windowInsetsEndWidth>`__
         - Applies the end side of windowInsets as the width (like
            ``Modifier.width``)
      - 

         - `Modifier.windowInsetsTopHeight(windowInsets: WindowInsets)  <#windowInsetsTopHeight>`__
         - Applies the top side of windowInsets as the height (like
            ``Modifier.height``)
      - 

         - `Modifier.windowInsetsBottomHeight(windowInsets: WindowInsets)  <#windowInsetsBottomHeight>`__
         - Applies the bottom side of windowInsets as the height (like
            ``Modifier.height``)

   These modifiers are especially useful for sizing a ``Spacer`` that takes up
   the space of insets:

   .. code:: prettyprint

      LazyColumn(
          Modifier.imePadding()
      ) {
          // Other content
          item {
              Spacer(
                  Modifier.windowInsetsBottomHeight(
                      WindowInsets.systemBars
                  )
              )
          }
      }InsetsSnippets.kt

   .. rubric:: Inset consumption
      :name: inset-consumption

   The inset padding modifiers (``windowInsetsPadding`` and helpers like
   ``safeDrawingPadding``) automatically consume the portion of the insets that
   are applied as padding. While going deeper into the composition tree, nested
   inset padding modifiers and the inset size modifiers know that some portion
   of the insets have already been consumed by outer inset padding modifiers,
   and avoid using the same portion of the insets more than once which would
   result in too much extra space.

   Inset size modifiers also avoid using the same portion of insets more than
   once if insets have already been consumed. However, since they are changing
   their size directly, they don't consume insets themselves.

   As a result, nesting padding modifiers automatically change the amount of
   padding applied to each composable.

   Looking at the same ``LazyColumn`` example as before, the ``LazyColumn`` is
   being resized by the ``imePadding`` modifier. Inside the ``LazyColumn``, the
   last item is sized to be the height of the bottom of the system bars:

   .. code:: prettyprint

      LazyColumn(
          Modifier.imePadding()
      ) {
          // Other content
          item {
              Spacer(
                  Modifier.windowInsetsBottomHeight(
                      WindowInsets.systemBars
                  )
              )
          }
      }InsetsSnippets.kt

   When the IME is closed, the ``imePadding()`` modifier applies no padding,
   since the IME has no height. Since the ``imePadding()`` modifier is applying
   no padding, no insets are being consumed, and the height of the ``Spacer``
   will be the size of the bottom side of the system bars.

   When the IME opens, the IME insets animate to match the size of the IME, and
   the ``imePadding()`` modifier begins applying bottom padding to resize the
   ``LazyColumn`` as the IME opens. As the ``imePadding()`` modifier begins
   applying bottom padding, it also starts consuming that amount of insets.
   Therefore, the height of the ``Spacer`` starts to decrease, as part of the
   spacing for the system bars has already been applied by the ``imePadding()``
   modifier. Once the ``imePadding()`` modifier is applying an amount of bottom
   padding that is larger than the system bars, the height of the ``Spacer`` is
   zero.

   When the IME closes, the changes happen in reverse: The ``Spacer`` starts to
   expand from a height of zero once the ``imePadding()`` is applying less than
   the bottom side of the system bars, until finally the ``Spacer`` matches the
   height of the bottom side of the system bars once the IME is completely
   animated out.

   .. container:: float
      :name: image-2

   **Caution:**\  Use ``Spacer`` instead of ``contentPadding`` to draw the last
   ``TextField`` in a ``LazyColumn`` above the system bars. Otherwise, the IME
   may hide the ``TextField``.
   This behavior is accomplished through communication between all
   ``windowInsetsPadding`` modifiers, and can be influenced in a couple of other
   ways.

   `Modifier.consumeWindowInsets(insets: WindowInsets)  <#consumeWindowInsets>`__
   also consumes insets in the same way as
   `Modifier.windowInsetsPadding  <#windowInsetsPadding>`__,
   but it doesn't apply the consumed insets as padding. This is useful in
   combination with the inset size modifiers, to indicate to siblings that a
   certain amount of insets have already been consumed:

   .. code:: prettyprint

      Column(Modifier.verticalScroll(rememberScrollState())) {
          Spacer(Modifier.windowInsetsTopHeight(WindowInsets.systemBars))

          Column(
              Modifier.consumeWindowInsets(
                  WindowInsets.systemBars.only(WindowInsetsSides.Vertical)
              )
          ) {
              // content
              Spacer(Modifier.windowInsetsBottomHeight(WindowInsets.ime))
          }

          Spacer(Modifier.windowInsetsBottomHeight(WindowInsets.systemBars))
      }InsetsSnippets.kt

   `Modifier.consumeWindowInsets(paddingValues: PaddingValues)  <#consumeWindowInsets>`__
   behaves very similarly to the version with a
   `WindowInsets  <#WindowInsets>`__
   argument, but takes an arbitrary
   `PaddingValues  <#PaddingValues>`__
   to consume. This is useful for informing children when padding or spacing is
   provided by some other mechanism than the inset padding modifiers, such as an
   ordinary ``Modifier.padding`` or fixed height spacers:

   .. code:: prettyprint

      @OptIn(ExperimentalLayoutApi::class)
      Column(Modifier.padding(16.dp).consumeWindowInsets(PaddingValues(16.dp))) {
          // content
          Spacer(Modifier.windowInsetsBottomHeight(WindowInsets.ime))
      }InsetsSnippets.kt

   In cases where the raw window insets are needed without consumption, use the
   ``WindowInsets`` values directly, or use
   `WindowInsets.asPaddingValues()  <#asPaddingValues>`__
   to return a ``PaddingValues`` of the insets that are unaffected by
   consumption. However, due to the caveats below, prefer to use the window
   insets padding modifiers and window insets size modifiers wherever possible.

   .. rubric:: Insets and Jetpack Compose phases
      :name: insets-and-phases

   Compose uses the underlying AndroidX core APIs to update and animate insets,
   which use the underlying platform APIs managing insets. Because of that
   platform behavior, insets have a special relationship with the `phases of Jetpack Compose  <#phases>`__.

   The value of insets are updated *after* the composition phase, but *before*
   the layout phase. This means that reading the value of insets in composition
   generally uses a value of the insets that is one frame late. The built-in
   modifiers described on this page are built to delay using the values of the
   insets until the layout phase, which ensures that the inset values are used
   on the same frame as they are updated.

   .. rubric:: Keyboard IME animations with ``WindowInsets``
      :name: ime-animations

   You can apply ``Modifier.imeNestedScroll()`` to a scrolling container to open
   and close the IME automatically when scrolling to the bottom of the
   container.

   .. code:: prettyprint

      class WindowInsetsExampleActivity : AppCompatActivity() {
          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)

              WindowCompat.setDecorFitsSystemWindows(window, false)

              setContent {
                  MaterialTheme {
                      MyScreen()
                  }
              }
          }
      }

      @OptIn(ExperimentalLayoutApi::class)
      @Composable
      fun MyScreen() {
          Box {
              LazyColumn(
                  modifier = Modifier
                      .fillMaxSize() // fill the entire window
                      .imePadding() // padding for the bottom for the IME
                      .imeNestedScroll(), // scroll IME at the bottom
                  content = { }
              )
              FloatingActionButton(
                  modifier = Modifier
                      .align(Alignment.BottomEnd)
                      .padding(16.dp) // normal 16dp of padding for FABs
                      .navigationBarsPadding() // padding for navigation bar
                      .imePadding(), // padding for when IME appears
                  onClick = { }
              ) {
                  Icon(imageVector = Icons.Filled.Add, contentDescription = "Add")
              }
          }
      }MigrationOtherConsiderationsSnippets.kt

   |Animation showing a UI element scrolling up and down to make way for a
   keyboard|

   **Figure 1.** IME animations

   .. rubric:: Inset support for Material 3 Components
      :name: material3-components

   For ease of use, many of the built-in Material 3 composables
   (`androidx.compose.material3  <#package-summary>`__)
   handle insets themselves, based on how the composables are placed in your app
   according to the Material specifications.

   **Note:**\  Material 2 Components
   (`androidx.compose.material  <#package-summary>`__)
   don't automatically handle insets themselves. However, you can get access to
   the insets and apply them manually. In
   `androidx.compose.material 1.6.0  <#compose-material-1.6.0-alpha03>`__
   and later use the ``windowInsets`` parameter to apply the insets manually for
   `BottomAppBar  <#BottomAppBar>`__,
   `TopAppBar  <#TopAppBar>`__,
   `BottomNavigation  <#BottomNavigation>`__,
   and
   `NavigationRail  <#NavigationRail>`__.
   Likewise, use the ``contentWindowInsets`` parameter for
   `Scaffold  <#Scaffold>`__.
   Otherwise, apply the insets manually as padding.

   .. rubric:: Inset handling composables
      :name: inset-handling

   Below is a list of the `Material Components  <#package-summary>`__
   that automatically handle insets.

   .. rubric:: App bars
      :name: app-bars

   -  `TopAppBar  <#TopAppBar>`__
      /
      `SmallTopAppBar  <#SmallTopAppBar>`__
      /
      `CenterAlignedTopAppBar  <#CenterAlignedTopAppBar>`__
      /
      `MediumTopAppBar  <#MediumTopAppBar>`__
      /
      `LargeTopAppBar  <#LargeTopAppBar>`__:
      Applies the *top* and *horizontal* sides of the system bars as padding
      since it is used at the top of the window.
   -  `BottomAppBar  <#BottomAppBar>`__:
      Applies the *bottom* and *horizontal* sides of the system bars as padding.

   .. rubric:: Content containers
      :name: content-containers

   -  `ModalDrawerSheet  <#ModalDrawerSheet>`__
      /
      `DismissibleDrawerSheet  <#DismissibleDrawerSheet>`__
      /
      `PermanentDrawerSheet  <#PermanentDrawerSheet>`__
      (content inside a modal navigation drawer): Applies *vertical* and *start*
      insets to content.
   -  `ModalBottomSheet  <#ModalBottomSheet>`__:
      Applies the *bottom* insets.
   -  `NavigationBar  <#NavigationBar>`__
      : Applies the *bottom* and *horizontal* insets.
   -  `NavigationRail  <#NavigationRail>`__:
      Applies the *vertical* and *start* insets.

   .. rubric:: Scaffold
      :name: scaffold

   By default,
   `Scaffold  <#Scaffold>`__
   provides insets as parameter ``paddingValues`` for you to consume and use.
   ``Scaffold`` does not apply the insets to content; this responsibility is
   yours. For example, to consume these insets with a ``LazyColumn`` inside a
   ``Scaffold``:

   .. code:: prettyprint

      Scaffold { innerPadding ->
          // innerPadding contains inset information for you to use and apply
          LazyColumn(
              // consume insets as scaffold doesn't do it by default
              modifier = Modifier.consumeWindowInsets(innerPadding),
              contentPadding = innerPadding
          ) {
              items(count = 100) {
                  Box(
                      Modifier
                          .fillMaxWidth()
                          .height(50.dp)
                          .background(colors[it % colors.size])
                  )
              }
          }
      }InsetsSnippets.kt

   .. rubric:: Override default insets
      :name: override-default

   You can change the ``windowInsets`` parameter passed to the composable to
   configure the composable's behavior. This parameter can be a different type
   of window inset to apply instead, or disabled by passing an empty instance:
   ``WindowInsets(0, 0, 0, 0)``.

   For example, to disable the inset handling on
   `LargeTopAppBar  <#LargeTopAppBar>`__,
   set the ``windowInsets`` parameter to an empty instance:

   .. code:: prettyprint

      LargeTopAppBar(
          windowInsets = WindowInsets(0, 0, 0, 0),
          title = {
              Text("Hi")
          }
      )InsetsSnippets.kt

   .. rubric:: Interop with the View system insets
      :name: interop-view

   You may need to override default insets when your screen has both Views and
   Compose code in the same hierarchy. In this case, you need to be explicit in
   which one should consume the insets, and which one should ignore them.

   For example, if your outermost layout is an Android View layout, you should
   consume the insets in the View system and ignore them for Compose.
   Alternatively, if your outermost layout is a composable, you should consume
   the insets in Compose, and pad the ``AndroidView`` composables accordingly.

   By default, each ``ComposeView`` consumes all insets at the
   ``WindowInsetsCompat`` level of consumption. To change this default behavior,
   set
   `ComposeView.consumeWindowInsets  <#consumeWindowInsets>`__
   to ``false``.

   .. rubric:: Resources
      :name: resources

   -  `Now in Android <https://github.com/android/nowinandroid>`__ - a fully
      functional Android app built entirely with Kotlin and Jetpack Compose.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Material Components and layouts  <#material>`__
   -  `Migrate ``CoordinatorLayout`` to
      Compose  <#coordinator-layout>`__
   -  `Other considerations  <#other-considerations>`__

Last updated 2024-05-03 UTC.

.. |Animation showing a UI element scrolling up and down to make way for a keyboard| image:: https://developer.android.google.cn/static/develop/ui/compose/images/interop-keyboard.gif

/Cutouts
========

.. https://developer.android.google.cn/develop/ui/compose/system/cutouts?hl=en

.. container:: devsite-article-body clearfix

   A *display cutout* is an area on some devices that extends into the display
   surface. It allows for an *edge-to-edge* experience while providing space for
   important sensors on the front of the device.

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/system/cutouts_example_portrait.png
      name: image-1
      :alt: Cutout example in portrait mode
      :figclass: screenshot
      :width: 300px

      **Figure 1**. Cutout example in Portrait mode

   .. figure::
      https://developer.android.google.cn/static/develop/ui/compose/images/system/cutouts_example_landscape.png
      name: image-2
      :alt: Cutout example in landscape mode
      :figclass: screenshot
      :width: 300px

      **Figure 2**. Cutout example in landscape mode

   Android supports display cutouts on devices running Android 9 (API level 28)
   and higher. However, device manufacturers can also support display cutouts on
   devices running Android 8.1 or lower.

   This page describes how to implement support for devices with cutouts in
   Compose, including how to work with the *cutout area*— that is, the
   edge-to-edge rectangle on the display surface that contains the cutout.

   .. rubric:: Default case
      :name: default-case

   By default, display cutouts are included in the window insets information.
   Because of this, your app won't draw in the display cutout areas when you
   follow the guide on making your app edge-to-edge.

   For example, when you use
   `Modifier.windowInsetsPadding(WindowInsets.safeContent)  <#package-summary?windowInsetsPadding>`__
   or ``Modifier.windowInsetsPadding(WindowInsets.safeDrawing)``, your app
   automatically won't draw in the areas where a cutout is placed.
   `WindowInsets.safeContent  <#package-summary?safeContent>`__
   and
   `WindowInsets.safeDrawing  <#package-summary?safeDrawing>`__
   both contain display cutout information and will not draw where a device
   cutout is.

   .. code:: prettyprint

      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)

          WindowCompat.setDecorFitsSystemWindows(window, false)

          setContent {
              Box(Modifier.windowInsetsPadding(WindowInsets.safeContent)) {
                  // Any composable inside here will avoid drawing behind cutouts
              }
          }
      }CutoutSnippets.kt

   To customize this behavior further, you need to handle the cutout information
   yourself.

   .. rubric:: Handle cutout information manually
      :name: handle-cutout

   You can handle cutouts in any of the following ways:

   -  Using
      `WindowInsets.displayCutout  <#package-summary?displayCutout>`__

   -  Setting in theme manifest with
      `android:windowLayoutInDisplayCutoutMode  <#windowLayoutInDisplayCutoutMode>`__

   -  Programmatically setting the option on a ``Window`` with
      `window.attributes.layoutInDisplayCutoutMode  <#layoutInDisplayCutoutMode>`__

   -  Accessing the cutout ``Path`` object with
      `LocalView.current.rootWindowInsets.displayCutout  <#LocalView>`__

   For Compose, it is recommended to set the ``windowLayoutInDisplayCutoutMode``
   to ``default`` in your overall theme, and then leverage
   ``WindowInsets.displayCutout`` to handle the insets in your composables:

   .. code:: prettyprint

      Canvas(modifier = Modifier.fillMaxSize().windowInsetsPadding(WindowInsets.displayCutout)) {
          drawRect(Color.Red, style = Stroke(2.dp.toPx()))
      }CutoutSnippets.kt

   This approach allows you to respect the ``displayCutout`` padding where
   required, or ignore it where it is not required.

   Alternatively, you can apply the same settings that the `Views Cutout documentation  <#display-cutout>`__ describes by
   setting either the activity theme ``android:windowLayoutInDisplayCutoutMode``
   to another option, or setting the window attribute using
   ``window.attributes.layoutInDisplayCutoutMode = LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT``.
   However, the cutout mode is then applied to a whole activity, and cannot be
   controlled per individual composable.

   To respect the display cutout in certain composables but not others, use
   ``WindowInset.displayCutout``. This API allows you to access the cutout
   information when required.

   .. rubric:: Best practices
      :name: best-practices

   When working with display cutouts, consider the following:

   -  Be mindful of the placement of critical elements of the UI. Don't let the
      cutout area obscure any important text, controls, or other information.
   -  Don't place or extend any interactive elements that require fine-touch
      recognition into the cutout area. Touch sensitivity might be lower in the
      cutout area.
   -  When following the edge-to-edge guidance, cutout information is included
      in the ``safeDrawing`` / ``safeContent`` insets.
   -  Where possible, use
      ``Modifier.windowInsetsPadding(WindowInsets.safeDrawing)`` to determine
      the appropriate padding to apply to your content. Avoid hardcoding the
      status bar height, as this can lead to overlapping or cut-off content.

   .. rubric:: Test how your content renders with cutouts
      :name: test-cutouts

   Be sure to test all of your app's screens and experiences. Test on devices
   with different types of cutouts, if possible. If you don't have a device with
   a cutout, you can simulate common cutout configurations on any device or
   emulator running Android 9 or higher by doing the following:

   #. Enable `Developer options  <#dev-options>`__.
   #. In the **Developer options** screen, scroll down to the **Drawing**
      section and select **Simulate a display with a cutout**.
   #. Select the cutout type.
      .. figure::
         https://developer.android.google.cn/static/develop/ui/compose/images/system/cutouts_testing_developer_options.png
         name: image-1
         :alt: simulating a display cutout in the emulator
         :figclass: screenshot
         :width: 300px

         **Figure 3**. Use **Developer options** to test how your content
         renders.

   .. rubric:: Recommended for you
      :name: recommended_for_you

   -  Note: link text is displayed when JavaScript is off
   -  `Window insets in Compose  <#insets>`__
   -  `Graphics Modifiers  <#modifiers>`__
   -  `Style paragraph  <#style-paragraph>`__

Last updated 2024-05-03 UTC.

/Picture-in-picture
===================

.. https://developer.android.google.cn/develop/ui/compose/system/picture-in-picture?hl=en

.. container:: devsite-article-body clearfix

   Picture-in-picture (PiP) is a special type of multi-window mode mostly used
   for video playback. It lets the user watch a video in a small window pinned
   to a corner of the screen while navigating between apps or browsing content
   on the main screen.

   PiP leverages the multi-window APIs made available in Android 7.0 to provide
   the pinned video overlay window. To add PiP to your app, you need to register
   your activity, switch your activity to PiP mode as needed, and make sure UI
   elements are hidden and video playback continues when the activity is in PiP
   mode.

   This guide describes how to add PiP in Compose to your app with a Compose
   video implementation. See the
   `Socialite <https://github.com/android/socialite>`__ app to see these best
   practices in action.

   .. rubric:: Set up your app for PiP
      :name: set-app

   In the activity tag of your ``AndroidManifest.xml`` file, do the following:

   #. Add ``supportsPictureInPicture`` and set it to ``true`` to declare you'll
      be using PiP in your app.

   #. Add ``configChanges`` and set it to
      ``orientation|screenLayout|screenSize|smallestScreenSize`` to specify that
      your activity handles layout configuration changes. This way, your
      activity doesn't relaunch when layout changes occur during PiP mode
      transitions.

      .. code:: prettyprint

           <activity
             android:name=".SnippetsActivity"
             android:exported="true"
             android:supportsPictureInPicture="true"
             android:configChanges="orientation|screenLayout|screenSize|smallestScreenSize"
             android:theme="@style/Theme.Snippets">

      **Note:**\  To learn more about configuration changes, how to restrict
      activity recreation, and how to react to those configuration changes, see
      the `Handle configuration changes  <#runtime-changes>`__ page.

   In your Compose code, do the following:

   #. Add this extension on ``Context``. You'll use this extension multiple
      times throughout the guide to access the activity.

      .. code:: prettyprint

         internal fun Context.findActivity(): ComponentActivity {
             var context = this
             while (context is ContextWrapper) {
                 if (context is ComponentActivity) return context
                 context = context.baseContext
             }
             throw IllegalStateException("Picture in picture should be called in the context of an Activity")
         }PictureInPictureSnippets.kt

   .. rubric:: Add PiP on leave app for pre-Android 12
      :name: add-pip-pre-12

   To add PiP for pre-Android 12, use
   `addOnUserLeaveHintProvider  <#OnUserLeaveHintProvider>`__.
   Follow these steps to add PiP for pre-Android 12:

   #. Add a version gate so that this code is only accessed in versions O until
      R.
   #. Use a ``DisposableEffect`` with ``Context`` as the key.
   #. Inside the ``DisposableEffect``, define the behavior for when the
      ``onUserLeaveHintProvider`` is triggered using a lambda. In the lambda,
      call
      `enterPictureInPictureMode()  <#enterPictureInPictureMode>`__
      on ``findActivity()`` and pass in
      `PictureInPictureParams.Builder().build()  <#PictureInPictureParams.Builder>`__.
   #. Add ``addOnUserLeaveHintListener`` using ``findActivity()`` and pass in
      the lambda.
   #. In ``onDispose``, add ``removeOnUserLeaveHintListener`` using
      ``findActivity()`` and pass in the lambda.

   .. code:: prettyprint

      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O &&
          Build.VERSION.SDK_INT < Build.VERSION_CODES.S
      ) {
          val context = LocalContext.current
          DisposableEffect(context) {
              val onUserLeaveBehavior: () -> Unit = {
                  context.findActivity()
                      .enterPictureInPictureMode(PictureInPictureParams.Builder().build())
              }
              context.findActivity().addOnUserLeaveHintListener(
                  onUserLeaveBehavior
              )
              onDispose {
                  context.findActivity().removeOnUserLeaveHintListener(
                      onUserLeaveBehavior
                  )
              }
          }
      } else {
          Log.i(PIP_TAG, "API does not support PiP")
      }PictureInPictureSnippets.kt

   .. rubric:: Add PiP on leave app for post-Android 12
      :name: add-pip-post-12

   Post-Android 12, the
   `PictureInPictureParams.Builder  <#PictureInPictureParams.Builder>`__
   is added through a modifier that is passed to the app's video player.

   #. Create a ``modifier`` and call
      `onGloballyPositioned  <#OnGloballyPositionedModifier>`__
      on it. The layout coordinates will be used in a later step.
   #. Create a variable for the ``PictureInPictureParams.Builder()``.
   #. Add an ``if`` statement to check if the SDK is S or above. If so, add
      `setAutoEnterEnabled  <#setAutoEnterEnabled>`__
      to the builder and set it to ``true`` to enter PiP mode upon swipe. This
      provides a smoother animation than going through
      `enterPictureInPictureMode  <#enterPictureInPictureMode(android.app.PictureInPictureParams))(>`__.
   #. Use ``findActivity()`` to call ``setPictureInPictureParams()``. Call
      ``build()`` on the ``builder`` and pass it in.

   .. code:: prettyprint

      val pipModifier = modifier.onGloballyPositioned { layoutCoordinates ->
          val builder = PictureInPictureParams.Builder()

          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
              builder.setAutoEnterEnabled(true)
          }
          context.findActivity().setPictureInPictureParams(builder.build())
      }
      VideoPlayer(pipModifier)PictureInPictureSnippets.kt

   .. rubric:: Add PiP through a button
      :name: add-pip-button

   To enter PiP mode through a button click, call
   `enterPictureInPictureMode()  <#enterPictureInPictureMode>`__
   on ``findActivity()``.

   The parameters are already set by previous calls to the
   `PictureInPictureParams.Builder  <#enterPictureInPictureMode>`__,
   so you do not need to set new parameters on the builder. However, if you do
   want to change any parameters on button click, you can set them here.

   .. code:: prettyprint

      val context = LocalContext.current
      Button(onClick = {
          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
              context.findActivity().enterPictureInPictureMode(
                  PictureInPictureParams.Builder().build()
              )
          } else {
              Log.i(PIP_TAG, "API does not support PiP")
          }
      }) {
          Text(text = "Enter PiP mode!")
      }PictureInPictureSnippets.kt

   .. rubric:: Handle your UI in PiP mode
      :name: handle-ui

   When you enter PiP mode, your app's entire UI enters the PiP window unless
   you specify how your UI should look in and out of PiP mode.

   First, you need to know when your app is in PiP mode or not. You can use
   `OnPictureInPictureModeChangedProvider  <#OnPictureInPictureModeChangedProvider>`__
   to achieve this. The code below tells you if your app is in PiP mode.

   .. code:: prettyprint

      @Composable
      fun rememberIsInPipMode(): Boolean {
          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
              val activity = LocalContext.current.findActivity()
              var pipMode by remember { mutableStateOf(activity.isInPictureInPictureMode) }
              DisposableEffect(activity) {
                  val observer = Consumer<PictureInPictureModeChangedInfo> { info ->
                      pipMode = info.isInPictureInPictureMode
                  }
                  activity.addOnPictureInPictureModeChangedListener(
                      observer
                  )
                  onDispose { activity.removeOnPictureInPictureModeChangedListener(observer) }
              }
              return pipMode
          } else {
              return false
          }
      }PictureInPictureSnippets.kt

   Now, you can use ``rememberIsInPipMode()`` to toggle which UI elements to
   show when the app enters PiP mode:

   .. code:: prettyprint

      val inPipMode = rememberIsInPipMode()

      Column(modifier = modifier) {
          // This text will only show up when the app is not in PiP mode
          if (!inPipMode) {
              Text(
                  text = "Picture in Picture",
              )
          }
          VideoPlayer()
      }PictureInPictureSnippets.kt

   .. rubric:: Make sure that your app enters PiP mode at the right times
      :name: make-sure

   Your app should not enter PiP mode in the following situations:

   -  If the video is stopped or paused.
   -  If you are on a different page of the app than the video player.

   To control when your app enters PiP mode, add a variable that tracks the
   state of the video player using a
   `mutableStateOf  <#mutableStateOf>`__.

   .. rubric:: Toggle state based on if video is playing
      :name: toggle-state-playing

   To toggle the state based on if the video player is playing, add a listener
   on the video player. Toggle the state of your state variable based on if the
   player is playing or not:

   .. code:: prettyprint

      player.addListener(object : Player.Listener {
          override fun onIsPlayingChanged(isPlaying: Boolean) {
              shouldEnterPipMode = isPlaying
          }
      })PictureInPictureSnippets.kt

   .. rubric:: Toggle state based on if player is released
      :name: toggle-state-released

   When the player is released, set your state variable to ``false``:

   .. code:: prettyprint

      fun releasePlayer() {
          shouldEnterPipMode = false
      }PictureInPictureSnippets.kt

   .. rubric:: Use state to define if PiP mode is entered (pre-Android 12)
      :name: use-state-pre-12

   #. Since adding PiP pre-12 uses a
      `DisposableEffect  <#disposableeffect>`__,
      you need to create a new variable by
      `rememberUpdatedState  <#rememberupdatedstate>`__
      with ``newValue`` set as your state variable. This will ensure that the
      updated version is used within the ``DisposableEffect``.

   #. In the lambda that defines the behavior when the
      ``OnUserLeaveHintListener`` is triggered, add an ``if`` statement with the
      state variable around the call to ``enterPictureInPictureMode()``:

      .. code:: prettyprint

         val currentShouldEnterPipMode by rememberUpdatedState(newValue = shouldEnterPipMode)
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O &&
             Build.VERSION.SDK_INT < Build.VERSION_CODES.S
         ) {
             val context = LocalContext.current
             DisposableEffect(context) {
                 val onUserLeaveBehavior: () -> Unit = {
                     if (currentShouldEnterPipMode) {
                         context.findActivity()
                             .enterPictureInPictureMode(PictureInPictureParams.Builder().build())
                     }
                 }
                 context.findActivity().addOnUserLeaveHintListener(
                     onUserLeaveBehavior
                 )
                 onDispose {
                     context.findActivity().removeOnUserLeaveHintListener(
                         onUserLeaveBehavior
                     )
                 }
             }
         } else {
             Log.i(PIP_TAG, "API does not support PiP")
         }PictureInPictureSnippets.kt

   .. rubric:: Use state to define if PiP mode is entered (post-Android 12)
      :name: use-state-post-12

   Pass your state variable into ``setAutoEnterEnabled`` so that your app only
   enters PiP mode at the right time:

   .. code:: prettyprint

      val pipModifier = modifier.onGloballyPositioned { layoutCoordinates ->
          val builder = PictureInPictureParams.Builder()

          // Add autoEnterEnabled for versions S and up
          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
              builder.setAutoEnterEnabled(shouldEnterPipMode)
          }
          context.findActivity().setPictureInPictureParams(builder.build())
      }

      VideoPlayer(pipModifier)PictureInPictureSnippets.kt

   .. rubric:: Use ``setSourceRectHint`` to implement a smooth animation
      :name: use_setsourcerecthint_to_implement_a_smooth_animation

   The
   `setSourceRectHint  <#setSourceRectHint>`__
   API creates a smoother animation for entering PiP mode. In Android 12+, it
   also creates a smoother animation for exiting PiP mode. Add this API to the
   PiP builder to indicate the area of the activity that is visible following
   the transition into PiP.

   #. Only add ``setSourceRectHint()`` to the ``builder`` if the state defines
      that the app should enter PiP mode. This avoids calculating ``sourceRect``
      when the app does not need to enter PiP.
   #. To set the ``sourceRect`` value, use the ``layoutCoordinates`` that are
      given from the
      `onGloballyPositioned  <#OnGloballyPositionedModifier>`__
      function on the modifier.
   #. Call ``setSourceRectHint()`` on the ``builder`` and pass in the
      ``sourceRect`` variable.

   .. code:: prettyprint

      val context = LocalContext.current

      val pipModifier = modifier.onGloballyPositioned { layoutCoordinates ->
          val builder = PictureInPictureParams.Builder()
          if (shouldEnterPipMode) {
              val sourceRect = layoutCoordinates.boundsInWindow().toAndroidRectF().toRect()
              builder.setSourceRectHint(sourceRect)
          }

          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
              builder.setAutoEnterEnabled(shouldEnterPipMode)
          }
          context.findActivity().setPictureInPictureParams(builder.build())
      }

      VideoPlayer(pipModifier)PictureInPictureSnippets.kt

   **Note:**\  Depending on the video player you are using, you may need to
   reference the documentation and choose the ``sourceRectHint`` that represents
   the actual video content instead of the full video player.

   .. rubric:: Use ``setAspectRatio`` to set PiP window's aspect ratio
      :name: use-setaspectratio

   To set the aspect ratio of the PiP window, you can either choose a specific
   aspect ratio or use the width and height of the ``sourceRect`` variable to
   set the aspect ratio.

   **Warning:**\  The bounds of what the aspect ratio can be are between 2.39:1
   and 1:2.39 (inclusive). If your aspect ratio does not fall between these
   values, your app will crash.
   .. code:: prettyprint

      val context = LocalContext.current

      val pipModifier = modifier.onGloballyPositioned { layoutCoordinates ->
          val builder = PictureInPictureParams.Builder()

          if (shouldEnterPipMode) {
              val sourceRect = layoutCoordinates.boundsInWindow().toAndroidRectF().toRect()
              builder.setSourceRectHint(sourceRect)
              builder.setAspectRatio(
                  Rational(sourceRect.width(), sourceRect.height())
              )
          }

          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
              builder.setAutoEnterEnabled(shouldEnterPipMode)
          }
          context.findActivity().setPictureInPictureParams(builder.build())
      }

      VideoPlayer(pipModifier)PictureInPictureSnippets.kt

   .. rubric:: Add remote actions
      :name: add-remote

   If you want to add controls (play, pause, etc.) to your PiP window, create a
   `RemoteAction  <#RemoteAction>`__ for each control
   you want to add.

   **Note:**\  If you are using a
   `MediaSession  <#media3>`__, there will be default
   actions added to the window that you don't need to implement yourself.

   #. Add constants for your broadcast controls:

      .. code:: prettyprint

         // Constant for broadcast receiver
         const val ACTION_BROADCAST_CONTROL = "broadcast_control"

         // Intent extras for broadcast controls from Picture-in-Picture mode.
         const val EXTRA_CONTROL_TYPE = "control_type"
         const val EXTRA_CONTROL_PLAY = 1
         const val EXTRA_CONTROL_PAUSE = 2PictureInPictureSnippets.kt

   #. Create a list of
      `RemoteActions  <#RemoteAction>`__ for the
      controls in your PiP window.

   #. Next, add a
      `BroadcastReceiver  <#BroadcastReceiver>`__
      and override ``onReceive()`` to set the actions of each button. Use a
      `DisposableEffect  <#disposableeffect>`__
      to register the receiver and the remote actions. When the player is
      disposed, unregister the receiver.

      .. code:: prettyprint

         @RequiresApi(Build.VERSION_CODES.O)
         @Composable
         fun PlayerBroadcastReceiver(player: Player?) {
             val isInPipMode = rememberIsInPipMode()
             if (!isInPipMode || player == null) {
                 // Broadcast receiver is only used if app is in PiP mode and player is non null
                 return
             }
             val context = LocalContext.current

             DisposableEffect(player) {
                 val broadcastReceiver: BroadcastReceiver = object : BroadcastReceiver() {
                     override fun onReceive(context: Context?, intent: Intent?) {
                         if ((intent == null) || (intent.action != ACTION_BROADCAST_CONTROL)) {
                             return
                         }

                         when (intent.getIntExtra(EXTRA_CONTROL_TYPE, 0)) {
                             EXTRA_CONTROL_PAUSE -> player.pause()
                             EXTRA_CONTROL_PLAY -> player.play()
                         }
                     }
                 }
                 ContextCompat.registerReceiver(
                     context,
                     broadcastReceiver,
                     IntentFilter(ACTION_BROADCAST_CONTROL),
                     ContextCompat.RECEIVER_NOT_EXPORTED
                 )
                 onDispose {
                     context.unregisterReceiver(broadcastReceiver)
                 }
             }
         }PictureInPictureSnippets.kt

   #. Pass in a list of your remote actions to the
      `PictureInPictureParams.Builder  <#PictureInPictureParams.Builder>`__:

      .. code:: prettyprint

         val context = LocalContext.current

         val pipModifier = modifier.onGloballyPositioned { layoutCoordinates ->
             val builder = PictureInPictureParams.Builder()
             builder.setActions(
                 listOfRemoteActions()
             )

             if (shouldEnterPipMode) {
                 val sourceRect = layoutCoordinates.boundsInWindow().toAndroidRectF().toRect()
                 builder.setSourceRectHint(sourceRect)
                 builder.setAspectRatio(
                     Rational(sourceRect.width(), sourceRect.height())
                 )
             }

             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                 builder.setAutoEnterEnabled(shouldEnterPipMode)
             }
             context.findActivity().setPictureInPictureParams(builder.build())
         }
         VideoPlayer(modifier = pipModifier)PictureInPictureSnippets.kt

   .. rubric:: Next steps
      :name: next_steps

   In this guide you learned the best practices of adding PiP in Compose both
   pre-Android 12 and post-Android 12.

   -  See the `Socialite <https://github.com/android/socialite>`__ app to see
      the best practices of Compose PiP in action.
   -  See the `PiP design guidance  <#picture-in-picture>`__ for
      more information.

Last updated 2024-03-25 UTC.

/Overview: Create widgets
=========================

.. https://developer.android.google.cn/develop/ui/compose/glance?hl=en

.. container:: devsite-article-body clearfix

   Jetpack Glance is a framework built on top of the `Jetpack Compose runtime  <#compose-runtime>`__ that lets you develop
   and design app widgets using Kotlin APIs. *App widgets* are miniature
   application views that can be embedded in other applications and receive
   periodic updates.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/glance-widget.png
      name: image-1
      :alt: An information widget from a weather app.
      :width: 40.0%

      **Figure 1.** An information widget from a weather app.

   Glance provides a set of composables to help you build responsive widgets for
   the home screen quickly and with less code. The pages in this doc set
   describe how to use Glance to build app widgets.

   **Note:**\  Jetpack Glance is in active development. File any issues on the
   `issue tracker <https://b.corp.google.com/issues/new?component=1097239&template=1611667>`__.
   **Caution:**\  Glance requires Compose to be enabled and depends on Runtime,
   Graphics, and Unit `UI Compose layers  <#layering>`__, but
   it's *not directly interoperable* with other existing Jetpack Compose UI
   elements. Avoid mixing the two.

Last updated 2024-03-25 UTC.

/Glance setup
=============

.. https://developer.android.google.cn/develop/ui/compose/glance/setup?hl=en

.. container:: devsite-article-body clearfix

   This page describes how to set up your development environment to use Glance.

   .. rubric:: Add Glance dependencies
      :name: add-dependencies

   Add the specific Glance dependency in your app's module based on the features
   you need:

   .. code:: prettyprint

      dependencies {
         // For AppWidgets support
         implementation( "androidx.glance:glance-appwidget:1.0.0" )

         // For interop APIs with Material 2
         implementation( "androidx.glance:glance-material:1.0.0" )

         // For interop APIs with Material 3
         implementation( "androidx.glance:glance-material3:1.0.0" )
      }

   .. rubric:: Activate Compose Compiler
      :name: activate_compose_compiler

   Set the following options to ensure that the compose compiler is available
   for Glance

   .. code:: prettyprint

      android {
         buildFeatures {
            compose true
         }

         composeOptions {
            kotlinCompilerExtensionVersion = "1.5.13"
         }

         kotlinOptions {
            jvmTarget = "1.8"
         }
      }

   You can get the latest available version from the Glance `release page  <#glance>`__.

Last updated 2024-05-03 UTC.

/Create an app widget with Glance
=================================

.. https://developer.android.google.cn/develop/ui/compose/glance/create-app-widget?hl=en

.. container:: devsite-article-body clearfix

   The following sections describe how to create a simple app widget with
   Glance.

   **Key Point:**\  Glance provides a modern approach to build app widgets using
   Compose, but is restricted by the limitations of ``AppWidgets`` and
   ``RemoteViews``. Therefore, Glance uses different *composables* from the
   Jetpack Compose UI.

   .. rubric:: Declare the ``AppWidget`` in the Manifest
      :name: declare-appwidget

   After completing the `setup steps  <#setup>`__,
   declare the `AppWidget  <#appwidgets>`__ and its metadata in
   your app.

   #. Register the provider of the app widget in your ``AndroidManifest.xml``
      file and the associated metadata file:

   .. code:: prettyprint

      <receiver android:name=".glance.MyReceiver"
          android:exported="true">
          <intent-filter>
              <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
          </intent-filter>
          <meta-data
              android:name="android.appwidget.provider"
              android:resource="@xml/my_app_widget_info" />
      </receiver>AndroidManifest.xml

   #. Extend the ``AppWidget`` receiver from ``GlanceAppWidgetReceiver``:

   .. code:: prettyprint

      class MyAppWidgetReceiver : GlanceAppWidgetReceiver() {
          override val glanceAppWidget: GlanceAppWidget = TODO("Create GlanceAppWidget")
      }GlanceSnippets.kt

   .. rubric:: Add the ``AppWidgetProviderInfo`` metadata
      :name: add-appwidgetproviderinfo

   Next, follow this step to add the ``AppWidgetProviderInfo`` metadata:

   #. Follow the `Create a simple widget  <#MetaData>`__
      guide to create and define the app widget info in the
      ``@xml/my_app_widget_info`` file.

      The only difference for Glance is that there is no ``initialLayout`` XML,
      but you must define one. You can use the predefined loading layout
      provided in the library:

   .. code:: prettyprint

      <appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
          android:initialLayout="@layout/glance_default_loading_layout">
      </appwidget-provider>my_app_widget_info.xml

   .. rubric:: Define ``GlanceAppWidget``
      :name: define-glanceappwidget

   #. Create a new class that extends from
      `GlanceAppWidget  <#GlanceAppWidget>`__
      and overrides the ``provideGlance`` method. This is the method where you
      can load data that is needed to render your widget:

      **Note:**\  ``provideGlance`` runs on the main thread. To perform any long
      running operations in ``provideGlance``, switch to another thread using
      ``withContext``. See `Use coroutines for main-safety  <#main-safety>`__ for more
      details on how to run outside of the main thread.

   .. code:: prettyprint

      class MyAppWidget : GlanceAppWidget() {

          override suspend fun provideGlance(context: Context, id: GlanceId) {

              // In this method, load data needed to render the AppWidget.
              // Use `withContext` to switch to another thread for long running
              // operations.

              provideContent {
                  // create your AppWidget here
                  Text("Hello World")
              }
          }
      }GlanceSnippets.kt

   #. Instantiate it in the ``glanceAppWidget`` on your
      ``GlanceAppWidgetReceiver``:

   .. code:: prettyprint

      class MyAppWidgetReceiver : GlanceAppWidgetReceiver() {

          // Let MyAppWidgetReceiver know which GlanceAppWidget to use
          override val glanceAppWidget: GlanceAppWidget = MyAppWidget()
      }GlanceSnippets.kt

   You've now configured an ``AppWidget`` using Glance.

   .. rubric:: Create UI
      :name: create-ui

   The following snippet demonstrates how to create the UI:

   .. code:: prettyprint

      /* Import Glance Composables
       In the event there is a name clash with the Compose classes of the same name,
       you may rename the imports per https://kotlinlang.org/docs/packages.html#imports
       using the `as` keyword.

      import androidx.glance.Button
      import androidx.glance.layout.Column
      import androidx.glance.layout.Row
      import androidx.glance.text.Text
      */
      class MyAppWidget : GlanceAppWidget() {

          override suspend fun provideGlance(context: Context, id: GlanceId) {
              // Load data needed to render the AppWidget.
              // Use `withContext` to switch to another thread for long running
              // operations.

              provideContent {
                  // create your AppWidget here
                  GlanceTheme {
                      MyContent()
                  }
              }
          }

          @Composable
          private fun MyContent() {
              Column(
                  modifier = GlanceModifier.fillMaxSize()
                      .background(GlanceTheme.colors.background),
                  verticalAlignment = Alignment.Top,
                  horizontalAlignment = Alignment.CenterHorizontally
              ) {
                  Text(text = "Where to?", modifier = GlanceModifier.padding(12.dp))
                  Row(horizontalAlignment = Alignment.CenterHorizontally) {
                      Button(
                          text = "Home",
                          onClick = actionStartActivity<MyActivity>()
                      )
                      Button(
                          text = "Work",
                          onClick = actionStartActivity<MyActivity>()
                      )
                  }
              }
          }
      }GlanceSnippets.kt

   The preceding code sample does the following:

   -  In the top level
      `Column  <#column>`__,
      items are placed vertically one after each other.
   -  The ``Column`` expands its size to match the available space (via the
      `GlanceModifier  <#GlanceModifier)>`__
      and aligns its content to the top (``verticalAlignment``) and centers it
      horizontally (``horizontalAlignment``).
   -  The ``Column``'s content is defined using the lambda. The order matters.

      -  The first item in the ``Column`` is a ``Text`` component with ``12.dp``
         of padding.
      -  The second item is a
         `Row  <#row>`__,
         where items are placed horizontally one after each other, with two
         `Buttons  <#button>`__
         centered horizontally (``horizontalAlignment``). The final display
         depends on the available space. The following image is an example of
         what it may look like:

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/destination_widget.png
      name: image-1
      :alt: destination_widget
      :width: 35.0%

      **Figure 1.** An example UI.

   You can change the alignment values or apply different modifier values (such
   as padding) to change the placement and size of the components. See the
   `reference documentation  <#package-summary>`__ for a
   full list of components, parameters, and available modifiers for each class.

Last updated 2024-03-25 UTC.

/Handle user interaction with Glance
====================================

.. https://developer.android.google.cn/develop/ui/compose/glance/user-interaction?hl=en

.. container:: devsite-article-body clearfix

   Glance simplifies handling user interaction via the ``Action`` classes.
   Glance's ``Action`` classes define the actions a user can take, and you can
   specify the operation performed in response to the action. You can apply an
   ``Action`` to any component with the
   `GlanceModifier.clickable  <#clickable>`__
   method.

   App widgets live on a remote process, so the actions are defined at creation
   time and the execution happens in the remote process. In native
   ``RemoteViews``, this is done via ``PendingIntents``.

   The following actions are described on this page:

   -  `Launch an activity  <#launch-activity>`__
   -  `Launch a service  <#launch-service>`__
   -  `Send a broadcast event  <#send-broadcast>`__
   -  `Run callback  <#run-actioncallback>`__

   **Note:**\  See
   `ActionAppWidget.kt <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/ActionAppWidget.kt>`__
   for an example of how to handle actions.

   .. rubric:: Launch an activity
      :name: launch-activity

   To launch an activity on user interaction, provide the
   `actionStartActivity  <#actionStartActivity>`__
   function to a ``Button`` or other composable via the
   ``GlanceModifier.clickable``\ (..) modifier.

   Provide one of the following in ``actionStartActivity``:

   -  The target activity class
   -  The `ComponentName  <#ComponentName>`__
   -  An Intent

   Glance translates the Action into a ``PendingIntent`` with the provided
   target and parameters. In the following example, the ``NavigationActivity``
   is launched when a user clicks the button:

   .. code:: prettyprint

      @Composable
      fun MyContent() {
          // ..
          Button(
              text = "Go Home",
              onClick = actionStartActivity<MyActivity>()
          )
      }GlanceSnippets.kt

   .. rubric:: Launch a service
      :name: launch-service

   Similar to launching an activity, launch a service on user interaction using
   one of the
   `actionStartService  <#actionstartservice>`__
   methods.

   Provide one of the following in ``actionStartService``:

   -  The target activity class
   -  The `ComponentName  <#ComponentName>`__
   -  An intent

   .. code:: prettyprint

      @Composable
      fun MyButton() {
          // ..
          Button(
              text = "Sync",
              onClick = actionStartService<SyncService>(
                  isForegroundService = true // define how the service is launched
              )
          )
      }GlanceSnippets.kt

   .. rubric:: Send a broadcast event
      :name: send-broadcast

   Send a broadcast event on user interaction using one of the
   `actionSendBroadcast  <#actionstartbroadcastreceiver>`__
   methods:

   Provide one of the following in ``actionSendBroadcast``:

   -  String action
   -  The `ComponentName  <#ComponentName>`__
   -  An intent
   -  `BroadcastReceiver  <#BroadcastReceiver>`__
      class

   .. code:: prettyprint

      @Composable
      fun MyButton() {
          // ..
          Button(
              text = "Send",
              onClick = actionSendBroadcast<MyReceiver>()
          )
      }GlanceSnippets.kt

   .. rubric:: Perform custom actions
      :name: custom-actions

   Instead of launching a specific target, Glance can use a lambda action or an
   ``actionRunCallback`` to perform an action, such as updating the UI or state
   on user interaction.

   .. rubric:: Run lambda actions
      :name: run-lambda

   You can use lambda functions as callbacks to the UI interactions.

   **Note:**\  Lambda callbacks run in the context of a ``WorkManager`` worker
   that is run in a ``Service``. Apps that target Android 12 or higher can't
   start activities from services or broadcast receivers that act as
   `trampolines  <#notification-trampolines>`__.
   Instead of starting activities from lambdas, use the
   `actionStartActivity  <#actionStartActivity>`__
   callback to start the activity from the ``GlanceAppWidget``.
   For example, pass the lambda function to the ``GlanceModifier.clickable``
   modifier:

   .. code:: prettyprint

      Text(
          text = "Submit",
          modifier = GlanceModifier.clickable {
              submitData()
          }
      )GlanceSnippets.kt

   Or, pass it to the ``onClick`` parameter on composables that support it:

   .. code:: prettyprint

      Button(
          text = "Submit",
          onClick = {
              submitData()
          }
      )GlanceSnippets.kt

   .. rubric:: Run ActionCallback
      :name: run-actioncallback

   Alternatively, use the
   `actionRunCallback  <#actionruncallback>`__
   methods to perform an action on user interaction. To do this, provide a
   custom implementation of the
   `ActionCallback  <#ActionCallback>`__:

   .. code:: prettyprint

      @Composable
      private fun MyContent() {
          // ..
          Image(
              provider = ImageProvider(R.drawable.ic_hourglass_animated),
              modifier = GlanceModifier.clickable(
                  onClick = actionRunCallback<RefreshAction>()
              ),
              contentDescription = "Refresh"
          )
      }

      class RefreshAction : ActionCallback {
          override suspend fun onAction(
              context: Context,
              glanceId: GlanceId,
              parameters: ActionParameters
          ) {
              // TODO implement
          }
      }GlanceSnippets.kt

   On the user click, the ``suspend onAction`` method of the provided
   ``ActionCallback`` is called, executing the defined logic (i.e., requesting
   refresh data).

   To update the widget after the action is performed, create a new instance and
   call ``update``\ (..). For more details, see the `Manage GlanceAppWidget state  <#manage-state>`__ section.

   .. code:: prettyprint

      class RefreshAction : ActionCallback {
          override suspend fun onAction(
              context: Context,
              glanceId: GlanceId,
              parameters: ActionParameters
          ) {
              // do some work but offset long-term tasks (e.g a Worker)
              MyAppWidget().update(context, glanceId)
          }
      }
      GlanceSnippets.kt

   **Note:**\  Glance uses a custom async ``BroadcastReceiver`` to handle the
   user click and call the ``onRun`` method of the provided ``ActionCallback``.
   This allows extra execution time, but certain restrictions apply. Any long or
   consuming tasks should be offset into, for example, a
   `Worker  <#workmanager>`__.

   .. rubric:: Provide parameters to actions
      :name: provide-parameters

   To provide additional information to an action, use the
   `ActionParameters  <#ActionParameters>`__
   API to create a typed key-value pair. For example, to define the clicked
   destination:

   .. code:: prettyprint

      private val destinationKey = ActionParameters.Key<String>(
          NavigationActivity.KEY_DESTINATION
      )

      class MyAppWidget : GlanceAppWidget() {

          // ..

          @Composable
          private fun MyContent() {
              // ..
              Button(
                  text = "Home",
                  onClick = actionStartActivity<NavigationActivity>(
                      actionParametersOf(destinationKey to "home")
                  )
              )
              Button(
                  text = "Work",
                  onClick = actionStartActivity<NavigationActivity>(
                      actionParametersOf(destinationKey to "work")
                  )
              )
          }

          override suspend fun provideGlance(context: Context, id: GlanceId) {
              provideContent { MyContent() }
          }
      }GlanceSnippets.kt

   Underneath, the parameters are included in the intent used to launch the
   activity, allowing the target Activity to retrieve it.

   .. code:: prettyprint

          override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              val destination = intent.extras?.getString(KEY_DESTINATION) ?: return
              // ...
          }
      }GlanceSnippets.kt

   The parameters are also provided to the ``ActionCallback``. Use the defined
   ``Parameters.Key`` to retrieve the value:

   .. code:: prettyprint

      class RefreshAction : ActionCallback {

          private val destinationKey = ActionParameters.Key<String>(
              NavigationActivity.KEY_DESTINATION
          )

          override suspend fun onAction(
              context: Context,
              glanceId: GlanceId,
              parameters: ActionParameters
          ) {
              val destination: String = parameters[destinationKey] ?: return
              // ...
          }
      }GlanceSnippets.kt

Last updated 2024-03-25 UTC.

/Manage and update GlanceAppWidget
==================================

.. https://developer.android.google.cn/develop/ui/compose/glance/glance-app-widget?hl=en

.. container:: devsite-article-body clearfix

   The following sections describe how to update ``GlanceAppWidget`` and manage
   its state.

   .. rubric:: Manage ``GlanceAppWidget`` state
      :name: manage-state

   The provided ``GlanceAppWidget`` class is instantiated whenever the widget is
   created or requires an update, so it should be *stateless and passive*.

   **Key Point:**\  App widgets live in a different process. While the defined
   UI content (meaning the underlying ``RemoteViews``) is restored by the
   system, any state kept in-memory, for example in the app's scope, can be
   destroyed at any time.
   The concept of state can be divided into the following:

   -  **Application state**: The state or content of the app that is required by
      the widget. For example, a list of stored destinations (i.e., database)
      defined by the user.
   -  **Glance state**: The specific state that is only relevant to the app
      widget and does not necessarily modify or affect the app's state. For
      example, a checkbox was selected in the widget or a counter was increased.

   .. rubric:: Use application state
      :name: use-application

   App widgets should be passive. Each application is responsible for managing
   the data layer and handling the states, such as idle, loading, and error
   reflecting in the widget UI.

   For example, the following code retrieves the destinations from the in-memory
   cache from the repository layer, provides the stored list of destinations,
   and displays a different UI depending on its state:

   .. code:: prettyprint

      class DestinationAppWidget : GlanceAppWidget() {

          // ...

          @Composable
          fun MyContent() {
              val repository = remember { DestinationsRepository.getInstance() }
              // Retrieve the cache data everytime the content is refreshed
              val destinations by repository.destinations.collectAsState(State.Loading)

              when (destinations) {
                  is State.Loading -> {
                      // show loading content
                  }

                  is State.Error -> {
                      // show widget error content
                  }

                  is State.Completed -> {
                      // show the list of destinations
                  }
              }
          }
      }GlanceSnippets.kt

   Whenever the state or the data changes, it is the app's responsibility to
   notify and update the widget. See `Update GlanceAppWidget  <#update-glance-appwidget>`__
   for more information.

   **Note:**\  See the `Optimizations for updating widget content  <#update-widgets>`__ section in the
   app widgets guide to understand how and when to update.

   .. rubric:: Update ``GlanceAppWidget``
      :name: update-glanceappwidget

   As explained in the `Manage ``GlanceAppWidget`` state <#manage-state>`__
   section, app widgets are hosted in a different process. Glance translates the
   content into actual ``RemoteViews`` and sends them to the host. To update the
   content, Glance must recreate the ``RemoteViews`` and send them again.

   To send the update, call the ``update`` method of the ``GlanceAppWidget``
   instance, providing the ``context`` and the ``glanceId``:

   .. code:: prettyprint

      MyAppWidget().update(context, glanceId)GlanceSnippets.kt

   To obtain the ``glanceId``, query the ``GlanceAppWidgetManager``:

   .. code:: prettyprint

      val manager = GlanceAppWidgetManager(context)
      val widget = GlanceSizeModeWidget()
      val glanceIds = manager.getGlanceIds(widget.javaClass)
      glanceIds.forEach { glanceId ->
          widget.update(context, glanceId)
      }GlanceSnippets.kt

   Alternatively, use one of the ``GlanceAppWidget update`` extensions:

   .. code:: prettyprint

      // Updates all placed instances of MyAppWidget
      MyAppWidget().updateAll(context)

      // Iterate over all placed instances of MyAppWidget and update if the state of
      // the instance matches the given predicate
      MyAppWidget().updateIf<State>(context) { state ->
          state == State.Completed
      }GlanceSnippets.kt

   These methods can be called from any part of your application. Because they
   are ``suspend`` functions, we recommend launching them outside of the main
   thread scope. In the following example, they are launched in a
   ``CoroutineWorker``:

   .. code:: prettyprint

      class DataSyncWorker(
          val context: Context,
          val params: WorkerParameters,
      ) : CoroutineWorker(context, params) {

          override suspend fun doWork(): Result {
              // Fetch data or do some work and then update all instance of your widget
              MyAppWidget().updateAll(context)
              return Result.success()
          }
      }GlanceSnippets.kt

   See `Kotlin Coroutines on Android  <#coroutines>`__ for more details on
   coroutines.

Last updated 2024-03-25 UTC.

/Build UI with Glance
=====================

.. https://developer.android.google.cn/develop/ui/compose/glance/build-ui?hl=en

.. container:: devsite-article-body clearfix

   This page describes how to handle sizes and provide flexible and responsive
   layouts with Glance.

   **Note:**\  See
   `ResponsiveAppWidget.kt <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/ResponsiveAppWidget.kt>`__
   and
   `ScrollableAppWidget.kt <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/ScrollableAppWidget.kt>`__
   to better understand the following sections.

   .. rubric:: Use ``Box``, ``Column``, and ``Row``
      :name: use-box

   Glance has three main composable layouts:

   -  ``Box``: Places elements on top of another. It translates to a
      ``RelativeLayout``.

   -  ``Column``: Places elements after each other in the vertical axis. It
      translates to a ``LinearLayout`` with vertical orientation.

   -  ``Row``: Places elements after each other in the horizontal axis. It
      translates to a ``LinearLayout`` with horizontal orientation.

   .. figure:: https://developer.android.google.cn/static/develop/ui/compose/images/column_row_box.png
      name: image-1
      :alt: Image of a column, row, and box layout.
      :width: 60.0%

      **Figure 1.** Examples of layouts with Column, Row, and Box.

   **Key Point:**\  Glance provides a modern approach to build app widgets using
   Compose, but is restricted by the limitations of ``AppWidgets`` and
   ``RemoteViews``. Therefore, Glance uses different *composables* from the
   Jetpack Compose UI.
   Each of these composables lets you define the vertical and horizontal
   alignments of its content and the width, height, weight, or padding
   constraints using modifiers. In addition, each child can define its modifier
   to change the space and placement inside the parent.

   The following example shows you how to create a ``Row`` that evenly
   distributes its children horizontally, as seen in Figure 1:

   .. code:: prettyprint

      Row(modifier = GlanceModifier.fillMaxWidth().padding(16.dp)) {
          val modifier = GlanceModifier.defaultWeight()
          Text("first", modifier)
          Text("second", modifier)
          Text("third", modifier)
      }GlanceSnippets.kt

   The ``Row`` fills the max available width, and because each child has the
   same weight, they evenly share the available space. You can define different
   weights, sizes, paddings, or alignments to adapt layouts to your needs.

   **Note:**\  Glance translates its composables into actual ``Views``, using
   the defined modifiers and parameters to create the underlying view. Thus, the
   same Android View concepts (such as weights) apply when building certain
   composables with Glance.

   .. rubric:: Use scrollable layouts
      :name: use-scrollable

   Another way to provide responsive content is to make it scrollable. This is
   possible with the ``LazyColumn`` composable. This composable lets you define
   a set of items to be displayed inside a scrollable container in the app
   widget.

   The following snippets show different ways to define items inside the
   ``LazyColumn``.

   You can provide the number of items:

   .. code:: prettyprint

      // Remember to import Glance Composables
      // import androidx.glance.appwidget.layout.LazyColumn

      LazyColumn {
          items(10) { index: Int ->
              Text(
                  text = "Item $index",
                  modifier = GlanceModifier.fillMaxWidth()
              )
          }
      }GlanceSnippets.kt

   Provide individual items:

   .. code:: prettyprint

      LazyColumn {
          item {
              Text("First Item")
          }
          item {
              Text("Second Item")
          }
      }GlanceSnippets.kt

   Provide a list or array of items:

   .. code:: prettyprint

      LazyColumn {
          items(peopleNameList) { name ->
              Text(name)
          }
      }GlanceSnippets.kt

   You can also use a combination of the preceding examples:

   .. code:: prettyprint

      LazyColumn {
          item {
              Text("Names:")
          }
          items(peopleNameList) { name ->
              Text(name)
          }

          // or in case you need the index:
          itemsIndexed(peopleNameList) { index, person ->
              Text("$person at index $index")
          }
      }GlanceSnippets.kt

   Note that the previous snippet does not specify the ``itemId``. Specifying
   the ``itemId`` helps with improving the performance and maintaining the
   scroll position through list and ``appWidget`` updates from Android 12
   onwards (for example, when adding or removing items from the list). The
   following example shows how to specify an ``itemId``:

   .. code:: prettyprint

      items(items = peopleList, key = { person -> person.id }) { person ->
          Text(person.name)
      }GlanceSnippets.kt

   **Note:**\  Glance translates a ``LazyColumn`` into an actual ``ListView``
   with the translation of the provided items. Thus, the same limitations and
   restrictions of ``RemoteViews`` collections apply.

   .. rubric:: Define the ``SizeMode``
      :name: define-sizemode

   ``AppWidget`` sizes may differ depending on the device, user choice, or
   launcher, so it is important to provide flexible layouts as described in the
   `Provide flexible widget layouts  <#layouts>`__
   page. Glance simplifies this with the ``SizeMode`` definition and the
   ``LocalSize`` value. The following sections describe the three modes.

   .. rubric:: ``SizeMode.Single``
      :name: sizemode-single

   `SizeMode.Single  <#SizeMode.Single>`__
   is the default mode. It indicates that only one type of content is provided;
   that is, even if the ``AppWidget`` available size changes, the content size
   is not changed.

   .. code:: prettyprint

      class MyAppWidget : GlanceAppWidget() {

          override val sizeMode = SizeMode.Single

          override suspend fun provideGlance(context: Context, id: GlanceId) {
              // ...

              provideContent {
                  MyContent()
              }
          }

          @Composable
          private fun MyContent() {
              // Size will be the minimum size or resizable
              // size defined in the App Widget metadata
              val size = LocalSize.current
              // ...
          }
      }GlanceSnippets.kt

   When using this mode, ensure that:

   -  The minimum and maximum size `metadata values  <#add-appwidgetproviderinfo>`__
      are properly defined based on the content size.
   -  The content is flexible enough within the expected size range.

   In general, you should use this mode when either:

   a) the ``AppWidget`` has a fixed size, or b) it does not change its content
   when resized.

   .. rubric:: ``SizeMode.Responsive``
      :name: sizemode-responsive

   This mode is the equivalent of `providing responsive layouts  <#provide-responsive-layouts>`__,
   which allows the ``GlanceAppWidget`` to define a set of responsive layouts
   bounded by specific sizes. For each defined size, the content is created and
   mapped to the specific size when the ``AppWidget`` is created or updated. The
   system then selects the *best fitting* one based on the available size.

   **Note:**\  The best fitting size is one of the provided ``DpSize`` that fits
   within the available bounding box with minimal distortion. If none fits, the
   smallest one is used.
   For example, in our destination ``AppWidget``, you can define three sizes and
   its content:

   .. code:: prettyprint

      class MyAppWidget : GlanceAppWidget() {

          companion object {
              private val SMALL_SQUARE = DpSize(100.dp, 100.dp)
              private val HORIZONTAL_RECTANGLE = DpSize(250.dp, 100.dp)
              private val BIG_SQUARE = DpSize(250.dp, 250.dp)
          }

          override val sizeMode = SizeMode.Responsive(
              setOf(
                  SMALL_SQUARE,
                  HORIZONTAL_RECTANGLE,
                  BIG_SQUARE
              )
          )

          override suspend fun provideGlance(context: Context, id: GlanceId) {
              // ...

              provideContent {
                  MyContent()
              }
          }

          @Composable
          private fun MyContent() {
              // Size will be one of the sizes defined above.
              val size = LocalSize.current
              Column {
                  if (size.height >= BIG_SQUARE.height) {
                      Text(text = "Where to?", modifier = GlanceModifier.padding(12.dp))
                  }
                  Row(horizontalAlignment = Alignment.CenterHorizontally) {
                      Button()
                      Button()
                      if (size.width >= HORIZONTAL_RECTANGLE.width) {
                          Button("School")
                      }
                  }
                  if (size.height >= BIG_SQUARE.height) {
                      Text(text = "provided by X")
                  }
              }
          }
      }
      GlanceSnippets.kt

   In the previous example, the ``provideContent`` method is called three times
   and mapped to the defined size.

   -  In the first call, the size evaluates to ``100x100``. The content doesn't
      include the extra button, nor the top and bottom texts.
   -  In the second call, the size evaluates to ``250x100``. The content
      includes the extra button, but not the top and bottom texts.
   -  In the third call, the size evaluates to ``250x250``. The content includes
      the extra button and both texts.

   ``SizeMode.Responsive`` is a combination of the other two modes, and lets you
   define responsive content within predefined bounds. In general, this mode
   performs better and allows smoother transitions when the ``AppWidget`` is
   resized.

   **Note:**\  Responsive layouts were introduced in Android 12. Before Android
   12, the composable is called for each size at which the app widget may be
   displayed (similar to ``SizeMode.Exact``). For each size, the best view is
   chosen, which is the largest one that fits in the available space, or the
   smallest one if none fits.

   The following table shows the value of the size, depending on the
   ``SizeMode`` and the ``AppWidget`` available size:

   ========================  ===========  ==========  ==========  ==========
   Available size            105 x 110    203 x 112   72 x 72     203 x 150
   ========================  ===========  ==========  ==========  ==========
   ``SizeMode.Single``       110 x 110    110 x 110   110 x 110   110 x 110
   ``SizeMode.Exact``        105 x 110    203 x 112   72 x 72     203 x 150
   ``SizeMode.Responsive``   80 x 100     80 x 100    80 x 100    150 x 120
   ========================  ===========  ==========  ==========  ==========

   \* The exact values are just for demo purposes.

   ``SizeMode.Exact``
   ~~~~~~~~~~~~~~~~~~

   `SizeMode.Exact  <#SizeMode.Exact>`__
   is the equivalent of `providing exact layouts  <#provide-exact-layouts>`__, which
   requests the ``GlanceAppWidget`` content each time the available ``AppWidget``
   size changes (for example, when the user resizes the ``AppWidget`` in the
   homescreen).

   For example, in the destination widget, an extra button can be added if the
   available width is larger than a certain value.

   .. code:: prettyprint

      class MyAppWidget : GlanceAppWidget() {

          override val sizeMode = SizeMode.Exact

          override suspend fun provideGlance(context: Context, id: GlanceId) {
              // ...

              provideContent {
                  MyContent()
              }
          }

          @Composable
          private fun MyContent() {
              // Size will be the size of the AppWidget
              val size = LocalSize.current
              Column {
                  Text(text = "Where to?", modifier = GlanceModifier.padding(12.dp))
                  Row(horizontalAlignment = Alignment.CenterHorizontally) {
                      Button()
                      Button()
                      if (size.width > 250.dp) {
                          Button("School")
                      }
                  }
              }
          }
      }GlanceSnippets.kt

   This mode provides more flexibility than the others, but it comes with a few
   caveats:

   -  The ``AppWidget`` must be completely recreated each time the size changes.
      This can lead to performance issues and UI jumps when the content is complex.
   -  The available size might differ depending on the launcher's implementation.
      For example, if the launcher does not provide the list of sizes, the minimum
      possible size is used.
   -  In pre-Android 12 devices, the size calculation logic might not work in all
      situations.

   In general, you should use this mode if ``SizeMode.Responsive`` cannot be used
   (that is, a small set of responsive layouts isn't feasible).

   Access resources
   ----------------

   Use ``LocalContext.current`` to access any Android resource, as shown in the
   following example:

   .. code:: prettyprint

      LocalContext.current.getString(R.string.glance_title)GlanceSnippets.kt

   We recommend providing resource IDs directly to reduce the size of the final
   ``RemoteViews`` object and to enable dynamic resources, such as `dynamic colors  <#dynamic-colors>`__.

   Composables and methods accept resources using a "provider", such as
   ``ImageProvider``, or using an overload method like
   ``GlanceModifier.background(R.color.blue)``. For example:

   .. code:: prettyprint

      Column(
          modifier = GlanceModifier.background(R.color.default_widget_background)
      ) { /**...*/ }

      Image(
          provider = ImageProvider(R.drawable.ic_logo),
          contentDescription = "My image",
      )GlanceSnippets.kt

   .. _add-compound:

   Add compound buttons
   --------------------

   Compound buttons were `introduced in Android 12  <#new-compound-buttons>`__. Glance
   supports backwards compatibility for the following types of compound buttons:

   -  `Switch  <#Switch>`__
   -  `CheckBox  <#CheckBox>`__
   -  `RadioButton  <#RadioButton>`__

   These compound buttons each display a clickable view that represents the
   "checked" state.

   .. code:: prettyprint

      var isApplesChecked by remember { mutableStateOf(false) }
      var isEnabledSwitched by remember { mutableStateOf(false) }
      var isRadioChecked by remember { mutableStateOf(0) }

      CheckBox(
          checked = isApplesChecked,
          onCheckedChange = { isApplesChecked = !isApplesChecked },
          text = "Apples"
      )

      Switch(
          checked = isEnabledSwitched,
          onCheckedChange = { isEnabledSwitched = !isEnabledSwitched },
          text = "Enabled"
      )

      RadioButton(
          checked = isRadioChecked == 1,
          onClick = { isRadioChecked = 1 },
          text = "Checked"
      )GlanceSnippets.kt

   When the state changes, the provided lambda is triggered. You can store the
   check state, as shown in the following example:

   .. code:: prettyprint

      class MyAppWidget : GlanceAppWidget() {

          override suspend fun provideGlance(context: Context, id: GlanceId) {
              val myRepository = MyRepository.getInstance()

              provideContent {
                  val scope = rememberCoroutineScope()

                  val saveApple: (Boolean) -> Unit =
                      { scope.launch { myRepository.saveApple(it) } }
                  MyContent(saveApple)
              }
          }

          @Composable
          private fun MyContent(saveApple: (Boolean) -> Unit) {

              var isAppleChecked by remember { mutableStateOf(false) }

              Button(
                  text = "Save",
                  onClick = { saveApple(isAppleChecked) }
              )
          }
      }GlanceSnippets.kt

   You can also provide the ``colors`` attribute to ``CheckBox``, ``Switch``, and
   ``RadioButton`` to customize their colors:

   .. code:: prettyprint

      CheckBox(
          // ...
          colors = CheckboxDefaults.colors(
              checkedColor = ColorProvider(day = colorAccentDay, night = colorAccentNight),
              uncheckedColor = ColorProvider(day = Color.DarkGray, night = Color.LightGray)
          ),
          checked = isChecked,
          onCheckedChange = { isChecked = !isChecked }
      )

      Switch(
          // ...
          colors = SwitchDefaults.colors(
              checkedThumbColor = ColorProvider(day = Color.Red, night = Color.Cyan),
              uncheckedThumbColor = ColorProvider(day = Color.Green, night = Color.Magenta),
              checkedTrackColor = ColorProvider(day = Color.Blue, night = Color.Yellow),
              uncheckedTrackColor = ColorProvider(day = Color.Magenta, night = Color.Green)
          ),
          checked = isChecked,
          onCheckedChange = { isChecked = !isChecked },
          text = "Enabled"
      )

      RadioButton(
          // ...
          colors = RadioButtonDefaults.colors(
              checkedColor = ColorProvider(day = Color.Cyan, night = Color.Yellow),
              uncheckedColor = ColorProvider(day = Color.Red, night = Color.Blue)
          ),

      )GlanceSnippets.kt

   **Note:**\  See the
   `CompoundButtonAppWidget.kt <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/CompoundButtonAppWidget.kt>`__
   sample for a more detailed example.

Last updated 2024-03-25 UTC.

/Implement a Glance theme
=========================

.. https://developer.android.google.cn/develop/ui/compose/glance/theme?hl=en

.. container:: devsite-article-body clearfix

   Glance provides an API to manage the color theme. For other style attributes,
   such as
   `TextStyle  <#TextStyle>`__,
   declare top-level variables.

   .. rubric:: Add colors
      :name: add-colors

   Glance provides an implementation of Material colors out of the box. To use
   the built-in theme, wrap your top level composable with ``GlanceTheme``, as
   shown in the following example.

   On devices that support dynamic colors, this theme is derived from the
   user-specific platform colors. On other devices, this falls back to the
   Material baseline theme. Use ``GlanceTheme.colors`` to style with colors from
   the wrapped theme. You can use these values from the theme anywhere a color
   is needed.

   .. code:: prettyprint

      override suspend fun provideGlance(context: Context, id: GlanceId) {

          provideContent {
              GlanceTheme {
                  MyContent()
              }
          }
      }

      @Composable
      private fun MyContent() {

          Image(
              colorFilter = ColorFilter.tint(GlanceTheme.colors.secondary),
              // ...

          )
      }GlanceSnippets.kt

   To customize the theme, you can pass the ``colors`` to the ``GlanceTheme``.
   Glance provides the ``androidx.glance:glance-material`` interoperability
   library for Material 2, and ``androidx.glance:glance-material3`` for Material
   3 colors support.

   For example, provide your app's existing material colors to the
   ``ColorProviders`` API to create a Glance color scheme, as shown in the
   following snippet:

   .. code:: prettyprint

      // Remember, use the Glance imports
      // import androidx.glance.material3.ColorProviders

      // Example Imports from your own app
      // import com.example.myapp.ui.theme.DarkColors
      // import com.example.myapp.ui.theme.LightColors

      object MyAppWidgetGlanceColorScheme {

          val colors = ColorProviders(
              light = LightColors,
              dark = DarkColors
          )
      }GlanceSnippets.kt

   Provide the colors from the scheme to the ``GlanceTheme`` that wraps all your
   composables, as shown in the following example:

   .. code:: prettyprint

      override suspend fun provideGlance(context: Context, id: GlanceId) {
          // ...

          provideContent {
              GlanceTheme(colors = MyAppWidgetGlanceColorScheme.colors) {
                  MyContent()
              }
          }
      }

      @Composable
      private fun MyContent() {

          Image(
              colorFilter = ColorFilter.tint(GlanceTheme.colors.secondary),
              // ...
          )
      }GlanceSnippets.kt

   If you prefer to use dynamic colors from the wallpaper when supported, and
   your app's color scheme otherwise, you can conditionally pass your app's
   color scheme in the ``GlanceTheme``. This is shown in the following snippet:

   .. code:: prettyprint

      override suspend fun provideGlance(context: Context, id: GlanceId) {

          provideContent {
              GlanceTheme(
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S)
                      GlanceTheme.colors
                  else
                      MyAppWidgetGlanceColorScheme.colors
              ) {
                  MyContent()
              }
          }
      }

      @Composable
      private fun MyContent() {
          // ...
          Image(
              colorFilter = ColorFilter.tint(GlanceTheme.colors.secondary),
              // ...
          )
      }GlanceSnippets.kt

   .. rubric:: Add shapes
      :name: add-shapes

   To provide special shapes or shadows to your app widget, use the Android
   Drawables API.

   For example, the following snippet shows how to create a drawable (a shape):

   .. code:: prettyprint

      <shape xmlns:android="http://schemas.android.com/apk/res/android">
          <corners android:radius="16dp"/>
          <stroke android:color="@color/outline_color" android:width="1dp"/>
      </shape>button_outline.xml

   Provide it to the target composable:

   .. code:: prettyprint

      GlanceModifier.background(
          imageProvider = ImageProvider(R.drawable.button_outline)
      )GlanceSnippets.kt

   **Note:**\  You can use the Android resource folder structure to define
   different shapes or other resources for any type of configuration (e.g.,
   ``values-night``).

Last updated 2024-03-25 UTC.

/Glance interoperability
========================

.. https://developer.android.google.cn/develop/ui/compose/glance/interoperability?hl=en

.. container:: devsite-article-body clearfix

   In some cases, you may want to use XML and ``RemoteViews`` to provide a view.
   Perhaps you have already implemented a feature without Glance, or the feature
   is not yet available or possible with the current Glance API. For these
   situations, Glance provides ``AndroidRemoteViews``, an interoperability API.

   The ``AndroidRemoteViews`` composable allows ``RemoteViews`` to be placed
   together with your other composables:

   .. code:: prettyprint

      val packageName = LocalContext.current.packageName
      Column(modifier = GlanceModifier.fillMaxSize()) {
          Text("Isn't that cool?")
          AndroidRemoteViews(RemoteViews(packageName, R.layout.example_layout))
      }GlanceSnippets.kt

   Create and define the ``RemoteViews`` as you would without Glance, and simply
   pass it as a parameter.

   In addition, you can create ``RemoteViews`` containers for your composables:

   .. code:: prettyprint

      AndroidRemoteViews(
          remoteViews = RemoteViews(packageName, R.layout.my_container_view),
          containerViewId = R.id.example_view
      ) {
          Column(modifier = GlanceModifier.fillMaxSize()) {
              Text("My title")
              Text("Maybe a long content...")
          }
      }GlanceSnippets.kt

   In this case, a layout that contains the "container" is passed with the
   defined ID. This container must be a
   `ViewGroup  <#ViewGroup>`__, since it is used to
   place the defined content.

   **Note:**\  Any children of the defined container are removed and replaced
   with the content. Also, the provided ``ViewGroup`` must be supported by
   ``RemoteViews.`` See
   `RemoteViewsWidget.kt <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/RemoteViewsWidget.kt>`__
   for an example of using ``AndroidRemoteViews``.

Last updated 2024-03-25 UTC.

/Additional resources
=====================

.. https://developer.android.google.cn/develop/ui/compose/glance/additional-resources?hl=en

.. container:: devsite-article-body clearfix

   See the following Glance samples and showcases to learn more:

   -  `AppWidgets  samples <https://github.com/android/platform-samples/tree/main/samples/user-interface/appwidgets>`__:
      A sample demonstrating how to build Android ``AppWidgets`` with Jetpack
      Glance.
   -  `AndroidX demos <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/>`__:

      -  `How to use Actions <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/ActionAppWidget.kt>`__
      -  `How to use Compound buttons (switches, checkboxes) <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/CompoundButtonAppWidget.kt>`__
      -  How size modes work:

         -  `Exact mode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/ExactAppWidget.kt>`__
         -  `Responsive mode <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/ResponsiveAppWidget.kt>`__
         -  `Single mode (responsive) <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/ResizingAppWidget.kt>`__

      -  `How to use LazyColumn <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/ScrollableAppWidget.kt>`__
      -  `How to use Images <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/ImageAppWidget.kt>`__
      -  `How to use GlanceAppWidgetManager <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/GlanceAppWidgetDemoActivity.kt>`__
      -  `How to configure periodic work <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/samples/src/main/java/androidx/glance/appwidget/samples/GlanceAppWidgetSamples.kt;drc=c28b42063433bb0f928a897c0d6ec31b45ba2021;l=114>`__
      -  `How widgets don't crash, they show an error UI <https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:glance/glance-appwidget/integration-tests/demos/src/main/java/androidx/glance/appwidget/demos/ErrorUiAppWidget.kt>`__

   -  `Glance API Reference  <#package-summary>`__

Last updated 2024-03-25 UTC.
