
Mastering
STM32
A
step-by-step
guide
to
the
most
complete
ARM
Cortex-M
platform,
using
a
free
and
powerful
development
environment
based
on
Eclipse
and
GCC
Carmine
Noviello
This
book
is
for
sale
at
http://leanpub.com/mastering-stm32
This
version
was
published
on
2018-08-17
This
is
a
Leanpub
book.
Leanpub
empowers
authors
and
publishers
with
the
Lean
Publishing
process.
Lean
Publishing
is
the
act
of
publishing
an
in-progress
ebook
using
lightweight
tools
and
many
iterations
to
get
reader
feedback,
pivot
until
you
have
the
right
book
and
build
traction
once
you
do.
©
2015
-
2018
Carmine
Noviello
(by P3ATeam)
Tweet This Book!
Please help Carmine Noviello by spreading the word about this book on Twitter!
The suggested hashtag for this book is #MasteringSTM32.
Find out what other people are saying about the book by clicking on this link to search for this
hashtag on Twitter:
#MasteringSTM32
Contents
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . i
Why Did I Write the Book? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . i
Who Is This Book For? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ii
How to Integrate This Book? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . iii
How Is the Book Organized? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . iv
About the Author . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . vii
Errata and Suggestions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . viii
Book Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . viii
How to Help the Author . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ix
Copyright Disclaimer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ix
Credits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ix
Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . x
I Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1. Introduction to STM32 MCU Portfolio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.1 Introduction to ARM Based Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.1.1 Cortex and Cortex-M Based Processors . . . . . . . . . . . . . . . . . . . . 4
1.1.1.1 Core Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.1.1.2 Memory Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.1.1.3 Bit-Banding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.1.1.4 Thumb-2 and Memory Alignment . . . . . . . . . . . . . . . . 12
1.1.1.5 Pipeline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.1.1.6 Interrupts and Exceptions Handling . . . . . . . . . . . . . . . 15
1.1.1.7 SysTimer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.1.1.8 Power Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.1.1.9 CMSIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.1.1.10 Effective Implementation of Cortex-M Features in the
STM32 Portfolio . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
1.2 Introduction to STM32 Microcontrollers . . . . . . . . . . . . . . . . . . . . . . . . . . 21
1.2.1 Advantages of the STM32 Portfolio…. . . . . . . . . . . . . . . . . . . . . . 22
1.2.2 ….And Its Drawbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
CONTENTS
1.3 A Quick Look at the STM32 Subfamilies . . . . . . . . . . . . . . . . . . . . . . . . . . 24
1.3.1 F0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
1.3.2 F1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
1.3.3 F2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
1.3.4 F3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
1.3.5 F4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
1.3.6 F7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
1.3.7 H7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
1.3.8 L0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
1.3.9 L1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
1.3.10 L4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
1.3.11 L4+ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
1.3.12 STM32WB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
1.3.13 How to Select the Right MCU for You? . . . . . . . . . . . . . . . . . . . . 43
1.4 The Nucleo Development Board . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
2. Setting-Up the Tool-Chain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
2.1 Why Choose Eclipse/GCC as Tool-Chain for STM32 . . . . . . . . . . . . . . . . . . 53
2.1.1 Two Words About Eclipse… . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
2.1.2 … and GCC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
2.2 Windows - Installing the Tool-Chain . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
2.2.1 Windows - Eclipse Installation . . . . . . . . . . . . . . . . . . . . . . . . . 56
2.2.2 Windows - Eclipse Plug-Ins Installation . . . . . . . . . . . . . . . . . . . . 57
2.2.3 Windows - GCC ARM Embedded Installation . . . . . . . . . . . . . . . . 63
2.2.4 Windows – Build Tools Installation . . . . . . . . . . . . . . . . . . . . . . 64
2.2.5 Windows – OpenOCD Installation . . . . . . . . . . . . . . . . . . . . . . . 64
2.2.6 Windows – ST Tools and Drivers Installation . . . . . . . . . . . . . . . . 65
2.2.6.1 Windows – ST-LINK Firmware Upgrade . . . . . . . . . . . . 65
2.3 Linux - Installing the Tool-Chain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
2.3.1 Linux - Install i386 Run-Time Libraries on a 64-bit Ubuntu . . . . . . . . 67
2.3.2 Linux - Java Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
2.3.3 Linux - Eclipse Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
2.3.4 Linux - Eclipse Plug-Ins Installation . . . . . . . . . . . . . . . . . . . . . . 69
2.3.5 Linux - GCC ARM Embedded Installation . . . . . . . . . . . . . . . . . . 75
2.3.6 Linux - Nucleo Drivers Installation . . . . . . . . . . . . . . . . . . . . . . . 75
2.3.6.1 Linux – ST-LINK Firmware Upgrade . . . . . . . . . . . . . . 75
2.3.7 Linux – OpenOCD Installation . . . . . . . . . . . . . . . . . . . . . . . . . 76
2.3.8 Linux - ST Tools Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
2.4 Mac - Installing the Tool-Chain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
2.4.1 Mac - Eclipse Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
2.4.2 Mac - Eclipse Plug-Ins Installation . . . . . . . . . . . . . . . . . . . . . . . 83
2.4.3 Mac - GCC ARM Embedded Installation . . . . . . . . . . . . . . . . . . . 88
2.4.4 Mac - Nucleo Drivers Installation . . . . . . . . . . . . . . . . . . . . . . . 89
CONTENTS
2.4.4.1 Mac – ST-LINK Firmware Upgrade . . . . . . . . . . . . . . . 89
2.4.5 Mac – OpenOCD Installation . . . . . . . . . . . . . . . . . . . . . . . . . . 90
2.4.6 Mac - ST Tools Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
3. Hello, Nucleo! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
3.1 Get in Touch With the Eclipse IDE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
3.2 Create a Project . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
3.3 Connecting the Nucleo to the PC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
3.4 Flashing the Nucleo using STM32CubeProgrammer . . . . . . . . . . . . . . . . . . . 106
3.5 Understanding the Generated Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
4. STM32CubeMX Tool . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
4.1 Introduction to CubeMX Tool . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
4.1.1 Pinout View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
4.1.1.1 Chip View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
4.1.1.2 IP Tree Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
4.1.2 Clock View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
4.1.3 Configuration View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
4.1.4 Power Consumption Calculator View . . . . . . . . . . . . . . . . . . . . . 120
4.2 Project Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
4.2.1 Generate C Project with CubeMX . . . . . . . . . . . . . . . . . . . . . . . 121
4.2.1.1 Understanding Generated Code . . . . . . . . . . . . . . . . . 123
4.2.2 Create Eclipse Project . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
4.2.3 Importing Generated Files Into the Eclipse Project Manually . . . . . . . 128
4.2.4 Importing Files Generated With CubeMX Into the Eclipse Project
Automatically . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
4.3 Understanding Generated Application Code . . . . . . . . . . . . . . . . . . . . . . . . 134
4.3.1 Add Something Useful to the Firmware . . . . . . . . . . . . . . . . . . . . 139
4.4 Downloading Book Source Code Examples . . . . . . . . . . . . . . . . . . . . . . . . 140
5. Introduction to Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
5.1 Getting Started With OpenOCD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
5.1.1 Launching OpenOCD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
5.1.1.1 Launching OpenOCD on Windows . . . . . . . . . . . . . . . 146
5.1.1.2 Launching OpenOCD on Linux and MacOS X. . . . . . . . . 147
5.1.2 Connecting to the OpenOCD Telnet Console . . . . . . . . . . . . . . . . . 149
5.1.3 Configuring Eclipse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
5.1.4 Debugging in Eclipse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
5.2 ARM Semihosting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
5.2.1 Enable Semihosting on a New Project . . . . . . . . . . . . . . . . . . . . . 161
5.2.1.1 Using Semihosting With C Standard Library . . . . . . . . . 164
5.2.2 Enable Semihosting on an Existing Project . . . . . . . . . . . . . . . . . . 167
5.2.3 Semihosting Drawbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
5.2.4 Understanding How Semihosting Works . . . . . . . . . . . . . . . . . . . 168
CONTENTS
II Diving into the HAL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
6. GPIO Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
6.1 STM32 Peripherals Mapping and HAL Handlers . . . . . . . . . . . . . . . . . . . . . 174
6.2 GPIOs Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
6.2.1 GPIO Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
6.2.2 GPIO Alternate Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
6.2.3 Understanding GPIO Speed . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
6.3 Driving a GPIO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
6.4 De-initialize a GPIO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
7. Interrupts Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
7.1 NVIC Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
7.1.1 Vector Table in STM32 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
7.2 Enabling Interrupts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
7.2.1 External Lines and NVIC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
7.2.2 Enabling Interrupts With CubeMX . . . . . . . . . . . . . . . . . . . . . . . 199
7.3 Interrupt Lifecycle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
7.4 Interrupt Priority Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
7.4.1 Cortex-M0/0+ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
7.4.2 Cortex-M3/4/7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
7.4.3 Setting Interrupt Priority in CubeMX . . . . . . . . . . . . . . . . . . . . . 216
7.5 Interrupt Re-Entrancy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
7.6 Mask All Interrupts at Once or an a Priority Basis . . . . . . . . . . . . . . . . . . . . 218
8. Universal Asynchronous Serial Communications . . . . . . . . . . . . . . . . . . . . . . . 221
8.1 Introduction to UARTs and USARTs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
8.2 UART Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
8.2.1 UART Configuration Using CubeMX . . . . . . . . . . . . . . . . . . . . . 232
8.3 UART Communication in Polling Mode . . . . . . . . . . . . . . . . . . . . . . . . . . 233
8.3.1 Installing a Serial Console in Windows . . . . . . . . . . . . . . . . . . . . 237
8.3.2 Installing a Serial Console in Linux and MacOS X . . . . . . . . . . . . . 239
8.4 UART Communication in Interrupt Mode . . . . . . . . . . . . . . . . . . . . . . . . . 241
8.4.1 UART Related Interrupts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
8.5 Error Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
8.6 I/O Retargeting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
9. DMA Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
9.1 Introduction to DMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
9.1.1 The Need of a DMA and the Role of the Internal Buses . . . . . . . . . . 255
9.1.2 The DMA Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
9.1.2.1 The DMA Implementation in F0/F1/F3/L1 MCUs . . . . . . . 259
9.1.2.2 The DMA Implementation in F2/F4/F7 MCUs . . . . . . . . . 263
9.1.2.3 The DMA Implementation in L0/L4 MCUs . . . . . . . . . . 266
CONTENTS
9.2 HAL_DMA Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
9.2.1 DMA_HandleTypeDef in F0/F1/F3/L0/L1/L4 HALs . . . . . . . . . . . . . . . 267
9.2.2 DMA_HandleTypeDef in F2/F4/F7 HALs . . . . . . . . . . . . . . . . . . . . . 269
9.2.3 DMA_HandleTypeDef in L0/L4 HALs . . . . . . . . . . . . . . . . . . . . . . . 273
9.2.4 How to Perform Transfers in Polling Mode . . . . . . . . . . . . . . . . . . 273
9.2.5 How to Perform Transfers in Interrupt Mode . . . . . . . . . . . . . . . . . 276
9.2.6 How to Perform Peripheral-To-Peripheral Transfers . . . . . . . . . . . . 278
9.2.7 Using the HAL_UART Module With DMA Mode Transfers . . . . . . . . . . 279
9.2.8 Miscellaneous Functions From HAL_DMA and HAL_DMA_Ex Modules . . . . 281
9.3 Using CubeMX to Configure DMA Requests . . . . . . . . . . . . . . . . . . . . . . . 282
9.4 Correct Memory Allocation of DMA Buffers . . . . . . . . . . . . . . . . . . . . . . . 283
9.5 A Case Study: The DMA Memory-To-Memory Transfer Performance Analysis . . . 284
10. Clock Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
10.1 Clock Distribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
10.1.1 Overview of the STM32 Clock Tree . . . . . . . . . . . . . . . . . . . . . . 291
10.1.1.1 The Multispeed Internal RC Oscillator in STM32L Families 295
10.1.2 Configuring Clock Tree Using CubeMX . . . . . . . . . . . . . . . . . . . . 296
10.1.3 Clock Source Options in Nucleo Boards . . . . . . . . . . . . . . . . . . . . 298
10.1.3.1 OSC Clock Supply . . . . . . . . . . . . . . . . . . . . . . . . . 298
10.1.3.2 OSC 32kHz Clock Supply . . . . . . . . . . . . . . . . . . . . . 299
10.2 Overview of the HAL_RCC Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
10.2.1 Compute the Clock Frequency at Run-Time . . . . . . . . . . . . . . . . . 302
10.2.2 Enabling the Master Clock Output . . . . . . . . . . . . . . . . . . . . . . . 303
10.2.3 Enabling the Clock Security System . . . . . . . . . . . . . . . . . . . . . . 303
10.3 HSI Calibration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304
11. Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
11.1 Introduction to Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
11.1.1 Timer Categories in an STM32 MCU . . . . . . . . . . . . . . . . . . . . . . 307
11.1.2 Effective Availability of Timers in the STM32 Portfolio . . . . . . . . . . 309
11.2 Basic Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
11.2.1 Using Timers in Interrupt Mode . . . . . . . . . . . . . . . . . . . . . . . . . 314
11.2.1.1 Time Base Generation in Advanced Timers . . . . . . . . . . 316
11.2.2 Using Timers in Polling Mode . . . . . . . . . . . . . . . . . . . . . . . . . . 317
11.2.3 Using Timers in DMA Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
11.2.4 Stopping a Timer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320
11.2.5 Using CubeMX to Configure a Basic Timer . . . . . . . . . . . . . . . . . 320
11.3 General Purpose Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
11.3.1 Time Base Generator With External Clock Sources . . . . . . . . . . . . . 321
11.3.1.1 External Clock Mode 2 . . . . . . . . . . . . . . . . . . . . . . . 323
11.3.1.2 External Clock Mode 1 . . . . . . . . . . . . . . . . . . . . . . . 327
CONTENTS
11.3.1.3 UsingCubeMXtoConfiguretheSourceClockofaGeneral
Purpose Timer . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
11.3.2 Master/Slave Synchronization Modes . . . . . . . . . . . . . . . . . . . . . 333
11.3.2.1 Enable Trigger-Related Interrupts . . . . . . . . . . . . . . . . 338
11.3.2.2 Using CubeMX to Configure the Master/Slave Synchro-
nization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338
11.3.3 Generate Timer-Related Events by Software . . . . . . . . . . . . . . . . . 339
11.3.4 Counting Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
11.3.5 Input Capture Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342
11.3.5.1 Using CubeMX to Configure the Input Capture Mode . . . 349
11.3.6 Output Compare Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
11.3.6.1 Using CubeMX to Configure the Output Compare Mode . . 355
11.3.7 Pulse-Width Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
11.3.7.1 Generating a Sinusoidal Wave Using PWM . . . . . . . . . . 358
11.3.7.2 Using CubeMX to Configure the PWM Mode . . . . . . . . . 363
11.3.8 One Pulse Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364
11.3.8.1 Using CubeMX to Configure the OPM Mode . . . . . . . . . 366
11.3.9 Encoder Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
11.3.9.1 Using CubeMX to Configure the Encoder Mode . . . . . . . 372
11.3.10 Other Features Available in General Purpose and Advanced Timers . . . 372
11.3.10.1 Hall Sensor Mode . . . . . . . . . . . . . . . . . . . . . . . . . . 373
11.3.10.2 Combined Three-Phase PWM Mode and Other Motor-
Control Related Features . . . . . . . . . . . . . . . . . . . . . 373
11.3.10.3 Break Input and Locking of Timer Registers . . . . . . . . . . 374
11.3.10.4 Preloading of Auto-Reload Register . . . . . . . . . . . . . . . 374
11.3.11 Debugging and Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
11.4 SysTick Timer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376
11.4.1 Use Another Timer as System Timebase Source . . . . . . . . . . . . . . . 377
11.5 A Case Study: How to Precisely Measure Microseconds With STM32 MCUs . . . . 378
12. Analog-To-Digital Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 384
12.1 Introduction to SAR ADC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 384
12.2 HAL_ADC Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389
12.2.1 Conversion Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 391
12.2.1.1 Single-Channel, Single Conversion Mode . . . . . . . . . . . 391
12.2.1.2 Scan Single Conversion Mode . . . . . . . . . . . . . . . . . . 392
12.2.1.3 Single-Channel, Continuous Conversion Mode . . . . . . . . 392
12.2.1.4 Scan Continuous Conversion Mode . . . . . . . . . . . . . . . 393
12.2.1.5 Injected Conversion Mode . . . . . . . . . . . . . . . . . . . . 393
12.2.1.6 Dual Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
12.2.2 Channel Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
12.2.3 ADC Resolution and Conversion Speed . . . . . . . . . . . . . . . . . . . . 396
12.2.4 A/D Conversions in Polling Mode . . . . . . . . . . . . . . . . . . . . . . . 396
CONTENTS
12.2.5 A/D Conversions in Interrupt Mode . . . . . . . . . . . . . . . . . . . . . . 400
12.2.6 A/D Conversions in DMA Mode . . . . . . . . . . . . . . . . . . . . . . . . 401
12.2.6.1 Convert Multiple Times the Same Channel in DMA Mode . 404
12.2.6.2 Multiple and not Continuous Conversions in DMA Mode . 404
12.2.6.3 Continuous Conversions in DMA Mode . . . . . . . . . . . . 405
12.2.7 Errors Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 405
12.2.8 Timer-Driven Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406
12.2.9 Conversions Driven by External Events . . . . . . . . . . . . . . . . . . . . 409
12.2.10 ADC Calibration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
12.3 Using CubeMX to Configure ADC Peripheral . . . . . . . . . . . . . . . . . . . . . . . 410
13. Digital-To-Analog Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
13.1 Introduction to the DAC Peripheral . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
13.2 HAL_DAC Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415
13.2.1 Driving the DAC Manually . . . . . . . . . . . . . . . . . . . . . . . . . . . 417
13.2.2 Driving the DAC in DMA Mode Using a Timer . . . . . . . . . . . . . . . 419
13.2.3 Triangular Wave Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . 422
13.2.4 Noise Wave Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424
14. I²C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425
14.1 Introduction to the I²C specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 425
14.1.1 The I²C Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
14.1.1.1 START and STOP Condition . . . . . . . . . . . . . . . . . . . 428
14.1.1.2 Byte Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 428
14.1.1.3 Address Frame . . . . . . . . . . . . . . . . . . . . . . . . . . . 428
14.1.1.4 Acknowledge (ACK) and Not Acknowledge (NACK) . . . . 429
14.1.1.5 Data Frames . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
14.1.1.6 Combined Transactions . . . . . . . . . . . . . . . . . . . . . . 430
14.1.1.7 Clock Stretching . . . . . . . . . . . . . . . . . . . . . . . . . . 431
14.1.2 Availability of I²C Peripherals in STM32 MCUs . . . . . . . . . . . . . . . 431
14.2 HAL_I2C Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 433
14.2.1 Using the I²C Peripheral in Master Mode . . . . . . . . . . . . . . . . . . . 436
14.2.1.1 I/O MEM Operations . . . . . . . . . . . . . . . . . . . . . . . . 444
14.2.1.2 Combined Transactions . . . . . . . . . . . . . . . . . . . . . . 445
14.2.1.3 A Note About the Clock Configuration in STM32F0/L0/L4
families . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
14.2.2 Using the I²C Peripheral in Slave Mode . . . . . . . . . . . . . . . . . . . . 447
14.3 Using CubeMX to Configure the I²C Peripheral . . . . . . . . . . . . . . . . . . . . . . 453
15. SPI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455
15.1 Introduction to the SPI Specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455
15.1.1 Clock Polarity and Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 458
15.1.2 Slave Select Signal Management . . . . . . . . . . . . . . . . . . . . . . . . 459
15.1.3 SPI TI Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 459
CONTENTS
15.1.4 Availability of SPI Peripherals in STM32 MCUs . . . . . . . . . . . . . . . 460
15.2 HAL_SPI Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 461
15.2.1 Exchanging Messages Using SPI Peripheral . . . . . . . . . . . . . . . . . . 463
15.2.2 Maximum Transmission Frequency Reachable using the CubeHAL . . . 465
15.3 Using CubeMX to Configure SPI Peripheral . . . . . . . . . . . . . . . . . . . . . . . . 465
16. Cyclic Redundancy Check . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466
16.1 Introduction to CRC Computing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 466
16.1.1 CRC Calculation in STM32F1/F2/F4/L1 MCUs . . . . . . . . . . . . . . . . 469
16.1.2 CRC Peripheral in STM32F0/F3/F7/L0/L4 MCUs . . . . . . . . . . . . . . . 471
16.2 HAL_CRC Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 472
17. IWDG and WWDG Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 476
17.1 The Independent Watchdog Timer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 476
17.1.1 Using the CubeHAL to Program IWDG Timer . . . . . . . . . . . . . . . . 477
17.2 The System Window Watchdog Timer . . . . . . . . . . . . . . . . . . . . . . . . . . . . 478
17.2.1 Using the CubeHAL to Program WWDG Timer . . . . . . . . . . . . . . . 480
17.3 Detecting a System Reset Caused by a Watchdog Timer . . . . . . . . . . . . . . . . 481
17.4 Freezing Watchdog Timers During a Debug Session . . . . . . . . . . . . . . . . . . . 482
17.5 Selecting the Right Watchdog Timer for Your Application . . . . . . . . . . . . . . . 482
18. Real-Time Clock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483
18.1 Introduction to the RTC Peripheral . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483
18.2 HAL_RTC Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 485
18.2.1 Setting and Retrieving the Current Date/Time . . . . . . . . . . . . . . . . 486
18.2.1.1 Correct Way to Read Date/Time Values . . . . . . . . . . . . 488
18.2.2 Configuring Alarms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 489
18.2.3 Periodic Wakeup Unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
18.2.4 Timestamp Generation and Tamper Detection . . . . . . . . . . . . . . . . 493
18.2.5 RTC Calibration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
18.2.5.1 RTC Coarse Calibration . . . . . . . . . . . . . . . . . . . . . . 494
18.2.5.2 RTC Smooth Calibration . . . . . . . . . . . . . . . . . . . . . 494
18.2.5.3 Reference Clock Detection . . . . . . . . . . . . . . . . . . . . 496
18.3 Using the Backup SRAM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 496
III Advanced topics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 498
19. Power Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499
19.1 Power Management in Cortex-M Based MCUs . . . . . . . . . . . . . . . . . . . . . . 499
19.2 How Cortex-M MCUs Handle Run and Sleep Modes . . . . . . . . . . . . . . . . . . 500
19.2.1 Entering/exiting sleep modes . . . . . . . . . . . . . . . . . . . . . . . . . . 503
19.2.1.1 Sleep-On-Exit . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505
19.2.2 Sleep Modes in Cortex-M Based MCUs . . . . . . . . . . . . . . . . . . . . 505
CONTENTS
19.3 Power Management in STM32F Microcontrollers . . . . . . . . . . . . . . . . . . . . . 506
19.3.1 Power Sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 506
19.3.2 Power Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 507
19.3.2.1 Run Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 508
19.3.2.1.1 Dynamic Voltage Scaling in STM32F4/F7 MCUs . . . . . . . . . 509
19.3.2.1.2 Over/Under-Drive Mode in STM32F4/F7 MCUs . . . . . . . . . 510
19.3.2.2 Sleep Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510
19.3.2.3 Stop Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 511
19.3.2.4 Standby Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . 512
19.3.2.5 Low-Power Modes Example . . . . . . . . . . . . . . . . . . . 512
19.3.3 An Important Warning for STM32F1 Microcontrollers . . . . . . . . . . . 516
19.4 Power Management in STM32L Microcontrollers . . . . . . . . . . . . . . . . . . . . . 518
19.4.1 Power Sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 518
19.4.2 Power Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 520
19.4.2.1 Run Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 520
19.4.2.2 Sleep Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 522
19.4.2.2.1 Batch Acquisition Mode . . . . . . . . . . . . . . . . . . . . . . . . 523
19.4.2.3 Stop Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 523
19.4.2.4 Standby Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . 524
19.4.2.5 Shutdown Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . 525
19.4.3 Power Modes Transitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 525
19.4.4 Low-Power Peripherals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526
19.4.4.1 LPUART . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526
19.4.4.2 LPTIM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
19.5 Power Supply Supervisors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
19.6 Debugging in Low-Power Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528
19.7 Using the CubeMX Power Consumption Calculator . . . . . . . . . . . . . . . . . . . 528
19.8 A Case Study: Using Watchdog Timers With Low-Power Modes . . . . . . . . . . . 529
20. Memory layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
20.1 The STM32 Memory Layout Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531
20.1.1 Understanding Compilation and Linking Processes . . . . . . . . . . . . . 533
20.2 The Really Minimal STM32 Application . . . . . . . . . . . . . . . . . . . . . . . . . . 536
20.2.1 ELF Binary File Inspection . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540
20.2.2 .data and .bss Sections Initialization . . . . . . . . . . . . . . . . . . . . . 542
20.2.2.1 A Word About the COMMON Section . . . . . . . . . . . . . . . . 548
20.2.3 .rodata Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550
20.2.4 Stack and Heap Regions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 551
20.2.5 Checking the Size of Heap and Stack at Compile-Time . . . . . . . . . . . 554
20.2.6 Differences With the Tool-Chain Script Files . . . . . . . . . . . . . . . . . 555
20.3 How to Use the CCM Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
20.3.1 Relocating the vector table in CCM Memory . . . . . . . . . . . . . . . . . 560
20.4 How to Use the MPU in Cortex-M0+/3/4/7 Based STM32 MCUs . . . . . . . . . . . 563
CONTENTS
20.4.1 Programming the MPU With the CubeHAL . . . . . . . . . . . . . . . . . 567
21. Flash Memory Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 570
21.1 Introduction to STM32 Flash Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . 570
21.2 The HAL_FLASH Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 573
21.2.1 Flash Memory Unlocking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 574
21.2.2 Flash Memory Erasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 574
21.2.3 Flash Memory Programming . . . . . . . . . . . . . . . . . . . . . . . . . . 576
21.2.4 Flash Read Access During Programming and Erasing . . . . . . . . . . . 577
21.3 Option Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577
21.3.1 Flash Memory Read Protection . . . . . . . . . . . . . . . . . . . . . . . . . 579
21.4 Optional OTP and True-EEPROM Memories . . . . . . . . . . . . . . . . . . . . . . . 581
21.5 Flash Read Latency and the ART™ Accelerator . . . . . . . . . . . . . . . . . . . . . . 582
21.5.1 The Role of the TCM Memories in STM32F7 MCUs . . . . . . . . . . . . . 585
21.5.1.1 How to Access Flash Memory Through the TCM Interface . 590
21.5.1.2 Using CubeMX to Configure Flash Memory Interface . . . . 592
22. Booting Process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
22.1 The Cortex-M Unified Memory Layout and the Booting Process . . . . . . . . . . . 593
22.1.1 Software Physical Remap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 594
22.1.2 Vector Table Relocation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 595
22.1.3 Running the Firmware From SRAM Using the GNU MCU Eclipse
Toolchain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 597
22.2 Integrated Bootloader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 598
22.2.1 Starting the Bootloader From the On-Board Firmware . . . . . . . . . . . 600
22.2.2 The Booting Sequence in the GNU MCU Eclipse Tool-chain . . . . . . . 601
22.3 Developing a Custom Bootloader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 604
22.3.1 Vector Table Relocation in STM32F0 Microcontrollers . . . . . . . . . . . 614
22.3.2 How to Use the flasher.py Tool . . . . . . . . . . . . . . . . . . . . . . . . 617
23. Running FreeRTOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 620
23.1 Understanding the Concepts Underlying an RTOS . . . . . . . . . . . . . . . . . . . . 621
23.2 Introduction to FreeRTOS and CMSIS-RTOS Wrapper . . . . . . . . . . . . . . . . . 627
23.2.1 The FreeRTOS Source Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . 628
23.2.1.1 How to Import FreeRTOS Manually . . . . . . . . . . . . . . 629
23.2.1.2 How to Import FreeRTOS Using CubeMX and CubeMX-
Importer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 630
23.2.1.3 How to Enable FPU Support in Cortex-M4F and Cortex-
M7 Cores . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 632
23.3 Thread Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 632
23.3.1 Thread States . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 635
23.3.2 Thread Priorities and Scheduling Policies . . . . . . . . . . . . . . . . . . . 636
23.3.3 Voluntary Release of the Control . . . . . . . . . . . . . . . . . . . . . . . . 639
23.3.4 The idle Thread . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 640
CONTENTS
23.4 Memory Allocation and Management . . . . . . . . . . . . . . . . . . . . . . . . . . . 641
23.4.1 Dynamic Memory Allocation Model . . . . . . . . . . . . . . . . . . . . . . 642
23.4.1.1 heap_1.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 643
23.4.1.2 heap_2.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 644
23.4.1.3 heap_3.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 644
23.4.1.4 heap_4.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 644
23.4.1.5 heap_5.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 645
23.4.1.6 How to Use malloc() and Related C Functions With
FreeRTOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 645
23.4.1.7 FreeRTOS Heap Definition . . . . . . . . . . . . . . . . . . . . 646
23.4.2 Static Memory Allocation Model . . . . . . . . . . . . . . . . . . . . . . . . 646
23.4.2.1 idle Thread Allocation With Static Memory Allocation
Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 647
23.4.3 Memory Pools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 647
23.4.4 Stack Overflow Detection . . . . . . . . . . . . . . . . . . . . . . . . . . . . 649
23.5 Synchronization Primitives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 651
23.5.1 Message Queues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 651
23.5.2 Semaphores . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 655
23.5.3 Thread Signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 658
23.6 Resources Management and Mutual Exclusion . . . . . . . . . . . . . . . . . . . . . . 658
23.6.1 Mutexes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 659
23.6.1.1 The Priority Inversion Problem . . . . . . . . . . . . . . . . . 660
23.6.1.2 Recursive Mutexes . . . . . . . . . . . . . . . . . . . . . . . . . 661
23.6.2 Critical Sections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 661
23.6.3 Interrupt Management With an RTOS . . . . . . . . . . . . . . . . . . . . . 662
23.6.3.1 FreeRTOS API and Interrupt Priorities . . . . . . . . . . . . . 663
23.7 Software Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 664
23.7.1 How FreeRTOS Manages Timers . . . . . . . . . . . . . . . . . . . . . . . . 666
23.8 A Case Study: Low-Power Management With an RTOS . . . . . . . . . . . . . . . . . 666
23.8.1 The idle Thread Hook . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 667
23.8.2 The Tickless Mode in FreeRTOS . . . . . . . . . . . . . . . . . . . . . . . . 668
23.8.2.1 A Schema for the tickless Mode . . . . . . . . . . . . . . . . . 670
23.8.2.2 A Custom tickless Mode Policy . . . . . . . . . . . . . . . . . 674
23.9 Debugging Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 681
23.9.1 configASSERT() Macro . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 681
23.9.2 Run-Time Statistics and Thread State Information . . . . . . . . . . . . . 682
23.10 Alternatives to FreeRTOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 685
23.10.1 ChibiOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 686
23.10.2 Contiki OS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 686
23.10.3 OpenRTOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 687
24. Advanced Debugging Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 688
24.1 Understanding Cortex-M Fault-Related Exceptions . . . . . . . . . . . . . . . . . . . 688
CONTENTS
24.1.1 The Cortex-M Exception Entrance Sequence and the ARM Calling
Convention . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 690
24.1.1.1 How the GNU MCU Eclipse Tool-chain Handles Fault-
Related Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . 695
24.1.1.2 How to Interpret the Content of the LR Register on Excep-
tion Entrance . . . . . . . . . . . . . . . . . . . . . . . . . . . . 696
24.1.2 Fault Exceptions and Faults Analysis . . . . . . . . . . . . . . . . . . . . . 697
24.1.2.1 Memory Management Exception . . . . . . . . . . . . . . . . 698
24.1.2.2 Bus Fault Exception . . . . . . . . . . . . . . . . . . . . . . . . 698
24.1.2.3 Usage Fault Exception . . . . . . . . . . . . . . . . . . . . . . . 699
24.1.2.4 Hard Fault Exception . . . . . . . . . . . . . . . . . . . . . . . 700
24.1.2.5 Enabling Optional Fault Handlers . . . . . . . . . . . . . . . . 701
24.1.2.6 Fault Analysis in Cortex-M0/0+ Based Processors . . . . . . 701
24.2 Eclipse Advanced Debugging Features . . . . . . . . . . . . . . . . . . . . . . . . . . . 702
24.2.1 Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 702
24.2.1.1 Memory Monitors . . . . . . . . . . . . . . . . . . . . . . . . . 703
24.2.2 Watchpoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 704
24.2.3 Instruction Stepping Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . 705
24.2.4 Keil Packs and Peripheral Registers View . . . . . . . . . . . . . . . . . . . 706
24.2.5 Core Registers View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
24.3 Debugging Aids From the CubeHAL . . . . . . . . . . . . . . . . . . . . . . . . . . . . 710
24.4 External Debuggers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 710
24.4.1 Using SEGGER J-Link for ST-LINK Debugger . . . . . . . . . . . . . . . . 712
24.4.2 Using the ITM Interface and SWV Tracing . . . . . . . . . . . . . . . . . . 716
24.5 STM Studio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 717
24.6 Debugging two Nucleo Boards Simultaneously . . . . . . . . . . . . . . . . . . . . . . 719
25. FAT Filesystem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 722
25.1 Introduction to FatFs Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 722
25.1.1 Using CubeMX to Include FatFs Library in Your Projects . . . . . . . . . 725
25.1.1.1 The Generic Disk Interface API . . . . . . . . . . . . . . . . . 726
25.1.1.2 The Implementation of a Driver to Access SD Cards in SPI
Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 727
25.1.2 Relevant FatFs Structures and Functions . . . . . . . . . . . . . . . . . . . 728
25.1.2.1 Mounting a Filesystem . . . . . . . . . . . . . . . . . . . . . . . 728
25.1.2.2 Opening a File . . . . . . . . . . . . . . . . . . . . . . . . . . . . 728
25.1.2.3 Reading From/Writing Into a File . . . . . . . . . . . . . . . . 729
25.1.2.4 Creating and Opening a Directory . . . . . . . . . . . . . . . 730
25.1.3 How to Configure the FatFs Library . . . . . . . . . . . . . . . . . . . . . . 733
26. Develop IoT Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 735
26.1 Solutions Offered by STM to Develop IoT Applications . . . . . . . . . . . . . . . . . 736
26.2 The W5500 Ethernet Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 738
CONTENTS
26.2.1 How to Use the W5500 Shield and the ioLibrary_Driver Module . . . . 742
26.2.1.1 Configuring the SPI Interface . . . . . . . . . . . . . . . . . . 744
26.2.1.2 Configuring the Socket Buffers and the Network Interface . 745
26.2.2 Socket APIs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 747
26.2.2.1 Handling Sockets in TCP Mode . . . . . . . . . . . . . . . . . 749
26.2.2.2 Handling Sockets in UDP Mode . . . . . . . . . . . . . . . . . 749
26.2.3 I/O Retargeting to a TCP/IP Socket . . . . . . . . . . . . . . . . . . . . . . . 750
26.2.4 Setting up an HTTP Server . . . . . . . . . . . . . . . . . . . . . . . . . . . 752
26.2.4.1 A Web-Based Oscilloscope . . . . . . . . . . . . . . . . . . . . 754
27. Getting Started With a New Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 767
27.1 Hardware Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 767
27.1.1 PCB Layer Stack-Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 768
27.1.2 MCU Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 769
27.1.3 Decoupling of Power-Supply Pins . . . . . . . . . . . . . . . . . . . . . . . 770
27.1.4 Clocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 772
27.1.5 Filtering of RESET Pin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 773
27.1.6 Debug Port . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 773
27.1.7 Boot Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 775
27.1.8 Pay attention to “pin-to-pin” Compatibility… . . . . . . . . . . . . . . . . 776
27.1.9 …And to Selecting the Right Peripherals . . . . . . . . . . . . . . . . . . . 777
27.1.10 The Role of CubeMX During the Board Design Stage . . . . . . . . . . . 777
27.1.11 Board Layout Strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 780
27.2 Software Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 781
27.2.1 Generating the binary image for production . . . . . . . . . . . . . . . . . 781
Appendix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 784
A. Miscellaneous HAL functions and STM32 features . . . . . . . . . . . . . . . . . . . . . . . . 785
Force MCU reset from the firmware . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 785
STM32 96-bit Unique CPU ID . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 785
B. Troubleshooting guide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 787
GNU MCU Eclipse Installation Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 787
Eclipse related issue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 787
Eclipse cannot locate the compiler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 788
Eclipse continuously breaks at every instruction during debug session . . . . . . . . 789
The step-by-step debugging is really slow . . . . . . . . . . . . . . . . . . . . . . . . . 789
The firmware works only under a debug session . . . . . . . . . . . . . . . . . . . . . 790
STM32 related issue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 790
The microcontroller does not boot correctly . . . . . . . . . . . . . . . . . . . . . . . . 790
It is Not Possibile to Flash or to Debug the MCU . . . . . . . . . . . . . . . . . . . . . 792
CONTENTS
C. Nucleo pin-out . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 793
Nucleo-F446RE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 794
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 794
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 794
Nucleo-F411RE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 795
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 795
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 795
Nucleo-F410RB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 796
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 796
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 796
Nucleo-F401RE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 797
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 797
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 797
Nucleo-F334R8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 798
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 798
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 798
Nucleo-F303RE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 799
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 799
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 799
Nucleo-F302R8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 800
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 800
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 800
Nucleo-F103RB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 801
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 801
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 801
Nucleo-F091RC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 802
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 802
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 802
Nucleo-F072RB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 803
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 803
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 803
Nucleo-F070RB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 804
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 804
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 804
Nucleo-F030R8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 805
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 805
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 805
Nucleo-L476RG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 806
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 806
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 806
Nucleo-L152RE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 807
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 807
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 807
CONTENTS
Nucleo-L073R8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 808
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 808
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 808
Nucleo-L053R8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 809
Arduino compatible headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 809
Morpho headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 809
D. STM32 packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 810
LFBGA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 810
LQFP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 810
TFBGA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 811
TSSOP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 811
UFBGA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 811
UFQFPN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 812
VFQFP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 812
WLCSP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 812
E. History of this book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 814
Release 0.1 - October 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 814
Release 0.2 - October 28th, 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 814
Release 0.2.1 - October 31th, 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 814
Release 0.2.2 - November 1st, 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 815
Release 0.3 - November 12th, 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 815
Release 0.4 - December 4th, 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 815
Release 0.5 - December 19th, 2015 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 815
Release 0.6 - January 18th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 816
Release 0.6.1 - January 20th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 816
Release 0.6.2 - January 30th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 816
Release 0.7 - February 8th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 816
Release 0.8 - February 18th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 817
Release 0.8.1 - February 23th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 817
Release 0.9 - March 27th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 817
Release 0.9.1 - March 28th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 817
Release 0.10 - April 26th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 818
Release 0.11 - May 27th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 818
Release 0.11.1 - June 3rd, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 819
Release 0.11.2 - June 24th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 819
Release 0.12 - July 4th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 819
Release 0.13 - July 18th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 819
Release 0.14 - August 12th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 819
Release 0.15 - September 13th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 820
Release 0.16 - October 3th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 820
Release 0.17 - October 24th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 820
CONTENTS
Release 0.18 - November 15th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 821
Release 0.19 - November 29th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 821
Release 0.20 - December 28th, 2016 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 821
Release 0.21 - January 29th, 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 821
Release 0.22 - May 2nd, 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 822
Release 0.23 - July 20th, 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 822
Release 0.24 - December 11th, 2017 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 822
Release 0.25 - January 3rd, 2018 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 823
Release 0.26 - May 7th, 2018 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 823
Preface
As far as I know this book is the first attempt to write a systematic text about the STM32 platform
and its official STM32Cube HAL. When I started dealing with this microcontroller architecture, I
searched far and wide for a book able to introduce me to the subject, with no success.
The book is divided in three parts: an introductory part showing how to setup a complete
development environment and how to work with it; a part that introduces the basics of STM32
programming and the main aspects of the official HAL (Hardware Abstraction Layer); a more
advanced section covering aspects such as the use of a Real Time Operating Systems, the boot
sequence and the memory layout of an STM32 application.
However,thisbookdoesnotaimtoreplaceofficialdatasheetsfromSTMicroelectronics.Adatasheet
isstillthemainreferenceaboutelectronicdevices,anditisimpossible(aswellasmakinglittlesense)
toarrangethecontentoftensofdatasheetsinabook.Youhavetoconsiderthattheofficialdatasheet
of the STM32F4 MCU alone is almost one thousand pages, that is more than a book! Hence, this
text will offer a hint to start diving inside the official documentation from ST. Moreover, this book
will not focus on low-level topics and questions related to the hardware, leaving this hard work
to datasheets. Lastly, this book is not a cookbook about custom and funny projects: you will find
several good tutorials on the web.
Why Did I Write the Book?
I started to cover topics about STM32 programming on my personal blog in 2013. I first started
writing posts only in Italian and then translating them into English. I covered several topics, ranging
from how to setup a complete free tool-chain to specific aspects related to STM32 programming.
Since then, I have received plenty of comments and requests about all kinds of topics. Thanks to
the interaction with readers of my blog, I realized that it is not simple to cover complex topics in
depth on a personal web site. A blog is an excellent place where to cover really specific and limited
topics. If you need to explain broader topics involving software frameworks or hardware, a book is
still the right answer. A book forces you to organize topics in a systematic way, and gives you all the
necessary space to expand the subject as needed (I am one of those people who still believe reading
long texts on a monitor is a bad idea).
For reasons that I do not know, there are no books¹ covering the topics presented here. To be honest,
in the hardware industry is not so common to find books about microcontrollers, and this is really
strange.Comparedtosoftware,hardwarehasmuchgreaterlongevity.Forexample,allSTM32MCUs
¹ Thisisnotexactlytrue,sincethereisagoodandfreebookfromGeoffreyBrownofUniversityofIndiana(http://bit.ly/1Rc1tMl).However,
in my opinion, it goes too quickly to the point, leaving out important topics such as the use of a complete tool-chain. It also does not cover
the STM32Cube HAL, which has replaced the old std peripheral library . Finally, it does not show the differences between each STM32
subfamily and it is focused only on the STM32F4 family.
Preface ii
have a guaranteed life of ten years starting from January 2017 (ST has been updating this “starting
date” every year until now). This means that a book on this subject may potentially have the same
lifeexpectation,andthisisreallyuncommonincomputerscience.Apartfromsomereallyimportant
titles, most technical books have a shelf-life of two years or less.
I think that there are several reasons why this happens. First of all, in the electronics industryknow-
how is still a great value to protect. Compared to the software world, hardware requires years of
field experience. Every mistake has a cost, and it is highly dependent on the product stage (if the
device is already on the market, an issue may have dramatic costs). For this reason, electronics
engineers and firmware developers tend to protect their know-how, and this may be one of the
reasons discouraging really experienced users from writing books about these topics.
I believe another reason being that if you want to write a book about an MCU, you must be able
to range from aspects of electronics to more high-level programming topics. This requires a lot of
time and effort, and it is really hard especially when things change at a high pace (during the time of
writing the first few chapters of this book, ST has released more then twenty versions of its HAL). In
theelectronicsindustry,hardwareengineersandfirmwaredevelopersaretraditionallytwodifferent
figures, and sometimes they do not know what the other is doing.
Finally, another important reason is that electronics design becomes sort of a niche when compared
to the software world (there is great disparity between the number of software programmers and
electronics designers), and the STM32 is itself a niche within the niche.
For these and other minor reasons, I decided to write this book using a self-publishing platform like
LeanPub, which allows you to build a book progressively. I think that the idea behind LeanPub is
perfectforbooksaboutnichesubjects,anditgivesauthorsthetimeandtoolstowriteaboutasmuch
complex topics as they want.
Who Is This Book For?
This book is addressed to novices of the STM32 platform, interested in learning in less time how to
program these fantastic microcontrollers. However, this book is not for people completely new to the
C language or embedded programming. I assume you have a decent knowledge of C and are not new
to most fundamental concepts of digital electronics and MCU programming. The perfect reader of
this book may be both a hobbyist or a student who is familiar with the Arduino platform and wants
to learn a more powerful and comprehensive architecture, or a professional in charge of working
with an MCU he/she does not know yet.
Preface iii
What About Arduino?
I received this question many times from several people in doubt about which MCU platform to
learn. The answer is not simple, for several reasons.
First of all, Arduino is not a given MCU family or a silicon manufacturer. Arduino is both a brand
and an ecosystem. There are tens of Arduino development boards available on the market, even if
it is common to refer to the Arduino UNO board as “the Arduino”. Arduino UNO is a development
board built around the ATMega328, an 8-bit microcontroller designed by Atmel. Atmel is one of the
leadingcompanies,togetherwithMicrochip,thatrulethe8-bitMCUsegment.However,Arduinois
notonlyacoldpieceofhardware,butitisalsoacommunitybuiltaroundtheArduinoIDE(aderived
version of Processing) and the Arduino libraries, which greatly simplify the development process
on ATMega MCUs. This really large and continuously growing community has developed hundred
of libraries to interface as many hardware devices, and thousand of examples and applications.
So,thequestionis:“IsArduinogoodforprofessionalapplicationsorforthosewantingtodevelopthe
lastmainstreamproductonKickstarter?”.Theansweris:“YES,definitively.”.Imyselfhavedeveloped
a couple of custom boards for a customer, and being these boards based on the ATMega328 IC (the
SMD version), the firmware was developed using the Arduino IDE. So, it is not true that Arduino is
only for hobbyists and students.
However, if you are looking for something more powerful than an 8-bit MCU or if you want to
increase your knowledge about firmware programming (the Arduino environment hides too much
detail about what’s under the hood), the STM32 is probably the best choice for you. Thanks to an
Open Source development environment based on Eclipse and GCC, you will not have to invest a
fortune to start developing STM32 applications. Moreover, if you are building a cost sensitive device,
where each PCB square inch makes a difference for you, consider that the STM32F0 value line is
also known as the 32-bits MCU for 32 cents. This means that the low-cost STM32 line has a price
perfectlycomparablewith8-bitMCUs,butoffersalotmorecomputingpower,hardwarecapabilities
and integrated peripherals.
 https://www.arduino.cc/
 Microchip has acquired Atmel in January 2016.
 https://processing.org/
How to Integrate This Book?
Thisbookdoesnotaimtobeafull-comprehensiveguidetoSTM32microcontrollers,butisessentially
a guide to developing applications using the official ST HAL. It is strongly suggested to integrate it
with a book about the ARM Cortex-M architecture, and the series by Joseph Yiu² is the best source
for every Cortex-M developer.
² http://amzn.to/1P5sZwq
Preface iv
How Is the Book Organized?
The book is divided in twenty-seven chapters, and they cover the following topics.
Chapter 1 gives a brief and preliminary introduction to the STM32 platform. It presents the
main aspects of these microcontrollers, introducing the reader to the ARM Cortex-M architecture.
Moreover, the key features of each STM32 subfamily (L0, F1, etc.) are briefly explained. The chapter
also introduces the development board used throughout this book as testing board for the presented
topics: the Nucleo.
Chapter 2 shows how to setup a complete and working tool-chain to start developing STM32
applications. The chapter is divided in three different branches, each one explaining the tool-chain
setup process for the Windows, Linux and Mac OS X platforms.
Chapter 3 is dedicated to showing how to build the first application for the STM32 Nucleo
development board. This is a really simple application, a blinking led, which is with no doubt the
Hello World application of hardware.
Chapter 4 is about the STM32CubeMX tool, our main companion every time we need to start a
new application based on an STM32 MCUs. The chapter gives a hands-on presentation of the tool,
explaining its characteristics and how to configure the MCU peripherals according to the features
we need. Moreover, it explains how to dive into the generated code and customize it, as well as how
to import a project generated with it into the Eclipse IDE.
Chapter 5 introduces the reader to debugging. A hand-on presentation of OpenOCD is given,
showing how to integrate it in Eclipse. Moreover, a brief view of Eclipse’s debugging capabilities is
presented. Finally, the reader is introduced to a really important topic: ARM semihosting.
Chapter6givesaquickoverviewoftheSTCubeHAL,explaininghowperipheralsaremappedinside
the HAL using handlers to the peripheral memory mapped region. Next, it presents the HAL_GPIO
libraries and all the configuration options offered by STM32 GPIOs.
Chapter 7 explains the mechanisms underlying the NVIC controller: the hardware unit integrated
in every STM32 MCU which is responsible for the management of exceptions and interrupts. The
HAL_NVIC module is introduced extensively, and the differences between Cortex-M0/0+ and Cortex-
M3/4/7 are highlighted.
Chapter 8 gives a practical introduction to the HAL_UART module used to program the UART
interfaces provided by all STM32 microcontrollers. Moreover, a quick introduction to the difference
between UART and USART interfaces is given. Two ways to exchange data between devices using
a UART are presented: polling and interrupt oriented modes. Finally we present in a practical way
how to use the integrated VCP of every Nucleo board, and how to retarget the printf() / scanf()
functions using the Nucleo’s UART.
Chapter9talksabouttheDMAcontroller,showingthedifferencesbetweenseveralSTM32families.
A more detailed overview of the internals of an STM32 MCU is presented, describing the relations
between the Cortex-M core, DMA controllers and slave peripherals. Moreover, it shows how to
Preface v
use the HAL_DMA module in both polling and interrupt modes. Finally, a performance analysis of
memory-to-memory transfers is presented.
Chapter 10 introduces the clock tree of an STM32 microcontroller, showing main functional blocks
and how to configure them using the HAL_RCC module. Moreover, the CubeMX Clock configuration
view is presented, explaining how to change its settings to generate the right clock configuration.
Chapter 11 is a walkthrough into timers, one of the most advanced and highly customizable
peripherals implemented in every STM32 microcontroller. The chapter will guide the reader step-
by-step through this subject, introducing the most fundamental concepts of basic, general purpose
and advanced timers. Moreover, several advanced usage modes (master/slave, external trigger, input
capture, output compare, PWM, etc.) are illustrated with practical examples.
Chapter12providesanoverviewoftheAnalogToDigital (ADC)peripheral.Itintroducesthereader
to the concepts underlying SAR ADCs and then it explains how to program this useful peripheral
using the designated CubeHAL module. Moreover, this chapter provides a practical example that
shows how to use a hardware timer to drive ADC conversions in DMA mode.
Chapter 13 briefly introduces the Digital To Analog (DAC) peripheral. It provides the most
fundamental concepts underlying R-2R DACs and how to program this useful peripheral using the
designated CubeHAL module. This chapter also shows an example detailing how to use a hardware
timer to drive DAC conversions in DMA mode.
Chapter 14 is dedicated to the I²C bus. The chapter starts introducing the essentials of the I²C
protocol, and then it shows the most relevant routines from the CubeHAL to use this peripheral.
Moreover, a complete example that explains how to develop I²C slave applications is also shown.
Chapter 15 is dedicated to the SPI bus. The chapter starts introducing the essentials of the
SPI specification, and then it shows the most relevant routines from the CubeHAL to use this
fundamental peripheral.
Chapter 16 talks about the CRC peripheral, briefly introducing the math behind its calculation, and
it shows the related CubeHAL module used to program it.
Chapter 17 is about IWDT and WWDT timers, and it briefly introduces their role and how to use
the related CubeHAL modules to program them.
Chapter18talksabouttheRTCperipheralanditsmainfunctionalities.ThemostrelevantCubeHAL
routines to program the RTC are also shown.
Chapter 19 introduces the reader to the power management capabilities offered by STM32F
and STM32L microcontrollers. It starts showing how Cortex-M cores handle low-power modes,
introducing WFI and WFE instructions. Then it explains how these modes are implemented in STM32
MCUs. The corresponding HAL_PWR module is also described.
Chapter 20 analyzes the activities involved during the compilation and linking processes, which
define the memory layout of an STM32 application. A really bare-bone application is shown, and a
complete and working linker script is designed from scratch, showing how to organize the STM32
memory space. Moreover, the usage of CCM RAM is presented, as well as other important Cortex-M
functionalities like the vector table relocation.
Preface vi
Chapter 21 provides an introduction to the internal flash memory, and its related controller,
available in all STM32 microcontrollers. It illustrates how to configure and program this peripheral,
showingtherelatedCubeHALroutines.Moreover,awalk-throughoftheSTM32F7busandmemory
organization introduces the reader to the architecture of these high-performing MCUs.
Chapter 22 describes the operations performed by STM32 microcontrollers at startup. The whole
booting process is described, and some advanced techniques (like the vector table relocation in
Cortex-M0 microcontrollers) are explained. Moreover, a custom and secure bootloader is shown,
which has the ability to upgrade the on-board firmware through the USART peripheral. The
bootloader uses the AES algorithm to encrypt the firmware.
Chapter 23 is dedicated to the FreeRTOS Real-Time Operating System. It introduces the reader to
the most relevant concepts underlying an RTOS and shows how to use the main FreeRTOS func-
tionalities (like threads, semaphores, mutexes, and so on) using the CMSIS-RTOS layer developed
by ST on top of the FreeRTOS API. Moreover, some advanced techniques, like the tickless mode in
low-power design, are shown.
Chapter 24 introduces the reader to some advanced debugging techniques. The chapter starts
explaining the role of the fault-related exceptions in Cortex-M based cores, and how to interpret
the related hardware registers to go back to the source of fault. Moreover, some Eclipse advanced
debugging tools are presented, such as watchpoints and expressions, and how to use Keil Packs
integrated in the GNU MCU Eclipse tool-chain. Finally, a brief introduction to SEGGER J-LINK
professional debuggers is given, and to the way to use them in the Eclipse tool-chain.
Chapter 25 briefly introduces the reader to the FatFs middleware. This library allows to manipulate
structured filesystems created with the widespread FAT12/16/32 filesystem. The chapter also shows
the way ST engineers have integrated this library in the CubeHAL. Finally, it provides an overview
of the most relevant FatFs routines and configuration options.
Chapter 26 describes a solution to interface Nucleo boards to the Internet by using the W5500
network processor. The chapter shows how-to develop Internet- and web-based applications using
STM32 microcontrollers even if they do not provide a native Ethernet peripheral. Moreover, the
chapter introduces the reader to possible strategies to handle dynamic content in static web pages.
Finally, an application of the FatFs middleware is shown, in order to store web pages and alike on
an external SD card.
Chapter 27 shows how to start a new custom PCB design using an STM32 MCU. This chapter is
mainly focused on hardware related aspects such as decoupling, signal routing techniques and so
on. Moreover, it shows how to use CubeMX during the PCB design process and how to generate the
application skeleton when the board design is complete.
During the book you will find some horizontal rulers with “badges”, like the one above. This means
thattheinstructionsinthatpartofthebookarespecificforagivenfamilyofSTM32microcontrollers.
Sometimes, you could find a badge with a specific MCU type: this means that instructions are
Preface vii
exclusively related to that particular MCU. A black horizontal ruler (like the one below) closes the
specific section. This means that the text returns to be generic for the whole STM32 platform.
You will also find several asides, each one starting with an icon on the left. Let us explain them.
This a warning box. The text contained explains important aspects or gives important in-
structions. It is strongly recommended to read the text carefully and follow the instructions.
This is an information box. The text contained clarifies some concepts introduced before.
Thisisatipbox.Itcontainssuggestionstothereaderthatcouldsimplifythelearningprocess.
This a discussion box, and it is used to talk about the subject in a broader way.
This a bug-related box, used to report some specific and/or un-resolved bug (both hardware
and software).
About the Author
When someone asks me about my career and my studies, I like to say that I am a high level
programmer that someday has started fighting against bits.
I began my career in informatics when I was only a young boy with a 80286 PC, but unlike all
those who started programming in BASIC, I decided to learn a quite uncommon language: Clipper.
Clipper was a language mostly used to write software for banks, and a lot of people suggested that I
should start with this programming language (uh?!?). When visual environments, like Windows 3.1,
started to be more common, I decided to learn the foundations of Visual Basic and I wrote several
programswithit(oneofthem,aprogramforpatientmanagementformedicaldoctors,madeittothe
market)untilI begancollege,whereI started programmingin Unixenvironmentsandprogramming
languages like C/C++. One day I discovered what would become the programming language of my
life:Python.IhavewrittenhundredsofthousandslinesofcodeinPython,rangingfromwebsystems
Preface viii
to embedded devices. I think Python is an expressive and productive programming language, and it
is always my first choice when I have to code something.
For about ten years I worked as a research assistant at the National Research Council in Italy (CNR),
where I spent my time coding web-based and distributed content management systems. In 2010
my professional life changed dramatically. For several reasons that I will not detail here, I found
myself slingshot into a world I had always considered obscure: electronics. I first started developing
firmware on low-cost MCUs, then designing custom PCBs. In 2010 I co-founded a company that
produced wireless sensors and control boards used for small scale automation. Unfortunately, this
company was unlucky and it does not reached the success we wanted.
In 2013 I was introduced to the STM32 world during a presentation day at the ST headquarters
in Naples. Since then, I have successfully used STM32 microcontrollers in several products I have
designed, ranging from industrial automation to security tokens. Even thanks to the success of this
book, I currently work mainly as a full-time hardware consultant for some Italian companies.
Errata and Suggestions
I am aware of the fact that there are several errors in the text. Unfortunately, English is not my
mother tongue, and this is one of the main reasons I like lean publishing: being an in-progress book
I have all the time to check and correct them. I have decided that once this book reaches completion,
I will look for a professional editor to help me fix all the mistakes in my English. However, feel free
to contact me to signal what you find.
On the other end, I am totally open to suggestions and improvements about book content. I like
to think that this book will save your day every time you need to understand an aspect related to
STM32 programming, so feel free to suggest any topic you are interested in, or to signal parts of the
book which are not clear or well explained.
You can reach me through this book website: http://www.carminenoviello.com/en/mastering-
stm32/³
Book Support
I have setup a small forum on my personal website as support site for the topics presented in
this book. For any question, please subscribe here: http://www.carminenoviello.com/en/mastering-
stm32/⁴.
It is impossible for me to answer questions sent privately by e-mail, since they are often
variations on the same topic. I hope you understand.
³ http://www.carminenoviello.com/en/mastering-stm32/
⁴ http://www.carminenoviello.com/en/mastering-stm32/
Preface ix
How to Help the Author
Almost twice a week I receive nice emails from readers of this book encouraging me to continue
the work. Some of them would also donate additional money to help me during the book writing.
Needless to say that these emails make me really happy for days on end :-)
However, if you really want to help me, you may consider to:
• give me feedback about unclear things or errors contained both in the text and examples;
• write a small review about what you think⁵ of this book in the feedback section⁶.
• use your favorite social network or blog to spread the word. The suggested hashtag for this
book on Twitter is #MasteringSTM32⁷.
Copyright Disclaimer
This book contains references to several products and technologies whose copyright is owned by
their respective companies, organizations or individuals.
ART TM Accelerator, STM32, ST-LINK, STM32Cube and the STM32 logo with the white butterfly on
the cover of this book are copyright ©ST Microelectronics NV.
ARM, Cortex, Cortex-M, CoreSight, CoreLink, Thumb, Thumb-2, AMBA, AHB, APB, Keil are
registered trademarks of ARM Holdings.
GCC,GDBandothertoolsfromtheGNUCollectionCompilersmentionedinthisbookarecopyright
© Free Software Foundation.
Eclipse is copyright of the Eclipse community and all its contributors.
During the rest of the book, I will mention the copyright of tools and libraries I will introduce. If
I have forgot to attribute copyrights for products and software used in this book, and you think I
should add them here, please e-mail me through the LeanPub platform.
Credits
The cover of this book was designed by Alessandro Migliorato (AleMiglio⁸)
⁵ Negative feedback is also welcome ;-)
⁶ https://leanpub.com/mastering-stm32/feedback
⁷ https://twitter.com/search?q=%23MasteringSTM32
⁸ https://99designs.it/profiles/alemiglio
Acknowledgments
Even if there is just my name on the cover, this book would not have been possible without the help
of a lot of people who have contributed during its development.
First and foremost, I big thank you to Alan Smith, manager of the ST Microelectronics site in Naples
(Arzano - Italy). Alan, with persistence and great determination, came to my office more than three
years ago bringing a couple of Nucleo boards with him. He said to me: You must know STM32!. This
book was born almost that day!
I would like to thank several people that silently and actively contributed to this work. Enrico
Colombini (aka Erix⁹) helped me a lot during the early stages of this book, by reviewing several
parts of it. Without his initial support and suggestions, probably this book would have never seen
the end. For a self-publishing and in-progress author the early feedback is paramount to better
understand how to arrange a so complex work.
Ubaldo de Feo (aka @ubi¹⁰ also helped me a lot by providing technical feedback and by performing
an excellent proof-reading of some chapters.
Another special thanks goes to Davide Ruggiero, from ST Microelectronics in Naples, who helped
me by reviewing several examples and editing the chapter about CRC peripheral (Davide is a
mathematician and he better knows how to approach formulas :-)). Davide also actively contributed
by donating me some wine bottles: without adequate fuel you cannot write a 900 pages book!
Some english speaking people tried to help me with my poor english, dedicating a lot of time and
efforttoseveralpartsofthetext.Soabigthankyouto:OmarShaker,RogerBerger,J.Clarke,William
Den Beste, J.Behloul, M.Kaiser. I hope not to forget anyone.
A big thanks also to all early adopters of the book, especially to those ones that bought it when it
was made of just few chapters. This fundamental encouragement gave me the necessary energies to
complete a so long and hard work.
Finally, a special thanks to my business partners Antonio Chello and Francesco Vitobello who gave
me a lot of help during last year with the management of our company: a book is probably the most
time-consuming activity after a business development.
Regards,
Carmine I.D. Noviello
⁹ http://www.erix.it
¹⁰ http://ubidefeo.com
I Introduction
1. Introduction to STM32 MCU
Portfolio
This chapter gives a brief introduction to the entire STM32 portfolio. Its goal is to introduce the
reader to this rather complex family of microcontrollers subdivided in ten distinct sub-families.
These share a set of characteristics and present features specific to the given series. Moreover, a
quick introduction to the Cortex-M architecture is presented. Far from wanting to be a complete
reference to either the Cortex-M architecture or STM32 microcontrollers, it aims at being a guide
for the readers in choosing the microcontroller that best suits their development needs, considering
that, with more than 500 MCUs to choose from, it is not easy to decide which one fits the bill.
1.1 Introduction to ARM Based Processors
With the term ARM we nowadays refer to both a multitude of families of Reduced Instruction
Set Computing (RISC) architectures and several families of complete cores which are the building
blocks (hence the term core) of CPUs produced by many silicon manufacturers. When dealing with
ARM based processors, a lot of confusion may arise due to the fact that there are many different
ARM architecture revisions (ARMv6, ATMv6-M, ARMv7-M, ARMv7-A, and so on) and many core
architectures, which are in turn based on an ARM architecture revision. For the sake of clarity, for
example, a processor based on the Cortex-M4 core is designed on the ARMv7-M architecture.
An ARM architecture is a set of specifications regarding the instruction set, the execution model,
the memory organization and layout, the instruction cycles and more, which describes precisely
a machine that will implement said architecture. If your compiler is able to generate assembly
instructions for that architecture, it is able to generate machine code for all those actual machines
(aka, processors) implementing that given architecture.
Cortex-M is a family of physical cores designed to be further integrated with vendor-specific silicon
devices to form a finished microcontroller. The way a core works is not only defined by its related
ARM architecture (eg. ARMv7-M), but also by the integrated peripherals and hardware capabilities
defined by the silicon manufacturer. For example, the Cortex-M4 core architecture is designed to
supportbit-dataaccessoperationsintwospecificmemoryregionsusingafeaturecalledbit-banding,
butitisuptotheactual implementationtoaddsuchfeatureornot.TheSTM32F4isafamilyofMCUs
based on the Cortex-M4 core that implements this bit-banding feature. Figure 1 clearly shows the
relation between a Cortex-M3 based MCU and its Cortex-M3 core.
Introduction to STM32 MCU Portfolio 3
Figure 1: The relation between a Cortex-M3 core and a Cortex-M3 based MCU
ARM Holdings is a British¹ company that develops the instruction set and architecture for ARM-
based products but does not manufacture devices. This is a really important aspect of the ARM
world, and the reason why there are many manufacturers of silicon that develop, produce and sell
microcontrollers based on the ARM architectures and cores. ST Microelectronics is one of them, and
it is currently the only manufacturer selling a complete portfolio of Cortex-M based processors.
ARM Holdings neither manufactures nor sells CPU devices based on its own designs, but rather
licenses the processor architecture to interested parties. ARM offers a variety of licensing terms,
varying in cost and deliverables. When referring to Cortex-M cores, it is also common to talk about
Intellectual Property (IP) cores, meaning a chip design layout which is considered the intellectual
property of one party, namely ARM Holdings.
Thanks to this business model and to really interesting features such as low power capabilities,
low production costs of some architectures and so on, ARM is the most widely used instruction set
architecture in terms of quantity. ARM based products have become extremely popular. More than
50billionARMprocessorshavebeenproducedasof2014,10billionofwhichwereproducedin2013.
ARM based processors equip about 75 percent of the world’s mobile devices. A lot of mainstream
and popular 64-bit and multi-cores CPUs, used in devices that have become icons in the electronic
industry (i.e.: Apple’s iPhone), are based on an ARM architecture (ARMv8-A).
Being a sort of widespread standard, there are a lot of compilers and tools, as well as Operating
¹ In July 2016 the Japanese Softbank announced a plan to acquire ARM Holdings for $31 Billions. The deal has been closed on September
5th and on the following day the formerly British company has been de-listed from the London Stock Exchange.
Introduction to STM32 MCU Portfolio 4
Systems (Linux is the most used OS on Cortex-A processors) which support these architectures,
offering developers plenty of opportunities to build their applications.
1.1.1 Cortex and Cortex-M Based Processors
ARM Cortex is a wide set of 32/64-bit architectures and cores really popular in the embedded world.
Cortex microcontrollers are divided into three main subfamilies:
• Cortex-A, which stands for Application, is a series of processors providing a range of
solutions for devices undertaking complex computing tasks, such as hosting a rich Operating
System (OS) platform (Linux and its derivative Android are the most common ones), and
supporting multiple software applications. Cortex-A cores equip the processors found in most
of mobile devices, like phones and tablets. In this market segment we can find several silicon
manufacturers ranging from those who sell catalogue parts (TI or Freescale) to those who
produce processors for other licensees. Among the most common cores in this segment, we
can find Cortex-A7 and Cortex-A9 32-bit processors, as well as the latest ultra-performance
64-bit Cortex-A53 and Cortex-A57 cores.
• Cortex-M, which stands for eMbedded, is a range of scalable, compatible, energy efficient
and easy to use processors designed for the low-cost embedded market. The Cortex-M family
is optimized for cost and power sensitive MCUs suitable for applications such as Internet of
Things, connectivity, motor control, smart metering, human interface devices, automotive and
industrial control systems, domestic household appliances, consumer products and medical
instruments. In this market segment, we can find many silicon manufacturers who produce
Cortex-M processors: ST Microelectronics is one of them.
• Cortex-R, which stand for Real-Time, is a series of processors offering high-performance
computing solutions for embedded systems where reliability, high availability, fault tolerance,
maintainability and deterministic real-time response are essential. Cortex-R series processors
deliver fast and deterministic processing and high performance, while meeting challenging
real-timeconstraints.Theycombinethesefeaturesinaperformance,powerandareaoptimized
package, making them the trusted choice in reliable systems demanding fault tolerance.
The next sections will introduce the main features of Cortex-M processors, especially from the
embedded developer point of view.
1.1.1.1 Core Registers
Like all RISC architectures, Cortex-M processors areload/store machines, which perform operations
only on CPU registers except² for two categories of instructions: load and store , used to transfer
data between CPU registers and memory locations.
² This is not entirely true, since there are other instructions available in the ARMv6/7 architecture that access memory locations, but for
the purpose of this discussion it is best to consider that sentence to be true.
Introduction to STM32 MCU Portfolio 5
Figure 2 shows the core Cortex-M registers. Some of them are available only in the higher
performance series like M3, M4 and M7. R0-R12 are general-purpose registers, and can be used
as operands for ARM instructions. Some general-purpose registers, however, can be used by the
compiler as registers with special functions. R13 is the Stack Pointer (SP) register, which is also said
to be banked. This means that the register content changes according to the current CPU mode
(privileged or unprivileged). This function is typically used by Real Time Operating Systems (RTOS)
to do context switching.
Figure 2: ARM Cortex-M core registers
For example, consider the following C code using the local variables “a”, “b”, “c”:
...
uint8_t a,b,c;
a = 3;
b = 2;
c = a * b;
...
Introduction to STM32 MCU Portfolio 6
Compiler will generate the following ARM assembly code³:
1 movs r3, #3 ;move "3" in register r3
2 strb r3, [r7, #7] ;store the content of r3 in "a"
3 movs r3, #2 ;move "2" in register r3
4 strb r3, [r7, #6] ;store the content of r3 in "b"
5 ldrb r2, [r7, #7] ;load the content of "a" in r2
6 ldrb r3, [r7, #6] ;load the content of "b" in r3
7 smulbb r3, r2, r3 ;multiply "a" with "b" and store result in r3
8 strb r3, [r7, #5] ;store the result in "c"
As we can see, all the operations always involve a register. Instructions at lines 1-2 move the number
3 into the register r3 and then store its content (that is, the number 3 ) inside the memory location
given by the register r7 (which is the frame pointer, as we will see in Chapter 20) plus an offset of
7 memory locations - that is the place where a variable is stored. The same happens for the variable
b at lines 3-4. Then lines 5-7 load the content of variables a and b and perform the multiplication.
Finally, line 8 stores the result in the memory location of variable c .
Figure 3: Cortex-M fixed memory address space
³ That assembly code was generated compiling in thumb mode with any optimization disabled, invoking GCC in the following way: $
arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -fverbose-asm -save-temps -O0 -g -c file.c
Introduction to STM32 MCU Portfolio 7
1.1.1.2 Memory Map
ARM defines a standardized memory address space common to all Cortex-M cores, which ensures
code portability among different silicon manufacturer. The address space is 4GB wide, and it is
organized in several sub-regions with different logical functionalities. Figure 3 shows the memory
layout of a Cortex-M processor ⁴.
The first 512MB are dedicated to code area. STM32 devices further divide this area in some sub-
regions as shown in Figure 4. Let us briefly introduce them.
All Cortex-M processors map the code area starting at address 0x0000 0000 ⁵. This area also includes
the pointer to the beginning of the stack (usually placed in SRAM) and the vector table, as we will
see in Chapter 7. The position of the code area is standardized among all other Cortex-M vendors,
even if the core architecture is sufficiently flexible to allow manufacturers to arrange this area in
a different way. In fact, for all STM32 devices an area starting at address 0x0800 0000 is bound to
the internal MCU flash memory, and it is the area where program code resides. However, thanks to
a specific boot configuration we will explore in Chapter 22, this area is also aliased from address
0x0000 0000 . This means that it is perfectly possible to refer to the content of the flash memory both
starting at address 0x0800 0000 and 0x0000 0000 (for example, a routine located at address 0x0800
16DC can also be accessed from 0x0000 16DC ).
⁴ Althoughthememorylayoutandthesizeofsub-regions(andthereforealsotheiraddresses)arestandardizedbetweenallCortex-Mcores,
some functionalities may differ. For example, Cortex-M7 does not provide bit-band regions, and some peripherals in thePrivate Peripheral Bus
region differ. Always consult the reference manual for the architecture you are considering.
⁵ To increase readability, all 32-bit addresses in this book are written splitting the upper two bytes from the lower ones. So, every time you
see an address expressed in this way ( 0x0000 0000 ) you have to interpret it just as one common 32-bit address ( 0x00000000 ). This rule does
not apply to C and assembly source code.
Introduction to STM32 MCU Portfolio 8
Figure 4: Memory layout of Code Area on STM32 MCUs
The last two sections are dedicated to System memory and Option bytes. The former is a ROM
region reserved to bootloaders. Each STM32 family (and their sub-families - low density, medium
density, and so on) provides a bootloader pre-programmed into the chip during production. As we
will see in Chapter 22, this bootloader can be used to load code from several peripherals, including
USARTs, USB and CAN bus. TheOption bytes region contains a series of bit flags which can be used
to configure several aspects of the MCU (such as flash read protection, hardware watchdog, boot
mode and so on) and are related to the specific STM32 microcontroller.
Going back to the whole 4GB address space, the next main region is the one bounded to the internal
MCU SRAM. It starts at address 0x2000 0000 and can potentially extend to 0x3FFF FFFF . However,
the actual end address depends on the effective amount of internal SRAM. For example, in the case
of an STM32F103RB MCU with 20KB of SRAM, we have a final address of 0x2000 4FFF⁶. Trying to
access a location outside of this area will cause a Bus Fault exception (more about this later).
The next 0.5GB of memory is dedicated to the mapping of peripherals. Every peripheral provided
by the MCU (timers, I²C and SPI interfaces, USARTs, and so on) has an alias in this region. It is up
to the specific MCU to organize this memory space.
Thenext2GBareaisdedicatedtoexternalSRAMan/orflashestorage.Cortex-Mdevicescanexecute
code and load/store data from external memory, which extend the internal memory resources,
through the EMI/FSMC interface. Some STM32 devices, like the STM32F7, are able to execute code
from external memory without performance bottlenecks, thanks to an L1 cache and the ART TM
⁶ The final address is computed in the following way: 20K is equal to 20 * 1024 bytes, which in base 16 is 0x5000 . But addresses start from
0, hence the final address is 0x2000 0000 + 0x4FFF .
Introduction to STM32 MCU Portfolio 9
Accelerator.
The final 0.5 GB of memory is allocated to the internal (core) Cortex processor peripherals, plus
a reserved area for future enhancements to Cortex processors. All Cortex processor registers are
at fixed locations for all Cortex-based microcontrollers. This allows code to be more easily ported
between different STM32 variants and indeed other vendors’ Cortex-based microcontrollers.
1.1.1.3 Bit-Banding
In embedded applications, it is quite common to work with single bits of a word using bit masking.
For example, suppose that we want to set or clear the 3rd bit (bit 2) of an unsigned byte. We can
simply do this using the following C code:
...
uint8_t temp = 0;
temp |= 0x4;
temp &= ~0x4;
...
Bitmaskingisusedwhenwewanttosavespaceinmemory(usingonesinglevariableandassigninga
differentmeaning to each of its bits) or wehave to deal with internal MCU registers and peripherals.
Considering the previous C code, we can see that the compiler will generate the following ARM
assembly code⁷:
#temp |= 0x4;
a: 79fb ldrb r3, [r7, #7]
c: f043 0304 orr.w r3, r3, #4
10: 71fb strb r3, [r7, #7]
#temp &= ~0x4;
12: 79fb ldrb r3, [r7, #7]
14: f023 0304 bic.w r3, r3, #4
18: 71fb strb r3, [r7, #7]
As we can see, such a simple operation requires three assembly instructions (fetch, modify, save).
This leads to two types of problems. First of all, there is a waste of CPU cycles related to those
three instructions. Second, that code works fine if the CPU is working in single task mode, and
we have just one execution stream, but, if we are dealing with concurrent execution, another task
(or simply an interrupt routine) may affect the content of the memory before we complete the “bit
mask” operation (that is, for example, an interrupt occurs between instructions at lines 0xC-0x10 or
0x14-0x18 in the above assembly code).
Bit-banding is the ability to map each bit of a given area of memory to a whole word in the aliased
bit-banding memory region, allowing atomic access to such bit. Figure 5 shows how the Cortex
⁷ That assembly code was generated compiling in thumb mode with any optimization disabled, invoking GCC in the following way: $
arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -fverbose-asm -save-temps -O0 -g -c file.c
Introduction to STM32 MCU Portfolio 10
CPU aliases the content of memory address 0x2000 0000 to the bit-banding region 0x2200 0000-1c .
For example, if we want to modify (bit 2) of 0x2000 0000 memory location we can simply access to
0x2200 0008 memory location.
Figure 5: Memory mapping of SRAM address 0x2000 0000 in bit-banding region (first 8 of 32 bits shown)
This is the formula to compute the addresses for alias regions:
bit_band_address = alias_region_base + (region_base_offset x 32) + (bit_number x 4)
For example, considering the memory address of Figure 5, to access bit 2 :
alias_region_base = 0x22000000
region_base_offset = 0x20000000 - 0x20000000 = 0
bit_band_address = 0x22000000 + 0*32 + (0x2 x 0x4) = 0x22000008
ARM defines two bit-band regions for Cortex-M based MCUs⁸, each one is 1MB wide and mapped
to a 32Mbit bit-band alias region. Each consecutive 32-bit word in the “alias” memory region refers
to each consecutive bit in the “bit-band” region (which explains that size relationship: 1Mbit <->
32Mbit). The first one starts at 0x2000 0000 and ends at 0x200F FFFF , and it is aliased from 0x2200
0000 to 0x23FF FFFF . It is dedicated to the bit access of SRAM memory locations. Another bit-
banding region starts at 0x4000 0000 and ends at 0x400F FFFF , as shown in Figure 6.
⁸ Unfortunately, Cortex-M7 based MCUs do not provide bit-banding capabilities.
Introduction to STM32 MCU Portfolio 11
Figure 6: Memory map and bit-banding regions
This other region is dedicated to the memory mapping of peripherals. For example, ST maps the
GPIO Output Data Register (GPIO->ODR) of GPIOA peripheral from 0x4002 0014 . This means that
each bit of the word addressed at 0x4002 0014 allows modifying the output state of a GPIO (from
LOW to HIGH and vice versa). So if we want to modify the status of PIN5 of GPIOA port⁹, using
the previous formula we have:
alias_region_base = 0x42000000
region_base_offset = 0x40020014 - 0x40000000 = 0x20014
bit_band_address = 0x42000000 + 0x20014*32 + (0x5 x 0x4) = 0x42400294
We can define two macros in C that allow to easily compute bit-band alias addresses:
1 // Define base address of bit-band
2 #define BITBAND_SRAM_BASE 0x20000000
3 // Define base address of alias band
4 #define ALIAS_SRAM_BASE 0x22000000
5 // Convert SRAM address to alias region
6 #define BITBAND_SRAM(a,b) ((ALIAS_SRAM_BASE + ((uint32_t)&(a)-BITBAND_SRAM_BASE)*32 + (b*4)))
7
8 // Define base address of peripheral bit-band
9 #define BITBAND_PERI_BASE 0x40000000
10 // Define base address of peripheral alias band
11 #define ALIAS_PERI_BASE 0x42000000
12 // Convert PERI address to alias region
13 #define BITBAND_PERI(a,b) ((ALIAS_PERI_BASE + ((uint32_t)a-BITBAND_PERI_BASE)*32 + (b*4)))
Still using the aboveexample,wecan quickly modify the state of PIN5 of the GPIOAport as follows:
⁹ Anyone who has already played with Nucleo boards, knows that user LED LD2 (the green one) is connected to that port pin.
Introduction to STM32 MCU Portfolio 12
1 #define GPIOA_PERH_ADDR 0x40020000
2 #define ODR_ADDR_OFF 0x14
3
4 uint32_t *GPIOA_ODR = GPIOA_PERH_ADDR + ODR_ADDR_OFF;
5 uint32_t *GPIOA_PIN5 = BITBAND_PERI(GPIOA_ODR, 5);
6
7 *GPIOA_PIN5 = 0x1; // Turns GPIO HIGH
1.1.1.4 Thumb-2 and Memory Alignment
Historically, ARM processors provide a 32-bit instructions set. This not only allows for a rich set of
instructions,butalsoguaranteesthebestperformanceduringtheexecutionofinstructionsinvolving
arithmetic operations and memory transfers between core registers and SRAM. However, a 32-bit
instruction set has a cost in terms of memory footprint of the firmware. This means that a program
written with a 32-bit Instruction Set Architecture (ISA) requires a higher amount of bytes of flash
storage, which impacts on power consumption and overall costs of the MCU (silicon wafers are
expensive, and manufacturers constantly shrink chips size to reduce their cost).
To address such issues, ARM introduced the Thumb 16-bit instruction set, which is a subset of the
most commonly used 32-bit one. Thumb instructions are each 16 bits long, and are automatically
“translated” to the corresponding 32-bit ARM instruction that has the same effect on the processor
model. This means that 16-bit Thumb instructions are transparently expanded (from the developer
point of view) to full 32-bit ARM instructions in real time, without performance loss. Thumb code is
typically 65% the size of ARM code, and provides 160% the performance of the latter when running
from a 16-bit memory system; however, in Thumb, the 16-bit opcodes have less functionality. For
example, only branches can be conditional, and many opcodes are restricted to accessing only half
of all of the CPU’s general-purpose registers.
Afterwards, ARM introduced the Thumb-2 instruction set, which is a mix of 16 and 32-bit
instruction sets in one operation state. Thumb-2 is a variable length instruction set, and offers a
lot more instructions compared to the Thumb one, achieving similar code density.
Cortex-M3/4/7wheredesignedtosupportthefullThumb andThumb-2 instructionsets,andsomeof
them support other instruction sets dedicated to Floating Point operations (Cortex-M4/7) and Single
Instruction Multiple Data (SIMD) operations (also known as NEON instructions).
Introduction to STM32 MCU Portfolio 13
Figure 7: Difference between aligned and unaligned memory access
Another interesting feature of Cortex-M3/4/7 cores is the ability to do unaligned access to memory.
ARM based CPUs are traditionally capable of accessing byte (8-bit), half word (16-bit) and word
(32-bit) signed and unsigned variables, without increasing the number of assembly instructions as
it happens on 8-bit MCU architectures. However, early ARM architectures were unable to perform
unaligned memory access, causing a waste of memory locations.
Tounderstandtheproblem,considertheleftdiagraminFigure7.Herewehaveeightvariables.With
memory aligned access we mean that to access the word variables (1 and 4 in the diagram), we need
to access addresses which are multiples of 32-bits (4 bytes). That is, a word variable can be stored
only in 0x2000 0000 , 0x2000 0004 , 0x2000 0008 and so on. Every attempt to access a location which
is not a multiple of 4 causes a UsageFaults exception. So, the following ARM pseudo-instruction is
not correct:
STR R2, 0x20000002
The same applies for half word access: it is possible to access to memory locations stored at multiple
of 2 bytes: 0x2000 0000 , 0x2000 0002 , 0x2000 0004 and so on. This limitation causes fragmentation
inside the RAM memory. To solve this issue, Cortex-M3/4/7 based MCUs are able to perform
unaligned memory access, as shown in the right diagram in Figure 7. As we can see, variable 4
is stored starting at address 0x2000 0007 (in early ARM architectures this was only possible with
single byte variables). This allows us to store variable 5 in memory location 0x2000 000b , causing
variable 8 to be stored in 0x2000 000e . Memory is now packed, and we have saved 4 bytes of SRAM.
However, unaligned access is restricted to the following ARM instructions:
• LDR, LDRT
• LDRH, LDRHT
• LDRSH, LDRSHT
• STR, STRT
• STRH, STRHT
1.1.1.5 Pipeline
Whenever we talk about instructions execution we are making a series of non-trivial assumptions.
Beforeaninstructionisexecuted,theCPUhastofetchitfrommemoryanddecodeit.Thisprocedure
Introduction to STM32 MCU Portfolio 14
consumes a number of CPU cycles, depending on the memory and core CPU architecture, which
is added to the actual instruction cost (that is, the number of cycles required to execute the given
instruction).
Modern CPUs introduce a way to parallelize these operations in order to increase their instructions
throughput (the number of instructions which can be executed in a unit of time). The basic
instruction cycle is broken up into a series of steps, as if the instructions traveled along a pipeline.
Rather than processing each instruction sequentially (one at a time, finishing one instruction before
starting with the next one), each instruction is split into a sequence of stages so that different steps
can be executed in parallel.
Figure 8: Three stage instruction pipeline
All Cortex-M based microcontrollers introduce a form of pipelining. The most common one is the
3-stage pipeline, as shown in Figure 8. 3-stage pipeline is supported by Cortex-M0/3/4. Cortex-M0+
cores, which are dedicated to low-power MCUs, provide a 2-stage pipeline (although pipelining
helps reducing the time cost related to the instruction’s fetch/decode/execution cycle, it introduces
an energy cost which has to be minimized in low-power applications). Cortex-M7 cores provide a
6-stage pipeline.
When dealing with pipelines, branching is an issue to be addressed. Program execution is all
about taking different paths; this is achieved through branching ( if equal goto ). Unfortunately,
branchingcausestheinvalidationofpipelinestreams,asshowninFigure9.Thelasttwoinstructions
havebeenloadedintothepipelinebuttheyarediscardedduetotheoptionalbranchpathbeingtaken
(we usually refer to them as branch shadows)
Figure 9: Branching in program execution related to pipelining
Even in this case there are several techniques to minimize the impact of branching. They are often
referred as branching prediction techniques. The ideas behind these techniques is that the CPU
Introduction to STM32 MCU Portfolio 15
starts fetching and decoding both the instructions following the branching and the ones that would
be reached if the branch were to happen (in Figure 9 both MOV and ADD instructions). There are,
however, other ways to implement a branch prediction scheme. If you want to look deeper into this
subject, this post¹⁰ from the official ARM support forum is a good starting point.
1.1.1.6 Interrupts and Exceptions Handling
Interrupts and exception management is one of the most powerful features of Cortex-M based
processors. Interrupts and exceptions are asynchronous events that alter the program flow. When an
exceptionoraninterruptoccurs,theCPUsuspendstheexecutionofthecurrenttask,savesitscontext
(that is, its stack pointer) and starts the execution of a routine designed to handle the interrupting
event. This routine is called Exception Handler in case of exceptions and Interrupt Service Routine
(ISR) in case of an interrupt. After the exception or interrupt has been handled, the CPU resumes
the previous execution flow, and the previous task can continue its execution¹¹.
In the ARM architecture, interrupts are one type of exception. Interrupts are usually generated from
on-chipperipherals(e.g.,atimer)orexternalinputs(e.g.atactileswitchconnectedtoaGPIO),andin
some cases they can be triggered by software. Exceptions are, instead, related to software execution,
and the CPU itself can be a source of exceptions. These could be fault events such as an attempt to
access an invalid memory location, or events generated by the Operating System, if any.
Each exception (and hence interrupt) has a number which uniquely identifies it. Table 1 shows
the predefined exceptions common to all Cortex-M cores, plus a variable number of user-defined
ones related to interrupts management. This number reflects the position of the exception handler
routineinsidethevectortable,wheretheactualaddressoftheroutineisstored.Forexample,position
15 contains the memory address of a code area containing the exception handler for the SysTick
interrupt, generated when the SysTick timer reaches zero.
¹⁰ http://bit.ly/1k7ggh6
¹¹ With the term task we refer to a series of instructions which constitute the main flow of execution. If our firmware is based on an OS,
the scenario could be a bit more articulated. Moreover, in case of low-power sleep mode, the CPU may be configured to go back to sleep after
an interrupt management routine is executed.
Introduction to STM32 MCU Portfolio 16
Table 1: Cortex-M exception types
Other than the first three, each exception can be assigned a priority level, which defines the
processing order in case of concurrent interrupts: the lower the number, the higher the priority.
For example, suppose we have two interrupt routines related to external inputs A and B. We can
assign a higher-priority interrupt (lower number) to input A. If the interrupt related to A arrives
while the processor is serving the interrupt from input B the execution of B is suspended, allowing
the higher priority interrupt service routine to be executed immediately.
Both exceptions and interrupts are processed by a dedicated unit called Nested Vectored Interrupt
Controller (NVIC). The NVIC has the following features:
• Flexible exception and interrupt management: NVIC is able to process both interrupt
signals/requests coming from peripherals and exceptions coming from the processor core,
allowing us to enable/disable them in software (except for NMI¹²).
¹² Also the Reset exception cannot be disabled, even if it is improper to talk about the Reset exception disabling, since it is the first exception
generated after the MCU resets. As we will see in Chapter 7, the Reset exception is the actual entry point of every STM32 application.
Introduction to STM32 MCU Portfolio 17
• Nested exception/interrupt support: NVIC allows the assignment of priority levels to
exceptions and interrupts (except for the first three exception types), giving the possibility
to categorize interrupts based on user needs.
• Vectoredexception/interruptentry:NVICautomaticallylocatesthepositionoftheexception
handler related to an exception/interrupt, without need of additional code.
• Interrupt masking: developers are free to suspend the execution of all exception handlers
(except for NMI), or to suspend some of them on a priority level basis, thanks to a set of
dedicated registers. This allows the execution of critical tasks in a safe way, without dealing
with asynchronous interruptions.
• Deterministic interrupt latency: one interesting feature of NVIC is the deterministic latency
of interrupt processing, which is equal to 12 cycles for all Cortex-M3/4 cores, 15 cycles for
Cortex-M0, 16 cycles for Cortex-M0+, regardless of the processor’s current status.
• Relocationofexceptionhandlers:aswewillexplorenext,exceptionhandlerscanberelocated
to other flash memory locations as well as totally different - even external - non read-only
memory. This offers a great degree of flexibility for advanced applications.
1.1.1.7 SysTimer
Cortex-M based processors can optionally provide a System Timer, also known asSysTick. The good
news is that all STM32 devices provide one, as shown in Table 3.
SysTick is a 24-bit down-counting timer used to provide a system tick for Real Time Operating
Systems (RTOS) like FreeRTOS. It is used to generate periodic interrupts to scheduled tasks.
ProgrammerscandefinetheupdatefrequencyofSysTick timerbysettingitsregisters.SysTicktimer
is also used by the STM32 HAL to generate precise delays, even if we aren’t using an RTOS. More
about this timer in Chapter 11.
1.1.1.8 Power Modes
The current trend in the electronics industry, especially when it comes to mobile devices design,
is all about power management. Reducing power consumption to minimum is the main goal of
all hardware designers and programmers involved in the development of battery-powered devices.
Cortex-M processors provide several levels of power management, which can be divided into two
main groups: intrinsic features and user-defined power modes.
With intrinsic features we refer to those native capabilities related to power consumption defined
during the design of both the Cortex-M core and the whole MCU. For example, Cortex-M0+ cores
only define two pipeline stages in order to reduce power consumption during instructions prefetch.
Another native behavior related to power management is the high code density of the Thumb-2
instructionset,whichallowsdeveloperstochooseMCUswithsmallerflashmemorytolowerpower
needs.
Introduction to STM32 MCU Portfolio 18
Figure 10: Cortex-M power consumption at different power modes
Traditionally, Cortex-M processors provide user-defined power modes via System Control Regis-
ter(SCR). The first ons is the Run mode (see Figure 10), which has the CPU running at its full
capabilities. In Run mode, power consumption depends on clock frequency and used peripherals.
Sleep mode is the first low-power mode available to reduce power consumption. When activated,
most functionalities are suspended, CPU frequency is lowered and its activities are reduced to those
necessary for it to wake up. In Deep sleep mode all clock signals are stopped and the CPU needs an
external event to wake up from this state.
However, these power modes are only general models, which are further implemented in the
actual MCU. For example, consider Figure 11 displaying the power consumption of an STM32F2
MCU running at 80MHZ @30°C¹³. As we can see, the maximum power consumption is reached
in Run-mode (that is, the Active mode) with the ART TM accelerator disabled. Enabling the ART TM
accelerator we can save up to 10mAh while also achieving better computing performances. This
clearly shows that the real MCU implementation can introduce different power levels.
¹³ Source ST AN3430
Introduction to STM32 MCU Portfolio 19
Figure 11: STM32F2 power consumption at different power modes
STM32Lx families provide several further intermediate power levels, allowing to precisely select the
preferred power mode and hence MCU performance and power consumption.
We will go in more depth about this topic in Chapter 19.
1.1.1.9 CMSIS
OneofthekeyadvantagesoftheARMplatform(bothforsiliconvendorsandapplicationdevelopers)
is the existence of a complete set of development tools (compilers,run-time libraries, debuggers, and
so on) which are reusable across several vendors.
ARM is also actively working on a way to standardize the software infrastructure amongst MCUs
vendors. Cortex Microcontroller Software Interface Standard (CMSIS) is a vendor-independent
hardware abstraction layer for the Cortex-M processor series and specifies debugger interfaces. The
CMSIS consists of the following components:
• CMSIS-CORE:APIfortheCortex-Mprocessorcoreandperipherals.Itprovidesastandardized
interface for Cortex-M0/3/4/7.
• CMSIS-Driver: defines generic peripheral driver interfaces for middleware making them
reusable across supported devices. The API is RTOS independent and connects microcontroller
peripherals to middleware which implements, amongst other things, communication stacks,
file systems or graphical user interfaces.
• CMSIS-DSP: DSP Library Collection with over 60 Functions for various data types: fixed-point
(fractional q7, q15, q31) and single precision floating-point (32-bit). The library is available for
Cortex-M0, Cortex-M3, and Cortex-M4. The Cortex-M4 implementation is optimized for the
SIMD instruction set.
Introduction to STM32 MCU Portfolio 20
• CMSIS-RTOS API: Common API for Real-Time Operating Systems. It provides a standardized
programming interface which is portable to many RTOS and therefore enables software
templates, middleware, libraries, and other components which can work across supported
RTOS systems. We will talk about this API layer in Chapter 23.
• CMSIS-Pack: describes, using an XML based package description file named “PDSC”, the user
and device relevant parts of a file collection (namely “software pack”) which includes source,
header, library files, documentation, flash programming algorithms, source code templates
and example projects. Development tools and web infrastructures use the PDSC file to extract
device parameters, software components, and evaluation board configurations.
• CMSIS-SVD: System View Description (SVD) for Peripherals. Describes the peripherals of a
device in an XML file and can be used to create peripheral awareness in debuggers or header
files with peripheral registers and interrupt definitions.
• CMSIS-DAP: Debug Access Port. Standardized firmwares for a Debug Unit that connects to
the CoreSight Debug Access Port. CMSIS-DAP is distributed as a separate package and well
suited for integration on evaluation boards.
However, this initiative from ARM is still evolving, and the support to all components from ST is
still very bare-bone. The official ST HAL is the main way to develop applications for the STM32
platform, which presents a lot of peculiarities between MCUs of different families. Moreover, it is
quite clear that the main objective of silicon vendors is to retain their customers and avoid their
migration to other MCUs platform (even if based on the same ARM Cortex core). So, we are really
far from having a complete and portable layer that works on all ARM based MCUs available on the
market.
1.1.1.10 Effective Implementation of Cortex-M Features in the STM32 Portfolio
Some of the features presented in the previous paragraphs are optional and may not be available in
a given MCU. Tables 2 and 3 summarize the Cortex-M instructions and components available in
the STM32 Portfolio. These could be useful during the selection of an STM32 MCU.
Table 2: ARM Cortex-M instruction variations
Introduction to STM32 MCU Portfolio 21
Table 3: ARM Cortex-M optional components
1.2 Introduction to STM32 Microcontrollers
STM32 is a broad range of microcontrollers divided in nine sub-families, each one with its features.
STstartedthemarketproductionofthisportfolioin2007,beginningwiththeSTM32F1series,which
is still under development. Figure 12 shows the internal die of an STM32F103 MCU, one of the most
widespreadSTM32MCUs¹⁴.AllSTM32microcontrollershaveaCortex-Mcore,plussomedistinctive
ST features (like the ART TM accelerator). Internally, each microcontroller consists of the processor
core, static RAM, flash memory, debugging interface, and various other peripherals. Some MCUs
provide additional types of memory (EEPROM, CCM, etc.), and a whole line of devices targeting
low-power applications is continuously growing.
¹⁴ This picture is taken from Zeptobars.ru (http://bit.ly/1FfqHsv), a really fantastic blog. Its authors decap (remove the protective casing)
integrated circuits in acid and publish images of what’s inside the chip. I love those images, because they show what humans were able to
achieve in electronics.
Introduction to STM32 MCU Portfolio 22
Figure 12: Internal die of an STM32F103 MCU³
The remaining paragraphs in this chapter will introduce the reader to STM32 microcontrollers,
giving a complete overview of all STM32 subfamilies.
1.2.1 Advantages of the STM32 Portfolio….
The STM32 platform provides several advantages for embedded developers. This paragraph tries to
summarize the relevant ones.
• They are Cortex-M based MCUs: this could still not be clear to those of you who are new
to this platform. Being Cortex-M based microcontrollers ensures that you have several tools
available on the market to develop your applications. ARM has become a sort of standard in
the embedded world (this is especially true for Cortex-A processors; in the Cortex-M market
segment there are still several good alternatives: PIC, MSP430, etc.) and 50 billions of devices
sold by 2014 is a strong guarantee that investing on this platform is a good choice.
• Free ARM based tool-chain: thanks to the diffusion of ARM based processors, it is possible to
work with completely free tool-chains, without investing a lot of money to start working with
this platform, which is extremely important if you are a hobbyist or a student.
• Know-how reuse: STM32 is a quite extensive portfolio, which is based on a common
denominator: their main CPU platform. This ensures, for example, that know-how acquired
Introduction to STM32 MCU Portfolio 23
working on a given STM32Fx CPU can easily be applied to other devices from the same family.
Moreover, working with Cortex-M processors allows you to reuse much of the acquired skills
if you (or your boss) decide to switch to Cortex-M MCUs from other vendors (in theory).
• Pin-to-pin compatibility: most of STM32 MCUs are designed to be pin-to-pin compatible
inside the extensive STM32 portfolio. This is especially true for LQFP64-100 packages, and it is
a big plus. You will have less responsibility in the initial choice of the right microcontroller for
your application, knowing that you can eventually jump to another family in case you find it
does not fit your needs.
• 5V tolerant: Most STM32 pins are 5V tolerant. This means that you can interface other
devices that do not provide 3.3V I/O without using level shifters (unless speed is really key
to your application - a level shifter always introduce a parasitic capacitance that reduced the
commutation frequency).
• 32 cents for 32 bit: STM32F0 is the right choice if you want to migrate from 8/16-bit MCUs
to a powerful and coherent platform, while keeping a comparable target price. You can use an
RTOS to boost your application and write much better code.
• Integratedbootloader:STM32MCUsareshippedwithanintegratedbootloader,whichallows
to reprogram the internal flash memory using some communication peripherals (USART, I²C,
etc.). For some of you this will not be a killer feature, but it can dramatically simplify the work
of people developing devices as professionals.
1.2.2 ….And Its Drawbacks
This book is not a brochure or a document made by marketing people. Nor is the author an ST
employee or is he having business with ST. So it is right to say that there are some pitfalls regarding
this platform.
• Learning curve: STM32’s learning curvecan be quite steep,especially for inexperienced users.
If you are completely new to embedded development, the process of learning how to develop
STM32applicationscanbereallyfrustrating.EvenifSTisdoingagreatjobattryingtoimprove
the overall documentation and the official libraries, it is still hard to deal with this platform,
and this is a shame. Historically,ST documentation has not been the best one for inexperienced
people, being too cryptic and lacking clear examples.
• Lack of official tools: this book will guide the reader through the process of setting up a full
tool-chain for the STM32 platform. The fact that ST does not provide its official development
environment(like,for example,Microchip does for its MCUs) pushes a lot of people away from
this platform. This is a strategic mishap that people at ST should seriously take into account.
• Fragmented and dispersive documentation: ST is actively working on improving its official
documentation for the STM32 platform. You can find a lot of really huge datasheets on ST’s
website, but there is still a lack of good documentation especially for its HAL. Recent versions
of the CubeHAL provide one or more “CHM” files¹⁵, which are automatically generated from
¹⁵ a CHM file is a typical Microsoft file format used to distribute documentation in HTML format in just one file. It is really common on
the Windows OS, and you can find several good free tools on MacOS and Linux to read them.
Introduction to STM32 MCU Portfolio 24
the documentation inside the CubeHAL source code. However, those files are not sufficient
to start programming with this framework, especially if you are new to the STM32 ecosystem
and the Cortex-M world.
• Buggy HAL: unfortunately, the official HAL from ST contains several bugs, andsome of them
are really severe and lead to confusion in novices. For example, during the development of
thisbookIhavefounderrorsinseverallinkerscripts¹⁶(whicharesupposedtobethefoundation
blocksoftheHAL)andinsomecriticalroutinesthatshouldworkseamlessly.Everydayatleast
a new post regarding HAL bugs appears in the official ST forum¹⁷, and this can be source of
great frustration. ST is actively working on fixing the HAL bugs, but it seems we are still far
from a “stable release”. Moreover, their software release lifecycle is too old and not appropriate
for the times we live in: bug fixes are released after several months, and sometimes the fix
bares more issues than the broken code itself. ST should seriously consider investing less on
designing the next development kit and more on the development of a decent STM32 HAL,
which is currently not adequate to the hardware development. I would respectfully suggest to
release the whole HAL on a community for developers like github, and let the community help
fixing the bugs. This would also greatly simplify the bug reporting process, which is currently
demanded to scattered posts on the ST forum. A real pity.
1.3 A Quick Look at the STM32 Subfamilies
As you read, the STM32 is a rather complex product lineup, spanning over ten product sub-families.
Figure 13 and Figure 14 summarize the current STM32 portfolio¹⁸. The diagrams aggregate the
subfamilies in four macro groups: High-performance, Mainstream, Wireless and Ultra Low-Power
MCUs.
High-performance microcontrollers are those STM32 MCUs dedicated to CPU-intensive and mul-
timedia applications. They are Cortex-M3/4F/7 based MCUs, with maximum clock frequencies
ranging from 120MHz (F2) up to 400MHz (H7). All MCUs in this group provide ART TM Accelerator,
an ST technology that allows 0-wait execution from flash memory.
¹⁶ http://bit.ly/1iRAKdf
¹⁷ http://bit.ly/1LTf2MS
¹⁸ The diagram was taken from this ST Microelectronics brochure (http://bit.ly/1G7HMFj).
Introduction to STM32 MCU Portfolio 25
Figure 13: STM32 portfolio
Introduction to STM32 MCU Portfolio 26
Figure 14: STM32 portfolio
Mainstream MCUs are developed for cost-sensitive applications, where the cost of the MCU must
Introduction to STM32 MCU Portfolio 27
be even less than 1$/pc and space is a strong constraint. In this group we can find Cortex-M0/3/4
based MCUs, with maximum clock frequencies ranging from 48MHz (F0) to over 72MHz (F1/F3).
Wireless MCUs are the brand new lineup of dual-core STM32 microcontrollers with integrated
2.4GHz radio fronted suitable for wireless and Bluetooth applications. These MCUs feature a
Cortex-M0+ core (named Network Processor) dedicated to the radio management (a companion
BLE 5.0 stack is also provided by ST) and a user-programmable Cortex-M4 core (named Application
Processor) for the main embedded application.
The Ultra Low-Power group contains those STM32 families of MCUs addressing low-power appli-
cations, used in battery-powered devices which need to reduce total power consumption to low
levels ensuring longer battery life. In this group we can find both Cortex-M0+ based MCUs, for
cost-sensitive applications, and Cortex-M4F based microcontrollers with Dynamic Voltage Scaling
(DVS), a technology which allows to optimize the internal CPU voltage according to its frequency.
The following paragraphs give a brief description of each STM32 family, introducing its main
features. The most important ones will be summarized inside tables. Tables were arranged by the
author of this book, inspired by the official ST documentation.
1.3.1 F0
Table 4: STM32F0 features
The STM32F0 series is the famous 32-cents for 32-bit line of MCU from the STM32 portfolio. It is
designed to have a street price able to compete with 8/16-bit MCUs from other vendors, offering a
more advanced and powerful platform.
The most important features of this series are:
• Core:
– ARM Cortex-M0 core at a maximum clock rate of 48 MHz.
Introduction to STM32 MCU Portfolio 28
– Cortex-M0 options include the SysTick Timer.
• Memory:
– Static RAM from 4 to 32 KB.
– Flash from 16 to 256 KB.
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Peripherals:
– Each F0-series device features a range of peripherals which vary from line to line (see
Table 4 for a quick overview).
• Oscillator source consists of internal RC (8 MHz, 40 kHz), optional external HSE (4 to 32 MHz),
LSE (32.768 to 1000 kHz).
• IC packages: LQFP, TSSOP20¹⁹, UFBGA, UFQFPN, WLCSP (see Table 4 for more about this).
• Operating voltage range is 2.0V to 3.6V with the possibility to go down to 1.8V ±8%.
1.3.2 F1
Table 5: STM32F1 features
The STM32F1 series was the first ARM based MCU from ST. Introduced in the market in 2007,
it is still the most widespread MCU from the STM32 portfolio. Plenty of development boards are
available on the market, produced by ST and other vendors, and you will find tons of examples on
the web for F1 microcontrollers. If you are new to the STM32 world, probably the F1 line is the best
choice to start working with to learn this platform.
The F1-series has evolved over time by increasing speed, size of internal memory, variety of
peripherals. There are five F1 lines: Connectivity (STM32F105/107), Performance (STM32F103), USB
Access (STM32F102), Access (STM32F101), Value (STM32F100).
The most important features of this series are:
¹⁹ F0/L0 are the only STM32 families that provides this convenient package.
Introduction to STM32 MCU Portfolio 29
• Core:
– ARM Cortex-M3 core at a maximum clock rate ranging from 24 to 72 MHz.
• Memory:
– Static RAM from 4 to 96 KB.
– Flash from 16 to 256 KB.
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Peripherals:
– Each F1-series device features a range of peripherals which vary from line to line (see
Table 5 for a quick overview).
• OscillatorsourceconsistsofinternalRC(8MHz,40kHz),optionalexternalHSE(4-24MHz(F100),
4-16MHz(F101/2/3), 3-25MHz (F105/7), LSE (32.768 - 1000 kHz) ).
• IC packages: LFBGA, LQFP, UFBGA, UFQFPN, WLCSP (see Table 5 for more about this).
• Operating voltage range is 2.0V to 3.6V
• Multiple connectivity options, including Ethernet, CAN and USB 2.0 OTG.
1.3.3 F2
Table 6: STM32F2 features
The STM32F2 series of STM32 microcontrollers is the cost-effective solution in the High-perfor-
mance segment. It is the most recent and fastest Cortex-M3 based MCU, with exclusive ART TM
Accelerator from ST. The F2 is pin-to-pin compatible with the STM32 F4-series. STM32F2 was the
MCU chosen by the developers of popular Pebble watch for their first smart-watch.
Introduction to STM32 MCU Portfolio 30
Figure 15: The first Pebble watch with STM32F205 MCU inside
The most important features of this series are:
• Core:
– ARM Cortex-M3 core at a maximum clock rate of 120 MHz.
• Memory:
– Static RAM from 64 to 128 KB.
* 4 KB battery-backed, 80 bytes battery-backed with tamper-detection erase.
– Flash from 128 to 1024 KB.
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Peripherals:
– Each F2-series device features a range of peripherals which vary from line to line (see
Table 6 for a quick overview).
• Oscillators consist of internal RC (16 MHz, 32 kHz), optional external HSE (1 to 26 MHz), LSE
(32.768 to 1000 kHz).
• IC packages: BGA, LQFP, UFBGA, WLCSP (see Table 6 for more about this).
• Operating voltage range is 1.8V to 3.6V.
Introduction to STM32 MCU Portfolio 31
1.3.4 F3
Table 7: STM32F3 features
The STM32F3 is the most powerful series of MCU in the Mainstream segment, based on the ARM
Cortex-M4F core. It is designed to be almost pin-to-pin compatible with the STM32 F1-series, even
if it does not offer the same variety of peripherals. STM32F3 was the MCU chosen by the developers
of the BB-8 droid²⁰ toy by Sphero²¹.
The distinguishing feature for this series is the presence of integrated analog peripherals leading to
cost reduction at application level and simplifying application design, including:
• Ultra-fast comparators (25 ns).
• Op-amp with programmable gain.
• 12-bit DACs.
• Ultra-fast 12-bit ADCs with 5 MSPS (Million Samples Per Second) per channel (up to 18 MSPS
in Interleaved mode).
• Precise 16-bit sigma-delta ADCs (21 channels).
• 144 MHz Advanced 16-bit pulse-width modulation timer (resolution < 7 ns) for control
applications; high resolution timer (217 picoseconds), self-compensated vs power supply and
temperature drift.
AnotherinterestingfeatureofthisseriesisthepresenceofaCoreCoupledMemory (CCM),aspecific
memory architecture which couples some regions of memory to the CPU core, allowing 0-wait
²⁰ http://cnet.co/1M2NyJS
²¹ http://www.sphero.com/
Introduction to STM32 MCU Portfolio 32
states. This can be used to boost time-critical routines, improving performance by up to 40%. For
example, OS routines for context switching can be stored in this area to speed up RTOS activities.
The most important features of this series are:
Figure 16: The BB-8 droid made with an STM32F3 MCU
• Core:
– ARM Cortex-M4F core at a maximum clock rate of 72 MHz.
• Memory:
– Static RAM from 16 to 80 KB general-purpose with hardware parity check.
* 64 / 128 bytes battery-backed with tamper-detection erase.
– Up to 8 KB Core Coupled Memory (CCM) with hardware parity check.
– Flash from 32 to 512 KB.
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Peripherals:
– Each F3-series device features a range of peripherals which vary from line to line (see
Table 7 for a quick overview).
• Oscillators consist of internal RC (8 MHz, 40 kHz), optional external HSE (4 to 32 MHz), LSE
(32.768 to 1000 kHz).
• IC packages: LQFP, UFBGA, UFQFPN, WLCSP (see Table 7 for more about this). Operating
voltage range is 1.8V ±8%. to 3.6V.
Introduction to STM32 MCU Portfolio 33
1.3.5 F4
Table 8: STM32F4 features
The STM32F4 series is the most widespread group of Cortex-M4F based MCUs in the High-
performance segment. The F4-series is also the first STM32 series to have DSP and Floating Point SP
instructions. The F4 is pin-to-pin compatible with the STM32 F2-series and adds higher clock speed,
64K CCM static RAM, full duplex I²S, improved real-time clock, and faster ADCs. The STM32F4-
series is also targeted to multimedia applications, and some MCUs offer dedicated support for LCD-
TFT.
The most important features of this series are:
Introduction to STM32 MCU Portfolio 34
• Core:
– ARM Cortex-M4F core at a maximum clock ranging from 84 to 180 MHz.
• Memory:
– Static RAM from 128 to 384 KB.
* 4 KB battery-backed, 80 bytes battery-backed with tamper-detection erase.
– 64 KB Core Coupled Memory (CCM).
– Flash from 256 to 2048 KB.
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Peripherals:
– Each F4-series device features a range of peripherals which vary from line to line (see
Table 8 for a quick overview).
• Oscillators consist of internal RC (16 MHz, 32 kHz), optional external HSE (4 to 26 MHz), LSE
(32.768 to 1000 kHz).
• IC packages: BGA, LQFP, TFBGA, UFBGA, UFQFPN, WLCSP (see Table 8 for more about
this).
• Operating voltage range is 1.8V to 3.6V.
1.3.6 F7
Table 9: STM32F7 features
Introduction to STM32 MCU Portfolio 35
The STM32F7 series is the latest ultra-performance MCU in the High-performance segment, and it
wasthefirstCortex-M7basedMCUintroducedonthemarket.ThankstoST’sART TM Acceleratoras
well as an L1 cache, STM32F7 devices deliver the maximum theoretical performance of the Cortex-
M7regardlessofcodebeingexecutedfromembeddedflashorexternalmemory:1082CoreMark/462
DMIPS at 216 MHz. STM32F7 is clearly targeted to heavy multimedia embedded applications.
Thanks to the STM32 longevity program (10 years) it is possible to develop powerful embedded
applications without worrying about the MCU availability on the market in the far future. Cortex-
M7 is backwards compatible with the Cortex-M4 instruction set, and STM32F7 series is pin-to-pin
compatible with the STM32F4 series.
The most important features of this series are:
• Core:
– ARM Cortex-M7 core at a maximum clock of 216 MHz.
• Memory:
– Static RAM up to 512 KB with scattered architecture.
– L1 cache (I/D up to 16 KB + 16 KB).
– Flash from 512 to 2048 KB.
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Peripherals:
– Each F7-series device features a range of peripherals which vary from line to line (see
Table 9 for a quick overview).
• Oscillators consist of internal RC (16 MHz, 32 kHz), optional external HSE (4 to 26 MHz), LSE
(32.768 to 1000 kHz).
• IC packages: LQFP, TFBGA, UFBGA, WLCSP (see Table 9 for more about this).
• Operating voltage range is 1.7V to 3.6V.
1.3.7 H7
Table 10: STM32H7 features
Introduction to STM32 MCU Portfolio 36
ST announced in October 2016 a new family of STM32 MCUs: the STM32H7. This is a Cortex-M7
made with a 40nm process, able to run up to 400MHz. It also provides a 1MB SRAM with the same
scattered architecture found in the STM32F7-series. According to this author, this family of STM32
MCUs will open the doors to dual-core STM32 MCUs, tanks to the 40nm production process.
At the time of finalizing the book, these are the specs of the STM32H7-series:
• Core:
– ARM Cortex-M7 core at a maximum clock of 400 MHz.
• Memory:
– Static RAM up to 1024 KB with scattered architecture.
– L1 cache (I/D up to 16 KB + 16 KB).
– Flash from 512 to 2048 KB.
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Peripherals:
– Several new peripherals such as 14-bit ADC and a new SAI.
• IC packages: LQFP, TFBGA
• Pin-to-pin compatible with the STM32F7-series.
This book does not cover the STM32H7.
1.3.8 L0
Table 11: STM32L0 features
The STM32L0 series is the cost-effective solution of the Ultra Low-Power segment. The combination
of an ARM Cortex-M0+ core and ultra-low-power features makes STM32L0 the best fit for
applications operating on battery or powered by energy harvesting, offering the world’s lowest
power consumption at 125°C. The STM32L0 offers dynamic voltage scaling, an ultra-low-power
clock oscillator, LCD interface, comparator, DAC and hardware encryption. Current consumption
reference values:
Introduction to STM32 MCU Portfolio 37
• Dynamic run mode: down to 87 μA/MHz.
• Ultra-low-power mode + full RAM + low power timer: 440 nA (16 wakeup lines).
• Ultra-low-power mode + backup register: 250 nA (3 wakeup lines).
• Wake-up time: 3.5 µs.
The most important features of this series are:
• Core:
– ARM Cortex-M0+ core at a maximum clock rate of 32 MHz.
• Memory:
– Static RAM of 8 KB.
* 20-byte battery-backed with tamper-detection erase.
– Flash from 32 to 64 KB.
– EEPROM up to 2 KB (with ECC).
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Peripherals:
– Each L0-series features a range of peripherals which vary from line to line (see Table 11
for a quick overview).
• Oscillators consist of internal RC (16 MHz, 37 kHz), optional external HSE (1 to 24 MHz), LSE
(32.768kHz).
• IC packages are LQFP, TFBGA, UFQFPN, WLCSP (see Table 11 for more about this).
• Operating voltage range is 1.65V to 3.6V.
1.3.9 L1
Table 12: STM32L1 features
Introduction to STM32 MCU Portfolio 38
The STM32L1 series is the mid-range solution of the Ultra Low-Power segment. The combination of
an ARM Cortex-M3 core with FPU and ultra-low-power features makes the STM32L1 optimal for
applications operating on battery that also demand sufficient computing power. Like the L0-series,
The STM32L1 offers dynamic voltage scaling, an ultra-low-power clock oscillator, LCD interface,
comparator, DAC and hardware encryption.
Current consumption reference values:
• Ultra-low-power mode: 280 nA with backup registers (3 wakeup pins)
• Ultra-low-power mode + RTC: 900 nA with backup registers (3 wakeup pins)
• Low-power run mode: down to 9 μA
• Dynamic run mode: down to 177 μA/MHz
STM32L1 is pin-to-pin compatible with several MCU from the STM32F series. The most important
features of this series are:
• Core:
– ARM Cortex-M3 core with FPU at a maximum clock rate of 32 MHz.
• Memory:
– Static RAM from 4 to 80 KB.
* 20 bytes battery-backed with tamper-detection erase.
– Flash from 32 to 512 KB.
– EEPROM up to 2 KB (with ECC).
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Peripherals:
– Each L1 series device features a range of peripherals which vary from line to line (see
Table 12 for a quick overview).
• Oscillators consist of internal RC (16 MHz, 37 kHz), optional external HSE (1 to 24 MHz), LSE
(32.768kHz).
• IC packages are LQFP, TFBGA, UFBGA, UFQFPN, WLCSP (see Table 12 for more about this).
• Operating voltage range is 1.65V to 3.6V, including a programmable brownout detector.
Introduction to STM32 MCU Portfolio 39
1.3.10 L4
Table 13: STM32L4 features
The STM32L4 series is one of the best-in-class MCU series in the Ultra Low-Power segment.
The combination of an ARM Cortex-M4 core with FPU and ultra-low-power features, makes the
STM32L4 the best fit for applications demanding high performance while operating on battery or
powered by energy harvesting. Like the L1-series, The STM32L4 offers dynamic voltage scaling and
an ultra-low-power clock oscillator.
Current consumption reference values:
• Ultra-low-power mode: 30 nA with backup registers without RTC.
• Ultra-low-power mode + RTC: 330 nA with backup registers (5 wakeup lines).
• Ultra-low-power mode + 32 Kbytes of RAM: 360 nA.
• Ultra-low-power mode + 32 Kbytes of RAM + RTC: 660 nA.
• Dynamic run mode: down to 100 μA/MHz.
• Wake-up time: 5 μs.
STM32L4 is pin-to-pin compatible with several MCU from the STM32F series. The most important
features of this series are:
Introduction to STM32 MCU Portfolio 40
• Core:
– ARM Cortex-M4F core with FPU at a maximum clock rate of 80 MHz.
• Memory:
– Static RAM up to 320 KB.
* 20 bytes battery-backed with tamper-detection erase.
– Flash sizes from 256 to 1024 KB.
– Support to SDMMC and FSMC interfaces.
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Peripherals:
– Each L4-series device features a range of peripherals which vary from line to line (see
Table 13 for a quick overview).
• Oscillators consist of internal RC (16 MHz, 37 kHz), optional external HSE (1 to 24 MHz), LSE
(32.768kHz).
• IC packages are LQFP, UFBGA, WLCSP (see Table 13 for more about this).
• Operating voltage range is 1.7V to 3.6V.
1.3.11 L4+
Table 14: STM32L4+ features
The STM32L4+ series, introduced on the market at the end of 2017, is the new best-in-class
MCU series in the Ultra Low-Power segment. The STM32L4+ series shatters processing capabilities
Introduction to STM32 MCU Portfolio 41
limits in the ultra‐low‐power world by delivering 150 DMIPS/409 CoreMark score while executing
from internal Flash memory and by embedding 640 Kbytes SRAM enabling more advanced
consumer, medical and industrial low-power applications and devices. STM32L4+ microcontrollers
offer dynamic voltage scaling to balance power consumption with processing demand, low‐power
peripherals (LP UART, LP timers) available in Stop mode, safety and security features, smart and
numerous peripherals, advanced and low‐power analog peripherals such as op amps, comparators,
12‐bit DACs and 16‐bit ADC (hardware oversampling). The new STM32L4+ series also embeds
advanced graphic features enabling state‐of‐the‐art graphic user interfaces. The Chrom‐ART Ac-
celerator™, ST’s proprietary 2D hardware graphic accelerator, efficiently handles repetitive graphic
operations releasing the main CPU capabilities for real time processing or even more advanced
graphic operations. The Chrom‐ART Accelerator is coupled with the large embedded SRAM, the
Chrom‐GRC™ round display memory optimizer, the high-throughput Octo-SPI interface and to the
advancedTFTandDSIcontrollers,allowingyoutoachieve‘smartphone‐like’graphicuserinterfaces
in a single‐chip and an ultra‐low power solution.
Current consumption reference values:
• Ultra-low-power mode: 20 nA with backup registers without RTC.
• Ultra-low-power mode + RTC: 200 nA with backup registers (5 wakeup lines).
• Ultra-low-power mode + 64 Kbytes of RAM: 800 nA.
• Ultra-low-power mode + 64 Kbytes of RAM + RTC: 1 μA.
• Dynamic run mode: down to 43 μA/MHz.
• Wake-up time: 5 μs.
STM32L4+ is pin-to-pin compatible with several MCU from the STM32F series. The most important
features of this series are:
• Core:
– ARM Cortex-M4F core with FPU at a maximum clock rate of 120 MHz.
• Memory:
– Static RAM up to 640 KB.
* 64 bytes battery-backed with tamper-detection erase.
– Flash sizes from 1024 to 2048 KB.
– Support to SDMMC and FSMC interfaces.
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Peripherals:
– Each L4+-series device features a range of peripherals which vary from line to line (see
Table 14 for a quick overview).
• Oscillators consist of internal RC (16 MHz, 37 kHz), optional external HSE (1 to 24 MHz), LSE
(32.768kHz).
• IC packages are LQFP, UFBGA, WLCSP (see Table 14 for more about this).
• Operating voltage range is 1.7V to 3.6V.
Introduction to STM32 MCU Portfolio 42
1.3.12 STM32WB
Table 15: STM32WB features
The STM32WB series, introduced on the market at the beginning of 2018, is the new MCU series in
the Wireless segment. STM32WB is a lineup of dual-core STM32 microcontrollers with integrated
2.4GHz radio fronted suitable for wireless and Bluetooth 5.0 applications. These MCUs feature a
Cortex-M0+corerunningat32MHz(namedNetworkProcessor)dedicatedtotheradiomanagement
(a companion BLE 5.0 stack is also provided by ST) and a user-programmable Cortex-M4 core
running at 64 MHz (named Application Processor) for the main embedded application.
TheSTM32WBplatformisanevolutionoftheSTM32L4UltraLow‑Power seriesofMCUs.Itprovides
the same digital and analog peripherals suitable for applications requiring extended battery life
and complex functionalities. STM32WB integrate several communication peripherals, a convenient
crystal-less USB2.0 FS interface, audio support, an LCD driver, up to 72 GPIOs, an integrated SMPS
for power consumption optimization and multiple low-power modes to maximize battery life.
On top of wireless and low‐power features, a particular focus was placed on embedding security
hardware functions such as a 256‐bit AES, PCROP, JTAG Fuse, PKA (elliptic curve encryption
engine), and Root Secure Services (RSS). The RSS allows authenticating OTA communications,
regardless of the radio stack or application.
The STM32WB55 is a Bluetooth 5.0 certified device and it offers Mesh 1.0 software support, multiple
profiles and flexibility to integrate proprietary BLE stacks. OpenThread-certified software stack
is also available. The radio can also run BLE/OpenThread protocols concurrently. The embedded
generic MAC allows the usage of other IEEE 802.15.4 proprietary stacks like ZigBee®, or proprietary
protocols, giving even more options for connecting devices to the Internet of Things (IoT).
• Core:
– ARM Cortex-M4F core with FPU at a maximum clock rate of 64 MHz (Application
Processor).*ARMCortex-M0+coreamaximumclockrateof32MHz(NetworkProcessor).
• Memory:
– Static RAM up to 256 KB.
– Flash sizes up to 1024 KB.
Introduction to STM32 MCU Portfolio 43
– Support to Quad-SPI interface.
– Each chip has a factory-programmed 96-bit unique device identifier number.
• Radio:
– BLE 5.0 compatible radio front-end and stack.
– IEEE 802.15.4 compatible radio front-end.
– Over-The-Air Firmware upgradability.
– Support for an external Power Amplifier.
• Peripherals:
– Each WB-series device features a range of peripherals which vary from line to line (see
Table 15 for a quick overview).
• Oscillators consist of several internal RC (16 MHz, 32 kHz), optional external HSE (1 to 24
MHz), LSE (32.768kHz).
• IC packages are WLCSP, UFQFPN, VFQFPN (see Table 15 for more about this).
• Operating voltage range is 1.7V to 3.6V.
At the time of writing this chapter (May 2018) ST has not still released a dedicated CubeHAL for
the STM32WB family. Moreover, a specific Nucleo board is expected to be released in June 2018.
1.3.13 How to Select the Right MCU for You?
Selecting a microcontroller for a new project is never a trivial task, unless you are reusing a previous
design. First of all, there are tens of MCU manufacturers on the market, each one with its market
share and audience. ST, Microchip, TI, Atmel, Renesas, NXP and so on²². In our case we are very
lucky: we have already picked a brand.
As we have seen in the previous paragraphs, the STM32 is really an extensive portfolio. We can
choose an MCU from more than 500 devices (if we also consider package variants). So, where to
start?
In an ideal world, the first step of the selection process involves the understanding of needed
computing power. If we are going to develop a CPU intensive application, focused on multimedia
and graphic applications, then we have to shift our attention to the High-Performance group of
STM32 microcontrollers. If, on the other hand, the computing power is not the main requirement of
our electronic device, we can focus on the Mainstream segment, giving a close look at the STM32F1
series which offers the most extensive selection to choose from.
The next step is about connectivity requirements. If we need to interact with the external world
throughanEthernetconnectionorotherindustrialprotocolssuchasaCANbus,andourapplication
has to be responsive and able to deal with several Internet Protocols, then the STM32F4 portfolio is
probably your best option; otherwise the STM32F105/7 connectivity line is a better choice.
²² A good list of MCU manufacturers can be found here (http://bit.ly/1VUkN2e). Please, take note that in the last years several of the
mentioned companies have merged to try to survive in a market that has become very crowded.
Introduction to STM32 MCU Portfolio 44
If we are going to develop a battery-powered device (maybe the new bestseller on the wearable
market), then we have to look at the STM32L selection, choosing amongst the various sub-families
according to the computing power we need.
As stated at the beginning of this paragraph, this is the selection process as it happens in an ideal
world. But what about the real world? In the everyday development process, we probably have to
answer the following questions before we begin selecting the right MCU for our project:
• Is this device targeted for mass-market or a niche?
Ifyouaredevelopingadevicethatwillbeproducedinsmallquantities,thenthepricedifference
amongst the STM32 microcontrollers will not affect your project too much. You may also
consider the brand new STM32F7 and put little attention to software optimization (when
dealing with low performance MCUs you have to do your best to optimize your code. Keep in
mind that this is also a cost which increases the final investment). On the other hand, if you
are going to build a mass-market device, then the price of a single IC is really important: how
much you will save during production often outweighs the initial investment.
• What is the allowed budget for the total BOM?
This is a corollary to the previous point. If you already have the target price of your board,
then you must carefully select the right MCU in the early stages.
• What about space constraints? Does your board have to fit the latest wearable device, or do
you have sufficient room to use the IC package you prefer? The answer to this question deeply
affects the selection process of an MCU and what we can demand of it in terms of performance
and peripherals capabilities.
• Which production technology can my company afford?
This is another non-trivial question. LQFP packages are still really popular in the MCU market
thanks to the fact that they do not require complex production costs and they can be easily
assembled even on old production lines. BGA and WLCSP packages require X-Ray inspection
equipment and could affect your selection process.
• Is time-to-market critical for you?
Time-to-market is always a key factor for anybody doing business, but sometimes you are
required to have a firmware ready the day before you start the development process. This
could lead to non optimized firmware, at least at an early stage. This means that probably an
MCU with more computing power is the best choice for you.
• Can you reuse board layouts or code?
Every embedded developer has a portfolio of libraries and well known ICs. Software devel-
opment is a complex task which involves several stages before we can consider our firmware
stableandreadyforproduction.Sometimes(thisishappeningreallyfrequentlynowadays),you
have to deal with undocumented hardware bugs or, at least, with their unpredictable behavior.
This implies that you have to be really careful in deciding to switch to another architecture or
even another MCU in the same series.
One of the key features of the STM32 platform could help a lot during the selection process: the
pin-to-pin compatibility. This allows you to choose a more powerful (or cheaper) MCU during
Introduction to STM32 MCU Portfolio 45
the selection process, giving you the freedom to change it at a more advanced development stage.
For example, for a recent board I have developed, I started by choosing an STM32F1 MCU, but
I downgraded it to a cheaper STM32F0 when I reached the conclusion that it would satisfy my
requirements. However, keep in mind that this process always involves adapting the code to the
different sub-family.
Figure 17: The STM32 selection tool available on the ST web site
ST offers two convenient tools to help you in the MCU selection process. The first one is available
on the ST website²³, in the STM32 section: a parametric search tool which allows you to choose the
features you are interested in. The tool automatically filters the results to display the MCUs which
fit your requirements.
²³ http://www.st.com/web/en/catalog/mmc/FM141/SC1169
Introduction to STM32 MCU Portfolio 46
Figure 18: The MCU Finder App for Android OS
The second tool is a useful mobile app available for iOS²⁴, Android²⁵ and Windows Mobile²⁶.
1.4 The Nucleo Development Board
Every practical text about an electronic device requires a development board (also known as kit) to
start working with it. In the STM32 world the most widespread development board is the STM32
Discovery. ST has developed more than 20 different discovery boards useful to test STM32 MCUs
and their capabilities.
Figure 19: The STM32L0538 Discovery kit introduced by ST in 2015
Forexample,thenewSTM32L0538DISCOVERYboard(Figure19)allowstotestboththeSTM32L053
MCUandane-paperdisplay.YoucanfindalotoftutorialsaroundtheInternetcoveringboardsfrom
the Discovery line.
²⁴ http://apple.co/Uf20WR
²⁵ http://bit.ly/1Pvo8EV
²⁶ http://bit.ly/1Gf4YBd
Introduction to STM32 MCU Portfolio 47
ST has recently introduced a completely new range of development boards: the Nucleo. The Nucleo
line-up is divided in three main groups: Nucleo-32, Nucleo-64 and Nucleo-144 (see Figure 20). The
name of each group comes from the MCU package type used: Nucleo-32 uses an STM32 in an
LQFP-32 package; Nucleo-64 uses an LQFP-64; Nucleo-144 an LQFP-144. The Nucleo-64 was the
first line introduced to the market and there are 16 different boards²⁷, each one with a given STM32
microcontroller. The Nucleo-144 has been introduced in January 2016, and it is the first low-cost kit
equippingthepowerfulSTM32F746.ItalsoprovidesanEthernetphyther²⁸andaLANport.Sincethe
Nucleo-64 is the most complete range, this book will cover only this type of boards. In the remaining
parts of this book we refer to the Nucleo-64 simply with the term “Nucleo”.
The Nucleo is composed of two parts, as shown in Figure 21. The part with the mini-USB connector
is an ST-LINK 2.1 integrated debugger, which is used to upload the firmware on the target MCU and
todostep-by-stepdebugging.TheST-LINKinterfacealsoprovidesaVirtualCOMPort (VCP),which
canbeusedtoexchangedataandmessageswiththehostPC.OnekeyfeatureofNucleoboardsisthat
the ST-LINK interface can be easily separated from the rest of the board (two red scissors in Figure
21showwheretobreak).Thiswayitcanbeusedasstand-aloneST-LINKprogrammer(astand-alone
ST-LINK programmer costs about $25). However, the ST-LINK provides an optional SWD interface
which can be used to program another board without detaching the ST-LINK interface from the
Nucleo (as it already happens with the Discovery boards) by removing the two jumpers labeled ST-
LINK. The rest of the board contains the target MCU (the microcontroller we will use to develop
our applications), a RESET button, a user programmable tactile button and an LED. The board also
contains one pad to mount an external high speed crystal (HSE). All recent Nucleo boards already
provide a low-speed crystal. Finally, the board has several pin headers we will look at in a while.
Figure 20: A Nucleo development board
The reason why ST introduced this new kit is not clear, given that Discovery boards are more than
valid development tools. I think that the main reason is to attract people from the Arduino world.
²⁷ In late 2017 ST has introduced two additional Nucleo-64 boards, named Nucleo-L452RE-P and Nucleo-L433RC-P. These two additional
boards introduce a variation over the existing sixteen Nucleo-64 boards: they add an integrates SMPS to further show low-power capabilities
of those two MCUs. This book was finalized before the commercialization of those two boards, and it does not cover them at all.
²⁸ TheEthernetphyther (alsocalledEthernetPHY)isadevicewhichtranslatesmessagesexchangedoveraLANnetworkinelectricalsignals.
Introduction to STM32 MCU Portfolio 48
In fact, Nucleo boards provide pin headers to accept Arduino shields, expansion boards specifically
built to expand the Arduino UNO and all other Arduino boards. Figure 22²⁹ shows the STM32
peripherals and GPIOs associated with the Arduino compatible connector.
Figure 21: The relevant parts of a Nucleo board
To be honest, the Nucleo boards have other interesting advantages compared to the Discovery ones.
First of all, ST sells them at a really aggressive price (probably for the aforementioned reasons). A
Nucleo costs between $10 and $15, depending on where you buy it, and if you think about what you
cando with this architecture,youhaveto agree that it is really underpriced compared to an Arduino
DUE board (which is also equipped with a 32-bit processor from Atmel). Another interesting feature
is that Nucleo boards are designed to be pin-to-pin compatible with each other. This means that
you can develop the firmware for the STM32Nucleo-F103RB board (equipped with the popular
STM32F103 MCU) and later adapt it to a more powerful Nucleo (e.g. STM32Nucleo-F401RE) if you
need more co mputing power.
²⁹ Figure 22 and 22 are taken from the mbed.org website and they refer to the Nucleo-F401RE board. Please, refer to Appendix C for the
right pin-out of your Nucleo board.
Introduction to STM32 MCU Portfolio 49
Figure 22: Peripherals and GPIOs associated to Arduino headers
In addition to Arduino compatible pin headers, the Nucleo provides its own expansion connectors.
They are two 2x19, 2.54mm spaced male pin headers. They are called Morpho connectors and are a
convenient way to access most of the MCU pins.Figure 23 shows the STM32 peripherals and GPIOs
associated with the Morpho connector.
Figure 23: Peripherals and GPIOs associated to Morpho headers
As far as I know there aren’t expansion boards which use the Morpho connector yet. Even ST is
releasing several expansion shields for the Nucleo that are only compatible with the Arduino UNO.
For example, Figure 24 shows a Nucleo board with an X-NUCLEO-IDB04A1 expansion board, a
Introduction to STM32 MCU Portfolio 50
shield which features the BlueNRG monolithic Bluetooth Low Energy 4.0 Network Processor.
Figure 24: The BlueNRG expansion shield
TherearesixteenNucleoboardsavailableatthetimeofwritingthischapter(September2015).Table
16 summarizes their main features, together with the ones common to all Nucleo boards.
Introduction to STM32 MCU Portfolio 51
Table 16: The list of available Nucleo boards and their features
Why Use the Nucleo as Example Board for This Book?
The answers to this question are almost all contained in the previous paragraphs. First of
all, Nucleo boards are cheap, and allow you to start learning the STM32 platform at nearly
no cost. Second, they greatly simplify the instructions and examples contained in this book.
You are completely free to use the Nucleo you like. The book will show all the steps required
to easily adapt examples to your specific Nucleo. The third reason comes from the previous
statement:theauthorboughtallNucleo-64boardstoruntests,andhedidnotinvestafortune
:-)
Keep in mind that the whole book is designed to give the reader all the necessary tools to
start working with any board, even custom ones. It will be really easy to adapt the examples
to your needs.
2. Setting-Up the Tool-Chain
Before we can start developing applications for the STM32 platform, we need a complete tool-chain.
A tool-chain is a set of programs, compilers and tools that allows us:
• to write down our code and to navigate inside source files of our application;
• to navigate inside the application code, allowing us to inspect variables, function definition-
s/declarations, and so on;
• to compile the source code using a cross-platform compiler;
• to upload and debug our application on the target development board (or a custom board we
have made).
To accomplish these activities, we essentially need:
• an IDE with integrated source editor and navigator;
• a cross-platform compiler able to compile source code for the ARM Cortex-M platform;
• a debugger that allows us to execute step by step debugging of firmware on the target board;
• a tool that allows to interact with the integrated hardware debugger of our Nucleo board (the
ST-LINK interface) or the dedicated programmer (e.g. a JTAG adapter).
There are several complete tool-chains for the STM32 Cortex-M family, both free and commercial.
IAR for Cortex-M¹ and Keil² are two of the most used commercial tool-chains for Cortex-M
microcontrollers. They are a complete solution for developing applications for the STM32 platform,
but being commercial products they have a street price that may be too high for small sized
companies or students (they may cost more than $5,000 according the features you need). However,
this book does not cover commercial IDEs and, if you already have a license for one of these
environments, you can skip this chapter, but you will need to arrange the instructions contained
in this book according your tool-chain.
CooCox³ and System Workbench for STM32⁴ (shortened as SW4STM32) are two free development
environments for the STM32 platform. These IDEs are essentially based on Eclipse and GCC. They
do a good job trying to provide support for the STM32 family, and they work out of the box in
most cases. However, there are several things to consider while evaluating these tools. First of all,
CooCox IDE currently supports only Windows; instead, SWSTM32 provides support for Linux and
MacOS too, but it lacks of some additional features found in the tool-chain described in this book.
Moreover, they already come with all needed tools preinstalled and configured. While this could be
¹ http://bit.ly/1Qxtkql
² http://www.keil.com/arm/mdk.asp
³ http://www.coocox.org/
⁴ http://www.openstm32.org/
Setting-Up the Tool-Chain 53
an advantage if you are totally new to the development process for Cortex-M processors, it can be a
strong limitation if you want to do serious work. It is really important to have the full control over
the tools needed to develop your firmware, especially when dealing with Open Source software. So,
the best choice is to set up a complete tool-chain from scratch. This allows you to become familiar
with the programs and their configuration procedures, giving full control over your development
environment. This could be annoying especially at the first time, but it is the only way to learn
which piece of software is involved in a given development stage.
In this chapter I will show the required steps to setup a complete tool-chain for the STM32 platform
onWindows, MacOSX andLinux. The tool-chainis basedon twomaintools, Eclipseand GCC,plus
a series of external tools and Eclipse plug-ins that allow you to build STM32 programs efficiently.
Although the instructions are essentially equal for the three platforms, I will adapt them for each
OS,showingdedicatedscreencapturesandcommands.Thiswillsimplifytheinstallationprocedure,
and will allow you to setup a complete tool-chain in less time. This will also give us the opportunity
to study in detail every component of our tool-chain. In the next chapter, I will show you how to
setup a minimal application (a blinking LED - theHello World application in electronics), which will
allow us to test our tool-chain.
2.1 Why Choose Eclipse/GCC as Tool-Chain for STM32
Before we start setting up our tool-chain, there is a really common question to answer: which tool-
chain is the best one to develop applications for the STM32 platform? The question is unfortunately
not simple to answer. Probably the best answer is that it depends on the type of application. First
of all, the audience should be divided between professionals and hobbyists. Companies often prefer
to use commercial IDEs with annual fees that allow to receive technical support. You have to figure
out that in business time means money and, sometimes, commercial IDE can reduce the learning
curve (especially if you consider that ST gives explicit support to these environments). However, I
think that even companies (especially small organizations) can take great advantages in using an
open source tool-chain.
I think these are the most important reasons to use a Eclipse/GCC tool-chain for embedded
development with STM32 MCUs:
• It is GCC based: GCC is probably the best compiler on the earth, and it gives excellent results
even with ARM based processors. ARM is nowadays the most widespread architecture (thanks
to the embedded systems becoming widespread in the recent years), and many hardware and
software manufacturers use GCC as the base tool for their platform.
• It is cross-platform: if you have a Windows PC, the latest sexy Mac or a Linux server you will
be able to successfully develop, compile and upload the firmware on your development board
with no difference. Nowadays, this is a mandatory requirement.
• Eclipse diffusion: a lot of commercial IDEs for STM32 (like TrueSTUDIO and others) are also
based on Eclipse, which has become a sort of standard. There are a lot of useful plug-ins for
Eclipse that you can download with just one click. And it is a product that evolves day by day.
Setting-Up the Tool-Chain 54
• It is Open Source: ok. I agree. For such giant pieces of software it is really hard to try to
understand their internals and modify the code, especially if you are a hardware engineer
committed to transistors and interrupts management. But if you get in trouble with your tool,
it is simpler to try to understand what goes wrong with an open source tool than a closed one.
• Large and growing community: these tools have by now a great international community,
which continuously develops new features and fixes bugs. You will find tons of examples and
blogs, which can help you during your work. Moreover, many companies, which have adopted
this software as official tools, give economical contribution to the main development. This
guarantees that the software will not suddenly disappear.
• It is free: Yep. I placed this as the last point, but it is not the least. As said before, a commercial
IDE can cost a fortune for a small company or a hobbyist/student. And the availability of free
tools is one of the key advantages of the STM32 platform.
2.1.1 Two Words About Eclipse…
Eclipse⁵isanOpenSourceandafreeJavabasedIDE. Despitethisfact(unfortunately,Javaprograms
tend to eat a lot of machine resources and to slow down your PC), Eclipse is one of the most
widespread and complete development environments. Eclipse comes in several pre-configured
versions, customized for specific uses. For example, the Eclipse IDE for Java Developers comes
preconfigured to work with Java and with all those tools used in this development platform (Ant,
Maven, and so on). In our case, the Eclipse IDE for C/C++ Developers is what fits our need.
Eclipseisdesignedtobeexpandablethankstoplug-ins.Thereareseveralplug-insavailableinEclipse
Marketplace really useful for software development for embedded systems. We will install and use
most of them in this book. Moreover, Eclipse is highly customizable. I strongly suggest you to take
a look at its settings, which allow you to adapt it to your needs and flavor.
2.1.2 … and GCC
The GNU Compiler Collection⁶ (GCC) is a complete and widespread compiler suite. It is the only
development tool able to compile several programming languages (front-end) to tens of hardware
architectures that come in several variants. GCC is a really complex piece of software. It provides
several tools to accomplish compilation tasks. These include, in addition to the compiler itself,
an assembler, a linker, a debugger (known as GNU Debugger - GDB), several tools for binary
files inspection, disassembly and optimization. Moreover, GCC is also equipped with the run-time
environment for the C language, customized for the target architecture.
In recent years, several companies, even in the embedded world, have adopted GCC as their
official compiler. For example, ATMEL uses GCC as cross-compiler for its AVR Studio development
environment.
⁵ http://www.eclipse.org
⁶ https://gcc.gnu.org/
Setting-Up the Tool-Chain 55
What Is a Cross-Compiler?
We usually refer to term compiler as a tool able to generate machine code for the processor
in our PC. A compiler is just a “language translator” from a given programming language
(C in our case) to a low-level machine language, also known as assembly. For example, if we
are working on Intel x86 machine, we use a compiler to generate x86 assembly code from
the C programming language. For the sake of completeness, we have to say that nowadays a
compiler is a more complex tool that addresses both the specific target hardware processor
and the Operating System we are using (e.g. Windows 7).
A cross-platform compiler is a compiler able to generate machine code for a hardware
machine different from the one we are using to develop our applications. In our a case,
the GCC ARM Embedded compiler generates machine code for Cortex-M processors while
compiling on an x86 machine with a given OS (e.g. Windows or Mac OSX).
In the ARM world, GCC is the most used compiler especially due the fact that it is used as
main development tool for Linux based Operating Systems for ARM Cortex-A processors (ARM
microcontrollers that equip almost every mobile device). ARM engineers actively collaborate to the
development of ARM GCC. ST Microelectronics does not provide its development environment, but
explicitly supports GCC based tool-chains. For this reason, it is relatively simple to setup a complete
and working tool-chain to develop embedded applications with GCC.
The next three paragraphs, and their sub-paragraphs, are almost identical. They only differ
on those parts specific for the given OS (Windows, Linux or Mac OS). So, jump to the
paragraph you are interested in, and skip the remaining ones.
2.2 Windows - Installing the Tool-Chain
The whole installation procedure assumes these requirements:
• A Windows based PC with sufficient hardware resources (I suggest to have at least 4Gb of
RAM and 5Gb of free space on the Hard Disk); the screen captures in this section are based on
Windows 7, but the instructions have been tested successfully on Windows XP, 7, 8.1 and the
latest Windows 10.
• Java SE 8 Update 121 or later. If you do not have this version, you can download it for free
from official Java SE support page⁷.
Please, take note that if you have a 64-bit Windows machine, you need to install the 64-bit
Java Virtual Machine (JVM). Even if it is perfectly possible to use a 32-bit JVM on a 64-bit
machine, Eclipse requires that you have a 64-bit Java if using a 64-bit machine.
⁷ http://bit.ly/2k5ppYR
Setting-Up the Tool-Chain 56
Choosing a Tool-Chain Folder
One interesting feature of Eclipse is that it is not required to be installed in a specific path
on the hard disk. This allows the user to decide where to put the whole tool-chain and, if
desired, to move it in another place or to copy it on another machine using a thumb drive
(this is really useful if you have several machines to maintain).
In this book we will assume that the whole tool-chain is installed inside the
C:\STM32Toolchain folderontheHardDisk.Youarefreetoplaceitelsewhere,butrearrange
paths in the instructions accordingly.
2.2.1 Windows - Eclipse Installation
The first step is to install the Eclipse IDE. As said before, we are interested in the Eclipse version for
C/C++developers.Thelatestversionattimeofrevisingthischapter(August2018)isPhoton(Eclipse
v4.8). However, it is strongly suggested to use the previous release, that is Oxygen.3a (Eclipse
v4.7.3a), since the newest one is still not supported by the GNU MCU Eclipse plug-ins suite
and by several other tools used in this book. It can be downloaded from the official download
page⁸ as shown in Figure 1⁹.
Figure 1: Eclipse download page
Choose the release (32bit or 64bit) for your PC.
⁸ https://www.eclipse.org/downloads/packages/release/oxygen/3a/
⁹ Some screen captures may appear different from the ones reported in this book. This happens because the Eclipse IDE is updated
frequently. Don’t worry about that: the installation instructions should work in any case.
Setting-Up the Tool-Chain 57
The Eclipse IDE is distributed as a ZIP archive. Extract the contents of the archive inside the folder
C:\STM32Toolchain . At the end of the process you will find the folder C:\STM32Toolchain\eclipse
containing the whole IDE.
Now we can execute for the first time the Eclipse IDE. Go inside the C:\STM32Toolchain\eclipse
folderandrunthe eclipse.exe file.Afterawhile,Eclipsewillaskyouforthepreferredfolderwhere
all Eclipse projects are stored (this is called workspace), as shown in Figure 2.
Figure 2: Eclipse workspace setting
You are free to choose the folder you prefer, or leave the suggested one. In this book we will assume
that the Eclipse workspace is located inside the C:\STM32Toolchain\projects folder. Arrange the
instructions accordingly if you choose another location.
2.2.2 Windows - Eclipse Plug-Ins Installation
Once Eclipse is started, we can proceed to install some relevant plug-ins.
What Is a Plug-In?
Aplug-inisanexternalsoftwaremodulethatextendsEclipsefunctionalities.Aplug-inmust
adhere to a standard API defined by Eclipse developers. In this way, it is possible for third
party developers to add features to the IDE without changing the main source code. We will
install several plug-ins in this book to adapt Eclipse to our needs.
Thefirstplug-inweneedtoinstallistheC/C++DevelopmentToolsSDK,alsoknownasEclipseCDT,
or simply CDT. CDT provides a fully functional C and C++ Integrated Development Environment
(IDE) based on the Eclipse platform. Features include: support for project creation and managed
build for various tool-chains, standard make build, source navigation, various source knowledge
tools,suchastypehierarchy,callgraph,includesbrowser,macrodefinitionbrowser,codeeditorwith
syntax highlighting, folding and hyperlink navigation, source code refactoring and code generation,
visual debugging tools, including memory, registers, and disassembly viewers.
Setting-Up the Tool-Chain 58
To install CDT we have to follow this procedure. Go to Help->Install new software… as shown in
Figure 3.
Figure 3: Eclipse plug-in install menu
In the plug-ins install window, we need to enable other plug-in repositories by clicking onManage…
button.InthePreferenceswindow,selectthe“Install/Update->AvailableSoftwareSites”entryonthe
left and then check “CDT” entry as shown in Figure 4. Click on the OK button.
Setting-Up the Tool-Chain 59
Figure 4: Eclipse plug-in repository selection
Now, from “work with” drop-down menu choose “CDT” repository, as shown in Figure 5, and
then select “CDT Main Features->C/C++ Development Tools” and “CDT Optional Features->C/C++
GDB Hardware Debugging” entries, as shown in Figure 6. Click on “Next” button and follow the
instructions to install the plug-in. At the end of installation process (the installation takes a while
depending your Internet connection speed), restart Eclipse when requested.
Setting-Up the Tool-Chain 60
Figure 5: CDT repository selection
Setting-Up the Tool-Chain 61
Figure 6: CDT plug-in selection
NowwehavetoinstalltheGNUMCUplug-insforEclipse¹⁰.Theseplug-insaddarichsetoffeatures
toEclipseCDTtointerfacetheGCCARMtool-chain.Moreover,theyprovidespecificfunctionalities
for the STM32 platform. Plug-ins are developed and maintained by Liviu Ionescu, who did a really
excellentworkinprovidingsupportfortheGCCARMtool-chain.Withouttheseplug-insitisalmost
impossible to develop and run code with Eclipse for the STM32 platform.
To install GCC ARM plug-ins go to Help->Install new software…. In the Install window, click the
Add… button and fill the fields in the following way (see Figure 7):
Name: GNU MCU Eclipse Plug-ins
Location: http://gnu-mcu-eclipse.netlify.com/v4-neon-updates
Click on the OK button. Now, from “work with” drop-down menu choose “GNU MCU Eclipse Plug-
ins” repository. A list of installable packages appears. Check the packages to install according to
Figure 8.
¹⁰ https://gnu-mcu-eclipse.github.io/
Setting-Up the Tool-Chain 62
Figure 7: GNU MCU plug-ins installation
Figure 8: GNU MCU plug-ins selection
Click on “Next >” button and follow the instructions to install the plug-ins. At the end of
installation process, restart Eclipse when requested. he end of installation process, restart Eclipse
when requested.
Read Carefully
If you run in troubles during the plug-ins installation (handshake error, provisioning error
or something like that), please refer to the troubleshooting section.
Setting-Up the Tool-Chain 63
Eclipse is now essentially configured to start developing STM32 applications. Now we need the
cross-compiler suite to generate the firmware for the STM32 family.
2.2.3 Windows - GCC ARM Embedded Installation
The next step in tool-chain configuration is installing the GCC suite for ARM Cortex-M and
Cortex-R microcontrollers. This is a set of tools (macro preprocessor, compiler, assembler, linker
and debugger) designed to cross-compile the code we will create for the STM32 platform.
The latest release of ARM GCC can be downloaded from ARM Developer¹¹. At the time of writing
this chapter, the latest available version is the 6.0. The Windows Installer can be downloaded from
the download section¹².
Once download is complete, run the installer. When the installer asks for the destination folder,
choose C:\STM32Toolchain\gcc-arm and then click on “Install” button, as shown in Figure 9.
Figure 9: Selection of GCC destination folder
The installer, by default, suggests a destination folder that is related to the GCC version we
are going to install (6.0 2017q2). This is not convenient, because when GCC is updated to a
newer version we need to change settings for each Eclipse project we have made.
Once the installation is complete, the installer will show us a form with four different checkboxes.
If only one GCC is installed on your system, or you do not know, check the entry Add path to
environment variable and Add registry information (two checked boxes), as shown in Figure 10.
¹¹ https://developer.arm.com/open-source/gnu-toolchain/gnu-rm
¹² https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads
Setting-Up the Tool-Chain 64
Figure 10: Final GCC install options
If you have multiple copies of GCC installed in your system, then I suggest to leave that
two options unchecked, and to handle the PATH environment variable using Eclipse. Refer
to the Troubleshooting Appendix (paragraph named “Eclipse cannot locate the compiler”)
where it is explained how to configure GCC paths in Eclipse.
2.2.4 Windows – Build Tools Installation
Windows historically lacks some tools that are a must in the UNIX world. One of these is make,
the tool that controls the compilation process of programs written in C/C++. If you have already
installedaproductlikeMinGWorsimilar(anditisconfiguredinyourPATHenvironmentcorrectly),
you can skip this process. If not, you can install the Build Tools package made by the same author of
GCC ARM plug-ins for Eclipse. You can download setup program from here¹³. Choose the version
that fits your OS release (32 or 64 bit). At the time of writing this chapter, the last available version
is 2.8.
When asked, install the tools in this folder: C:\STM32Toolchain\Build Tools . Restart Eclipse if it is
already running.
2.2.5 Windows – OpenOCD Installation
OpenOCD¹⁴ is a tool that allows to upload the firmware on the Nucleo board and to do the step-by-
step debugging. Originally started by Dominic Rath, OpenOCD is now actively maintained by the
community and several companies, including STM. We will discuss it in depth in Chapter 5, which
is dedicated to the debugging. But we will install it in this chapter, because the procedure changes
between the three different platforms (Windows, Linux and Mac OS). The latest official release at
the time of writing this book is the 0.10.
Compiling a tool like OpenOCD, expressly designed to be compiled on UNIX like systems, is not
a trivial task. It requires a complete UNIX C tool-chain like MinGW or Cygwin. Luckily, Liviu
¹³ http://bit.ly/2g2bu5R
¹⁴ http://openocd.org/
Setting-Up the Tool-Chain 65
Ionescu has already done the dirty job for us. You can download the latest development version
of OpenOCD (0.10.0-5-20171110-* at the time of writing this chapter) from the GNU MCU Eclipse
official repository¹⁵. Choose the .exe package for your Windows platform (32- or 64-bits). When
asked, install the files inside the C:\STM32Toolchain\openocd folder (pay attention to write openocd
as-is).
Once again, this ensures us that we should not change Eclipse settings when a new
release of OpenOCD will be released, but we only need to replace the content inside
C:\STM32Toolchain\openocd folder with the new software release.
2.2.6 Windows – ST Tools and Drivers Installation
ST provides several tools that are useful for developing STM32 based applications. We will install
them in this chapter, and we will discuss their use later in this book.
STM32CubeMX is a graphical tool used to generate setup files in C programming language for
an STM32 MCU, according the hardware configuration of our board. For example, if we have the
Nucleo-F401RE,whichisbasedontheSTM32F401REMCU,andwewanttouseitsuserLED(marked
asLD2ontheboard),thenSTM32CubeMXwillautomaticallygenerateallsourcefilescontainingthe
C code required to configure the MCU (clock, peripheral ports, and so on) and the GPIO connected
to the LED (port GPIO 5 on port A on almost all Nucleo boards). You can download STM32CubeMX
from the official ST website¹⁶¹⁷ (the download link is at the bottom of the page), and follow the
installation instructions.
Another important tool is the STM32CubeProgrammer¹⁸. It is a software that uploads the firmware
on the MCU using the ST-LINK interface of our Nucleo, or a dedicated ST-LINK programmer.
We will use it in the next chapter. The STM32CubeProgrammer installation package also pro-
vides necessary drivers to interface ST development boards with Windows. You can download
STM32CubeProgrammer from the official ST page¹⁹ (the download link is at the bottom of the page
in the GET SOFTWARE section), and follow the installation instructions.
2.2.6.1 Windows – ST-LINK Firmware Upgrade
Warning
Read this paragraph carefully. Do not skip this step!
I bought several Nucleo boards and I saw that all boards come with an old ST-LINK firmware. In
ordertousetheNucleowithOpenOCD,thefirmwaremustbeupdatedatleasttothe2.29.18version.
¹⁵ http://bit.ly/2khxhXL
¹⁶ http://bit.ly/1RLCa4G
¹⁷ To download the software, you need to register to the ST website providing a valid email.
¹⁸ http://bit.ly/2CK4aFa
¹⁹ http://bit.ly/2CK4aFa
Setting-Up the Tool-Chain 66
Once the ST-LINK drivers are installed, we can download the latest ST-LINK firmware update from
ST website²⁰. The firmware is distributed as ZIP file. Extract it in a convenient place. Connect
your Nucleo board using a USB cable and go inside the Windows sub-folder and execute the file
ST-LINKUpgrade . Click on Device Connect button.
Figure 12: The ST-LINK Upgrade program
Afterawhile,ST-LINKUpgradewillshowifyourNucleofirmwareneedstobeupdated(pointingout
adifferentversion,asshowninFigure12).Ifso,clickonYes>>>>buttonandfollowtheinstructions.
Congratulation. The tool-chain is now complete, and you can jump to the next chapter.
2.3 Linux - Installing the Tool-Chain
The whole installation procedure will assume these requirements:
• A PC running Ubuntu Linux 14.04 LTS Desktop (aka Trusty Tahr) with sufficient hardware
resources (I suggest to have at least 4Gb of RAM and 5Gb of free space on the Hard Disk); the
instructions should be easily arranged for other Linux distributions.
• Java 8 Update 121 or later. Read the next paragraph dedicated for Java installation if it is not
installed yet.
Choosing a Tool-Chain Folder
One interesting feature of Eclipse is that it is not required to be installed in a specific path
on the Hard Disk. This allows the user to decide where to put the whole tool-chain and, if
desired, to move it in another place or to copy it on another machine (this is really useful if
you have several Linux machines to maintain).
In this book we will assume that the whole tool-chain is installed inside the
∼/STM32Toolchain folder on the Hard Disk (that is, a STM32Toolchain directory inside your
Home folder). You are free to place it elsewhere, but rearrange paths in the instructions
accordingly.
²⁰ http://bit.ly/1RLDp3H
Setting-Up the Tool-Chain 67
2.3.1 Linux - Install i386 Run-Time Libraries on a 64-bit Ubuntu
If your Ubuntu is a 64-bit release, then you need to install some compatibility libraries that allow to
run 32-bit applications. To do so, simply run the following commands at Linux console:
$ sudo dpkg –-add-architecture i386
$ sudo apt-get update
$ sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386
If in doubt about your Ubuntu release, then you can run the following command at Linux console:
$ uname -i
If the result is x86_64 , then you have a 64-bit machine, otherwise a 32-bit one.
2.3.2 Linux - Java Installation
Java 8 installation under Ubuntu Linux requires an in-depth analysis. It is strongly suggested to
install the official Oracle distribution of Java, as shown here.
First we need to add webupd8team Java PPA repository in our system and install Oracle Java 8 using
following set of commands at Linux console:
$ sudo add-apt-repository ppa:webupd8team/java
$ sudo apt-get update
$ sudo apt-get install oracle-java8-installer
AftersuccessfullyinstallingtheJDK,checkthatallworkswellrunningthe java -version command
at command line:
$ java -version
java version "1.8.0_60"
Java(TM) SE Runtime Environment (build 1.8.0_60-b27)
Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)
2.3.3 Linux - Eclipse Installation
The first step is to install the Eclipse IDE. As said before, we are interested in the Eclipse version for
C/C++developers.Thelatestversionattimeofrevisingthischapter(August2018)isPhoton(Eclipse
v4.8). However, it is strongly suggested to use the previous release, that is Oxygen.3a (Eclipse
v4.7.3a), since the newest one is still not supported by the GNU MCU Eclipse plug-ins suite
Setting-Up the Tool-Chain 68
and by several other tools used in this book. It can be downloaded from the official download
page²¹ as shown in Figure 13²².
Figure 13: Eclipse download page
TheEclipseIDEisdistributedasa .tar.gz archive.Extractthecontentofthearchiveas-isinsidethe
folder ∼/STM32Toolchain .Attheendoftheprocessyouwillfindthefolder ∼/STM32Toolchain/eclipse
containing the whole IDE.
Now we can execute for the first time the Eclipse IDE. Go inside the ∼/STM32Toolchain/eclipse
folder and run the eclipse file. After a while, Eclipse will ask you for the preferred folder where all
Eclipse projects are stored (this is called workspace), as shown in Figure 14.
²¹ https://www.eclipse.org/downloads/packages/release/oxygen/3a/
²² Some screen captures may appear different from the ones reported in this book. This happens because the Eclipse IDE is updated
frequently. Don’t worry about that: the installation instructions should work in any case.
Setting-Up the Tool-Chain 69
Figure 14: Eclipse workspace setting
You are free to choose the folder you prefer, or leave the suggested one. In this book we will assume
that the Eclipse workspace is located inside the ∼/STM32Toolchain/projects folder. Arrange the
instructions accordingly if you choose another location.
2.3.4 Linux - Eclipse Plug-Ins Installation
Once Eclipse is started, we can proceed to install some relevant plug-ins.
What Is a Plug-In?
Aplug-inisanexternalsoftwaremodulethatextendsEclipsefunctionalities.Aplug-inmust
adhere to a standard API defined by Eclipse developers. In this way, it is possible for third
party developers to add features to the IDE without changing the main source code. We will
install several plug-ins in this book to adapt Eclipse to our needs.
Thefirstplug-inweneedtoinstallistheC/C++DevelopmentToolsSDK,alsoknownasEclipseCDT.
CDT provides a fully functional C and C++ Integrated Development Environment based on Eclipse
platform. Features include: support for project creation and managed build for various tool-chains,
standard make build, source navigation, various source knowledge tools, such as type hierarchy, call
graph, include browser, macro definition browser, code editor with syntax highlighting, folding and
hyperlinknavigation,sourcecoderefactoringandcodegeneration,visualdebuggingtools,including
memory, registers, and disassembly viewers.
To install CDT we have to follow this procedure. Go to Help->Install new software… as shown in
Figure 15.
Setting-Up the Tool-Chain 70
Figure 15: Eclipse plug-in install menu
In the plug-ins install window, we need to enable other plug-in repositories clicking on Manage…
button.InthePreferenceswindow,selectthe“Install/Update->AvailableSoftwareSites”entryonthe
left and then check “CDT” entry as shown in Figure 16. Click on the OK button.
Setting-Up the Tool-Chain 71
Figure 16: Eclipse plug-in repository selection
Now, from “work with” drop-down menu choose “CDT” repository, as shown in Figure 17, and
then select “CDT Main Features->C/C++ Development Tools” and “CDT Optional Features->C/C++
GDB Hardware Debugging” entries, as shown in Figure 18. Click on “Next” button and follow the
instructions to install the plug-in. At the end of installation process (the installation takes a while
depending your Internet connection speed), restart Eclipse when requested.
Setting-Up the Tool-Chain 72
Figure 17: CDT repository selection
Setting-Up the Tool-Chain 73
Figure 18: CDT plug-in selection
NowwehavetoinstalltheGNUMCUplug-insforEclipse²³.Theseplug-insaddarichsetoffeatures
toEclipseCDTtointerfacetheGCCARMtool-chain.Moreover,theyprovidespecificfunctionalities
for the STM32 platform. Plug-ins are developed and maintained by Liviu Ionescu, who did a really
excellentworkinprovidingsupportfortheGCCARMtool-chain.Withouttheseplug-insitisalmost
impossible to develop and run code with Eclipse for the STM32 platform. +
To install GCC ARM plug-ins go to Help->Install new software…. In the Install window, click the
Add… button and fill the fields in the following way (see Figure 19):
Name: GNU MCU Eclipse Plug-ins
Location: http://gnu-mcu-eclipse.netlify.com/v4-neon-updates
Click on the OK button. Now, from “work with” drop-down menu choose “GNU MCU Eclipse Plug-
ins” repository. A list of installable packages appears. Check the packages to install according to
Figure 20.
²³ https://gnu-mcu-eclipse.github.io/
Setting-Up the Tool-Chain 74
Figure 19: GNU MCU plug-ins installation
Figure 20: GNU MCU plug-ins selection
Click on “Next >” button and follow the instructions to install the plug-ins. At the end of installation
process, restart Eclipse when requested.
Read Carefully
If you run in troubles during the plug-ins installation (handshake error, provisioning error
or something like that), please refer to the troubleshooting section.
Eclipse is now essentially configured to start developing STM32 applications. Now we need the
Setting-Up the Tool-Chain 75
cross-compiler suite to generate the firmware for the STM32 family.
2.3.5 Linux - GCC ARM Embedded Installation
The next step in tool-chain configuration is installing the GCC suite for ARM Cortex-M and
Cortex-R microcontrollers. This is a set of tools (macro preprocessor, compiler, assembler, linker
and debugger) designed to cross-compile the code we will create for the STM32 platform.
The latest release of ARM GCC can be downloaded from ARM Developer²⁴. At the time of writing
this chapter, the latest available version is the 6.0. The Linux tarball can be downloaded from the
download section²⁵.
Once download is complete, extract the .tar.bz2 package inside the ∼/STM32Toolchain
Theextractedfolder,bydefault,isnamed gcc-arm-none-eabi-6-2017-q2-update .Thisisnot
convenient, because when GCC is updated to a newer version we need to change settings
for each Eclipse project we have made. So, rename it to simply gcc-arm .
2.3.6 Linux - Nucleo Drivers Installation
Warning
Read this paragraph carefully. Do not skip this step!
On Linux, we do not need to install Nucleo drivers from ST, but we need to install libusb-1.0 with
the following command:
$ sudo apt-get install libusb-1.0
2.3.6.1 Linux – ST-LINK Firmware Upgrade
Warning
Read this paragraph carefully. Do not skip this step!
I bought several Nucleo boards and I saw that all boards come with an old ST-LINK firmware. In
ordertousetheNucleowithOpenOCD,thefirmwaremustbeupdatedatleasttothe2.29.18version.
²⁴ https://developer.arm.com/open-source/gnu-toolchain/gnu-rm
²⁵ https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads
Setting-Up the Tool-Chain 76
We can download the latest ST-LINK drivers from ST website²⁶. The firmware is distributed as ZIP
file. Extract it in a convenient place. Connect your Nucleo board using a USB cable and go inside
the AllPlatforms subfolder and execute the file STLinkUpgrade.jar . Click on Open in update mode
button (see Figure 21).
Figure 21: The ST-LINK Upgrade program
After a while, ST-LINK Upgrade will show if your Nucleo firmware needs to be updated (it shows
different versions). If so, click on Upgrade button and follow the instructions.
2.3.7 Linux – OpenOCD Installation
OpenOCD²⁷ is a tool that allows to upload the firmware on the Nucleo board and to do the step-
by-step debugging. OpenOCD is a tool that originally started by Dominic Rath, and now actively
maintained by the community and several companies, including ST. We will discuss it in depth in
chapter 5, which is dedicated to the debugging. But we will install it in this chapter, because the
install procedure changes between the three different platforms (Windows, Linux and Mac OS). The
latest official release at the time of writing this book is the 0.10.
The quickest solution to install OpenOCD consists in using a pre-compiled package provided by
Liviu Ionescu. In fact, he has already done the dirty job for us. You can download the latest
development version of OpenOCD (0.10.0-5-20171110-* at the time of writing this chapter) from
the GNU MCU Eclipse official repository²⁸. Choose the .tgz package for your Linux platform (32-
or 64-bits - they are named debian32 or debian64). Extract the files in a convenient place. When
complete, you will find a folder named openocd , which in turn contains a folder named in the same
way of the .tgz package (for example, you will find a folder named 0.10.0-5-20171110-1117 ). Copy
that folder inside the inside the ∼/STM32Toolchain folder and rename it in openocd , so that the final
path is equal to ∼/STM32Toolchain/openocd .
Once again, this ensures us that we should not change Eclipse settings when a new
release of OpenOCD will be released, but we only need to replace the content of
∼/STM32Toolchain/openocd folder with the new software release.
²⁶ http://bit.ly/1RLDp3H
²⁷ http://openocd.org/
²⁸ http://bit.ly/2khxhXL
Setting-Up the Tool-Chain 77
Now we need one more step. By default, Linux does not not allow unprivileged users to access an
USB device using libusb . So, to start a connection between OpenOCD and the ST-LINK interface,
we need to run OpenOCD with root privileges. This not convenient, because we will have troubles
with the Eclipse configuration. So, we have to configure the Universal DEVice manager (aka udev )
to grant access to unprivileged users to ST-LINK interface. To do so, let us create a file named
stlink.rules inside the /etc/udev/rules.d directory and add this line inside it:
$ sudo cp ~/STM32Toolchain/openocd/contrib/99-openocd.rules /etc/udev/rules.d/
$ sudo udevadm control --reload-rules
Now we are ready to test our Nucleo board. Plug it in your PC using USB cable. After a few seconds,
type the following commands:
$ cd ~/STM32Toolchain/openocd/scripts
$ ../bin/openocd -f board/<nucleo_conf_file>.cfg
where <nucleo_conf_file>.cfg must be substituted with the config file that fits your Nucleo board,
according Table 1. For example, if your Nucleo is the Nucleo-F401RE, then the proper config file to
pass to OpenOCD is st_nucleo_f4.cfg .
Table 1: Corresponding OpenOCD board file for a given Nucleo
Nucleo P/N OpenOCD 0.10.0 board script file
NUCLEO-F446RE st_nucleo_f4.cfg
NUCLEO-F411RE st_nucleo_f4.cfg
NUCLEO-F410RB st_nucleo_f4.cfg
NUCLEO-F401RE st_nucleo_f4.cfg
NUCLEO-F334R8 stm32f334discovery.cfg
NUCLEO-F303RE st_nucleo_f3.cfg
NUCLEO-F302R8 st_nucleo_f3.cfg
NUCLEO-F103RB st_nucleo_f103rb.cfg
NUCLEO-F091RC st_nucleo_f0.cfg
NUCLEO-F072RB st_nucleo_f0.cfg
NUCLEO-F070RB st_nucleo_f0.cfg
NUCLEO-F030R8 st_nucleo_f0.cfg
NUCLEO-L476RG st_nucleo_l476rg.cfg
NUCLEO-L152RE st_nucleo_l1.cfg
NUCLEO-L073RZ st_nucleo_l073rz.cfg
NUCLEO-L053R8 stm32l0discovery.cfg
If everything went the right way, you should see these messages on the console:
Setting-Up the Tool-Chain 78
Open On-Chip Debugger 0.10.0 (2015-09-09-16:32)
Licensed under GNU GPL v2
For bug reports, read
http://openocd.org/doc/doxygen/bugs.html
Info : The selected transport took over low-level target control. The results might differ com\
pared to plain JTAG/SWD
adapter speed: 2000 kHz
adapter_nsrst_delay: 100
none separate
srst_only separate srst_nogate srst_open_drain connect_deassert_srst
Info : Unable to match requested speed 2000 kHz, using 1800 kHz
Info : clock speed 1800 kHz
Info : STLINK v2 JTAG v24 API v2 SWIM v11 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 3.245850
Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints
At the same time, the LED LD1 on the Nucleo board should start blinking GREEN and RED
alternatively.
On some GNU/Linux distributions, the UDEV definitions are not enough, or are not
effective, and when trying to access the JTAG probe, an error is issued:
libusb_open failed: LIBUSB_ERROR_ACCESS
If this happens, first try to start openocd with sudo ; if this works, for regular work you also
need to grant your user permission to use the USB. For example, on Ubuntu 15.10 you need
to issue something like:
sudo usermod -aG plugdev $USER
Then relogin or restart. If you still have problems, check your distribution documentation
and when you have a functional solution post it on the project forum.
2.3.8 Linux - ST Tools Installation
ST provides several tools that are useful for developing STM32 based applications.
STM32CubeMX is a graphical tool used to generate setup files in C programming language for
an STM32 MCU, according the hardware configuration of our board. For example, if we have the
Nucleo-F401RE,whichisbasedontheSTM32F401REMCU,andwewanttouseitsuserLED(marked
asLD2ontheboard),thenSTM32CubeMXwillautomaticallygenerateallsourcefilescontainingthe
CcoderequiredtoconfiguretheMCU(clock,peripheralports,andsoon)andtheGPIOconnectedto
theLED(portGPIO5onportAonalmostallNucleoboards).Youcandownloadthelatestversionof
STM32CubeMX (currently, the 4.23) from the official ST page²⁹ (the download link is at the bottom
²⁹ http://bit.ly/1RLCa4G
Setting-Up the Tool-Chain 79
of the page). The file is a ZIP archive. Once extracted, you will find a file named SetupSTM32CubeMX-
4.23.0.linux . This file is the setup program to install the tool. The setup program needs root
privileges if you want to install STM32CubeMX system wide (if this case, open the file at command
prompt using the sudo ), otherwise you can simply place it inside the ∼/STMToolchain folder in your
home folder. We are going to install it in our home directory.
So, double click on the SetupSTM32CubeMX-4.23.0.linux icon. After a while, the setup wizard will
appear, as shown in Figure 22.
Figure 22: STM32CubeMX install wizard
Follow the setup instructions. By default, installing the program in ∼/STM32Toolchain/STM32CubeMX
folder. Once setup is completed, go inside the ∼/STM32Toolchain/STM32CubeMX folder and double
click on the STM32CubeMX icon. After a while, STM32CubeMX will appear on the screen, as shown
in Figure 23.
Setting-Up the Tool-Chain 80
Figure 23: STM32CubeMX interface
Another important tool is the STM32CubeProgrammer³⁰. It is a software that uploads the firmware
on the MCU using the ST-LINK interface of our Nucleo, or a dedicated ST-LINK programmer. We
willuseitinthenextchapter.YoucandownloadSTM32CubeProgrammerfromtheofficialSTpage³¹
(the download link is at the bottom of the page in the GET SOFTWARE section), and follow the
installation instructions.
2.4 Mac - Installing the Tool-Chain
The whole installation procedure will assume these requirements:
• A Mac running Mac OSX 10.11 (aka El Capitan) or higher with sufficient hardware resources
(I suggest to have at least 4Gb of RAM and 5Gb of free space on the Hard Disk).
• YouhavealreadyinstalledtheXcodereleasethatfitsyourMacOSXversion(youcandownload
itusingtheAppStore)anditscorrespondingcommandlinetools.Youwillfindseveraltutorials
³⁰ http://bit.ly/2CK4aFa
³¹ http://bit.ly/2CK4aFa
Setting-Up the Tool-Chain 81
on the web describing how to install Xcode and command line tools if you are completely new
to this topic.
• You have already installed MacPorts³² and upgraded it issuing the command sudo port
selfupdate at terminal command line. You are free to use another package manager for Mac
OSX, but arrange following instructions accordingly.
• Java SE 8 Update 121 or later. If you do not have this version, you can download it for free
from official Java SE support page³³.
Choosing a Tool-Chain Folder
One interesting feature of Eclipse is that it is not required to be installed in a specific path
on the Hard Disk. This allows the user to decide where to put the whole tool-chain and, if
desired, to move it in another place or to copy it on another machine (this is really useful if
you have several Mac to maintain).
In this book we will assume that the whole tool-chain is installed inside the
∼/STM32Toolchain folder on the Hard Disk (that is, a STM32Toolchain directory inside your
Home folder). You are free to place it elsewhere, but rearrange paths in the instructions
accordingly.
2.4.1 Mac - Eclipse Installation
The first step is to install the Eclipse IDE. As said before, we are interested in the Eclipse version for
C/C++developers.Thelatestversionattimeofrevisingthischapter(August2018)isPhoton(Eclipse
v4.8). However, it is strongly suggested to use the previous release, that is Oxygen.3a (Eclipse
v4.7.3a), since the newest one is still not supported by the GNU MCU Eclipse plug-ins suite
and by several other tools used in this book. It can be downloaded from the official download
page³⁴ as shown in Figure 25³⁵.
³² https://www.macports.org/
³³ http://bit.ly/2k5ppYR
³⁴ https://www.eclipse.org/downloads/packages/release/oxygen/3a/
³⁵ Some screen captures may appear different from the ones reported in this book. This happens because the Eclipse IDE is updated
frequently. Don’t worry about that: the installation instructions should work in any case.
Setting-Up the Tool-Chain 82
Figure 25: Eclipse download page
The Eclipse IDE is distributed as a DMG image. Mount the image and drag the Eclipse.app file
inside the folder ∼/STM32Toolchain/eclipse .
Now we can execute for the first time the Eclipse IDE. Go inside the ∼/STM32Toolchain/eclipse
folderandrunthe Eclipse.app file.Afterawhile,Eclipsewillaskyouforthepreferredfolderwhere
all Eclipse projects are stored (this is called workspace), as shown in Figure 26.
Setting-Up the Tool-Chain 83
Figure 26: Eclipse workspace setting
You are free to choose the folder you prefer, or leave the suggested one. In this book we will assume
that the Eclipse workspace is located inside the ∼/STM32Toolchain/projects folder. Arrange the
instructions accordingly if you choose another location.
2.4.2 Mac - Eclipse Plug-Ins Installation
Once Eclipse is started, we can proceed to install some relevant plug-ins.
What is a Plug-In?
Aplug-inisanexternalsoftwaremodulethatextendsEclipsefunctionalities.Aplug-inmust
adhere to a standard API defined by Eclipse developers. In this way, it is possible for third
party developers to add features to the IDE without changing the main source code. We will
install several plug-ins in this book to adapt Eclipse to our needs.
Thefirstplug-inweneedtoinstallistheC/C++DevelopmentToolsSDK,alsoknownasEclipseCDT.
CDT provides a fully functional C and C++ Integrated Development Environment based on Eclipse
platform. Features include: support for project creation and managed build for various tool-chains,
standard make build, source navigation, various source knowledge tools, such as type hierarchy, call
graph, include browser, macro definition browser, code editor with syntax highlighting, folding and
hyperlinknavigation,sourcecoderefactoringandcodegeneration,visualdebuggingtools,including
memory, registers, and disassembly viewers.
To install CDT we have to follow this procedure. Go to Help->Install new software….
Setting-Up the Tool-Chain 84
Figure 26: Eclipse plug-in repository selection
In the plug-ins install window, we need to enable other plug-in repositories clicking on Manage…
button.InthePreferenceswindow,selectthe“Install/Update->AvailableSoftwareSites”entryonthe
left and then check “CDT” entry as shown in Figure 26. Click on the OK button.
Now, from “work with” drop-down menu choose “CDT” repository, as shown in Figure 27, and
then select “CDT Main Features->C/C++ Development Tools” and “CDT Optional Features->C/C++
GDB Hardware Debugging” entries, as shown in Figure 28. Click on “Next” button and follow the
instructions to install the plug-in. At the end of installation process (the installation takes a while
depending your Internet connection speed), restart Eclipse when requested.
Setting-Up the Tool-Chain 85
Figure 27: CDT repository selection
Setting-Up the Tool-Chain 86
Figure 28: CDT plug-in selection
Setting-Up the Tool-Chain 87
NowwehavetoinstalltheGNUMCUplug-insforEclipse³⁶.Theseplug-insaddarichsetoffeatures
toEclipseCDTtointerfacetheGCCARMtool-chain.Moreover,theyprovidespecificfunctionalities
for the STM32 platform. Plug-ins are developed and maintained by Liviu Ionescu, who did a really
excellentworkinprovidingsupportfortheGCCARMtool-chain.Withouttheseplug-insitisalmost
impossible to develop and run code with Eclipse for the STM32 platform.
To install GCC ARM plug-ins go to Help->Install new software…. In the Install window, click the
Add… button and fill the fields in the following way (see Figure 29):
Name: GNU MCU Eclipse Plug-ins
Location: http://gnu-mcu-eclipse.netlify.com/v4-neon-updates
Click on the OK button. Now, from “work with” drop-down menu choose “GNU MCU Eclipse Plug-
ins” repository. A list of installable packages appears. Check the packages to install according to
Figure 30.
Figure 29: GNU MCU plug-ins installation
³⁶ https://gnu-mcu-eclipse.github.io/
Setting-Up the Tool-Chain 88
Figure 30: GNU MCU plug-ins selection
Click on “Next >” button and follow the instructions to install the plug-ins. At the end of installation
process, restart Eclipse when requested.
Read Carefully
If you run in troubles during the plug-ins installation (handshake error, provisioning error
or something like that), please refer to the troubleshooting section.
Eclipse is now essentially configured to start developing STM32 applications. Now we need the
cross-compiler suite to generate the firmware for the STM32 family.
2.4.3 Mac - GCC ARM Embedded Installation
The next step in tool-chain configuration is installing the GCC suite for ARM Cortex-M and
Cortex-R microcontrollers. This is a set of tools (macro preprocessor, compiler, assembler, linker
and debugger) designed to cross-compile the code we will create for the STM32 platform.
Setting-Up the Tool-Chain 89
The latest release of ARM GCC can be downloaded from ARM Developer³⁷. At the time of writing
this chapter, the latest available version is the 6.0. The Mac tarball can be downloaded from the
download section³⁸.
Once download is complete, extract the .tar.bz2 package inside the ∼/STM32Toolchain
Theextractedfolder,bydefault,isnamed gcc-arm-none-eabi-6-2017-q2-update .Thisisnot
convenient, because when GCC is updated to a newer version we need to change settings
for each Eclipse project we have made. So, rename it to simply gcc-arm .
2.4.4 Mac - Nucleo Drivers Installation
Warning
Read this paragraph carefully. Do not skip this step!
On Mac, we do not need to install Nucleo drivers from ST, but we need to install libusb-1.0 with
the following command:
$ sudo port install libtool libusb [libusb-compat] [libftdi1]
2.4.4.1 Mac – ST-LINK Firmware Upgrade
Warning
Read this paragraph carefully. Do not skip this step!
I have bought several Nucleo boards and I saw that all boards come with an old ST-LINK firmware.
In order to use the Nucleo with OpenOCD, the firmware must be updated at least to the 2.29.18
version.
Once the ST-LINK drivers are installed, we can download the latest ST-LINK drivers from ST
website³⁹. The firmware is distributed as ZIP file. Extract it in a convenient place. Connect your
Nucleo board using a USB cable and go inside the AllPlatforms subfolder and execute the file
STLinkUpgrade.jar . Click on Open in update mode button.
³⁷ https://developer.arm.com/open-source/gnu-toolchain/gnu-rm
³⁸ https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads
³⁹ http://bit.ly/1RLDp3H
Setting-Up the Tool-Chain 90
Figure 30: The ST-LINK Upgrade program
Afterawhile,ST-LINKUpgradewillshowifyourNucleofirmwareneedstobeupdated(pointingout
adifferentversion,asshowninFigure30).Ifso,clickonUpgrade buttonandfollowtheinstructions.
2.4.5 Mac – OpenOCD Installation
OpenOCD⁴⁰ is a tool that allows to upload the firmware on the Nucleo board and to do the step-
by-step debugging. OpenOCD is a tool that originally started by Dominic Rath, and now actively
maintained by the community and several companies, including ST. We will discuss it in depth in
chapter 5, which is dedicated to the debugging. But we will install it in this chapter, because the
install procedure changes between the three different platforms (Windows, Linux and Mac OS). The
latest official release at the time of writing this book is the 0.10.
The quickest solution to install OpenOCD consists in using a pre-compiled package provided by
Liviu Ionescu. In fact, he has already done the dirty job for us. You can download the latest
development version of OpenOCD (0.10.0-5-20171110-* at the time of writing this chapter) from the
GNU MCU Eclipse official repository⁴¹. Choose the file ending with .pkg and launch the installer
when downloaded. Follow the installation instructions. When complete, the installer will place
all files inside the /Applications/GNU MCU Eclipse/OpenOCD folder. You will find in turn a folder
named in the same way of the .pkg package (for example, you will find a folder named 0.10.0-5-
20171110-1117 ). Copy that folder inside the inside the ∼/STM32Toolchain folder and rename it in
openocd , so that the final path is equal to ∼/STM32Toolchain/openocd .
Once again, this ensures us that we will not change Eclipse settings when a new release of
OpenOCDwillbereleased,butwewillonlyneedtoreplacethe ∼/STM32Toolchain/openocd
with the new software release.
Ok. Weareready to test our Nucleo board. Plug it in yourMac using USB cable.After a fewseconds,
type the following commands:
⁴⁰ http://openocd.org/
⁴¹ http://bit.ly/2khxhXL
Setting-Up the Tool-Chain 91
$ cd ~/STM32Toolchain/openocd/scripts
$ ../bin/openocd -f board/<nucleo_conf_file>.cfg
where <nucleo_conf_file>.cfg must be substituted with the config file that fits your Nucleo board,
according Table 1. For example, if your Nucleo is the Nucleo-F401RE, then the proper config file to
pass to OpenOCD is st_nucleo_f4.cfg .
Table 1: Corresponding OpenOCD board file for a given Nucleo
Nucleo P/N OpenOCD 0.10.0 board script file
NUCLEO-F446RE st_nucleo_f4.cfg
NUCLEO-F411RE st_nucleo_f4.cfg
NUCLEO-F410RB st_nucleo_f4.cfg
NUCLEO-F401RE st_nucleo_f4.cfg
NUCLEO-F334R8 stm32f334discovery.cfg
NUCLEO-F303RE st_nucleo_f3.cfg
NUCLEO-F302R8 st_nucleo_f3.cfg
NUCLEO-F103RB st_nucleo_f103rb.cfg
NUCLEO-F091RC st_nucleo_f0.cfg
NUCLEO-F072RB st_nucleo_f0.cfg
NUCLEO-F070RB st_nucleo_f0.cfg
NUCLEO-F030R8 st_nucleo_f0.cfg
NUCLEO-L476RG st_nucleo_l476rg.cfg
NUCLEO-L152RE st_nucleo_l1.cfg
NUCLEO-L073RZ st_nucleo_l073rz.cfg
NUCLEO-L053R8 stm32l0discovery.cfg
If everything went the right way, you should see these messages on the console:
Open On-Chip Debugger 0.10.0 (2015-09-09-16:32)
Licensed under GNU GPL v2
For bug reports, read
http://openocd.org/doc/doxygen/bugs.html
Info : The selected transport took over low-level target control. The results might differ com\
pared to plain JTAG/SWD
adapter speed: 2000 kHz
adapter_nsrst_delay: 100
none separate
srst_only separate srst_nogate srst_open_drain connect_deassert_srst
Info : Unable to match requested speed 2000 kHz, using 1800 kHz
Info : clock speed 1800 kHz
Info : STLINK v2 JTAG v24 API v2 SWIM v11 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 3.245850
Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints
Setting-Up the Tool-Chain 92
At the same time, the LED LD1 on the Nucleo board should start blinking GREEN and RED
alternatively.
2.4.6 Mac - ST Tools Installation
ST provides several tools that are useful for developing STM32 based applications.
STM32CubeMX is a graphical tool used to generate setup files in C programming language for
an STM32 MCU, according the hardware configuration of our board. For example, if we have
the Nucleo-F401RE, which is based on the STM32F401RE MCU, and we want to use its user LED
(marked as LD2 on the board), then STM32CubeMX will automatically generate all source files
containing the C code required to configure the MCU (clock, peripheral ports, and so on) and the
GPIO connected to the LED (port GPIO 5 on port A on almost all Nucleo boards). You can download
the latest version of STM32CubeMX (currently, the 4.23) from the official ST page⁴² (the download
link is at the bottom of the page). The file is a ZIP archive. Once extracted, you will find a file
named SetupSTM32CubeMX-4_14_0_macos . This file is the setup program to install the tool. The setup
program may need root privileges if you want to install STM32CubeMX system wide. So, double
click on the SetupSTM32CubeMX-4_14_0_macos icon. After a while, the setup wizard will appear, as
shown in Figure 30.
Figure 30: STM32CubeMX install wizard
Follow the setup instructions. By default, the program is installed in /Applications/STMicroelec-
tronics . Once setup is completed, open the Finder and go inside the /Applications/STMicroelec-
⁴² http://bit.ly/1RLCa4G
Setting-Up the Tool-Chain 93
tronics folder and double click on the STM32CubeMX.app icon. After a while, STM32CubeMX will
appear on the screen, as shown in Figure 31.
Figure 31: STM32CubeMX interface
Another important tool is the STM32CubeProgrammer⁴³. It is a software that uploads the firmware
on the MCU using the ST-LINK interface of our Nucleo, or a dedicated ST-LINK programmer. We
willuseitinthenextchapter.YoucandownloadSTM32CubeProgrammerfromtheofficialSTpage⁴⁴
(the download link is at the bottom of the page in the GET SOFTWARE section), and follow the
installation instructions.
Congratulation. The tool-chain is now complete, and you can jump to the next chapter.
⁴³ http://bit.ly/2CK4aFa
⁴⁴ http://bit.ly/2CK4aFa
3. Hello, Nucleo!
There is no programming book that does not begin with the classic “Hello world!” program. And
this book will follow the tradition. In the previous chapter we have configured the development
environment needed to program STM32 based boards. So, we are now ready to start coding.
In this chapter we will create a really basic program: a blinking LED. We will use the GNU MCU
Eclipse plug-in to create a complete application in a few steps without dealing, in this phase, with
aspectsrelatedtotheSTHardwareAbstractionLayer (HAL).Iamawarethatnotalldetailspresented
in this chapter will be clear from the beginning, especially if you are totally new to embedded
programming.
However, this first example will allow us to become familiar with the development environment.
Following chapters, especially the next one, will clarify a lot of obscure things. So I suggest you to
be patient and try to take the best from the following paragraphs.
A Note on GNU MCU Eclipse Plug-ins
Experienced programmers might observe that these plug-ins are not strictly necessary to
generate code for the STM32 platform. It is perfectly possible to start importing the HAL in
an empty C/C++ project and to configure the tool-chain accordingly. Moreover, as we will
see in the next chapter, it is better to directly use the code from the latest HAL release and
the one automatically generated by STM32CubeMX tool. However, the GNU MCU plugin
brings several features that simplify the project management. Moreover, I think that for
newbies it is recommended to start with an automatic-generated project to avoid a lot of
confusion. When writing code for the STM32 platform, we need to deal with a lot of tools
andlibraries.Someofthemaremandatory,whileothersmayleadtoconfusion.Soitisbestto
start gradually and dive inside the whole stack. Once you get familiar with the development
environment, it will be really easy to adapt it to your needs.
If you are totally new to Eclipse IDE, the next paragraph will briefly explain its main functionalities.
3.1 Get in Touch With the Eclipse IDE
When you start Eclipse, you might be a bit puzzled by its interface. Figure 1¹ shows how Eclipse
appears when started for the first time.
¹ Starting from this chapter, all screen captures, unless differently required, are based on Mac OS, because it is the OS the author uses to
develop STM32 applications (and to write this book). However, they also apply to other Operating Systems.
Hello, Nucleo! 95
Figure 1: The Eclipse interface once started for the first time
Eclipse is a multi-view IDE, organized so that all the functionalities are displayed in one window,
but the user is free to arrange the interface at its needs. When Eclipse starts, a welcome screen is
presented. The content of that Welcome Tab is called view.
Figure 2: How to close the Welcome view by clicking on the X.
To close the Welcome view, click on the cross icon, as shown in Figure 2. Once the Welcome view
goes away, the C/C++ perspective appears, as shown in Figure 3.
Hello, Nucleo! 96
Figure 3: The C/C++ perspective view in eclipse (with a main.c file loaded later)
In Eclipse a perspective is a way to arrange views in a manner that is related to the functionalities
of the perspective. The C/C++ perspective is dedicated to coding, and it presents all aspects related
to the editing of the source code and its compiling. It is divided into four views.
The view on the left, named Project Explorer, shows all projects inside the workspace.
If you recall from the previous chapter, the first time we started Eclipse we had to choose
the workspace directory. The workspace is the place where a group of projects are stored.
Please note that we say a group of projects and not all the projects. This means that we
can have several workspaces (that is, directories) where different groups of projects are
stored. However, a workspace also contains IDE configurations, and we can have different
configurations for every workspace.
The centered view, that is the larger one, is the C/C++ editor. Each source file is shown as a tab, and
it is possible to have many tabs opened at the same time.
The view in the bottom of Eclipse window is dedicated to several activities related to coding and
compiling, and it is subdivided into tabs. For example, the Console tab shows the output from the
compiler; the Problems tab organizes all messages coming from the compiler in a convenient way
to inspect them; the Search tab contains the search results.
The view on the right contains several other tabs. For example the Outline tab shows the content of
each source file (functions, variables, and so on), allowing quickly navigation inside the file content.
Hello, Nucleo! 97
There are other views available (and many other ones that are provided by custom plug-ins). Users
can see them by going inside the Window->Show View->Other… menu.
Sometimes it happens that a view is “minimized” and it seems to disappear from the IDE.
When you are new to Eclipse, this might lead to frustration trying to understand where
it went. For example, looking at Figure 4 it seems that the Project Explorer view has
disappeared, but it is simply minimized and you can restore it clicking on the icon circled in
red. However, sometimes the view has really been closed. This happens when there is only
one tab active in that view and we close it. In this case you can enable the view again going
in the Window->Show View->Other… menu.
Figure 4: Project Explorer view minimized
To switch between different perspectives you can use the specific toolbar available in the top-right
side of Eclipse (see Figure 5)
Hello, Nucleo! 98
Figure 5: Perspective switcher toolbar
By default, the other available perspective is Debug, which we will see in more depth later. You can
enable other perspectives by going to Window->Perspective->Open Perspective->Other… menu.
StartingfromEclipse4.6(akaNeon),theperspectiveswitchertoolbarnolongershows
the perspective name by default, but only the icon associated to the perspective. This
tends to confuse novice users. You can show the perspective name near its icon by
clicking with the right button of the mouse on the toolbar and selecting the Show
Text entry, as shown below.
Figure 6: How to enable the name of a perspective in the perspective switcher toolbar
As we go forward with the topics of this book, we will have a chance to see other features of Eclipse.
3.2 Create a Project
Let us create our first project. We will create a simple application that makes the Nucleo LD2 LED
(the green one) blink.
Go to File->New->C Project. Eclipse shows a wizard that allows us to create our test project (see
Figure 7).
Hello, Nucleo! 99
Figure 7: Project wizard - STEP 1
In the Project name field write hello-nucleo (your are totally free to choose the project name
you like). The important part, indeed, is the Project type section. Here we have to choose the
STM32 family of our Nucleo board. For example, if we have a NUCLEO-F401RE we have to choose
STM32F4xx C/C++ Project.
Unfortunately, Liviu Ionescu still has not implemented project templates for the
STM32L0/1/4 families. Moreover, project templates for some Nucleo boards are missed. If
your Nucleo is based on one of these series, you have to jump to the next chapter, where we
will see a more general way to generate projects for the STM32 platform. However, it could
be that by the time you read this chapter, the plug-in has been updated with new templates.
Now click on the Next button. In this step of the wizard it is really important to select the right
size of RAM and flash memory (if those fields do not match the quantity of RAM and flash of the
MCU equipping your Nucleo, it will be impossible to start the example application)². Use Table 1 to
choose the correct values for your Nucleo board³.
² Owners of STM32F4 and STM32F7 development boards will not find the entry to specify the RAM size. Do not complain about this, since
the project wizard is designed to properly configure the right amount of RAM if you choose the right Chip family type.
³ In case you are using a different development board (e.g. a Discovery kit), check on the ST web site for right values of RAM and flash.
Hello, Nucleo! 100
Table 1: RAM and flash size to select according the given Nucleo
So, fill the fields of second step in the following way⁴ (see Figure 8 for reference):
Chip Family: Select the exact MCU equipping your Nucleo (see Table 1).
Flash size: pick the right value from Table 1.
RAM size: pick the right value from Table 1.
External clock(Hz): it is ok to leave this field as is.
Content: Blinky (blink a LED).
Use system calls: Freestanding (no POSIX system calls).
Trace output: None (no trace output).
Check some warnings: Checked.
Check most warnings: Unchecked.
Enable -Werror: Unchecked.
Use -Og on debug: Checked.
Use newlib nano: Checked.
Exclude unused: Checked.
Use link optimizations: Unchecked.
Those of you having a STMF3 Nucleo, will find an additional field in the wizard step. It is named
CCM RAM Size (KB), and it is related to the Core Coupled Memory (CCM), a special internal and
fast memory that we will study in a following chapter. If you have a Nucleo-F334 or a Nucleo-F303
board, fill the field with the value from Table 1. For other STM32F3 based boards place a zero in
that field.
⁴ Please, take note that, depending the actual STM32 family of your development board, some of those fields may be absent in the second
step. Don’t care about this, because it means that the project generator knows how to fill them.
Hello, Nucleo! 101
Figure 8: Project wizard - STEP 2
Now click on the Next button. In the next two wizard steps, leave all parameters as default.
Finally, in the last step you have to select the GCC tool-chain path. In the previous chapter,
we have installed GCC inside the ∼/STM32Toolchain/gcc-arm folder (in Windows the folder was
C:\STM32Toolchain\gcc-arm ).So,selectthatfolderasshowninFigure9(eithertypingthepathname
or using the Browse button), and ensure that theToolchain namefield containsGNU Tools for ARM
Embedded Processors (arm-none-eabi-gcc), otherwise select it from the drop-down menu. Click on
the Finish button.
Hello, Nucleo! 102
Figure 9: Project wizard - STEP 5
Ourtestprojectisalmostcomplete.WeonlyneedtomodifyonethingtomakeitworkontheNucleo.
However, before we complete the example, it is better to take a look at what has been generated by
the GNU MCU plug-in.
Figure 10 shows what appears in the Eclipse IDE after the project has been generated. The Project
Explorer view shows the project structure. This is the content of the first-level folders (going from
top to bottom):
Includes: this folder shows all folders that are part of the GCC Include Folders⁵.
src:thisEclipsefoldercontainsthe .c files⁶thatmakeupourapplication.Oneofthesefilesis main.c ,
which contains the int main(int argc, char* argv[]) routine.
system: this Eclipse folder contains header and source files of many relevant libraries (like, among
the other, the ST HAL and the CMSIS package). We will see them more in depth in the next chapter.
include: this folder contains the header files of our main application.
ldscripts:thisfoldercontainssomerelevantfilesthatmakeourapplicationworkontheMCU.These
are LD (the GNU Link eDitor) script files, and we will study them in depth in a following chapter.
⁵ Every C/C++ compiler needs to be aware of where to look for include files (files ending with .h). These folders are called include folders
and their path must be specified to GCC using the -I parameter. However, as we will see later, Eclipse is able to do this for us automatically.
⁶ The exact type and amount of files in this folder depends on the STM32 family. Do not worry if you see additional files than the ones
shown in Figure 10, and focus your attention exclusively on the main.c file.
Hello, Nucleo! 103
Figure 10: The project content after its generation
As said before, we need to modify one more thing to make the example project work on our Nucleo
board. The GNU MCU plugin generates an example project that fits the Discovery hardware layout.
This means that the LED is routed to a different MCU I/O pin. We need to modify this.
How can we know to which pin the LED is connected? STprovides schematics⁷ of the Nucleo board.
Schematics are made using the Altium Designer CAD, a really expensive piece of software used in
the professional world. However, luckily for us, ST provides a convenient PDF with schematics.
Looking at page 4, we can see that the LED is connected to the PA5 pin ⁸, as shown in Figure 11.
⁷ http://bit.ly/1FAVXSw
⁸ Except for the Nucleo-F302RB, where LD2 is connected to PB13 port. More about this next.
Hello, Nucleo! 104
Figure 11: LD2 connection to PA5
PA5 is shorthand for PIN5 of GPIOA port, which is the standard way to indicate a GPIO in the
STM32 world.
We can now proceed to modify the source code. Open the Include/BlinkLed.h and go to line 19.
Here we find the macro definition for the GPIO associated to the LED. We need to change the code
in the following way:
Filename: include/BlinkLed.h
30 #define BLINK_PORT_NUMBER (0)
31 #define BLINK_PIN_NUMBER (5)
BLINK_PORT_NUMBER defines the GPIO port (in our case GPIOA=0 ), and BLINK_PIN_NUMBER the pin
number.
Nucleo-F302R8 is the only Nucleo board that has a different hardware configuration regarding the
pin used for LED LD2, because it is connected to pin PB13, as you can see in schematics. This means
that the right pin configuration is:
30 #define BLINK_PORT_NUMBER (1)
31 #define BLINK_PIN_NUMBER (13)
We can now compile the project. Go to menu Project->Build Project. After a while, we should see
something similar to this in the output console[^ch3-flash-image-size].
Hello, Nucleo! 105
Invoking: Cross ARM GNU Create Flash Image
arm-none-eabi-objcopy -O ihex "hello-nucleo.elf" "hello-nucleo.hex"
Finished building: hello-nucleo.hex
Invoking: Cross ARM GNU Print Size
arm-none-eabi-size --format=berkeley "hello-nucleo.elf"
text data bss dec hex filename
5697 176 416 6289 1891 hello-nucleo.elf
Finished building: hello-nucleo.siz
09:52:01 Build Finished (took 6s.704ms)
3.3 Connecting the Nucleo to the PC
Once we have compiled our test project, you can connect the Nucleo board to your computer using
an USB cable connected to micro-USB port (calledVCP in Figure 12). After few seconds, you should
see at least two LED turning ON.
The first one is the LD1 LED, which in Figure 12 is called ST-LINK LED. It is a red/green LED and
it is used to signal the ST-LINK activity: once the board is connected to the computer, that LED is
green; during a debug session or while uploading the firmware on the MCU it blinks green and red
alternatively.
Another LED that turns ON when the board is connected to the computer is the LED LD3, which is
calledPOWERLEDinFigure12.ItisaredLEDthatturnsONwhentheUSBportendsenumeration,
that is the ST-LINK interface is properly recognized by the computer OS as a USB peripheral. The
Hello, Nucleo! 106
target MCU on the board is powered only when that LED is ON (this means that the ST-LINK
interface also manages the powering of the target MCU).
Finally, if you have not still flashed your board with a custom firmware, you will see that the LD2
LED, a green LED named USER LED in Figure 12, also blinks: this happens because ST preloads
the board with a firmware that makes the LD2 LED blinking. To change the blinking frequency you
can press the USER BUTTON (the blue one).
Now we are going to replace the on-board firmware with the one made by us before.
3.4 Flashing the Nucleo using STM32CubeProgrammer
ST has recently introduced a new and really practical tool to flash firmware on the target board:
STM32CubeProgrammer. Its aim is to replace the historical ST-LINK Utility tool and the good news
isthatitisfinallymulti-platform.Thetoolisnotstillperfectlystable,butIamsurethatnextreleases
will fix its early bugs. Figure 13 shows the STM32CubeProgrammer’s main interface.
Figure 13: The STM32CubeProgrammer interface once connected to the board
We installed STM32CubeProgrammer in Chapter 2 and now we are going to use it. Launch the
program and connect your Nucleo to the PC using the USB cable. Once STM32CubeProgrammer
has identified the board its serial number will appear in the Serial number combo box, as shown in
Figure A.
Hello, Nucleo! 107
Figure 14: The ST-LINK interface serial number as shown by STM32CubeProgrammer tool
Read Carefully
If the label “Old ST-LINK Firmware” appears instead of the ST-LINK interface serial number,
then you need to update the ST-LINK firmware to the latest version. Click on theFirmware
upgrade button at the bottom of the ST-LINK Configuration pane and following the
instruction. Alternatively, follow the upgrade instructions reported in Chapter 2.
Once the ST-LINK board has been identified, click the Connect button. After a while you will see
the content of flash memory, as shown in Figure 13 (ensure that all connection parameters are the
same of the ones reported in Figure 13).
Ok, let us upload the example firmware to the board. Click on the Erase & programming icon
(the second green icon on the left). Then, click on the Browse button in the File programming
section and select the file C:\STM32Toolchain\projects\hello-nucleo\Debug\hello-nucleo.hex
inWindowsor ∼/STM32Toolchain/projects/hello-nucleo/Debug/hello-nucleo.hex inLinuxand
Mac OS. Check the Verify programming and Run after programming flags and click on Start
Programming button to start flashing. At the end of flashing procedure your Nucleo green LED
will start blinking. Congratulations: welcome to the STM32 world ;-)
3.5 Understanding the Generated Code
Now that we brought a cold piece of hardware to life, we can give a first look at the code generated
by the GNU MCU plugin. Opening main.c file we can see the content of main() function, the entry
point⁹ of our application.
⁹ Experienced STM32 programmers know that it is improper to say that the main() function is the entry point of an STM32 application.
The execution of the firmware begins much earlier, with the calling of some important setup routines that create the execution environment
for the firmware. However, from the application point of view, its start is inside the main() function. A following chapter will show in detail
the bootstrap process of an STM32 microcontroller.
Hello, Nucleo! 108
Filename: src/main.c
45 // Keep the LED on for 2/3 of a second.
46 #define BLINK_ON_TICKS (TIMER_FREQUENCY_HZ * 3 / 4)
47 #define BLINK_OFF_TICKS (TIMER_FREQUENCY_HZ - BLINK_ON_TICKS)
48
49 int main(int argc, char* argv[])
50 {
51 trace_puts("Hello ARM World!");
52 trace_printf("System clock: %u Hz\n", SystemCoreClock);
53
54 timer_start();
55
56 blink_led_init();
57
58 uint32_t seconds = 0;
59
60 // Infinite loop
61 while (1)
62 {
63 blink_led_on();
64 timer_sleep(seconds == 0 ? TIMER_FREQUENCY_HZ : BLINK_ON_TICKS);
65
66 blink_led_off();
67 timer_sleep(BLINK_OFF_TICKS);
68
69 ++seconds;
70
71 trace_printf("Second %u\n", seconds);
72 }
73 }
Instructions at line 51, 52 and 71 are related to debugging¹⁰ and we will see them in depth in Chapter
5. Function timer_start(); initializes the SysTick timer so that it fires an interrupt every 1ms. This
is used to compute delays, and we will study how it works in Chapter 7. The function blink_led_-
init(); initializes the GPIO pin PA5 to be an output GPIO. Finally, the infinite loop turns ON and
OFF the LED LD2, keeping it ON for 2/3 of second and OFF for 1/3 of second.
The only way to learn something in this field is to get your hands dirty writing code and
making a lot of mistakes. So, if you are new to the STM32 platform, it is a good idea to start
looking inside the code generated by the GNU MCU plugin, and trying to modify it.
For example, a good exercise is to modify the code so that the LED starts blinking when the
user button (the blue one) is pressed. A hint? The user button is connected to PC13 pin.
¹⁰ For the sake of completeness, they are tracing functions that use ARM semihosting, a feature allowing to execute code in the host PC
invoking it from the microcontroller - a sort of remote procedure call.
Hello, Nucleo! 109
Eclipse intermezzo
Eclipse allows us to easily navigate inside the source code, without jumping between source files
manually looking for where a function is defined. For example, suppose that we want to see how
the function timer_start() is coded. To go to its definition, highlight the function call, click with the
right mouse button and select Open declaration entry, as shown in the following image.
Sometimes, it happens that Eclipse makes a mess of its index files, and it is impossible to navigate
inside the source code. To address this issue, you can force Eclipse to rebuild its index going to
Project->C/C++ Index->Rebuild menu.
Another interesting Eclipse feature is the ability to expand complex macros. For example, click with
right mouse button on the BLINK_OFF_TICKS macro at line 71, and choose the entry Explore macro
expansion. The following contextual window will appear.
4. STM32CubeMX Tool
STM32CubeMX¹ is the Swiss army knife of every STM32 developer, and it is a fundamental tool
especially if you are new to the STM32 platform. It is a quite complex piece of software distributed
freely by ST, and it is part of the STCube initiative², which aims to provide to developers with a
complete set of tools and libraries to speed up the development process.
Although there is a well-established group of people that still develops embedded software in pure
assembly code³, time is the most expensive thing during project development nowadays, and it is
really important to receive as much help as possible for a quite complex hardware platform like the
STM32.
In this chapter we will see how this tool from ST works, and how to build Eclipse projects from
scratchusingthecodegeneratedbyit.ThiswillmakeGNUMCUpluginalesscriticalcomponentfor
projectgeneration,allowingustocreatebettercodeandreadytobeintegratedwiththeSTM32Cube
HAL. However, this chapter is not a substitute for the official ST documentation for CubeMX tool⁴,
a document made of more than 170 pages that explains in depth all its functionalities.
4.1 Introduction to CubeMX Tool
CubeMX is the tool used to configure the microcontroller chosen for our project. It is used both to
choose the right hardware connections and to generate the code necessary to configure the ST HAL.
CubeMX is a MCU-centric application. This means that all activities performed by the tool are based
on:
• The family of the STM32 MCU (F0, F1, and so on).
• The type of package chosen for our device (LQFP48, BGA144, and so on).
• The hardware peripherals we need in our project (USART, SPI, etc.).
– How chosen peripherals are mapped to microcontroller pins.
• MCU general configurations (like clock, power management, NVIC controller, and so on)
In addition to features related to the hardware, CubeMX is also able to deal with the following
software aspects:
¹ STM32CubeMX name will be simplified in CubeMX in the rest of the book.
² http://bit.ly/1YKvl85
³ Probably, one day someone will explain them that, except for really rare and specific cases, a modern compiler can generate better
assembly code from C than could be written directly in assembly by hand. However, we have to say that these habits are limited to ultra
low-cost 8-bit MCUs like PIC12 and similar.
⁴ http://bit.ly/1O50wrp
STM32CubeMX Tool 111
• Management of the ST HAL for the chosen MCU family (CubeF0, CubeF1, and so on).
• Additional software library functionalities we need in our project (FatFs library, FreeRTOS,
etc.).
• The development environment we will use to build the firmware (IAR, TrueSTUDIO, and so
on).
CubeMX aims to be a complete project management tool. However, it has some limitations that
restrict its usage to the early stages of board and firmware development (more about this later).
Figure 1: The CubeMX tool
We have already installed CubeMX in Chapter 2. If you still have not done it, it is strongly suggested
to refer to that chapter.
Once CubeMX is launched, a nice welcome screen is presented (see Figure 1). Clicking on New
project will bring up the MCU and board selector dialog, as shown Figure 2.
STM32CubeMX Tool 112
Figure 2: CubeMX MCU selection tool
The dialog is a tab-based window, with two main tabs: MCU Selector and Board Selector.
The first tab allows to choose a microcontroller from the whole STM32 portfolio. Several filters
allow to identify the right microcontroller for the user application. Using the Serie filters, we can
show just those MCUs belonging to selected series. TheLine filters allow to further select the MCUs
belonging to a sub-family (Value line, etc.). Packages filters allow to select all MCUs having the
desired package. Filters from the Advanced Choice section allow to limit the MCUs according
budgetary price, number of I/Os, dimensions of FLASH, SRAM and EEPROM memories. Finally,
filters from the Peripheral Choice section allow to select available MCUs according to wanted
peripherals.
STM32CubeMX Tool 113
Figure 3: CubeMX board selection tool
The Board Selector tab allows to filter among all the official ST development boards (see Figure
3). There are three kinds of development boards to choose from: Nucleo, Discovery and EvalBoard,
which are the most complete (and expensive) development boards to experiment with an STM32
MCU. We are, obviously, interested to Nucleo boards. So, start by selecting the type of your Nucleo
board and click on the OK button.
In the Board Selector view there is a checkbox under the Vendor combo box. The label says
Initialize all IP with their default Mode. What does it mean? First of all, let us clarify that IP
does not mean Internet Protocol, but it is the acronym for Integrated Peripheral. Checking
that box causes that CubeMX will automatically generate the C initialization code for all the
peripherals available on the board and not only for those relevant to the user application.
For example, Nucleo boards have a USART (USART2) connected to the ST-LINK interface,
which maps it as a Virtual COM Port. Checking that box says to CubeMX to generate all
necessary code to initialize the USART.
This could seem a good feature to enable, but for novices it is best to leave that feature
disabled and to enable each peripheral by hand only when needed. This simplifies the
learning process and avoids wasting a lot of time trying to understand all at once the
generated code.
STM32CubeMX Tool 114
Figure 4: The MCU view in CubeMX
Once we have selected the MCU (or the development board) to work with, the main CubeMX
window appears, as shown in Figure 4. A nice graphical representation of the STM32 MCU
dominates the view. Even in this case we have a tabbed view. Let us see each tab more in depth.
4.1.1 Pinout View
The Pinout view is the first one, and it is divided in two parts. The right side contains the MCU
representation with the selected peripherals and GPIOs, and it is called by ST Chip view. In the left
side we have the list, in form of a tree view, of all peripherals (hardware parts) and middleware
libraries (software parts) that can be used with the selected MCU. This is called by ST IP tree pane.
4.1.1.1 Chip View
The Chip view allows to easily navigate inside the MCU configuration, and it is a really convenient
way to configure the microcontroller.
Pins⁵ colored in bright green are enabled. This means that CubeMX will generate the needed code
to configure that pin according its functionalities. For example, for pin PA5 CubeMX will generate
the C code needed to setup it as generic output pin⁶.
A pin is colored in orange when the corresponding peripheral is not enabled. For example, pins
PA2 ⁷and PA3 areenabled and CubeMX will generatecorresponding C code toinitialize them, but the
associated peripherals (USART2) is not enabled and no setup code will be automatically generated.
Yellow pins are power source pins, and their configuration cannot be changed.
BOOT and RESET pins are colored in khaki, and their configuration cannot be changed.
⁵ In this context, pin and signal can be used as synonyms.
⁶ Except for Nucleo-F302, where the LD2 is connected to PB13 pin. More about this later in this chapter.
⁷ The pin configurations shown in this section are referred to the STM32F401RE MCU.
STM32CubeMX Tool 115
Figure 5: Contextual tool-tips help understanding signal usage
A contextual tool-tip is showed moving the mouse pointer over the MCU pins (see Figure 5). For
example, contextual tool-tip for pin PB3 says to us that the signal is mapped to Serial Wire Debug
(SWD) interface and it acts as Serial Wire Output (SWO) pin. Moreover, the pin number (55) is also
shown.
Figure 6: Alternate mapping of peripherals
STM32 MCUs allow mapping a peripheral to different pins. For example, in an STM32F401xE MCU,
SPI2 MOSI signal can be mapped to pins PC2 or PB14. CubeMX makes it easy to see the allowed
alternatives with a Ctrl+click. If an alternate pin exists, it is shown in light blue (the alternative is
shown only if the pin is not in reset state - that is, it is enabled). For example, in Figure 6 we can
see that, if we do a Ctrl+click on PC2 pin, the PB14 signal is highlighted in blue. This comes really
handy during the layout of a board. If it is really hard to route a signal to that pin, or if that pin is
needed for some other functionality, an alternate pin may simplify the board.
STM32CubeMX Tool 116
Figure 7: Alternate function of a pin
In the same way, most of MCU pins can have alternate functionalities. A contextual menu is shown
when clicking on a pin. This allows us to select the function we are interested to enable for that
signal.
Suchflexibilityleadstothegenerationofconflictsbetweensignalfunctions.CubeMXtriestoresolve
theseconflictsautomatically,assigningthesignaltoanotherpin.Pinnedsignalsarethosepinswhose
functionality is locked to a specific pin, preventing CubeMX to choose an alternate pin. When a
conflict prevents a peripheral to be used, the pin mode in Chip View is disabled, and the pin is
colored in orange.
4.1.1.2 IP Tree Pane
TheIPtreepaneprovidesaconvenientwaytoenable/disableandtoconfigurethedesiredperipherals
and software middleware. CubeMX shows the peripherals list in a smart way, using icons and
different colors, so that the user can quickly understand if the peripheral is available and what
configuration capabilities it has. Let us see them in depth.
STM32CubeMX Tool 117
Table 1: CubeMX way to show peripherals in IP tree pane
• Case 1: indicates that the peripheral is available and currently disabled, and all its possible
modes can be used. For example, in case of I²C interface, all possible modes for this peripheral
are: I²C, SMBus-Alert-mode, SMBus-two-wire-interface (TWI).
• Case 2: shows that the peripheral is disabled due to a conflict with another peripheral. This
means that both the peripherals use the same GPIOs, and it is not possible to use them
simultaneously. Passing the mouse over it will show the other peripheral involved in conflict.
For example, for an STM32F401RE MCU it is impossible to use I2C2 and SWD debug pins at
the same time.
• Case 3: indicates that the peripheral is available and currently disabled, but at least one
of its modes is not available due to a conflict with other peripherals. For example, in an
STM32F401RE MCU the fourth channel of TIM2 peripheral uses the PA2 GPIO, which is the
USART_RXsignaloftheUSART2peripheral.ThismeansthatyoucannotusetheTIM2channel
4 as input capture while using the Nucleo VCP.
• Case 4: indicates that the peripheral is unavailable for the chosen package type (if you strongly
needthatperipheral,youhavetoswitchtoanotherpackagetype-usuallyonewithmorepins).
• Case 5: indicates that the peripheral is used and all its modes are available (refer to Case 7).
• Case 6: shows that the peripheral is used, but some of its modes or I/Os are not available (refer
to Case 3 and 8).
• Case 7: when all peripheral modes are available, all configuration options are shown in black.
STM32CubeMX Tool 118
• Case 8: when not all peripheral modes are available, unavailable configuration options are
shown with red background.
4.1.2 Clock View
Figure 8: The CubeMX clock view
Clock view is the area where all configurations related to clocks management take place. Here we
can set both the main core and the peripherals clocks. All clock sources and PLLs configurations
are presented in a graphical way (see Figure 8). The first times the user see this view, he could be
puzzled by the amount of configuration options. However, with a little bit of practice, this is the
simplest way to deal with the STM32 clock configuration (which is quite complex if compared to
8-bit MCUs).
If your board design needs an external source for the High Speed clock (HSE), the Low Speed clock
(LSE) or both, you have to first enable it in the Pinout view in the RCC section, as shown in Figure
9.
STM32CubeMX Tool 119
Figure 9: HSE and LSE enabling in CubeMX
Once this is accomplished, you will be able to change clock sources in clock view.
Clock tree configuration will be explored in Chapter 10. To avoid confusion in this phase, leave all
parameters as automatically configured by CubeMX.
Overclocking
A common hacking practice is to overclock the MCU core, changing the PLL configuration
sothatitcanrunatahigherfrequency.Thisauthorstronglydiscouragesthispractice,which
not only could seriously damage the microcontroller, but it may result in abnormal behavior
difficult to debug.
Do not change anything unless you are absolutely sure of what you are doing.
4.1.3 Configuration View
Configuration view allows to further setup peripherals and software components. For example, it is
possible to enable pull-up for a GPIO pin, or to configure the FATFS options.
Figure 10: The CubeMX configuration view
Configuration options defined in this view impact the automatically generated C source code. A
good management of this CubeMX section allows to simplify a lot the development process related
STM32CubeMX Tool 120
to peripherals optimizations. We will analyze each configuration view when we will deal with each
type of peripheral.
4.1.4 Power Consumption Calculator View
Power Consumption Calculator (PCC) view is a feature of CubeMX that, given a microcontroller,
a battery model and a user-defined power sequence, provides an estimation of the following
parameters:
• Average power consumption.
• Battery life.
• Average DMIPS.
It is possible to add user-defined batteries through a dedicated interface.
For each step, the user can choose VBUS as possible power source instead of the battery. This will
impact the battery life estimation. If power consumption measurements are available at different
voltage levels, CubeMX will also propose a choice of voltage values.
Figure 10: The CubeMX configuration view
PCC view will be analyzed in a following chapter.
STM32CubeMX Tool 121
4.2 Project Generation
OncetheconfigurationoftheMCU,ofitsperipheralsandmiddlewaresoftwareiscompleted,wecan
use CubeMX to generate the C project skeleton for us. In this paragraph we will see all the required
steps to:
• Create a new “universal” Eclipse project, ready to accept CubeMX auto-generated C code.
• Import the CubeMX generated files inside the Eclipse project.
• Configure the project, if needed.
The final result of this chapter will be another blinking application, but this time we will create
it using the most of the code coming from the latest STCube framework. This will also give us the
opportunitytostartunderstandingthefoundationblocksoftheSTCubeHardwareAbstractionLayer
(HAL). Once we understand the steps explained here, we would be fully autonomous in setting up
any project for the STM32 platform.
4.2.1 Generate C Project with CubeMX
ThefirststepistogeneratetheCcodecontainingHALinitializationcodeusingCubeMXtool.Ifyou
have done experiments in the previous paragraph, it is better to start a totally new project, selecting
your Nucleo board from the Board Selector Tool, as shown before.
STM32CubeMX Tool 122
Figure 11: The Project Settings dialog
Once CubeMX has created the new project, go to Project->Settings… menu. The Project Settings
dialog appears, as shown in Figure 11.
In the Project Name field write the name you like for the project. For the Project Location field,
it is best to create a folder inside the ∼/STM32Toolchain ⁸ folder ( C:\STM32Toolchain for Windows
users). A good folder name could be ∼/STM32Toolchain/cubemx-out . In the Toolchain/IDE field
select the SW4STM32 entry. Leave all the other fields as default.
⁸ Once again, you are completely free to choose the preferred path for your workspace. Here, to simplify the instructions, all path assumed
relative to ∼/STM32Toolchain .
STM32CubeMX Tool 123
Figure 12: The Code Generator section of Project Settings dialog
Switch now to Code Generator tab, and select the options as shown in Figure 12. Click on the OK
button.
Now we are ready to generate the C initialization code for our Nucleo. Go to Project->Generate
Code menu. CubeMX may ask you to download the latest version of the STCube HAL framework
for your Nucleo (e.g., if you have a Nucleo-F401RE it will ask you to download STCube-F4 HAL). If
so, click on Yes button and wait for completion. After a while, you will find the C code inside the
∼/STM32Toolchain/cubemx-out/<project-name> directory.
4.2.1.1 Understanding Generated Code
Before we continue with the Eclipse project creation, it is a good thing to take a look at the code
generated by CubeMX.
STM32CubeMX Tool 124
Figure 13: The generated code compared to the CMSIS architectural view
Opening the ∼/STM32Toolchain/cubemx-out/<project-name> folder, you will find several sub-
folders inside it. Figure 13 compares the generated project structure to the CMSIS software
architecture⁹. As we have seen in Chapter 1, CMSIS is composed by several components. Here we
are interested in CMSIS-CORE.
CMSIS-COREimplementsthebasicrun-timesystemforaCortex-Mdeviceandgivestheuseraccess
to the processor core and the device peripherals. In detail it defines:
• HAL for Cortex-M processor registers, with standardized definitions for the SysTick, NVIC,
System Control Block registers, MPU registers, FPU registers, and core access functions.
• System exception names to interface to system exceptions without having compatibility
issues.
• Methods to organize header files that make it easy to learn new Cortex-M microcontroller
products and improve software portability. This includes naming conventions for device-
specific interrupts.
• Methods for system initialization to be used by each MCU vendor. For example, the
standardized SystemInit() function is essential for configuring the clock system when device
starts.
• Intrinsic functions used to generate CPU instructions that are not supported by standard C
functions.
• A global variable, named SystemCoreClock , to easily determine the system clock frequency.
⁹ You will find also the sub-folder SW4STM32. It contains the project file for the ACS6 IDE, which we cannot import in our tool-chain.
So, simply ignore it.
STM32CubeMX Tool 125
The CMSIS-CORE pack is subdivided in several files in the project generated with CubeMX, as
shown in Figure 13:
• Include folder contains several core_<cpu>.h files (where <cpu> is replaced by cm0 , cm3 , etc).
Thesefilesdefinethecoreperipheralsandprovidehelperfunctionsthataccessthecoreregisters
(SysTick, NVIC, ITM, DWT etc.). These files are generic for all Cortex-M based MCUs.
• Device folder contains device specific informations for all STM32F/L devices (e.g., STM32F4),
such as interrupt numbers (IRQn) for all exceptions and device interrupts, definitions for the
Peripheral Access to all device peripherals (all data structures and the address mapping for de-
vice-specific peripherals) - file system_<device>.h . It also contains additional helper functions
to simplify peripherals programming. Moreover, there are also several startup_<device>.s
assembly files: these contain startup code and system configuration code (reset handler which
is executed after CPU reset, exception vectors of the Cortex-M Processor, interrupt vectors that
are device specific).
Finally, Inc and Src folders in the project root contain headers and source files of the skeleton
application generated by CubeMX, and the STM32xxxx_HAL_Driver folder, inside the Drivers one, is
the whole ST HAL for that microcontroller series.
A Note About CubeMX Eclipse Plug-In
For the sake of completeness, we have to say that ST distributes a CubeMX release as an Eclipse
plug-in. It can be download from the official ST website. The plug-in as such works quite well, and
it can be used on the three Operating Systems we are considering in this book. However, it is quite
useless with our tool-chain, since its generated projects cannot be easily used with the GNU MCU
Eclipse plug-in. So, we will consider only the standalone edition in this book.
 http://bit.ly/1W5Xgkc
4.2.2 Create Eclipse Project
We are now going to create an Eclipse project that will host the files generated by CubeMX.
Go to File->New->C Project menu. Type the project name you like and select Hello World ARM
Cortex-M C/C++ Project as project type.
STM32CubeMX Tool 126
Figure 14: Second step of project generation wizard
In the second step fill the fields Processor core, Clock, Flash size and RAM size according your
Nucleo type (refer to Table 3 if you do not know them), and leave all other fields as shown inFigure
14.
Table 3: Project settings to select according the given Nucleo
STM32CubeMX Tool 127
In the third step leave all fields as default, except for the last one: Vendor CMSIS name. That field
must have this pattern: <stm32family>xx . For example, for a Nucleo-F1 write stm32f1xx , or for a
Nucleo-L4 write stm32l4xx , as shown in Figure 15. Go ahead with the project wizard until it is
completed.
Once again, we have used the GNU MCU Eclipse plug-in to generate the project, but this time there
are some files we do not need, since we will use the ones generated by CubeMX tool. Figure 16
shows the Eclipse project and five highlighted files in the Project Explorer view. You can safely
delete them hitting the delete button on your keyboard.
Figure 15: Third step of project generation wizard
STM32CubeMX Tool 128
Figure 16: Eclipse project with highlighted files to delete
We need to change one more thing to the files generated by GNU MCU plugin. Opening the file
ldscripts/mem.ld we can see that the origin of FLASH memory is wrong because, as we have seen
in Chapter 1, the flash memory is mapped from the address 0x0800 0000 for all STM32 devices. So,
ensure that memory origin definitions¹⁰ of your .ld file are equal to the following ones:
...
MEMORY
{
FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 512K
RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 96K
...
4.2.3 Importing Generated Files Into the Eclipse Project Manually
Once we have created the Eclipse project, we need to import the CubeMX project inside it. There
are two ways to do this: manually or using a convenient tool made by the author of this book. It is
strongly suggested to execute the operation manually at least once, in order to understand exactly
what software components are involved in this operation.
¹⁰ Clearly, the memory length depends on the specific MCU. Always double check that they correspond with the hardware specifications of
your MCU. If they do not match, strange faults may occur at startup (we will learn how to deal with hardware faults in a following chapter).
Another quick solution is offered to us by CubeMX. Opening the ∼/STM32Toolchain/cubemx-out/<project-name>/SW4STM32/<project-name>
Configuration folder you will find a file ending with .ld . It is the linker script containing the right memory origin definitions for your MCU.
You can simply copy the MEMORY section contained in that file and past it into the ldscripts/mem.ld file.
STM32CubeMX Tool 129
Starting from now, all paths are relative to the ∼/STM32Toolchain/cubemx-out/<project-name>
folder.
Go inside the Inc filesystem folder and drag all its content inside the include Eclipse folder. Eclipse
will ask you how to import the files. Select theCopy files options and click on the OK button. In the
same way, go inside the Src filesystem folder and drag all its content inside the src Eclipse folder.
With these two operations, we have imported the application code inside the Eclipse project.
Starting from this point, you will find several paths and filenames related to F4 MCUs. For
example, a path having this structure ‘Drivers/STM32F4xx_HAL_Driver/Inc’ or a file name
like this one ‘system_stm32f4xx.c’. Please, note that you have to substitute the F4 with
the STM32 family of your MCU (F0, F1, F2, F3, F7, L0, L1, L4). Pay attention if the path
or the filename has a capital letter (F4) or not (f4).
Please, take also note that starting from this paragraph we will use the Courier font
to indicate filesystem paths (e.g. Drivers/STM32F4xx_HAL_Driver/Inc ); instead, we will
indicate Eclipse folders in bold (e.g. system/include/stm32f4xx). This convention is valid
in the whole book.
Now, go inside the Drivers/STM32F4xx_HAL_Driver/Inc filesystem folder and import all its content
inside the system/include/stm32f4xx Eclipse folder. In the same way, go inside the Driver-
s/STM32F4xx_HAL_Driver/Src filesystem folder and import all its content inside the system/sr-
c/stm32f4xx Eclipse folder. We have successfully imported the ST HAL in our project. It is now
the turn of CMSIS-CORE package.
First, we start importing the official CMSIS-CORE package. Go inside the Drivers/CMSIS/Include
filesystem folder and drag all its content inside the system/include/cmsis Eclipse folder. When
asked, answer Yes to replace existing files.
Now we have to import the specific device files for the CMSIS-CORE.
Please, take note that the GNU MCU Plugin already embeds the CMSIS-CORE inside the
generated project, but it is an old version (3.20). We are replacing it with the latest official
version shipped by ST (4.30 at the time of writing this chapter).
Go inside the Drivers/CMSIS/Device/ST/STM32F4xx/Include filesystem folder and drag all its
content inside the system/include/cmsis Eclipse folder. Eclipse will ask you to overwrite existing
files: answer Yes. Now go inside the startup folder and drag the file startup_stm32f4xxxx.s inside
the system/src/cmsis Eclipse folder.
Read Carefully
.s files are assembly files that need to be processed directly by the GNU Assembler (AS).
However, Eclipse CDT is programmed to expect the assembly file ending with .S (capital
S). So rename the file from startup_stm32f4xxxx.s to startup_stm32f4xxxx.S . To do this,
right click on the file in Eclipse and choose Rename entry.
STM32CubeMX Tool 130
So, let us recap what we have done until now.
1. First, we have created an Empty ARM C/C++ project, using the specs of our MCU.
2. Next we have deleted some files generated by GNU MCU plugin and imported those generated
by CubeMX; we have also updated the FLASH address origin in mem.ld file.
3. Then we have copied the main application files from Inc and Src folders.
4. We have so imported the ST HAL for our MCU and the latest CMSIS-CORE package.
5. Finally we have added the right startup assembly file startup_stm32f4xxxx.s for our MCU,
and renamed it in startup_stm32f4xxxx.S (ending with capital .S).
Table 2 summarizes the files and folders that have to be imported in the Eclipse project. Paths on
the left are filesystem paths (relative to the CubeMX project output directory); paths on the right
are the corresponding Eclipse folder.
Table 2: Files and folders that have to be imported in the corresponding Eclipse folders
Filesystem Paths and Files Eclipse Folders
Inc include
Src src
Drivers/STM32F4xx_HAL_Driver/Inc system/include/stm32f4xx
Drivers/STM32F4xx_HAL_Driver/Src system/src/stm32f4xx
Drivers/CMSIS/Include system/include/cmsis
Drivers/CMSIS/Device/ST/STM32F4xx/Include system/include/cmsis
startup/startup_stm32f4xxxx.S system/src/cmsis
I am aware of the fact that this procedures seems cumbersome, but trust me: once you get
familiar with this procedure, you will be able to create a project for every STM32 MCU,
including the latest STM32F7 and future STM32 microcontrollers. However, in the next
paragraph we will review a way to automatize this task.
If you try to compile the project, you will see a lot of errors and warnings. To complete its
configuration, we still need another two steps.
The ST HAL is designed to work with all MCUs of a given series (F0, F1, etc.). Several conditional
macros are used inside the HAL to discriminate the MCU type. So we have to specify the MCU
equipping our Nucleo.
Go to Project->Properties menu, and then in C/C++ Build->Settings section. Select the Cross
ARM C Compiler->Preprocessor section and then click on the Add… icon (the one circled in red
in Figure 17). Type in the macro name corresponding to your Nucleo (refer toTable 3, column HAL
Macro). For example, for a Nucleo-F401RE, use the macro STM32F401xE .
STM32CubeMX Tool 131
Figure 17: Eclipse project settings and MCU macro definition
If you are using a custom board with a microcontroller not listed in Table 3, you can find
the macro for your MCU inside the file system/include/cmsis/stm32XXxx.h.
The last step is to delete the following files from the Eclipse project¹¹:
• system/src/stm32XXxx/stm32XXx_hal_msp_template.c
• system/src/stm32XXxx/stm32XXxx_hal_timebase_tim_template.c
• system/src/stm32XXxx/stm32XXxx_hal_timebase_rtc_alarm_template.c:
These files are templates generated by CubeMX inside the system/stm32XXxx folder (I think that
CubeMX should not put that file inside the generated project). We will analyze them later in the
book.
Congratulations: you are now ready to compile the project. If all has gone well, the project should
compile generating the binary file without errors (some warnings are still there, but do not care
about them).
¹¹ Some of these file are still not present in all CubeHALs - if you cannot find it, do not care about this. If you find other files ending in
template.c remove them.
STM32CubeMX Tool 132
Eclipse Intermezzo
You might have noticed that every time you change something to the project settings, a lot of time
is required to compile the whole source tree. This happens because Eclipse recompiles all the HAL
source files, contained in system/src/stm32XXxx/. This is really annoying, and you can speed up
the compile time by disabling all those files not needed to your application. For example, if your
board does not need to use I²C devices, you can safely disable the compilation of stm32XXxx_-
hal_i2c_ex.candstm32XXxx_hal_i2c.cfilesbyrightclickingonthemandthenchoosingResource
configuration->Exclude from build, and selecting all the project configurations defined.
Another solution to the same problem is to configure CubeMX so that it adds to the project only
necessary library files. To do it, choose in CubeMX project settings the entry Copy only the
necessary library files, as shown below.
 However, keep in mind that excluding the unused HAL files from compilation will not impact on the size of binary file:
any modern liker is able to automatically exclude from generation of the absolute file (the binary file we will load on our board)
all those relocatable files that contains unused code and data (more about the linking process of an STM32 binary in a following
chapter).
 This will cause that if you need to use an additional peripheral later, you will have to import the corresponding HAL files
manually.
STM32CubeMX Tool 133
4.2.4 Importing Files Generated With CubeMX Into the Eclipse
Project Automatically
The previous steps can be executed automatically using a bare-bone Python script. Its name is
CubeMXImporter and it can be downloaded by this author’s github account¹².
Read Carefully
The tool automatically deletes all unneeded existing project files. This includes also the
main.c file and all other files contained in src and include Eclipse Folder. For this reason,
do not execute the CubeMXImporter on an existing project. Always execute it on a fresh
new Eclipse project generated with the GNU MCU Eclipse plugin.
ThisscriptworkswellonlyifyouhavegeneratedaCubeMXprojectfortheSW4STM32
(aka AC6) tool-chain.
CubeMXImporter relies on Python 2.7.x and the lxml library. Here you can find the installation
instructions for Windows, Linux and Mac OSX.
Windows
InWindowswehavetoinstallfirstthelatestPython2.7release.Wecandownloaditdirectly
from this link¹³. Once downloaded, launch the installer and ensure that all installation
options are enabled, as shown in Figure 18. When the installation is completed, you can
install a pre-compiled lxml package, downloading it from here¹⁴.
Linux and MacOS X
On these two Operating Systems, Python 2.7 is installed by default. So, we only need to
install the lxml library (if it is not already installed). We can simply install it using the pip
command:
$ sudo pip install lxml
¹² https://github.com/cnoviello/CubeMXImporter
¹³ http://bit.ly/1MjXoGb
¹⁴ http://bit.ly/1P4lxSO
STM32CubeMX Tool 134
Figure 18: all installation options have to be enabled when installing Python in Windows
Once we have installed Python and the lxml library, we can download the CubeMXImporter
script from github and place it in a convenient place (I assume that it is downloaded inside the
∼/STM32Toolchain/CubeMXImporter folder).
Now, close the Eclipse project (do not skip this step) and execute the CubeMXImporter at terminal
console in the following way:
$ python cubemximporter.py <path-to-eclipse-project> <path-to-cube-mx-project>
After few seconds, the CubeMX project is correctly imported. Now, open again the Eclipse project
and perform a refresh of the source tree, clicking with the right mouse button on the project root
and selecting the Refresh entry.
You can proceed building the project.
4.3 Understanding Generated Application Code
We finally have a fully working project template to start with. If you want, to avoid repeating the
previous annoying procedures, you can follow this recipe:
• store the template project in a place separated from the Eclipse workspace;
• import it inside the workspace when you need to start a new project (Go to File->Import… and
choose the entry Import Existing Projects into Workspace);
• open the project and rename it as you want by clicking with the right mouse button on the
project root and choosing the entry Rename….
STM32CubeMX Tool 135
We are now going to customize its main.c to do something useful with our Nucleo. But, before
changing application files, let us have a look at them.
The first important file we are going to analyze is include/stm32XXxx_hal_conf.h. This is the file
where the HAL configurations are translated into C code, using several macro definitions. These
macros are used to “instruct” the HAL about enabled MCU functionalties. You will find a lot of
commented macros, as shown below:
Filename: include/stm32XXxx_hal_conf.h
87 //#define HAL_QSPI_MODULE_ENABLED
88 //#define HAL_CEC_MODULE_ENABLED
89 //#define HAL_FMPI2C_MODULE_ENABLED
90 //#define HAL_SPDIFRX_MODULE_ENABLED
91 //#define HAL_DFSDM_MODULE_ENABLED
92 //#define HAL_LPTIM_MODULE_ENABLED
93 #define HAL_GPIO_MODULE_ENABLED
94 #define HAL_DMA_MODULE_ENABLED
95 #define HAL_RCC_MODULE_ENABLED
96 #define HAL_FLASH_MODULE_ENABLED
97 #define HAL_PWR_MODULE_ENABLED
98 #define HAL_CORTEX_MODULE_ENABLED
These macros are used to selectively include HAL modules at compile time. When you need a
module, you can simply uncomment the corresponding macro. We will have the opportunity to
see all the other macros defined in this file throughout the rest of the book.
The file src/stm32f4xx_it.c is another fundamental source file. It is where all the Interrupt Service
Routines (ISR) generated by CubeMX are stored. Let us see its content.
Filename: src/stm32XXxx_it.c
42 /* External variables --------------------------------------------------------*/
43
44 /******************************************************************************/
45 /* Cortex-M4 Processor Interruption and Exception Handlers */
46 /******************************************************************************/
47
48 /**
49 * @brief This function handles System tick timer.
50 */
51 void SysTick_Handler(void)
52 {
53 /* USER CODE BEGIN SysTick_IRQn 0 */
54
55 /* USER CODE END SysTick_IRQn 0 */
56 HAL_IncTick();
57 HAL_SYSTICK_IRQHandler();
STM32CubeMX Tool 136
58 /* USER CODE BEGIN SysTick_IRQn 1 */
59
60 /* USER CODE END SysTick_IRQn 1 */
61 }
Given the CubeMX configuration we have chosen, the file contains essentially only the definition
of the function void SysTick_Handler(void) , which is declared inside the filesystem/include/cor-
texm/ExceptionHandlers.h. SysTick_Handler() is the ISR of the SysTick timer, that is the routine
that is invoked when the SysTick timer reaches 0. But where is this ISR invoked?
Theanswertothisquestiongivesustheopportunitytostartdealingwithoneofthemostinteresting
featuresofCortex-Mprocessors:theNestedVectoredInterruptController (NVIC).Table1inChapter
1 shows the Cortex-M exception types. If you remember, we have said that in Cortex-M CPU
interrupts are a special type of exceptions. Cortex-M defines the SysTick_Handler to be the fifteenth
exception in the NVIC vector array. But where is this array defined? In the previous paragraph we
have added a special file written in assembly, that we have called startup file. Opening this file we
can see the minimal vector table for a Cortex processor, about at line 140, as shown below:
Filename: system/src/cmsis/startup_stm32f401xe.S
142 g_pfnVectors:
143 .word _estack
144 .word Reset_Handler
145 .word NMI_Handler
146 .word HardFault_Handler
147 .word MemManage_Handler /* Not available in Cortex-M0/0+ */
148 .word BusFault_Handler /* Not available in Cortex-M0/0+ */
149 .word UsageFault_Handler /* Not available in Cortex-M0/0+ */
150 .word 0
151 .word 0
152 .word 0
153 .word 0
154 .word SVC_Handler
155 .word DebugMon_Handler /* Not available in Cortex-M0/0+ */
156 .word 0
157 .word PendSV_Handler
158 .word SysTick_Handler
Line 158 is where the SysTick_Handler() is defined as ISR for the SysTick timer.
Please, consider that startup files have minor modifications between the ST HALs. Line
numbers reported here could differ a little bit from the startup file for your MCU.
Moreover,the MemManage Fault , Bus Fault , Usage Fault and Debug Monitor exceptionsare
not available (and hence the corresponding vector entry is RESERVED - see the Table 1 in
Chapter 1) in Cortex-M0/0+ based processors. However, the first fifteen exceptions in NVIC
are always the same for all Cortex-M0/0+ based processors and all Cortex-M3/4/7 based
MCUs.
STM32CubeMX Tool 137
Anotherreallyimportantfiletoanalyzeisthesrc/stm32XXxx_hal_msp.c.Firstofall,itisimportant
to clarify the meaning of “MSP”. It stands for MCU Support Package, and it defines all the
initializationfunctionsusedtoconfiguretheon-chipperipheralsaccordingtotheuserconfiguration
(pin allocation, enabling of clock, use of DMA and Interrupts). Let us explain this in depth with an
example. A peripheral is essentially composed of two things: the peripherals itself (for example, the
SPI2 interface) and the hardware pins associated with this peripheral.
Figure 19: The relation between MSP files and the HAL
The ST HAL is designed so that the SPI module of the HAL is generic and abstracts from the specific
I/Osettings,whichmaydifferduetotheMCUpackageandtheuser-definedhardwareconfiguration.
So, ST developers have leaved to the user the responsibility to “fill” this piece of the HAL with the
code necessary to configure the peripheral, using a sort of callback routines, and this code resides
inside the src/stm32XXxx_hal_msp.c file (see Figure 19).
Let us open the src/stm32XXxx_hal_msp.c file. Here we can find the function void HAL_-
MspInit(void) :
Filename: src/ch4-stm32XXxx_hal_msp.c
44 void HAL_MspInit(void)
45 {
46 /* USER CODE BEGIN MspInit 0 */
47
48 /* USER CODE END MspInit 0 */
49
50 HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
51
52 /* System interrupt init*/
53 /* SysTick_IRQn interrupt configuration */
54 HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
55
56 /* USER CODE BEGIN MspInit 1 */
57
58 /* USER CODE END MspInit 1 */
59 }
HAL_MspInit(void) is called inside the function HAL_Init() , which is in turn called in the main.c
STM32CubeMX Tool 138
file as we will see soon. The function simply defines the priority of SysTick_IRQn exception, the
one handled by the SysTick_Handler() ISR. The code assigns the highest user defined priority (the
lower the number, the higher is the priority).
The last file that remains to analyze is src/main.c . It essentially contains three routines: System-
Clock_Config(void) , MX_GPIO_Init(void) and int main(void) .
The first function is used to initialize core and peripheral clocks. Its explanation is outside the scope
of this chapter, but its code is not so much complicated to understand. MX_GPIO_Init(void) is the
function that configures the GPIO. Chapter 6 will explain this matter in depth.
Finally, we have the main(void) function, as shown below.
Filename: src/main.c
60 int main(void)
61 {
62 /* USER CODE BEGIN 1 */
63
64 /* USER CODE END 1 */
65
66 /* MCU Configuration----------------------------------------------------------*/
67 /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
68 HAL_Init();
69 /* Configure the system clock */
70 SystemClock_Config();
71 /* Initialize all configured peripherals */
72 MX_GPIO_Init();
73
74 /* USER CODE BEGIN 2 */
75
76 /* USER CODE END 2 */
77
78 /* Infinite loop */
79 /* USER CODE BEGIN WHILE */
80 while (1)
81 {
82 /* USER CODE END WHILE */
83
84 /* USER CODE BEGIN 3 */
85 }
86 /* USER CODE END 3 */
87 }
88
89 /** System Clock Configuration
90 */
91 void SystemClock_Config(void)
92 {
STM32CubeMX Tool 139
The code is really self-explaining. First, the HAL is initialized by calling the function HAL_Init() .
Don’t forget that this causes the function HAL_MSP_Init() to be automatically called by the HAL.
Then, clocks and GPIOs are initialized. Finally, the application enters an infinite loop: that is the
place where our code must be placed.
You will have noticed that the code generated by CubeMX is full of these commented
regions:
/* USER CODE BEGIN 1 */
...
/* USER CODE END 1 */
What are those comments for? CubeMX is designed so that if you change the hardware
configuration you can regenerate the project code without losing the pieces of code you
have added. Placing your code inside those “guarded regions” should guarantee that you
will not lose your work. However, I have to admit that CubeMX often makes a mess with
generatedfiles,andtheusercodegoeslost.So,Isuggestalwaysgeneratinganotherseparated
project and doing a copy and paste of the changed code inside the application files. This also
gives you the full control over your code.
4.3.1 Add Something Useful to the Firmware
Now that we are masters of the code generated by CubeMX, we can add something useful to the
main() function. We will add the code required to blink the LD2 LED when the user presses the
Nucleo blue button connected to PC13.
Filename: src/main.c
72 while (1) {
73 if(HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == GPIO_PIN_RESET) {
74 while(1) {
75 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
76 HAL_Delay(500);
77 }
78 }
79 }
At line 72 there is an infinite loop that waits until HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin)
returns the value GPIO_PIN_RESET , that is the user has pressed the blue button. When this happens,
the MCU enters another infinite loop where the LD2_Pin pin is toggled every 500ms. The macros
LD2_Pin , B1_GPIO_Port and B1_Pin are defined inside the main.h file.
STM32CubeMX Tool 140
Why do we have to check when the PC13 goes low (that is HAL_GPIO_ReadPin() returns
GPIO_PIN_RESET state) to detect that the button was pressed?
The answer comes from the Nucleo schematics. Looking below, we can see that one side
of the button is connected to the ground, and resistor R30 pulls up the MCU pin when the
button is not pressed.
Now compile and try out the program on your Nucleo board!
4.4 Downloading Book Source Code Examples
All examples presented in this book are available for downloading from its GitHub repository:
http://github.com/cnoviello/mastering-stm32¹⁵.
¹⁵ http://github.com/cnoviello/mastering-stm32
STM32CubeMX Tool 141
Figure 20: The content of the GitHub repository containing all the book examples
The examples are divided for each Nucleo model, as you can see in Figure 20. You can clone the
whole repository using git command:
$ git clone https://github.com/cnoviello/mastering-stm32.git
or you can download only the repository content as a .zip package following this link¹⁶. Now you
have to import the Eclipse project for your Nucleo into the Eclipse workspace.
Open Eclipse and go to File->Import…. The Import dialog appears. Select the entry General-
>Existing Project into Workspace and click on the Next button. Now browse to the folder
containing the example projects clicking on the Browse button. Once selected the folder, a list
of the contained projects appear. Select the project you are interested in and check the entry Copy
projects into workspace as shown in Figure 21 and click the Finish button.
¹⁶ https://github.com/cnoviello/mastering-stm32/archive/master.zip
STM32CubeMX Tool 142
Figure 21: Eclipse project import wizard
Now you can see all imported projects inside the Project Explorer pane. Close the projects you are
notinterestedin.Forexample,ifyourNucleoisbasedonanSTM32F030MCU,thancloseallprojects
exceptthe nucleo-F030R8 one¹⁷(oryoucansimplyimportonlyprojectsthatfitsyourNucleoboards).
Figure 22: Quick way to select project configurations
Each project contains all the examples shown in this book. This is done using different build
configurations for each type of Nucleo. Build configurations is a feature that all modern IDEs
support.Itallowshavingseveralprojectconfigurationsinsidethesameproject.EveryEclipseproject
has at least two build configurations: Debug and Release. The former is used to generate a binary
¹⁷ You can do this simply by clicking with the right mouse button on the project you are interested in (in our example case, the
stm32nucleo-F0 ) and select the entry Close Unrelated Projects.
STM32CubeMX Tool 143
file suitable to be debugged. The latter is used to generate optimized firmware for production.
ToselecttheconfigurationforyourNucleogotoProject->BuildConfigurations->SetActivemenu
and choose the corresponding configuration, or click the down arrow close the build icon, as shown
in Figure 22. Now you can compile the whole project. At the end, you will find the binary file of
your firmware inside the folder ∼/STM32Toolchain/projects/nucleo-XX/CHx-EXx folder.
5. Introduction to Debugging
Coding is all about debugging, said a friend of mine one day. And this is dramatically true. We can
do all the best writing really great code, but sooner or later we have to deal with software bugs
(hardware bugs are another terrible beast to fight). And a good debugging of embedded software is
all about to be a happy embedded developer.
In this chapter we will start analyzing an important debugging tool: OpenOCD. It has become a
sort of standard in the embedded development world, and thanks to the fact that many companies
(including ST) are officially supporting its development, OpenOCD is facing a rapid growth. Every
new release includes the support for tens of microcontrollers and development boards. Moreover,
being portable among the three major Operating Systems (Windows, Linux and Mac OS), it allows
us to use one unique and consistent tool to debug examples in this book.
This chapter also covers another important debugging mechanism:ARM semi-hosting. It is a way to
communicate input/output requests from application code to a host computer running a debugger
and it is extremely useful to execute functions that would be too complicated (or impossible due to
the lack of some hardware features) to execute on the target microcontroller.
This chapter is a preliminary view of the debugging process, which would require a separate book
even for simpler architectures like the STM32. Chapter 24 will give a close look at other debugging
tools, and it will focus on Cortex-M exception mechanism, which is a distinctive feature of this
platform.
5.1 Getting Started With OpenOCD
The Open On-Chip Debugger¹ (OpenOCD) started as thesis work by Dominic Rath and now is
actively developed and maintained by a large and growing community, with the official support
from several silicon vendors.
OpenOCD aims to provide debugging, in-system programming and boundary-scan testing for
embedded target devices. It does so with the assistance of a hardware debug adapter, which provides
the right kind of electrical signaling to the target being debugged. In our case, this adapter is
the integrated ST-LINK debugger provided by the Nucleo board². Every debug adapter uses a
transport protocol that mediates between the hardware under debugging and the host software,
that is OpenOCD.
¹ http://openocd.org
² The Nucleo ST-LINK debugger is designed so that it can be used as standalone adapter to debug an external device (e.g., a board designed
by you equipping an STM32 MCU).
Introduction to Debugging 145
Figure 1: How OpenOCD interacts with a Nucleo board
OpenOCD is designed to be a generic tool able to work with tens of hardware debuggers, using
several transport protocols. This requires a way to configure how to interface the specific debugger,
and this is done through the use of script files. OpenOCD uses an extended definition of Jim-TCL,
which in turn is a subset of the TCL programming language.
Figure 1 shows a typical debugging environment for the Nucleo board. Here we have the hardware
part, composed by a Nucleo with its integrated ST-LINK interface, and OpenOCD interacting
with the ST-LINK debugger using libusb, or any API-compatible library able to allow user-space
applications to interface USB devices. OpenOCD also provides needed drivers to interact with the
internal STM32 flash memory³ and the ST-LINK protocol. So it is instructed about the specific
hardware under debugging (and the used debugger) through configuration files.
Once OpenOCD has established the connection with the board to debug, it provides two ways to
communicate with the developer. The first one is through a local telnet connection on the port
4444 . OpenOCD provides a convenient shell that is used to send commands to it and to receive
information about the board under debugging. The second option is offered by using it as remote
server for GDB. OpenOCD also implements the GDB remote protocol and it is used as “mediator”
component between GDB and the hardware. This allows us to debug the firmware using GDB and,
more important, using Eclipse as graphical debugging environment.
5.1.1 Launching OpenOCD
Before we configure Eclipse to use OpenOCD in our project, it is better to take a look at how
OpenOCD works at a lower level. This will allow us to familiarize with it and, in case something
does not works properly, it will allow to better investigate for issues related to the OpenOCD
configuration.
TheinstructionstostartOpenOCDaredifferentbetweenWindowsandUNIXlikesystems.So,jump
to the paragraph that fits your OS.
³ One common misunderstanding about the STM32 platform is that all STM32 devices have a common and standardized way to access to
their internal flash. This is not true, since every STM32 family has specific capabilities regarding their peripherals, including the internal flash.
This requires OpenOCD to provide drivers to handle all STM32 devices.
Introduction to Debugging 146
5.1.1.1 Launching OpenOCD on Windows
Open the Windows Command Line tool⁴ and go inside the C:\STM32Toolchain\openocd\scripts
folder and execute the following command:
$ cd C:\STM32Toolchain\openocd\scripts
$ ..\bin\openocd.exe -f board\<nucleo_conf_file.cfg>
where <nucleo_conf_file.cfg> must be substituted with the config file that fits your Nucleo board,
according to Table 1⁵. For example, if your Nucleo is the Nucleo-F401RE, then the proper config file
to pass to OpenOCD is st_nucleo_f4.cfg .
Table 1: Corresponding OpenOCD board file for a given Nucleo
Nucleo P/N OpenOCD 0.10.0 board script file
NUCLEO-F446RE st_nucleo_f4.cfg
NUCLEO-F411RE st_nucleo_f4.cfg
NUCLEO-F410RB st_nucleo_f4.cfg
NUCLEO-F401RE st_nucleo_f4.cfg
NUCLEO-F334R8 stm32f334discovery.cfg
NUCLEO-F303RE st_nucleo_f3.cfg
NUCLEO-F302R8 st_nucleo_f3.cfg
NUCLEO-F103RB st_nucleo_f103rb.cfg
NUCLEO-F091RC st_nucleo_f0.cfg
NUCLEO-F072RB st_nucleo_f0.cfg
NUCLEO-F070RB st_nucleo_f0.cfg
NUCLEO-F030R8 st_nucleo_f0.cfg
NUCLEO-L476RG st_nucleo_l476rg.cfg
NUCLEO-L152RE st_nucleo_l1.cfg
NUCLEO-L073RZ st_nucleo_l073rz.cfg
NUCLEO-L053R8 stm32l0discovery.cfg
If everything went the right way, you should see messages similar to those appearing in Figure 2.
⁴ It is strongly suggested to use a decent terminal emulator like ConEmu(https://conemu.github.io/) or similar.
⁵ OpenOCD 0.10.0 still does not provide full support to all types of Nucleo boards, but the community is working hard on this and in the
next main release the support will be completed. However, you can use alternative configuration files to work with your Nucleo at the time of
writing this chapter.
Introduction to Debugging 147
Figure 2: What appears on the command line prompt when OpenOCD starts correctly
At the same time, the LED LD1 on the Nucleo board should start blinking GREEN and RED
alternatively. Now we can jump to the next paragraph.
5.1.1.2 Launching OpenOCD on Linux and MacOS X.
LinuxandMacOSXuserssharethesameinstructions.Goinsidethe ∼/STM32Toolchain/openocd/scripts
folder and execute the following command:
$ cd ~/STM32Toolchain/openocd/scripts
$ ../bin/openocd -f board/<nucleo_conf_file.cfg>
where <nucleo_conf_file.cfg> must be substituted with the config file that fits your Nucleo board,
according to Table 1. For example, if your Nucleo is the Nucleo-F401RE, then the proper config file
to pass to OpenOCD is st_nucleo_f4.cfg .
If everything went the right way, you should see messages similar to those appearing in Figure
2. At the same time, the LED LD1 on the Nucleo board should start blinking GREEN and RED
alternatively. Now we can jump to the next paragraph.
Introduction to Debugging 148
Common OpenOCD Issues on the Windows Platform
If you experienced issues trying to use OpenOCD on Windows, probably this paragraph could help
you solving them.
It happens really often that Windows users cannot use OpenOCD the first time they install it. When
OpenOCD is executed, an error message regarding libusb is thrown, as shown at lines 12-14 below.
1 Open On-Chip Debugger 0.10.0 (2015-05-19-12:09)
2 Licensed under GNU GPL v2
3 For bug reports, read http://openocd.org/doc/doxygen/bugs.html
4 Info : The selected transport took over low-level target control. The results might differ com\
5 pared to plain JTAG/SWD
6 adapter speed: 2000 kHz
7 adapter_nsrst_delay: 100
8 none separate
9 srst_only separate srst_nogate srst_open_drain connect_deassert_srst
10 Info : Unable to match requested speed 2000 kHz, using 1800 kHz
11 Info : Unable to match requested speed 2000 kHz, using 1800 kHz
12 Info : clock speed 1800 kHz
13 Error: libusb_open() failed with LIBUSB_ERROR_NOT_SUPPORTED
14 Error: libusb_open() failed with LIBUSB_ERROR_NOT_SUPPORTED
15 Error: libusb_open() failed with LIBUSB_ERROR_ACCESS
16 Error: open failed
17 in procedure 'init'
18 in procedure 'ocd_bouncer'
This happens because a wrong version of libusb is used to interface the ST-LINK Debug Interface.
Tosolvethis,downloadtheZadigutilityforyourWindowsversion.LaunchtheZadigtoolensuring
that your Nucleo board is plugged to the USB port, and go to the Option->List All Devices menu.
After a while the ST-LINK Debug (Interface 0) entry should appear inside the device list combo box.
If the installed driver is not the WinUSB one, then select it and click on Reinstall Driver button, as
shown below.
 http://zadig.akeo.ie/
Introduction to Debugging 149
5.1.2 Connecting to the OpenOCD Telnet Console
Once OpenOCD starts, it acts as a daemon program⁶ waiting for external connections. OpenOCD
offers two ways to interact with it. One of these is mode is through GDB (the GNU Debugger), as
we will see later. The other one is through a telnet ⁷ connection to the localhost port 4444 ⁸. Let us
start a connection.
$ telnet localhost 4444
Trying ::1...
telnet: connect to address ::1: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Open On-Chip Debugger
>
To access to the list of supported commands, we can type help . The list is quite huge, and its
content is outside of the scope of this book (the official OpenOCD document is a good place to
start understanding what those commands are used for). Here, we will simply see how to flash the
firmware.
Before we can upload a firmware to the target MCU of our Nucleo, we have to halt the MCU. This
is done issuing a reset init command:
Open On-Chip Debugger
> reset init
target state: halted
target halted due to debug-request, current mode: Thread
xPSR: 0x01000000 pc: 0x080002a8 msp: 0x20018000, semihosting
OpenOCD says to us that the micro is now halted and we can proceed to upload the firmware using
the flash write_image command:
⁶ Daemon is the way in UNIX to name those programs that works like a service. For example, a hTTP server or an FTP server is called a
daemon in UNIX. In the Windows world these kind of programs are called services.
⁷ Starting from Windows 7, telnet is an optional component to install. However, it is strongly suggested to use a more evolute telnet client
like putty (http://bit.ly/1jsQjnt).
⁸ Thedefaultportcanbechangedissuinga telnet_port commandinsidetheboardconfigurationfile.Thiscanbeusefulifwearedebugging
two different boards using two OpenOCD sessions, as we will see next.
Introduction to Debugging 150
> flash write_image erase <path to the .elf file>
auto erase enabled
Padding image section 0 with 3 bytes
target state: halted
target halted due to breakpoint, current mode: Thread
xPSR: 0x61000000 pc: 0x20000042 msp: 0xfffffffc, semihosting
wrote 16384 bytes from file <path to the .elf file> in 0.775872s (20.622 KiB/s) >
where <path to the .elf file> is the full path to the binary file (it is usually stored inside the
Debug subdirectory in the Eclipse project folder).
To start running our firmware we can simply type the reset command to the OpenOCD command
line.
ThereareotherfewOpenOCDcommandsthatmaybeusefulduringfirmwaredebugging,especially
when dealing with hardware faults. The reg commands shows the current status of all Cortex-M
core registries when the target MCU is halted:
> reset halt
...
> reg
===== arm v7m registers
(0) r0 (/32): 0x00000000
(1) r1 (/32): 0x00000000
...
Another group of useful commands are md[whb] to read a word, half-word and byte respectively.
For example, the command:
> mdw 0x8000000
0x08000000: 12345678
reads 32 bit (a word) from the address 0x8000 000 . The commands mw[whb] are the equivalent
commands to store data in a given memory location.
Now you can close the OpenOCD daemon sending the shutdown command to the telnet console.
This will also close the telnet session.
5.1.3 Configuring Eclipse
Now that we are familiar with the way OpenOCD works, we can configure Eclipse to debug our
applicationfromtheIDE.Thiswilldramaticallysimplifythedebuggingprocess,allowingustoeasily
set breakpoints in our code, to inspect the content of variables and to do step-by-step execution.
Eclipse is a generic and high configurable IDE, and it allows to create configurations that easily
integrate external tools like OpenOCD in its development life-cycle. The process we are going to
Introduction to Debugging 151
accomplish here is essentially to create a debug configuration. There are at least three ways to
integrate OpenOCD in Eclipse, but only one is probably the more convenient way when we deal
with the ST-LINK debugger.
We will configure OpenOCD as external debugging tool that we execute only once and leave as
daemon process, like we have done in the previous paragraph executing it from command line
prompt. The next step is to create a GDB debug configuration that instructs GDB to connect to
OpenOCD port 3333 and use it as GDB server.
Figure 3: The External Tools Configurations dialog
First, ensure that you have a project opened in Eclipse. Then, go toRun->External Tools->External
Tools Configurations… menu. The External Tools Configurations dialog appears. Highlight the
Program entry in the list view on the left and click on the New icon (the one circled in red in
Figure 3). Now, fill the following fields in this way:
• Name: write the name you like for this configuration; it is suggested to use OpenOCD FX,
where FX is the STM32 family of your Nucleo board (F0, F1, and so on).
• Location: choose the location of the OpenOCD executable ( C:\STM32Toolchain\openocd\bin\
openocd.exe for Windows users, ∼/STM32Toolchain/openocd/bin/openocd for Linux and Mac
OS users).
• Working directory: choose the location of the OpenOCD scripts directory
( C:\STM32Toolchain\openocd\scripts forWindowsusers, ∼/STM32Toolchain/openocd/scripts
for Linux and Mac OS users).
• Arguments: write the command line arguments for OpenOCD, that is “ -f board\<nucleo_-
conf_file.cfg> ” for Windows users and “ -f board/<nucleo_conf_file.cfg> ” for Linux and
Mac OS users. <nucleo_conf_file.cfg> must be substituted with the config file that fits your
Nucleo board, according to Table 1.
Whencompleted,clickontheApplybuttonandthanontheCloseone.Toavoidmistakesthatcould
Introduction to Debugging 152
cause confusion, Figure 4 shows how to fill the fields on Windows and Figure 5 on a UNIX-like
system (arrange the home directory accordingly).
Figure 4: How to fill the External Tools Configurations fields on Windows
Figure 5: How to fill the External Tools Configurations fields on UNIX systems
To launch OpenOCD now you can simply go to Run->External Tools menu and choose the
configuration you have created. If everything went the right way, you should see the classical
Introduction to Debugging 153
OpenOCD messages inside the Eclipse Console, as shown in Figure 6. At the same time, the LED
LD1 on the Nucleo board should start blinking GREEN and RED alternatively.
Figure 6: The OpenOCD output in the Eclipse console
Now we are ready to create a Debug Configuration to use GDB in conjunction with OpenOCD. This
operation must be repeated every time we create a new project.
Go to Run->Debug Configurations… menu. Highlight the GDB OpenOCD Debugging entry in
the list view on the left and click on the New icon (the one circled in red in Figure 7).
Figure 7: The Debug Configuration dialog
Eclipse fills automatically all the needed fields in the Main tab. However, if you are using a project
with several build configurations, you need to click on the Search Project button and choose the
ELF file for the active build configuration.
Introduction to Debugging 154
Unfortunately, sometimes Eclipse is not able to automatically locate the binary file. This is
probably a bug, or at least a weird behaviour. It may happens really often especially when
therearemorethanoneprojectopened.Toaddressthisissue,clickontheBrowsebuttonand
find the binary file in the project folder (usually you find it inside the <project-dir>/Debug
sub-directory).
Alternatively, another solution consists in closing the Debug Configuration dialog, then
refreshingthewholeprojecttree(byclickingwiththerightmousebuttonontheprojectroot
andselectingtheRefreshentry).YouwillnoticethatEclipseupdatesthecontentof Binaries
subfolder. Now you can re-open again the Debug Configuration dialog and complete the
configuration by clicking on the Search Project button.
Figure 8: The Debug Configuration dialog - Debugger section
Next,gointheDebuggertabandunchecktheentryStartOpenOCDlocally,sincewehavecreated
the specific OpenOCD external tool configuration. Ensure that all other fields are equal to the ones
shown in Figure 8.
Introduction to Debugging 155
Figure 9: The Debug Configuration dialog - Startup section
Now,gointheStartupsectionandleavealloptionsasdefaultbutdonotforgettoaddtheOpenOCD
command set remotetimeout 20 as shown in Figure 9.
What Do All Those Fields Mean?
If you take a pause and look at the fields in this section, you should recognize most of
commands we have typed when using the OpenOCD telnet session to load the firmware on
our Nucleo board.
The Initial reset checkbox is the equivalent of the reset init to reset the MCU. The Load
symbols and the Load executables are the equivalent flash write_image command⁹. Fi-
nally,the set remotetimeout 20 increasesthekeepalivetimebetweenGDBandOpenOCD,
which ensures that the OpenOCD backend is still alive. 20(ms) is a proven value to use.
⁹ Experienced STM32 users would dispute this sentence. They would be right: here we are issuing different GDB load commands, and not
the OpenOCD flash write_image command. However, for the sake of simplicity, consider that sentence true. A later chapter will explain this
better.
Introduction to Debugging 156
Figure 10: The Debug Configuration dialog - Common section
Finally, go in the Common section and check the option Shared file¹⁰ in Save as frame box and
check the entry Debug in Display in favorites menu frame box, as shown in Figure 10.
Click on the Apply button and then on the Close one. Now we are ready to start debugging.
5.1.4 Debugging in Eclipse
Eclipse provides a complete separated perspective dedicated to debugging. It is designed to offer the
most of required tools during the debugging process, and it can be customized at need adding other
views offered by additional plug-ins (more about this later).
¹⁰ This setting saves the debug configuration at project level, and not as global Eclipse setting. This will allow us to share the configuration
with other people if we work in team.
Introduction to Debugging 157
Figure 11: The Debug icon to start debugging in Eclipse
To start a new debug session using the debug configuration made earlier, you can click on the arrow
near the Debug icon on the Eclipse toolbar and choose the debug configuration, as shown in Figure
11. Eclipse will ask you if you want to switch to the Debug Perspective. Click on the Yes button (it
is strongly suggested to flag the Remember my decision checkbox). Eclipse switches to the Debug
Perspective, as shown in Figure 12.
Figure 12: The Debug Perspective
Let us see what each view is used for. The top-left view is called Debug and it shows all the
running debug activities. This is a tree-view, and the first entry represents the OpenOCD process
launchedusingtheexternaldebugconfiguration.WecaneventuallystoptheexecutionofOpenOCD
Introduction to Debugging 158
highlighting the executable program and clicking on the Terminate icon on the Eclipse toolbar, as
shown in Figure 13.
Figure 13: How to terminate the execution of a debug activity
The second activity showed in the Debug view represents the GDB process. This activity is really
useful, because when the program is halted the complete call stack is shown here and it offers a
quick way to navigate inside the call stack.
Figure 14: The variables inspection pane in the debug perspective
The top-right view contains several sub-panes. The Variables one offers the ability to inspect the
content of variables defined in the current stack frame (that is, the selected procedure in the call
stack). Clicking on an inspected variable with the right button of mouse, we can further customize
thewaythevariableisshown.Forexample,wecanchangeitsnumericrepresentation,fromdecimal
(the default one) to hexadecimal or binary form. We can also cast it to a different datatype (this is
Introduction to Debugging 159
really useful when we are dealing with raw amount of data that we know to be of a given type - for
example, a bunch of bytes coming from a stream file). We can also go to the memory address where
the variable is stored clicking on the View Memory… entry in the contextual menu.
The Breakpoint pane lists all the used breakpoints in the application. A breakpoint is a hardware
primitive that allows to stop the execution of the firmware when the Program Counter(PC) reaches
a given instruction. When this happens, the debugger is warned and Eclipse will show the context
of the halted instruction. Every Cortex-M base MCU has a limited number of hardware breakpoints.
Table 2 summarizes the maximum breakpoints and watchpoints¹¹ for a given Cortex-M family.
Table 2: Available breakpoints/watchpoints in Cortex-M cores
Cortex-M Breakpoints Watchpoints
M0/0+ 4 2
M3/4/7 6 4
Figure 15: How to add a breakpoint at a given line number
Eclipseallowstoeasilysetupbreakpointsinsidethecodefromtheeditorviewinthecenterof Debug
perspective. To place a breakpoint, simply double-click on the blue stripe on the left of the editor,
near to the instruction where we want to halt the MCU execution. A blue bullet will appear, as
shown in Figure 15.
When the program counter reaches the first assembly instruction constituting to that line of code,
the execution is halted and Eclipse shows the corresponding line of code as shown in Figure 12.
Once we have inspected the code, we have several options to resume the execution.
¹¹ A watchpoint, indeed, is a more advanced debugging primitive that allows to define conditional breakpoints over data and peripheral
registers, that is the MCU halts its execution only if a variable satisfies an expression (e.g. var == 10 ). We will analyze watchpoints in Chapter
24.
Introduction to Debugging 160
Figure 16: The Eclipse debug toolbar
Figure16showstheEclipsedebugtoolbar.Thehighlightediconsallowtocontrolthedebugprocess.
Let us see each of them in depth.
• Skipallbreakpoints:thistoggleiconallowstotemporarilyignoreallthebreakpointused.This
allows to run the firmware without interruption. We can resume breakpoints by deactivating
the icon.
• Resume execution: this icon restarts the execution of the firmware from the current PC. The
adjacent icon, the pause, will stop the execution on request.
• Stop debug: this icon causes the end of the debug session. GDB is terminated and the target
board is halted.
• Step into routine: this icon is the first one of two icons used to do step-by-step debugging.
When we execute the firmware line-by-line, it could be important to enter inside a called
routine. This icon allows to do this, otherwise the next icon is what needed to execute the next
instruction inside the current stack frame.
• Step over: the next icon of the debug toolbar has a counterintuitive name. It is calledstep over,
and its name might suggest “skip the next instruction” (that is, go over). But this icon is the
one used to execute the next instruction. Its name comes from the fact that, unlike the previous
icon, it executes a called routine without entering inside it.
• Reset MCU: this icon is used to do a soft reset of MCU, without stopping the debug and
relaunch it again.
Finally, another interesting pane of that view is the Registers one. It displays the content of all
Cortex-M registers and it is the equivalent of the reg OpenOCD command we have seen before.
Introduction to Debugging 161
It can be really useful to understand the current state of the Cortex-M core. In Chapter 24 about
debugging we will see how to deal with Cortex-M exceptions and we will learn how to interpret the
content of some important Cortex-M registers.
5.2 ARM Semihosting
ARM semihosting is a distinctive feature of the Cortex-M platform, and it is extremely useful for
testing and debug purpose. It is a mechanism that allows target boards (e.g. the Nucleo board) to
“exchange messages” from the embedded firmware to a host computer running a debugger. This
mechanism enables some functions in the C library, such as printf() and scanf() , to use the screen
andkeyboardofthehostinsteadofhavingascreenandkeyboardonthetargetsystem.Thisisuseful
because development hardware often does not have all the input and output facilities of the final
system. Semihosting enables the host computer to provide these facilities.
Semihosting requires additional runtime library code and it can be implemented in several ways
on Cortex-M architecture. However, the preferred one is by the use of the bktp ARM assembly
instruction, the one used by the debugger to set breakpoints. Luckily for us, Liviu Ionescu has
alreadypackedinhisGNUMCUEclipsepluginaworkingsupportforthemostcommonsemihosting
operations. So it is extremely easy to enable this feature for our projects. However, a deep
understanding of how semihosting works can dramatically simplify the debug process in certain
critical operations.
The next paragraph will give a quick explanation of how to configure our Eclipse project to use
semihosting in our code. This will allows us to print messages on the OpenOCD console. This is a
fantastic debug tool, especially when you need to understand what is happening to your firmware.
5.2.1 Enable Semihosting on a New Project
GNU MCU plug-in allows to easily enable semihosting support during the project generation. We
already encountered these options so far, but for the sake of simplicity we did not care about them.
Now it is the right time to have a look. Let us generate a new project.
Introduction to Debugging 162
Figure 17: Project settings needed to enable semihosting
GotoFile->New->CProjectmenu.SelecttheHelloWorldARMCortex-MC/C++projecttypeand
choosetheprojectnameyoulike.Inthenextstep,compiletheCortex-Mcorerelatedfieldsaccording
yourtargetboard.Choose“Freestanding(noPOSIXsystemcalls)”forthefieldUsesystemcallsand
“Semihosting DEBUG channel” for the field Trace output. Continue with the project wizard until
it finishes. Next, import the ST HAL and project skeleton from CubeMX as described in Chapter 4.
Now we have a project ready to use semihosting. The tracing routines are available inside the
system/src/diag/Trace.c file. They are:
• trace_printf() : it is the equivalent of C printf() function. It allows to format string with a
variable number of parameters, and it adopts the same string formatting convention of the C
programming languange.
• trace_puts() : writes a string to the debug console terminating it with a newline char '\n'
automatically.
• trace_putchar() : writes one char to the debug console.
• trace_dump_args() it is a convenient routine that automatically does pretty printing of
command line arguments.
The following example shows how to use the trace_printf() function.
Introduction to Debugging 163
Filename: src/main-ex1.c
34 #include "stm32f4xx_hal.h"
35 #include "diag/Trace.h"
36
37 void SystemClock_Config(void);
38 static void MX_GPIO_Init(void);
39
40 int main(void)
41 {
42 char msg[] = "Hello STM32 lovers!\n";
43
44 HAL_Init();
45 SystemClock_Config();
46 MX_GPIO_Init();
47
48 trace_printf(msg);
49
50 while(1) {
51 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
52 HAL_Delay(500);
53 }
54 }
First of all, to use tracing routines we have to correctly import the Trace.h header file, as done at
line 35. Next, at line 48, we call the trace_printf() function passing a string to print. The rest of
the main() simply blinks the Nucleo LD2 for ever.
Read Carefully
Semihosting implementation in OpenOCD is designed so that every string must be termi-
nated with the newline character ( \n ) before the string appears on the OpenOCD console.
This is a really common error, and it leads to a lot of frustration the first times programmers
start using it. Never forget to terminate every string passed to trace_printf() or the C
printf() routine with the ( \n ).
To use semihosting we need one more important step: we have to instruct OpenOCD to enable
it. Create a new Debug configuration as shown in the previous paragraphs, but ensure that in the
Startup section the entry Enable ARM semihosting is checked, as shown in Figure 9 (this is the
default behavior, but it is better to give a look). Ok. Now we are ready to launch our firmware. The
“ Hello STM32 lovers ” string will appear on the OpenOCD console, as shown in Figure 18.
Introduction to Debugging 164
Figure 18: The output string coming from the Nucleo routed on the OpenOCD console
Sometimes, it happens that the OpenOCD console is not shown automatically when
a message is printed, but the GDB console remains active. You can switch to
OpenOCD console clicking on the console icon (circled in red in the image below).
This behavior can be changed by going in the global Eclipse preferences->Run/Debug-
>Console and checking the Show when program writes to standard out flag.
5.2.1.1 Using Semihosting With C Standard Library
Crun-timelibraryprovidesseveralfunctionsusedtodoI/Omanipulation,likethe printf() / scanf()
routines for terminal output/input management and the file manipulation functions ( fopen() ,
fseek() and so on). These functions are built around low-level services provided by the underlying
operating system, also called system calls.
STM32applicationsdevelopedwithGCCareautomaticallylinkedwiththe newlib-nano ,alightweight
version of the standard C/C++ library explicitly designed to work with microcontrollers. newlib-
Introduction to Debugging 165
nano does not provide an implementation of low-level system calls. It is our responsibility to provide
animplementationforthosefunctionsifweneedtousethem.Sincethetargetboardlacksofterminal
management capabilities (no screen and no input devices), we can use semihosting to route those
low-level functions to the host debugger, that is OpenOCD.
Figure 19: How syscalls are routed to debugger using semihosting
Figure 19 clearly shows the whole process. For example, let us consider the printf() function.
When we invoke it in our firmware, newlib transfers the control to the _write() routine. So, we
have to provide our implementation of this function that sends the string to OpenOCD, which in
turns display it on the Host PC console.
Liviu Ionescu has already packed in his plugin the most used low-levels system calls. We only need
to enable their compilation, and we can start using the classical C run-time I/O manipulation envi-
ronment. To enable it, go to Project->Properties menu. Next go inside the C/C++ Build->Settings
section. In the Optimization section, uncheck the entry Assume freestanding environment (-
ffreestanding). Click on the OK button, go to Project->Clean.. and rebuild the whole project.
Introduction to Debugging 166
What Does Exactly Mean Freestanding Environment?
The standard C not only precisely defines the main language, but it also characterizes
some libraries that are considered essential part of the language itself. For example, strings
management, sorting and comparison, character manipulation and similar services are
invariably expected in all C compilers implementation. Some of these libraries function
inevitably rely on the underlying Operating Systems. For example, it is almost impossible to
talk about file manipulation routines without the underlying notion of filesystem ( open() ,
write() , etc.). The same happens for terminal management functions ( printf() , scanf() ,
etc.).
The standard defines as hosted environment a run-time environment that provides all
the standard library functions, including those functions that need some underlying OS
services to accomplish their task. Instead, it defines as freestanding environment a run-time
environment that does not rely on the underling OS and, hence, it does not provide all those
standard library functions related to “more low-level” activities.
When coding applications for the bare metal (that is, when we develop applications for em-
bedded devices like the STM32 platform) is common to assume a freestanding environment.
Otherwise, it is our responsibility to provide those low-level routines ( _write() , _seek() ,
and so on) which the standard library assumes in its standard library functions.
The following code can be used to test if all works correctly.
Filename: src/main-ex2.c
34 #include "stm32f4xx_hal.h"
35 #include <string.h>
36
37 void SystemClock_Config(void);
38 static void MX_GPIO_Init(void);
39
40 int main(void)
41 {
42 char msg[20], name[20];
43
44 HAL_Init();
45 SystemClock_Config();
46 MX_GPIO_Init();
47
48 printf("What's your name?: \r\n");
49 scanf("%s", name);
50 sprintf(msg, "Hello %s!\r\n", name);
51 printf(msg);
52
53 FILE *fd = fopen("/tmp/test.out", "w+");
54 fwrite(msg, sizeof(char), strlen(msg), fd);
55 fclose(fd);
The code is really self-explaining. It uses standard C functions like printf() and scanf() to print
Introduction to Debugging 167
and to retrieve a string from the OpenOCD console (lines 48-51). Next it opens the test.out file in
the /tmp folder on the host PC¹² and it writes the same string inside it (lines 53-55).
This feature is extremely useful in many situations. For example, it can be used to log firmware
activities inside a file on the PC for debugging purpose. Another example is a web server running
on a target board, and all HTML files resides on the host PC: you are free to change them to test
how they render without the need to re-flash the target file every time you change it.
5.2.2 Enable Semihosting on an Existing Project
If you have an existing project and you want to enable semihosting, we need to distinguish between
two cases.
The first one is the more simple. If you have generated the project using the GNU MCU plug-in, you
only need to add the following global macro to project settings:
• If you want to use only the trace_printf() functions from Liviu Ionescu, then add the macros
TRACE and OS_USE_TRACE_SEMIHOSTING_DEBUG .
• If you want to use the C standard library I/O manipulation functions, then add the macro OS_-
USE_SEMIHOSTING and uncheck the flag Assume freestanding environment (-ffreestanding).
The second case is the more complex. You have an existing project imported in Eclipse that has not
been generated using the GNU MCU Eclipse plugin. If it is sufficient to use the trace_printf()
function, then you can import inside your project these files taken from a project generated with the
GNU MCU plugin:
• src/diag/trace_impl.c
• src/diag/Trace.c
• include/diag/Trace.h
Next, you have to define the macros TRACE and OS_USE_TRACE_SEMIHOSTING_DEBUG at project level
and to call the routine initialise_monitor_handles() in your main() routine.
In case you want to use all standard C library I/O routines, you need to:
• import inside your project the src/newlib/_syscalls.c file;
• define the macro OS_USE_SEMIHOSTING at project level;
• uncheck the flag Assume freestanding environment (-ffreestanding);
• call the routine initialise_monitor_handles() in your main() routine.
¹² Windows users have to rearrange the path accordingly. For example, use C:\Temp\test.out ¹³ as filename.
Introduction to Debugging 168
5.2.3 Semihosting Drawbacks
Semihosting is an excellent feature, but it has also several drawbacks. First of all, it works only
during a debug session, and it completely hangs the firmware if not running under the GDB control.
For example, upload one of the previous examples on your Nucleo board and terminate the debug
session. If you reset your board pressing the RESET button, you will not see the LD2 LED blinking.
This happens because the firmware is stuck in the trace_printf() routine (more about why this
happens in the next paragraph). This is a really common issue that every novice encounters every
time it starts working with the STM32 platform.
Another important aspect to keep in mind is that semihosting has a great impact on the firmware
performance. Every semihosting call costs several CPU cycles, and it impacts on the overall
performance.Moreover,thiscostinunpredictable,becauseitinvolvesactivitiesthathappensoutside
the MCU execution streams (more about this in the next paragraph).
In Chapter 8 we will see another interesting technique to exchange messages with the host PC using
one of the STM32 USARTs.
5.2.4 Understanding How Semihosting Works
If you are new to the STM32 world and you are a little bit confused by its initial complexity, you can
stopreadingthisparagraphandjumptonextchapter.Whatwewillbedescribedhereisanadvanced
topic, that needs a bit of understanding of how ARM architecture works and some advanced GCC
features. It is not required you read this paragraph, but having a look at it could improve your global
understanding.
There are several ways to implement semihosting capabilities. One of this is through the use
of software breakpoints. ARM Cortex-M offers two types of breakpoints: Hardware (HBP) and
Software (SBP) breakpoints.
HBP is set by programming the Break Point Unit (a hardware unit inside every Cortex-M core) to
monitor the core buses for an instruction fetch from a specific memory location. HBP can be set
on any location in RAM or ROM using an external physical programmer connected to the Debug
Interface. In case of the Nucleo board, the integrated ST-LINK programmer is connected to the MCU
Debug Interface, and it is in turn managed by OpenOCD. Figure 20 shows the relation between the
external debugger and the internal MCU debug unit.
Introduction to Debugging 169
Figure 20: Debug components in Cortex-M microcontrollers
SWP are implemented by adding a special bkpt instruction immediately before the code we want
to inspect. When the core executes the breakpoint instruction, it will be forced into debug state. The
debugger sees that the MCU is halted and start debugging the MCU. The bkpt instruction accepts
an immediate 8-bit opcode, which can be used to specify particular break condition. If you want to
halt the execution of your firmware and transfer the control to the debugger, then the instruction:
asm("bkpt #0")
iswhatyouneed.Thistechniqueisusedtoimplementsoftwareconditionalbreakpoint.Forexample,
suppose you have a strange fault condition that you need to inspect. You could have a piece of code
like the following one:
if(cond == 0) {
...
} else if(cond > 0) {
...
} else { /* Abnormal state, let us debug it */
asm("bkpt #0");
}
In the above code, if cond variable assumes a negative value, the MCU is halted and the control is
transferred to GDB, which allows us to inspect the call stack and the current stack frame.
Semihosting is implemented using the special immediate opcode 0xAB . That is, the instruction:
asm("bkpt #0xAB")
causes the MCU to stop, but this time OpenOCD sees the special opcode and interprets it as
semihosting operation. By convention, the r0 register contains the type of operation ( _write() ,
Introduction to Debugging 170
_read() ,etc)andthe r1 registercontainsthepointertotheregionofmemorycontainingthefunction
parameters. For example, if we want to write a null terminated string on the host PC console, then
we can write the following assembly instructions:
asm (
"mov r0, 0x4 \n" /* OPCODE for WRITE0 */
"mov r1, 0x20001400 \n" /* address of string to transfer to OpenOCD */
"bkpt #0xAB"
);
Table 3 summarizes the supported semihosting operations. Please, take note that OpenOCD
currently does not support all of them.
The following complete C code shows how to implement the trace_printf() function.
Filename: src/main-ex3.c
34 #include "stm32f4xx_hal.h"
35
36 void SystemClock_Config(void);
37 static void MX_GPIO_Init(void);
38
39 int main(void)
40 {
41 char msg[] = "Hello STM32 lovers!\n";
42
43 HAL_Init();
44 SystemClock_Config();
45 MX_GPIO_Init();
46
47 asm volatile (
48 " mov r0, 0x4 \n"
49 " mov r1, %[msg] \n"
50 " bkpt #0xAB"
51 :
52 : [msg] "r" (msg)
53 : "r0", "r1"
54 );
55
56 while(1);
57 }
Here we use the capabilities of GCC asm() function to pass the pointer of the msg buffer, containing
the string “ Hello STM32 lovers!\n ”.
Now you can understand why semihosting causes the MCU to become stuck if the debugger is not
active. The bkpt instruction halts the MCU execution, and there is no way to restore it without
Introduction to Debugging 171
using an external debugger (or doing a hardware reset). Moreover, every time the bkpt instruction
is issued, the internal MCU activities are suspended until the control passes to the debugger. During
this time, important asynchronous events (like interrupts generated by peripherals) could be lost.
This interval time is totally unpredictable, and it depends on many factors (speed of the hardware
interface, current Host PC load, speed of ST-LINK firmware, etc., etc.).
Table 3: Summary of semihosting operations
Semihosting operation immediate opcode Description
EnterSVC 0x17 Sets the processor to Supervisor mode and disables all
interrupts by setting both interrupt mask bits in the new
CPSR.
ReportException 0x18 This SVC can be called by an application to report an
exception to the debugger directly. The most common use
is to report that execution has completed, using
ADP_Stopped_ApplicationExit.
SYS_CLOSE 0x02 Closes a file on the host system. The handle must
reference a file that was opened with SYS_OPEN.
SYS_CLOCK 0x10 Returns the number of centiseconds since the execution
started.
SYS_ELAPSED 0x30 Returns the number of elapsed target ticks since
execution started. Use SYS_TICKFREQ to determine the
tick frequency.
SYS_ERRNO 0x13 Returns the value of the C library errno variable
associated with the host implementation of the
semihosting SVCs.
SYS_FLEN 0x0C Returns the length of a specified file.
SYS_GET_CMDLINE 0x15 Returns the command line used to call the executable,
that is, argc and argv.
SYS_HEAPINFO 0x16 Returns the system stack and heap parameters. The
values returned are typically those used by the C library
during initialization.
SYS_ISERROR 0x08 Determines whether the return code from another
semihosting call is an error status or not. This call is
passed a parameter block containing the error code to
examine.
SYS_ISTTY 0x09 Checks whether a file is connected to an interactive
device.
SYS_OPEN 0x01 Opens a file on the host system. The file path is specified
either as relative to the current directory of the host
process, or absolute, using the path conventions of the
host operating system.
SYS_READ 0x06 Reads the contents of a file into a buffer.
SYS_READC 0x07 Reads a byte from the console.
SYS_REMOVE 0x0E Deletes a specified file on the host filing system.
SYS_RENAME 0x0F Renames a specified file.
Introduction to Debugging 172
Table 3: Summary of semihosting operations
Semihosting operation immediate opcode Description
SYS_SEEK 0x0A Seeks to a specified position in a file using an offset
specified from the start of the file. The file is assumed to
be a byte array and the offset is given in bytes.
SYS_SYSTEM 0x12 Passes a command to the host command-line interpreter.
This enables you to execute a system command such as
dir , ls , or pwd . The terminal I/O is on the host, and is not
visible to the target.
SYS_TICKFREQ 0x31 Returns the tick frequency.
SYS_TIME 0x11 Returns the number of seconds since 00:00 January 1,
1970.
SYS_TMPNAM 0x0D Returns a temporary name for a file identified by a
system file identifier.
SYS_WRITE 0x05 Writes the contents of a buffer to a specified file at the
current file position. Current OpenOCD implementation
expects that the buffer is terminated with the newline
character ( \n ).
SYS_WRITEC 0x03 Writes a character byte, pointed to by R1, to the debug
channel. When executed under an ARM debugger, the
character appears on the host debugger console.
SYS_WRITE0 0x04 Writes a null-terminated string to the debug channel.
When executed under an ARM debugger, the characters
appear on the host debugger console.
II Diving into the HAL
6. GPIO Management
With the advent of the STCube initiative, ST has decided to completely revamp the Hardware
Abstraction Layer (HAL) for its STM32 microcontrollers. Prior to the release of the STCube HAL,
the official library to develop STM32 applications was for a long time the Standard Peripheral
Library. Despite of the fact it is still widespread between STM32 developers, and you can find a
lot of examples on the web using this library, the STCube HAL is a great improvement respect of
the old Standard Peripheral Library. In fact, being the first library developed by ST, not all of its
parts were consistent between different STM32 families and a lot of bugs were present in the early
versionsofthelibrary.ThiscausedtheemergenceofdifferentalternativestotheStandardPeripheral
Library, and the official software from ST is still considered poor by many people.
So, ST has completely redesigned the HAL and, even if it still needs a little bit of tuning, it is what
ST will officially support in the future. Moreover, the new HAL simplifies a lot the porting of code
betweentheSTM32sub-families(F0,F1,etc.),reducingtheeffortneededtoadaptyourapplicationto
a different MCU (without a good abstraction layer, the pin-to-pin compatibility is just an advantage
from the marketing point of view). For this and several other reasons, this book is based exclusively
on the STCube HAL.
This chapter starts our journey inside the HAL looking to one of its simplest modules: HAL_GPIO . We
have already used many functions from this module in the early examples in this book, but now it is
the right time to understand all possibilities offered by a so simple and commonly used peripheral.
However, before we can start describing HAL features, it is best to give a quick look at how the
STM32 peripherals are mapped to logical addresses and how they are represented inside the HAL
library.
6.1 STM32 Peripherals Mapping and HAL Handlers
Every STM32 peripheral is interconnected to the MCU core by several orders of buses, as shown in
Figure 1¹.
¹ Here, to simplify this topic, we are considering the bus organization of one of the simplest STM32 microcontrollers, the STM32F030.
STM32F4 and STM32F7, for example, have a more advanced bus interconnection system, which is outside the scope of this book. Please,
always refer to the reference manual of your MCU.
GPIO Management 175
Figure 1: Bus architecture of an STM32F030 microcontroller
• The System bus connects the system bus of the Cortex-M core to a BusMatrix, which manages
the arbitration between the core and the DMA. Both the core and the the DMA act as masters.
• The DMA bus connects the Advanced High-performance Bus(AHB) master interface of the
DMA to the BusMatrix, which manages the access of CPU and DMA to SRAM, flash memory
and peripherals.
• The BusMatrix manages the access arbitration between the core system bus and the DMA
master bus. The arbitration uses a Round Robin algorithm. The BusMatrix is composed of two
masters (CPU, DMA) and four slaves (flash memory interface, SRAM, AHB1 with AHB to
Advanced Peripheral Bus(APB) bridge and AHB2). AHB peripherals are connected on system
bus through a BusMatrix to allow DMA access.
• The AHB to APB bridge provides full synchronous connections between the AHB and the APB
bus, where the most of peripherals are connected.
As we will see in a later chapter, each of these buses is connected to different clock sources, which
determine the maximum speed for the peripheral connected to that bus².
In Chapter 1 we have learned that peripherals are mapped to a specific region of the 4GB address
space, starting from 0x4000 0000 and lasting up to 0x5FFF FFFF . This region is further divided in
several sub-regions, each one mapped to a specific peripheral, as shown in Figure 2.
² For some of you the above description may be unclear and too complex to understand. Don’t worry and keep reading the next content
in this chapter. They will become clear once you reach the chapter dedicated to the DMA.
GPIO Management 176
Figure 2: Memory map of peripheral regions for an STM32F030 microcontroller
Thewaythisspaceisorganized,andhencehowperipheralsaremapped,isspecificofagivenSTM32
microcontroller. For example, in an STM32F030 microcontroller the AHB2 bus is mapped to the
region ranging from 0x4800 0000 to 0x4800 17FF . This means that the region is 6144 bytes wide.
Thisregionisfurtherdividedinseveralsub-regions,eachonecorrespondingtoaspecificperipheral.
Following the previous example, the GPIOA peripheral (which manages all pins connected to the
PORT-A) is mapped from 0x4800 0000 to 0x4800 03FF , which means that it occupies 1KB of aliased
peripheral memory. How this memory-mapped space is in turn organized depends on the specific
peripheral. Table 1³ shows the memory layout of a GPIO peripheral.
Figure 3: GPIO MODER register memory layout
³ Both Table 1 and Figure 1 are taken from the ST STM32F030 Reference Manual (http://bit.ly/1GfS3iC).
GPIO Management 177
Table 1: GPIO peripheral memory map for an STM32F030 microcontroller
Aperipheraliscontrolledmodifyingandreadingeachregisterofthesemappedregions.Forexample,
continuingtheexampleofthe GPIOA peripheral,toenablePA5pinasoutputpinwehavetoconfigure
GPIO Management 178
the MODER register so that bits[11:10] are configured as 01 (which corresponds to General purpose
output mode), as shown in Figure 3. Next, to pull the pin high, we have to set the corresponding
bit[5] inside the Output Data Register(ODR), which according Table 1 is mapped to the GPIOA +
0x14 memory location, that is 0x4800 0000 + 0x14 .
The following minimal example shows how to use pointers to access to the GPIOA peripheral
mapped memory in an STM32F030 MCU.
int main(void) {
volatile uint32_t *GPIOA_MODER = 0x0, *GPIOA_ODR = 0x0;
GPIOA_MODER = (uint32_t*)0x48000000; // Address of the GPIOA->MODER register
GPIOA_ODR = (uint32_t*)(0x48000000 + 0x14); // Address of the GPIOA->ODR register
// This ensure that the peripheral is enabled and connected to the AHB1 bus
__HAL_RCC_GPIOA_CLK_ENABLE();
*GPIOA_MODER = *GPIOA_MODER | 0x400; // Sets MODER[11:10] = 0x1
*GPIOA_ODR = *GPIOA_ODR | 0x20; // Sets ODR[5] = 0x1, that is pulls PA5 high
while(1);
}
It is important to clarify once again that every STM32 family (F0, F1, etc.) and every member of
the given family (STM32F030, STM32F1, etc.) provides its subset of peripherals, which are mapped
to specific addresses. Moreover, the way how peripherals are implemented differs between STM32-
series.
One of the HAL roles is to abstract from the specific peripheral mapping. This is done by defining
several handlers for each peripheral. A handler is nothing more then a C struct , whose references
are used to point to real peripheral address. Let us see one of them.
In the previous chapters, we have configured the PA5 pin with the following code:
/*Configure GPIO pin : PA5 */
GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
Here, the GPIOA variable is a pointer of type GPIO_TypeDef defined in this way:
GPIO Management 179
typedef struct {
volatile uint32_t MODER;
volatile uint32_t OTYPER;
volatile uint32_t OSPEEDR;
volatile uint32_t PUPDR;
volatile uint32_t IDR;
volatile uint32_t ODR;
volatile uint32_t BSRR;
volatile uint32_t LCKR;
volatile uint32_t AFR[2];
volatile uint32_t BRR;
} GPIO_TypeDef;
The GPIOA pointer is defined so that it points⁴ to the address 0x4800 0000 :
GPIO_TypeDef *GPIOA = 0x48000000;
GPIOA->MODER |= 0x400;
GPIOA->ODR |= 0x20;
6.2 GPIOs Configuration
Every STM32 microcontroller has a variable number of general programmable I/Os. The exact
number depends on:
• The type of package chosen (LQFP48, BGA176, and so on).
• The family of microcontroller (F0, F1, etc.).
• The usage of external crystals for HSE and LSE.
GPIOs are the way an MCU communicates with the external world. Every board uses a variable
number of I/Os to drive external peripherals (e.g. an LED) or to exchange data through several types
of communication peripherals (UART, USB, SPI, etc.). Every time we need to configure a peripheral
that uses MCU pins, we need to configure its corresponding GPIOs using the HAL_GPIO module.
As seen before, the HAL is designed so that it abstracts from the specific peripheral memory
mapping. But, it also provides a general and more user-friendly way to configure the peripheral,
without forcing the programmers to now how to configure its registers in detail.
ToconfigureaGPIOweusethe HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_-
Init) function. GPIO_InitTypeDef is the C struct used to configure the GPIO, and it is defined in
the following way:
⁴ This not exactly true, since the HAL, to save RAM space, defines GPIOA as a macro ( #define GPIOA ((GPIO_TypeDef *) GPIOA_BASE) ).
GPIO Management 180
typedef struct {
uint32_t Pin;
uint32_t Mode;
uint32_t Pull;
uint32_t Speed;
uint32_t Alternate;
} GPIO_InitTypeDef;
This is the role of each field of the struct :
• Pin : it is the number, starting from 0, of the pins we are going to configure. For example, for
PA5 pin it assumes the value GPIO_PIN_5 ⁵. We can use the same GPIO_InitTypeDef instance
to configure several pins at once, doing a bitwise OR (e.g., GPIO_PIN_1 | GPIO_PIN_5 | GPIO_-
PIN_6 ).
• Mode : it is the operating mode of the pin, and it can assume one of the values in Table 2. More
about this field soon.
• Pull : specifies the Pull-up or Pull-Down activation for the selected pins, according Table 3.
• Speed : defines the pin speed. More about this later.
• Alternate : specifies which peripheral to associate to the pin. More about this later.
Table 2: Available GPIO_InitTypeDef.Mode for a GPIO
Pin Mode Description
GPIO_MODE_INPUT Input Floating Mode ⁶
GPIO_MODE_OUTPUT_PP Output Push Pull Mode
GPIO_MODE_OUTPUT_OD Output Open Drain Mode
GPIO_MODE_AF_PP Alternate Function Push Pull Mode
GPIO_MODE_AF_OD Alternate Function Open Drain Mode
GPIO_MODE_ANALOG Analog Mode
GPIO_MODE_IT_RISING External Interrupt Mode with Rising edge trigger detection
GPIO_MODE_IT_FALLING External Interrupt Mode with Falling edge trigger detection
GPIO_MODE_IT_RISING_FALLING External Interrupt Mode with Rising/Falling edge trigger detection
GPIO_MODE_EVT_RISING External Event Mode with Rising edge trigger detection
GPIO_MODE_EVT_FALLING External Event Mode with Falling edge trigger detection
GPIO_MODE_EVT_RISING_FALLING External Event Mode with Rising/Falling edge trigger detection
Table 3: Available GPIO_InitTypeDef.Pull modes for a GPIO
Pin Mode Description
GPIO_NOPULL No Pull-up or Pull-down activation
⁵ Take note that the GPIO_PIN_x is a bit mask, where the i-th pin corresponds to the i-th bit of a uint16_t datatype. For example, the
GPIO_PIN_5 has a value of 0x0020 , which is 32 in base 10.
⁶ During and just after reset, the alternate functions are not active and all the I/O ports are configured in Input Floating mode.
GPIO Management 181
Table 3: Available GPIO_InitTypeDef.Pull modes for a GPIO
Pin Mode Description
GPIO_PULLUP Pull-up activation
GPIO_PULLDOWN Pull-down activation
6.2.1 GPIO Mode
STM32 MCUs provide a really flexible GPIOs management.Figure 4⁷ shows the hardware structure
of a single I/O of an STM32F030 microcontroller.
Figure 4: Basic structure of an I/O port bit
Depending on the GPIO GPIO_InitTypeDef.Mode field, the MCU changes the way the hardware of
an I/O works. Let us have a look at the main modes.
When the I/O is configured as GPIO_MODE_INPUT :
• The output buffer is disabled.
• The Schmitt trigger input is activated.
• The pull-up and pull-down resistors are activated depending on the value of the Pull field.
• The data present on the I/O pin are sampled into the input data register every AHB clock cycle.
• A read access to the input data register provides the I/O state.
When the I/O port is programmed as GPIO_MODE_ANALOG :
⁷ The figure is taken from the ST STM32F030 Reference Manual (http://bit.ly/1GfS3iC).
GPIO Management 182
• The output buffer is disabled.
• The Schmitt trigger input is deactivated, providing zero consumption for every analog value
of the I/O pin.
• The weak pull-up and pull-down resistors are disabled by hardware.
• Read access to the input data register gets the value 0 .
When the I/O port is programmed as output:
• The output buffer is enabled as follow:
– if mode is GPIO_MODE_OUTPUT_OD : A 0 in the Output register (ODR) activates the N-MOS
whereas a 1 leaves the port in Hi-Z (the P-MOS is never activated);
– if mode is GPIO_MODE_OUTPUT_PP : A 0 in the ODR activates the N-MOS whereas a 1
activates the P-MOS.
• The Schmitt trigger input is activated.
• The pull-up and pull-down resistors are activated depending on the value of the Pull field.
• The data present on the I/O pin are sampled into the input data register every AHB clock cycle.
• A read access to the input data register gets the I/O state.
• A read access to the output data register gets the last written value.
When the I/O port is programmed as alternate function: * The output buffer can be configured
in open-drain or push-pull mode. * The output buffer is driven by the signals coming from the
peripheral (transmitter enable and data). * The Schmitt trigger input is activated. * The weak pull-
up and pull-down resistors are depending on the value of the Pull field. * The data present on the
I/O pin are sampled into the input data register every AHB clock cycle. * A read access to the input
data register gets the I/O state.
The GPIO modes GPIO_MODE_EVT_* are related to sleep modes. When an I/O is configured to work in
one of these modes, the CPU will be woken up (when placed in sleep mode with a WFE instruction) if
the corresponding I/O is triggered, without generating the corresponding interrupt (more about this
topicinChapter19).TheGPIOmodes GPIO_MODE_IT_* modesarerelatedtointerruptsmanagement,
and they will be analyzed in the next chapter.
However, keep in mind that this implementation scheme can vary between the STM32-families,
especially for the low-power series. Always refer to the reference manual of your MCU, which
exactly describes I/O modes and their impact on the MCU working and power consumption.
It is also important to remark that this flexibility represents an advantage for the hardware design
too.Forexample,ifyouneedexternalpull-upresistorsinyourapplicationthereisnoneedtouseex-
ternal anddedicated ones,since thecorresponding GPIOscan beconfigured setting GPIO_InitType-
Def.Mode = GPIO_MODE_OUTPUT_PP and GPIO_InitTypeDef.Pull = GPIO_PULLUP . This saves space
on the PCB and simplifies the BOM.
GPIO Management 183
Figure 5: Pin Configuration dialog can be used to configure I/O mode
I/O mode can be eventually configured using the CubeMX tool, as shown in Figure 5. Pin
Configuration dialog can be reached inside the Configuration view, clicking on the GPIO button.
6.2.2 GPIO Alternate Function
Most of GPIOs have “alternate functions”, that is they can be used as I/O pin for at least one internal
peripheral. However, keep in mind that an I/O can be associated to only one peripheral at a time.
Figure 6: CubeMX can be easily used to discover alternate functions of an I/O
To discover which peripherals can be bound to an I/O, you can refer to the MCU datasheet or simply
use the CubeMX tool. Clicking on a pin in the Pin View causes a pop-up menu to appear. In this
menu we can set the wanted alternate function. For example, in Figure 6 you can see that PA3 can
be used as USART2_RX (that is, it can be used as RX pin for USART/UART2 peripheral, and this is
possible for every STM32 MCU with LQFP48 package). CubeMX will automatically generate the
right initialization code for us, as shown below:
GPIO Management 184
/* Configure GPIO pins : PA2 PA3 */
GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
GPIO_InitStruct.Alternate = GPIO_AF1_USART2;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
Those of you working on an STM32F1 MCU will notice that the GPIO_InitTypeDef.Alternate field
is missed in the CubeF1 HAL. This happens because STM32F1 MCUs have a less flexible way to
define alternate functions of a pin. While other STM32 microcontrollers define the possible alternate
functions at GPIO level (by configuring dedicated registers GPIOx_AFRL and GPIOx_AFRH ), allowing
to have up to sixteen different alternate functions associated of a pin (this only happens in packages
with high pin count), GPIOs of an STM32F1 MCU have really limited remapping capabilities. For
example,inanSTM32F103RBMCUonlytheUSART3canhavetwocoupleofpinsthatcanbeusedas
peripheral I/O alternatively. Usually, two dedicated peripheral registers, AFIO_MAPR and AFIO_MAPR2
“remap” signal I/Os of those peripherals allowing this operation.
This is essentially the reason why that field is not available in CubeF1 HAL.
6.2.3 Understanding GPIO Speed
One of the most misleading things of STM32 microcontrollers is the GPIO_InitTypeDef.Speed
parameter. This field can assume the values from Table 4 and it has effect only when the GPIO is
configured in output mode. Unfortunately, ST has not adopted a consistent name for those constants
inside the different Cube HALs.
Table 4: Available Speed modes for a GPIO
CubeF0/1/3/L0/L1 CubeF4/L4
GPIO_SPEED_LOW GPIO_SPEED_FREQ_LOW
GPIO_SPEED_MEDIUM GPIO_SPEED_FREQ_MEDIUM
GPIO_SPEED_FAST GPIO_SPEED_FREQ_HIGH
GPIO_SPEED_HIGH ⁸ GPIO_SPEED_FREQ_VERY_HIGH
Speed. A so sweet word for anybody loving performances. But what does it exactly means when it
refers to a GPIO? Here a GPIO speed is not related to switching frequency, that is how many times a
pin goes from ON to OFF in a unit of time. The GPIO_InitTypeDef.Speed parameter, instead, defines
the slew rate of a GPIO, that is how fast it goes from the 0V level to VDD one, and vice versa.
⁸ These modes are available only in some high performance version of STM32 MCUs. Check the reference manual for your MCU.
GPIO Management 185
Figure 7: Slew rate effect on a square wave - red=desired output, green=actual output
Figure 7 clearly shows this phenomenon. The red wave is the one that we will get if the response
speed was maximum, and therefore there was no response delay. In practice, what we get is that
shown by the green wave.
But how much does this parameter impact on the slew rate of an STM32 I/O? First of all, we have to
say that every STM32 family has its I/O driving characteristics. So you need to check the datasheet
of your MCU inside the Absolute Maximum Ratings section. Next, we can use this simple test to
measure the slew rate (the test is conducted on a Nucleo-F446RE board).
int main(void) {
GPIO_InitTypeDef GPIO_InitStruct;
HAL_Init();
__HAL_RCC_GPIOC_CLK_ENABLE();
/* Configure GPIO pin : PC4 */
GPIO_InitStruct.Pin = GPIO_PIN_4;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
/* Configure GPIO pin : PC8 */
GPIO_InitStruct.Pin = GPIO_PIN_8;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
while(1) {
GPIOC->ODR = 0x110;
GPIOC->ODR = 0;
}
}
The code is really self-explaining. We are configuring two pins as output I/Os. One of them, PC4, is
GPIO Management 186
configured with a GPIO_SPEED_FREQ_LOW speed. The other one, PC8, with GPIO_SPEED_FREQ_VERY_-
HIGH . Figure 8 shows the difference between the two pins. As we can see, the PC4 speed is about
25MHz, while the speed of PC8 pin is about 50MHz⁹.
Figure 8: The top figure shows the slew rate of PC4 pin and the one below the slew rate of PC8 pin
However, keep in mind that driving a pin “too hard” impacts on the overall EMI emissions of your
board. Professional design is nowadays all about EMI minimizing. Unless differently required, it is
strongly suggested you leave the default GPIO speed parameter to the minimum level.
What about the effective switching frequency? ST claims in its datasheets that the fastest toggle
speed of an output pin is every two clock cycles. The AHB1 bus, where the GPIO peripheral is
connected,runsat42MHzforanSTM32F446MCU.Soapinshouldtoggleinabout20MHz.However,
we have to add an additional overhead related to the memory transfer between the GPIO->ODR
register and the value we are going to store inside it ( 0x110 ), which costs another CPU cycle. So the
expected GPIO maximum switching speed is ∼ 14MHz. The oscilloscope confirms this, as shown in
Figure 9¹⁰.
⁹ Unfortunately, my oscilloscope probes have a load capacitance two high to conduct a precise measurement. According to STM32F446RE
datasheet, its maximum switching frequency is 90MHz, when C L = 30 pF, VDD ≥ 2.7 V and the compensation cell is activated. But I was not
able to obtain those results, due the poor oscilloscope and probably thanks to the length of the traces connecting the Nucleo morpho header
and the MCU pins.
¹⁰ TestswereconductedtogglingthemaximumGCCoptimizationlevel(-O3),prefetchenabledandallinternalcachesenabled.Thisjustifies
that the detected speed is a little bit higher then 14MHz.
GPIO Management 187
Figure 9: The maximum I/O switching frequency achieved with an STM32F446
Curiously, driving an I/O through the bit-banding region, using the same number of assembly
instructions, dramatically reduces the switching frequency down to 4MHz, as shown in Figure 10.
Figure 10: Switching frequency when toggling an I/O through bit-banding region
The code used to drive the test is the following (non relevant code was omitted):
#define BITBAND_PERI_BASE 0x40000000
#define ALIAS_PERI_BASE 0x42000000
#define BITBAND_PERI(a,b)((ALIAS_PERI_BASE+((uint32_t)a-BITBAND_PERI_BASE)*32+(b*4)))
...
volatile uint32_t *GPIOC_ODR = (((((uint32_t)0x40000000) + 0x00020000) + 0x0800) + 0x14);
volatile uint32_t *GPIOC_PIN8 = (uint32_t)BITBAND_PERI(GPIOC_ODR, 8);
...
while(1) {
*GPIOC_PIN8 = 0x1;
*GPIOC_PIN8 = 0;
}
6.3 Driving a GPIO
CubeHAL provides four manipulation routines to read, change and lock the state of an I/O.
To read the status of an I/O we can use the function:
GPIO Management 188
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
which accepts the GPIO descriptor and the pin number. It returns GPIO_PIN_RESET when the I/O is
low or GPIO_PIN_SET when high. Conversely, to change the I/O state, we have the function:
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
whichacceptsthe GPIO descriptor,thepin number andthe desiredstate.Ifwewanttosimply invert
the I/O state, then we can use this convenient routine:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin).
Finally, one feature of the GPIO peripheral is that we can lock the configuration of an I/O.
Any subsequent attempt to change its configuration will fail, until a reset occurs. To lock a pin
configuration we can use this routine:
HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin).
6.4 De-initialize a GPIO
ItispossibletosetaGPIOpintoitsdefaultresetstatus(thatisinInputFloatingMode).Thefunction:
void HAL_GPIO_DeInit(GPIO_TypeDef *GPIOx, uint32_t GPIO_Pin).
does this job automatically for us.
This function comes in really handy if we no longer need a given peripheral, or to avoid waste of
power when the CPU goes in sleep mode.
GPIO Management 189
Eclipse Intermezzo
It is possible to heavily customize the Eclipse interface by installing custom themes. A theme
essentially allows to change the appearance of the Eclipse user interface. This may seem a non
essential feature, but nowadays a lot of programmers prefer to customize colors, fonts type and size
and so on of their favorite development environment. That is one of the success reasons of some
minimal yet highly customizable source code editors, like TextMate and Sublime Text.
There are several theme packs available for Eclipse, but it is strongly suggested to install a plug-in
which automatically installs several other plug-ins useful for this scope: its name is Color IDE Pack
and it is available through the Eclipse Marketplace. The most relevant plug-ins installed are:
• Eclipse Color Theme, which is a “marketplace” of hundreds of Eclipse themes.
• Eclipse Moonrise UI Theme, which is considered the best full-black color theme by Andrea
Guarinoni.
• Jeeeyul’s Eclipse Themes, which contains color themes and color customization tools by
Jeeeyul Lee.
This author prefers a mixed approach between a full-dark theme and a full-light one: he prefers a
dark theme for the source editor, and a white background for other parts of IDE, as shown below.
 http://marketplace.eclipse.org/content/color-ide-pack
7. Interrupts Management
Hardware management is all about dealing with asynchronous events. The most of these come
from hardware peripherals. For example, a timer reaching a configured period value, or a UART
that warns about the arrival of data. Others are originated by the “world outside” our board. For
example, the user presses that damned switch that causes your board to hang, and you will spend a
whole day understanding what’s wrong.
All microcontrollers provide a feature called interrupts. An interrupt is an asynchronous event
that causes stopping the execution of the current code on a priority basis (the more important the
interrupt is, the higher its priority; this will cause that a lower-priority interrupt is suspended). The
code that services the interrupt is called Interrupt Service Routine (ISR).
Interrupts are a source of multiprogramming: the hardware knows about them and it is responsible
of saving the current execution context (that is, the stack frame, the current Program Counter and
few other things) before switching to the ISR. They are exploited by Real Time Operating Systems to
introducethenotionoftasks.Withouthelpbythehardwareitisimpossibletohaveatruepreemptive
system, which allows switching between several execution contexts without irreparably losing the
current execution flow.
Interrupts can originate both by the hardware and the software itself. ARM architecture distin-
guishes between the two types: interrupts originate by the hardware, exceptions by the software
(e.g.,an access to invalid memory location). In ARM terminology,an interrupt is a type of exception.
Cortex-M processors provide a unit dedicated to exceptions management. This is called Nested
VectoredInterruptController (NVIC)andthischapterisaboutprogrammingthisreallyfundamental
hardware component. However, here we deal only with interrupts management. Exceptions han-
dling will be treated in Chapter 24 about advanced debugging.
7.1 NVIC Controller
NVIC is a dedicated hardware unit inside the Cortex-M based microcontrollers that is responsible of
theexceptionshandling.Figure1showstherelationbetweentheNVICunit,theProcessorCoreand
peripherals. Here we have to distinguish two types of peripherals: those external to the Cortex-M
core, but internal to the STM32 MCU (e.g. timers, UARTS, and so on), and those peripherals external
to the MCU at all. The source of the interrupts coming from the last kind of peripherals are the MCU
I/O, which can be both configured as general purpose I/O (e.g. a tactile switch connected to a pin
configured as input) or to drive an external advanced peripheral (e.g. I/Os configured to exchange
data with an ethernet phyther through the RMII interface). A dedicated programmable controller,
named External Interrupt/Event Controller (EXTI), is responsible of the interconnection between
the external I/O signals and the NVIC controller, as we will see next.
Interrupts Management 191
Figure 1: the relation between the NVIC controller, the Cortex-M core and the STM32 peripherals
As stated before, ARM distinguishes between system exceptions, which originate inside the CPU
core, and hardware exceptions coming from external peripherals, also called Interrupt Requests
(IRQ). Programmers manage exceptions through the use of specific ISRs, which are coded at higher
level (most often using C language). The processor knows where to locate these routines thanks to
an indirect table containing the addresses in memory of Interrupt Service Routines. This table is
commonly called vector table, and every STM32 microcontrollers defines its own. Let us analyze
this in depth.
7.1.1 Vector Table in STM32
All Cortex-M processors define a fixed set of exceptions (fifteen for the Cortex-M3/4/7 cores and
thirteenforCortex-M0/0+cores)commontoallCortex-MfamiliesandhencecommontoallSTM32-
series. We already encountered them in Chapter 1. Here, you can find the same table (Table 1) for
your convenience. It is a good idea to take a quick look at these exceptions (we will study fault
exceptions better in Chapter 24 dedicated to advanced debugging).
• Reset: this exception is raised just after the CPU resets. Its handler is the real entry point of the
running firmware. In an STM32 application all starts from this exception. The handler contains
some assembly-coded functions designed to initialize the execution environment, such as the
main stack, the .bss area, etc. Chapter 22 dedicated to the booting process will explain this
deeply.
• NMI: this is a special exception, which has the highest priority after the Reset one. Like the
Reset exception, it cannot be masked (that is disabled), and it can be associated to critical and
non-deferrable activities. In STM32 microcontrollers it is linked to the Clock Security System
(CSS). CSS is a self-diagnostic peripheral that detects the failure of the HSE. If this happens,
HSE is automatically disabled (this means that the internal HSI is automatically enabled) and
a NMI interrupt is raised to inform the software that something is wrong with the HSE. More
about this feature in Chapter 10.
Interrupts Management 192
• Hard Fault: is the generic fault exception, and hence related to software interrupts. When
the other fault exceptions are disabled, it acts as a collector for all types of exceptions (e.g., a
memory access to an invalid location raised the Hard Fault exceptions if the Bus Fault one is
not enabled).
• Memory Management Fault¹: it occurs when executing code attempts to access an illegal
location or violates a rule of the Memory Protection Unit (MPU). More about this in Chapter
20.
• Bus Fault¹: it occurs when AHB interface receives an error response from a bus slave (also
called prefetch abort if it is an instruction fetch, or data abort if it is a data access). Can also
be caused by other illegal accesses (e.g. an access to a non existent SRAM memory location).
• Usage Fault¹: it occurs when there is a program error such as an illegal instruction, alignment
problem, or attempt to access a non-existent co-processor.
• SVCCall: this is not a fault condition, and it is raised when the Supervisor Call (SVC)
instructions is called. This is used by Real Time Operating Systems to execute instructions in
privileged state (a task needing to execute privileged operations executes the SVC instruction,
and the OS performs the requested operations - this is the same behavior of a system call in
other OS).
• Debug Monitor¹: this exception is raised when a software debug event occurs while the
processor core is in Monitor Debug-Mode. It is also used as exception for debug events like
breakpoints and watchpoints when software based debug solution is used.
• PendSV: this is another exception related to RTOS. Unlike the SVCall exception, which is
executed immediately after a SVC instruction is executed, the PendSV can be delayed. This
allows the RTOS to complete tasks with higher priorities.
• SysTick: this exception is also usually related to RTOS activities. Every RTOS needs a timer to
periodically interrupt the execution of current code and to switch to another task. All STM32
microcontrollers provide a SysTick timer, internal to the Cortex-M core. Even if every other
timer may be used to schedule system activities, the presence of a dedicated timer ensures
portability among all STM32 families (due to optimization reasons related to the internal die of
the MCU, not all timers could be available as external peripheral). Moreover, even if we aren’t
using an RTOS in our firmware, it is important to keep in mind that the ST CubeHAL uses the
SysTick timertoperforminternaltime-relatedactivities(anditalsoassumesthattheSysTick
timer is configured to generate an interrupt every 1ms).
The remaining exceptions that can be defined for a given MCU are related to IRQ handling.
Cortex-M0/0+ cores allows up to 32 external interrupts, while Cortex-M3/4/7 cores allows silicon
manufacturers to define up to 240 interrupts.
Where can we find the list of usable interrupts for a given STM32 microcontrollers? The datasheet
of that MCU is certainly the main source about available interrupts. However, we can simply refer
to the vector table provided by ST in its HAL. This table is defined inside the startup file for our
MCU, the assembly file ending with .S we have learned to import in our Eclipse project in Chapter
¹ This exception is not available in Cortex-M0/0+ based microcontrollers.
Interrupts Management 193
4 (for example, for an STM32F030R8 MCU the file name is startup_stm32f030x8.S ). Opening that
file we can find the whole vector table for that MCU, starting about at line 140.
Table 1: Cortex-M exception types
Even if the vector table contains the addresses of the handler routines, the Cortex-M core needs a
way to find the vector table inside memory. By convention, the vector table starts at the hardware
address 0x0000 0000 in all Cortex-M based processors. If the vector table resides in the internal
flash memory (this is what usually happens), and since the flash in all STM32 MCUs is mapped
from 0x0800 0000 address, it is placed starting from the 0x0800 0000 address, which is aliased to
0x0000 0000 when the CPU boots up².
Figure 2 shows how the vector table is organized in memory. Entry zero of this array is the
address of the Main Stack Pointer (MSP) inside the SRAM. Usually, this address corresponds to
the end of the SRAM, that is its base address + its size (more about memory layout of an STM32
² Apart from the Cortex-M0, the rest of Cortex-M cores allow torelocate the position in memory of the vector table. Moreover, it is possible
to force the MCU to boot up from different memories than the internal flash one. These are advanced topics that will be covered in Chapter
20 about memory layout and another one dedicated to booting process. To avoid confusion in unexperienced readers it is best to consider the
vector table position fixed and bound to the 0x0000 0000 address.
Interrupts Management 194
application in Chapter 20). Starting from the second entry of this table, we can find all exceptions
and interrupts handler. This means that the vector table has a length equal to 48 for Cortex-M0/0+
based microcontrollers and a length equal to 256 for Cortex-M3/4/7.
Figure 2: The minimal layout of the vector table in an STM32 MCU based on a Cortex-M3/4/7 core
It is important to clarify some things about the vector table.
1. The name of the exception handlers is just a convention, and you are totally free to rename
them if you like a different one. They are just symbols (as are variables and functions inside a
program). However, keep in mind that the CubeMX software is designed to generate ISR with
those names, which are an ST convention. So, you have to rename the ISR name too.
2. As said before, the vector table must be placed at the beginning of the flash memory, where
the processor expects to find it. This is a Link Editor job that places the vector table at the
beginning of the flash data during the generation of the absolute file, which is the binary file
we upload to the flash. In Chapter 20 we will study the content of ldscripts/sections.ld file,
which contains the directives to instruct GNU LD about this.
7.2 Enabling Interrupts
When an STM32 MCU boots up, only Reset, NMI and Hard Fault exceptions are enabled by default.
Therestofexceptionsandperipheralinterruptsaredisabled,andtheyhavetobeenabledonrequest.
To enable an IRQ, the CubeHAL provides the following function:
Interrupts Management 195
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn);
where the IRQn_Type is an enumeration of all exceptions and interrupts defined for that specific
MCU. The IRQn_Type enum is part of the ST Device HAL, and it is defined inside a header file
specific for the given STM32 MCU in the Eclipse folder system/include/cmsis/ . These files are
named stm32fxxxx.h . For example, for an STM32F030R8 MCU the right filename is stm32f030x8.h
(the pattern name of these files is the same of start-up files).
The corresponding function to disable an IRQ is the:
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn);
It is important to remark that the previous two function enable/disable an interrupt at the
NVIC controller level. Looking a Figure 1, you can see that an interrupt line is asserted by the
peripheral connected to that line. For example, the USART2 peripheral asserts the interrupt line
that corresponds to the USART2_IRQn interrupt line inside the NVIC controller. This means that the
single peripheral must be properly configured to work in interrupt mode. As we will see in the
remain of this book, the majority of STM32 peripherals are designed to work, among the others,
in interrupt mode. By using specific HAL routines we can enable the interrupt at peripheral level.
For example, using the HAL_USART_Transmit_IT() we implicitly configure the USART peripheral in
interrupt mode. Clearly, it is also required to enable the corresponding interrupt at NVIC level by
calling the HAL_NVIC_EnableIRQ() .
Now it is a good time to start playing with interrupts.
7.2.1 External Lines and NVIC
AswehaveseeninFigure1,STM32microcontrollersprovideavariablenumberofexternalinterrupt
sources connected to the NVIC through the EXTI controller, which in turn is capable to manage
several EXTI lines. The number of interrupt sources and lines depends on the specific STM32 family.
GPIO are connected to the EXTI lines, and it is possible to enable interrupts for every MCU GPIO,
even if the most of them share the same interrupt line. For example, for an STM32F4 MCU, up to 114
GPIOs are connected to 16 EXTI lines. However, only 7 of these lines have an independent interrupt
associated with them.
Figure 3 shows EXTI lines 0, 10 and 15 in an STM32F4 MCU. All Px0 pins are connected to EXTI0,
all Px10 pins are connected to EXTI10 and all Px15 pins are connected to EXTI15. However, EXTI
lines 10 and 15 share the same IRQ inside the NVIC (and hence are serviced by the same ISR)³.
This means that:
³ Sometimes, it also happens that different peripherals share the same request line, even in Cortex-M3/4/7 based MCUs where up to 240
configurable request lines are available. For example, in an STM32F446RE MCU, timer TIM6 shares its global IRQ with DAC1 and DAC2
under-run error interrupts.
Interrupts Management 196
• Only one PxY pin can be a source of interrupt. For example, we cannot define both PA0 and
PB0 as input interrupt pins.
• For EXTI lines sharing the same IRQ inside the NVIC controller, we have to code the
corresponding ISR so that we must be able to discriminate which lines generated the interrupt.
Figure 3: The relation between GPIO, EXTI lines and corresponding ISR in an STM32F4 MCU
The following example⁴ shows how to use interrupts to toggle the LD2 LED every time we press
the user-programmable button, which is connected to the PC13 pin. First, we configure in the GPIO
PC13 to fire an interrupt every time it goes from the low level to the high one (lines 49:52). This
is accomplished setting GPIO .Mode to be equal to GPIO_MODE_IT_RISING (for the complete list of
available interrupt related modes, refer to Table 2 in Chapter 6). Next, we enable the interrupt of the
EXTI line associated with the Px13 pins, that is EXTI15_10_IRQn .
⁴ The example is designed to work with a Nucleo-F401RE board. Please, refer to other book examples if you have a different Nucleo board.
Interrupts Management 197
Filename: src/main-ex1.c
39 int main(void) {
40 GPIO_InitTypeDef GPIO_InitStruct;
41
42 HAL_Init();
43
44 /* GPIO Ports Clock Enable */
45 __HAL_RCC_GPIOC_CLK_ENABLE();
46 __HAL_RCC_GPIOA_CLK_ENABLE();
47
48 /*Configure GPIO pin : PC13 - USER BUTTON */
49 GPIO_InitStruct.Pin = GPIO_PIN_13;
50 GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
51 GPIO_InitStruct.Pull = GPIO_PULLDOWN;
52 HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
53
54 /*Configure GPIO pin : PA5 - LD2 LED */
55 GPIO_InitStruct.Pin = GPIO_PIN_5;
56 GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
57 GPIO_InitStruct.Pull = GPIO_NOPULL;
58 GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
59 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
60
61 HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
62
63 while(1);
64 }
65
66 void EXTI15_10_IRQHandler(void) {
67 __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_13);
68 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
69 }
Finally, we need to define the function void EXTI15_10_IRQHandler() ⁵, which is the ISR routine
associated to the IRQ for the EXTI15_10 line inside the vector table (lines 66:69). The content of
the ISR is really simple. We toggle the PA5 I/O every time the ISR fires. We also need to clear the
pending bit associated to the EXTI line (more about this next).
Fortunately,theSTHALprovidesanabstractionmechanismthatavoidsustodealwiththesedetails,
unless we really need to take care of them. The previous example can be rewritten in the following
way:
⁵ AnotherfeatureoftheARMarchitecturesistheabilitytouseconventionalCfunctionsasISRs.Whenaninterruptfires,theCPUswitches
from the Threaded mode (that is, the main execution flow) to the Handler mode. During this switching process, the current execution context
is saved thanks to a procedure named stacking. The CPU itself is responsible of storing the previous saved context when the ISR terminates
the execution (unstacking). The explanation of this procedure is outside from the scope of this book. For more information about these aspects,
refer to the Joseph Yiu book.
Interrupts Management 198
Filename: src/main-ex2.c
48 /*Configure GPIO pin : PC12 and PC13 */
49 GPIO_InitStruct.Pin = GPIO_PIN_13 | GPIO_PIN_12;
50 GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
51 GPIO_InitStruct.Pull = GPIO_PULLDOWN;
52 HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
53
54 /*Configure GPIO pin : PA5 - LD2 LED */
55 GPIO_InitStruct.Pin = GPIO_PIN_5;
56 GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
57 GPIO_InitStruct.Pull = GPIO_NOPULL;
58 GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
59 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
60
61 HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
62
63 while(1);
64 }
65
66 void EXTI15_10_IRQHandler(void) {
67 HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_12);
68 HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
69 }
70
71 void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
72 if(GPIO_Pin == GPIO_PIN_13)
73 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
74 else if(GPIO_Pin == GPIO_PIN_12)
75 HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, RESET);
76 }
This time we have configured as interrupt source both pin PC13 and PC12. When the EXTI15_10_-
IRQHandler() ISR is called, we transfer the control to the HAL_GPIO_EXTI_IRQHandler() function
inside the HAL. This will perform for us all the interrupt related activities, and it will call the HAL_-
GPIO_EXTI_Callback() routinepassing the GPIO that has generated the IRQ.Figure4 clearly shows
the call sequence that generates from the IRQ⁶.
⁶ Don’t consider those time intervals related to the CPU cycles, they are just used to indicate “subsequent” events.
Interrupts Management 199
Figure 4: How an IRQ is processed by the HAL
This mechanism is used by almost all IRQ routines inside the HAL.
Please, take note that, since EXTI12 and EXTI13 lines are connected to the same IRQ, we need to
discriminate in our code which of the two pins generated the interrupt. This work is done for us by
the HAL, passing the GPIO_Pin parameter when the callback function is called.
7.2.2 Enabling Interrupts With CubeMX
CubeMX can be used to easily enable IRQs and to automatically generate the ISR code. The first
step is to enable the corresponding EXTI line using the Chip view, as shown in Figure 5.
Figure 5: How a GPIO can be bound to EXTI line using CubeMX
Once we have enabled an IRQ, we need to instruct CubeMX to generate the corresponding ISR. This
configuration is done through the Configuration view, clicking on the NVIC button. A list of ISRs
that can be enabled appears, as shown in Figure 6.
Interrupts Management 200
Figure 6: The NVIC configuration view allows to enable the corresponding ISR
CubeMX will automatically add the enabled ISRs inside the src/stm32fxxx_it.c file, and it will take
care of enabling the IRQs. Moreover, it adds for us the corresponding HAL handler routine to call,
as shown below:
/**
* @brief This function handles EXTI line[15:10] interrupts.
*/
void EXTI15_10_IRQHandler(void) {
/* USER CODE BEGIN EXTI15_10_IRQn 0 */
/* USER CODE END EXTI15_10_IRQn 0 */
HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
/* USER CODE BEGIN EXTI15_10_IRQn 1 */
/* USER CODE END EXTI15_10_IRQn 1 */
}
We only need to add the corresponding callback function (for example the HAL_GPIO_EXTI_Call-
back() routine) inside our application code.
What Belongs to What
When starting to deal with the ST HAL, a lot of confusion arises from its relationship with
the ARM CMSIS package. The stm32XX_hal_cortex.c module clearly shows the interaction
between the ST HAL and the CMSIS package, since it completely relies on the official ARM
package to deal with the underlying Cortex-M core functionalities. Every HAL_NVIC_xxx()
function is a wrap of the corresponding CMSIS NVIC_xxx() function. This means that we
may use the CMSIS API to program the NVIC controller. However, since this book is about
the CubeHAL, we will use the ST API to manage interrupts.
Interrupts Management 201
7.3 Interrupt Lifecycle
Onedealingwithinterrupts,itisreallyimportanttounderstandtheirlifecycle.AlthoughtheCortex-
Mcoreautomaticallyperformsthemostoftheworkforus,wehavetopayattentiontosomeaspects
thatcouldbeasourceofconfusionduringtheinterruptmanagement.However,thisparagraphgives
alookattheinterruptslifecyclefromthe“HALpointofview”.Ifyouareinterestedinlookingdeeper
into this matter, the book series from Joseph Yiu⁷ it is again the best source.
An interrupt can:
1. either be disabled (default behavior) or enabled;
• we enable/disable it calling the HAL_NVIC_EnableIRQ() / HAL_NVIC_DisableIRQ() function;
2. either be pending (a request is waiting to be served) or not pending;
3. either be in an active (being served) or inactive state.
We have already seen the first case in the previous paragraph. Now it is important to study what
happens when an interrupt occurs.
Whenaninterruptfires,itismarkedaspending untiltheprocessorcanserveit.Ifnootherinterrupts
are currently being processed, its pending state is automatically cleared by the processor, which
almost immediately starts serving it.
Figure 7: The relation between the pending bit and the interrupt active status
Figure 7 shows how this works. Interrupt A fires at the time t 0 and, since the CPU is not servicing
another interrupt, its pending bit is cleared and its execution starts immediately⁸ (the interrupt
becomes active). At the time t 1 the B interrupt fires, but here we suppose that it has a lower priority
than A. So it is leaved in pending state until the A ISR concludes its operations. When this happens,
the pending bit is automatically cleared and the ISR become active.
⁷ http://amzn.to/1P5sZwq
⁸ Here, it is important to understand the with the word “immediately” we are not saying that the interrupt execution starts without delay. If
no other interrupts are running, Cortex-M3/4/7 cores serve an interrupt in 12 CPU cycles, while Cortex-M0 does it in 15 cycles and Cortex-M0+
in 16 cycles.
Interrupts Management 202
Figure 8: The relation between the active status and interrupts priority
Figure 8 shows another important case. Here we have that the A interrupt fires, and the CPU can
immediately serve it. The interrupt B fires while A is serviced, so it remains in pending state until
A finishes. When this happens, the pending bit of B interrupt is cleared, and it becomes active.
However, after a while, A interrupt fires again, and since it has a higher priority, B interrupt is
suspended (becomes inactive) and the execution of A starts immediately. When this finishes, the B
interrupt becomes active again, and it completes its job.
Figure 9: How an interrupt can be forced to fire again setting its pending bit
NVIC provides a high degree of flexibility for programmers. An interrupt can be forced to fire again
during its execution, simply setting its pending bit again, as shown in Figure 9⁹. In the same way,
the execution of an interrupt can be canceled clearing its pending bit while it is in pending state, as
shown in Figure 10.
Figure 10: IRQ servicing can be canceled clearing its pending bit before it is executed
⁹ For the sake of completeness, it is important to specify that Cortex-M architecture is designed so that if an interrupt fires while the
processor is already servicing another interrupt, this will be serviced without restoring the previous application doing the unstacking (refer
to note 3 in this chapter for the definition of stacking/unstacking). This technique is called tail chaining and it allows to speed up interrupt
management and reduce power consumption.
Interrupts Management 203
Here it is important to clarify an important aspect related to how peripherals warn the NVIC
controller about the interrupt request. When an interrupt takes place, the most of STM32 peripherals
assert a specific signal connected to the NVIC, which is mapped in the peripheral memory through
a dedicated bit. This peripheral Interrupt Request bit will be held high until it is manually cleared
by the application code. For example, in the Example 1 we had to expressly clear the EXTI line IRQ
pending bit using the macro __HAL_GPIO_EXTI_CLEAR_IT() . If we do not de-assert that bit, a new
interrupt will be fired until it is cleared.
Figure 11: The relation between the peripheral IRQ and the corresponding interrupt
The Figure 11 clearly shows the relation between the peripheral IRQ pending state and the ISR
pending state. Signal I/O is the external peripheral driving the I/O (e.g. a tactile switch connected to
a pin). When the signal level changes, the EXTI line connected to that I/O generates an IRQ and the
corresponding pending bit is asserted. As consequence, the NVIC generates the interrupt. When the
processor starts servicing the ISR, the ISR pending bit is cleared automatically, but the peripheral
IRQ pending bit will be held high until it is cleared by the application code.
Interrupts Management 204
Figure 12: When an interrupt is forced setting its pending bit, the corresponding peripheral IRQ remains unset
The Figure 12 shows another case. Here we force the execution of the ISR setting its pending bit.
Since this time the external peripheral is not involved, there is no need to clear the corresponding
IRQ pending bit.
Since the presence of the IRQ pending bit is peripheral dependent, it is always opportune to
use the ST HAL functions to manage interrupts, leaving all the underlying details to the HAL
implementation (unless we want to have full control, but this is not case of this book). However, take
in mind that to avoid losing important interrupts, it is a good design practice to clear peripherals
IRQ pending status bit as their ISR start to be serviced. The processor core does not keep track of
multiple interrupts (it does not queue interrupts), so if we clear the peripheral pending bit at the end
of an ISR, we may lose important IRQs that fire in the middle.
To see if an interrupt is pending (that is, fired but not running), we can use the HAL function:
uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn);
which returns 0 if the IRQ is not pending, 1 otherwise.
To programmatically set the pending bit of an IRQ we can use the HAL function:
void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn);
This will cause the interrupt to fire, as it would be generated by the hardware. A distinctive feature
of Cortex-M processors it that it is possible to programmatically fire an interrupt inside the ISR
routine of another interrupt.
Instead, to programmatically clear the pending bit of an IRQ, we can use the function:
Interrupts Management 205
void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn);
Once again, it is also possible to clear the execution of a pending interrupt inside the ISR servicing
another IRQ.
To check if an ISR is active (IRQ being serviced), we can use the function:
uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn);
which returns 1 if the IRQ is active, 0 otherwise.
7.4 Interrupt Priority Levels
A distinctive features of the ARM Cortex-M architecture is the ability to prioritize interrupts (except
for the first three software exceptions that have a fixed priority, as shown in Table 1). Interrupt
priority allows to define two things:
• the ISRs that will be executed first in case of concurrent interrupts;
• thoseroutinesthatcanbeoptionallypreemptedtostartexecutinganISRwithahigherpriority.
NVICprioritymechanismissubstantiallydifferentbetweenCortex-M0/0+andCortex-M3/4/7cores.
For this reason we are going to explain them in two separated subparagraphs.
7.4.1 Cortex-M0/0+
Cortex-M0/0+ based microcontrollers have a simpler interrupt priority mechanism. This means that
STM32F0 and STM32L0 MCUs have a different behavior from the rest of STM32 microcontrollers.
And you have to pay special attention if you are porting your code between the STM32 series.
In Cortex-M0/0+ cores the priority of each interrupt is defined through an 8-bit register, called IPR .
In the ARMv6-M core architecture only 4 bits of this register are used, allowing up to 16 different
priority levels. However, in practice, STM32 MCUs implementing these coresuse only the two upper
bits of this register, seeing all other bits equal to zero.
Figure 13: The content of IPR register on an STM32 MCU based on Cortex-M0
Figure13showshowthecontentofIPRisinterpreted.Thismeansthatwehaveonlyfourmaximum
priority levels: 0x00, 0x40, 0x80, 0xC0. The lower this number is, the higher the priority is. That is,
an IRQ having a priority equal to 0x40 has a higher priority than an IRQ with a priority level equal
Interrupts Management 206
to 0xC0. If two interrupts fire at the same time, the one with the higher priority will be served
first. If the processor is already servicing an interrupt and a higher priority interrupt fires, then the
current interrupt is suspended and the control passes to the higher priority interrupt. When this
is completed, the execution goes back to the previous interrupt, if no other interrupt with higher
priority occurs in the meantime. This mechanism is called interrupt preemption.
Figure 14: Preemption of interrupts in case of concurrent execution
Figure 14 shows an example of interrupt preemption. A is an IRQ with lower priority that fires at
time t 0 . The ISR starts the execution but the IRQ B, which has a higher priority (lower priority level),
fires at time t 1 and the execution of A ISR is stopped. When B finishes its job, the execution of A ISR
is resumed until it finishes. This “nested” mechanism induced by interrupt priorities leads to the
name of the NVIC controller, which is Nested Vectored Interrupt Controller.
Cortex-M0/0+ has an important difference compared to Cortex-3/4/7 cores. The interrupt priority is
static. This means that once an interrupt is enabled its priority can no longer be changed, until we
disable the IRQ again.
The CubeHAL provides the following function to assign a priority to an IRQ:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);
The HAL_NVIC_SetPriority() function accepts the IRQ we are going to configure and the Preempt-
Priority , which is the preemption priority we are going to assign to the IRQ. The CMSIS API, and
hence the CubeHAL library, is designed so that PreemptPriority is specified with a priority level
numberrangingfrom0to4.Thevalueisinternallyshiftedtothemostsignificantbitsautomatically.
This simplifies the porting of code to other MCU with a different number of priority bits (this is the
reason why only the left part of IPR register is used by silicon vendors).
Interrupts Management 207
As you can see, the function accepts also the additional parameter SubPriority , which is
simply ignored in CubeF0 and CubeL0 HALs since the underlying Cortex-M processor does
not support interrupt sub-priority. Here ST engineers have decided to use the same API
available in the other HALs for Cortex-M3/4/7 based processors. Probably they decided to
do so to simplify porting code between the different STM32 MCUs.
Curiously, they have decided to define the corresponding function to retrieve the priority of
an IRQ in the following way:
uint32_t HAL_NVIC_GetPriority(IRQn_Type IRQn);
which is completely different from the one defined in the HALs for Cortex-M3/4/7 based
processors¹⁰.
The following example¹¹ shows how the interrupt priority mechanism works.
Filename: src/main-ex3.c
39 uint8_t blink = 0;
40
41 int main(void) {
42 GPIO_InitTypeDef GPIO_InitStruct;
43
44 HAL_Init();
45
46 /* GPIO Ports Clock Enable */
47 __HAL_RCC_GPIOC_CLK_ENABLE();
48 __HAL_RCC_GPIOB_CLK_ENABLE();
49 __HAL_RCC_GPIOA_CLK_ENABLE();
50
51 /*Configure GPIO pin : PC13 - USER BUTTON */
52 GPIO_InitStruct.Pin = GPIO_PIN_13 ;
53 GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
54 GPIO_InitStruct.Pull = GPIO_PULLDOWN;
55 HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
56
57 /*Configure GPIO pin : PB2 */
58 GPIO_InitStruct.Pin = GPIO_PIN_2 ;
59 GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
60 GPIO_InitStruct.Pull = GPIO_PULLUP;
61 HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
62
63 /*Configure GPIO pin : PA5 - LD2 LED */
64 GPIO_InitStruct.Pin = GPIO_PIN_5;
65 GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
66 GPIO_InitStruct.Pull = GPIO_NOPULL;
¹⁰ I have opened a dedicated thread on the official ST Forum, but there is still no answer from ST at the time of writing this chapter.
¹¹ The example is designed to work with a Nucleo-F030R8 board. Please, refer to other book examples if you have a different Nucleo board.
Interrupts Management 208
67 GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
68 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
69
70 HAL_NVIC_SetPriority(EXTI4_15_IRQn, 0x1, 0);
71 HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);
72
73 HAL_NVIC_SetPriority(EXTI2_3_IRQn, 0x0, 0);
74 HAL_NVIC_EnableIRQ(EXTI2_3_IRQn);
75
76 while(1);
77 }
78
79 void EXTI4_15_IRQHandler(void) {
80 HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
81 }
82
83 void EXTI2_3_IRQHandler(void) {
84 HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);
85 }
86
87 void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
88 if(GPIO_Pin == GPIO_PIN_13) {
89 blink = 1;
90 while(blink) {
91 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
92 for(volatile int i = 0; i < 100000; i++) {
93 /* Busy wait */
94 }
95 }
96 }
97 else {
98 blink = 0;
The code should be really easy to understand if the previous explanation is clear for you. Here
we have two IRQs associated to EXTI lines 2 and 13. The corresponding ISRs call the HAL HAL_-
GPIO_EXTI_IRQHandler() which in turn calls the HAL_GPIO_EXTI_Callback() callback passing the
GPIO involved in the interrupt. When the user button connected to PC13 signal is pushed, the
ISR starts an infinite loop until the blink global variables is >0 . This loop makes the LD2 LED
blinking quickly. When the PB2 pin is asserted low (use the pinout diagram for your Nucleo from
Appendix C to identify PB2 pin position), the EXTI2_3_IRQHandler() ¹² fires and this causes the
HAL_GPIO_EXTI_IRQHandler() to set the blink variable to 0 . The EXTI4_15_IRQHandler() can now
end. The priority of each interrupt is configured at lines 70 and 73: as you can see, since the interrupt
priority is static in Cortex-M0/0+ based MCUs, we have to set it before we enable the corresponding
interrupt.
¹² Please, take note that for STM32F302 MCUs the default name of the IRQ associated to EXTI line 2 is EXTI2_TSC_IRQHandler . Refer to
book examples if you are working with this MCU.
Interrupts Management 209
Please, take note that this is a really bad way to deal with interrupts. Locking the MCU
inside an interrupt is a poor programming style, and it is the root of all evil in embedded
programming. Unfortunately, this is the only example that came up to the author’s mind,
considering that at this point the book still covers few topics. Every ISR must be designed to
last as little as possible, otherwise other fundamental ISRs could be masked for a long time
loosing important information coming from other peripherals.
As exercise, try to play with interrupt priorities, and see what happens if both interrupts
have the same priority.
You may notice that often the interrupt fires by simply touching the wire, even if it is not
tied to the ground. Why does this happen? There are essentially two reasons that cause the
interrupt to “accidentally” trigger. First of all, modern microcontrollers try to minimize the
power leakages connected with the usage of internal pull-up/down resistors. So, the value of
these resistors is chosen really high (something around 50kΩ). If you play with the voltage
divider equation, you can figure out that it is really easy to pull an I/O low or high when a
pull-up/down resistor has a high resistance value. Secondly, here we are not doing adequate
debouncing of the input pin. Debouncing is the process of minimizing the effect of bounces
produced by “unstable” sources (e.g. a mechanical switch). Usually debouncing is performed
in hardware¹³ or in software, by counting how much time is elapsed from the first variation
of the input state: in our case, if the input remains low for more than a given period (usually
something between 100ms and 200ms is sufficient), then we can says that the input has been
effectively tied to the ground). As we will see in Chapter 11, we can also use one channel of
a timer configured to work in input capture mode to detect when a GPIO changes state. This
gives us the ability to automatically count how much time is elapsed from the first event.
Moreover, timer channels support integrated and programmable hardware filters, which
allow us to reduce the number of external components to debounce the I/Os.
7.4.2 Cortex-M3/4/7
Interrupt priority mechanism in Cortex-M3/4/7 is more advanced than the one available in Cortex-
M0/0+basedmicrocontrollers.Developershaveahigherdegreeofflexibility,andthisisoftensource
of several headaches for novices. Moreover, the way interrupt priority is presented both in the ARM
and ST documentation is a little bit counterintuitive.
InCortex-M3/4/7coresthepriorityofeachinterruptisdefinedthroughthe IPR register.Thisisa8bit
register in the ARMv7-M core architecture that allows up to 255 different priority levels. However,
in practice, STM32 MCUs implementing these cores use only the four upper bits of this register,
seeing all other bits equal to zero.
¹³ Usually, a capacitor and a resistor in parallel with the switch contacts are sufficient in most cases. For example, you can take a look at
schematics of the Nucleo board to see how ST engineers have debounced the USER button connected to PC13 GPIO.
Interrupts Management 210
Figure 15: The content of IPR register on an STM32 MCU based on Cortex-M3/4/7 core
Figure 15 clearly shows how the content of IPR is interpreted. This means that we have the only
sixteen maximum priority levels: 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xA0,
0xB0, 0xC0, 0xD0, 0xE0, 0xF0. The lower this number is, the higher the priority is. That is, an IRQ
having a priority equal to 0x10 has a higher priority than an IRQ with a priority level equal to
0xA0. If two interrupts fire at the same time, the one with the higher priority will be served first. If
the processor is already servicing an interrupt and a higher priority interrupts fires, then the current
interruptissuspendedandthecontrolpassestothehigherpriorityinterrupt.Whenthisiscompleted,
the execution goes back to the previous interrupt, if no other interrupts with higher priority occurs
in the meantime.
So far, the mechanism is substantially the same of Cortex-M0/0+. The complication arises from
the fact that the IPR register can be logically subdivided in two parts: a series of bits defining the
preemption priority¹⁴ and a series of bits defining the sub-priority. The first priority level rules the
preemption priorities between ISRs. If an ISR has a priority higher than another one, it will preempt
the execution of the lower priority ISR in case it fires. The sub-priority determines what ISR will be
executed first, in case of multiple pending ISR, but it will not act on ISR preemption.
Figure 16: Preemption of interrupts in case of concurrent execution
Figure 16 shows an example of interrupt preemption. A is an IRQ with the lowest priority that fires
at time t 0 . The ISR starts the execution but the IRQ B, which has a higher priority (lower priority
level), fires at time t 1 and the execution of A ISR is stopped. After a while, C IRQ fires at time t 2
and the B ISR is stopped and the C ISR starts execution. When this finishes, the execution of B ISR
is resumed until it finishes. When this happens, the execution of A ISR is resumed. This “nested”
mechanism induced by interrupt priorities leads to the name of the NVIC controller, which isNested
Vectored Interrupt Controller.
¹⁴ Whatcomplicatestheunderstandingofinterruptprioritiesisthefactthatintheofficialdocumentationsometimesthepreemptionpriority
is also called group priority. This leads to a lot of confusion, since novices tends to imagine that this bits define a sort of Access Control List
(ACL) privileges. Here, to simplify the understanding of this matter, we will only speak about preemption priority level.
Interrupts Management 211
Figure 17: If two interrupts with the same priority are pending, the one with the higher sub-priority is executed first
Figure 17 shows how the sub-priority affects the execution of multiple pending ISRs. Here we have
three interrupts, all with the same maximum priority. At time t 0 the IRQ A fires and it is serviced
immediately. At the time t 1 B IRQ fires, but since it has the same priority level of other IRQs, it is
leaved in pending state. At time t 2 also C IRQ fires, but for the same reason as before it is leaved
in pending state by the processor. When The A ISR finishes, the C IRQ is served first, since it has a
higher sub-priority than B. Only when the C ISR finishes the B IRQ can be served.
The way how IPR bits are logically subdivided is defined by the SCB->AIRCR register (a sub-group
of bits of the System Control Block (SCB) register), and it is important to stress right from the start
that this way to interpret the content of the IPR register is global to all ISRs. Once we have defined
a priority scheme (also called priority grouping in the HAL), this is common to all interrupts used
in the system.
Figure 18: The subdivision of IPR bits between preemption priority and sub-priority
Figure 18 shows all five possible subdivisions of IPR register, while Table 2 shows the maximum
number of preemption priority levels and sub-priority levels that each subdivision scheme allows.
Interrupts Management 212
Table 2: The number of preemption priority level available based on the current priority grouping schema
NVIC Priority Group Number of preemption priority levels Number of sub-priority levels
NVIC_PRIORITYGROUP_0 0 16
NVIC_PRIORITYGROUP_1 2 8
NVIC_PRIORITYGROUP_2 4 4
NVIC_PRIORITYGROUP_3 8 2
NVIC_PRIORITYGROUP_4 16 0
The CubeHAL provides the following function to assign a priority to an IRQ:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority);
The HAL library is designed so that the PreemptPriority and SubPriority can be configured with a
priority level number ranging from 0 to 16. The value is internally shifted to the most significant bits
automatically. This simplifies the porting of code to other MCU with a different number of priority
bits (this is the reason why only the left part of IPR register is used by silicon vendors).
Instead, to define the priority grouping, that is how to subdivide the IPR register between the
preemption priority and sub-priority, the following function can be used:
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup);
where the PriorityGroup parameter is one of the macros from the column NVIC Priority Group
in Table 2.
The following example¹⁵ shows how the interrupt priority mechanism works.
Filename: src/main-ex3.c
59 uint8_t blink = 0;
60
61 int main(void) {
62 GPIO_InitTypeDef GPIO_InitStruct;
63
64 HAL_Init();
65
66 /* GPIO Ports Clock Enable */
67 __HAL_RCC_GPIOC_CLK_ENABLE();
68 __HAL_RCC_GPIOB_CLK_ENABLE();
69 __HAL_RCC_GPIOA_CLK_ENABLE();
70
71 /*Configure GPIO pin : PC13 */
72 GPIO_InitStruct.Pin = GPIO_PIN_13 ;
73 GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
¹⁵ The example is designed to work with a Nucleo-F401RE board. Please, refer to other book examples if you have a different Nucleo board.
Interrupts Management 213
74 GPIO_InitStruct.Pull = GPIO_PULLDOWN;
75 HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
76
77 /*Configure GPIO pin : PB2 */
78 GPIO_InitStruct.Pin = GPIO_PIN_2 ;
79 GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
80 GPIO_InitStruct.Pull = GPIO_PULLUP;
81 HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
82
83 /*Configure GPIO pin : PA5 */
84 GPIO_InitStruct.Pin = GPIO_PIN_5;
85 GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
86 GPIO_InitStruct.Pull = GPIO_NOPULL;
87 GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
88 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
89
90 HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0x1, 0);
91 HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
92
93 HAL_NVIC_SetPriority(EXTI2_IRQn, 0x0, 0);
94 HAL_NVIC_EnableIRQ(EXTI2_IRQn);
95
96 while(1);
97 }
98
99 void EXTI15_10_IRQHandler(void) {
100 HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
101 }
102
103 void EXTI2_IRQHandler(void) {
104 HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);
105 }
106
107 void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
108 if(GPIO_Pin == GPIO_PIN_13) {
109 blink = 1;
110 while(blink) {
111 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
112 for(int i = 0; i < 1000000; i++);
113 }
114 }
115 else {
116 blink = 0;
117 }
118 }
The code should be really easy to understand if the previous explanation is clear for you. Here we
Interrupts Management 214
have two IRQs associated to EXTI lines 2 and 13. The corresponding ISRs call the HAL HAL_GPIO_-
EXTI_IRQHandler() which in turn calls the HAL_GPIO_EXTI_Callback() callback passing the GPIO
involved in the interrupt. When the user button connected to PC13 signal is pushed, the ISR starts an
infinite loop until the blink global variables is >0 . This loop makes the LD2 LED blinking quickly.
When the PB2 pin is asserted low (use the pinout diagram for your Nucleo from Appendix C to
identifyitsposition),the EXTI2_IRQHandler() firesandthiscausesthe HAL_GPIO_EXTI_IRQHandler()
to set the blink variable to 0 . The EXTI15_10_IRQHandler() can now end.
Please, take note that this is a really bad way to deal with interrupts. Locking the MCU
inside an interrupt is a poor programming style, and it is the root of all evil in embedded
programming. Unfortunately, this is the only example that came up to the author’s mind,
considering that at this point the book still covers few topics. As we will see soon, every
ISR must be designed to last as little as possible, otherwise other fundamental ISRs could be
masked for a long time loosing important information coming from other peripherals.
As exercise, try to play with interrupt priorities, and see what happens if both interrupts
have the same priority.
You may notice that often the interrupt fires by simply touching the wire, even if it is not
tied to the ground. Why does this happen? There are essentially two reasons that cause the
interrupt to “accidentally” trigger. First of all, modern microcontrollers try to minimize the
power leakages connected with the usage of internal pull-up/down resistors. So, the value of
these resistors is chosen really high (something around 50kΩ). If you play with the voltage
divider equation, you can figure out that it is really easy to pull an I/O low or high when a
pull-up/down resistor has a high resistance value. Secondly, here we are not doing adequate
debouncing of the input pin. Debouncing is the process of minimizing the effect of bounces
produced by “unstable” sources (e.g. a mechanical switch). Usually debouncing is performed
in hardware¹⁶ or in software, by counting how much time is elapsed from the first variation
of the input state: in our case, if the input remains low for more than a given period (usually
something between 100ms and 200ms is sufficient), then we can says that the input has been
effectively tied to the ground). As we will see in Chapter 11, we can also use one channel of
a timer configured to work in input capture mode to detect when a GPIO changes state. This
gives us the ability to automatically count how much time is elapsed from the first event.
Moreover, timer channels support integrated and programmable hardware filters, which
allow us to reduce the number of external components to debounce the I/Os.
It is important to remark some fundamental things. First of all, different from Cortex-M0/0+ based
microcontrollers, Cortex-M3/4/7 cores allow to dynamically change the priority of an interrupt,
even if this is already enabled. Secondly, care must be taken when the priority grouping is
¹⁶ Usually, a capacitor and a resistor in parallel with the switch contacts are sufficient in most cases. For example, you can take a look at
schematics of the Nucleo board to see how ST engineers have debounced the USER button connected to PC13 GPIO.
Interrupts Management 215
lowered dynamically. Let us consider the following example. Suppose that we have three ISRs
with three decreasing priorities (the priority is specified inside the parenthesis): A(0x0), B(0x10),
C(0x20). Suppose that we have defined these priorities when the priority grouping was equal to
NVIC_PRIORITYGROUP_4 . If we lower it to the NVIC_PRIORITYGROUP_1 level, the current preemption
levels will be interpreted as sub-priorities. This will cause that interrupt service routines A, B and
C have the same preemption level (that is, 0x0), and it will not be possible to preempt them. For
example, looking at Figure 20 we can see what happens to the priority of the ISR C when the
priority grouping is lowered from 4 to 1. When the priority grouping is set to 4, the priority of C ISR
is just two levels under the maximum priority level, which is 0 (the next highest level is 0x10, which
is the B’s priority). This means that C can be preempted both by A and B. However, if we lower
the priority grouping to 1, then the priority of C becomes 0x0 (only bit 7 acts as priority) and the
remainingbits areinterpretedbythe NVIC controller as sub-priority. This can lead to the following
scenario:
1. all interrupts will not be able to preempt each other;
2. if C interrupt is triggered, and the CPU is not servicing another interrupt, C is serviced
immediately;
3. if CPU is servicing C ISR and then after a short while A and B are triggered, CPU will service
A and then B after it completes to service C;
4. if CPU is servicing another ISR, if C triggers and then after a short while A and B are triggered,
A will be serviced firstly, followed by B then C.
Figure 20: What happens to the C ISR priority when the priority gruping is lowered from 4 to 1
Before that the interrupt priority mechanism becomes clear, you will have to do several
experiments by yourself. So, try to modify the Example 3 so that changing the priority
grouping causes that the preemption priority is the same for both the IRQs.
To obtain the priority of an interrupt, the HAL defines the following function:
void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t* pPreemptPriority, \
uint32_t* pSubPriority);
I have to admit that the signature of this function is a little bit fuzzy, since it differs from the
HAL_NVIC_SetPriority() : here we have to specify also the PriorityGroup , while the HAL_NVIC_Set-
Priority() function computes it internally. I do not know why ST has decided to use this signature,
and I cannot see the reason to make it different from the HAL_NVIC_SetPriority() .
Interrupts Management 216
The current priority grouping can be obtained using the following function:
uint32_t HAL_NVIC_GetPriorityGrouping(void);
7.4.3 Setting Interrupt Priority in CubeMX
CubeMX can be also used to set the IRQ priority and the priority grouping schema. This configu-
ration is done through the Configuration view, clicking on the NVIC button. The list of enableable
ISRs appears, as shown in Figure 21.
Figure 21: The NVIC configuration view allows to set the ISR priority
Using the Priority Group combo box we can set the priority grouping schema, and then assign
the individual priority and sub-priority to each interrupt. CubeMX will automatically generate the
corresponding C code to setup the IRQ priority inside the MX_GPIO_Init() function. Instead, the
global priority grouping schema is configured inside the HAL_MspInit() function.
7.5 Interrupt Re-Entrancy
Let us suppose to rearrange the Example 3 so that it uses pin PC12 instead of PB2. In this case, since
EXTI12 and EXTI13 share the same IRQ, our Nucleo would never stop blinking. Due to the way
the priority mechanism is implemented in Cortex-M processors (that is, an exception with a given
priority cannot be preempted by another one with same priority), exceptions and interrupts are not
re-entrant. So they cannot be called recursively¹⁷.
¹⁷ Joseph Yiu shows a way to bypass this limitation in his books. However, I strongly discourage from using these tricky techniques unless
you really need interrupt re-entrancy in your application.
Interrupts Management 217
However, in most of cases our code can be rearranged to address this limitation. In the following
example¹⁸ the blinking code is executed inside the main() function, leaving to the ISR only the
responsibility to setup the global blink variable.
Filename: src/main-ex4.c
50 /*Configure GPIO pin : PC12 & PC13 */
51 GPIO_InitStruct.Pin = GPIO_PIN_12 | GPIO_PIN_13;
52 GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
53 GPIO_InitStruct.Pull = GPIO_PULLDOWN;
54 HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
55
56 /*Configure GPIO pin : PA5 */
57 GPIO_InitStruct.Pin = GPIO_PIN_5;
58 GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
59 GPIO_InitStruct.Pull = GPIO_NOPULL;
60 GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
61 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
62
63 HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_1);
64 HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
65 HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0x0, 0);
66
67 while(1) {
68 if(blink) {
69 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
70 for(int i = 0; i < 100000; i++);
71 }
72 }
73 }
74
75 void EXTI15_10_IRQHandler(void) {
76 HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_12);
77 HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
78 }
79
80 void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
81 if(GPIO_Pin == GPIO_PIN_13)
82 blink = 1;
83 else
84 blink = 0;
85 }
¹⁸ The example is designed to work with a Nucleo-F401RE board. Please, refer to other book examples if you have a different Nucleo board.
Interrupts Management 218
7.6 Mask All Interrupts at Once or an a Priority Basis
Sometimes we want to be sure that our code is not preempted to allow the execution of interrupts
or more privileged code. That is, we want to ensure that our code is thread-safe. Cortex-M based
processors allow to temporarily mask the execution of all interrupts and exceptions, without
disabling one by one. Two special registers, named PRIMASK and FAULTMASK allow to disable all
interrupts and exceptions respectively.
Figure 22: PRIMASK , FAULTMASK and BASEPRI registers
Even if these registers are 32-bit wide, just the first bit is used to enable/disable interrupts and
exceptions. The ARM assembly instruction CPSID i disables all interrupt by setting the PRIMASK bit
to 1, while the CPSIE i instructions enables them by setting PRIMASK to zero. Instead, the instruction
CPSID f disables all exceptions (except for the NMI one) by setting the FAULTMASK bit to 1, while the
CPSIE f instructions enables them.
The CMSIS-Core package provides several macros that we can use to perform these operation: __-
disable_irq() and __enable_irq() automatically set and clear the PRIMASK . Any critical task can
be placed between these two macros, as shown below:
...
__disable_irq();
/* All exceptions with configurable priority are temporarily disabled.
You can place critical code here */
...
__enable_irq();
However, take in mind that, as general rule, interrupt must be masked only for really short time,
otherwise you could lose important interrupts. Remember that interrupts are not queued.
Another macro we can use is the __set_PRIMASK(x) one, where x is the content of the PRIMASK
register (0 or 1). The macro __get_PRIMARK() returns the content of the PRIMASK register. Instead,
themacros __set_FAULTMASK(x) and __get_FAULTMASK() allowtomanipulatethe FAULTMASK register.
It is important to remark that, once the PRIMASK register is again set to zero, all pending interrupts
are serviced according their priority: PRIMASK causes that the the interrupt pending bit is set but
the ISR is not serviced. This is the reason why we say that interrupt are masked and not disabled.
Interrupts start to be serviced as soon as the PRIMASK is cleared.
Interrupts Management 219
Cortex-M3/4/7 cores allow to selectively mask interrupts on a priority basis. The BASEPRI register
masks exceptions or interrupts on a priority level. The width of the BASEPRI register is the same of
the IPR one, which lasts for the upper 4 bits in STM32 MCUs based on these cores. When BASEPRI
is set to 0, it is disabled. When it is set to a non-zero value, it blocks exceptions (including interrupts)
that have the same or lower priority level, while still allowing exceptions with a higher priority level
to be accepted by the processor. For example, if the BASEPRI register is set to 0x60 , then all interrupts
with a priority between 0x60-0xFF are disabled. Remember that in Cortex-M cores the higher is the
priority number the lower is the interrupt priority level. The __set_BASEPRI(x) macro allows to set
the content of the BASEPRI register: remember, again, that the HAL automatically shifts the priority
levels to the MSB bits. So, if we want to disable all interrupts with a priority higher than 2 , then we
have to pass to the __set_BASEPRI() macro the value 0x20 . Alternatively, we can use the following
code:
__set_BASEPRI(2 << (8 - __NVIC_PRIO_BITS));
Interrupts Management 220
Eclipse Intermezzo
When coding, productivity is important for every developer. Modern source code editors allow to
define custom code snippets, that is fragments of source code that are automatically inserted by the
editor when a given “keyword” is typed. Eclipse calls this functionality “code templates”, and they
can be invoked by issuing a Ctrl+Space right after a keyword is written. For example, open a source
file and write the keyword “ for ” and right after it hit Ctrl+Space. A contextual menu pops up, as
shown in the following picture.
By choosing the entry “for - for loop”, Eclipse will automatically place a new for loop inside the
code. Now note a thing: the loop variable var is highlighted, as shown in the following picture.
If you write the new name for the loop variable Eclipse will automatically change it is name in all
three places. Eclipse define its set of code templates, but the good news is that you can define your
owns! Go inside Eclipse preferences, and then into C/C++->Editor->Templates. Here you can find
all pre-defined code snippets and you can eventually add your owns.
For example, we can add a new code template that insert a software breakpoint instruction
( asm("BKPT #0"); ) when we write the keyword bkpt , as shown in the previous picture. Code
templates are highly customizable, thanks to the usage of variables and other pattern constructs.
For more information, refer to the Eclipse documentation.
 http://bit.ly/2c3Vm1K
8. Universal Asynchronous Serial
Communications
Nowadays there is a really high number of serial communication protocols and hardware interfaces
availableintheelectronicsindustry.Themostofthemarefocusedonhightransmissionbandwidths,
like the more recent USB 2.0 and 3.0 standards, the Firewire (IEEE 1394) and so on. Some of
these standards come from the past, but are still widespread especially as communication interface
between modules on the same board. One of this is the Universal Synchronous/Asynchronous
Receiver/Transmitter interface, also simply known as USART.
Almost every microcontroller provides at least one UART peripheral. Almost all STM32 MCUs
provideatleasttwoUART/USARTinterfaces,butthemostofthemprovidemorethantwointerfaces
(some up to eight interfaces) according the number of I/O supported by the MCU package.
In this Chapter we will see how to program this really useful peripheral using the CubeHAL.
Moreover, we will study how to develop applications using the UART both in polling and interrupt
modes, leaving the third operative mode, the DMA, to the next chapter.
8.1 Introduction to UARTs and USARTs
BeforewestartdivingintotheanalysisofthefunctionsprovidedbytheHALtomanipulateuniversal
serial devices, it is best to take a brief look at the UART/USART interface and its communication
protocol.
When we want two exchange data between two (or even more) devices, we have two alternatives:
we can transmit it in parallel, that is using a given number of communication lines equal to the
size of the each data word (e.g., eight independent lines for a word made of eight bits), or we can
transmit each bit constituting our word one by one. A UART/USART is a device that translates a
parallel sequence of bits (usually grouped in a byte) in a continuous stream of signals flowing on a
single wire.
When the information flows between two devices inside a common channel, both devices (here, for
simplicity, we will refer to them as the sender and the receiver) have to agree on the timing, that this
howlongittakestotransmiteachindividualbitoftheinformation.Inasynchronoustransmission,
the sender and the receiver share a common clock generated by one of the two devices (usually the
device that acts as the master of this interconnection system).
Universal Asynchronous Serial Communications 222
Figure 1: A serial communication between two devices using a shared clock source
In Figure 1 we have a typical timing diagram¹ showing the Device A sending one byte ( 0b01101001 )
serially to the Device B using a common reference clock. The common clock is also used to agree on
when to start sampling the sequence of bits: when the master device starts clocking the dedicated
line, it means that it is going to send a sequence of bits.
In a synchronous transmission the transmission speed and duration are defined by the clock: its
frequency determines how fast we can transmit a single byte on the communication channel². But
if both devices involved in data transmission agree on how long it takes to transmit a single bit and
when to start and finish to sample transmitted bits, than we can avoid to use a dedicated clock line.
In this case we have an asynchronous transmission.
Figure 2: The timing diagram of a serial communication without a dedicated clock line
Figure 2 shows the timing diagram of an asynchronous transmission. The idle state (that is, no
transmission occurring) is represented by the high signal. Transmission begins with a START bit,
whichisrepresentedbythelowlevel.Thenegativeedgeisdetectedbythereceiverand1.5bitperiods
after this (indicated in Figure 1s T 1.5bit ), the sampling of bits begins. Eight data bits are sampled. The
least significant bit (LSB) is typically transmitted first. An optional parity bit is then transmitted (for
error checking of the data bits). Often this bit is omitted if the transmission channel is assumed to be
noise free or if there are error checking higher up in the protocol layers. The transmission is ended
by a STOP bit, which last 1.5 bits.
¹ A Timing Diagram is a representation of a set of signals in the time domain.
² However,keepinmindthatthemaximumtransmissionspeedisdeterminedbyalotofotherthings,likethecharacteristicsoftheelectrical
channel, the ability of each device involved in transmission to sample fast signals, and so on.
Universal Asynchronous Serial Communications 223
Figure 3: The signaling difference between a USART and a UART
A Universal Synchronous Receiver/Transmitter interface is a device able to transmit data word
serially using two I/Os, one acting as transmitter (TX) and one as receiver (RX), plus one additional
I/O as one clock line, while a Universal Asynchronous Receiver/Transmitter uses only two RX/TX
I/Os(seeFigure3).TraditionalwerefertothefirstinterfacewiththetermUSARTandtothesecond
one with the term UART.
A UART/USART defines the signaling method, but it say nothing about the voltage levels. This
means that an STM32 UART/USART will use the voltage levels of the MCU I/Os, which is almost
equal to VDD (it is also common to refer to these voltage levels as TTL voltage levels). The way
these voltage levels are translated to allow serial communication outside the board is demanded to
other communication standards. For example, the EIA-RS232 or EIA-RS485 are two really popular
standards that define signaling voltages, in addition to their timing and meaning, and the physical
size and pinout of connectors. Moreover, UART/USART interfaces can be used to exchange data
using other physical and logical serial interfaces. For example, the FT232RL is a really popular IC
that allows to map a UART to a USB interface, as shown in Figure 4.
The presence of a dedicated clock line, or a common agreement about transmission frequency, does
not guarantee that the receiver of a byte stream is able to process them at the same transmission
rate of the master. For this reason, some communication standards, like the RS232 and the RS485,
provide the possibility to use a dedicated Hardware Flow Control line. For example, two devices
communicating using the RS232 interface can share two additional lines, named Request To
Send(RTS) and Clear To Send(CTS): the sender sets its RTS, which signals the receiver to begin
monitoring its data input line. When ready for data, the receiver will raise its complementary line,
CTS, which signals the sender to start sending data, and for the sender to begin monitoring the
slave’s data output line.
Universal Asynchronous Serial Communications 224
Figure 4: A typical circuit based on FT232RL used to convert a 3.3V TTL UART interface to USB
STM32 microcontrollers provide a variable number of USARTs, which can be configured to work
both in synchronous and asynchronous mode. Some STM32 MCUs also provide interfaces only able
to act as UART. Table 1 lists the UART/USARTs provided by STM32 MCUs equipping all Nucleo
boards. The most of USARTs are also able to automatically implement Hardware Flow Control, both
for the RS232 and the RS485 standards.
All Nucleo-64 boards are designed so that the USART2 of the target MCU is linked to the ST-
LINK interface³. When we install the ST-LINK drivers, an additional driver for the Virtual COM
Port(VCP) is also installed: this allows us to access to the target MCU USART2 using the USB
interface, without using a dedicated TTL/USB converter. Using a terminal emulation program we
can exchange messages and data with our Nucleo.
The CubeHAL separates the API for the management of UART and USART interfaces. All functions
and C type handlers used for the handling of USARTs start with the HAL_USART prefix and are
contained inside the files stm32xxx_hal_usart.{c,h} , while those related to UARTs management
start with the HAL_UART prefix and are contained inside the files stm32xxx_hal_uart.{c,h} . Since
both the modules are conceptually identical, and since the UART is the most common form of serial
interconnection between different modules, this book will only cover the features of the HAL_UART
module.
³ Please take note that this statement may not be true if you are using a Nucleo-32 or Nucleo-144 board. Check the ST documentation for
more about this.
Universal Asynchronous Serial Communications 225
Table 1: The list of available USARTs and UARTs on all Nucleo boards
8.2 UART Initialization
LikeallSTM32peripherals,eventheUSARTs⁴aremappedinthememorymappedperipheralregion,
which starts from 0x4000 0000 . The CubeHAL abstracts the effective location of each USART for
a given STM32 MCU thanks to the USART_TypeDef ⁵ descriptor. For example, we can simply use the
USART2 macro to refer to the second USART peripheral provided by all STM32 microcontrollers with
LQFP64 package.
⁴ Starting from this paragraph, the terms USART and UART are used interchangeably, unless different noticed.
⁵ The analysis of the fields of this C struct is outside of the scope of this book.
Universal Asynchronous Serial Communications 226
However, all the HAL functions related to UART management are designed so that they accept as
first parameter an instance of the C struct UART_HandleTypeDef , which is defined in the following
way:
typedef struct {
USART_TypeDef *Instance; /* UART registers base address */
UART_InitTypeDef Init; /* UART communication parameters */
UART_AdvFeatureInitTypeDef AdvancedInit; /* UART Advanced Features initialization
parameters */
uint8_t *pTxBuffPtr; /* Pointer to UART Tx transfer Buffer */
uint16_t TxXferSize; /* UART Tx Transfer size */
uint16_t TxXferCount; /* UART Tx Transfer Counter */
uint8_t *pRxBuffPtr; /* Pointer to UART Rx transfer Buffer */
uint16_t RxXferSize; /* UART Rx Transfer size */
uint16_t RxXferCount; /* UART Rx Transfer Counter */
DMA_HandleTypeDef *hdmatx; /* UART Tx DMA Handle parameters */
DMA_HandleTypeDef *hdmarx; /* UART Rx DMA Handle parameters */
HAL_LockTypeDef Lock; /* Locking object */
__IO HAL_UART_StateTypeDef State; /* UART communication state */
__IO HAL_UART_ErrorTypeDef ErrorCode; /* UART Error code */
} UART_HandleTypeDef;
Let us see more in depth the most important fields of this struct .
• Instance : is the pointer to the USART descriptor we are going to use. For example, USART2 is
the descriptor of the UART associated to the ST-LINK interface of every Nucleo board.
• Init : is an instance of the C struct UART_InitTypeDef , which is used to configure the UART
interface. We will study it more in depth in a while.
• AdvancedInit : this field is used to configure more advanced UART features like the automatic
BaudRate detection and the TX/RX pin swapping. Some HALs do not provide this additional
field. This happens because USART interfaces are not equal for all STM32 MCUs. This is an
important aspect to keep in mind while choosing the right MCU for your application. The
analysis of this field is outside the scope of this book.
• pTxBuffPtr and pRxBuffPtr : these fields point to the transmit and receive buffer respectively.
Theyareusedassourcetotransmit TxXferSize bytesovertheUARTandtoreceive RxXferSize
when the UART is configured in Full Duplex Mode. The TxXferCount and RxXferCount fields
are used internally by the HAL to take count of transmitted and received bytes.
• Lock : this field is used internally by the HAL to lock concurrent accesses to UART interfaces.
Universal Asynchronous Serial Communications 227
As said above, the Lock field is used to rule concurrent accesses in almost all HAL routines.
If you take a look at the HAL code, you can see several uses of the __HAL_LOCK() macro,
which is expanded in this way:
#define __HAL_LOCK(__HANDLE__) \
do{ \
if((__HANDLE__)->Lock == HAL_LOCKED) \
{ \
return HAL_BUSY; \
} \
else \
{ \
(__HANDLE__)->Lock = HAL_LOCKED; \
} \
}while (0)
It is not clear why ST engineers decided to take care of concurrent accesses to the HAL
routines. Probably they decided to have a thread safe approach, freeing the application
developer from the responsibility of managing multiple accesses to the same hardware
interface in case of multiple threads running in the same application.
However, this has an annoying side effect for all HAL users: even if my application does not
perform concurrent accesses to the same peripheral, my code will be poor optimized by a lot
of checks about the state of the Lock field. Moreover, that way to lock is intrinsically thread
unsafe, because there is no critical section used to prevent race conditions in case a more
privilegedISRpreemptstherunningcode.Finally,ifmyapplicationusesanRTOS,itismuch
better to use native OS locking primitives (like semaphores and mutexes which are not only
atomic, but also correctly manages the task scheduling avoiding thebusy waiting) to handle
concurrent accesses, without the need to check for a particular return value ( HAL_BUSY ) of
the HAL functions.
A lot of developers have disapproved this way to lock peripherals since the first release of
the HAL. ST engineers have recently announced that they are actively working on a better
solution.
All the UART configuration activities are performed by using an instance of the C struct UART_-
InitTypeDef , which is defined in the following way:
Universal Asynchronous Serial Communications 228
typedef struct {
uint32_t BaudRate;
uint32_t WordLength;
uint32_t StopBits;
uint32_t Parity;
uint32_t Mode;
uint32_t HwFlowCtl;
uint32_t OverSampling;
} UART_InitTypeDef;
• BaudRate : this parameter refers to the connection speed, expressed in bits per seconds. Even if
the parameter can assume an arbitrary value, usually the BaudRate comes from a list of well-
known and standard values. This because it is a function of the peripheral clock associated
to the USART (that is derived from the main HSI or HSE clock by a complex chain of PLLs
and multipliers in some STM32 MCU), and not all BaudRates can be easily achieved without
introducing sampling errors, and hence communication errors. Table 2 shows the list of
commonBaudRates,andtherelatederrorcalculation,foranSTM32F030MCU.Alwaysconsult
thereferencemanualforyourMCUtoseewhichperipheralclockfrequencybestfitstheneeded
BaudRate on the given STM32 microcontroller.
Table 2: Error calculation for programmed baud rates at 48 MHz in both cases of oversampling by 16 or by 8
Universal Asynchronous Serial Communications 229
• WordLength : it specifies the number of data bits transmitted or received in a frame. This field
can assume the value UART_WORDLENGTH_8B or UART_WORDLENGTH_9B , which means that we can
transmit over a UART packets containing 8 or 9 data bits. This number does not include the
overhead bits transmitted, such as the start and stop bits.
• StopBits :thisfieldspecifiesthenumberofstopbitstransmitted.Itcanassumethevalue UART_-
STOPBITS_1 or UART_STOPBITS_2 , which means that we can use one or two stop bits to signal
the end of the frame.
• Parity : it indicates the parity mode. This field can assume the values from Table 3. Take
note that, when parity is enabled, the computed parity is inserted at the MSB position of the
transmitted data (9th bit when the word length is set to 9 data bits; 8th bit when the word
length is set to 8 data bits). Parity is a very simple form of error checking. It comes in two
flavors: odd or even. To produce the parity bit, all data bits are added up, and the evenness of
the sum decides whether the bit is set or not. For example, assuming parity is set to even and
was being added to a data byte like 0b01011101, which has an odd number of 1’s (5), the parity
bit would be set to 1. Conversely, if the parity mode was set to odd, the parity bit would be 0.
Parity is optional, and not very widely used. It can be helpful for transmitting across noisy
mediums, but it will also slow down data transfer a bit and requires both sender and receiver
to implement error-handling (usually, received data that fails must be re-sent). When a parity
error occurs, all STM32 MCUs generate a specific interrupt, as we will see next.
• Mode : it specifies whether the RX or TX mode is enabled or disabled. This field can assume one
of the values from Table 4.
• HwFlowCtl :itspecifieswhethertheRS232⁶HardwareFlowControlmodeisenabledordisabled.
This parameter can assume one of the values from Table 5.
Table 3: Available parity modes for a UART connection
Parity Mode Description
UART_PARITY_NONE No parity check enabled
UART_PARITY_EVEN The parity bit is set to 1 if the count of bits equal to 1 is odd
UART_PARITY_ODD The parity bit is set to 1 if the count of bits equal to 1 is even
Table 4: Available UART modes
UART Mode Description
UART_MODE_RX The UART is configured only in receive mode
UART_MODE_TX The UART is configured only in transmit mode
UART_MODE_TX_RX The UART is configured to work bot in receive an transmit mode
⁶ this field is only used to enable the RS232 flow control. To enable the RS485 flow control, the HAL provides a specific function, HAL_-
RS485Ex_Init() , defined inside the stm32xxxx_hal_uart_ex.c file.
Universal Asynchronous Serial Communications 230
Table 5: Available flow control mode for a UART connection
Flow Control Mode Description
UART_HWCONTROL_NONE The Hardware Flow Control is disabled
UART_HWCONTROL_RTS The Request To Send(RTS) line is enabled
UART_HWCONTROL_CTS The Clear To Send(CTS) line is enabled
UART_HWCONTROL_RTS_CTS Both RTS and CTS lines enabled
• OverSampling : when the UART receives a frame from the remote peer, it samples the signals
in order to compute the number of 1 and 0 constituting the message. Oversampling is the
techniqueofsamplingasignalwithasamplingfrequencysignificantlyhigherthantheNyquist
rate. The receiver implements different user-configurable oversampling techniques (except in
synchronous mode) for data recovery by discriminating between valid incoming data and
noise. This allows a trade-off between the maximum communication speed and noise/clock
inaccuracy immunity. The OverSampling field can assume the value UART_OVERSAMPLING_16 to
perform 16 samples for each frame bit or UART_OVERSAMPLING_8 to perform 8 samples. Table 2
shows the error calculation for programmed baud rates at 48 MHz in an STM32F030 MCU in
both cases of oversampling by 16 or by 8.
Now it is a good time to start writing down a bit of code. Let us see how to configure the USART2
of the MCU equipping our Nucleo to exchange messages through the ST-LINK interface.
int main(void) {
UART_HandleTypeDef huart2;
/* Initialize the HAL */
HAL_Init();
/* Configure the system clock */
SystemClock_Config();
/* Configure the USART2 */
huart2.Instance = USART2;
huart2.Init.BaudRate = 38400;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
HAL_UART_Init(&huart2);
...
}
Universal Asynchronous Serial Communications 231
The first step is to configure the USART2 peripheral. Here we are using this configuration: 38400, N,
1. That is, a BaudRate equal to 38400 Bps, no parity check and just one stop bit. Next, we disable any
form of Hardware Flow Control and we choose the highest oversampling rate, that is 16 clock ticks
for each transmitted bit. The call to the HAL_UART_Init() function ensures that the HAL initializes
the USART2 according the given options.
However, the above code is still not sufficient to exchange messages through the Nucleo Virtual
COM Port. Don’t forget that every peripheral designed to exchange data with the outside world
must be properly bound to corresponding GPIOs, that is we have to configure the USART2 TX and
RX pins. Looking to the Nucleo schematics, we can see that USART2 TX and RX pins are PA2 and
PA3 respectively. Moreover, we have already seen in Chapter 4 that the HAL is designed so that
HAL_UART_Init() function automatically calls the HAL_UART_MspInit() (see Figure 19 in Chapter 4)
to properly initialize the I/Os: it is our responsibility to write this function in our application code,
which we will be automatically called by the HAL.
Is It Mandatory to Define This Function?
The answer is simply no. This is just a practice enforced by the HAL and by the code
automatically generated by CubeMX. The HAL_UART_MspInit() , and the corresponding
function HAL_UART_MspDeInit() which is called by the HAL_UART_DeInit() function, are
declared inside the HAL in this way:
__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart);
The function attribute __weak is a GCC way to declare a symbol (here, a function name)
with a weak scope visibility, which we will be overwritten if another symbol with the same
name with a global scope (that is, without the __weak attribute) is defined elsewhere in the
application (that is, in another relocatable file). The linker will automatically substitute the
call to the function HAL_UART_MspInit() defined inside the HAL if we implement it in our
application code.
The code below shows how to correctly code the HAL_UART_MspInit() function.
void HAL_UART_MspInit(UART_HandleTypeDef* huart) {
GPIO_InitTypeDef GPIO_InitStruct;
if(huart->Instance==USART2) {
/* Peripheral clock enable */
__HAL_RCC_USART2_CLK_ENABLE();
/**USART2 GPIO Configuration
PA2 ------> USART2_TX
PA3 ------> USART2_RX
*/
GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
Universal Asynchronous Serial Communications 232
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
GPIO_InitStruct.Alternate = GPIO_AF1_USART2; /* WARNING: this depends on
the specific STM32 MCU */
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
}
}
As you can see, the function is designed so that it is common for every USART used inside the
application. The if statement disciplines the initialization code for the given USART (in our case,
USART2). The remaining of code configures the PA2 and PA3 pins. Please, take note that the
alternate function may change for the MCU equipping your Nucleo. Consult the book examples
to see the right initialization code for your Nucleo.
Once we have configured the USART2 interface, we can start exchanging messages with our PC.
Please, take note that the code presented before could not be sufficient to correctly initialize
the USART peripheral for some STM32 MCUs. Some STM32 microcontrollers, like the
STM32F334R8, allow the developer to choose the clock source for a given peripheral (for
example, the USART2 in an STM32F334R8 MCU can be optionally clocked from SYSCLK ,
HSI , LSE or PCLK1 ). It is strongly suggested to use CubeMX the first time you configure the
peripherals for your MCU and to check carefully the generated code looking for this kind of
exceptions. Otherwise, the datasheet is the only source for this information.
8.2.1 UART Configuration Using CubeMX
As said before, the first time we configure the USART2 for our Nucleo it is best to use CubeMX.
The first step is enabling the USART2 peripheral inside the Pinout view, selecting the Asynchronous
entry from the Mode combo box, as shown inFigure 5. Both PA2 and PA3 pins will be automatically
highlighted in green. Then, go inside the Configuration section and click on the USART2 button.
The configuration dialog will appear, as shown in Figure 5 on the right⁷. This allows us to configure
the USART configuration settings, such as the BaudRate, word length and so on⁸.
Once we have configured the USART interface, we can generate the C code. You will notice that
CubeMX places all the USART2 initialization code inside the MX_USART2_UART_Init() (which is
contained in the main.c file). Instead, all the code related to GPIO configuration is placed into the
HAL_UART_MspInit() function, which is contained inside the stm32xxxx_hal_msp.c file.
⁷ Please, take note that the Figure 5 is obtained combining two captures in one figure. It is not possible to show the USART configuration
dialog from the Pinout view.
⁸ Some of you, especially those having a Nucleo-F3, will notice that the configuration dialog is different from the one shown in Figure 5.
Please, refer to the reference manual for your target MCU for more information.
Universal Asynchronous Serial Communications 233
Figure 5: CubeMX can be used to configure the UART2 interface easily
8.3 UART Communication in Polling Mode
STM32 microcontrollers, and hence the CubeHAL, offer three ways to exchange data between peers
over a UART communication: polling, interrupt and DMA mode. It is important to stress right from
now that these modes are not only three different flavors to handle UART communications. They
are three different programming approach to the same task, which introduce several benefits both
from the design and performance point of view. Let us introduce them briefly.
• In polling mode, also called blocking mode, the main application, or one of its threads,
synchronously waits for the data transmission and reception. This is the most simple form
of data communication using this peripheral, and it can be used when the transmit rate is not
too much low and when the UART is not used as critical peripheral in our application (the
classical example is the usage of the UART as output console for debug activities).
• In interrupt mode, also called non-blocking mode, the main application is freed from waiting
for the completion of data transmission and reception. The data transfer routines terminate
as soon as they complete to configure the peripheral. When the data transmission ends, a
subsequent interrupt will signal the main code about this. This mode is more suitable when
communication speed is low (below 38400 Bps) or when it happens “rarely”, compared to other
activities performed by the MCU, and we do not want to stuck it waiting for data transmission.
Universal Asynchronous Serial Communications 234
• DMA mode offers the best data transmission throughput, thanks to the direct access of the
UARTperipheraltoMCUinternalRAM.Thismodeisbestforhigh-speedcommunicationsand
when we totally want to free the MCU from the overhead of data transmission. Without the
DMAmode, it is almost impossible to reach the fastest transfer rates that the USART peripheral
is capable to handle. In this chapter we will not see this USART communication mode, leaving
it to the next chapter dedicated to DMA management.
To transmit a sequence of bytes over the USART in polling mode the HAL provides the function
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData,
uint16_t Size, uint32_t Timeout);
where:
• huart : it is the pointer to an instance of the struct UART_HandleTypeDef seen before, which
identifies and configures the UART peripheral;
• pData : is the pointer to an array, with a length equal to the Size parameter, containing the
sequence of bytes we are going to transmit;
• Timeout : is the maximum time, expressed in milliseconds, we are going to wait for the transmit
completion. If the transmission does not complete in the specified timeout time, the function
aborts and returns the HAL_TIMEOUT value; otherwise it returns the HAL_OK value if no other
errors occur. Moreover, we can pass a timeout equal to HAL_MAX_DELAY ( 0xFFFF FFFF ) to wait
indefinitely for the transmit completion.
Conversely, to receive a sequence of bytes over the USART in polling mode the HAL provides the
function
HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData,
uint16_t Size, uint32_t Timeout);
where:
• huart : it is the pointer to an instance of the struct UART_HandleTypeDef seen before, which
identifies and configures the UART peripheral;
• pData : is the pointer to an array, with a length at lest equal to the Size parameter, containing
the sequence of bytes we are going to receive. The function will block until all bytes specified
by the Size parameter are received.
• Timeout : is the maximum time, expressed in milliseconds, we are going to wait for the receive
completion. If the transmission does not complete in the specified timeout time, the function
aborts and returns the HAL_TIMEOUT value; otherwise it returns the HAL_OK value if no other
errors occur. Moreover, we can pass a timeout equal to HAL_MAX_DELAY ( 0xFFFF FFFF ) to wait
indefinitely for the receive completion.
Universal Asynchronous Serial Communications 235
Read Carefully
It is important to remark that the timeout mechanism offered by the two functions works
only if the HAL_IncTick() routine is called every 1ms, as done by the code generated by
CubeMX (the function that increments the HAL tick counter is called inside the SysTick
timer ISR).
Ok. Now it is the right time to see an example.
Filename: src/main-ex1.c
21 int main(void) {
22 uint8_t opt = 0;
23
24 /* Reset of all peripherals, Initializes the Flash interface and the SysTick. */
25 HAL_Init();
26
27 /* Configure the system clock */
28 SystemClock_Config();
29
30 /* Initialize all configured peripherals */
31 MX_GPIO_Init();
32 MX_USART2_UART_Init();
33
34 printMessage:
35
36 printWelcomeMessage();
37
38 while (1) {
39 opt = readUserInput();
40 processUserInput(opt);
41 if(opt == 3)
42 goto printMessage;
43 }
44 }
45
46 void printWelcomeMessage(void) {
47 HAL_UART_Transmit(&huart2, (uint8_t*)"\033[0;0H", strlen("\033[0;0H"), HAL_MAX_DELAY);
48 HAL_UART_Transmit(&huart2, (uint8_t*)"\033[2J", strlen("\033[2J"), HAL_MAX_DELAY);
49 HAL_UART_Transmit(&huart2, (uint8_t*)WELCOME_MSG, strlen(WELCOME_MSG), HAL_MAX_DELAY);
50 HAL_UART_Transmit(&huart2, (uint8_t*)MAIN_MENU, strlen(MAIN_MENU), HAL_MAX_DELAY);
51 }
52
53 uint8_t readUserInput(void) {
54 char readBuf[1];
55
56 HAL_UART_Transmit(&huart2, (uint8_t*)PROMPT, strlen(PROMPT), HAL_MAX_DELAY);
57 HAL_UART_Receive(&huart2, (uint8_t*)readBuf, 1, HAL_MAX_DELAY);
Universal Asynchronous Serial Communications 236
58 return atoi(readBuf);
59 }
60
61 uint8_t processUserInput(uint8_t opt) {
62 char msg[30];
63
64 if(!opt || opt > 3)
65 return 0;
66
67 sprintf(msg, "%d", opt);
68 HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
69
70 switch(opt) {
71 case 1:
72 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
73 break;
74 case 2:
75 sprintf(msg, "\r\nUSER BUTTON status: %s",
76 HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_RESET ? "PRESSED" : "RELEASED");
77 HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
78 break;
79 case 3:
80 return 2;
81 };
82
83 return 1;
84 }
The example is a sort of bare-bone management console. The application starts printing a welcome
message (lines 36) and then entering in a loop waiting for the user choice. The first option allows
to toggle the LD2 LED, while the second to read the status of the USER button. Finally, the option 3
causes that the welcome screen is printed again.
The two strings "\033[0;0H" and "\033[2J" are escape sequences. They are standard
sequences of chars used to manipulate the terminal console. The first one places the cursor
in the top-left part of the available console screen, and the second one clears the screen.
To interact with this simple management console, we need a serial communication program. There
are several options available. The easy one is to use a standalone program like putty ⁹ for the
Windows platform (if you have an old Windows version, you can also consider to use the classical
HyperTerminal tool), or kermit ¹⁰ for Linux and MacOS. However, we will now introduce a solution
to have an integrated serial communication tool inside the Eclipse IDE. As usual, the instructions
differ between Windows, Linux and MacOS.
⁹ http://bit.ly/1jsQjnt
¹⁰ http://www.columbia.edu/kermit/
Universal Asynchronous Serial Communications 237
8.3.1 Installing a Serial Console in Windows
For the Windows OS we have a simple and reliable solution. This is based on two plug-ins. The first
oneisawrapperplug-inaroundtheRXTX¹¹Javalibrary.Toinstallit,gotoHelp->Installsoftware…
menu, then click on the Add… button, and fill the fields in the following way: (see Figure 6).
Name: RXTX
Location: http://rxtx.qbang.org/eclipse/
Figure 6: The dialog to add a new plug-in repository
Click on OK and install the release RXTX 2.1-7r4 following the instructions.
Nowweneedtoinstallsomefilestoenabletheplugintoaccessyourcomputersserialporthardware.
FirstweneedtodownloadtheWindowsbinariesfromthefollowinglink:http://fizzed.com/oss/rxtx-
for-java. If you’re using 32-bit Java download the Windows-x86 packet. For 64-bit Java download
the Windows-x64 packet. Extract the downloaded file into a folder of your choice. Finally we need
to copy these files into the Java Runtime Environment folder¹²:
• Copy RXTXcomm.jar to C:\Program Files\Java\jre1.8.0_121\lib\ext .
• Copy rxtxParallel.dll and rxtxSerial.dll to C:\Program Files\Java\jre1.8.0_121\bin .
• For32-bitJavachangethepathsto C:\Program Files (x86)\Java\jre1.8.0_121\lib\ext and
C:\Program Files (x86)\Java\jre1.8.0_121\bin .
We can now proceed by installing a terminal plug-in for Eclipse. Go to Help->Eclipse Market-
place….IntheFindtextboxwrite“terminal”.Afterawhile,theTMTerminalplug-inshouldappear,
as shown in Figure 7. Click on the Install button and follow the instructions. Restart Eclipse when
requested.
¹¹ http://rxtx.qbang.org/
¹² Replace the JRE version ( \jre1.8.0_121\ ) with your installed version of the JRE.
Universal Asynchronous Serial Communications 238
Figure 7: The Eclipse Marketplace
To open the Terminal panel you can simply press Ctrl+Alt+T, or you can go to Window->Show
View->Other… menu and search for Terminal view.
Figure 8: How to start a new terminal
By default, the Terminal pane opens a new command line prompt. Click on the Open a Terminal
Universal Asynchronous Serial Communications 239
icon (the one circled in red in Figure 8). In the Launch Terminal dialog (see Figure 9) select Serial
Terminal as terminal type, and then select the COM Port corresponding to the Nucleo VCP, and
38400Bps as Baud Rate. Click on the OK button.
Figure 9: Terminal type selection dialog
Now you can reset the Nucleo. The management console we have programmed using the HAL_UART
library should appear in the serial console window, as shown in Figure 10.
Figure 10: The Nucleo management console shown in the terminal view
8.3.2 Installing a Serial Console in Linux and MacOS X
Unfortunately, installing the RXTX plug-in on Linux and MacOS X is not a trivial task. For this
reason we will go another way.
The first step is installing the kermit tool. To install it in Linux, type at command line:
Universal Asynchronous Serial Communications 240
$ sudo apt-get install ckermit
while to install it in MacOS X type:
$ sudo port install kermit
Once,theinstallationhasbeencompleted,switchtoEclipseandgotoHelp->EclipseMarketplace….
In the Find text box write “terminal”. After a while, the TM Terminal plug-in should appear, as
shown in Figure 7. Click on the Install button and follow the instructions. Restart Eclipse when
requested.
To open the Terminal panel you can simply press Ctrl+Alt+T, or you can go to Window->Show
View->Other… menu and search for Terminal view. The command line prompt appears. Before we
can connect to the Nucleo VCP, we have to identify the corresponding device under the /dev path.
Usually, on UNIX like systems the USB serial devices are mapped with a device name similar to
/dev/tty.usbmodem1a1213 . Take a look at your /dev folder. Once you grab the device filename, you
can launch the kermit tool and execute the commands shown below at the kermit console:
$ kermit
C-Kermit 9.0.302 OPEN SOURCE:, 20 Aug 2011, for Mac OS X 10.9 (64-bit)
Copyright (C) 1985, 2011,
Trustees of Columbia University in the City of New York.
Type ? or HELP for help.
(/Users/cnoviello/) C-Kermit>set line /dev/tty.usbmodem1a1213
(/Users/cnoviello/) C-Kermit>set speed 38400
/dev/tty.usbmodem1a1213, 38400 bps
(/Users/cnoviello/) C-Kermit>set carrier-watch off
(/Users/cnoviello/) C-Kermit>c
Connecting to /dev/tty.usbmodem1a1213, speed 38400
Escape character: Ctrl-\ (ASCII 28, FS): enabled
Type the escape character followed by C to get back,
or followed by ? to see other options.
----------------------------------------------------
To avoid retyping the above commands every time you launch kermit , you can create a
file named ∼/.kermrc inside your home directory, and put inside it the above commands.
kermit will load those commands automatically when it is executed.
Now you can reset the Nucleo. The management console we have programmed using the HAL_UART
library should appear in the serial console window, as shown in Figure 10.
Universal Asynchronous Serial Communications 241
8.4 UART Communication in Interrupt Mode
Let us consider again the first example of this chapter. What’s wrong with it? Since our firmware
is all committed to this simple task, there is nothing wrong by using the UART in polling mode.
The MCU is essentially blocked waiting for the user input (the HAL_MAX_DELAY timeout value blocks
the HAL_UART_Receive() until one char is sent over the UART). But what if our firmware has to
accomplish other cpu-intensive activities in real-time?
Suppose to rearrange the main() from the first example in the following way:
38 while (1) {
39 opt = readUserInput();
40 processUserInput(opt);
41 if(opt == 3)
42 goto printMessage;
43
44 performCriticalTasks();
45 }
In this case we cannot block the execution of function processUserInput() waiting for the user
choice, but we have to specify a much more short timeout value to the HAL_UART_Receive()
function, otherwise performCriticalTasks() is never executed. However, this could cause the loss
of important data coming from the UART peripheral (remember that the UART interface has a one
byte wide buffer).
To address this issue the HAL offers another way to exchange data over a UART peripheral: the
interrupt mode. To use this mode, we have to accomplish the following tasks:
• To enable the USARTx_IRQn interrupt and to implement the corresponding USARTx_IRQHan-
dler() ISR.
• Tocall HAL_UART_IRQHandler() insidethe USARTx_IRQHandler() :thiswillperformallactivities
related to management of interrupts generated by the UART peripheral¹³.
• To use the functions HAL_UART_Transmit_IT() and HAL_UART_Receive_IT() to exchange data
over the UART. These functions also enables theinterrupt mode of the UART peripheral: in this
way the peripheral will assert the corresponding line in the NVIC controller so that the ISR is
raised when an event occurs.
• To rearrange our application code to deal with asynchronous events.
Before we rearrange the code from the first example, it is best to take a look at the available UART
interrupts and to the way HAL routines are designed.
¹³ If we use CubeMX to enable the USARTx_IRQn from the NVIC configuration section (as shown in Chapter 7), it will automatically place
the call to the HAL_UART_IRQHandler() from the ISR.
Universal Asynchronous Serial Communications 242
8.4.1 UART Related Interrupts
Every STM32 USART peripheral provides the interrupts listed in Table 6. These interrupts include
both IRQs related to data transmission and to communication errors. They can be divided in two
groups:
• IRQs generated during transmission: Transmission Complete, Clear to Send or Transmit Data
Register empty interrupt.
• IRQs generated while receiving: Idle Line detection, Overrun error, Receive Data register not
empty, Parity error, LIN break detection, Noise Flag (only in multi buffer communication) and
Framing Error (only in multi buffer communication).
Table 6: The list of USART related interrupts
Interrupt Event Event Flag Enable Control Bit
Transmit Data Register Empty TXE TXEIE
Clear To Send (CTS) flag CTS CTSIE
Transmission Complete TC TCIE
Received Data Ready to be Read RXNE RXNEIE
Overrun Error Detected ORE RXNEIE
Idle Line Detected IDLE IDLEIE
Parity Error PE PEIE
Break Flag LBD LBDIE
Noise Flag, Overrun error and Framing
Error in multi buffer communication
NF or ORE or FE EIE
These events generate an interrupt if the corresponding Enable Control Bit is set (third column of
Table 6). However, STM32 MCUs are designed so that all these IRQs are bound to just one ISR
for every USART peripheral (see Figure 11¹⁴). For example, the USART2 defines only the USART2_-
IRQn as IRQ for all interrupts generated by this peripheral. It is up to the user code to analyze the
corresponding Event Flag to infer which interrupt has generated the request.
¹⁴ The Figure 9s taken from the STM32F030 Reference Manual (RM0390).
Universal Asynchronous Serial Communications 243
Figure 11: How the USART interrupt events are connected to the same interrupt vector
The CubeHAL is designed to automatically do this job for us. The user is warned about the interrupt
generation thanks to a series of callback functions invoked by the HAL_UART_IRQHandler() , which
must be called inside the ISR.
From a technical point of view, there is not so much difference between UART transmission in
polling and in interrupt mode. Both the methods transfer an array of bytes using the UART Data
Register (DR) with the following algorithm:
• For data transmission, place a byte inside the USART->DR register and wait until the Transmit
Data Register Empty(TXE) flag is asserted true.
• For data reception, wait until the Received Data Ready to be Read(RXNE) is not asserted true,
and then store the content of the USART->DR register inside the application memory.
The difference between the two methods consists in how they wait for the completion of data trans-
mission. In polling mode, the HAL_UART_Receive()/HAL_UART_Transmit() functions are designed
so that it waits for the corresponding event flag to be set, for every byte we want to transmit. In
interruptmode,thefunction HAL_UART_Receive_IT()/HAL_UART_Transmit_IT() aredesignedsothat
they do not wait for data transmission completion, but the dirty job to place a new byte inside the
DR register, or to load its content inside the application memory, is accomplished by the ISR routine
when the RXNEIE/TXEIE interrupt is generated¹⁵.
To transmit a sequence of bytes in interrupt mode, the HAL defines the function:
¹⁵ This is the reason why transferring a sequence of bytes in interrupt mode is not a smart thing when the communication speed is too high,
or when we have to transfer a great amount of data very often. Since the transmission of each byte happens quickly, the CPU will be congested
by the interrupts generated by the UART for every byte transmitted. For continuous transmission of great sequences of bytes at high speed is
best to use the DMA mode, as we will see in the next chapter.
Universal Asynchronous Serial Communications 244
HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart,
uint8_t *pData, uint16_t Size);
where:
• huart : it is the pointer to an instance of the struct UART_HandleTypeDef seen before, which
identifies and configures the UART peripheral;
• pData : it is the pointer to an array, with a length equal to the Size parameter, containing the
sequence of bytes we are going to transmit; the function will not block waiting for the data
transmission, and it will pass the control to the main flow as soon as it completes to configure
the UART.
Conversely, to receive a sequence of bytes over the USART in interrupt mode the HAL provides the
function:
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart,
uint8_t *pData, uint16_t Size);
where:
• huart : it is the pointer to an instance of the struct UART_HandleTypeDef seen before, which
identifies and configures the UART peripheral;
• pData : it is the pointer to an array, with a length at lest equal to the Size parameter, containing
the sequence of bytes we are going to receive. The function will not block waiting for the data
reception, and it will pass the control to the main flow as soon as it completes to configure the
UART.
Now we can proceed rearranging the first example.
Filename: src/main-ex2.c
37 /* Enable USART2 interrupt */
38 HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
39 HAL_NVIC_EnableIRQ(USART2_IRQn);
40
41 printMessage:
42 printWelcomeMessage();
43
44 while (1) {
45 opt = readUserInput();
46 if(opt > 0) {
47 processUserInput(opt);
48 if(opt == 3)
49 goto printMessage;
Universal Asynchronous Serial Communications 245
50 }
51 performCriticalTasks();
52 }
53 }
54
55 int8_t readUserInput(void) {
56 int8_t retVal = -1;
57
58 if(UartReady == SET) {
59 UartReady = RESET;
60 HAL_UART_Receive_IT(&huart2, (uint8_t*)readBuf, 1);
61 retVal = atoi(readBuf);
62 }
63 return retVal;
64 }
65
66
67 uint8_t processUserInput(int8_t opt) {
68 char msg[30];
69
70 if(!(opt >=1 && opt <= 3))
71 return 0;
72
73 sprintf(msg, "%d", opt);
74 HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
75 HAL_UART_Transmit(&huart2, (uint8_t*)PROMPT, strlen(PROMPT), HAL_MAX_DELAY);
76
77 switch(opt) {
78 case 1:
79 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
80 break;
81 case 2:
82 sprintf(msg, "\r\nUSER BUTTON status: %s",
83 HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_RESET ? "PRESSED" : "RELEASED");
84 HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
85 break;
86 case 3:
87 return 2;
88 };
89
90 return 1;
91 }
92
93 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle) {
94 /* Set transmission flag: transfer complete*/
95 UartReady = SET;
96 }
Universal Asynchronous Serial Communications 246
As you can see in the above code, the first step is to enable the USART2_IRQn and to assign it a
priority¹⁶. Next, we define the corresponding ISR inside the stm32xxxx_it.c file (not shown here)
and we add the call to the HAL_UART_IRQHandler() function inside it. The remaining part of the
example file is all about restructuring the readUserInput() and processUserInput() functions to
deal with asynchronous events.
The function readUserInput() now checks for the value of the global variable UartReady . If it is
equal to SET , it means that the user has sent a char to the management console. This character is
contained inside the global array readBuf . The function then calls the HAL_UART_Receive_IT() to
receive another character in interrupt mode. When readUserInput() returns a value greater than 0 ,
thefunction processUserInput() iscalled.Finally,thefunction HAL_UART_RxCpltCallback() ,which
is automatically called by the HAL when one byte is received, is defined: it simply sets the global
UartReady variable, which in turn is used by the readUserInput() as seen before.
It is important to clarify that the function HAL_UART_RxCpltCallback() is called only when all
the bytes specified with the Size parameter, passed to the HAL_UART_Receive_IT() function, are
received.
What about the HAL_UART_Transmit_IT() function? It works in a way similar to the HAL_UART_Re-
ceive_IT() :ittransfersthenextbyteinthearrayeverytimetheTransmitDataRegisterEmpty(TXE)
interrupt is generated. However, special care must be taken when calling it multiple times. Since the
function returns the control to the caller as soon as it finishes to setup the UART, a subsequent call
of the same function will fail and it will return the HAL_BUSY value.
Suppose to rearrange the function printWelcomeMessage() from the previous example in the
following way:
void printWelcomeMessage(void) {
HAL_UART_Transmit_IT(&huart2, (uint8_t*)"\033[0;0H", strlen("\033[0;0H"));
HAL_UART_Transmit_IT(&huart2, (uint8_t*)"\033[2J", strlen("\033[2J"));
HAL_UART_Transmit_IT(&huart2, (uint8_t*)WELCOME_MSG, strlen(WELCOME_MSG));
HAL_UART_Transmit_IT(&huart2, (uint8_t*)MAIN_MENU, strlen(MAIN_MENU));
HAL_UART_Transmit_IT(&huart2, (uint8_t*)PROMPT, strlen(PROMPT));
}
The abovecode will neverwork correctly, since each call to the function HAL_UART_Transmit_IT() is
much faster than the UART transmission, and the subsequent calls to the HAL_UART_Transmit_IT()
will fail.
If speed is not a strict requirement for your application, and the use of the HAL_UART_Transmit_IT()
is limited to few parts of your application, the above code could be rearranged in the following way:
¹⁶ The example is designed for an STM32F4. Please, refer to the book examples for your specific Nucleo.
Universal Asynchronous Serial Communications 247
void printWelcomeMessage(void) {
char *strings[] = {"\033[0;0H", "\033[2J", WELCOME_MSG, MAIN_MENU, PROMPT};
for (uint8_t i = 0; i < 5; i++) {
HAL_UART_Transmit_IT(&huart2, (uint8_t*)strings[i], strlen(strings[i]));
while (HAL_UART_GetState(&huart2) == HAL_UART_STATE_BUSY_TX ||
HAL_UART_GetState(&huart2) == HAL_UART_STATE_BUSY_TX_RX);
}
}
Here we transfer each string using the HAL_UART_Transmit_IT() but, before we transfer the next
string, we wait to the transmission completion. However, this is just a variant of the HAL_UART_-
Transmit() , since we have a busy wait for every UART transfer.
A more elegant and performing solution is to use a temporary memory area where to store the byte
sequences and to let the ISR to execute the transfer. A queue is the best options to handle FIFO
events. There are several ways to implement a queue, both using static and dynamic data structure.
If we decide to implement a queue with a predefined area of memory, a circular buffer is the data
structure suitable for this kind of applications.
Figure 12: A circular buffer implemented using an array and two pointers
Acircularbufferis nothingmorethanan arraywith afixed sizewheretwopointers areused tokeep
track of the head and the tail of data that still needs to be processed. In a circular buffer, the first and
the last position of the array are seen “contiguous” (see Figure 12). This is the reason why this data
structure is called circular. Circular buffers have an important feature too: unless our application
Universal Asynchronous Serial Communications 248
has up to two concurrent execution streams (in our case, the main flow that places chars inside the
buffer and the ISR routine that sends these chars over the UART), they are intrinsically thread safe,
since the “consumer” thread (the ISR in our case) will update only the tail pointer and the producer
(the main flow) will update only the head one.
Circular buffers can be implemented in several ways. Some of them are faster, others are more safe
(that is, they add an extra overhead ensuring that we handle the buffer content correctly). You will
find a simple and quite fast implementation in the book examples. Explaining how it is coded is
outside the scope of this book.
Using a circular buffer, we can define a new UART transmit function in the following way:
uint8_t UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t len) {
if(HAL_UART_Transmit_IT(huart, pData, len) != HAL_OK) {
if(RingBuffer_Write(&txBuf, pData, len) != RING_BUFFER_OK)
return 0;
}
return 1;
}
The function does just two things: it tries to send the buffer over the UART in interrupt mode; if the
HAL_UART_Transmit_IT() functionfails(whichmeansthattheUARTisalreadytransmittinganother
message), then the byte sequence is placed inside a circular buffer.
It is up to the HAL_UART_TxCpltCallback() to check for pending bytes inside the circular buffer:
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
if(RingBuffer_GetDataLength(&txBuf) > 0) {
RingBuffer_Read(&txBuf, &txData, 1);
HAL_UART_Transmit_IT(huart, &txData, 1);
}
}
The RingBuffer_Read() it is not really fast as it could be with a more performant
implementation. For some real world situations, the whole overhead of the HAL_UART_-
TxCpltCallback() routine (that is called from the ISR routine) could be too high. If this
is your case, you can consider to create a function like the following one:
void processPendingTXTransfers(UART_HandleTypeDef *huart) {
if(RingBuffer_GetDataLength(&txBuf) > 0) {
RingBuffer_Read(&txBuf, &txData, 1);
HAL_UART_Transmit_IT(huart, &txData, 1);
}
}
Then, you could call this function from the main application code or in a lower privileged
task if you are using an RTOS.
Universal Asynchronous Serial Communications 249
8.5 Error Management
When dealing with external communications, the error management is an aspect that we must
strongly take in consideration. An STM32 UART peripheral offers some error flags related to
communication errors. Moreover, it is possible to enable a corresponding interrupt to be noticed
when the error occurs.
The CubeHAL is designed to automatically detect error conditions, and to warn us about them. We
only need to implement the HAL_UART_ErrorCallback() function inside our application code. The
HAL_UART_IRQHandler() will automatically invoke it in case an error occurs. To understand which
error has been occurred, we can check the value of the UART_HandleTypeDef->ErrorCode field. The
list of error codes is reported in Table 7.
Table 7: List of UART_HandleTypeDef->ErrorCode possible values
UART Error Code Description
HAL_UART_ERROR_NONE No error occurred
HAL_UART_ERROR_PE Parity check error
HAL_UART_ERROR_NE Noise error
HAL_UART_ERROR_FE Framing error
HAL_UART_ERROR_ORE Overrun error
HAL_UART_ERROR_DMA DMA Transfer error
The HAL_UART_IRQHandler() is designed so that we should not care with the implementation details
of UART error management. The HAL code will automatically perform all needed steps to handle
the error (like clearing event flags, pending bit and so on), leaving to us the responsibility to handle
theerroratapplicationlevel(forexample,wemayasktotheotherpeertoresendacorruptedframe).
Read Carefully
At the time of writing this chapter, December 2nd 2015, a subtle bug prevents the right
management of the Overrun error. You can read more about it on the official ST forum¹⁷.
You can reproduce this bug even with the second example of this chapter. Run the example
on your Nucleo, and hit the key ‘3’ on your keyboard leaving it pressed. After a while,
the firmware will hang. This happens because, after the Overrun error occurs, the HAL
does not restart the receiving process again. You can address this bug implementing the
HAL_UART_ErrorCallback() function in the following way:
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
if(huart->ErrorCode == HAL_UART_ERROR_ORE)
HAL_UART_Receive_IT(huart, readBuf, 1);
}
}
¹⁷ http://bit.ly/1Pvim7X
Universal Asynchronous Serial Communications 250
8.6 I/O Retargeting
In Chapter 5 we have learned how to use the semihosting feature to send debug messages to the
OpenOCD console using the C printf() function. If you have already used this feature, you know
that there are two strong limitations:
• semihosting really slows down the firmware execution;
• it also prevents your firmware from working if it is executed without a debug session (due to
the fact that semihosting is implemented using software breakpoints).
Now that we are familiar with the UART management, we can redefine the needed system calls
( _write() , _read() and so on) to retarget the STDIN , STDOUT and STDERR standard streams to the
Nucleo USART2. This can be easily done in the following way:
Filename: system/src/retarget/retarget.c
14 #if !defined(OS_USE_SEMIHOSTING)
15
16 #define STDIN_FILENO 0
17 #define STDOUT_FILENO 1
18 #define STDERR_FILENO 2
19
20 UART_HandleTypeDef *gHuart;
21
22 void RetargetInit(UART_HandleTypeDef *huart) {
23 gHuart = huart;
24
25 /* Disable I/O buffering for STDOUT stream, so that
26 * chars are sent out as soon as they are printed. */
27 setvbuf(stdout, NULL, _IONBF, 0);
28 }
29
30 int _isatty(int fd) {
31 if (fd >= STDIN_FILENO && fd <= STDERR_FILENO)
32 return 1;
33
34 errno = EBADF;
35 return 0;
36 }
37
38 int _write(int fd, char* ptr, int len) {
39 HAL_StatusTypeDef hstatus;
40
41 if (fd == STDOUT_FILENO || fd == STDERR_FILENO) {
42 hstatus = HAL_UART_Transmit(gHuart, (uint8_t *) ptr, len, HAL_MAX_DELAY);
43 if (hstatus == HAL_OK)
Universal Asynchronous Serial Communications 251
44 return len;
45 else
46 return EIO;
47 }
48 errno = EBADF;
49 return -1;
50 }
51
52 int _close(int fd) {
53 if (fd >= STDIN_FILENO && fd <= STDERR_FILENO)
54 return 0;
55
56 errno = EBADF;
57 return -1;
58 }
59
60 int _lseek(int fd, int ptr, int dir) {
61 (void) fd;
62 (void) ptr;
63 (void) dir;
64
65 errno = EBADF;
66 return -1;
67 }
68
69 int _read(int fd, char* ptr, int len) {
70 HAL_StatusTypeDef hstatus;
71
72 if (fd == STDIN_FILENO) {
73 hstatus = HAL_UART_Receive(gHuart, (uint8_t *) ptr, 1, HAL_MAX_DELAY);
74 if (hstatus == HAL_OK)
75 return 1;
76 else
77 return EIO;
78 }
79 errno = EBADF;
80 return -1;
81 }
82
83 int _fstat(int fd, struct stat* st) {
84 if (fd >= STDIN_FILENO && fd <= STDERR_FILENO) {
85 st->st_mode = S_IFCHR;
86 return 0;
87 }
88
89 errno = EBADF;
90 return 0;
Universal Asynchronous Serial Communications 252
91 }
92
93 #endif //#if !defined(OS_USE_SEMIHOSTING)
To retarget the standard streams in your firmware, you have to remove the macro OS_USE_SEMI-
HOSTING at project level, and to initialize the library calling the RetargetInit() passing the pointer
to the UART_HandleTypeDef instance of the UART2. For example, the following code shows how to
use printf() / scanf() functions in your firmware:
int main(void) {
char buf[20];
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
RetargetInit(&huart2);
printf("Write your name: ");
scanf("%s", buf);
printf("\r\nHello %s!\r\n", buf);
while(1);
}
If you are going to use printf() / scanf() functions to print/read float datatypes on the serial
console (but also if you are going to use sprintf() and similar routines), you need to explicitly
enable float support in newlib-nano , which is the more compact version of the C runtime library
for embedded systems. To do this, go to Project->Properties… menu, then go to C/C++ Build-
>Settings->Cross ARM C++ Linker->Miscellaneous and check Use float with nano printf/scanf
according the feature you need, as shown in Figure 13. This will increase the firmware binary size.
Universal Asynchronous Serial Communications 253
Figure 13: How to enable float support in printf() and scanf()
9. DMA Management
Every embedded application needs to exchange data with the outside world or to drive external
peripherals. For example, our microcontroller may exchange messages with other modules on the
PCBusinganUART,oritmaystoredatainanexternalflashusingoneoftheavailableSPIinterfaces.
ThisinvolvesthetransferofagivenamountofdatabetweentheinternalSRAMorflashmemoryand
the peripheral registers, and it requires a certain number of CPU cycles to accomplish the transfer.
This leads to a loss of computing power (the CPU is occupied in the transfer process), to a reduction
of the overall performances and eventually to a loss of important asynchronous events.
The Direct Memory Access (DMA) controller is a dedicated and programmable hardware unit that
allows MCU peripherals to access to internal memories without the intervention of the Cortex-M
core. The CPU is completely freed from the overhead generated by the data transfer (except for
the overhead related to the DMA configuration), and it can perform other activities in parallel¹. The
DMAisdesignedtoworkinboththeways(thatis,itallowsdatatransferfrommemorytoperipheral
and vice versa), and all STM32 microcontrollers provide at least one DMA controller, but the most
of them implement two independent DMAs.
The DMA is an “advanced” feature of modern MCUs, and novice users tend to consider it too
complicated to use. Instead, the concepts underlying the DMA are really simple, and once you
understand them it will be really easy to use it. Moreover, the good news is that the CubeHAL
is designed to abstract the most of DMA configuration steps for a given peripheral, leaving to the
user the responsibility to provide just few basic configurations.
This chapter will guide you to the fundamental concepts related to the DMA usage, and it will offer
an overview of the DMA characteristics in all STM32 families. As usual, this chapter does not aim
to be exhaustive and to substitute the official ST documentation², which is a good thing to have as
reference during the reading of this chapter. However, once you master the fundamental concepts
related to the DMA, you will be able to dive inside your MCU datasheets easily.
9.1 Introduction to DMA
Before we can analyze the features offered by the HAL_DMA module, it is important to understand
some fundamental concepts behind the DMA controller. The next paragraphs try to summarize the
most important aspects to keep in mind during the study of this peripheral. Moreover, they try to
address the implementation differences between STM32F2/4/7 and other STM32 families.
¹ This is not exactly true, as we will see next. But it is ok to consider that sentence true here.
² ST provides a dedicated application note about the DMA for every STM32 family. For example, the AN4104 (http://bit.ly/1VMugtO) talks
about the DMA in STM32F0 MCUs. Curiously, the most of them are too much “cryptic” and lack of examples and images to better explain
how the DMA works. Instead, the AN4031 (http://bit.ly/1n66sW7) related to the DMA in STM32F2/F4 MCUs is the most complete, clear and
well organized document about the DMA from ST, even if the DMA in these families differs from the other STM32 families (except the latest
STM32F7whichfacesthesameDMAcontrolleravailableinF2/F4microcontrollers),anditisstronglysuggestedtohavealookatthatdocument
even if you are not working with those STM32 families.
DMA Management 255
9.1.1 The Need of a DMA and the Role of the Internal Buses
Why the DMA is a so important feature? Every peripheral in an STM32 microcontroller needs to
exchange data with the internal Cortex-M core. Some of them translate this data in electrical I/O
signals to exchange it to the outside world according a given communication protocol (this is the
case, for example, of UART or SPI interfaces). Others are just designed so that the access to their
registers inside the peripheral memory mapped region (from 0x4000 0000 to 0x5FFF FFFF ) causes a
changing to their state (for example, the GPIOx->ODR register drives the state of all I/Os connected
to that port). However, keep in mind that from the CPU point of view this also implies a memory
transfer between the core and the peripheral.
TheMCUcore,intheory,couldbedesignedsothateveryperipheralwouldhaveitsownstoragearea,
and it in turn could be tightly coupled with the CPU core to minimize the costs related to memory
transfers³.This,however,complicatestheMCUarchitecture,requiringalotofmoresiliconandmore
“active components” that consume power. So, the approach used in all embedded microcontrollers
is to use some portions of the internal memory (SRAM as well flash) as temporary area storage for
different peripherals. It is up to the user to decide how much room to dedicate to these areas. For
example, let us consider this code fragment:
uint8_t buf[20];
...
HAL_UART_Receive(&huart2, buf, 20, HAL_MAX_DELAY);
Here we are going to read twenty bytes from the UART2 interface, and hence we allocate an array
(the temporary storage) of the same size inside the SRAM. The HAL_UART_Receive() function will
access twenty times to the huart2.Instance->DR data register to transfer bytes from the peripheral
to the internal memory, plus it will poll the UART RXNE flag to detect when the new data is ready
to be transferred. The CPU will be involved during these operations (see Figure 1), even if its role
is “limited” to move data from the peripheral to the SRAM⁴.
³ This is what happens in some vector processors equipping really expensive supercomputers, but this is not the case of 32 cents CPUs like
the STM32.
⁴ Keep in mind that using the UART in interrupt mode does not change the story. Once the UART generates the interrupt to signal the core
that new data is arriving, it is always up to the CPU to “move” this data byte-by-byte from UART data register to the SRAM. That’s the reason
why from the performance point of view there is no difference between UART management in polling and interrupt mode.
DMA Management 256
Figure 1: the flow of data during a transfer from peripheral to SRAM
Whilethisapproachsimplifiesthedesignofthehardwareontheonehand,itintroducesperformance
penalties on the other. The Cortex-M core is “responsible” to load data from peripheral memory to
the SRAM, and this is a blocking operation, which not only prevents the CPU from doing other
activities but it also requires the CPU to wait for “slower” units completing their job (some STM32
peripherals are connected to the core by slower buses, as we will see in Chapter 10). This is the
reason why high performance microcontrollers provide hardware units dedicated to the transfer of
data between peripherals and centralized buffer storage, that is the SRAM.
BeforewegomoreindepthinsidetheDMAdetails,itisbettertotakeanoverviewofallcomponents
involved in the transfer process of data from a peripheral to the SRAM memory and vice versa. We
have already seen in Chapter 6 the bus architecture of the STM32F030 MCU, one of the simplest
STM32 microcontrollers. The bus architecture is shown again inFigure 2⁵ for convenience. It differs
a lot from other more performant STM32 families. We will analyze them later in this chapter, since
it is best to keep it simple in this phase.
The figure says to us some important things:
• Both the Cortex-M core and the DMA1 controller interact with the other MCU peripherals
through a series of buses. If it is still unclear, it is important to remark that also the flash and
SRAM memories are components outside the MCU core, and so they need to interact each
other through a bus interconnection.
• Both the Cortex-M core and the DMA1 controller are masters. This means they are the only
units that can start a transaction on a bus. However, the access to the bus must be regulated so
that they cannot access to the same slave peripheral at the same time.
• The BusMatrix manages the access arbitration between the Cortex-M core the DMA1 con-
troller. The arbitration uses a Round Robin algorithm to rule the access to the bus. The
BusMatrix is composed of two masters (CPU, DMA) and four slaves (flash interface, SRAM,
AHB1 with AHB to Advanced Peripheral Bus (APB) bridge and AHB2). The BusMatrix also
allows to automatically interconnect several peripherals between them.
• The System bus connects the Cortex-M core to the BusMatrix.
⁵ Figure 1 is taken from the ST STM32F030 Reference Manual (http://bit.ly/1GfS3iC).
DMA Management 257
• The DMA bus connects the Advanced High-performance Bus (AHB) master interface of the
DMA to the BusMatrix.
• The AHB to APB bridge provides full synchronous connections between the AHB and the APB
bus, where the most of peripherals are connected.
Figure 2: bus architecture of an STM32F030 microcontroller
The acronyms AHB, AHB1, AHB2, APB and so on are always confusing terms in the STM32 world.
They represent two things at the same time:
• They are hardware components used to connect different units inside the MCU to allow them
exchanging data. They can be clocked by different clock sources, with different speeds. This
means that the access to slower buses can introduce bottlenecks in your application.
• They are part of a more general specification, the ARM Advanced Microcontroller Bus
Architecture (AMBA)thatdefinesthewaydifferentfunctionalblocksinteracteachotherinside
an MCU. The AMBA is an open-standard, and it is implemented in different releases (and
flavors) in all ARM Cortex processors (Cortex-A and Cortex-R included).
We left off one other thing in Figure 2: the DMA requests arrow that goes from the peripherals
block (white rectangle) to the DMA1 controller. What does it accomplish? In Chapter 7 we have
seen that the NVIC controller notifies the Cortex-M core about asynchronous interrupt requests
(IRQs) coming from peripherals. When a peripheral is ready to do something (e.g., the UART is
DMA Management 258
ready to receive data or a timer overflows), it asserts a dedicated IRQ line. The core executes in
a given number of cycles the corresponding ISR, which contains the code necessary to handle the
IRQ. Don’t forget that the peripherals are slave units: they cannot access the bus independently. A
master is always needed to start a transaction. But, since peripherals are slave units, if we use the
DMAtotransferdatafromperipheralstomemorywehaveawaytonotifyitthattheperipheralsare
ready to exchange data. That is the reason why a dedicated number of requests lines are available
from peripherals to the DMA controller. We will see in the next paragraph how they are organized
and how we can program them.
9.1.2 The DMA Controller
In every STM32 MCU, the DMA controller is a hardware unit that:
• has two master ports, named peripheral and memory port respectively, connected to the
Advanced High-performance Bus (AHB), one able to interface a slave peripheral and the other
oneamemorycontroller(SRAM,flash,FSMC,etc.);insomeDMAcontrollersaperipheralport
is also able to interface a memory controller, allowing memory-to-memory transfers;
• has one slave port, connected to the AHB bus, used to program the DMA controller from the
other master, that is the CPU;
• has a number of independent and programmable channels (request sources), each one con-
nectable to a given peripheral request line ( UART_TX , TIM_UP etc. - the number and type of
requests for a channel is established during the MCU design);
• allows to assign different priorities to channels, in order to arbitrate the access to the memory
giving higher priority to faster and important peripherals;
• allows the data to flow in both directions, that is from memory-to-peripheral and from
peripheral-to-memory.
EachSTM32MCUprovidesavariablenumberofDMAsandChannelsaccordingitsfamilyandsales
type. The Table 1 reports their exact number for the STM32 MCUs equipping all Nucleo boards.
These characteristics are broadly common to all STM32 microcontrollers. However, STM32F2/F4/F7
families provide a more advanced DMA controller in conjunction with a multilayer BusMatrix that
allows boosting and parallelizing DMA transfers. This is the reason why we are going to treat them
separately⁶.
⁶ However, keep in mind that this book does not aim to be an exhaustive source of hardware details of each STM32 family. Always keep
in your hands the reference manual for the MCU you are considering, and look carefully to the chapter related to the DMA.
DMA Management 259
Table 1: The number of DMAs/Channels available in every Nucleo board
9.1.2.1 The DMA Implementation in F0/F1/F3/L1 MCUs
The Figure 3 shows a representation of the DMA in F0/F1/F3/L1 MCUs. Here, for simplicity, only
one request line is shown, but each DMA implements a request line for each channel. Each request
line has a variable number of peripheral request sources connected to it. A channel is bound during
the chip design to a fixed set of peripherals. However, only one peripheral at once can be active
in the same channel. For example, Table 2⁷ shows how channels are bound to peripherals in an
STM32F030 MCU. Every request line can be also triggered by “software”. This ability is used to
perform memory-to-memory transfers.
Each channel has a configurable priority that allows to rule the access to the AHB bus. An internal
arbiter rules the requests coming from the channels according a user configurable priority. If two
requestlinesactivatearequestandtheirchannelshavethesamepriority,thechannelwiththelower
number wins the contention.
⁷ The table is extracted from the ST RM0360 reference manual (http://bit.ly/1GfS3iC)
DMA Management 260
Figure 3: A representation of the DMA structure (other request lines omitted)
Depending on the sales type used one ore two DMA controllers are available, for a total of 12
independent channels (5 for DMA1 and 7 for DMA2). For example, as shown in Table 2, the
STM32F030 provides only DMA1, with 5 channels.
DMA Management 261
Table 2: How channels are bound to peripheral in an STM32F030 MCU
WehavealreadyseeninFigure2thebusarchitectureofanSTM32F030.Forthesakeofcompleteness,
Figure4⁸showsthebusarchitectureofmoreperformantMCUswiththesameDMAimplementation
(e.g.,theSTM32F1).Asyoucansee,thetwofamilieshaveaquitedifferentinternalbusorganization.
You can see two additional buses named ICode and DCode. Why this difference?
The most of STM32 MCUs share the same computer architecture except for STM32F0 and STM32L0
that are based on the Cortex-M0/0+ cores. They, in fact, are the only Cortex-M cores based on the
von Neumann architecture, compared to the other Cortex-M cores that are based on the Harvard
architecture⁹.ThefundamentaldistinctionbetweenthetwoarchitecturesisthatCortex-M0/0+cores
access to flash memory, SRAM and peripherals using one common bus, while the other Cortex-M
cores have two separated bus lines for the access to the flash (one for the fetch of instructions called
instruction bus, or simply I-Bus or even I-Code, and one for the access to const data called data bus,
or simply D-Bus or even D-Code) and one dedicated line for the access to SRAM and peripherals
(also called system bus, or simply S-Bus). What advantages gives this to our applications?
⁸ The figure is taken from the RM0008 reference manual from ST (http://bit.ly/1TNekGo)
⁹ For the sake of completeness, we have to say that they are based on a modified Harvard architecture
(https://en.wikipedia.org/wiki/Modified_Harvard_architecture), but let us leave the distinction to historians of computer science.
DMA Management 262
Figure 4: The bus architecture in an STM32F1 MCU from the Connectivity Line
InCortex-M0/0+corestheDMAandtheCortexcorecontendtheaccesstomemoriesandperipherals
using the BusMatrix. Suppose that the CPU is performing math operations on data contained in its
internalregisters(R0-R14).IftheDMAistransferringdatatotheSRAM,theBusMatrixarbitratesthe
access from the Cortex core to the flash memory to load the next instruction to execute. So the core
is stalled waiting for its turn (more about this in a while). In the other Cortex-M cores, the CPU can
access to the flash memory independently, boosting the overall performances. This is a fundamental
difference that justifies the price of STM32F0 MCUs: they not only can have less SRAM and flash
and run at lower frequencies, but they face a simpler and intrinsically less performant architecture.
However,itisimportanttoremarkthattheBusMatriximplementsschedulingpoliciestoavoidthata
givenmaster(CPUandDMAinValueLinesMCUs,orCPU,DMA,EthernetandUSBinConnectivity
Lines MCUs) stalls for too much time. Each DMA transfer is made up of four phases: a sample and
arbitration phase, an address computation phase, bus access phase and a final acknowledgement
phase (which is used to signal that the transfer has been completed). Each phase takes a single cycle,
withtheexceptionofthebusaccessphase,whichcanlastforahighernumberofcycles.However,its
maximum duration is fixed, and the BusMatrix guarantees that at the end of the acknowledgement
phaseanothermasterwillbescheduledfortheaccesstothebus.Aswewillseeinthenextparagraph,
DMA Management 263
theSTM32F2/F4/F7familiesallowamoreadvancedparallelismwhileaccessingtoslavedevices.The
details of these aspects, however, are outside of the scope of this book. It is strongly suggested to
have a look at the AN4031 (http://bit.ly/1n66sW7¹⁰) from ST to better understand them.
Finally, the DMA can also perform peripheral-to-peripheral transfers under particular conditions,
as we will see next.
9.1.2.2 The DMA Implementation in F2/F4/F7 MCUs
STMF2/F4/F7 MCUs implement a more advanced DMA controller, as shown in Figure 5. It offers
a higher degree of flexibility compared to the DMA found in other STM32 MCUs. Every DMA
implements 8 differentstreams. Each stream is dedicated to managing memory access requests from
one or more peripherals. Each stream can have up to 8 channels (requests) in total (but keep in mind
that only one channel/request can be active at the same time in a stream), and it has an arbiter for
handling the priority between DMA requests. Moreover, every stream can optionally provide (is a
configuration option) a four-word depth 32-bit first-in/first-out (FIFO) memory buffer. The FIFO
is used to temporarily store data coming from the source before transmitting it to the destination.
Every stream can be also triggered by “software”. This ability is used to performmemory-to-memory
transfers, but it is limited only to DMA2 as highlighted in Table 1.
Every STM32F2/F4/F7 MCU provides two DMA controllers, for a total of 16 independent streams.
Like in the other STM32 microcontrollers, a channel is bound to a fixed set of peripherals during the
chip design. Table 3 shows the DMA1 stream/channel request mapping in an STM32F401RE MCU.
STM32F2/F4/F7 MCUs embed a multi-masters/multi-slaves architecture made of: * Eight masters: *
CortexcoreI-bus*CortexcoreD-bus*CortexcoreS-bus*DMA1memorybus*DMA2memorybus
* DMA2 peripheral bus * Ethernet DMA bus (if available) * USB high-speed DMA bus (if available)
¹⁰ http://bit.ly/1n66sW7
DMA Management 264
Figure 5: The DMA architecture in an STM32F2/F4/F7 MCU
Table 3: The DMA1 stream/channel request mapping in an STM32F401RE MCU
DMA Management 265
• Eight slaves:
– Internal flash memory I-Code bus
– Internal flash memory D-Code bus
– Main internal SRAM1
– Auxiliary internal SRAM2 (if available)
– Auxiliary internal SRAM3 (if available)
– AHB1 peripherals including AHB-to-APB bridges and APB peripherals
– AHB2 peripherals
– AHB3 peripheral (FMC) (if available)
Masters and slaves are connected via a multi-layer BusMatrix ensuring concurrent access from
separated masters and efficient operations, even when several high-speed peripherals work simulta-
neously. This architecture is shown inFigure 6¹¹ for the case of STM32F405/415 and STM32F407/417
lines.
The multi-layer Bus Matrix allows different masters to perform data transfers concurrently as long
as they are addressing different slave modules (but for a given DMA, only “one stream” at time can
access to the bus). On top of the Cortex-M Harvard architecture and dual AHB port DMAs, this
structure enhances data transfer parallelism, thus contributing to reduce the execution time, and
optimizing the DMA efficiency and power consumption.
Figure 6: The multi-layer BusMatrix in an STM32F405 MCU
¹¹ The figure is taken from the AN4031 application note from ST (http://bit.ly/1n66sW7)
DMA Management 266
9.1.2.3 The DMA Implementation in L0/L4 MCUs
The DMA implementation in STM32L0/L4 MCUs has a hybrid approach between the DMA im-
plementation found in F0/F1/F3/L1 and F2/F4/F7 MCUs. In fact, it provides a multi-stream/channel
approach but without the support to internal FIFOs for each stream.
ST has adopted a different nomenclature to indicate streams and channels in these DMA controllers.
Here streams are called channels and channels are called requests (probably this nomenclature is
clearer than the stream/channel one used in F2/F4/F7 MCUs). The Table 4¹² shows the channels/re-
quests map in an STM32L053 MCU. This nomenclature impacts also on the HAL, as we will see
next.
Table 4: The DMA channels/requests map in an STM32L053 MCU
¹² The table is taken from the RM0367 reference manual by ST (http://bit.ly/1Q3yKtW)
DMA Management 267
9.2 HAL_DMA Module
After a lot of talking, it is now the time to start writing code.
Strictly speaking, programming the DMA is fairly simple, especially if it is clear how the DMA
works from a theoretical point of view. Moreover, the CubeHAL is designed to abstract the most of
underlying hardware details.
All the HAL functions related to DMA manipulation are designed so that they accept as first
parameter an instance of the C struct DMA_HandleTypeDef . This structure is slightly different from
CubeF2/F4/F7 HALs and the other CubeHALs, due to the different DMA implementation as shown
in the previous paragraphs. For this reason, we will show them separately.
9.2.1 DMA_HandleTypeDef in F0/F1/F3/L0/L1/L4 HALs
The struct DMA_HandleTypeDef is defined in the following way in CubeF0/F1/F3/L1 HALs:
typedef struct {
DMA_Channel_TypeDef *Instance; /* Register base address */
DMA_InitTypeDef Init; /* DMA communication parameters */
HAL_LockTypeDef Lock; /* DMA locking object */
__IO HAL_DMA_StateTypeDef State; /* DMA transfer state */
void *Parent; /* Parent object state */
void (* XferCpltCallback)( struct __DMA_HandleTypeDef * hdma);
void (* XferHalfCpltCallback)( struct __DMA_HandleTypeDef * hdma);
void (* XferErrorCallback)( struct __DMA_HandleTypeDef * hdma);
__IO uint32_t ErrorCode; /* DMA Error code */
} DMA_HandleTypeDef;
Let us see more in depth the most important fields of this struct.
• Instance : is the pointer to the DMA/Channel pair descriptor we are going to use. For example,
DMA1_Channel5 indicates the fifth channel of DMA1. Remember that channels are bound to
peripherals during the MCU design, so consult the datasheet for your MCU to see the channel
bound to the peripheral you want to use in DMA mode.
• Init : is an instance of the C struct DMA_InitTypeDef , which is used to configure the
DMA/Channel pair. We will study it more in depth in a while.
• Parent : this pointer is used by the HAL to keep track of the peripheral handlers associated to
the current DMA/Channel. For example, if we are using an UART in DMA mode, this field
will point to an instance of UART_HandleTypeDef . We will see soon how peripheral handlers
are “linked” to this field.
• XferCpltCallback , XferHalfCpltCallback , XferErrorCallback :thesearepointerstofunctions
used as callbacks to signal the user code that a DMA transfer is completed, half-completed or
an error occurred. They are automatically called by the HAL when a DMA interrupt is faired,
by the function HAL_DMA_IRQHandler() , as we will see next.
DMA Management 268
All the DMA/Channel configuration activities are performed by using an instance of the C struct
DMA_InitTypeDef , which is defined in the following way:
typedef struct {
uint32_t Direction;
uint32_t PeriphInc;
uint32_t MemInc;
uint32_t PeriphDataAlignment;
uint32_t MemDataAlignment;
uint32_t Mode;
uint32_t Priority;
} DMA_InitTypeDef;
• Direction : it defines the DMA transfer direction and it can assume one of the values reported
in Table 5.
• PeriphInc : as said in previous paragraphs, a DMA controller has one peripheral port used to
specify the address of the peripheral register involved in the memory transfer (for example,
for a UART interface the address of its Data Register (DR)). Since a DMA memory transfer
usually involves several bytes, the DMA can be programmed to automatically increment the
peripheral register for every byte transmitted. This is true both when a memory-to-memory
transfer is performed and when the peripheral is byte, half-word and word addressable (like
anexternalSRAMmemory).Inthiscasethefieldassumethevalue DMA_PINC_ENABLE ,otherwise
DMA_PINC_DISABLE .
• MemInc : this field has the same meaning of the PeriphInc field, but it involves thememory port.
It can assume the value DMA_MINC_ENABLE to signal that the specified memory address has to be
incremented after each byte transmitted, or the value DMA_MINC_DISABLE to leave it unchanged
after each transfer.
• PeriphDataAlignment :transferdatasizesoftheperipheralandmemoryarefullyprogrammable
through this field and the next one. It can assume a value from Table 6. The DMA controller
is designed to automatically perform data alignment (packing/unpacking) when source and
destination data sizes differ. This topic is outside the scope of this book. Please, refer to the
Reference Manual of your MCU.
• MemDataAlignment : it specifies memory transfer data size and it can assume a value fromTable
7.
• Mode : the DMA controller in STM32 MCUs has two working modes: DMA_NORMAL and DMA_CIR-
CULAR . In normal mode the DMA sends the specified amount of data from source to destination
port and stops the activities. It must be re-armed again to do another transfer. Incircular mode,
at the end of transmission, it automatically resets the transfer counter and starts transmitting
againfromthefirstbyteofsourcebuffer(thatis,ittreatsthesourcebufferasaringbuffer).This
mode is also called continuous mode, and it is the only way to achieve really high transmission
speed in some peripheral (e.g. high speed SPI devices).
• Priority : one important feature of the DMA controller is the ability to assign priorities to each
channel, in order to rule concurrent requests. This field can assume a value from Table 8. In
DMA Management 269
case of concurrent requests from peripherals connected to channels with the same priority, the
channel with lower number fires first.
Table 5: Available DMA transfer directions
DMA transfer direction Description
DMA_PERIPH_TO_MEMORY Peripheral to memory direction
DMA_MEMORY_TO_PERIPH Memory to peripheral direction
DMA_MEMORY_TO_MEMORY Memory to memory direction
Table 6: DMA Peripheral data size
Peripheral data size Description
DMA_PDATAALIGN_BYTE Peripheral data alignment : Byte
DMA_PDATAALIGN_HALFWORD Peripheral data alignment : HalfWord
DMA_PDATAALIGN_WORD Peripheral data alignment : Word
Table 7: DMA Memory data size
Peripheral data size Description
DMA_MDATAALIGN_BYTE Memory data alignment : Byte
DMA_MDATAALIGN_HALFWORD Memory data alignment : HalfWord
DMA_MDATAALIGN_WORD Memory data alignment : Word
Table 8: Available DMA channel priorities
DMA channel priority Description
DMA_PRIORITY_LOW Priority level : Low
DMA_PRIORITY_MEDIUM Priority level : Medium
DMA_PRIORITY_HIGH Priority level : High
DMA_PRIORITY_VERY_HIGH Priority level : Very_High
9.2.2 DMA_HandleTypeDef in F2/F4/F7 HALs
The struct DMA_HandleTypeDef is defined in the following way in CubeF2/F4/F7 HALs:
DMA Management 270
typedef struct {
DMA_Stream_TypeDef *Instance; /* Register base address */
DMA_InitTypeDef Init; /* DMA communication parameters */
HAL_LockTypeDef Lock; /* DMA locking object */
__IO HAL_DMA_StateTypeDef State; /* DMA transfer state */
void *Parent; /* Parent object state */
void (* XferCpltCallback)( struct __DMA_HandleTypeDef * hdma);
void (* XferHalfCpltCallback)( struct __DMA_HandleTypeDef * hdma);
void (* XferM1CpltCallback)( struct __DMA_HandleTypeDef * hdma);
void (* XferErrorCallback)( struct __DMA_HandleTypeDef * hdma);
__IO uint32_t ErrorCode; /* DMA Error code */
uint32_t StreamBaseAddress; /* DMA Stream Base Address */
uint32_t StreamIndex; /*!< DMA Stream Index */
} DMA_HandleTypeDef;
Let us see more in depth the most important fields of this struct.
• Instance : is the pointer to the stream descriptor we are going to use. For example, DMA1_-
Stream6 indicates the seventh¹³ stream of DMA1. Remember that a stream must be bound to a
channel before it can be used. This is achieved through the Init field, as we will see in a while.
Remember also that channels are bound to peripherals during the MCU design, so consult the
datasheet for your MCU to see the channel bound to the peripheral you want to use in DMA
mode.
• Init : is an instance of the C struct DMA_InitTypeDef , which is used to configure the
DMA/Channel/Stream triple. We will study it more in depth in a while.
• Parent : this pointer is used by the HAL to keep track of the peripheral handlers associated to
the current DMA/Channel. For example, if we are using an UART in DMA mode, this field
will point to an instance of UART_HandleTypeDef . We will see soon how peripheral handlers
are “linked” to this field.
• XferCpltCallback , XferHalfCpltCallback , XferM1CpltCallback , XferErrorCallback : these
are pointers to functions used as callbacks to signal the user code that a DMA transfer
is completed, half-completed, the transmission of first buffer in a multi-buffer transfer is
completed or an error occurred. They are automatically called by the HAL when a DMA
interrupt is faired, by the function HAL_DMA_IRQHandler() , as we will see next.
All the DMA/Channel configuration activities are performed by using an instance of the C struct
DMA_InitTypeDef , which is defined in the following way:
¹³ Stream count starts from zero.
DMA Management 271
typedef struct {
uint32_t Channel;
uint32_t Direction;
uint32_t PeriphInc;
uint32_t MemInc;
uint32_t PeriphDataAlignment;
uint32_t MemDataAlignment;
uint32_t Mode;
uint32_t Priority;
uint32_t FIFOMode;
uint32_t FIFOThreshold;
uint32_t MemBurst;
uint32_t PeriphBurst;
} DMA_InitTypeDef;
• Channel : it specifies the DMA channel used for the given stream. It can assume the values
DMA_CHANNEL_0 , DMA_CHANNEL_1 up to DMA_CHANNEL_7 . Remember that peripherals are bound to
streams and channels during the MCU design, so consult the datasheet for your MCU to see
the stream bound to the peripheral you want to use in DMA mode.
• Direction : it defines the DMA transfer direction and it can assume one of the values reported
in Table 5.
• PeriphInc : as said in previous paragraphs, a DMA controller has one peripheral port used to
specify the address of the peripheral register involved in the memory transfer (for example,
for a UART interface the address of its Data Register (DR)). Since a DMA memory transfer
usually involves several bytes, the DMA can be programmed to automatically increment the
peripheral register for every byte transmitted. This is true both when a memory-to-memory
transfer is performed and when the peripheral is byte, half-word and word addressable (like an
externalSRAMmemoryis).Inthiscasethefieldassumesthevalue DMA_PINC_ENABLE ,otherwise
DMA_PINC_DISABLE .
• MemInc : this field has the same meaning of the PeriphInc field, but it involves thememory port.
It can assume the value DMA_MINC_ENABLE to signal that the specified memory address has to be
incremented after each byte transmitted, or the value DMA_MINC_DISABLE to leave it unchanged
after each transfer.
• PeriphDataAlignment :transferdatasizesoftheperipheralandmemoryarefullyprogrammable
through this field and the next one. It can assume a value from Table 6. The DMA controller
is designed to automatically perform data alignment (packing/unpacking) when source and
destination data sizes differ. This topic is outside the scope of this book. Please, refer to the
Reference Manual of your MCU.
• MemDataAlignment : it specifies memory transfer data size and it can assume a value fromTable
7.
• Mode : the DMA controller in STM32 MCUs has two working modes: DMA_NORMAL and DMA_CIR-
CULAR . In normal mode the DMA sends the specified amount of data from source to destination
port and stops the activities. It must be re-armed again to do another transfer. Incircular mode,
DMA Management 272
at the end of transmission, it automatically resets the transfer counter and starts transmitting
again from the first byte of the source buffer (that is, it treats the source buffer as a ring
buffer). This mode is also called continuous mode, and it is the only way to achieve really
high transmission speeds in some peripheral (e.g. really fast SPI devices).
• Priority : one important feature of the DMA controller is the ability to assign priorities to
each stream, in order to rule concurrent requests. This field can assume a value from Table 8.
In case of concurrent requests from peripherals connected to streams with the same priority,
the stream with lower number fires first.
• FIFOMode : it is used to enable/disable the DMA FIFO mode using DMA_FIFOMODE_ENABLE / DMA_-
FIFOMODE_DISABLE macros. In STM32F2/F4/F7 MCUs, each stream has an independent 4-word
(4 * 32 bits) FIFO. The FIFO is used to temporarily store data coming from the source before
transmitting it to the destination. When disabled, the Direct mode is used (this is the “normal”
mode available in other STM32 MCUs).
The FIFO mode introduces several advantages: it reduces SRAM access and so give more
time for the other masters to access the Bus Matrix without additional concurrency; it allows
software to do burst transactions which optimize the transfer bandwidth (more about this in a
while); it allows packing/unpacking data to adapt source and destination data width with no
extra DMA access.
If DMA FIFO is enabled, data packing/unpacking and/or Burst mode can be used. The FIFO is
automatically emptied according a threshold level. This level is software-configurable between
1/4, 1/2, 3/4 or full size.
• FIFOThreshold : it specifies the FIFO threshold level and it can assume a value from Table 9.
• MemBurst : a round robin scheduling policy rules the access of a DMA stream before it can
transfer a sequence of bytes through the AHB bus. This “slows” down the transfer operations,
and for some high-speed peripherals it can be a bottleneck. A burst transfer allows a DMA
stream to transmit data repeatedly without going through all the steps required to transmit
each piece of data in a separate transaction. The burst mode works in conjunction with FIFOs
and it says nothing about the amount of bytes transferred. This is based on the settings
of MemDataAlignment field (when we are doing a memory-to-peripheral transfer). MemBurst
indicates the number of “shoots” performed by the stream, and it is made of bytes, half-word
and word depending the source configuration. The MemBurst field can assume one value from
Table 10.
• PeriphBurst :Thisfieldhasthesamemeaningofthepreviousone,butitisrelatedtoperipheral-
to-memory transfers. It cam assume a value from Table 11.
Table 9: Available FIFO threshold levels
DMA channel priority Description
DMA_FIFO_THRESHOLD_1QUARTERFULL FIFO threshold 1 quart full configuration
DMA_FIFO_THRESHOLD_HALFFULL FIFO threshold half full configuration
DMA_FIFO_THRESHOLD_3QUARTERSFULL FIFO threshold 3 quarts full configuration
DMA_FIFO_THRESHOLD_FULL FIFO threshold full configuration
DMA Management 273
Table 10: Available DMA memory burst modes
DMA channel priority Description
DMA_MBURST_SINGLE Single burst
DMA_MBURST_INC4 Burst of 4 beats
DMA_MBURST_INC8 Burst of 8 beats
DMA_MBURST_INC16 Burst of 16 beats
Table 11: Available DMA peripheral burst modes
DMA channel priority Description
DMA_PBURST_SINGLE Single burst
DMA_PBURST_INC4 Burst of 4 beats
DMA_PBURST_INC8 Burst of 8 beats
DMA_PBURST_INC16 Burst of 16 beats
9.2.3 DMA_HandleTypeDef in L0/L4 HALs
Since STM32L0/L4 MCUs adopt a different nomenclature to indicate the stream/channel pair (they
adopt the channel/request one), the DMA_HandleTypeDef reflects this difference in their HALs.
However, we will avoid repeating the complete story here. The only two things to keep in mind
are:
• the DMA_HandleTypeDef.Instance is the channel number, and it can assume the values DMA1_-
Channel1..DMA1_Channel7 ;
• the DMA_HandleTypeDef.Init.Request is the request line, and it can assume the values DMA_-
REQUEST_0..DMA_REQUEST_11 ;
• this DMA implementation does not support FIFO and burst mode.
9.2.4 How to Perform Transfers in Polling Mode
Once we have configured the DMA channel/stream we need, we have to do few other things:
• to setup the addresses on the memory and peripheral port;
• to specify the amount of data we are going to transfer;
• to arm the DMA;
• to enable the DMA mode on the corresponding peripheral.
The HAL abstracts the first three points by using the
DMA Management 274
HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddr\
ess, uint32_t DataLength);
while the fourth point is peripheral dependent, and we have to consult our specific MCU datasheet.
However, as we will see later, the HAL also abstracts this point (for example, if we use the
corresponding HAL_UART_Transmit_DMA() function when configuring an UART in DMA mode).
Now we should have all the elements to see a fully working application. What we are going to do in
the next example is just sending a string over the UART2 peripheral using DMA mode. The involved
steps are:
• The UART2 is configured using the HAL_UART module, as we have seen in the previous chapter.
• The DMA1 channel (or the DMA1 channel/stream couple for STM32F4 based Nucleo boards)
is configured to do a memory-to-peripheral transfer (see Table 12)
• The corresponding channel is armed to execute the transfer and UART is enabled in DMA
mode.
Table 12: How USART_TX/USART_RX DMA channels are mapped in the MCUs equipping Nucleo boards
The following example, which is designed to work on a Nucleo-F030 (refer to book samples for the
other Nucleo boards), shows how to do this easily.
DMA Management 275
Filename: src/main-ex1.c
43 MX_DMA_Init();
44 MX_USART2_UART_Init();
45
46 hdma_usart2_tx.Instance = DMA1_Channel4;
47 hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
48 hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
49 hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
50 hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
51 hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
52 hdma_usart2_tx.Init.Mode = DMA_NORMAL;
53 hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
54 HAL_DMA_Init(&hdma_usart2_tx);
55
56 HAL_DMA_Start(&hdma_usart2_tx, (uint32_t)msg, (uint32_t)&huart2.Instance->TDR, strlen(msg)\
57 );
58 //Enable UART in DMA mode
59 huart2.Instance->CR3 |= USART_CR3_DMAT;
60 //Wait for transfer complete
61 HAL_DMA_PollForTransfer(&hdma_usart2_tx, HAL_DMA_FULL_TRANSFER, HAL_MAX_DELAY);
62 //Disable UART DMA mode
63 huart2.Instance->CR3 &= ~USART_CR3_DMAT;
64 //Turn LD2 ON
65 HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);
The hdma_usart2_tx variable is an instance of the DMA_HandleTypeDef struct seen before. Here we
configureDMA1_Channel4todoamemory-to-peripheral transfer.SincetheUSARTperipheralhasa
TransmitDataRegister (TDR)onebytewide,weconfiguretheDMAsothattheperipheraladdressis
not automatically incremented ( DMA_PINC_DISABLE ), while we want that the source memory address
is automatically incremented at every byte sent ( DMA_MINC_ENABLE ). Once the configuration is
completed, we call the HAL_DMA_Init() which performs the DMA interface configuration according
the information provided inside the hdma_usart2_tx.Init structure. Next, at line 56, we invoke the
HAL_DMA_Start() routine, which configures the source memory address (that is the address of the
msg array), the destination peripheral address (that is the address of USART2->TDR register) and the
amountofdatawearegoingtotransmit.TheDMAisnowreadytoshoot,andwestartthetransmis-
sion setting the corresponding bit of USART2 peripheral, as shown in line 62. Finally, take note that
the function MX_DMA_Init() (invoked at line 43) uses the macro __HAL_RCC_DMA1_CLK_ENABLE() to
enable the DMA1 controller (remember that almost every STM32 internal module must be enabled
by using the __HAL_RCC_<PERIPHERAL>_CLK_ENABLE() macro).
Since we do not know how long it takes to complete the transfer procedure, we use the function:
DMA Management 276
HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, uint32_t CompleteLevel, uin\
t32_t Timeout);
which automatically waits for full transfer completion. This way to send data in DMA mode is
called “polling mode” in the official ST documentation. Once the transfer is completed, we disable
the UART2 DMA mode and turn on the LD2 LED.
9.2.5 How to Perform Transfers in Interrupt Mode
From the performance point of view, the DMA transfer in polling mode is meaningless, unless our
codedoesnotneedtowaitfortransfercompletion.Ifourgoalistoimprovetheoverallperformances,
there are no reasons to use the DMA controller and then to consume a lot of CPU cycles waiting
for transfer completion. So the best option is to arm the DMA and let it notify us when the transfer
is completed. The DMA is able to generate interrupts related to channel activities (for example, the
DMA1 in an STM32F030 MCU has one IRQ for channel 1, one for channels 2 and 3, one for channels
4 and 5). Moreover, three independent enable bits are available to enable IRQ on half transfer, full
transfer and transfer error.
The DMA can be enabled in interrupt mode following these steps:
• definethreefunctionsactingascallbackroutinesandpassthemtofunctionpointers XferCplt-
Callback , XferHalfCpltCallback and XferErrorCallback in a DMA_HandleTypeDef handler (it
is ok to define only the functions we are interested in, but set the corresponding pointer
to NULL, otherwise strange faults may occur);
• write down the ISR for the IRQ associated to the channel you are using and do a call to the
HAL_DMA_IRQHandler() passing the reference to the DMA_HandleTypeDef handler;
• enable the corresponding IRQ in the NVIC controller;
• use the function HAL_DMA_Start_IT() , which automatically performs all the necessary setup
steps for you, passing to it the same arguments of the HAL_DMA_Start() .
Purists of performances will be disappointed by the way the HAL manages DMA interrupts.
In fact, it enables by default all the available IRQs for a given channel, even if we are
not interested to some of them (for example, we might not interested in capturing the
half transfer interrupt). If performances are fundamental for you, then take a look at the
HAL_DMA_Start_IT() code and rearrange it at your needs. Unfortunately, ST has decided to
design the HAL in a way that it abstracts a lot of detail to the user, at the expense of speed.
DMA Management 277
It is important to remark a thing about the XferCpltCallback , XferHalfCpltCallback and
XferErrorCallback callbacks: we need to set them when we are using DMA without the
mediation of the CubeHAL. Let us clarify this concept.
Suppose that we are using the UART2 in DMA mode. If we are doing the DMA management
ourselves, then it is ok to define those callback routines and to manage the necessary
UART interrupt related configurations each time a transfer takes place. However, if we
are using the HAL_UART_Trasmit_DMA() / HAL_UART_Receive_DMA() routines, then the HAL
already correctly defines those callbacks and we do not have to change them. Instead, for
example,tocapturetheDMAcompletioneventfortheUART,weneedtodefinethefunction
HAL_UART_RxCpltCallback() . Always consult the HAL documentation for the peripheral
you are going to use in DMA mode.
The following example shows how to a DMA memory-to-peripheral transfer in interrupt mode.
Filename: src/main-ex2.c
47 hdma_usart2_tx.Instance = DMA1_Channel4;
48 hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
49 hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
50 hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
51 hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
52 hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
53 hdma_usart2_tx.Init.Mode = DMA_NORMAL;
54 hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
55 hdma_usart2_tx.XferCpltCallback = &DMATransferComplete;
56 HAL_DMA_Init(&hdma_usart2_tx);
57
58 /* DMA interrupt init */
59 HAL_NVIC_SetPriority(DMA1_Channel4_5_IRQn, 0, 0);
60 HAL_NVIC_EnableIRQ(DMA1_Channel4_5_IRQn);
61
62 HAL_DMA_Start_IT(&hdma_usart2_tx, (uint32_t)msg, \
63 (uint32_t)&huart2.Instance->TDR, strlen(msg));
64 //Enable UART in DMA mode
65 huart2.Instance->CR3 |= USART_CR3_DMAT;
66
67 /* Infinite loop */
68 while (1);
69 }
70
71 void DMATransferComplete(DMA_HandleTypeDef *hdma) {
72 if(hdma->Instance == DMA1_Channel4) {
73 //Disable UART DMA mode
74 huart2.Instance->CR3 &= ~USART_CR3_DMAT;
75 //Turn LD2 ON
76 HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);
77 }
DMA Management 278
9.2.6 How to Perform Peripheral-To-Peripheral Transfers
The official documentation from ST speaks broadly about peripheral-to-peripheral transfers using
DMA in F0/F1/F3/L0/L1/L4 MCUs. But looking at reference manuals, and demonstration projects
provided in CubeHAL, it is impossible to find any reasonably example on how to use this feature.
Even on the web (and on the official ST forum) there are no hints about how to use it. In a first
instance, I thought that this was an obviously consequence of the fact that peripherals are memory
mapped in the 4GB address space. Hence, a peripheral-to-peripheral transfer would be simply a
special case of peripheral-to-memory transfer. Instead, doing some tests, I have reached to the
conclusion that this feature requires that the DMA is expressly designed to allow trigger transfers
between different peripherals. Doing some experiments, I have found that in F2/F4/F7/L1/L4 MCUs
only the DMA2 controller has a complete access to the Bus Matrix and it is the only one (together
with the Cortex core) that can perform peripheral-to-peripheral transfers.
This feature can be useful when we want to exchange data between two peripherals without the
intervention of Cortex core. The following example shows how to toggle the Nucleo LD2 LED
sending a sequence of messages from the UART2 peripheral¹⁴.
Filename: src/main-ex3.c
45 hdma_usart2_rx.Instance = DMA1_Channel5;
46 hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
47 hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
48 hdma_usart2_rx.Init.MemInc = DMA_MINC_DISABLE;
49 hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
50 hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
51 hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;
52 hdma_usart2_rx.Init.Priority = DMA_PRIORITY_LOW;
53 HAL_DMA_Init(&hdma_usart2_rx);
54
55 __HAL_RCC_DMA1_CLK_ENABLE();
56
57 HAL_DMA_Start(&hdma_usart2_rx, (uint32_t)&huart2.Instance->RDR, (uint32_t)&GPIOA->ODR, 1);
58 //Enable UART in DMA mode
59 huart2.Instance->CR3 |= USART_CR3_DMAR;
This time we configure the channel to do a transfer from peripheral-to-memory, without incre-
menting neither the source peripheral register (UART data register) nor the target memory location,
which in our case is the address of the GPIOA->ODR register. Finally, the channel is configured to
work in circular mode: this will cause that all bytes transmitted over the UART will be stored inside
the GPIOA->ODR register continuously.
To test the example, we can simply use the following Python script:
¹⁴ The example is designed to run on a Nucleo-F030. For Nucleo boards based on F2/F4/L1/L4 MCUs, the example is designed to work with
the UART1, whose DMA requests are bound to the DMA2.
DMA Management 279
Filename: src/uartsend.py
1 #!/usr/bin/env python
2 import serial, time
3
4 SERIAL_PORT = "/dev/tty.usbmodem1a1213" #Windows users, replace with "COMx"
5 ser = serial.Serial(SERIAL_PORT, 38400)
6
7 while True:
8 ser.write((0xff,))
9 time.sleep(0.05)
10 ser.write((0,))
11 time.sleep(0.05)
12
13 ser.close()
The code is really self-explaining. We use the pyserial module to open a new serial connection
on the Nucleo VCP. Then we start an infinite-loop that sends the 0xFF and 0x0 bytes alternatively.
This will cause that the GPIOA->ODR assumes the same value (that is, the first eight I/Os goes HIGH
and LOW alternatively) and the Nucleo LD2 LED blinks. As you can see, the Cortex-M core knows
nothing about what’s happening between the UART2 and the GPIOA peripheral.
9.2.7 Using the HAL_UART Module With DMA Mode Transfers
In Chapter 8 we left out how to use the UART in DMA mode. We have already seen in the previous
paragraphs how to do it. However, we had to play with some USART registers to enable the
peripheral in DMA mode.
The HAL_UART module is designed to abstract from all underlying hardware details. The steps
required to use it are the following:
• configure the DMA channel/stream hardwired to the UART you are going to use, as seen in
this chapter;
• link the UART_HandleTypeDef to the DMA_HandleTypeDef using the __HAL_LINKDMA() ;
• enable the DMA interrupt related to the channel/stream you are using and call the HAL_DMA_-
IRQHandler() routine from its ISR;
• enable the UART related interrupt and call the HAL_UART_IRQHandler() routine from its ISR
(this is really important, do not skip this step¹⁵);
• Use the HAL_UART_Transmit_DMA() and HAL_UART_Receive_DMA() function to exchange data
over the UART and be prepared to be notified of transfer completion implementing the HAL_-
UART_RxCpltCallback() .
¹⁵ It is important to enable the UART-related interrupt and to invoke the HAL_UART_IRQHandler() routine, because the HAL is designed so
that UART-related errors (like parity error, overrun error, and so on) may be raised even when the UART is driven in DMA mode. By catching
the error condition, the HAL suspends the DMA transfer and invokes the corresponding error callback to signal the error condition to the
application layer.
DMA Management 280
The following code shows how to receive three bytes from UART2 in DMA mode in an STM32F030
MCU¹⁶:
uint8_t dataArrived = 0;
int main(void) {
HAL_Init();
Nucleo_BSP_Init(); //Configure the UART2
//Configure the DMA1 Channel 5, which is wired to the UART2_RX request line
hdma_usart2_rx.Instance = DMA1_Channel5;
hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;
hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
hdma_usart2_rx.Init.Mode = DMA_NORMAL;
hdma_usart2_rx.Init.Priority = DMA_PRIORITY_LOW;
HAL_DMA_Init(&hdma_usart2_rx);
//Link the DMA descriptor to the UART2 one
__HAL_LINKDMA(&huart, hdmarx, hdma_usart2_rx);
/* DMA interrupt init */
HAL_NVIC_SetPriority(DMA1_Channel4_5_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA1_Channel4_5_IRQn);
/* Peripheral interrupt init */
HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(USART2_IRQn);
//Receive three bytes from UART2 in DMA mode
uint8_t data[3];
HAL_UART_Receive_DMA(&huart2, &data, 3);
while(!dataArrived); //Wait for the arrival of data from UART
/* Infinite loop */
while (1);
}
//This callback is automatically called by the HAL when the DMA transfer is completed
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
dataArrived = 1;
}
¹⁶ Arranging the DMA initialization code for other STM32 MCUs is left as exercise to the reader.
DMA Management 281
void DMA1_Channel4_5_IRQHandler(void) {
HAL_DMA_IRQHandler(&hdma_usart2_rx); //This will automatically call the HAL_UART_RxCpltCallb\
ack()
}
Where the HAL_UART_RxCpltCallback() is exactly called? In the previous paragraphs we have
seen that the DMA_HandleTypeDef contains a pointer (named XferCpltCallback ) to a function that
is invoked by the HAL_DMA_IRQHandler() routine when the DMA transfer has been completed.
However, when we use the HAL module for a given peripheral ( HAL_UART in this case), we do
not need to provide our own callbacks: they are defined internally by the HAL, which uses them
to carry out its activities. The HAL offers us the ability to define our corresponding callback
functions ( HAL_UART_RxCpltCallback() for UART_RX transfers in DMA mode), which will be
invoked automatically by the HAL, as shown in Figure 7. This rule applies to all HAL modules.
Figure 7: The call sequence generated by the HAL_DMA_IRQHandler()
As you can seen, once mastered how the DMA controller works, is really simple to use a peripheral
using this transfer mode.
9.2.8 Miscellaneous Functions From HAL_DMA and HAL_DMA_Ex Modules
The HAL_DMA module provides other functions that help using the DMA controller. Let us see them
briefly.
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma);
This function disables the DMA stream/channel. If a stream is disabled while a data transfer is
ongoing, the current data will be transferred and the stream will be effectively disabled only after
the transfer of this single data is finished.
DMA Management 282
Some STM32 MCUs can perform multi-buffer DMA transfers, which allow to use two separated
buffers during the transfer process: the DMA will automatically “jump” from the first buffer (named
memory0) to the second one (named memory1) when the end of the first one is reached. This
especially useful when DMA works in circular mode. The function:
HAL_StatusTypeDef HAL_DMAEx_MultiBufferStart(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uin\
t32_t DstAddress, uint32_t SecondMemAddress, uint32_t DataLength);
is used to setup multi-buffer DMA transfers. It is available only in F2/F4/F7 HALs. A corresponding
HAL_DMAEx_MultiBufferStart_IT() is also available, which also takes care of enabling DMA
interrupts.
The function:
HAL_StatusTypeDef HAL_DMAEx_ChangeMemory(DMA_HandleTypeDef *hdma, uint32_t Address, HAL_DMA_Me\
moryTypeDef memory);
changes the memory0 or memory1 address on the fly in a multi-buffer DMA transaction.
Differences Between HAL_PPP and HAL_PPP_Ex Modules
We have encountered several HAL modules until here, each one covering one specific peripheral or
core feature. Every HAL module is contained in a file named stm32XXxx_hal_ppp.{c,h}, where the
“XX”representstheSTM32family,and“ppp”theperipheraltype.Forexample,thestm32f4xx_hal_-
dma.c file contains all the generic function definitions for the HAL_DMA module, which is dedicated
to timers.
However, some peripheral functions are specific of a given family, and cannot be abstracted in a
general way common to all STM32 portfolio. In this cases, the HAL provide an extension module
named HAL_PPP_EX and implemented in a file named stm32XXxx_hal_ppp_ex.{c,h}. For example,
the previous HAL_DMAEx_MultiBufferStart() function is defined in the HAL_DMA_Ex module, imple-
mented in stm32f4xx_hal_dma_ex.c file.
The implementation of the APIs in an extension module is specific of the corresponding STM32
series, or even of a given part number in that series, and the usage of those APIs leads to a less
portable code between the several STM32 microcontrollers.
9.3 Using CubeMX to Configure DMA Requests
CubeMXcanreducetotheminimumtheeffortrequiredtosettingupchannel/streamrequests.Once
you have enabled a peripheral in the Pinout section, go inside the Configuration section and click
on the DMA button. The DMA Configuration dialog appears, as shown in Figure 8.
DMA Management 283
Figure 8: The DMA Configuration dialog in CubeMX
The dialog contains two or three tabs (according the number of DMA controllers provided by your
MCU). The first two are related to peripheral requests. For example, if you want to enable a DMA
request for USART2 in transmit mode (to do a memory-to-peripheral transfer), click on the Add
button, and select the USART2_TX entry. CubeMX will automatically fill the remaining fields for you,
selecting the right channel. You can then assign a priority to the request, and to set other things
like the DMA mode, peripheral/memory increment, and so on. Once completed, click on the OK
button.Inthesameway,itispossibletoconfigureDMAchannels/streamstodomemory-to-memory
transfers.
CubeMX will automatically generate the right initialization code for the used channels inside the
stm32xxxx_hal_msp.c file.
9.4 Correct Memory Allocation of DMA Buffers
If you take a look at the source code of all examples presented in this chapter, you can see that
DMA buffers (that is, both source and destination arrays used to perform memory-to-peripheral
and peripheral-to-memory transfers) are always allocated at the global scope. Why we are doing
that?
This is a common mistake that all novices sooner or later will do. When we declare a variable at
the local scope (that is, on the stack frame of the called routine), that variable will “live” as long
as that stack frame is active. When the called function exits, the stack area where the variable has
been allocated is reassigned to other uses (to store the arguments or other local variables of the next
called function). If we use a local variable as buffer for DMA transfers (that is, we pass to the DMA
memory port the address of a memory location in the stack), then it will be very likely that DMA
will access to a memory region containing other data, corrupting that memory area if we are doing
DMA Management 284
a peripheral-to-memory transfer, unless we are sure that the function is never popped from the stack
(this could be the case of a variable declared inside the main() function).
Figure 9: The difference between a variable allocated locally and globally
The Figure 9 clearly shows the difference between a variable allocated locally ( lbuf ) and one
allocated at the global scope ( gbuf ). lbuf will be active as long the func1() is on the stack.
Ifyouwanttoavoidglobalvariablesinyourapplication,anothersolutionisrepresentedbydeclaring
it as static . As we will discover in Chapter 20, static variables are automatically allocated inside
the .data region (Global Data region in Figure 9), even if their “visibility” is limited at the local
scope.
9.5 A Case Study: The DMA Memory-To-Memory
Transfer Performance Analysis
The DMA controller can be also used to do memory-to-memory transfers¹⁷. For example, it can be
used to move a large array of data from flash memory to the SRAM, or to copy arrays in SRAM,
or to zero a memory area. The C library usually provides a set of functions to accomplish this task.
memcpy() and memset() are the most common ones. Surfing around in the web, you can find several
tests that do a performance comparison between memcpy() / memset() routines and DMA transfers.
The majority of these tests claim that usually the DMA is much more slower than the Cortex-M
core. Is this true? The answer is: it depends. So, why would you use the DMA when you actually
have already those routines?
The story behind these tests is much more complicated, and it involves several factors like the
memory align, the C library used and the right DMA settings. Let us consider the following test
application (the code is designed to run on an STM32F4 MCU) divided in several stages:
¹⁷ Remember that in STM32F2/F4/F7 MCUs only the DMA2 can be used for this kind of transfers.
DMA Management 285
Filename: src/mem2mem.c
12 DMA_HandleTypeDef hdma_memtomem_dma2_stream0;
13
14 const uint8_t flashData[] = {0xe7, 0x49, 0x9b, 0xdb, 0x30, 0x5a, ...};
15 uint8_t sramData[1000];
16
17 int main(void) {
18 HAL_Init();
19 Nucleo_BSP_Init();
20
21 hdma_memtomem_dma2_stream0.Instance = DMA2_Stream0;
22 hdma_memtomem_dma2_stream0.Init.Channel = DMA_CHANNEL_0;
23 hdma_memtomem_dma2_stream0.Init.Direction = DMA_MEMORY_TO_MEMORY;
24 hdma_memtomem_dma2_stream0.Init.PeriphInc = DMA_PINC_ENABLE;
25 hdma_memtomem_dma2_stream0.Init.MemInc = DMA_MINC_ENABLE;
26 hdma_memtomem_dma2_stream0.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
27 hdma_memtomem_dma2_stream0.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
28 hdma_memtomem_dma2_stream0.Init.Mode = DMA_NORMAL;
29 hdma_memtomem_dma2_stream0.Init.Priority = DMA_PRIORITY_LOW;
30 hdma_memtomem_dma2_stream0.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
31 hdma_memtomem_dma2_stream0.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
32 hdma_memtomem_dma2_stream0.Init.MemBurst = DMA_MBURST_SINGLE;
33 hdma_memtomem_dma2_stream0.Init.PeriphBurst = DMA_MBURST_SINGLE;
34 HAL_DMA_Init(&hdma_memtomem_dma2_stream0);
35
36 GPIOC->ODR = 0x100;
37 HAL_DMA_Start(&hdma_memtomem_dma2_stream0, (uint32_t)&flashData, (uint32_t)sramData, 1000);
38 HAL_DMA_PollForTransfer(&hdma_memtomem_dma2_stream0, HAL_DMA_FULL_TRANSFER, HAL_MAX_DELAY);
39 GPIOC->ODR = 0x0;
40
41 while(HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin));
42
43 hdma_memtomem_dma2_stream0.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
44 hdma_memtomem_dma2_stream0.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
45
46 HAL_DMA_Init(&hdma_memtomem_dma2_stream0);
47
48 GPIOC->ODR = 0x100;
49 HAL_DMA_Start(&hdma_memtomem_dma2_stream0, (uint32_t)&flashData, (uint32_t)sramData, 250);
50 HAL_DMA_PollForTransfer(&hdma_memtomem_dma2_stream0, HAL_DMA_FULL_TRANSFER, HAL_MAX_DELAY);
51 GPIOC->ODR = 0x0;
52
53 HAL_Delay(1000); /* This is a really primitive form of debouncing */
54
55 while(HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin));
56
57 GPIOC->ODR = 0x100;
DMA Management 286
58 memcpy(sramData, flashData, 1000);
59 GPIOC->ODR = 0x0;
Here we have two quite large arrays. One of these, flashData , is allocated inside the flash memory
thanks to the const modifier¹⁸. We want to copy its content inside the sramData array, which is
stored inside the SRAM as the name suggests, and we want to test how long it takes using DMA and
memcpy() function.
First we start testing the DMA. The hdma_memtomem_dma2_stream0 handle is used to configure the
DMA2stream0/channel0toexecuteamemory-to-memorytransfer.Inthefirststageweconfigurethe
DMAstreamtoperformabyte-alignedmemorytransfer.OncetheDMAconfigurationiscompleted,
we start the transfer. Using an oscilloscope attached to Nucleo PC8 pin, we can measure how long
the transfer takes. Pressing the Nucleo USER button (connected to PC13) causes the start of another
test stage. This time we configure the DMA so that a word-aligned transfer is executed. Finally, at
line 58 we test how long it takes to copy the array using memcpy() .
Table 13: M2M transfer test results
The Table 13 shows the results obtained for every Nucleo board. Let us focus on the the Nucleo-
F401RE board. As you can see, the DMA M2M byte-aligned transfer takes ∼ 42μS, while the DMA-
¹⁸ The reason why this happens will be explained in Chapter 20.
DMA Management 287
M2M word-aligned transfer takes ∼ 14 μS. This is a great speed-up, which proves that using the right
DMA configuration can give us the best transfer performance, since we are moving 4 bytes at once
for each DMA shoot. What about the memcpy()? As you can see from Table 13, it depends on the
C library used. The GCC tool-chain we are using provides two C run-time libraries: one is named
newlib and one newlib-nano . The first one is the most complete and speed-optimized of the two,
while the second one is a reduced-size version. The memcpy() in the newlib library is designed to
provide the fastest copy speed, at the expense of code size. It automatically detects word-aligned
transfers, and it equals the DMA when doing word-aligned M2M transfers. So, it is much faster
than DMA when doing byte-aligned M2M transfers and that is the reason why someone claims that
memcpy() is always faster then DMA. On the other hand, both Cortex-M core and the DMA need to
access flash and SRAM memory using the same bus. So there are no reasons why the core should
be faster than the DMA¹⁹.
As you can see, the fastest transfer speed is achieved when the DMA stream/channel disables the
internal FIFO buffer ( ∼ 12 μS). It is important to remark that for STM32 MCUs with smaller flash
memories the newlib-nano it is almost an unavoidable choice, unless the code can fit the flash
space. But again, using the right DMA settings we can achieve the same performances of the speed-
optimized version available in newlib library.
The last thing we have to analize is the last column in Table 13. It shows how long it takes to do a
memory transfer using a simple loop like the following one:
...
GPIOC->ODR = 0x100;
for(int i = 0; i < 1000; i++)
sramData[i] = flashData[i];
GPIOC->ODR = 0x0;
...
As you can see, with the maximum optimization level (-O3) it takes exactly the same time of
memcpy() . Why does this happen?
...
GPIOC->ODR = 0x100;
8001968: f44f 7380 mov.w r3, #256 ; 0x100
800196c: 6163 str r3, [r4, #20]
800196e: 4807 ldr r0, [pc, #28] ; (800198c <main+0x130>)
8001970: 4907 ldr r1, [pc, #28] ; (8001990 <main+0x134>)
8001972: f44f 727a mov.w r2, #1000 ; 0x3e8
8001976: f000 f92d bl 8001bd4 <memcpy>
for(int i = 0; i < 1000; i++)
sramData[i] = flashData[i];
GPIOC->ODR = 0x0;
800197a: 6165 str r5, [r4, #20]
...
¹⁹ Here I am clearly excluding some “privileged paths” between the Cortex-M core and SRAM. This is the role of the Core-Coupled Memory
(CCM), a feature available in some STM32 MCUs and that we will explore better in Chapter 20.
DMA Management 288
Looking at generated assembly code above you can see that the compiler automatically transforms
the loop in a call to the memcpy() function. This clearly explains why they have the same
performances.
Table 13 shows another interesting result. For an STM32F152RE MCU, the memcpy() in newlib is
always twice faster than the DMA M2M. I do not know why this happens, but I have executed
several tests and I can confirm the result.
Finally, other tests not reported here show that it is convenient to use DMA to do M2M transfers
when the array has more than 30-50 elements, otherwise the DMA setup costs outweigh the benefits
related to its usage. However, it is important to remark that the other advantage in using the DMA
M2M transfer is that the CPU is free to accomplish other tasks while the DMA performs the transfer,
even if its access to the bus slows the overall DMA performances.
How to switch to the newlib run-time library? This can be easily done in Eclipse, going in the
project settings (Project->Properties menu), then going into C/C++ Build->Settings section and
selectingtheMiscellaneousentryinsidetheCrossARMC++Linkersection.Uncheckingtheentry
Use newlib-nano (see Figure 10) will automatically cause that the final binary is linked with the
newlib library.
DMA Management 289
Figure 10: How to select newlib / newlib-nano run-time library
10. Clock Tree
Almost every digital circuit needs a way to synchronize its internal circuitry or to synchronize itself
with other circuits. A clock is a device that generates periodic signals, and it is the most widespread
form of heart beat source in digital electronics.
Thesameclocksignal,however,cannotbeusedtofeedallcomponentsandperipheralsprovidedbya
modern microcontroller like STM32 ones. Moreover, power consumption is a critical aspect directly
connected with the clock speed of a given peripheral. Having the ability to selectively disable or
reducetheclockspeedofsomeMCUpartsallowstooptimizetheoveralldevicepowerconsumption.
This requires that the clock is organized in a hierarchical structure, giving to the developer the
possibility to choose different speeds and clock sources.
ThischaptergivesabriefintroductiontothecomplexclockdistributionnetworkofanSTM32MCU.
Itsintentistoprovidetothereadernecessarytoolstounderstandandmanagetheclocktree,showing
themainfunctionalitiesofthe HAL_RCC module.ThischapterwillbefurthercompletedwithChapter
19 dedicated to the power management.
10.1 Clock Distribution
A clock is a device that usually generates a square wave signal, with a 50% duty cycle, as the one
shown in Figure 1¹.
Figure 1: A typical clock signal with a 50% duty cycle
A clock signal oscillates between V L and V H voltage levels, which for STM32 microcontrollers are
a fraction of the VDD supply voltage. The most fundamental parameter of a clock is the frequency,
which indicates how many times it switches from V L to V H in a second. The frequency is expressed
in Hertz.
¹ It is important to remark that the square wave represented in Figure 1 is “ideal”. The real square wave of a clock source has a trapezoidal
form.
Clock Tree 291
ThemajorityofSTM32MCUs²canbeclocked bytwodistinctclocksourcesalternatively:aninternal
RC oscillator³ (named High Speed Internal (HSI)) or an external dedicated crystal oscillator⁴ (named
High Speed External (HSE)). There are several reasons to prefer an external crystal to the internal
RC oscillator:
• An external crystal offers a higher precision compared to the internal RC network, which is
rated of a 1% accuracy⁵, especially when PCB operative temperatures are far from the ambient
temperature of 25°C.
• Some peripherals, especially high speed ones, can be clocked only by a dedicated external
crystal running at a given frequency.
Together with the high-speed oscillator⁶, another clock source can be used to bias the low-speed
oscillator, which in turn can be clocked by an external crystal (named Low Speed External (LSE)) or
the internal dedicated RC oscillator (named Low Speed Internal (LSI)). The low-speed oscillator is
used to drive the Real Time Clock (RTC) and the Independent Watchdog (IWDT) peripheral.
The frequency of the high-speed oscillator does not establish the actual frequency neither of the
Cortex-M core nor of the other peripherals. A complex distribution network, also called clock
tree, is responsible for the propagation of the clock signal inside an STM32 MCU. Using several
programmablePhase-LockedLoops(PLL)andprescalers,itispossibletoincrease/decreasethesource
frequency at needs (see Figure 2), depending on the performances we want to reach, the maximum
speed for a given peripheral or bus and the overall global power consumption⁷.
Figure 2: How the source clock signal frequency is increased/decreased using PLLs and prescalers
10.1.1 Overview of the STM32 Clock Tree
The clock tree of an STM32 MCU can have a really articulated structure. Even in “simpler” STM32F0
MCUs, the internal clock network can have up to four PLL/prescaler stages, and the System Clock
Multiplexer (also known as System Clock Switch (SW)) can be fed by several alternate sources.
² There exist some STM32 MCUs, especially those ones with low pin count, that cannot be clocked by an external clock source.
³ http://bit.ly/1TkDnUd
⁴ http://bit.ly/20ymjJx
⁵ A 1% accuracy may seem a good compromise, especially if you consider that you can save PCB space and the cost of a dedicated crystal,
which is a device that has a non-negligible price. However, for time-constraint applications, 1% may be a huge shift. For example, a day is made
of 86,400 seconds. An error equal to 1% means that in the worst case we can lose (or earn) up to 864 seconds, which is equal to 14,4 minutes!
And things may worsen if temperature increases. This is the reason why it is mandatory to use an external low-speed crystal if you are going
to use the RTC. However, a solution to increase this accuracy exists. More about this later.
⁶ In this book we will refer to the high-speed oscillator as an “abstract” clock source, which has two mutually exclusive “concrete” sources:
the HSE or the HSI oscillator. The same applies to the low-speed oscillator
⁷ Remember that the power consumption of an MCU is about linear with its frequency. The higher is the frequency, the more power it
consumes.
Clock Tree 292
Table 1: The maximum clock speeds for AHB, APB1 and APB2 buses of the MCUs equipping all Nucleo boards
Moreover, explaining in depth the clock tree of every STM32 family is a complex task, which also
requires we focus our attention on a specific part number. In fact, the clock tree structure is affected
mainly by the following key aspects:
• The STM32 main family of the microcontroller. For example, all STM32F0 MCUs provide
just one peripheral bus (APB1), which can be clocked at the same Cortex-M core maximum
frequency. Other STM32 microcontrollers usually provide two peripheral buses, and only one
ofthese(APB2)canreachthemaximumCPUclockspeed.Instead,noneoftheperipheralbuses
available in an STM32F7 microcontroller can reach the maximum core frequency⁸. Table 1
reports the maximum clock speed for AHB, APB1 and APB2 buses (with related timers clock
speed) of the MCUs equipping all Nucleo boards: you can note that, for some STM32 MCUs, it
is possible to reach the maximum clock speed only by using an external HSE oscillator.
• The type and number of peripherals provided by the MCU. The complexity of the clock
tree increases with the number of available peripherals. Moreover, some peripherals require
dedicated clock sources and speeds, which impact on the number of PLL stages.
• The sales type and package of the MCU, which determines the effective type and number of
provided peripherals.
EvenrestrictingourfocusonlyonthesixteenMCUsequippingtheNucleoboards,thiswouldrequire
a long and tedious work, which involve a deep knowledge of all peripherals implemented by the
⁸ Except for timers on the APB2 bus (at least at the time of writing this chapter - February 2016).
Clock Tree 293
given MCU. For these reasons, we will give a quick overview to the STM32 clock tree, leaving to the
reader the responsibility to deepen the particular MCU he is considering. Moreover, as we will see
in a while, thanks to CubeMX it is possible to abstract from the specific clock tree implementation,
unless we need to deal with specific PLL configurations for performance and power management
reasons.
Figure 3: The clock tree of an STM32F030R8 MCU
Figure 3 shows the clock tree of one of the simplest STM32 microcontrollers: the STM32F030R8. It
is extracted from the related reference manual⁹ provided by ST. For a lot of novices of the STM32
platform that figure is completely meaningless and quite hard to decode, especially if they are also
⁹ http://bit.ly/1GfS3iC
Clock Tree 294
new to embedded microcontrollers. The most relevant path has been outlined in red: the one that
goes from the HSI oscillator to the Cortex-M0 core, AHB bus and DMA. This is the path we have
“used”sinceheresilently,withoutdealingtoomuchwithitspossibleconfigurations.Letusintroduce
the most relevant parts of that path.
The path starts from the internal 8MHz oscillator. As said before, it is an RC oscillator factory-
calibrated by ST for 1% accuracy at a ambient temperature of 25 °C. The HSI clock can then be used
to feed the System Clock Switch (SW) as is (path highlighted in blue in Figure 3) or it can be used
to feed the PLL multiplier after it has been divided by two thanks to an intermediate prescaler¹⁰.
The main PLL so can multiply the 4MHz clock up to 12 times to obtain the maximum System Clock
Frequency (SYSCLK) of 48MHz. The SYSCLK source can be used to feed the I2C1 peripheral (in
alternative to the HSI) and another intermediate prescaler, the AHB prescaler, which can be used to
lower the High (speed) Clock (HCLK), which in turn biases the AHB bus, the core and the SysTimer.
Why So Many Intermediate PLL/Prescaler Stages?
As said before, the clock speed determines the overall performances, but it also affects the
total power consumption of the MCU. Having the capability to selectively turn ON/OFF or
reduce the clock speed of some parts of the MCU gives the possibility to reduce the power
consumptionaccordingtheeffectivecomputingpowerneeded.AswewillseeinChapter19,
L0/1/4 MCUs introduce even more PLL/prescaler stages to offer to developers more control
on the overall MCU consumption. Together with a dedicated hardware design, this allows
to create battery-powered devices that can be run even for years using the same battery.
The clock tree configuration is performed through a dedicated peripheral¹¹ named Reset and Clock
Control (RCC), and it is a process essentially composed by three steps:
1. The high-speed oscillator source is selected (HSI or HSE) and properly configured, if the HSE
is used.¹²
2. If we want to feed the SYSCLK with a frequency higher than the one provided by the high-
speed oscillator, then we need to configure the main PLL (which provides the PLLCLK signal).
Otherwise we can skip this step.
3. The System Clock Switch (SW) is configured choosing the right clock source (HSI, HSE, or
PLLCLK). Then we select the right AHB, APB1 and APB2 (if available) prescaler settings to
reach the wanted frequency of theHigh-speed clock (HCLK - that is the one that feeds the core,
DMAs and AHB bus), and the frequencies of Advanced Peripheral Bus 1 (APB1) and APB2 (if
available) buses.
Knowing the admissible values for PLLs and prescalers can be a nightmare, especially for more
complex STM32 MCUs. Only some combinations are valid for a given STM32 microcontroller, and
¹⁰ A prescaler is an “electronic counter” used to reduce high frequencies. In this case, the “/2” prescaler reduces the main 8MHz frequency
to 4MHz.
¹¹ Sometimes, ST defines in its documents the RCC as “peripheral”. Sometimes no. I am not sure that if it is properly a peripheral, but I will
define it in the same way ST does. Sometimes.
¹² In STM32L0/1/4 MCUs, the SYSCLK can be also fed by another dedicated and low-power clock source, named MSI. We will talk about
this clock source next.
Clock Tree 295
their improper configuration could potentially damage the MCU or at least cause malfunctions
(a wrong clock configuration could lead to abnormal behaviour, strange and unpredictable resets
and so on). Luckily for us, the STM32 engineers have provided a great tool to simplify the clock
configuration: CubeMX.
10.1.1.1 The Multispeed Internal RC Oscillator in STM32L Families
The clock source and its distribution network have a non-negligible impact on the overall power
consumption of the MCU. If we need a SYSCLK frequency higher or lower than the internal HSI
clock source (which is 8MHz for the most of STM32 MCUs and 16MHz for some others), we have to
increase/reduce it by using the PLL Source Mux and intermediate prescalers. Unfortunately, these
components consume energy, and this can have a dramatic impact on battery-powered devices.
Table 2: A comparison between clock sources in an STM32L476 MCU
STM32L0/1/4 MCUs are explicitly designed for low-power applications, and they address this
specific issue by supplying a dedicated internal clock source, named MultiSpeed Internal (MSI)
RC oscillator. MSI is a low-power RC oscillator, with a ±1%@25°C factory pre-calibrated accuracy,
whichcanincreaseupto±3%inthe0-85°Crange.ThemaincharacteristicoftheMSIisthatitsupplies
up to twelve different frequencies, without adding any external component. For example, the MSI
in an STM32F476 provides an internal clock source ranging from 100kHz up to 48MHz. The MSI
clock is used as SYSCLK after restart from Reset, wakeup from Standby and Shutdown low-power
modes. After restart from Reset, the MSI frequency is set to its default (for example, the default
MSI frequency in an STM32F476 is 4MHz). Table 2 summarizes the most relevant characteristics of
all possible clock sources in an STM32L476 MCU. As you can see, the best power consumption is
achieved while the MCU is clocked by the MSI (without using the PLL Multiplexer). Moreover, this
clock source guarantees the shortest startup time, if compared with the HSI. It is interesting to see
that up to two seconds are required to stabilize the LSE clock: if startup speed is really important for
your application, then using a separated thread to start the LSE is an option to consider.
In addition to the advantages related to low-power, when the MSI is used as source for the PLL
Clock Tree 296
Source Mux with the LSE, it provides a very accurate clock source which can be used by the USB
OTG FS device without using an external dedicated crystal, while feeding the main PLL to run the
system at the maximum speed of 80MHz.
10.1.2 Configuring Clock Tree Using CubeMX
We have already encountered in Chapter 4 the CubeMX Clock Configuration view. Now it is the
right time to see how it works. The Figure 4 shows the clock tree of the same F0 MCU seen so far.
As you can see, thanks to the more room available on the screen, the distribution network looks less
cumbersome.
Figure 4: How the clock tree of an STM32F030R8 MCU is represented in CubeMX
Even in this case, the most relevant paths of the clock tree have been highlighted in red and blue.
This should simplify the comparison with the Figure 3. When a new project is created, by default
CubeMXchoosestheHSIoscillatorasdefaultclocksource.HSIisalsochosenasdefaultclocksource
for the System Clock Switch (path in blue), as shown in Figure 4. This means that, for the MCU we
are considering here, the Cortex-M core frequency will be equal to 8MHz.
CubeMX also advises us about two things: the maximum frequency for the High (speed) Clock
(HCLK) and the APB1 bus is equal to 48MHz in this MCU (labels in blue). To increase the CPU
Clock Tree 297
core frequency we first need to select the PLLCLK as the source clock for the System Clock Switch
and then choose the right PLL multiplier factor. However, CubeMX offers a quick way to do this:
you can simply write “48” inside the HCLK field and hit the enter key. CubeMX will automatically
arrange the settings, choosing the right clock tree path (the red one in Figure 4)
If your board relies on an external HSE/LSE crystal, you have to enable it in the RCC peripheral
before you can use it as main clock source for the corresponding oscillator (we will see in a while
how to do this step-by-step). Once the external oscillator is enabled, it is possible to specify its
frequency (inside the blue box labeled “input frequency”) and to configure the main PLL to achieve
the desired SYSCLK speed (see Figure 5). Otherwise, the external oscillator input frequency can be
used directly as source clock for the System Clock Switch.
Figure 5: CubeMX allow to select the HSE oscillator once it is enabled using the RCC peripheral
We need to configure the RCC peripheral accordingly to enable an external clock source. This can
be done from the Pinout view in CubeMX, as shown in Figure 6.
Figure 6: The configuration options provided by the RCC peripheral
For both HSE and LSE oscillators, CubeMX offers three configuration options:
• Disable: the external oscillator is not available/used, and the corresponding internal oscillator
is used.
• Crystal/Ceramic Resonator: an external crystal/ceramic resonator is used and the corre-
sponding main frequency is derived from it. This implies that RCC_OSC_IN and RCC_OSC_-
OUT pins are used to interface the HSE, and the corresponding signal I/Os are unavailable
for other usages (if we are using an external low-speed crystal, then the corresponding
RCC_OSC32_IN and RCC_OSC32_OUT I/Os are used too).
• BYPASS Clock Source: an external clock source is used. The clock source is generated by
another active device. This means that the RCC_OSC_OUT is leaved unused, and it is possible
Clock Tree 298
to use it as regular GPIO. In almost all development board from ST (included the Nucleo ones)
the Master Clock Output (MCO) pin of the ST-LINK interface is used as external clock source
for the target STM32 MCU. Enabling this option allows to use the ST-LINK MCO as HSE.
The RCC peripheral also allows to enable the Master Clock Output (MCO), which is a pin that can
be connected to a clock source. It can be used to clock another external device, allowing to save on
the external crystal for this other IC. Once the MCO is enabled, it is possible to choose its clock
source using the Clock Configuration view, as shown in Figure 7.
Figure 7: How to select the clock source for the MCO pin
10.1.3 Clock Source Options in Nucleo Boards
The Nucleo development boards offer several alternatives for the clock sources
10.1.3.1 OSC Clock Supply
There are four ways to configure the pins corresponding to external high-speed clock external high-
speed clock (HSE):
• MCO from ST-LINK: MCO output of ST-LINK MCU is used as input clock. This frequency
cannot be changed, it is fixed at 8 MHz and connected to PF0/PD0/PH0-OSC_IN of target
STM32 MCU.
The following configuration is needed:
– SB55 OFF
– SB16 and SB50 ON
– R35 and R37 removed
• HSE oscillator on-board from X3 crystal (not provided): for typical frequencies and its
capacitors and resistors, refer to STM32 microcontroller datasheet. Please refer to the AN2867
for oscillator design guide for STM32 microcontrollers.
The following configuration is needed:
Clock Tree 299
– SB54 and SB55 OFF
– R35 and R37 soldered
– C33 and C34 soldered
– SB16 and SB50 OFF
• OscillatorfromexternalPF0/PD0/PH0:fromanexternaloscillatorthroughpin29oftheCN7
connector.
The following configuration is needed:
– SB55 ON
– SB50 OFF
– R35 and R37 removed
• HSE not used: PF0/PD0/PH1 and PF1/PD1/PH1 are used as GPIO instead of Clock
The following configuration is needed:
– SB54 and SB55 ON
– SB16 and SB50 (MCO) OFF
– R35 and R37 removed
There are two possible default configurations of the HSE pins depending on the version of NUCLEO
board hardware. The board version MB1136 C-01/02/03 is mentioned on sticker placed on bottom
side of the PCB.
• The board marking MB1136 C-01 corresponds to a board, configured for HSE not used.
• TheboardmarkingMB1136C-02(orhigher)correspondstoaboard,configuredtouseSTLINK
MCO as clock input.
Read Carefully
For Nucleo-L476RG the ST-LINK MCO output is not connected to OSCIN, to reduce power
consumption in low power mode. Consequently, the HSE in a Nucleo-L476RG cannot be
used unless an external crystal is mounted on X3 pad, as described before.
10.1.3.2 OSC 32kHz Clock Supply
There are three ways to configure the pins corresponding to low-speed clock (LSE):
• On-board oscillator: X2 crystal. Please refer to the AN2867 for oscillator design guide for
STM32 microcontrollers. The oscillator P/N is ABS25-32.768KHZ-6-T and it is manufactured
by Abracon corporation.
• Oscillator from external PC14: from external oscillator through the pin 25 of CN7 connector.
The following configuration is needed:
– SB48 and SB49 ON
Clock Tree 300
– R34 and R36 removed
• LSE not used: PC14 and PC15 are used as GPIOs instead of low speed Clock.
The following configuration is needed:
– SB48 and SB49 ON
– R34 and R36 removed
There are two possible default configurations of the LSE depending on the version of NUCLEO
board hardware. The board version MB1136 C-01/02/03 is mentioned on sticker placed on bottom
side of the PCB.
• The board marking MB1136 C-01 corresponds to a board configured as LSE not used.
• The board marking MB1136 C-02 (or higher) corresponds to a board configured with onboard
32kHz oscillator.
• The board marking MB1136 C-03 (or higher) corresponds to a board using new LSE crystal
(ABS25) and C26, C31 & C32 value update.
Read Carefully
All Nucleo boards with a release version equal to MB1136 C-02 have a severe issue with the
values of the dumping resistor R34, R36 and with the capacitors C26, C31 & C32. This issue
prevents the LSE to start correctly.
10.2 Overview of the HAL_RCC Module
So far we have seen that the Reset and Clock Control (RCC) peripheral is responsible of the
configuration for the whole clock tree of an STM32 MCU. The HAL_RCC module contains the
corresponding descriptors and routines of the CubeHAL to abstract from the specific RCC imple-
mentation. However, the actual implementation of this module inevitably reflects the peculiarities
of the clock tree in a given STM32-series and part number. Deepening this module, as we have done
for other HAL modules, is outside the scope of this book. It would require we keep track of too many
differences among the several STM32 microcontrollers. So, we will now give a brief overview to its
main features and to the steps involved during the configuration of the clock tree.
The most relevant C struct to configure the clock tree are RCC_OscInitTypeDef and RCC_ClkInit-
TypeDef . The first one is used to configure the RCC internal/external oscillator sources (HSE, HSI,
LSE, LSI), plus some additional clock sources if provided by the MCU. For example, some STM32
MCUsfromtheF0series(STM32F07x,STM32F0x2andSTM32F09xones)provideUSB2.0support,in
addition to an internal dedicated and factory-calibrated high-speed oscillator running at 48MHz to
bias the USB peripheral. If this is the case, the RCC_OscInitTypeDef struct is also used to configure
those additional clock sources. The RCC_OscInitTypeDef struct also has a field that is instance of
Clock Tree 301
the RCC_PLLInitTypeDef struct , which configures the main PLL used to increase the speed of the
source clock. It reflects the hardware structure of the main PLL, and can be composed by several
fields depending on the STM32 series (in STM32F2/4/7 MCUs it can have a quite complex structure).
The RCC_ClkInitTypeDef struct , instead, is used to configure the source clock for theSystem Clock
Switch (SWCLK), for the AHB bus and the APB1/2 buses.
CubeMX is designed to generate the right code initialization for the clock tree of our MCU. All the
necessary code is packed inside the SystemClock_Config() routine, which we have encountered in
the projects generated until now. For example, the following implementation of the SystemClock_-
Config() reflects the clock tree configuration for an STM32F030R8 MCU running at 48MHz:
1 void SystemClock_Config(void) {
2 RCC_OscInitTypeDef RCC_OscInitStruct;
3 RCC_ClkInitTypeDef RCC_ClkInitStruct;
4
5 RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
6 RCC_OscInitStruct.HSIState = RCC_HSI_ON;
7 RCC_OscInitStruct.HSICalibrationValue = 16;
8 RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
9 RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
10 RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
11 RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
12 HAL_RCC_OscConfig(&RCC_OscInitStruct);
13
14 RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK;
15 RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
16 RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
17 RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
18 HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);
19
20 HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
21
22 HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
23
24 /* SysTick_IRQn interrupt configuration */
25 HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
26 }
Lines [5:12] select the HSI as source oscillator and enable the main PLL, setting the HSI as its clock
source through the PLL multiplexer. The clock frequency is then increased by twelve times (settings
the PLLMUL field). Lines [14:18] set the SYSCLK frequency. The PLLCLK is selected as clock source
(line 15). In the same way, the SYSCLK frequency is selected as source for the AHB bus, and the
same HCLK frequency ( RCC_HCLK_DIV1 ) as source for the APB1 bus. The other lines of code set the
SysTick timer,aspecialtimeravailableintheCortex-McoreusedtosynchronizesomeinternalHAL
activities (or to drive the scheduler of an RTOS, as we will see in Chapter 23). The HAL is based
Clock Tree 302
on the convention that SysTick timer generates an interrupt ever 1ms. Since we are configuring
the SysTick clock so that it runs at the maximum core frequency of 48MHz (which means that the
SYSCLK performs 48.000.000 clock cycles every seconds), we can set the SysTick timer so that it
generates an interrupt every 48.000.000 cycles/1000ms = 48.000 clock cycles ¹³.
10.2.1 Compute the Clock Frequency at Run-Time
Sometimes it is important to know how fast is running the CPU core. If our firmware is designed so
that it always runs at an established frequency, we can easily hardcode that value in the firmware
using a symbolic constant. However, this is always a poor programming style, and it is totally
inapplicable if we manage the CPU frequency dynamically. The CubeHAL provides a function that
can be used to compute the SYSCLK frequency: the HAL_RCC_GetSysClockFreq() ¹⁴. However, this
function must be handled with special care. Let us see why.
The HAL_RCC_GetSysClockFreq() does not return the real SYSCLK frequency (it could never do this
in a reliable way without having a known and precise external reference), but it bases the result on
the following algorithm:
• if SYSCLK source is the HSI oscillator, then returns the value based on the HSI_VALUE macro;
• if SYSCLK source is the HSE oscillator, then returns the value based on the HSE_VALUE macro;
• if SYSCLK source is the PLLCLK, then returns a value based on HSI_VALUE/HSE_VALUE
multiplied by the PLL factor, according the specific STM32 MCU implementation.
HSI_VALUE and HSE_VALUE macros are defined inside the stm32xxx_hal_conf.h file, and they are
hardcoded values. The HSI_VALUE is defined by ST during chip design, and we can trust the value
of the corresponding macro (except for that 1% of accuracy). Instead, if we are using an external
oscillator as HSE source, we must provide the actual value for the HSE_VALUE macro, otherwise the
valuereturnedbythe HAL_RCC_GetSysClockFreq() functioniswrong¹⁵.Andthisalsoaffectsthetick
frequency (that is, how long it takes to generate the timer interrupt) of the SysTick timer.
We can also retrieve the core frequency by using the SystemCoreClock CMSIS global variable.
Read Carefully
If we decide to manipulate the clock tree configuration by hand without using CubeHAL
routines, we have to remember that every time we change the SYSCLK frequency, we
need to call the CMSIS function SystemCoreClockUpdate() , otherwise some CMSIS routines
may give wrong results. This function is automatically called for us by the HAL_RCC_-
ClockConfig() routine.
¹³ As we will see in the next chapter, a timer is free counter module, that is a device that counts from 0 to a given value at every clock cycle.
Take note that, for the sake of completeness, the SysTick timer is a 24-bit downcounter timer, that is it counts from the configured maximum
value(48.000inourcase)downtozero,andthenautomaticallyrestartsagain.Thesourceclockofatimerestablisheshowfastthistimercounts.
Since here we are specifying that the clock source for the SysTick timer is the HCLK (line 22), then the counter will reach zero every 1ms.
¹⁴ Pay attention that the Cortex-M core is not clocked by the SYSCLK frequency, but by the HCLK frequency, which could be lowered by
the AHB prescaler. So, to recap, the core frequency is equal to HAL_RCC_GetSysClockFreq() /AHB-prescaler.
¹⁵ The HAL_RCC_GetSysClockFreq() is defined to return an uint32_t . This means that it could return wrong results with fractional values
for the HSE oscillator.
Clock Tree 303
10.2.2 Enabling the Master Clock Output
As said before, depending on the IC package used, STM32 MCUs allow to route the clock signal to
one or two output I/Os, calledMaster Clock Output (MCO). This is performed by using the function:
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv);
For example, to route the PLLCLK to MCO1 pin in an STM32F401RE MCU (which corresponds to
PA8 pin), we must invoke the above function in the following way:
HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_PLLCLK, RCC_MCODIV_1);
Read Carefully
Please, take note that when configuring the MCO pin as output GPIO, its speed (that is, the
slew rate) affects the quality of the output clock. Moreover, for higher clock frequencies the
compensation cell must be enabled in the following way:
HAL_EnableCompensationCell();
Refer to the datasheet of your MCU for more about this.
10.2.3 Enabling the Clock Security System
The Clock Security System (CSS) is a feature of the RCC peripheral used to detect malfunctions of
theexternalHSE.TheCSSisanimportantfeatureinsomecriticalapplications,whereamalfunction
of the HSE could cause injuries to the user. Its importance is proven by the fact that the detection of
a failure is noticed through the NMI exception, a Cortex-M exception that cannot be disabled.
When the failure of HSE is detected, the MCU automatically switch to the HSI clock, which is
selectedassourcefortheSYSCLKclock.So,ifahighercorefrequencyisneeded,weneedtoperform
proper initializations inside the NMI exception handler.
To enable the CSS we use the HAL_RCC_EnableCSS() routine, and we need to define the handler for
the NMI exception in the following way¹⁶:
void NMI_Handler(void) {
HAL_RCC_NMI_IRQHandler();
}
The right way to catch the failure of the HSE clock is by defining the callback:
¹⁶ There is no need to enable the NMI exception, because it is automatically enabled and it cannot be disabled.
Clock Tree 304
void HAL_RCC_CSSCallback(void) {
//Catch the HSE failure and take proper actions
}
10.3 HSI Calibration
We have left uncommented one line of code in the SystemClock_Config() routine seen before: the
instruction at line 7. It used to perform a fine-tune calibration of the HSI oscillator. But what exactly
it does?
As said before, the frequency of the internal RC oscillators may vary from one chip to another due
to manufacturing process variations. For this reason, HSI oscillators are factory-calibrated by ST to
have a 1% accuracy at room temperature. After a reset, the factory calibration value is automatically
loaded in the second byte (HSICAL) of the RCC configuration register (RCC_CR) (the Figure 8
shows the implementation of this register in an STM32F401RE¹⁷).
Figure 8: The RCC_CR register in an STM32F401RE MCU
The frequency of the internal RC oscillator can be fine-tuned to achieve better accuracy with
wider temperature and supply voltage ranges. The trimming bits are used for this purpose. Five
trimming bits RCC_CR->HSITRIM[4:0] are used for fine-tuning. The default trimming value is 16.
An increase/decrease in this trimming value causes an increase/decrease in HSI frequency. The HSI
oscillator is fine-tuned in steps of 0.5% of the HSI clock speed:
• Writing a trimming value in the range of 17 to 31 increases the HSI frequency.
• Writing a trimming value in the range of 0 to 15 decreases the HSI frequency.
• Writing a trimming value equal to 16 causes the HSI frequency to keep its default value.
The HSI can be calibrated using the following procedure:
1. set the internal high-speed RC oscillator system clock;
2. measure the internal RC oscillator frequency for each trimming value;
3. compute the frequency error for each trimming value (according a known reference);
¹⁷ The figure is taken from the RM0368 application note from ST (http://bit.ly/1Kq3SoE).
Clock Tree 305
4. finally, set the trimming bits with the optimum value (corresponding to the lowest frequency
error).
The internal oscillator frequency is not measured directly but it is computed from the number of
clock pulses counted using a timer compared with the typical value. To do this, a very accurate
reference frequency must be available such as the LSE frequency provided by the external 32.768
kHz crystal or the 50 Hz/60 Hz of the mains.
ST provides several application notes describing better this procedure (for example, the AN4067¹⁸ is
about the calibration procedure in the STM32F0 family). Please, refer to those documents for more
information.
¹⁸ http://bit.ly/1R8kEbf
11. Timers
Embedded devices perform some activities on a time basis. For really simple and inaccurate delays a
busy loop could carry out the task, but using the CPU core to perform time-related activities is never
a smart solution. For this reason, all microcontrollers provide dedicated hardware peripherals: the
timers. Timers are not only timebase generators, but they also provides several additional features
used to interact with the Cortex-M core and other peripherals, both internal and external to the
MCU.
Dependingonthefamilyandpackageused,STM32microcontrollersimplementavariablenumberof
timers, each one with specific characteristics. Some part numbers can provide up to 14 independent
timers. Different from the other peripherals, timers have almost the same implementation in all
STM32-series, and they are grouped inside nine distinct categories. The most relevant of these are:
basic, general purpose and advanced timers.
STM32 timers arean advanced peripheral that offer a wide rangeof customizations. Moreover,some
of their features are specific of the application domain. This would require a completely separated
book to deepen the topic (you have to consider that usually more than 250 pages of a typical STM32
datasheet is dedicated to timers). This chapter, which is undoubtedly the longest in the book, tries
to shape the most relevant concepts regarding basic and general purpose timers in STM32 MCUs,
looking to the related CubeHAL module used to program them.
11.1 Introduction to Timers
Atimerisafree-running counterwithacountingfrequencythatisafractionofitssourceclock.The
counting speed can be reduced using a dedicated prescaler for each timer¹. Depending on the timer
type, it can be clocked by the internal clock (which is derived from the bus where it is connected),
by an external clock source or by another timer used as “master”.
Usually, a timer counts from zero up to a given value, which cannot be higher than the maximum
unsigned value for its resolution (for example, a 16-bit timer overflows when the counter reaches
65535), but it can also count on the contrary and in other ways we will see next.
The most advanced timers in an STM32 microcontroller have several features:
• They can be used as time base generator (which is the feature common to all STM32 timers).
• They can be used to measure the frequency of an external event (input capture mode).
• To control an output waveform, or to indicate when a period of time has elapsed (output
compare mode).
¹ This is not entirely true, but it is ok to consider it true here.
Timers 307
– One pulse mode (OPM) is a particular case of the input capture mode and the output
comparemode.Itallowsthecountertobestartedinresponsetoastimulusandtogenerate
a pulse with a programmable length after a programmable delay.
• TogeneratePWMsignalsinedge-alignedmodeorcenter-alignedmodeindependentlyoneach
channel (PWM mode).
– In some STM32 MCUs (notably from STM32F3 and recent STM32L4 series), some timers
can generate a center-aligned PWM signals with a programmable delay and phase shift.
Depending on the timer type, a timer can generate interrupts or DMA requests when the following
events occur:
• Update events
– Counter overflow/underflow
– Counter initialized
– Others
• Trigger
– Counter start/stop
– Counter Initialize
– Others
• Input capture/Output compare
11.1.1 Timer Categories in an STM32 MCU
STM32 timers can mainly grouped in nine categories. Let us give a brief look at each one of them.
• Basic timers: timers from this category are the simplest form of timers in STM32 MCUs. They
are 16-bit timers used as time base generator, and they do not have output/input pins. Basic
timers are also used to feed the DAC peripheral, since their update event can trigger DMA
requests for the DAC (for this reason they are usually available in STM32 MCUs providing at
least a DAC). Basic timers can be also used as “masters” for other timers.
• General purpose timers: they are 16/32-bit timers (depending on the STM32-series) providing
the classical features that a timer of a modern embedded microcontroller is expected to
implement.Theyareusedinanyapplicationforoutputcompare(timinganddelaygeneration),
One-Pulse Mode, input capture (for external signal frequency measurement), sensor interface
(encoder, hall sensor), etc. Obviously, a general purpose timer can be used as time base gen-
erator, like a basic timer. Timers from this category provide four-programmable input/output
channels.
– 1-channel/2-channels: they are two subgroups of general purpose timers providing only
one/two input/output channel.
Timers 308
– 1-channel/2-channels with one complimentary output: same as previous type, but
having a dead time generator on one channel. This allows having complementary signals
with a time base independent from the advanced timers.
• Advanced timers: these timers are the most complete ones in an STM32 MCU. In addition to
the features found in a general purpose timer, they include several features related to motor
controlanddigitalpowerconversionapplications:threecomplementarysignalswithdeadtime
insertion, emergency shut-down input.
• High resolution timer: The high-resolution timer (HRTIM1) is a special timer provided by
some microcontrollers from the STM32F3 series (which is the series dedicated to motor control
and power conversion). It allows generating digital signals with high-accuracy timings, such
as PWM or phase-shifted pulses. It consists of 6 sub-timers, 1 master and 5 slaves, totaling 10
high-resolution outputs, which can be coupled by pairs for dead time insertion. It also features
5 fault inputs for protection purposes and 10 inputs to handle external events such as current
limitation, zero voltage or zero current switching.
HRTIM1 timer is made of a digital kernel clocked at 144 MHz followed by delay lines. Delay
lines with closed loop control guarantee a 217ps resolution whatever the voltage, temperature
or chip-to-chip manufacturing process deviation. The high-resolution is available on the 10
outputs in all operating modes: variable duty cycle, variable frequency, and constant ON time.
This book will not cover HRTIM1 timer.
• Low-powertimers:timersfromthisgroupareespeciallydesignedforlow-powerapplications.
Thanks to their diversity of clock sources, these timers are able to keep running in all power
modes (except for Standby mode). Given this capability to run even with no internal clock
source, Low-power timers can be used as a “pulse counter” which can be useful in some
applications. They also have the capability to wake up the system from low-power modes.
Table 1: The most relevant feature of each timer category
Table 1² summarizes the most relevant features to keep on hand for each timer category.
² The table is adapted from the one found in the AN4013(http://bit.ly/1WAewd6) from ST, an application note dedicated to STM32 timers.
Timers 309
11.1.2 Effective Availability of Timers in the STM32 Portfolio
Not all types of timers are available in all STM32 MCUs. It depends mainly on the STM32-series, the
sales type and package used. The Table 2 summarizes the distribution of the 22 timers in all STM32
families.
Table 2: Which timers are implemented in each STM32-series
It is important to remark some things regarding Table 2:
• Given a specific timer (e.g. TIM1, TIM8, etc.), its implementation (features, number and types
Timers 310
of registers, generated interrupts, DMA requests, peripheral interconnection³, etc.) is the same⁴
in all STM32 MCUs. This guarantees you that a firmware written to use a specific timer is
portable to other MCUs or STM32-series having the same timer.
• The effective presence of a timer in an MCU belonging to the given family depends on sales
type and the package used (packages with more pins may provide all timers implemented by
that family).
• The table was extracted, expanded and rearranged from the AN4013⁵. I have checked carefully
thevaluesreportedinthattable,andfoundsomenon-updatedthings.However,Iamnottotally
sure that it faithfully adheres to actual implementation⁶ of the whole STM32 portfolio (I should
check more than 600 microcontrollers to be sure of that values). For this reason, I have leaved
cells empty, so you can eventually add values if you discover a mistake⁷.
Table 3 reports the list of all timers implemented by the MCUs equipping the sixteen Nucleo boards
we are considering in this book. It is important to underline some things reported in Table 3:
• STM32F411RE, STM32F401RE and STM32F103RB do not provide a basic timer.
• The “MAX clock speed” column reports the maximum clock speed for all timers in a given
STM32 MCU. This means that the timer maximum clock speed depends on the bus where it is
connected to. Always consult the datasheet to determine to which bus the timer is connected
(see the peripheral mapping section of the datasheet) and use CubeMX Clock configuration
view to determine the configured bus speed.
• The STM32F410RB MCU, which has been introduced on the market at the beginning of 2016,
implements a feature that is distinctive of the STM32L0/L4 series: a low-power timer.
When dealing with timers, it is important to have a pragmatic approach. Otherwise, it is really easy
to get lost in their settings and in the corresponding HAL routines (the HAL_TIM and HAL_TIM_EX
modules are among the most articulated in the CubeHAL).
For this reason, we will start studying how to use basic timers, whose functionalities are also
common to more advanced STM32 timers.
³ With the term peripheral interconnection we indicate the ability of some peripherals to “trigger” other peripherals, or to fire some of their
DMA requests (for example, the TIM6 update event can trigger the DAC1 conversion). More about this topic in Chapter 13.
⁴ As said at the beginning of this chapter, STM32 timers are the only peripherals that share the same implementation among all STM32
families. This is almost true, except for TIM2 and TIM5 timers, which have a 32-bit resolution in the majority of STM32 MCUs and 16-bit
resolution in some early STM32 MCUs. Moreover, some really specific features may have a slight different implementation between some
STM32 series (especially between more “old” STM32F1 microcontrollers and more recent STM32F4 ones). Always consult the datasheet for
your MCU before you plan to use a really dedicated feature provided by some timers.
⁵ http://bit.ly/1WAewd6
⁶ The table was arranged in February 2016. STM32 MCUs evolve almost day-by-day, so some things may be changed when you read this
chapter (for example, I suspect that ST is going to release an STM32L1 MCU with at least one low-power timer soon).
⁷ And eventually send me an email so that I can correct the table in next releases of the book :-)
Timers 311
Table 3: Which timers are implemented in each STM32 MCU equipping sixteen Nucleo boards
11.2 Basic Timers
Basic timers TIM6, TIM7 and TIM18⁸ are the most simple timers available in the STM32 portfolio.
Even if they are not provided by all STM32 MCUs, it is important to underline that STM32 timers
are designed so that more advanced timers implement the same features (in the same way) of less
powerful ones, as shown inFigure 1. This means that it is perfectly possible to use ageneral purpose
timer in the same way of a basic timer. The CubeHAL also reflects this hardware implementation:
the base operations on all timers are performed by using the HAL_TIM_Base_XXX functions.
⁸ The TIM18 basic timer is only available in STM32F37x microcontrollers.
Timers 312
A single timer is referenced by using an instance of the C struct TIM_HandleTypeDef , which is
defined in the following way:
typedef struct {
TIM_TypeDef *Instance; /* Pointer to timer descriptor */
TIM_Base_InitTypeDef Init; /* TIM Time Base required parameters */
HAL_TIM_ActiveChannel Channel; /* Active channel */
DMA_HandleTypeDef *hdma[7]; /* DMA Handlers array */
HAL_LockTypeDef Lock; /* Locking object */
__IO HAL_TIM_StateTypeDef State; /* TIM operation state */
} TIM_HandleTypeDef;
Figure 1: The relation between the three major categories of timers
Let us see more in depth the most important fields of this struct.
• Instance : is the pointer to the TIM descriptor we are going to use. For example, TIM6 is one
of the basic timers available in the majority of STM32 microcontrollers.
• Init : is an instance of the C struct TIM_Base_InitTypeDef , which is used to configure the
base timer functionalities. We will study it more in depth in a while.
• Channel : it indicates the number of active channels in timers that provide one or more
input/output channels (this is not the case of basic timers). It can assume one or more values
from the enum HAL_TIM_ActiveChannel , and we will study its usage in a next paragraph.
• *hdma[7] : this is an array containing the pointers to DMA_HandleTypeDef descriptors for DMA
requests associated to the timer. As we will see later, a timer can generate up to seven DMA
requests used to drive its features.
• State : this is used internally by the HAL to keep track of the timer state.
All the timer configuration activities are performed by using an instance of the C struct TIM_-
Base_InitTypeDef , which is defined in the following way:
Timers 313
typedef struct {
uint32_t Prescaler; /* Specifies the prescaler value used to divide the TIM clock. */
uint32_t CounterMode; /* Specifies the counter mode. */
uint32_t Period; /* Specifies the period value to be loaded into the active
Auto-Reload Register at the next update event. */
uint32_t ClockDivision; /* Specifies the clock division. */
uint32_t RepetitionCounter; /* Specifies the repetition counter value. */
} TIM_Base_InitTypeDef;
• Prescaler : it divides the timer clock by a factor ranging from 1 up to 65535 (this means that the
prescaler register has a 16-bit resolution). For example, if the bus where the timer is connected
runs at 48MHz, then a prescaler value equal to 48 lowers the counting frequency to 1MHz.
• CounterMode : it defines the counting direction of the timer, and it can assume one of the values
fromTable4.Somecountingmodesareavailableonlyingeneralpurpose andadvanced timers.
For basic timers, only the TIM_COUNTERMODE_UP is defined.
• Period : sets the maximum value for the timer counter before it restarts counting again. This
can assume a value from 0x1 to 0xFFFF (65535) for 16-bit timers, and from 0x1 to 0xFFFF FFFF
for TIM2 and TIM5 timers in those MCUs that implement them as 32-bit timers. If Period is
set to 0x0 the timer does not start.
• ClockDivision : this bit-field indicates the division ratio between the internal timer clock
frequency and sampling clock used by the digital filters on ETRx and TIx pins. It can assume
one value from Table 5, and it is available only in general purpose and advanced timers. We
will study digital filters on input pins of a timer later in this chapter. This field is also used by
the dead time generator (a feature non described in this book).
• RepetitionCounter : every timer has a specific update register that keeps track of the timer
overflow/underflow condition. This can also generate a specific IRQ, as we will see next. The
RepetitionCounter says how many times the timer overflows/underflows before the update
register is set, and the corresponding event is raised (if enabled). RepetitionCounter is only
available in advanced timers.
Table 4: Available counter mode for a timer
Counter Mode Description
TIM_COUNTERMODE_UP The timer counts from zero up to the Period value (which cannot be
higher than the timer resolution - 16/32-bit) and then generates an
overflow event.
TIM_COUNTERMODE_DOWN The timer counts down from the Period value to zero and then
generates an underflow event.
TIM_COUNTERMODE_CENTERALIGNED1 In center-aligned mode, the counter counts from 0 to the Period value
– 1, generates an overflow event, then counts from the Period value
down to 1 and generates a counter underflow event. Then it restarts
counting from 0. The Output compare interrupt flag of channels
configured in output mode is set when the counter counts down.
Timers 314
Table 4: Available counter mode for a timer
Counter Mode Description
TIM_COUNTERMODE_CENTERALIGNED2 Same as TIM_COUNTERMODE_CENTERALIGNED1 , but the Output compare
interrupt flag of channels configured in output mode is set when the
counter counts up.
TIM_COUNTERMODE_CENTERALIGNED3 Same as TIM_COUNTERMODE_CENTERALIGNED1 , but the Output compare
interrupt flag of channels configured in output mode is set when the
counter counts up and down.
Table 5: Available ClockDivision modes for general purpose and advanced timers
Clock division modes Description
TIM_CLOCKDIVISION_DIV1 Computes 1 sample of the input signal on ETRx and TIx
pins
TIM_CLOCKDIVISION_DIV2 Computes 2 sample of the input signal on ETRx and TIx
pins
TIM_CLOCKDIVISION_DIV4 Computes 4 sample of the input signal on ETRx and TIx
pins
11.2.1 Using Timers in Interrupt Mode
Before seeing a complete example, it is best to summarize what we have seen so far. A basic timer:
• is a free-running counter, which counts from 0 up to the value specified in the Period ⁹ field in
the TIM_Base_InitTypeDef initialization structure, which can assume the maximum value of
0xFFFF ( 0xFFFF FFFF for 32-bit timers);
• thecountingfrequencydependsonthespeedofthebuswherethetimerisconnected,anditcan
be lowered up to 65536 times by setting the Prescaler register in the initialization structure;
• when the timer reaches the Period value, it overflows and the Update Event (UEV) flag is set¹⁰;
the timer automatically restarts counting again from the initial value (which is always zero for
basic timers)¹¹.
The Period and Prescaler registers determine the timer frequency, that is how long does it takes to
overflow (or, if you prefer, how often an Update Event is generated), according this simply formula:
⁹ The Period is used to fill the Auto-reload register (ARR) of the timer. I do not know why ST engineers have decided to name it in this
way, since ARR is the register name used in all ST datasheets. This can lead to a lot of confusion, especially when you are new to the CubeHAL,
but unfortunately there is nothing we can do.
¹⁰ The Update Event (UEV) is latched to the prescaler clock, and it is automatically cleared on the next clock edge. Don’t confuse the UEV
with the Update Interrupt Flag (UIF), which must be cleared manually like every other IRQ. UIF is set only when the corresponding interrupt
is enabled. As we will discover in Chapter 19, the UEV event, like all event flags set for other peripherals, allows to wake up the MCU when it
entered a low-power mode using the WFE instruction.
¹¹ This is an important distinction with other microcontroller architectures (especially 8-bit ones) where timers need to be “rearmed”
manually before they can start counting again.
Timers 315
UpdateEvent =
Timer clock
(Prescaler + 1)(Period + 1)
[1]
For example, assume a timer connected to the APB1 bus in an STM32F030 MCU, with the HCLK set
to 48MHz, a Prescaler value equal to 47999 and a Period value equal to 499. We have that timer
will overflow at every:
UpdateEvent =
48.000.000
(47999 + 1)(499 + 1)
= 2Hz =
1
2 s = 0.5s
The following code, designed to run on a Nucleo-F030R8, shows a complete example using the
TIM6¹². The example is nothing more than the classical blinking LED, but this time we use a basic
timer to compute delays.
Filename: src/main-ex1.c
7 TIM_HandleTypeDef htim6;
8
9 int main(void) {
10 HAL_Init();
11
12 Nucleo_BSP_Init();
13
14 htim6.Instance = TIM6;
15 htim6.Init.Prescaler = 47999; //48MHz/48000 = 1000Hz
16 htim6.Init.Period = 499; //1000HZ / 500 = 2Hz = 0.5s
17
18 __HAL_RCC_TIM6_CLK_ENABLE(); //Enable the TIM6 peripheral
19
20 HAL_NVIC_SetPriority(TIM6_IRQn, 0, 0); //Enable the peripheral IRQ
21 HAL_NVIC_EnableIRQ(TIM6_IRQn);
22
23 HAL_TIM_Base_Init(&htim6); //Configure the timer
24 HAL_TIM_Base_Start_IT(&htim6); //Start the timer
25
26 while (1);
27 }
28
29 void TIM6_IRQHandler(void) {
30 // Pass the control to HAL, which processes the IRQ
31 HAL_TIM_IRQHandler(&htim6);
32 }
33
34 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
35 // This callback is automatically called by the HAL on the UEV event
¹² Owners of the Nucleo boards equipping F411, F401 and F103 STM32 MCUs will find a slight different example using a general purpose
timer. However, concepts remain the same.
Timers 316
36 if(htim->Instance == TIM6)
37 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
38 }
Lines [15:17] configure TIM6 using the Prescaler and Period values computed before. The timer
peripheralisthenenabledbyusingthemacroatline19.ThesameappliestoitsIRQ.Thetimeristhen
configured at line 24 and started in interrupt mode using the HAL_TIM_Base_Start_IT() function¹³.
The rest of the code is really similar to what seen until now.
The TIM6_IRQHandler() ISR fires when the timer overflows, and the HAL_TIM_IRQHandler() is then
called. The HAL will automatically handle for us all the necessary operations to properly manage
the update event, and it will call the HAL_TIM_PeriodElapsedCallback() routine to signal us that the
timer has been overflowed.
The Performance of the HAL_TIM_IRQHandler() Routine
For timers running really fast, the HAL_TIM_IRQHandler() has a non-negligible overhead.
That function is designed to check up to nine different interrupt status flags, which requires
severalARMassemblyinstructionstocarryoutthetask.Ifyouneedtoprocesstheinterrupts
inlesstime,probablyitisbesttohandletheIRQbyyourself.Onceagain,theHALisdesigned
to abstract a lot of details to the user, but it introduces performance penalties that every
embedded developer should know.
How to Choose the Values for Prescaler and Period Fields?
First of all, note that not all combinations of Prescaler and Period values lead to integer
division of the timer clock frequency. For example, for a timer running at 48MHz, a Period
equal to 65535 lowers the timer frequency to 732,4218 Hz. This author is used to divide the
main frequency of the timer setting an integer divider for the Prescaler value (e.g. 47999
for a 48MHz timer - remember that, according equation [1], the frequency is computed by
adding 1 to both the Prescaler and Period values), and then playing with the Period value
to achieve the wanted frequency. MikroElektronica provides a nice tool¹⁴ to automatically
computethatvalues,givenaspecificSTM32MCUsandtheHCLK frequency.Unfortunately,
the code it generates does not cover the CubeHAL at the time of writing this chapter.
11.2.1.1 Time Base Generation in Advanced Timers
So far we have seen that all base functionalities of a timer are configured through an instance of the
TIM_Base_InitTypeDef struct . This struct contains a field named RepetitionCounter used to fur-
therincreasetheperiodbetweentwoconsecutiveupdateevents:thetimerwillcountagivennumber
¹³ A really common mistake made by novices is to forget to start a timer, by using one of the HAL_TIM_xxx_Start function provided by the
CubeHAL.
¹⁴ http://www.mikroe.com/timer-calculator/
Timers 317
of times before setting the event and raising the corresponding interrupt. RepetitionCounter is only
available in advanced timers, and this causes that the formula to compute the frequency of update
events becomes:
UpdateEvent =
Timer clock
(Prescaler + 1)(Period + 1)(RepetitionCounter + 1)
Leavingthe RepetitionCounter equaltozero(defaultbehaviour),weobtainthesameworkingmode
of a basic timer.
11.2.2 Using Timers in Polling Mode
The CubeHAL provides three ways to use timers: polling, interrupt and DMA mode. For this reason,
the HAL provides three distinct functions to start a timer: HAL_TIM_Base_Start() , HAL_TIM_Base_-
Start_IT() and HAL_TIM_Base_Start_DMA() . The idea behind the polling mode is that the timer
counter register ( TIMx->CNT ) is accessed continuously to check for a given value. But care must be
taken when polling a timer. For example, it is quite common to find around in the web code like the
following one:
...
while (1) {
if(__HAL_TIM_GET_COUNTER(&tim) == value)
...
That way to poll for a timer is completely wrong, even if it apparently works in some examples.
Why?
Timers run independently from the Cortex-M core. A timer can count really fast, up to the same
clock frequency of the CPU core. But checking a timer counter for equality (that is, to check if it
is equal to a given value) requires several ARM assembly instructions, which in turn need several
clock cycles. There is no guarantee that the CPU accesses to the counter register exactly at the same
time it reaches the configured value (this happens only if the timer runs really slow). A better way
is to check if the timer current counter value is equal or greater than the given value, or to check
against the UIF flag status¹⁵: in the worst case we can have a shift in time measuring, but we will not
lose the event at all (unless the timer runs really fast and we lose the subsequent events because the
interrupt is masked - that is, UIF flag it still set before it is cleared manually by us or automatically
by the HAL).
¹⁵ However this requires that the timer is enabled in interrupt mode, using the HAL_TIM_Base_Start_IT() function.
Timers 318
...
while (1) {
if(__HAL_TIM_GET_FLAG(&tim) == TIM_FLAG_UPDATE) {
//Clear the IRQ flag otherwise we lose other events
__HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
...
However, timers are asynchronous peripherals, and the correct way to manage the overflow/under-
flow event is by using interrupts. There is no reason to not use a timer in interrupt mode, unless
the timer runs really fast and generating an interrupt after few microseconds (or even nanoseconds)
would completely flood the MCU preventing it from processing other instructions¹⁶.
11.2.3 Using Timers in DMA Mode
Timers are often programmed to work in DMA mode, especially when they are not used as timebase
generators. This mode guarantees that the operations performed by the timer are deterministic and
with the smallest possible latency, especially if they run really fast. Moreover, the Cortex-M core
is freed from the timer management, which usually involves the handling of really frequent ISRs
that could congest the CPU. Finally, in some advanced modes, like the output PWM one, it is almost
impossible to reach given switching frequencies without using the timer in DMA Mode.
For these reasons, timers offer up to seven DMA requests, which are listed in Table 6. Basic timers
implement only the TIM_DMA_UPDATE request, since they do not have input/output I/Os. However,
it is really useful to take advantage of the TIMx_UP request in those situation where we want to
perform DMA transfers on a time-basis.
Table 6: DMA requests (the most of them are available only in general purpose and advanced timers
Timer DMA request Description
TIM_DMA_UPDATE Update request (it is generated on the UEV event)
TIM_DMA_CC1 Capture/Compare 1 DMA request
TIM_DMA_CC2 Capture/Compare 2 DMA request
TIM_DMA_CC3 Capture/Compare 3 DMA request
TIM_DMA_CC4 Capture/Compare 4 DMA request
TIM_DMA_COM Commutation request
TIM_DMA_TRIGGER Trigger request
The following example is another variation of the blinking LED application, but this time we use a
timerinDMAmodetoturntheLEDON/OFF.HerewearegoingtousetheTIM6timerprogrammed
to overflow every 500ms: when this happens, the timer generates the TIM6_UP request (which in
¹⁶ Remember that even if the exception handling in a Cortex-M MCU has a deterministic latency (Cortex-M3/4/7 cores serve an interrupt
in 12 CPU cycles, while Cortex-M0 does it in 15 cycles and Cortex-M0+ in 16 cycles) it has a non-negligible cost, which requires several
nanoseconds in “low-speed” MCUs (for example, for an STM32F030 MCU running at 48MHz, an interrupt is serviced in about 300ns). This cost
has to be added to the overhead introduced by the HAL during the interrupt management, as seen before.
Timers 319
an STM32F030 MCU is bound to the third channel of DMA1) and the next element of a buffer is
transferred to the GPIOA->ODR register in DMA circular mode, which causes that the LD2 blinks
indefinitely.
Read Carefully
In STM32F2/F4/F7/L1/L4 families, only the DMA2 has full access to the Bus Matrix. This
means that only timers whose requests are bound to this DMA controller can be used to
perform transfers involving other peripheral (except for the internal and external volatile
memories). For this reasons, this example for Nucleo boards based on F2/F4/L1/L4 MCUs
use TIM1 as base generator.
In STM32F103R8, STM32F302RB and STM32F334R8, STM32L053R8 and STM32L073RZ
MCUs TIMx_UP request does not allow to trigger transfer between memory and GPIO
peripheral. So this example is not available for the corresponding Nucleo boards.
Filename: src/main-ex2.c
13 int main(void) {
14 uint8_t data[] = {0xFF, 0x0};
15
16 HAL_Init();
17 Nucleo_BSP_Init();
18 MX_DMA_Init();
19
20 htim6.Instance = TIM6;
21 htim6.Init.Prescaler = 47999; //48MHz/48000 = 1000Hz
22 htim6.Init.Period = 499; //1000HZ / 500 = 2Hz = 0.5s
23 htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
24 __HAL_RCC_TIM6_CLK_ENABLE();
25
26 HAL_TIM_Base_Init(&htim6);
27 HAL_TIM_Base_Start(&htim6);
28
29 hdma_tim6_up.Instance = DMA1_Channel3;
30 hdma_tim6_up.Init.Direction = DMA_MEMORY_TO_PERIPH;
31 hdma_tim6_up.Init.PeriphInc = DMA_PINC_DISABLE;
32 hdma_tim6_up.Init.MemInc = DMA_MINC_ENABLE;
33 hdma_tim6_up.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
34 hdma_tim6_up.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
35 hdma_tim6_up.Init.Mode = DMA_CIRCULAR;
36 hdma_tim6_up.Init.Priority = DMA_PRIORITY_LOW;
37 HAL_DMA_Init(&hdma_tim6_up);
38
39 HAL_DMA_Start(&hdma_tim6_up, (uint32_t)data, (uint32_t)&GPIOA->ODR, 2);
40 __HAL_TIM_ENABLE_DMA(&htim6, TIM_DMA_UPDATE);
41
42 while (1);
43 }
Timers 320
Lines [29:37] configure the DMA_HandleTypeDef for the DMA1_Channel3 in circular mode. Then line
39 starts the DMA transfer so that the content of the data buffer is transferred inside the GPIOA->ODR
register every time a TIM6_UP request is generated, that is the timer overflows. This causes that the
LD2LEDblinks.Takenotethatwearenotusingthe HAL_TIM_Base_Start_DMA() functionhere.Why
not?
Looking to the implementation of the HAL_TIM_Base_Start_DMA() routine, you can see that ST
engineers have defined it so that the DMA transfer is performed from the memory buffer to the
TIM6->ARR , which corresponds to the Period .
HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length) {
...
/* Enable the DMA channel */
HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->\
ARR, Length);
/* Enable the TIM Update DMA request */
__HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
...
Basically, we can use the HAL_TIM_Base_Start_DMA() only to change the timer Period every time it
overflows. So we need to configure the DMA by ourself in order to perform this transfer.
11.2.4 Stopping a Timer
The CubeHAL provides three functions to stop a running timer: HAL_TIM_Base_Stop() , HAL_TIM_-
Base_Stop_IT() and HAL_TIM_Base_Stop_DMA() . We pick one of these depending on the timer mode
we are using (for example, if we have started a timer ininterrupt mode, then we need to stop it using
the HAL_TIM_Base_Stop_IT() routine). Each function is designed to properly disable IRQs and DMA
configurations.
11.2.5 Using CubeMX to Configure a Basic Timer
CubeMX can reduce to the minimum the effort needed to configure a basic timer. Once the timer
is enabled in the Pinout view by checking the flag Activated, it can be configured from the
Configuration view. The timer configuration view allows to setup the values for the Prescaler
and Period registers, as shown in Figure 2. CubeMX will generate all the necessary initialization
code inside the MX_TIMx_Init() function. Moreover, always in the same configuration dialog, it is
possible to enable timer-related IRQs and DMA requests.
Timers 321
Figure 2: CubeMX allows to easily generate the necessary code to configure a timer
11.3 General Purpose Timers
The majority of STM32 timers are general purpose ones. Different from the basic timers seen before,
they offer much more interaction capabilities, thanks to up to four independent channels that can be
used to measure input signals, to output signals on a time basis, to generatePulse-Width Modulation
(PWM) signals. General purpose timers, however, offer much more functionalities that we will
discover progressively in this part of the chapter.
11.3.1 Time Base Generator With External Clock Sources
The Figure 3 shows the block diagram of a general purpose timer¹⁷. Some parts of the diagram have
been masked: we will study them more in depth later. The path highlighted in red is used to feed
the timer when the APB clock is selected as source: the internal clock CK_INT feeds the Prescaler
(PSC), which in turn determines how fast the Counter Register (CNT) is increased/decreased. This
one is compared with the content of the auto-reload register (which is filled with the value of
the TIM_Base_InitTypeDef.Period field). When they match, the UEV event is generated, and the
corresponding IRQ is fired, if enabled.
¹⁷ The figure is arranged from the one found in the RM0368(http://bit.ly/1Kq3SoE) reference manual from ST.
Timers 322
Figure 3: The structure of a general purpose timer
Looking at Figure 3, we can see that a timer can receive “stimuluses” from other sources. These can
be divided in two main groups:
• Clock sources, which are used to clock the timer. They can come from external sources
connected to the MCU pins or from other timers connected internally to the MCU. Keep in
mind that a timer cannot work without a clock source, because this is used to increment the
counter register.
• Trigger sources, which are used to synchronize the timer with external sources connected to
theMCUpinsorwithothertimersconnectedinternally.Forexample,atimercanbeconfigured
to start counting when an external event triggers it. In this case the timer is clocked by another
clock source (which can be both the APBx bus or an external clock source connected to the
ETR2 pin), and it is controlled (that is, when it starts counting, etc.) by another device.
Depending on the timer type and its actual implementation, a timer can be clocked from:
• The internal TIMx_CLK provided by the RCC (shown in paragraph 11.2)
Timers 323
• Internal trigger input 0 to 3
– ITR0, ITR1, ITR2 and ITR3 using another timer (master) as prescaler of this timer (slave)
(shown in paragraph 11.3.1.2)
• External input channel pins (shown in paragraph 11.3.1.2)
– Pin 1: TI1FP1 or TI1F_ED
– Pin 2: TI2FP2
• External ETR pins:
– ETR1 pin (shown in paragraph 11.3.1.2)
– ETR2 pin (shown in paragraph 11.3.1.1)
A timer can, instead, be triggered from:
• Internal trigger inputs 0 to 3
– ITR0, ITR1, ITR2 and ITR3 using another timer as master (shown in paragraph 11.3.2)
• External input channel pins (shown in paragraph 11.3.2)
– Pin 1: TI1FP1 or TI1F_ED
– Pin 2: TI2FP2
• External ETR1 pin
Let us study these ways to clock/trigger a timer from an external source by analyzing practical
examples.
11.3.1.1 External Clock Mode 2
General purpose timers have the ability to be clocked from external sources, setting them in two
distinct modes: External Clock Source Mode 1 and 2. The fist one is available when the timer is
configured in slave mode. We will study this mode in the next paragraph.
The second mode is, instead, activated simply by using an external clock source. This allows to use
more accurate and dedicated sources, and to eventually further reduce the counting frequency. In
fact, when the External Clock Source Mode 2 is selected, the formula to compute the frequency of
update events becomes:
UpdateEvent =
EXT clock
(EXT clock Prescaler)(Prescaler + 1)(Period + 1)(RepetitionCounter + 1)
[2]
where EXT clock is the frequency of the external source and EXT clock Prescaler is a source frequency
divider that can assume the values 1, 2, 4 and 8.
The clock source of a general purpose timer can be selected by using the function HAL_TIM_Con-
figClockSource() and an instance of the struct TIM_ClockConfigTypeDef , which is defined in the
following way:
Timers 324
typedef struct {
uint32_t ClockSource; /* TIM clock sources */
uint32_t ClockPolarity; /* TIM clock polarity */
uint32_t ClockPrescaler; /* TIM clock prescaler */
uint32_t ClockFilter; /* TIM clock filter */
} TIM_ClockConfigTypeDef;
• ClockSource : specifies the source of the clock signal used to bias the timer. It can assume a
value from the Table 7. By default, the TIM_CLOCKSOURCE_INTERNAL mode is selected.
• ClockPolarity : indicates the polarity of the clock signal used to bias the timer. It can assume
a value from the Table 8. By default, the TIM_CLOCKPOLARITY_RISING mode is selected.
• ClockPrescaler : specifies the prescaler for the external clock source. It can assume a value
from the Table 9. By default, the TIM_CLOCKPRESCALER_DIV1 value is selected.
• ClockFilter : this 4-bit field defines the frequency used to sample the external clock signal
and the length of the digital filter applied to it. The digital filter is made of an event counter
in which N consecutive events are needed to validate a transition on the output. Refer to the
datasheet of your MCU about how the f DTS (Dead-Time Signal) is computed. By default, the
filter is disabled.
Table 7: Available clock source modes for general purpose and advanced timers
Clock source mode Description
TIM_CLOCKSOURCE_INTERNAL The timer is clocked by the APBx bus where the timer is connected to
TIM_CLOCKSOURCE_ETRMODE1 This mode is called External Clock Mode 1¹⁸ and it is available when the
timer is configured in slave mode. The timer can be clocked by an
internal/external source connected to ITR0, ITR1, ITR2, ITR3, TI1FP1,
TI2FP2 or ETR1 pin.
TIM_CLOCKSOURCE_ETRMODE2 This mode is called External Clock Mode 2. The timer can be clocked by an
external source connected to ETR2 pin.
Table 8: Available external clock polarity modes for general purpose and advanced timers
External clock polarity mode Description
TIM_CLOCKPOLARITY_RISING The timer is synchronized on the rising edge of the external clock source
TIM_CLOCKPOLARITY_FALLING The timer is synchronized on the falling edge of the external clock source
TIM_CLOCKPOLARITY_BOTHEDGE The timer is synchronized on rising and falling edges of the external
clock source (this will increase the sampled frequency)
¹⁸ In the ST documentation these modes are also called External Trigger mode 1 and 2 (ETR1 and ETR2).
Timers 325
Table 9: Available external clock prescaler modes for general purpose and advanced timers
External clock prescaler mode Description
TIM_CLOCKPRESCALER_DIV1 No prescaler used
TIM_CLOCKPRESCALER_DIV2 Capture performed once every 2 events
TIM_CLOCKPRESCALER_DIV4 Capture performed once every 4 events
TIM_CLOCKPRESCALER_DIV8 Capture performed once every 8 events
Let us build an example that shows how to use an external clock source for the TIM3 timer. The
example consists in routing the Master Clock Output (MCO) pin to the TIM3_ETR2 pin, which
corresponds to PD2 pin for all Nucleo boards providing this timer. This can easily done by using
the Morpho connectors, as shown in Figure 4 for the Nucleo-F030R8 (for your Nucleo, use CubeMX
tool to identify the MCO pin and the corresponding pinout diagram from Appendix C).
Figure 4: How to route the MCO pin to the TIM3_ETR pin in a Nucleo-F030R8 board
The MCO pin is enabled and connected to the LSE clock source, which runs at 32.768kHz¹⁹. The
following code shows the most relevant parts of the example.
¹⁹ Unfortunately, early releases of the Nucleo boards do not provide an external low speed clock source. If this is your case, rearrange the
examples so that the LSI oscillator is used. Moreover, it is not possible to route either LSI nor LSE to the MCO pin in an STM32F103R8 MCU.
For this reason, this example on the Nucleo-F103R8 uses the HSI as MCO source.
Timers 326
Filename: src/main-ex3.c
23 void MX_TIM3_Init(void) {
24 TIM_ClockConfigTypeDef sClockSourceConfig;
25
26 htim3.Instance = TIM3;
27 htim3.Init.Prescaler = 0;
28 htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
29 htim3.Init.Period = 16383;
30 htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
31 htim3.Init.RepetitionCounter = 0;
32 HAL_TIM_Base_Init(&htim3);
33
34 sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_ETRMODE2;
35 sClockSourceConfig.ClockPolarity = TIM_CLOCKPOLARITY_NONINVERTED;
36 sClockSourceConfig.ClockPrescaler = TIM_CLOCKPRESCALER_DIV1;
37 sClockSourceConfig.ClockFilter = 0;
38 HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);
39
40 HAL_NVIC_SetPriority(TIM3_IRQn, 0, 0);
41 HAL_NVIC_EnableIRQ(TIM3_IRQn);
42 }
43
44 void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base) {
45 GPIO_InitTypeDef GPIO_InitStruct;
46 if(htim_base->Instance==TIM3) {
47 /* Peripheral clock enable */
48 __HAL_RCC_TIM3_CLK_ENABLE();
49 __HAL_RCC_GPIOD_CLK_ENABLE();
50
51 /**TIM3 GPIO Configuration
52 PD2 ------> TIM3_ETR
53 */
54 GPIO_InitStruct.Pin = GPIO_PIN_2;
55 GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
56 GPIO_InitStruct.Pull = GPIO_NOPULL;
57 GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
58 HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
59 }
60 }
Lines [27:33] configure the TIM3 timer, setting its period to 19999. Lines [34:38] configure the
external clock source for TIM3. Since the LSE oscillator runs at 32.768kHz, using the equation [2]
we can compute the UEV frequency, which is equal to:
UpdateEvent =
32.768
(1)(0 + 1)(16383 + 1)(0 + 1)
= 2Hz = 0.5s
Timers 327
Finally, lines [48:58] enable the TIM3 and configure the PD2 pin (which corresponds to the TIM3_-
ETR2 pin) as input source.
Read Carefully
It is important to underline that the GPIO port D must be enabled, before we can use it as
clock source for TIM3, by using the __GPIOD_CLK_ENABLE() macro. The same applies even
to TIM3, which is enabled by using the __TIM3_CLK_ENABLE() : this is required because the
external clocks are not directly feeding the prescaler, but they are first synchronized
with the APBx clock through dedicated logical blocks.
11.3.1.2 External Clock Mode 1
STM32 general purpose and advanced timers can be configured to work in master or slave mode²⁰.
When configured to act as a slave, a timer can be fed by internal ITR0, ITR1, ITR2 and ITR3 lines,
an external clock connected to the ETR1 pin or from other clock sources connected to TI1FP1 and
TI2FP2 sources, which correspond to Channel 1 and 2 input pins. This working mode is called
External Clock Mode 1.
The External Clock Mode 1 and 2 are rather confusing for all novices of the STM32 platform.
Both modes are a way to clock a timer using an external clock source, but the first one is
achieved by configuring the timer in slave mode (it is indeed a form of “triggering”), while
the second one is obtained by simply selecting a different clock source. I do not know the
origin of this nomenclature, and what are the practical effects of this distinction. However,
it is important to remark here that the ways to configure a timer in ETR1 or ETR2 mode are
completely different, as we will see in the next example.
Looking to Figure 16 we can see that the TI1FP1 and TI2FP2 inputs are nothing more than
the TI1 and TI2 input channels of a timer after the input filter has been applied.
To configure a timer in slave mode we use the function HAL_TIM_SlaveConfigSynchronization()
and an instance of the struct TIM_SlaveConfigTypeDef , which is defined in the following way:
²⁰ As we will see next, a timer can be configured to work in master and slave mode at the same time.
Timers 328
typedef struct {
uint32_t SlaveMode; /* Slave mode selection */
uint32_t InputTrigger; /* Input Trigger source */
uint32_t TriggerPolarity; /* Input Trigger polarity */
uint32_t TriggerPrescaler; /* Input trigger prescaler */
uint32_t TriggerFilter; /* Input trigger filter */
} TIM_SlaveConfigTypeDef;
• SlaveMode : when a timer is configured in slave mode, it can be clocked/triggered by several
sources. This field can assume a value from Table 10. This paragraph is about the TIM_SLAVE-
MODE_EXTERNAL1 mode.
• InputTrigger : defines the source that triggers/clocks the timer configured inslave mode.It can
assume a value from Table 11
• TriggerPolarity : indicates the polarity of the trigger/clock source. It can assume a value from
the Table 12.
• TriggerPrescaler : specifies the prescaler for the external clock source. It can assume a value
from the Table 13. By default, the TIM_TRIGGERPRESCALER_DIV1 value is selected.
• TriggerFilter : this 4-bit field defines the frequency used to sample the external clock/trigger
signal connected to input pin and the length of the digital filter applied to it. The digital filter
is made of an event counter in which N consecutive events are needed to validate a transition
on the output. Refer to the datasheet of your MCU about how the f DTS (Dead-Time Signal) is
computed. By default, the filter is disabled.
Table 10: Available slave modes for general purpose and advanced timers
Slave modes Working Description
TIM_SLAVEMODE_DISABLE Disabled The slave mode is disabled (default value)
TIM_SLAVEMODE_RESET Trigger Rising edge of the selected trigger input
(TRGI) reinitializes the counter and generates
an update of the registers
TIM_SLAVEMODE_GATED Trigger The counter clock is enabled when the trigger
input (TRGI) is high. The counter stops (but is
not reset) as soon as the trigger becomes low.
Both start and stop of the counter are
controlled
TIM_SLAVEMODE_TRIGGER Trigger The counter starts at a rising edge of TRGI
(but it is not reset). Only the start of the
counter is controlled
TIM_SLAVEMODE_EXTERNAL1 Clock Rising edges of the selected TRGI clock the
counter
TIM_SLAVEMODE_COMBINED_RESETTRIGGER ²¹ Trigger Rising edge of the selected trigger input
(TRGI) reinitializes the counter, generates an
update of the registers and starts the counter
²¹ This mode is available only in some STM32F3 MCUs.
Timers 329
Table 11: Available trigger/clock sources for a timer working in slave mode
Trigger/clock source Description
TIM_TS_ITR0 Trigger/clock source is the ITR0 line (which is internally connected to a master
timer)
TIM_TS_ITR1 Trigger/clock source is the ITR1 line (which is internally connected to a master
timer)
TIM_TS_ITR2 Trigger/clock source is the ITR2 line (which is internally connected to a master
timer)
TIM_TS_ITR3 Trigger/clock source is the ITR3 line (which is internally connected to a master
timer)
TIM_TS_TI1F_ED Trigger/clock source is the TIM_TS_TI1F_ED line
TIM_TS_TI1FP1 Trigger/clock source is the TIM_TS_TI1FP1 line that corresponds to the Channel 1
TIM_TS_TI2FP2 Trigger/clock source is the TIM_TS_TI2FP2 line that corresponds to the Channel 2
TIM_TS_ETRF Trigger/clock source is the ETR1 pin
TIM_TS_NONE No external clock/trigger source
Table 12: Available trigger/clock polarity modes for a timer working in slave mode
Trigger/clock polarity mode Description
TIM_TRIGGERPOLARITY_INVERTED This is used when the external clock source is ETR1. ETR1 is
noninverted, active at high level or rising edge
TIM_TRIGGERPOLARITY_NONINVERTED This is used when the external clock source is ETR1. ETR1 is
inverted, active at low level or falling edge
TIM_TRIGGERPOLARITY_RISING Polarity for TIxFPx or TI1_ED trigger sources. The timer is
synchronized on the rising edge of the external trigger source
TIM_TRIGGERPOLARITY_FALLING Polarity for TIxFPx or TI1_ED trigger sources. The timer is
synchronized on the falling edge of the external trigger source
TIM_TRIGGERPOLARITY_BOTHEDGE Polarity for TIxFPx or TI1_ED trigger sources. The timer is
synchronized on rising and falling edges of the external trigger
source (this will increase the sampled frequency)
Table 13: Available trigger/clock prescaler modes for a timer working in slave mode
External clock prescaler mode Description
TIM_TRIGGERPRESCALER_DIV1 No prescaler used
TIM_TRIGGERPRESCALER_DIV2 Capture performed once every 2 events
TIM_TRIGGERPRESCALER_DIV4 Capture performed once every 4 events
TIM_TRIGGERPRESCALER_DIV8 Capture performed once every 8 events
When the External Clock Source Mode 1 is selected, the formula to compute the frequency of update
events becomes:
Timers 330
UpdateEvent =
TRGI clock
(Prescaler + 1)(Period + 1)(RepetitionCounter + 1)
[3]
where TRGI clock is the frequency of the clock source connected to the ETR1 pin, the frequency of
the internal/external trigger clock source connected to internal lines ITR0..ITR3 or the frequency of
signal connected to external channels TI1FP1..T2FP2.
So, let us recap what seen until now:
• a timer can be clocked by an external source when working only in master mode²² by
connecting this source to the ETR2 pin;
• if the timer is working in slave mode, then it can be clocked by a signal connected to the ETR1
pin, by any trigger source connected to the internal lines ITR0…ITR2 (hence, the clock source
can be only another timer) or by an input signal connected to the timer channels TI1 and TI2,
which becomes TI1FP1 and TI2FP2 if the input filtering stage is activated.
Let us build another example that shows how to use an external clock source for the TIM3 timer.
The example consists in routing the Master Clock Output (MCO) pin to the TI2FP2 pin (that is, the
second channel of TIM3 timer), which in a Nucleo-F030R8 corresponds to PA7 pin. This can easily
done by using the Morpho connectors, as shown in Figure 5 (for your Nucleo, use CubeMX tool to
identify both MCO and TI2FP2 pins).
Figure 5: How to route the MCO pin to the TI2FP2 pin in a Nucleo-F030R8 board
The MCO pin is enabled and connected to the LSE clock source, as seen in the previous example.
The following code shows the most relevant parts of the example.
²² As we will discover later, the master/slave mode of a timer is not exclusively: a timer can be configured to work as a master and slave at
the same time.
Timers 331
Filename: src/main-ex4.c
24 void MX_TIM3_Init(void) {
25 TIM_SlaveConfigTypeDef sSlaveConfig;
26
27 htim3.Instance = TIM3;
28 htim3.Init.Prescaler = 0;
29 htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
30 htim3.Init.Period = 16383;
31 htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
32 HAL_TIM_Base_Init(&htim3);
33
34 sSlaveConfig.SlaveMode = TIM_SLAVEMODE_EXTERNAL1;
35 sSlaveConfig.InputTrigger = TIM_TS_TI2FP2;
36 sSlaveConfig.TriggerPolarity = TIM_TRIGGERPOLARITY_RISING;
37 sSlaveConfig.TriggerFilter = 0;
38 HAL_TIM_SlaveConfigSynchronization(&htim3, &sSlaveConfig);
39
40 HAL_NVIC_SetPriority(TIM3_IRQn, 0, 0);
41 HAL_NVIC_EnableIRQ(TIM3_IRQn);
42 }
43
44 void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base) {
45 GPIO_InitTypeDef GPIO_InitStruct;
46 if(htim_base->Instance==TIM3) {
47 /* Peripheral clock enable */
48 __HAL_RCC_TIM3_CLK_ENABLE();
49 __HAL_RCC_GPIOA_CLK_ENABLE();
50
51 /**TIM3 GPIO Configuration
52 PA7 ------> TIM3_CH2
53 */
54 GPIO_InitStruct.Pin = GPIO_PIN_7;
55 GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
56 GPIO_InitStruct.Pull = GPIO_NOPULL;
57 GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
58 GPIO_InitStruct.Alternate = GPIO_AF1_TIM3;
59 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
60 }
Lines [34:38] configure TIM3 in slave mode. The input trigger source is set to TI2FP2, and the timer
is synchronized to the rising edge of the input signal. Finally, lines [54:59] configure the PA7 as input
pin for the second channel of TIM3.
11.3.1.3 Using CubeMX to Configure the Source Clock of a General Purpose Timer
Configuringtheclocksourceofageneralpurpose timercanbeanightmare,especiallyfornovicesof
theSTM32platform.CubeMXcansimplifythisprocess,evenifagoodunderstandingofmaster/slave
Timers 332
modes and ETR1 and ETR2 modes is required.
To configure the timer in External Clock Mode 2 it is sufficient to select ETR2 as clock source from
the Pinout view, as shown in Figure 6.
Figure 6: How to select the ETR2 mode from the IP pane
Once the clock source is selected, it is possible to set the external clock filter, polarity and prescaler
from the timer configuration dialog, as shown in Figure 7.
Figure 7: How to configure a timer working in ETR2 mode
To configure the timer in External Clock Mode 1, we have to select this mode from the Slave entry
and then select the Trigger Source (which in this case is the clock source for the timer), as shown
in Figure 8.
Timers 333
Figure 8: How to select the ETR1 mode from the IP tree pane
Once the clock source is selected, it is possible to set the other configuration parameters from the
timer configuration dialog (not shown here).
11.3.2 Master/Slave Synchronization Modes
Once a timer operates in master mode it can feed another timer configured in slave mode through
a dedicated output line, called Trigger Output (TRGO)²³, connected to the internal dedicated lines
called ITR0, ITR1, ITR2 and ITR3. The master timer can both provide the clock source (and hence
act as a first order prescaler - this is what we have studied in the previous paragraph) or trigger the
slave timer.
These Internal Trigger (ITR) lines (ITR0, ITR1, ITR2 and ITR3) are precisely internal to the chip, and
each line is hardwired between two defined timers. For example, in an STM32F030 MCU the TIM1
TRGO line is connected to the ITR0 line of TIM2 timer, as shown in Figure 9.
Figure 9: The TIM1 can fed the TIM2 timer through the ITR0 line
A timer configured as slave can also simultaneously act as master for another timer, allowing to
create complex networks of timers. For example, the Figure 10 shows how timers can be connected
in cascade, while Figure 11 shows how timers can form hierarchical structures using combinations
of master/slave modes. Note that TIM1, TIM2 and TIM3 are internally interconnected through the
sameITR0line.Thisallowstosynchronizeseveraltimersuponthesameevent(reset,enable,update,
etc.).
²³ Some STM32 microcontrollers, notably STM32F3 ones, provide two independent trigger lines, named TRGO1 and TRGO2. This case is
not shown in this book.
Timers 334
Figure 10: The combination of master/slave modes allows to configure timers in cascade
Figure 11: The combination of master/slave modes allows to configure timers in a hierarchical structure
To configure a timer in master mode we use the function HAL_TIMEx_MasterConfigSynchroniza-
tion() and an instance of the struct TIM_MasterConfigTypeDef , which is defined in the following
way:
typedef struct {
uint32_t MasterOutputTrigger; /* Trigger output (TRGO) selection */
uint32_t MasterSlaveMode; /* Master/slave mode selection */
} TIM_MasterConfigTypeDef;
• MasterOutputTrigger : specifies the behaviour of the TRGO output and it can assume a value
from Table 14.
• MasterSlaveMode : it is used to enable/disable the master/slave mode of a timer. It can assume
the values TIM_MASTERSLAVEMODE_ENABLE or TIM_MASTERSLAVEMODE_DISABLE .
Timers 335
Table 14: Available trigger/clock sources for a timer working in slave mode
Timer master mode selection Description
TIM_TRGO_RESET The TRGO signal is generated when the UG bit of the TIMx->EGR
register is set. More about this in paragraph 11.3.3
TIM_TRGO_ENABLE The TRGO signal is generated when master timer is enabled. It is useful
to start several timers at the same time or to control a window in which
a slave timer is enabled
TIM_TRGO_UPDATE The update event is selected as trigger output (TRGO). For instance a
master timer can then be used as a prescaler for a slave timer (we have
studied this mode in paragraph 11.3.1.2)
TIM_TRGO_OC1 The trigger output send a positive pulse as soon as a capture or a
compare match occurred
TIM_TRGO_OC1REF The trigger output send a positive pulse as soon as a capture or a
compare match occurred on Channel 1
TIM_TRGO_OC2REF The trigger output send a positive pulse as soon as a capture or a
compare match occurred on Channel 2
TIM_TRGO_OC3REF The trigger output send a positive pulse as soon as a capture or a
compare match occurred on Channel 3
TIM_TRGO_OC4REF The trigger output send a positive pulse as soon as a capture or a
compare match occurred on Channel 4
Let us see an example that shows how to configure TIM1 and TIM3 in cascade mode, with TIM1 as
master for TIM3 timer. TIM1 is used as clock source for TIM3 through the ITR0 line. Moreover, the
TIM1 is configured so that it starts counting upon an external event on its TI1FP1 line, which in a
Nucleo-F030 corresponds to PA8 pin: TIM1 starts counting when the PA8 pin goes high, and then it
feeds the TIM3 timer through the ITR0 line.
Filename: src/main-ex5.c
12 int main(void) {
13 HAL_Init();
14
15 Nucleo_BSP_Init();
16 MX_TIM1_Init();
17 MX_TIM3_Init();
18
19 HAL_TIM_Base_Start_IT(&htim3);
20
21 while (1);
22 }
23
24 void MX_TIM1_Init(void) {
25 TIM_ClockConfigTypeDef sClockSourceConfig;
26 TIM_MasterConfigTypeDef sMasterConfig;
27 TIM_SlaveConfigTypeDef sSlaveConfig;
28
29 htim1.Instance = TIM1;
Timers 336
30 htim1.Init.Prescaler = 47999;
31 htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
32 htim1.Init.Period = 249;
33 htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
34 htim1.Init.RepetitionCounter = 0;
35 HAL_TIM_Base_Init(&htim1);
36
37 sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
38 HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig);
39
40 sSlaveConfig.SlaveMode = TIM_SLAVEMODE_TRIGGER;
41 sSlaveConfig.InputTrigger = TIM_TS_TI1FP1;
42 sSlaveConfig.TriggerPolarity = TIM_TRIGGERPOLARITY_RISING;
43 sSlaveConfig.TriggerFilter = 15;
44 HAL_TIM_SlaveConfigSynchronization(&htim1, &sSlaveConfig);
45
46 sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
47 sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_ENABLE;
48 HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig);
49 }
50
51 void MX_TIM3_Init(void) {
52 TIM_SlaveConfigTypeDef sSlaveConfig;
53
54 htim3.Instance = TIM3;
55 htim3.Init.Prescaler = 0;
56 htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
57 htim3.Init.Period = 1;
58 htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
59 HAL_TIM_Base_Init(&htim3);
60
61 sSlaveConfig.SlaveMode = TIM_SLAVEMODE_EXTERNAL1;
62 sSlaveConfig.InputTrigger = TIM_TS_ITR0;
63 HAL_TIM_SlaveConfigSynchronization(&htim3, &sSlaveConfig);
64
65 HAL_NVIC_SetPriority(TIM3_IRQn, 0, 0);
66 HAL_NVIC_EnableIRQ(TIM3_IRQn);
67 }
68
69 void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base) {
70 GPIO_InitTypeDef GPIO_InitStruct;
71 if(htim_base->Instance==TIM3) {
72 __HAL_RCC_TIM3_CLK_ENABLE();
73 }
74
75 if(htim_base->Instance==TIM1) {
76 __HAL_RCC_TIM1_CLK_ENABLE();
Timers 337
77
78 GPIO_InitStruct.Pin = GPIO_PIN_8;
79 GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
80 GPIO_InitStruct.Pull = GPIO_PULLDOWN;
81 GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
82 GPIO_InitStruct.Alternate = GPIO_AF2_TIM1;
83 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
84 }
85 }
Lines[29:38]configureTIM1tobeclockedfromtheinternalAPB1bus.Lines[40:44]configureTIM1
in slave mode, so that it starts counting when the TI1FP1 line goes high (that is, it is triggered).
PA8 GPIO is configured accordingly in lines [74:79] (it is configured as GPIO_AF2_TIM1 ). Take note
that the internal pull-down resistor is activated in line 76: this prevents that a floating input could
accidentally trigger the timer. For the same reason, the TriggerFilter is set to the maximum level
at line 43 (if you try to set it to zero, you will notice that it is really easy to trigger accidentally the
timer, even by simply touching the wire connected to PA8 pin).
Lines [46:48] configure TIM1 to work also in master mode. The timer will trigger its internal line
(which is connected to the ITR0 line of TIM3) every time theupdate event is generated. Finally, lines
[61:63] configure the TIM3 in External Clock Mode 1, selecting the ITR0 line as source clock.
Note that the, in order to have LD2 LED blinking every 500ms (2Hz), the TIM1 period is set
to 249²⁴, which causes that the update frequency of TIM1 is 4Hz. This is required because,
applying the equation [3], we have that:
UpdateEvent =
4Hz
(0 + 1)(1 + 1)(0 + 1)
= 2Hz = 0.5s
Remember that the Period field cannot be set to zero.
To trigger TIM1 you have to connect the PA8 pin to a +3V3 source. Figure 12 shows how to connect
it in a Nucleo-F030.
Finally, note that we do not call the HAL_TIM_Base_Start() function for the TIM1 timer (see the
main() routine), because the timer is started upon the trigger event generated on Channel 1 (that is,
we tight the PA8 pin to the +3V3 source).
²⁴ Clearly, that prescaler value is referred to an STM32F030R8 MCU running at 48MHz. For your Nucleo, check the book examples for the
right prescaler setting.
Timers 338
Figure 12: How to connect the TI2FP2 pin to AVDD pin in a Nucleo-F030R8 board
11.3.2.1 Enable Trigger-Related Interrupts
When a timer works in slave mode, the timer IRQ is raised, if enabled, every time the specified
trigger event occurs. For example, when the master clock triggers due to an update event, the IRQ
of the slave timer is faired and we can be notified of this by defining the callback:
void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim) {
...
}
By default, the HAL_TIM_Base_Start_IT() does not enable this type of interrupt. We have to use
the function HAL_TIM_SlaveConfigSynchronization_IT() , instead of the function HAL_TIM_Slave-
ConfigSynchronization() . Obviously, the corresponding ISR must be defined, and the function
HAL_TIM_IRQHandler() has to be called from it.
11.3.2.2 Using CubeMX to Configure the Master/Slave Synchronization
To configure a timer in slave mode from CubeMX, it is sufficient to select the desired trigger mode
(Reset Mode, Gated Mode, Trigger Mode) from the IP Pane tree (Slave mode combo-box), and
then select the Trigger Source, as shown in Figure 13. Remember that a timer configured in slave
mode, and not working in External Clock Mode 1, must be clocked from the internal clock or by the
ETR2 clock source.
Timers 339
Figure 13: How to configure a timer in slave mode
Instead, to enable the master mode, we have to select this mode from the timer configuration view,
as shown in Figure 14. Once the master mode is selected, it is possible to select the TRGO source
event.
Figure 14: How to configure a timer in master mode
11.3.3 Generate Timer-Related Events by Software
Timersusuallygenerateeventswhenagivenconditionismet.Forexample,theygeneratetheUpdate
Event (UEV) when the counter register (CNT) matches the Period value. However, we can force a
timer to generate a particular event by software. Every timer provide a dedicated register, named
Event Generator ( EGR ). Some bits of this register are used to fire a timer-related event. For example,
the first bit, named Update Generator ( UG ), allows to generate a UEV event when set. This bit is
automatically cleared once the event is generated.
To generate events by software, the HAL provides the following function:
Timers 340
HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource);
which accepts the pointer to the timer handle and the event to generate. The EventSource parameter
can assume one value from Table 15.
Table 15: Software-triggerable events
Event soure Description
TIM_EVENTSOURCE_UPDATE Timer update Event source
TIM_EVENTSOURCE_CC1 Timer Capture Compare 1 Event source
TIM_EVENTSOURCE_CC2 Timer Capture Compare 2 Event source
TIM_EVENTSOURCE_CC3 Timer Capture Compare 3 Event source
TIM_EVENTSOURCE_CC4 Timer Capture Compare 4 Event source
TIM_EVENTSOURCE_COM Timer COM event source
TIM_EVENTSOURCE_TRIGGER Timer Trigger Event source
TIM_EVENTSOURCE_BREAK Timer Break event source
The TIM_EVENTSOURCE_UPDATE plays two important roles. The first one is related to the way
the Period register (that is the TIMx->ARR register) is updated when the timer is running. By
default, the content of the ARR register is transferred to the internal shadow register when the
TIM_EVENTSOURCE_UPDATE event is generated, unless the timer is differently configured. More about
this later.
The TIM_EVENTSOURCE_UPDATE event is also useful when the TRGO output of a timer configured as
master is set in TIM_TRGO_RESET mode: in this case, the slave timer will be triggered only if the
TIMx->EGR register is used to generate the TIM_EVENTSOURCE_UPDATE event (that is, the UG bit is set).
The following code shows how to software event generation works (the example is based on
an STM32F401RE MCU). TIM3 and TIM4 are two timers configured in master and slave mode
respectively. TIM4 is configured to work in ETR1 mode (that is, it is clocked by the master timer).
TIM3isconfiguredtotriggertheTRGOoutput(whichisinternallyconnectedtotheITR2line)when
the UG bit of the TIM3->EGR register is set. Finally, we generate the UEV event manually every 200ms
from the main() routine.
int main(void) {
...
while (1) {
HAL_TIM_GenerateEvent(&htim3, TIM_EVENTSOURCE_UPDATE);
HAL_Delay(200);
}
...
}
void MX_TIM3_Init(void){
TIM_ClockConfigTypeDef sClockSourceConfig;
TIM_MasterConfigTypeDef sMasterConfig;
Timers 341
htim3.Instance = TIM3;
htim3.Init.Prescaler = 65535;
htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
htim3.Init.Period = 120;
htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
HAL_TIM_Base_Init(&htim3);
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_ENABLE;
HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);
}
void MX_TIM4_Init(void) {
TIM_SlaveConfigTypeDef sSlaveConfig;
htim4.Instance = TIM4;
htim4.Init.Prescaler = 0;
htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
htim4.Init.Period = 1;
htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
HAL_TIM_Base_Init(&htim4);
sSlaveConfig.SlaveMode = TIM_SLAVEMODE_EXTERNAL1;
sSlaveConfig.InputTrigger = TIM_TS_ITR2;
HAL_TIM_SlaveConfigSynchronization_IT(&htim4, &sSlaveConfig);
}
11.3.4 Counting Modes
At the beginning of this chapter we have seen that a basic timer counts from zero to a given Period
value. General purpose and advanced timers can count in other different ways, as reported in Table
4. The Figure 15 shows the three main counting modes.
When a timer counts in TIM_COUNTERMODE_DOWN mode, it starts from the Period value and counts
down to zero: when the counter reaches the end, the timer IRQ is raised and the UIF flag is set (that
is, the update event is generated and the HAL_TIM_PeriodElapsedCallback() is called by the HAL).
Timers 342
Figure 15: The three major counting modes of a general purpose timer
Instead, when a timer counts in TIM_COUNTERMODE_CENTERALIGNED mode, it starts counting from zero
up to Period value: this causes that the timer IRQ is raised and the UIF flag is set (that is, theupdate
event isgenerated andthe HAL_TIM_PeriodElapsedCallback() iscalled bytheHAL). Then thetimer
starts counting down to zero and another update event is generated (as well as the corresponding
IRQ).
11.3.5 Input Capture Mode
General purpose timers have not been designed to be used as timebase generators. Even if it is
perfectly possible to use them to accomplish this job, other timers like basic ones and the SysTick
timer can be used to carry out this task. General purpose timers offer much more advanced
capabilities, which can be used to drive other important time-related activities.
TheFigure16showsthestructureoftheinputchannelsinageneralpurpose timer²⁵.Asyoucansee,
each input is connected to an edge detector, which is also equipped with a filter used to “debounce”
the input signal. The output of the edge detector goes into a source multiplexer (IC1, IC2, etc.). This
allows to “remap” the input channels if a given I/O is allocated to another peripheral. Finally, a
dedicated prescaler allows to “slow down” the frequency of the input signal, in order to match the
timer running frequency if this cannot be lowered, as we will see in a while.
²⁵ Some general purpose timers (for example, TIM14) have less input channels and hence a simplified input stage structure. Refer to the
reference manual for your MCU to know the exact structure of the timer you are going to use.
Timers 343
Figure 16: The structure of the input channel in a general purpose timer
The input capture mode offered by general purpose and advanced timers allows to compute the
frequency of external signals applied to each one of the 4 channels that these timers provide. And
the capture is performed independently for each channel.
Figure 17: The capture process of an external signal feeding one of the timer channels
The Figure 17 shows how the capture process works. TIMx is a timer, configured to work at a
given TIMx_CLK clock frequency²⁶. This means that it increments the TIMx_CNT register up to
the Period value every
1
TIMx _ CLK
seconds. Supposing that we apply a square wave signal to one
of the timer channels, and supposing that we configure the timer to trigger at every rising edge
²⁶ The timer clock frequency is independent from the way the timer works (in this case, input capture mode). As seen in the previous
paragraphs, the timer clock depends on the bus frequency or the external clock source and on the related prescaler settings.
Timers 344
of the input signal, we have that the TIMx_CCRx²⁷ register will be updated with the content of
the TIMx_CNT register at every detected transition. When this happens, the timer will generate a
corresponding interrupt or a DMA request, allowing to keep track of the counter value.
To get the external signal period, two consecutive captures are needed. The period is calculated by
subtracting these two values, CNT 0 (the value 4 in Figure 17) and CNT 1 (the value 20 in Figure 17),
and using the following formula:
Period = Capture ·
(
TIMx _ CLK
(Prescaler + 1)(CH Prescaler )(Polarity Index )
) −1
[4]
where:
Capture = CNT 1 − CNT 0 if CNT 0 < CNT 1
Capture = (TIMx _ Period − CNT 0 ) + CNT 1 if CNT 0 > CNT 1
CH Prescaler is a further prescaler that can be applied to the input channel and Polarity Index is equal
to 1 if the channel is configured to trigger on rising or falling edge of the input signal, or it is equal
to 2 if both the edges are sampled.
Another relevant condition is that the UEV frequency should be lower than the sampled signal
frequency. The reason why this matters is evident: if the timer runs faster that the sampled signal,
then it will overflow (that is, it runs out the Period counter) before it can sample the signal edges
(see Figure 18). For this reason, it usually convenient to set the Period value to the maximum, and
increase the Prescaler factor to lower the counting frequency.
Figure 18: If the timer runs faster than the sample signal, then it overflow before the two rising edges are dected
To configure the input channels we use the function HAL_TIM_IC_ConfigChannel() and an instance
of the C struct TIM_IC_InitTypeDef , which is defined in the following way:
²⁷ CCR is acronym for Capture Compare Register and the x is the channel number.
Timers 345
typedef struct {
uint32_t ICPolarity; /* Specifies the active edge of the input signal. */
uint32_t ICSelection; /* Specifies the input. */
uint32_t ICPrescaler; /* Specifies the Input Capture Prescaler. */
uint32_t ICFilter; /* Specifies the input capture filter. */
} TIM_IC_InitTypeDef;
• ICPolarity : specifies the polarity of the input signal, and it can assume a value from Table 16.
• ICSelection : specifies the used input of the timer. It can assume a value from Table 17. It is
possible to selectively remap input channels to different input sources, that is (IC1,IC2) are
mapped to (TI2,TI1) and (IC3,IC4) are mapped to (TI4,TI3). Usually this is used to differentiate
rising-edge from falling-edge captures for signals where the T on is different from T off . It is
also possible to capture from the same internal channel, named TRC, connected to ITR0..ITR3
sources.
• ICPrescaler : configures the prescaler stage of a given input. It can assume a value from Table
18.
• ICFilter : this 4-bit field defines the frequency used to sample the external clock signal
connected to TIMx_CHx pin and the length of the digital filter applied to it. It is useful to
debounce the input signal. Refer to the datasheet of your MCU for more information.
Table 16: Available input capture polarity
Input capture polarity mode Description
TIM_ICPOLARITY_RISING The rising edge of the external signal is captured
TIM_ICPOLARITY_FALLING The falling edge of the external signal is captured
TIM_ICPOLARITY_BOTHEDGE The rising and falling edges of the external signal determine the capture
period (this will increase the frequency of the sampled signal)
Table 17: Available input capture selection modes
Input capture selection mode Description
TIM_ICSELECTION_DIRECTTI TIM Input 1, 2, 3 or 4 is selected to be connected to IC1, IC2, IC3 or IC4,
respectively
TIM_ICSELECTION_INDIRECTTI TIM Input 1, 2, 3 or 4 is selected to be connected to IC2, IC1, IC4 or IC3,
respectively.
TIM_ICSELECTION_TRC TIM Input 1, 2, 3 or 4 is selected to be connected to TRC (Trigger line in
Figure 3 - TRC input highlighted in red in Figure 16)
Timers 346
Table 18: Available input prescaler modes
Input capture prescaler mode Description
TIM_ICPSC_DIV1 No prescaler used
TIM_ICPSC_DIV2 Capture performed once every 2 events
TIM_ICPSC_DIV4 Capture performed once every 4 events
TIM_ICPSC_DIV8 Capture performed once every 8 events
Now it is the right time to see a practical example. We are going to rearrange the Example 2 of
this chapter so that we sample the switching frequency of PA5 pin (the one connected to LD2 LED)
through the Channel 1 of TIM3 timer (in an STM32F030 MCU this pin coincides with PA6 pin).
We so configure the Channel 1 as input capture pin, and we configure it in DMA mode so that it
triggers the TIM3_CH1 request to automatically fill a temporary buffer that stores the value of the
TIM3_CNT register when the rising edge of input signal is detected.
Before we analyze the main() function, it is best to give a look at the TIM3 initialization routines.
Filename: src/main-ex6.c
59 /* TIM3 init function */
60 void MX_TIM3_Init(void) {
61 TIM_IC_InitTypeDef sConfigIC;
62
63 htim3.Instance = TIM3;
64 htim3.Init.Prescaler = 0;
65 htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
66 htim3.Init.Period = 65535;
67 htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
68 HAL_TIM_IC_Init(&htim3);
69
70 sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
71 sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
72 sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
73 sConfigIC.ICFilter = 0;
74 HAL_TIM_IC_ConfigChannel(&htim3, &sConfigIC, TIM_CHANNEL_1);
75 }
76
77 void HAL_TIM_IC_MspInit(TIM_HandleTypeDef* htim_ic) {
78 GPIO_InitTypeDef GPIO_InitStruct;
79 if (htim_ic->Instance == TIM3) {
80 /* Peripheral clock enable */
81 __HAL_RCC_TIM3_CLK_ENABLE();
82
83 /**TIM3 GPIO Configuration
84 PA6 ------> TIM3_CH1
85 */
86 GPIO_InitStruct.Pin = GPIO_PIN_6;
Timers 347
87 GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
88 GPIO_InitStruct.Pull = GPIO_NOPULL;
89 GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
90 GPIO_InitStruct.Alternate = GPIO_AF1_TIM3;
91 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
92
93 /* Peripheral DMA init*/
94 hdma_tim3_ch1_trig.Instance = DMA1_Channel4;
95 hdma_tim3_ch1_trig.Init.Direction = DMA_PERIPH_TO_MEMORY;
96 hdma_tim3_ch1_trig.Init.PeriphInc = DMA_PINC_DISABLE;
97 hdma_tim3_ch1_trig.Init.MemInc = DMA_MINC_ENABLE;
98 hdma_tim3_ch1_trig.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
99 hdma_tim3_ch1_trig.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
100 hdma_tim3_ch1_trig.Init.Mode = DMA_NORMAL;
101 hdma_tim3_ch1_trig.Init.Priority = DMA_PRIORITY_LOW;
102 HAL_DMA_Init(&hdma_tim3_ch1_trig);
103
104 /* Several peripheral DMA handle pointers point to the same DMA handle.
105 Be aware that there is only one channel to perform all the requested DMAs. */
106 __HAL_LINKDMA(htim_ic, hdma[TIM_DMA_ID_CC1], hdma_tim3_ch1_trig);
107 }
108 }
The MX_TIM3_Init() configures the TIM3 timer so that it runs at a frequency equal to ∼ 732Hz. The
first channel is then configured to trigger the capture event (TIM3_CH1) at every rising edge of the
input signal. The HAL_TIM_IC_MspInit() then configures the hardware part (the PA6 pin connected
to the TIM3 Channel 1) and the DMA descriptor used to configure the TIM3_CH1 request.
Here we have two things to note. First of all, the DMA is configured so that both the
peripheral and memory data align are set to perform a 16-bit transfer, since the timer
counter register is 16-bit wide. In those MCU where TIM2 and TIM5 timers have a counter
register 32-bit wide, you need to setup the DMA to perform a word-aligned transfer.
Next, since we are using the HAL_TIM_IC_Init() at line 69, the HAL is designed to call
the function HAL_TIM_IC_MspInit() to perform low-level initializations, instead of the
HAL_TIM_Base_MspInit one.
Timers 348
Filename: src/main-ex6.c
20 uint8_t odrVals[] = { 0x0, 0xFF };
21 uint16_t captures[2];
22 volatile uint8_t captureDone = 0;
23
24 int main(void) {
25 uint16_t diffCapture = 0;
26 char msg[30];
27
28 HAL_Init();
29
30 Nucleo_BSP_Init();
31 MX_DMA_Init();
32
33 MX_TIM3_Init();
34 MX_TIM6_Init();
35
36 HAL_DMA_Start(&hdma_tim6_up, (uint32_t) odrVals, (uint32_t) &GPIOA->ODR, 2);
37 __HAL_TIM_ENABLE_DMA(&htim6, TIM_DMA_UPDATE);
38 HAL_TIM_Base_Start(&htim6);
39
40 HAL_TIM_IC_Start_DMA(&htim3, TIM_CHANNEL_1, (uint32_t*) captures, 2);
41
42 while (1) {
43 if (captureDone != 0) {
44 if (captures[1] >= captures[0])
45 diffCapture = captures[1] - captures[0];
46 else
47 diffCapture = (htim3.Instance->ARR - captures[0]) + captures[1];
48
49 frequency = HAL_RCC_GetPCLK1Freq() / (htim3.Instance->PSC + 1);
50 frequency = (float) frequency / diffCapture;
51
52 sprintf(msg, "Input frequency: %.3f\r\n", frequency);
53 HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
54 while (1);
55 }
56 }
57 }
Themostrelevantpartoftheapplicationisthe main() function.WefirstinitializeTIM6timer(which
is configured to run at 100kHz - this means that the PA5 pin is set HIGH every 20µs = 50kHz) using
the MX_TIM6_Init() function and then we start it in DMA mode, as described so far in this chapter.
Then we start TIM3 and we enable the DMA mode on the first channel, by using the HAL_TIM_IC_-
Start_DMA() function (line 40). The captures array is used to store the two consecutive captures
acquired on the channel.
Timers 349
Lines [42:53] are the part where we compute the frequency of the external signal. When the two
captures are performed, the global variable captureDone is set to 1 by the HAL_TIM_IC_CaptureCall-
back() callback function (not shown here),which is invoked at the end of the captureprocess. When
this happens we compute the frequency of the sample signal using the equation [4].
11.3.5.1 Using CubeMX to Configure the Input Capture Mode
Thanks to CubeMX, it is really easy to configure the input channels of a general purpose timer in
the input capture mode. To bound one channel to the corresponding input (that is, IC1 to TI1), you
have to select the Input capture direct mode for the desired channel, as shown in Figure 19.
Figure 19: How to enable a channel in input capture mode
Instead, to map the other channel of the couple (IC1,IC2) or (IC3,IC4) to the same input (that is
TI1 or TI2 for (IC1,IC2)), it is possible to enable the other channel in the couple in Input capture
indirect mode, as shown in Figure 20. Finally, from the TIMx configuration view (not shown here),
it is possible to configure the other input capture parameters (channel polarity, its filter, and so on).
Figure 20: How to enable a channel in input capture indirect mode
11.3.6 Output Compare Mode
So far we have used a couple of techniques to control an output waveform, one using interrupts and
one the DMA. Both of them use the generation of UEV event to toggle a GPIO configured as output
Timers 350
pin. The output compare is a mode offered by general purpose and advanced timers that allows to
control the status of output channels when the channel compare register (TIMx_CCRx) matches
with the timer counter register (TIMx_CNT).
There are six²⁸ output compare modes available to programmers:
• Output compare timing²⁹: the comparison between the output compare register (CCRx) and
the counter (CNT) has no effect on the output. This mode is used to generate a timing base.
• Output compare active: set the channel output to active level on match. The channel output is
forced high when the counter (CNT) matches the capture/compare register (CCRx).
• Output compare inactive: set channel to inactive level on match. The channel output is forced
low when the counter (CNT) matches the capture/compare register (CCRx).
• Output compare toggle: the channel output toggles when the counter (CNT) matches the
capture/compare register (CCRx).
• Output compare forced active/inactive: the channel output is forced high (active mode) or low
(inactive mode) independently from counter value.
Each channel of the timer is configured in output compare mode by using the function HAL_TIM_-
OC_ConfigChannel() and an instance of the C struct TIM_OC_InitTypeDef , which is defined in the
following way:
typedef struct {
uint32_t OCMode; /* Specifies the TIM mode. */
uint32_t Pulse; /* Specifies the pulse value to be loaded
into the Capture Compare Register. */
uint32_t OCPolarity; /* Specifies the output polarity. */
uint32_t OCNPolarity; /* Specifies the complementary output polarity.*/
uint32_t OCFastMode; /* Specifies the Fast mode state. */
uint32_t OCIdleState; /* Specifies the TIM Output Compare pin state during Idle state.*/
uint32_t OCNIdleState; /* Specifies the complementary TIM Output Compare pin
state during Idle state. */
} TIM_OC_InitTypeDef;
• OCMode : specifies the output compare mode and it can assume a value from Table 19.
• Pulse : the content of this field will be stored inside the CCRx register and it establishes when
to trigger the output.
• OCPolarity : defines the output channel polarity when the CCRx registers matches with the
CNT one. It can assume a value from Table 20.
• OCNPolarity : defines the complimentary output polarity. It is a mode available only in
TIM1 and TIM8 advanced timers, which allow to generate, on additional dedicated channels,
complimentary signals (that is, when the CH1 is HIGH the CH1N is LOW and vice versa). This
featureisespeciallydesignedformotorcontrolapplications,anditisnotdescribedinthisbook.
It can assume a value from Table 21.
²⁸ Theoutputcomparemodesareactuallyeight,buttwoofthemarerelatedtoPWMoutput,andtheywillbeanalizedinthenextparagraph.
²⁹ This mode in CubeMX is called Frozen mode.
Timers 351
• OCFastMode : specifies the fast mode state. This parameter is valid only in PWM1 and PWM2
mode and it can assume the values TIM_OCFAST_DISABLE and TIM_OCFAST_ENABLE .
• OCIdleState : specifies the channel output compare pin state during the timer idle state. It
can assume the values TIM_OCIDLESTATE_SET and TIM_OCIDLESTATE_RESET . This parameter is
available only in TIM1 and TIM8 advanced timers.
• OCNIdleState : specifies the complementary channel output compare pin state during the timer
idle state. It can assume the values TIM_OCNIDLESTATE_SET and TIM_OCNIDLESTATE_RESET . This
parameter is available only in TIM1 and TIM8 advanced timers.
Table 19: Available output compare modes
Output compare mode Description
TIM_OCMODE_TIMING The comparison between the output compare register (CCRx) and the
counter (CNT) has no effect on the output (aka, frozen mode)
TIM_OCMODE_ACTIVE Set the channel output to active level on match
TIM_OCMODE_INACTIVE Set channel to inactive level on match
TIM_OCMODE_TOGGLE The channel output toggles when the counter (CNT) matches the
capture/compare register (CCRx)
TIM_OCMODE_PWM1 PWM Mode 1 - see next paragraph
TIM_OCMODE_PWM2 PWM Mode 2 - see next paragraph
TIM_OCMODE_FORCED_ACTIVE The channel output is forced high independently from the counter value
TIM_OCMODE_FORCED_INACTIVE The channel output is forced low independently from the counter value
Table 20: Available output compare polarity modes
Output compare polarity mode Description
TIM_OCPOLARITY_HIGH When the CCRx and CNT registers match, the output channel is set
high
TIM_OCPOLARITY_LOW When the CCRx and CNT registers match, the output channel is set
low
Table 21: Available complementary output compare polarity modes
Complementary output compare polarity mode Description
TIM_OCNPOLARITY_HIGH When the CCRx and CNT registers match, the
complementary output channel is set high
TIM_OCNPOLARITY_LOW When the CCRx and CNT registers match, the
complementary output channel is set low
When the CCRx registers matches with the timer CNT counter, and the channel is configured to
work in output compare mode, a specific interrupt is generated (if enabled). This allows to control
theswitchingfrequencyofeachchannelindependently,andeventuallyperformphaseshiftbetween
channels. The channel frequency can be computed using the following formula:
Timers 352
CHx _ Update =
TIMx _ CLK
CCRx
[5]
where:
TIMx _ CLK is the running frequency of the timer and CCRx is the Pulse value of the TIM_-
OnePulse_InitTypeDef struct used to configure the channel. This means that we can compute the
Pulse value, given a channel frequency, in the following way:
Pulse =
TIMx _ CLK
CHx _ Update
[6]
Clearly, it is important to underline that the timer frequency must be set so that the Pulse value
computed with [6] is lower than the timer Period value (the CCRx value cannot be higher than the
TIM->ARR value, which corresponds to the timer’s Period ).
The following example shows how to generate two output square wave signals, one running at
50kHz and one at 100kHz. It uses the Channel 1 and 2 (bound to OC1 and OC2) of TIM3 timer and
it is designed to run on a Nucleo-F030R8.
Filename: src/main-ex7.c
17 volatile uint16_t CH1_FREQ = 0;
18 volatile uint16_t CH2_FREQ = 0;
19
20 int main(void) {
21 HAL_Init();
22
23 Nucleo_BSP_Init();
24 MX_TIM3_Init();
25
26 HAL_TIM_OC_Start_IT(&htim3, TIM_CHANNEL_1);
27 HAL_TIM_OC_Start_IT(&htim3, TIM_CHANNEL_2);
28
29 while (1);
30 }
31
32 /* TIM3 init function */
33 void MX_TIM3_Init(void) {
34 TIM_OC_InitTypeDef sConfigOC;
35
36 htim3.Instance = TIM3;
37 htim3.Init.Prescaler = 2;
38 htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
39 htim3.Init.Period = 65535;
40 htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
41 HAL_TIM_OC_Init(&htim3);
42
Timers 353
43 CH1_FREQ = computePulse(&htim3, 50000);
44 CH2_FREQ = computePulse(&htim3, 100000);
45
46 sConfigOC.OCMode = TIM_OCMODE_TOGGLE;
47 sConfigOC.Pulse = CH1_FREQ;
48 sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
49 sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
50 HAL_TIM_OC_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
51
52 sConfigOC.Pulse = CH2_FREQ;
53 HAL_TIM_OC_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2);
54 }
Lines [48:59] configure Channel 1 and 2 to work as output compare channels. Both are configured
in toggle mode (that is, they invert the state of the GPIO every time the CCRx register matches
with the CNT timer register). The TIM3 is configured to run at 16MHz, and hence the function
computePulse() , which uses the equation [6], will return the values 320 and 160 to have a channel
switching frequency equal to 50kHz and 100kHz respectively. However, the above code is still not
sufficient to drive the GPIO at that frequency. Here we are configuring the channels so that they
will toggle their output every time the timer CNT register is equal to 320 for Channel 1 and to 160
for Channel 2. But this means that the switching frequency is equal to:
16.000.000
65535 + 1
= 244Hz
and we only have a shift of 10µs between the two channels, as shown by Figure 21. That 65535
value corresponds to the timer Period value, that is the maximum value reached by the timer CNT
register.
Figure 21: The toggling shift between channels 1 and 2
To reach the desired switching frequency³⁰, we need to toggle the output every each 320 and 160
ticks of the TIM3 CNT register. To do so, we can define the following callback routine:
³⁰ Please, take note that the quality of the output signal is affected by the GPIO slew rate setting, as described in Chapter 6.
Timers 354
Filename: src/main-ex7.c
62 uint16_t pulse;
63
64 /* TIM2_CH1 toggling with frequency = 50KHz */
65 if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
66 {
67 pulse = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
68 /* Set the Capture Compare Register value */
69 __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_1, (pulse + CH1_FREQ));
70 }
71
72 /* TIM2_CH2 toggling with frequency = 100KHz */
73 if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2)
74 {
75 pulse = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2);
76 /* Set the Capture Compare Register value */
77 __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_2, (pulse + CH2_FREQ));
78 }
79 }
The HAL_TIM_OC_DelayElapsedCallback() is automatically called by the HAL every time the
Channel CCRx register matches the timer counter. We can so increase the Pulse (that is, the CCRx
register) by 320 for Channel 1 and by 160 for Channel 2. This causes that the corresponding channel
will switch at the wanted frequency, as shown in Figure 22.
Figure 22: Channel 2 is configured to switch twice as fast as channel 1
ThesameresultmaybeobtainedusingtheDMAmodeandapre-initializedvector,eventuallystored
in the flash memory by using the const modifier:
const uint16_t ch1IV[] = {320, 640, 960, ...};
...
HAL_TIM_OC_Start_DMA(&htim3, TIM_CHANNEL_1, (uint32_t)ch1IV, sizeof(ch1IV));
Timers 355
11.3.6.1 Using CubeMX to Configure the Output Compare Mode
The configuration process of the output compare mode in CubeMX is identical to the one for the
input capture mode. The first step is to select the Output compare CHx mode for the desired
channel, as shown in Figure 19. Next, from the TIMx configuration view (not shown here), it is
possible to configure the other output compare parameters (the output mode, channel polarity, and
so on).
11.3.7 Pulse-Width Generation
The square waves generated until now have all one common characteristic: they have a T ON period
equal to the T OFF one. For this reason they are also said to have a 50% duty cycle. A duty cycle is the
percentage of one period of time (for example, 1s) in which a signal is active. As a formula, a duty
cycle is expressed as:
D =
T ON
Period
× 100 % [8]
where D is the duty cycle, T ON is the time the signal is active. Thus, a 50% duty cycle means the
signal is on 50% of the time but off 50% of the time. The duty cycle says nothing about how long
it lasts. The “on time” for a 50% duty cycle could be a fraction of a second, a day, or even a week,
depending on the length of the period. The pulse width is the duration of the T ON , given the actual
period. For example, assuming a period of 1s, a duty cycle of 20% generates a pulse width of 200ms.
Figure 23: Three different duty cycles - 50%, 20% and 80%
The Figure 23 shows three different duty cycles: 50%, 20% and 80%.
Timers 356
Pulse-width modulation (PWM) is a technique used to generate several pulses with different duty
cycles in a given period of time or, if you prefer, at a given frequency. PWM has many applications
in digital electronics, but all of them can be grouped in two main categories:
• control the output voltage (and hence the current);
• encoding (that is, modulate) a message (that is, a series of bytes in digital electronics³¹) on a
carrier wave (which runs at a given frequency).
Those two categories can be expanded in several practical usages of the PWM technique. Focusing
our attention on the control of the output voltage, we can find several applications:
• generation of an output voltage ranging from 0V up to VDD (that is, the maximum allowed
voltage for an I/O, which in an STM32 is 3.3V);
– dimming of LEDs;
– motor control;
– power conversion;
• generation of an output wave running at a given frequency (sine wave, triangle, square, and
so on);
• sound output;
With adequate output filtering, which usually involves the usage of a low-pass filter, the PWM
can replicate the behaviour of a DAC, even if the MCU does not provide one. By varying the duty
cycle of the output pin it is possible to regulate the output voltage proportionally. An amplifier can
increase/decrease the voltage range at a need, and it is also possible to control high currents and
loads using power transistors.
A timer channel is configured in PWM mode by using the function HAL_TIM_PWM_ConfigChannel()
and an instance of the C struct TIM_OC_InitTypeDef seen in the previous paragraph. The TIM_OC_-
InitTypeDef.Pulse field defines the duty cycle, and it ranges from 0 up to the timer Period field.
The longer is the Period the wider is the tuning range. This means that we can fine-tune the output
voltage.
The choice of the period, which determines the frequency of the output signal together with
thetimerclock(internal,externalandsoon),isnotadetailtobelefttochance.Itdependson
the specific application field, and it can have a severe impact on the overall EMI emissions.
Moreover, some devices controlled with PWM tecnnique may emit audible noise at given
frequencies. This is the case of electric motors, which could emit unwanted buzzing noise
when controlled at frequencies in the hearing range. Another example, not too much related
here but with a similar genesis, is the noise emitted by power inductors in switching power
supplies, which use the concept underlying the PWM to regulate their output voltage, and
therefore the current. Sometimes, the output noise is unavoidable, and it is required to use
varnishing products to reduce the problem. Other times, the right frequency come from
“natural limitations”: dimming a LED at a frequency close to 100Hz is usually sufficient to
avoid visible flickering of the light.
³¹ However, keep in mind that the PWM as modulation technique is not limited to digital electronics, but it originates in the “analog era”
when it was used to modulate an audio wave on a carrier frequency.
Timers 357
There are two PWM modes avialable: PWM mode 1 and 2. Both of them are configurable through
the field TIM_OC_InitTypeDef.OCMode , using the values TIM_OCMODE_PWM1 and TIM_OCMODE_PWM2 . Let
us see the differnces.
• PWM mode 1: in upcounting, the channel is active as long as Period < Pulse , else inactive.
In downcounting, the channel is inactive as long as Period > Pulse , else active.
• PWM mode 2: in upcounting, channel 1 is inactive as long as Period < Pulse , else active.
In downcounting, channel 1 is active as long as Period > Pule , else inactive.
The following example shows a typical application of the PWM technique: LED dimming. The
example is designed to run on a Nucleo-F401RE and it fades ON/OFF the LD2 LED³².
Filename: src/main-ex8.c
11 int main(void) {
12 HAL_Init();
13
14 Nucleo_BSP_Init();
15 MX_TIM2_Init();
16
17 HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
18
19 uint16_t dutyCycle = HAL_TIM_ReadCapturedValue(&htim2, TIM_CHANNEL_1);
20
21 while(1) {
22 while(dutyCycle < __HAL_TIM_GET_AUTORELOAD(&htim2)) {
23 __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, ++dutyCycle);
24 HAL_Delay(1);
25 }
26
27 while(dutyCycle > 0) {
28 __HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, --dutyCycle);
29 HAL_Delay(1);
30 }
31 }
32 }
33
34 /* TIM3 init function */
35 void MX_TIM2_Init(void) {
36 TIM_OC_InitTypeDef sConfigOC;
37
38 htim2.Instance = TIM2;
39 htim2.Init.Prescaler = 499;
40 htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
³² Unfortunately, not all Nucleo boards have the LD2 LED connected to a timer channel (this depends on the fact that the pinout of LQFP-64
STM32 microcontrollers is not perfectly compatible). Only seven of them have this feature. Owners of other Nucleo boards have to rearrange
the example using an external LED.
Timers 358
41 htim2.Init.Period = 999;
42 htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
43 HAL_TIM_PWM_Init(&htim2);
44
45 sConfigOC.OCMode = TIM_OCMODE_PWM1;
46 sConfigOC.Pulse = 0;
47 sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
48 sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
49 HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
50 }
Lines [45:49] configure the first channel of timer TIM2 to work in PWM Mode 1. The duty cycle will
be range from 0 up to 999, which corresponds to the Period value. This means that we can regulate
the output voltage with steps of ∼ 0,0033V if the output is well filtered (and the PCB has a good
layout). This is close to the performances of a 10bit DAC.
Lines [21:32] is where the fading effect takes place. The first loop increments the value of the Pulse
(which corresponds to the Capture Compare Register 1 (CCR1)) up to the Period value (which
corresponds to the Auto Reload Register (ARR)) every 1ms. This means that in less then 1s the
LED becomes full bright. The second loop, in the same way, decrements the Pulse field unless it
reaches zero.
The update frequency of the timer is set to 84MHz³³/(499+1)(999+1)=168Hz. The same
frequency can be obtained by setting the Prescaler to 249 and the Period to 1999. But the
fading effect changes. Why that happens? If you cannot explain the difference, I strongly
suggest taking a break before going on, and doing experiments by yourself.
11.3.7.1 Generating a Sinusoidal Wave Using PWM
An output square wave generated with the PWM technique can be filtered to generate a smoothed
signal, that is an analog signal that has a reduced peak-to-peak voltage ( V pp ). A Resistor-Capacitor
(RC) low-pass filter (see Figure 24) is able to cut-off all those AC signals having a frequency higher
than a given threshold. The general rule of thumb of RC low-pass filters is that the lower is the
cut-off frequency the lower is the V pp ³⁴. An RC low-pass filter uses an important characteristic of
capacitors: the ability to block DC currents while allowing the passing of AC ones: given the R/C
time constant formed by the resistor-capacitor network, the filter will short to ground those AC
signal with a frequency higher than the RC constant, allowing to pass DC component of the signal
and lower frequency AC voltages.
³³ The maximum frequency of timers in an STM32F401RE MCU, when clocked from the APB1 bus, is 84MHz.
³⁴ When dealing with filters to smooth an output wave it is more convenient to consider the effects on the output voltage than the response
in frequency of the filter. However, the math under the transfer function of a filter is outside the scope of this book. If interested, this on-line
calculator(http://bit.ly/22breq2) allows to evaluate the V pp output given a V IN , the PWM frequency and the R and C values.
Timers 359
Figure 24: A typical low pass filter implemented with a resistor and a capscitor
While this circuit is very simple, choosing the appropriate values for R (the resistance) and C (the
capacitance) encompass some design decisions: how much ripple we can tolerate and how fast the
filterneedstorespond.Thesetwoparametersaremutuallyexclusive.Inmostfilters,wewouldliketo
have the perfect filter – one that passes all frequencies below the cut-off frequency, with no voltage
ripple. Unfortunately this ideal filter does not exists: to reduce the ripple to zero we have to chose
a very large filter, which causes that it will take a lot of time to the output to become stable. While
this could be acceptable for a continuous and fixed voltage, this has sever impact on the quality of
the output signal if we are trying to generate a complex waveform from the PWM signal.
The cut-off frequency ( f c ) of a first order RC low-pass filter is expressed by the formula:
f c =
1
2πRC
[9]
Figure 25 shows the effect of a low-pass filter on a PWM signal with a frequency of 100Hz. Here we
have chosen a 1K resistor and a 10µF capacitor. This means that the cut-off frequency is equal to:
f c =
1
2π10 3 × 10 −5
≈ 15.9Hz
Figure 25: The effect of a low-pass filter with cut-off frequency equal to 15.9Hz
Figure 26 shows the effect of the low-pass filter with a 4300K resistor and a 10µF capacitor. This
means that the cut-off frequency is equal to:
f c =
1
2π(4.3 × 10 3 ) × 10 −5
≈ 3.7Hz
Timers 360
As you can see, the second filter allows to have a ( V pp ) equal to about 160mV, which is a voltage
difference passable for a lot of applications.
Figure 26: The effect of a low-pass filter with cut-off frequency equal to 3.7Hz
By varying the output voltage (which implies that we vary the duty cycle) we can generate an
arbitrary output waveform, whose frequency is a fraction of the PWM period. The basic idea here
is to divide the waveform we want, for example a sine wave, into ‘x’ number of divisions. For each
division we have a single PWM cycle. The T ON time (that is, the duty cycle) directly corresponds to
the amplitude of the waveform in that division, which is calculated using sin() function.
Figure 27: How a sine wave can be approximated with multiple PWM signals
Consider the diagram shown in Figure 27. Here the sine wave has been divided in 10 steps. So
here we will require 10 different PWM pulses increasing/decreasing in sinusoidal manner. A PWM
pulse with 0% duty cycle will represent the min amplitude (0V), the one with 100% duty cycle will
represent max amplitude(3.3V). Since out PWM pulse has voltage swing between 0V to 3.3V, our
sine wave will swing between 0V to 3.3V too.
It takes 360 degrees for a sine wave to complete one cycle. Hence for 10 divisions we will need to
increase the angle in steps of 36 degrees. This is called the Angle Step Rate or Angle Resolution. We
can increase the number of divisions to get more accurate waveform. But as divisions increase we
also need to increase the resolution, which implies that we have to increase the frequency of the
timer used to generate the PWM signal (the faster runs the timer the smaller is the period).
Timers 361
Usually 200 divisions are a good approximation for an output wave. This means that if we want to
generate a 50Hz sine wave, we need to run the timer at a 50Hz*200 = 10kHz. The pulse period will be
equal to 200 (the number of steps - this means that we vary the output voltage by 3.3V/200=0.016V),
and so the Prescaler value will be (assuming an STM32F030 MCU running at 48MHz):
Prescaler =
48MHz
50Hz × 200 divisions × 200 Pulse
= 24
Thefollowingexampleshowshowtogeneratea50HzpuresinewaveinanSTM32F030MCUrunning
at 48MHz.
Filename: src/main-ex9.c
14 #define PI 3.14159
15 #define ASR 1.8 //360 / 200 = 1.8
16
17 int main(void) {
18 uint16_t IV[200];
19 float angle;
20
21 HAL_Init();
22
23 Nucleo_BSP_Init();
24 MX_TIM3_Init();
25
26 for (uint8_t i = 0; i < 200; i++) {
27 angle = ASR*(float)i;
28 IV[i] = (uint16_t) rint(100 + 99*sinf(angle*(PI/180)));
29 }
30
31 HAL_TIM_PWM_Start_DMA(&htim3, TIM_CHANNEL_1, (uint32_t *)IV, 200);
32
33 while (1);
34 }
35
36 /* TIM3 init function */
37 void MX_TIM3_Init(void) {
38 TIM_OC_InitTypeDef sConfigOC;
39
40 htim3.Instance = TIM3;
41 htim3.Init.Prescaler = 23;
42 htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
43 htim3.Init.Period = 199;
44 htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
45 HAL_TIM_PWM_Init(&htim3);
46
47 sConfigOC.OCMode = TIM_OCMODE_PWM1;
48 sConfigOC.Pulse = 0;
Timers 362
49 sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
50 sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
51 HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
52
53 hdma_tim3_ch1_trig.Instance = DMA1_Channel4;
54 hdma_tim3_ch1_trig.Init.Direction = DMA_MEMORY_TO_PERIPH;
55 hdma_tim3_ch1_trig.Init.PeriphInc = DMA_PINC_DISABLE;
56 hdma_tim3_ch1_trig.Init.MemInc = DMA_MINC_ENABLE;
57 hdma_tim3_ch1_trig.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
58 hdma_tim3_ch1_trig.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
59 hdma_tim3_ch1_trig.Init.Mode = DMA_CIRCULAR;
60 hdma_tim3_ch1_trig.Init.Priority = DMA_PRIORITY_LOW;
61 HAL_DMA_Init(&hdma_tim3_ch1_trig);
62
63 /* Several peripheral DMA handle pointers point to the same DMA handle.
64 Be aware that there is only one channel to perform all the requested DMAs. */
65 __HAL_LINKDMA(&htim3, hdma[TIM_DMA_ID_CC1], hdma_tim3_ch1_trig);
66 __HAL_LINKDMA(&htim3, hdma[TIM_DMA_ID_TRIGGER], hdma_tim3_ch1_trig);
67 }
The most relevant part is represented by lines [26:29]. That lines of code are used to generate the
Initialization Vector (IV), that is the vector containing the Pulse values used to generate the sine
wave (which corresponds to the output voltage levels). The C sinf() returns the sine of the given
angle expressed in radians. So we need to convert the angular expresses in degrees to radians using
the formula:
Radians =
π
180 °
× Degrees
However, in our case we have divided the sine wave cycle in 200 steps (that is, we have divided the
circumference in 200 steps), so we need to compute the value in radians of each step. But since sine
gives negative values for angle between 180° and 360° (seeFigure 28) we need to scale it, since PWM
output values cannot be negative.
Timers 363
Figure 28: The values assumed by sine function between 180° and 360°
Once the IV vector is generated, we can start PWM in DMA mode. The DMA1_Channel4 is
configured to work in circular mode, so that it automatically sets the value of the TIMx_CCRx
register according the Pulse values contained in IV . Using a timer in DMA mode is the best way to
generate arbitrary function without introducing latency and affecting the Cortex-M core. However,
often IVs are hardcoded inside the program, using const arrays automatically stored in the flash
memory. You can find several on-line tools to do this, like the one provided here³⁵.
Figure 29: How timers allow to approximate a 50Hz sine wave using PWM
Figure29showstheoutputfromTIM3Channel1:asyoucansee,usinganadequatefilteringstage³⁶,
it is really easy to generate a pure 50Hz sine wave.
11.3.7.2 Using CubeMX to Configure the PWM Mode
The configuration process of the PWM mode in CubeMX is straightforward, once the fundamental
concepts of PWM generation have been mastered. The first step is to select the PWM Generation
CHx mode for the desired channel, as shown in Figure 19. Next, from the TIMx configuration view
(not shown here), it is possible to configure the other PWM settings (PWM mode 1 or 2, channel
polarity, and so on).
³⁵ http://bit.ly/1QPfm4k
³⁶ Here, I have used a 100ohm resistor an a 10µF capacitor, which give a cut-off frequency of ∼ 159Hz and a V pp equal to 0.08V.
Timers 364
11.3.8 One Pulse Mode
One Pulse Mode (OPM) is a mix of the input capture and the output compare modes offered by
general purpose and advanced timers. It allows the counter to be started in response to a stimulus
and to generate a pulse with a programmable duration (PWM) after a programmable delay.
OPM is a mode designed to work exclusively with Channel 1 and 2 of a timer. We can decide which
of the two channels is the output and which is the input by using the function:
HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OnePulse_InitTypeDef* sConfig,
uint32_t OutputChannel, uint32_t InputChannel);
Both the channel are configured with an instance of the C struct TIM_OnePulse_InitTypeDef ,
which is defined in the following way:
typedef struct {
uint32_t Pulse; /* Specifies the pulse value to be loaded into the CCRx register.*/
/* Output channel configuration */
uint32_t OCMode; /* Specifies the TIM mode. */
uint32_t OCPolarity; /* Specifies the output polarity. */
uint32_t OCNPolarity; /* Specifies the complementary output polarity. */
uint32_t OCIdleState; /* Specifies the TIM Output Compare pin state during Idle state.*/
uint32_t OCNIdleState; /* Specifies the TIM Output Compare pin state during Idle state.*/
/* Input channel configuration */
uint32_t ICPolarity; /* Specifies the active edge of the input signal. */
uint32_t ICSelection; /* Specifies the input. */
uint32_t ICFilter; /* Specifies the input capture filter. */
} TIM_OnePulse_InitTypeDef;
The struct is logically divided in two parts: one related to the configuration of the input channel,
and one to the output. We will not go into the details of the struct fields, because they are similar
to what seen so far when we have talked about input capture and output compare modes.
An important aspect to understand is the way the timer computes delay and pulse durations. The
delay is computed according the following formula:
Delay =
Pulse
( TIMx _ CLK
Prescaler+1
)
[10]
while the duration (that is, the duty cycle) of the pulse is computed with this one:
Duration =
Period - Pulse
( TIMx _ CLK
Prescaler+1
)
[11]
Thismeansthat,oncetheinputchanneldetectsthetriggerevent,thetimerstartscountingandwhen
the CNT register reaches the CCRx register ( Pulse ) it generates the output signal, which lasts until
the CNT register reaches the ARR register ( Period ), that is Period - Pulse .
Timers 365
The OPM can be set as single shoot or in repetitive mode. This is performed by using the
HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode);
which accepts the pointer to the timer handler and the symbolic constant TIM_OPMODE_SINGLE to
configure OPM in single shoot or TIM_OPMODE_REPETITIVE to enable repetitive mode.
The following example shows how to configure TIM3 in OPM mode in an STM32F030 MCU.
Filename: src/main-ex10.c
12 int main(void) {
13 HAL_Init();
14
15 Nucleo_BSP_Init();
16 MX_TIM3_Init();
17
18 HAL_TIM_OnePulse_Start(&htim3, TIM_CHANNEL_1);
19
20 while (1);
21 }
22
23 /* TIM3 init function */
24 void MX_TIM3_Init(void) {
25 TIM_OnePulse_InitTypeDef sConfig;
26
27 htim3.Instance = TIM3;
28 htim3.Init.Prescaler = 47;
29 htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
30 htim3.Init.Period = 65535;
31 HAL_TIM_OnePulse_Init(&htim3, TIM_OPMODE_SINGLE);
32
33 /* Configure the Channel 1 */
34 sConfig.OCMode = TIM_OCMODE_PWM1;
35 sConfig.OCPolarity = TIM_OCPOLARITY_LOW;
36 sConfig.Pulse = 19999;
37
38 /* Configure the Channel 2 */
39 sConfig.ICPolarity = TIM_ICPOLARITY_RISING;
40 sConfig.ICSelection = TIM_ICSELECTION_DIRECTTI;
41 sConfig.ICFilter = 0;
42
43 HAL_TIM_OnePulse_ConfigChannel(&htim3, &sConfig, TIM_CHANNEL_1, TIM_CHANNEL_2);
44 }
Lines [34:36] configure the output channel in PWM Mode 1, while lines [39:41] configure the input
channel. The HAL_TIM_OnePulse_ConfigChannel() , at line 43, configures the two channels, setting
Timers 366
the Channel 1 as the output and the Channel 2 as the input. Finally the HAL_TIM_OnePulse_Start()
(called at line 18) starts the timer in OPM mode. By biasing the PA7 pin in a Nucleo-F030R8, the
timer will start after a delay of 20ms, and it will generate a PWM of about 45ms, as shown inFigure
30.
Figure 30: How the One Pulse mode works
The output channel of a timer running in One Pulse can be configured even in other modes different
than the PWM one.
11.3.8.1 Using CubeMX to Configure the OPM Mode
To enable the OPM mode using CubeMX, the first step is to configure the two Channel 1 and 2
independently, and then to select the One Pulse Mode checkbox, as shown in Figure 31. Next, from
theTIMxconfigurationview(notshownhere),itispossibletoconfiguretheotherchannelssettings.
Figure 31: How to enable the One Pulse mode in a timer
It is important to remark that, at the time of writing this chapter, the code generated by
CubeMX is not that good. The code does not use the HAL_TIM_OnePulse_ConfigChannel() ,
and each channel is configured as they would be used independently. This leads to a more
verbose and confusing code. However, it could be that when you read this chapter, ST has
already fixed this part.
Timers 367
11.3.9 Encoder Mode
Rotary encoders are devices that have a really wide range of applications. They are used to measure
the speed as well as the angular position of rotating objects. They can be used to measure RPM and
direction of a motor, to control servo-motors as well step motors, and so on. There are several types
of rotary encoders: optical, mechanical, magnetic.
Incremental encoders are a type of rotary encoders that provide cyclic output when they detect
movement. The mechanical type requires debouncing and is typically used as “digital potentiome-
ter”. Most modern home and car stereos use mechanical rotary encoders for volume control. The
incremental rotary encoder is the most widely used of all rotary encoders due to its low cost and
ability to provide signals that can be easily interpreted to provide motion related information such
as velocity.
Figure 32: The square waves emitted by a quadrature encoder on A and B channels
TheyemploytwooutputscalledAandB,whicharecalledquadratureoutputs,astheyare90degrees
out of phase, as shown in Figure 32. The direction of the motor depends if phase A leads phase B,
or phase B leads phase A. An optional third channel, index pulse, occurs once per revolution and
it is used as a reference to measure an absolute position. There are several ways to detect direction
and position of a rotary encoder. By connecting the A and B pins to two MCU I/O it is possible to
detect when the signal goes HIGH and LOW. This can be performed both manually (using interrupts
to capture when the channel changes status) or by using a timer: its channels can be configured in
input capture mode and the capture values are compared to compute the direction and speed of the
encoder.
STM32generalpurposetimersprovideaconvenientwaytoreadrotaryencoders:thismodeisindeed
calledencodermode anditsimplifiesalotthecaptureprocess.Whenatimerisconfiguredinencoder
mode, the timer counter register (TIMx_CNT) is incremented/decremented on the edge of input
channels.
Timers 368
Figure 33: How encoder speed and direction are computed by a timer in encoder mode
There are two capturing modes available: X2 and X4. In X2 mode the CNT register is increment-
ed/decremented on every edge of only one channel (either T1 or T2). In X4 mode the CNT register
is updated on every edge of both the channels: this doubles the capture frequency. The direction
of the movement is automatically derived and made available to the programmer in the TIMx_DIR
register,asshowninFigure33.Bycomparingthevalueofthecounterregisteronaregularbasis,itis
possible to derive the number of RPM, given the number of pulses the encoder emits per revolution.
Incremental mechanical encoders usually need to be debounced, due to noisy output. A comparator
is usually used as filtering stage of these devices, especially if they are used to interface motors and
other noisy devices. Under certain conditions, the input filter stage of an STM32 timer can be used
to filter the A and B channels, reducing the number of BOM components.
TheencodermodeisavailableonlyonTI1andTI2channels,anditisactivatedbyusingthefunction
HAL_TIM_Encoder_Init() and an instance of the C struct TIM_Encoder_InitTypeDef , which is
defined in the following way.
Timers 369
typedef struct {
/* T1 channel */
uint32_t EncoderMode; /* Specifies the active edge of the input signal. */
uint32_t IC1Polarity; /* Specifies the active edge of the input signal. */
uint32_t IC1Selection; /* Specifies the input. */
uint32_t IC1Prescaler; /* Specifies the Input capture prescaler. */
uint32_t IC1Filter; /* Specifies the input capture filter. */
/* T2 channel */
uint32_t IC2Polarity; /* Specifies the active edge of the input signal. */
uint32_t IC2Selection; /* Specifies the input. */
uint32_t IC2Prescaler; /* Specifies the Input capture prescaler. */
uint32_t IC2Filter; /* Specifies the input capture filter. */
} TIM_Encoder_InitTypeDef;
We have encountered the majority of the TIM_Encoder_InitTypeDef fields in the previous para-
graphs. The only remarkable one is the EncoderMode , which can assume the values TIM_ENCODER-
MODE_TI1 or TIM_ENCODERMODE_TI2 to set the X2 encoder mode on one of the two channels, and the
value TIM_ENCODERMODE_TI12 to set the X4 mode so that the TIMx_CNT register is updated on every
edge of TI1 and TI2 channels.
The following example, designed to run on a Nucleo-F030R8, simulates an incremental encoder by
using the TIM1 in output compare mode. TIM1 OC1 and OC2 (PA8, PA9) channels are routed to
TIM3 TI1 and TI2 channels (PA6, PA7) using the morpho connector, and they are configured so that
they generate two square wave signals having the same period but shifted in phase. The TIM3 is
then configured in encoder mode. The SysTick timer is used to generate the timebase: every 1s, the
number of pulses is computed, together with the encoder direction. The number of RPMs is then
derived, assuming an encoder that generates 4 pulses for every revolution. Finally, by pressing the
USER button it is possible to change the phase shift between phase A and B: this will invert the
encoder revolution.
Filename: src/main-ex11.c
22 #define PULSES_PER_REVOLUTION 4
23
24 int main(void) {
25 HAL_Init();
26
27 Nucleo_BSP_Init();
28 MX_TIM1_Init();
29 MX_TIM3_Init();
30
31 HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_ALL);
32 HAL_TIM_OC_Start(&htim1, TIM_CHANNEL_1);
33 HAL_TIM_OC_Start(&htim1, TIM_CHANNEL_2);
34
35 cnt1 = __HAL_TIM_GET_COUNTER(&htim3);
36 tick = HAL_GetTick();
Timers 370
37
38 while (1) {
39 if (HAL_GetTick() - tick > 1000L) {
40 cnt2 = __HAL_TIM_GET_COUNTER(&htim3);
41 if (__HAL_TIM_IS_TIM_COUNTING_DOWN(&htim3)) {
42 if (cnt2 < cnt1) /* Check for counter underflow */
43 diff = cnt1 - cnt2;
44 else
45 diff = (65535 - cnt2) + cnt1;
46 } else {
47 if (cnt2 > cnt1) /* Check for counter overflow */
48 diff = cnt2 - cnt1;
49 else
50 diff = (65535 - cnt1) + cnt2;
51 }
52
53 sprintf(msg, "Difference: %d\r\n", diff);
54 HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
55
56 speed = ((diff / PULSES_PER_REVOLUTION) / 60);
57
58 /* If the first three bits of SMCR register are set to 0x3
59 * then the timer is set in X4 mode (TIM_ENCODERMODE_TI12)
60 * and we need to divide the pulses counter by two, because
61 * they include the pulses for both the channels */
62 if ((TIM3->SMCR & 0x3) == 0x3)
63 speed /= 2;
64
65 sprintf(msg, "Speed: %d RPM\r\n", speed);
66 HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
67
68 dir = __HAL_TIM_IS_TIM_COUNTING_DOWN(&htim3);
69 sprintf(msg, "Direction: %d\r\n", dir);
70 HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
71
72 tick = HAL_GetTick();
73 cnt1 = __HAL_TIM_GET_COUNTER(&htim3);
74 }
75
76 if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_RESET) {
77 /* Invert rotation by swapping CH1 and CH2 CCR value */
78 tim1_ch1_pulse = __HAL_TIM_GET_COMPARE(&htim1, TIM_CHANNEL_1);
79 tim1_ch2_pulse = __HAL_TIM_GET_COMPARE(&htim1, TIM_CHANNEL_2);
80
81 __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, tim1_ch2_pulse);
82 __HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_2, tim1_ch1_pulse);
83 }
Timers 371
84 }
85 }
86
87 /* TIM1 init function */
88 void MX_TIM1_Init(void) {
89 TIM_OC_InitTypeDef sConfigOC;
90
91 htim1.Instance = TIM1;
92 htim1.Init.Prescaler = 9;
93 htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
94 htim1.Init.Period = 999;
95 HAL_TIM_Base_Init(&htim1);
96
97 sConfigOC.OCMode = TIM_OCMODE_TOGGLE;
98 sConfigOC.Pulse = 499;
99 sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
100 sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
101 sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
102 sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
103 sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
104 HAL_TIM_OC_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1);
105
106 sConfigOC.Pulse = 999; /* Phase B is shifted by 90° */
107 HAL_TIM_OC_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2);
108 }
109
110 /* TIM3 init function */
111 void MX_TIM3_Init(void) {
112 TIM_Encoder_InitTypeDef sEncoderConfig;
113
114 htim3.Instance = TIM3;
115 htim3.Init.Prescaler = 0;
116 htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
117 htim3.Init.Period = 65535;
118
119 sEncoderConfig.EncoderMode = TIM_ENCODERMODE_TI12;
120
121 sEncoderConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
122 sEncoderConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
123 sEncoderConfig.IC1Prescaler = TIM_ICPSC_DIV1;
124 sEncoderConfig.IC1Filter = 0;
125
126 sEncoderConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
127 sEncoderConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
128 sEncoderConfig.IC2Prescaler = TIM_ICPSC_DIV1;
129 sEncoderConfig.IC2Filter = 0;
130
Timers 372
131 HAL_TIM_Encoder_Init(&htim3, &sEncoderConfig);
132 }
Function MX_TIM1_Init() configures the TIM1 timer so that its OC1 and OC2 channels work in
output compare mode, triggering their output every ∼ 20μs. The two outputs are shifted in phase
by setting two different Pulse values (lines 84 and 92). The MX_TIM3_Init() function configures the
TIM3 in encoder X4 mode ( TIM_ENCODERMODE_TI12 ).
The main() function is designed so that every 1000 ticks of the SysTimer (which is configured to
generate a tick every 1ms) the current content of the counter register ( cnt2 ) is compared with a
saved value ( cnt1 ): according the encoder direction (up or down), the difference is computed, and
thespeediscalculated.Thecodeneedsalsotodetectaneventualoverflow/underflowofthecounter,
and compute the difference accordingly. Take also note that, since we are performing a comparison
every one second, TIM1 must be configured so that the sum of pulses generated by channelsA and B
should be less than 65535 per second. For this reason, we slow down TIM1 setting a Prescaler equal
to 9. Finally, lines [76:83] invert the phase shift between A and B (that is, OC1 and OC2 channels of
TIM1 timer) when the Nucleo user button is pressed.
11.3.9.1 Using CubeMX to Configure the Encoder Mode
To enable the encoder mode using CubeMX, the first step is to enable this mode from the Combined
Channels combo box, as shown in Figure 34. Next, from the TIMx configuration view (not shown
here), it is possible to configure the other channels settings.
Figure 34: How to enable the encoder mode in a timer
11.3.10 Other Features Available in General Purpose and Advanced
Timers
The features seen so far represent the most common usages of a timer. However, STM32 general
purpose and advanced timers provide other important functionalities, really useful in some specific
application domains. We will now give a quick overview to these additional capabilities. Since these
Timers 373
functionalities share common concepts found in other application shown in previous paragraphs,
we will not go too much into details of these topics (especially because it is not so easy to arrange
examples without dedicated hardware).
11.3.10.1 Hall Sensor Mode
In a brushed DC motor, brushes control the commutation by physically connecting the coils at the
correct moment. In Brush-Less DC (BLDC) motors the commutation is controlled by electronics,
using PWM. The electronics can either have position sensor inputs, which provide information
about when to commutate, or use theBack Electromotive Force ( B EF ) generated in the coils. Position
sensors are most often used in applications where the starting torque varies greatly or where a high
initialtorqueisrequired.Positionsensorsarealsooftenusedinapplicationswherethemotorisused
for positioning.
Hall-effect sensors, or simply Hall sensors, are mainly used to compute the position of three-phases
BLDC motors (one sensor for each phase). STM32 general purpose timers can be programmed to
workinHallsensormode.BysettingthefirstthreeinputinXORmode,itispossibletoautomatically
detect the position of the rotor.
This is done using the advanced-control timers (TIM1) to generate PWM signals to drive the motor
and another timer (e.g. TIM3) referred to as “interfacing timer”. This interfacing timer captures the
three timer input pins (CC1, CC2, CC3) connected through a XOR to the TI1 input channel (see
Figure 16). TIM3 is in slave mode, configured in reset mode; the slave input is TI1F_ED³⁷. Thus,
each time one of the 3 inputs toggles, the counter restarts counting from 0. This creates a time base
triggered by any change on the Hall inputs.
Onthe“interfacingtimer”(TIM3),capture/comparechannel1isconfiguredincapturemode,capture
signal is TRC (See Figure 16 - TRC is highlighted in red). The captured value, which corresponds
to the time elapsed between 2 changes on the inputs, gives information about motor speed. The
“interfacing timer” can be used in output mode to generate a pulse which changes the configuration
of the channels of the advanced-control timer (TIM1) (by triggering a COM event). The TIM1 timer
is used to generate PWM signals to drive the motor. To do this, the interfacing timer channel must
be programmed so that a positive pulse is generated after a programmed delay (in output compare
or PWM mode). This pulse is sent to the advanced timer (TIM1) through the TRGO output.
11.3.10.2 Combined Three-Phase PWM Mode and Other Motor-Control Related
Features
The ST32F3 family is the one dedicated to advanced power conversion and motor control. Some
STM32F3 MCUs, notably STM32F30x and STM32F3x8, provide the ability to generate one to three
center-aligned PWM signals with a single programmable signal ANDed in the middle of the pulses.
Moreover, they can generate up to three complementary outputs with insertion of dead time. These
features, in addition to the Hall sensor mode seen before, allow to build electronic devices suitable
for the motor control. For more information about this, refer to the AN4013³⁸ from ST.
³⁷ ED is acronyms for Edge Detector and it is an internal filtered timer input enabled when only one of the three inputs in XOR is HIGH.
³⁸ http://bit.ly/1WAewd6
Timers 374
11.3.10.3 Break Input and Locking of Timer Registers
The break input is an emergency input in the motor control application. The break function protects
power switches driven by PWM signals generated with the advanced timers. The break input is
usually connected to fault outputs of power stages and 3-phase inverters. When activated, the break
circuitry shuts down the TIM outputs and forces them to a predefined safe state.
Moreover, advanced timers offer a gradual protection of their registers, programming the LOCK bits
in the BDTR register. There are three locking levels available, which selectively lock up to all timer
register. For more information refer to the reference manual for your MCU.
11.3.10.4 Preloading of Auto-Reload Register
We have left uncommented one thing from Figure 16. The ARR register is graphically represented
with a shadow. This happens because it is preloaded, that is writing to or reading from the ARR
register accesses thepreload register. The content of thepreload register is transferred to theshadow
register(thatis,theregisterinternaltothetimerthateffectivelycontainsthecountervaluetomatch)
permanently or at each UEV event if and only if the auto-reload preload bit (APRE) is enabled in
the TIMx->CR1 register. If so, a UEV event can be generated setting the corresponding bit in the
TIMx->EGR register: this will cause that the content of the preload register is transferred in the
shadow one and the new value will be taken in account by the timer. Obviously, if you stop the
timer, you can change the content of the ARR register freely.
This is an important aspect to clarify. When a timer is stopped, we can configure the ARR register
usingthe TIM_Base_InitTypeDef.Period structure :thecontentofthe Period fieldistransferredin
the TIMx->ARR register by the HAL_TIM_Base_Init() function. This will cause that the UEV event
is generated and, if enabled, the corresponding IRQ will be raised. It is important to remark that this
happens even when the timer is configured for the first time since the peripheral was reset. Let us
consider this code:
htim6.Instance = TIM6;
htim6.Init.Prescaler = 47999; //48MHz/48000 = 1kHz
htim6.Init.Period = 4999; //1kHz / 5000 = 5s
htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
__TIM6_CLK_ENABLE();
HAL_NVIC_SetPriority(TIM6_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(TIM6_IRQn);
HAL_TIM_Base_Init(&htim6);
HAL_TIM_Base_Start_IT(&htim6);
TheabovecodeconfiguretheTIM6timersothatitexpiresafter5seconds.However,ifyourearrange
that code in a complete example, you can see that the IRQ fires almost immediately after the HAL_-
TIM_Base_Start_IT() functioniscalled.Thisisduetothefactthatthe HAL_TIM_Base_Init() routine
Timers 375
generates an UEV events to transfer the content of the TIM6->ARR register inside the internal shadow
register. This causes that the UIF flag is set and the IRQ fires when the HAL_TIM_Base_Start_IT()
enables it.
We can bypass this behaviour by setting the URS bit inside the TIMx->CR1 register: this will cause
that the UEV event is generated only when the counter reaches the overflow/underflow.
It is possible to configure the timer so that the ARR register is buffered, by setting the TIM_CR1_ARPE
bit in the TIMx->CR1 control register. This will cause that the content of the shadow register is
updated automatically. Unfortunately, the HAL does not seem to offer an explicit macro to do that,
and we need to access to the timer register at low-level:
TIM3->CR1 |= TIM_CR1_ARPE; //Enable preloading
TIM3->CR1 &= ~TIM_CR1_ARPE; //Disable preloading
Preloading is especially useful when we use a timer in output compare mode with multiple output
channels enabled and each one with its own capture value, and we have to be sure that any change
to the CCRx register takes place at the same time. This is especially true if we use a timer for motor
control or power conversion. Enabling the preload feature guarantees us that the new setting from
the CCRx register will take place on the next overflow/underflow of timer counter.
11.3.11 Debugging and Timers
During a debug session, when the execution is suspended due to a hardware or software breakpoint,
by default timers are not stopped. Sometimes is, instead, useful to stop a timer during debug,
especially if it is used to drive an external device.
STM32 timers can be selectively configured to stop when the core is halted due to a breakpoint. The
HAL macro __HAL_DBGMCU_FREEZE_TIMx() (where the x corresponds to timer number) enables this
working mode of a timer. Additionally, the outputs of the timers having complementary outputs are
disabled and forced to an inactive state. This feature is extremely useful for applications where the
timers are controlling power switches or electrical motors. It prevents the power stages from being
damaged by excessive current, or the motors from being left in an uncontrolled state when hitting
a breakpoint.
The macro __HAL_DBGMCU_UNFREEZE_TIMx() restores the default behaviour (that is, the timer does
not stop during a breakpoint).
Please, take note that, before invoking the __HAL_DBGMCU_FREEZE_TIMx() macro, the MCU
debug component (DBGMCU) must be enabled by calling the __HAL_RCC_DBGMCU_CLK_-
ENABLE() macro.
Timers 376
11.4 SysTick Timer
SysTick is a special timer, internal to the Cortex-M core, provided by all STM32 microcontrollers. It
is mainly used as timebase generator for the CubeHAL and the RTOS (if used). The most important
thing about SysTick timer is that, if used as timebase generator for the HAL, it must be configured
to generate an exception every 1ms: the exception handler will increment the system tick counter (a
global, 32-bit wide and static variable), which can be accessed by calling the HAL_GetTick() routine.
The SysTick is a 24-bit downcounter, clocked by the AHB bus (that is, it has the same frequency of
the High (speed) Clock - HCLK). Its clock speed can be eventually divided by 8 using the function:
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource);
which accepts the parameters SYSTICK_CLKSOURCE_HCLK and SYSTICK_CLKSOURCE_HCLK_DIV8 .
The SysTick update frequency is determined by the starting value of the SysTick counter, which is
configured using the function:
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb);
To configure the SysTick timer so that it generates an update event every 1ms, and assuming that it
is clocked at the same speed of the AHB bus, it is sufficient to invoke the HAL_SYSTICK_Config() in
the following way:
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
The HAL_SYSTICK_Config() routine is also responsible of enabling the timer and its SysTick_IRQn
exception³⁹. The priority of the exception can be configured at compile time setting the TICK_INT_-
PRIORITY symbolic constant in the include/stm32XXxx_hal_conf.h file, or by calling the HAL_-
NVIC_SetPriority() on the SysTick_IRQn exception, as seen in Chapter 7.
When the SysTick timer reaches zero, the SysTick_IRQn exception is raised, and the corresponding
handler is called. CubeMX already provides for us the right function body, which is defined in the
following way:
void SysTick_Handler(void) {
HAL_IncTick();
HAL_SYSTICK_IRQHandler();
}
³⁹ Remember that the SysTick_IRQn is an exception and not an interrupt, even if it is common to refer to it as interrupt. This means that
we cannot use the HAL_NVIC_EnableIRQ() function to enable it.
Timers 377
The HAL_IncTick() automatically increments the global SysTick counter, while the HAL_SYSTICK_-
IRQHandler() contains nothing more than a call to the HAL_SYSTICK_Callback() routine, which is
a callback that we can optionally implement to be notified when the timer underflows.
Read Carefully
Avoid to use slow code inside the HAL_SYSTICK_Callback() routine, otherwise the timebase
generation could be affected. This may lead to unpredictable behaviour of some HAL
modules, which rely on the exact 1ms timebase generation.
Moreover, care must be taken when using HAL_Delay() . This function provides accurate
delay (in milliseconds) based on SysTick counter. This implies that if HAL_Delay() is
called from a peripheral ISR process, then the SysTick interrupt must have higher priority
(numerically lower) than the peripheral interrupt. Otherwise the caller ISR process will be
blocked (because the global tick counter is never incremented).
To suspend the system timebase generation, it is possible to use HAL_SuspendTick() routine, while
to resume it the HAL_ResumeTick() one.
11.4.1 Use Another Timer as System Timebase Source
SysTick timer has just one relevant application: as timebase generator for the HAL or an optional
RTOS. Since the SysTick clock cannot be easily prescaled to more flexible counting frequencies, it
is not suitable to be used as a conventional timer. However, it has a relevant limitation that we will
better analyze in Chapter 23: it is not suitable to be used with tickless modes offered by some RTOS
for low-power applications. For this reason, sometimes it is important to use another timer (maybe
a LPTIM) as system timebase generator. Finally, as we will discover in Chapter 23, when using an
RTOS it is convenient to separate the timebase source for the HAL and for the RTOS.
Recent releases of the CubeMX software allow to easily use another timer instead of SysTick. To
perform this, go in the Pinout view, then open the RCC entry from the IP tree pane and select the
Timebase source, as shown in Figure 35.
Figure 35: How to select another timer as system timebase source
CubeMX will generate an additional file named stm32XXxx_hal_timebase_TIM.c containing the
definition of HAL_InitTick() (which contains all the necessary code to initialize the timer so
that it overflows every 1ms), HAL_SuspendTick() and HAL_ResumeTick() , plus the definition of
Timers 378
the HAL_TIM_PeriodElapsedCallback() , which contains the call to the HAL_IncTick() routine. This
“overriding” of the HAL routines is possible thanks to the fact that those function are defined __weak
inside the HAL source files.
11.5 A Case Study: How to Precisely Measure
Microseconds With STM32 MCUs
Sometimes, especially when dealing with communication protocols not implemented in hardware
by a peripheral, we need to precisely measure delays ranging from 1 up to a fistful of microseconds.
This leads to another more general question: how to measure microseconds precisely in STM32
MCUs?
There are several ways to do this, but some methods are more accurate and other ones are more
versatile among different MCUs and clock configurations.
Let us consider one member of the STM32F4 family: STM32F401RE. This micro is able to run up to
84MHz using internal RC clock. This means that ever 1µs, the clock cycles 84 times. So, we need a
way to count 84 clock cycles to assert that 1µs is elapsed (I am assuming that you can tolerate the
internal RC clock 1% accuracy).
Sometimes, it is common to find around delay routines like the following one:
void delay1US() {
#define CLOCK_CYCLES_PER_INSTRUCTION X
#define CLOCK_FREQ Y //IN MHZ (e.g. 16 for 16 MHZ)
volatile int cycleCount = CLOCK_FREQ / CLOCK_CYCLE_PER_INSTRUCTION;
while (cycleCount--);
}
Buthowtoestablishhowmanyclockcyclesarerequiredtocomputeonestepofthe while(cycleCount-
-) instruction? Unfortunately, it is not simple to give an answer. Let us assume that cycleCount is
equalto1.Doingsometests(IwillexplainlaterhowIhavedonethem),withcompileroptimizations
disabled (option -O0 to GCC), we can see that in this case the whole C instruction requires 24 cycles
to execute. How is it possible that? You have to figure out that our C statement is unrolled in several
assembly instructions, as we can see if we disassemble the firmware binary file:
Timers 379
...
while(counter--);
800183e: f89d 3003 ldrb.w r3, [sp, #3]
8001842: b2db uxtb r3, r3
8001844: 1e5a subs r2, r3, #1
8001846: b2d2 uxtb r2, r2
8001848: f88d 2003 strb.w r2, [sp, #3]
800184c: 2b00 cmp r3, #0
800184e: d1f6 bne.n 800183e <delay1US+0x3e>
Moreover, another source of latency is related to the fetch of instructions from internal MCU flash
(which differs a lot from “low-cost” STM32 MCUs and more powerful ones, like the STM32F4 and
STM32F7 with the ART accelerator, which is designed to zero the flash access latency). So that
instruction has a “basic cost” of 24 cycles. How many cycles are required if cycleCount is equal to
2? In this case the MCU requires 33 cycles, that is 9 additional cycles. This means that if we want
to spin for 84 cycles, cycleCount has to be equal to (84-24)/9, which is about 7. So, we can write our
delay function in a more general way:
void delayUS(uint32_t us) {
volatile uint32_t counter = 7*us;
while(counter--);
}
Testing this function with this code:
while(1) {
delayUS(1);
GPIOA->ODR = 0x0;
delayUS(1);
GPIOA->ODR = 0x20;
}
we can check, using an oscilloscope attached to PA5 pin, that we obtain the delay we are looking
for:
Timers 380
Is this way to delay 1µs consistent? Unfortunately, the answer is no. First of all, it works well only
when this specific MCU (STM32F401RE) works at full speed (84MHz). If we decide to use a different
clock speed, we need to rearrange it doing tests. Second, it is subject to compiler optimizations,
as we are going to see soon, and to CPU internal caches on D-Bus and I-Bus available in some
STM32 microcontrollers (these caches can be eventually disabled by setting the ( PREFETCH_ENABLE ,
INSTRUCTION_CACHE_ENABLE , DATA_CACHE_ENABLE in the include/stm32XXxx_hal_conf.h file).
Let us enable GCC optimizations for “size” (-Os). What results do we obtain? In this case we have
that the delayUS() function costs only 72 CPU cycles, that is ∼ 850ns. The oscilloscope confirms this:
And what happens if we enable the maximum optimization for speed (-O3)? In this case we have
only 64 CPU cycles, that is our delayUS() lasts only ∼ 750ns. However, this issue can be addressed
using specific GCC pragma directives:
#pragma GCC push_options
#pragma GCC optimize ("O0")
void delayUS(uint32_t us) {
volatile uint32_t counter = 7*us;
while(counter--);
}
#pragma GCC pop_options
However, if we want use a lower CPU frequency or we want to port our code to a different STM32
MCU, we still need to redo tests again and derive the number of cycles empirically.
However, take in account that the lower the CPU frequency is the more difficult is to delay
for 1µs precisely, because the number of cycles are fixed for a given instruction, but there is
less amount of cycles in the same unit of time.
So, how can we obtain a precise 1µs delay without doing tests if we change hardware setup?
One answer may be represented by setting a timer that overflows every 1µs (just setting its Period
to the peripheral bus speed in MHz - for example, for an STM32F401RE we need to set the Period
to (84 - 1)), and we may increment a global variable that keeps track of elapsed microseconds. This
is the same way SysTick timer is used for the timebase generation of the HAL.
Timers 381
However, this approach is impractical, especially for low-speed STM32 MCUs. Generating an
interrupt every 1µs (which in an STM32F0 MCU running at full speed would mean every 48 CPU
cycles) would congest the MCU, reducing the overall multiprogramming degree. Moreover, the
interrupt management has a non-negligible cost (from 12 up to 16 cycles), which would affect the
1µs timebase generation.
In the same way, polling the timer for the value of its counter is also impractical: a lot of time
would be spent checking the counter against a starting value, and the handling of the timer
overflow/underflow would impact on the timebase generation.
A more robust solution comes from the previous tests. How I have measured CPU cycles? Cortex-
M3/4/7 processors can have an optional debug unit, named Data Watchpoint and Tracing (DWT),
that provides watchpoints, data tracing, and system profiling for the processor. One register of this
unit is CYCCNT , which counts the number of cycles performed by CPU. So, we can use this special
unit available to count the number of cycles performed by the MCU during instruction execution.
uint32_t cycles = 0;
/* DWT struct is defined inside the core_cm4.h file */
DWT->CTRL |= 1 ; // enable the counter
DWT->CYCCNT = 0; // reset the counter
delayUS(1);
cycles = DWT->CYCCNT;
cycles--; /* We subtract the cycle used to transfer
CYCCNT content to cycles variable */
Using DWT we can build a more generic delayUS() routine in this way:
#pragma GCC push_options
#pragma GCC optimize ("O3")
void delayUS_DWT(uint32_t us) {
volatile uint32_t cycles = (SystemCoreClock/1000000L)*us;
volatile uint32_t start = DWT->CYCCNT;
do {
} while(DWT->CYCCNT - start < cycles);
}
#pragma GCC pop_options
How much precise this function is? If you are interested to the best resolution at 1µs, this function
will not help you, as shown by the scope.
Timers 382
The best performance is achieved when the higher compiler optimization level is set. As you can
see, for a wanted delay of 1µs, the function gives about 1.22µs delay (22% slower). However, if we
need to spin for 10µs, we obtain a real delay of 10.5µs (5% slower), which is more close to what we
want.
Starting from a delay of 100µs the error is completely negligible.
Why this function is not so precise? To understand why this function is less precise from the other
one, you have to figure out that we are using a series of instructions to check how many cycles are
expired since the function is started (the while condition). These instructions cost CPU cycles both
to update the internal CPU registers with the content of CYCCNT register and to do comparison and
branching. However, the advantage of this function is that it automatically detects CPU speed, and
it works out of the box especially if we are working on faster processors.
If you want full control over compiler optimizations, the best 1µs delay can be reached using this
macro fully written in assembler:
Timers 383
#define delayUS_ASM(us) do { \
asm volatile ("MOV R0,%[loops]\n \
1: \n \
SUB R0, #1\n \
CMP R0, #0\n \
BNE 1b \t" \
: : [loops] "r" (16*us) : "memory" \
); \
} while(0)
Thisisthemostoptimizedwaytowritethe while(counter--) function.Doingtestswiththescope,I
found that 1µs delay can be obtained when the MCU execute this loop 16 times at 84MHZ. However,
thismacrohastoberearrangedifyouprocessorspeedislower,andkeepinmindthatbeingamacro,
it is “expanded” every time you use it, causing the increase of firmware size.
12. Analog-To-Digital Conversion
It is quite common to interface analog peripherals to a microcontroller. In the digital era, there are
still a lot of devices that produce analog signals: sensors, potentiometers, transducers and audio
peripherals are just few examples of analog devices that generate a variable voltage, which usually
ranges in a fixed interval. By reading this voltage, we can convert it in a numerical entity useful
to be processed by our firmware. For example, the TMP36 is a quite-popular temperature sensor,
which produces a variable voltage proportional to the circuit operating voltage (it is said to give a
ratiometric output) and the ambient temperature.
All STM32 microcontrollers provide at least one Analog-to-Digital Converter (ADC), a peripheral
able to acquire several input voltages through dedicated I/O, and to convert them to a number.
The input voltage is compared against a well know and fixed voltage, also known as reference
voltage. This reference voltage can be either derived from the VDDA domain or, in MCUs with
high pin count, supplied by an external and fixed reference voltage generator (those MCUs provide
a dedicated pin named VREF+). The majority of STM32 MCUs provide a 12-bit ADC. Some of them
from the STM32F3 portfolio even a 16-bit ADC.
Differently from other STM32 peripherals seen so far, ADCs can diverge a lot between the various
STM32-series and even inside a given family. For this reason, will give only an introduction to this
useful peripheral, leaving to the reader the responsibility to analyze in depth the ADC in the specific
MCU he is considering.
Before we analyze the features offered by the ADC in an STM32 microcontroller, and the related
CubeHAL, it is best to give a quick introduction to the way this peripheral works.
12.1 Introduction to SAR ADC
InalmostallSTM32microcontrollers,theADCisimplementedasa12-bitSuccessiveApproximation
Register ADC¹. Depending on the sales type and packaged used, it can have a variable number of
multiplexed input channels (usually more then ten channels in the most of STM32 MCUs), allowing
to measure signals from external sources. Moreover, some internal channels are also available: a
channel for internal temperature sensor ( V SENSE ), one for internal reference voltage ( V REFINT ), one
for monitoring external V BAT power supply and a channel for monitoring LCD voltage in those
MCUs providing a native monochrome passive LCD controller (for example, the STM32L053 is one
of these). ADCs implemented in STM32F3 and in majority of STM32L4 MCUs are also capable of
convertingfullydifferentialinputs.Table1liststheexactADCperipheralsnumberandtheirrelated
¹ At the time of writing this chapter, the ADC provided by STM32F37x series is the only notably exception to this rule, since it provides a
more accurate 16-bit ADC with Sigma-Delta(Σ-Δ) modulator. This type of ADC will not be covered in this book. However, the HAL routines
to use it have the same organization.
Analog-To-Digital Conversion 385
input sources for all STM32 MCUs equipping the sixteen Nucleo boards we are considering in this
book.
Table 1: The availability of ADC peripheral in STM32 MCUs equipping Nucleo boards
A/D conversion of the various channels can be performed in single, continuous, scan or discontinu-
ous mode. The result of the ADC is stored in a left- or right-aligned 16-bit data register. Moreover,
the ADC also implements the analog watchdog feature, which allows the application to detect if the
input voltage goes outside the user-defined higher or lower thresholds: if this happens, a dedicated
IRQ fires.
Figure 1: The simplified structure of an ADC
Figure 1 schematizes the structure of the ADC². An input selection and scan control unit performs
the selection of the input source to the ADC. Depending on the conversion mode (single, scan or
² Figure 1 is a really simplified representation of the ADC. Since the ADC implementation can differ a lot among the several STM32
families, here we are going to consider a simplified view that clearly describes how the ADC unit is designed.
Analog-To-Digital Conversion 386
continuous mode), this unit automatically switches among the input channels, so that every one can
be sampled periodically. The output from this unit feeds the ADC.
Figure 1 also shows another important part of the ADC: the start and stop control unit. Its role is
to control the A/D conversion process, and it can be triggered by software or by a variable number
of input sources. Moreover, it is internally connected to the TRGO line of some timers so that time-
driven conversions can be automatically performed in DMA mode. We will analyze this important
mode of the ADC peripheral later.
Figure 2: The internal structure of a SAR ADC
Figure2showsthemainblocksformingtheSARADCunitshowninFigure1.Theinputsignalgoes
throughtheSHAunit.AsyoucanseeinFigure1,aswitchandacapacitorareinserieswiththeADC
input. That part represents the Sample-and-Hold (SHA) unit shown in Figure 2, which is a feature
available in all ADCs. This unit plays the important role to keep the input signal constant during
the conversion cycle. Thanks to an internal timing unit, which is regulated by a configurable clock
as we will see later, the SAR constantly connects/disconnects the input source by closing/opening
the “switch” in Figure 1. To keep the voltage level of the input constant, the SHA is implemented
with a network of capacitors: this ensure that source signal is kept at a certain level during the A/D
conversion, which is a procedure that requires a given amount of time, depending on the conversion
frequency chosen.
TheoutputfromtheSHAmodulefeedsacomparatorthatcomparesitwithanothersignalgenerated
byaninternalDAC.Theresultofcomparisonissenttothelogic unit,whichcomputesthenumerical
representation of the input signal according a well-characterized algorithm. This algorithm is what
distinguishes SAR ADC from other A/D converters.
The Successive Approximation algorithm computes the voltage of the input signal by comparing it
with the one generated by the internal DAC, which is a fraction of the V REF voltage: if the input
signal is higher than this internal reference voltage, then this is further increased until the input
signal is lower. The final result will correspond to a number ranging from zero to the maximum
12-bit unsigned integer, that is 2 12 − 1 = 4095 . Assuming V REF = 3300mV , we have that 3300mV is
represented with 4095 . This means that 1 10 =
3300
4095
≈ 0.8mV . For example, an input voltage equal to
2.5V will be converted to:
Analog-To-Digital Conversion 387
x =
4095
3300mV
× 2500mV = 3102
The SAR algorithm works in the following way:
1. The output data register is zeroed and the MSB bit is set to 1. This will correspond to a well-
defined voltage level generated by the internal DAC.
2. The output of the DAC is compared with the input signal V IN :
1. if V IN is higher, than the bit is left to 1;
2. if V IN is lower, than the bit is set back to 0;
3. The algorithm proceeds to the next MSB bit in the data register until all bits are either set to 1
or 0.
Figure 3 represents the conversion process made by the SAR logic unit inside a 4-bit ADC. Let us
consider the path highlighted in red and let us suppose that V IN = 2700mV and V REF = 3300mV . The
algorithm start by setting the MSB to 1, which corresponds to 1000 2 = 8 10 . This means that:
x =
3300mV
2 4 − 1
× 8 10 = 1760mV
Being V IN higher than 1760mV the 4th bit is left equal to 1 and the algorithm passes to the next
MSB bit. The data register is now equal to 1100 2 = 12 10 , and the DAC generates an output equal to
2640mV. Being V IN still higher than this value the 3rd bit is left again equal to 1. The register is so set
to 1110 2 = 14 10 , which leads to an internal voltage equal to 3080mV. This time V IN is lower, and the
second bit is reset to zero. The algorithm now sets the 1st bit to 1, which leads to an internal voltage
equal to 2860mV. This value is still higher than V IN and the algorithm resets the last bit to zero. The
ADC so detects that the input voltage is something close to 2640mV. Clearly, the more resolution
the ADC provides, the more close to V IN the converted value will be.
Asyoucansee,theSARalgorithmessentiallyperformsasearchinabinarytree.Thegreatadvantage
of this algorithm is that the conversion is performed in N-cycles, where N corresponds to the ADC
resolution. So a 12-bit ADC requires twelve cycles to perform a conversion. But how long a cycle
can last? The number of cycles per seconds, that is the ADC frequency, is a performance evaluation
parameter of the ADC. SAR ADCs can be really fast, especially if the ADC resolution is decreased
(less sampled bit corresponds to less cycles per conversion). However, the impedance of the analog
signal source, or series resistance ( R IN ), between the source and the MCU pin causes a voltage drop
across it because of the current flowing into the pin.
Analog-To-Digital Conversion 388
Figure 3: The conversion process made by a SAR ADC
The charging of the internal capacitor network (that we indicate with C ADC ) is controlled by the
switch in Figure 1 having a resistance equal to R ADC . With the addition of source resistance (that is,
R TOT = R ADC +R IN ), the time required to fully charge the hold capacitor increases. Figure 4 shows
the analog signal source resistance effect. The effective charging of C ADC is governed by R TOT , so
the charging time constant becomes t C = (R ADC + R IN ) × C ADC . If the sampling time is less than
the time required to fully charge the C ADC through R TOT ( t S < t C ), the digital value converted by
the ADC is less than the actual value. In general, it is necessary to wait a multiple of t C to achieve
a reasonable accuracy.
Analog-To-Digital Conversion 389
Figure 4: The effect of the ADC resistance on the analog signal source
For high speed A/D conversions, it is important to take in account the effect of the PCB layout and
proper decoupling during board design. ST provides a well-written application note, the AN2834³⁴,
which offers several and important tips to take the best from ADC integrated in STM32 MCUs.
12.2 HAL_ADC Module
After a brief introduction to the most important features offered by the ADC peripheral in STM32
microcontrollers, it is the right time to dive into the related CubeHAL APIs.
To manipulate the ADC peripheral, the HAL defines the C struct ADC_HandleTypeDef , which is
defined in the following way:
typedef struct {
ADC_TypeDef *Instance; /* Pointer to ADC descriptor */
ADC_InitTypeDef Init; /* ADC initialization parameters */
__IO uint32_t NbrOfCurrentConversionRank; /* ADC number of current conversion rank */
DMA_HandleTypeDef *DMA_Handle; /* Pointer to the DMA Handler */
HAL_LockTypeDef Lock; /* ADC locking object */
__IO uint32_t State; /* ADC communication state */
__IO uint32_t ErrorCode; /* Error code */
} ADC_HandleTypeDef;
Let us analyze the most important fields of this struct .
• Instance : is the pointer to the ADC descriptor we are going to use. For example, ADC1 is the
descriptor of the first ADC peripheral.
• Init : is an instance of the C struct ADC_InitTypeDef , which is used to configure the ADC.
We will study it more in depth in a while.
• NbrOfCurrentConversionRank : corresponds to the current i-th channel (rank) in a regular
conversion group. We will describe it better soon.
³ http://bit.ly/1rHj9ZN
⁴ The equivalent application note for the STM32F37x/38x series is the AN4207(http://bit.ly/1T8qudY).
Analog-To-Digital Conversion 390
• DMA_Handle : this is the pointer to the DMA handler configured to perform A/D conversion in
DMA mode. It is automatically configured by the __HAL_LINKDMA() macro.
ADC configuration is performed by using an instance of the C struct ADC_InitTypeDef , which is
defined in the following way⁵:
typedef struct {
uint32_t ClockPrescaler; /* Selects the ADC clock frequency */
uint32_t Resolution; /* Configures the ADC resolution mode */
uint32_t ScanConvMode; /* The scan sequence direction. */
uint32_t ContinuousConvMode; /* Specifies whether the conversion is performed in
Continuous or Single mode */
uint32_t DataAlign; /* Specifies whether the ADC data alignment
is left or right */
uint32_t NbrOfConversion; /* Specifies the number of input that will be converted
within the regular group sequencer */
uint32_t NbrOfDiscConversion; /* Specifies the number of discontinuous conversions in
which the main sequence of regular group */
uint32_t DiscontinuousConvMode; /* Specifies whether the conversion sequence of regular
group is performed in Complete-sequence/Discontinuous
sequence */
uint32_t ExternalTrigConv; /* Select the external event used to trigger the start
of conversion */
uint32_t ExternalTrigConvEdge; /* Select the external trigger edge and enable it */
uint32_t DMAContinuousRequests; /* Specifies whether the DMA requests are performed in
one shot or in continuous mode */
uint32_t EOCSelection; /* Specifies what EOC (End Of Conversion) flag is used
for conversion polling and interruption */
} ADC_InitTypeDef;
Let us analyze the most relevant field of this struct .
• ClockPrescaler :definesthespeedoftheclock(ADCCLK)fortheanalogcircuitrypartofADC.
In the previous paragraph we have seen that the ADC has an internal timing unit that controls
the switching frequency of the input switch (seeFigure 2). The ADCCLK establishes the speed
of this timing unit and it impacts on the number of samples per seconds, because it defines
the amount of time used by each conversion cycle. This clock is generated from the peripheral
clock divided by a programmable prescaler that allows the ADC to work at f PCLK /2,/4,/6 or
/8 (refer to the datasheets of the specific MCU for the maximum values of ADCCLK and its
prescaler). In some STM32 MCUs the ADCCLK can also be derived from the HSI oscillator.
The value of this field affects the ADCCLK speed of all ADCs implemented in the MCU.
⁵ The ADC_InitTypeDef struct slightly differs from the one defined in CubeF0 and CubeL0 HALs. This because the ADC in those families
doesnotprovidetheabilitytodefinecustominputsamplingsequences(byassigningrank values).Moreover,theADCinthosefamiliesprovide
the ability to perform oversampling of the input signal, and in CubeL0 HAL it is possible to enable dedicated low-power features offered by
the ADC in those MCUs. For more information, refer to the CubeHAL source code.
Analog-To-Digital Conversion 391
• Resolution : apart from STM32F1 MCUs, whose ADC does not allow to select the resolution of
samples (see Table 1), using this field it is possible to define the A/D conversion resolution. It
can assume a value from Table 2. The higher is the resolution the less number of conversions
are possible in a seconds. If speed is not relevant for your application, it is strongly suggested
to set the bit resolution to the maximum and the conversion speed to the minimum.
• ScanConvMode :thisfieldcanassumethevalue ENABLE or DISABLE anditisusedtoenable/disable
the scan conversion mode. More about this later.
• ContinuousConvMode : specifies if the conversion is performed in single or continuous mode,
and it can assume the value ENABLE or DISABLE . More about this later.
• NbrOfConversion : specifies the number of channels of the regular group that will be converted
in scan mode.
• DataAlign : specifies the data align of the converted result. ADC data register is implemented
as half-word register. Since only 12-bits are used to store the conversion, this parameters estab-
lishes how this bits are aligned inside the register. It can assume the value ADC_DATAALIGN_LEFT
or ADC_DATAALIGN_RIGHT .
• ExternalTrigConvEdge : select the external trigger source to drive conversion using a timer.
• EOCSelection : depending on the conversion mode (single or continuous conversions) the ADC
sets the End Of Conversion (EOC) flag accordingly. This field is used by the ADC polling or
interruptAPItodeterminewhenaconversioniscompleted,anditcanassumethevalues ADC_-
EOC_SEQ_CONV for continuous conversion, and ADC_EOC_SINGLE_CONV for single conversions.
Table 2: Available resolution options for the ADC
ADC resolution Description
ADC_RESOLUTION_12B ADC 12-bit resolution
ADC_RESOLUTION_10B ADC 10-bit resolution
ADC_RESOLUTION_8B ADC 8-bit resolution
ADC_RESOLUTION_6B ADC 6-bit resolution
Before we can start doing a practical example, we have to analyze another two topics: how input
channels are configured and how their input signals are sampled.
12.2.1 Conversion Modes
ADCs implemented in STM32 MCUs provide several conversion modes useful to deal with different
application scenarios. Now we are going to brief introduce the most relevant of them: the AN3116⁶
from ST describes all possible conversion modes provided by the ADC.
12.2.1.1 Single-Channel, Single Conversion Mode
ThisisthesimplestADCmode.Inthismode,theADCperformsthesingleconversion(singlesample)
of a single channel, as shown in Figure 5, and stops when conversion is finished.
⁶ http://bit.ly/1YnOr2j
Analog-To-Digital Conversion 392
Figure 5: Single-channel, single conversion mode
12.2.1.2 Scan Single Conversion Mode
This mode, also called multichannel single mode in some ST documents, is used to convert some
channels successively in independent mode. Using ranks, you can use this ADC mode to configure
any sequence of up to 16 channels successively with different sampling times and in custom orders.
You can, for example, carry out the sequence shown in Figure 6. In this way, you do not have
to stop the ADC during the conversion process in order to reconfigure the next channel with a
different sampling time. This mode saves additional CPU load and heavy software development.
Scan conversions are carried out in DMA mode.
Figure 6: Scan single conversion mode
For example, this mode can be used when starting a system depends on some parameters like
knowing the coordinates of the arm’s tip in a manipulator arm system. In this case, you have to
read the position of each articulation in the manipulator arm system at power-on to determine the
coordinates of the arm’s tip. This mode can also be used to make single measurements of multiple
signal levels (voltage, pressure, temperature, etc.) to decide if the system can be started or not in
order to protect the people and equipment.
12.2.1.3 Single-Channel, Continuous Conversion Mode
This mode converts a single channel continuously and indefinitely in regular channel conversion.
The continuous mode feature allows the ADC to work in the background. The ADC converts the
channels continuously without any intervention from the CPU. Additionally, the DMA can be used
in circular mode, thus reducing the CPU load.
Analog-To-Digital Conversion 393
Figure 7: Single-channel, continuous conversion
For example, this ADC mode can be implemented to monitor a battery voltage, the measurement
and regulation of an oven temperature using a PID, etc.
12.2.1.4 Scan Continuous Conversion Mode
This mode is also called multichannel continuous mode and it can be used to convert some channels
successivelywiththeADCinindependentmode.Usingranks,youcanconfigureanysequenceofup
to 16 channels successively with different sampling times and different orders. This mode is similar
to the multichannel single conversion mode except that it does not stop converting after the last
channel of the sequence but it restarts the conversion sequence from the first channel and continues
indefinitely. Scan conversions are carried out in DMA mode.
Figure 8: Scan continuous conversion mode
This mode may be used, for example, to monitor multiple voltages and temperatures in a multiple
battery charger. The voltage and temperature of each battery are read during the charging process.
When the voltage or the temperature reaches the maximum level, the corresponding battery should
be disconnected from the charger.
12.2.1.5 Injected Conversion Mode
This mode is intended for use when conversion is triggered by an external event or by software.
The injected group has priority over the regular channel group. It interrupts the conversion of the
current channel in the regular channel group.
Analog-To-Digital Conversion 394
Figure 9: Injected conversion mode
For example, this mode can be used to synchronize the conversion of channels to an event. It is
interesting in motor control applications where transistor switching generates noise that impacts
ADC measurements and results in wrong conversions. Using a timer, the injected conversion mode
can thus be implemented to delay the ADC measurements to after the transistor switching.
12.2.1.6 Dual Modes
Dual mode is available in STM32 microcontrollers that feature two ADCs: ADC1 master and
ADC2 slave. ADC1 and ADC2 triggers are synchronized internally for regular and injected channel
conversion. ADC1 and ADC2 work together. In some devices, there are up to 3 ADCs: ADC1, ADC2
and ADC3. In this case ADC3 always works independently, and is not synchronized with the other
ADCs.
Dual mode works so that when the conversion ends the result from ADC1 and ADC2 is simultane-
ously saved inside the ADC1 32-bit data register. By separating the two results, we can acquire the
data coming from two separated channels at the same time.
For more information regarding dual mode, refer to AN3116⁷ from ST.
12.2.2 Channel Selection
Depending on the STM32 family and package used, ADCs in STM32 MCUs can convert signals from
a variable number of channels. In F0 and L0 families the allocation of channel is fixed: the first one is
alwaysIN0,thesecondIN1andsoon.Usercandecideonlyifachannelisenabledornot.Thismeans
that in scan mode the first sampled channel will be always IN0, the second IN1 and so on. Other
⁷ http://bit.ly/1YnOr2j
Analog-To-Digital Conversion 395
STM32 MCUs, instead, offer the notion of group. A group consists of a sequence of conversions that
can be done on any channel and in any order. While input channels are fixed and bound to specific
MCU pins (that is, IN0 is the first channel, IN1 the second and so on), they can be logically reordered
to form custom sampling sequences. The reordering of channels is performed by assigning to them
an index ranging from 1 to 16. This index is called rank in the CubeHAL.
Figure 10: How input channels can be reordered using ranks
The Figure 10 shows this concept. Although the IN4 channel is fixed (for example, it is connected to
PA4pininanSTM32F401REMCU),itcanbelogicallyassignedtotherank1sothatitwillbethefirst
channel to be sampled. Those MCUs offering this possibility also allow to select the sampling speed
of each channel individually, differently from F0/L0 MCUs where the configuration is ADC-wide.
The channel/rank configuration is performed by using an instance of the C struct ADC_Channel-
ConfTypeDef , which is defined in the following way:
typedef struct {
uint32_t Channel; /* Specifies the channel to configure into ADC rank */
uint32_t Rank; /* Specifies the rank ID */
uint32_t SamplingTime; /* Sampling time value for the selected channel */
uint32_t Offset; /* Reserved for future use, can be set to 0 */
} ADC_ChannelConfTypeDef;
• Channel : specifies the channel ID. It can assume the value ADC_CHANNEL_0 , ADC_CHANNEL_-
1 … ADC_CHANNEL_N , depending the effective number of available channels.
• Rank : correspond to the rank associated to the channel. It can assume a value from 1 to 16,
which is the maximum number of user-definable ranks.
• SamplingTime : specifies the sampling time value to be set for the selected channel, and it
corresponds to the number or ADC cycles. This number cannot be arbitrary, but it is part of a
selected list of values. As we will see later, CubeMX helps a lot offering the list of admissible
values for the specific MCU you are considering.
There exist two groups for each ADC:
Analog-To-Digital Conversion 396
• A regular group, made of up to 16 channels, which corresponds to the sequence of sampled
channels during a scan conversion.
• An injected group, made of up to 4 channels, which corresponds to the sequence of injected
channel if an injected conversion is performed.
12.2.3 ADC Resolution and Conversion Speed
It is possible to perform faster conversions by reducing the ADC resolution⁸. The sampling time, in
fact, is defined by a fixed number of cycles (usually 3) plus a variable number of cycles depending
the A/D resolution. The minimum conversion time for each resolution is then as follows:
• 12 bits: 3 + ∼ 12 = 15 ADCCLK cycles
• 10 bits: 3 + ∼ 10 = 13 ADCCLK cycles
• 8 bits: 3 + ∼ 8 = 11 ADCCLK cycles
• 6 bits: 3 + ∼ 6 = 9 ADCCLK cycles
By reducing the resolution is so possible to increase the number of maximum samples per seconds,
reaching even more then 15Msps in some STM32 MCUs. Remember that the ADCCLK is derived
from the peripheral clock: this means that SYSCLK and PCLK speeds impact on the maximum
number of samples per second.
12.2.4 A/D Conversions in Polling Mode
LikethemajorityofSTM32peripherals,theADCcanbedriveninthreemodes:polling,interrupt and
DMA mode. As we will see later, a timer can eventually drive this last mode so that A/D conversions
take place at regular interval. This is extremely useful when we need to sample signals at a given
frequency, like in audio applications.
Once the ADC controller is configured by using an instance of the ADC_InitTypeDef struct passed
to the HAL_ADC_Init() routine, we can start the peripheral using the HAL_ADC_Start() function.
Depending on the conversion mode chosen, ADC will convert each selected input continuously or
once: in this case, to convert again selected inputs we need to call the HAL_ADC_Stop() function
before calling again the HAL_ADC_Start() one.
In polling mode we use the function
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout);
to determine when the A/D conversion is complete and the result is available inside the ADC data
register. The function accepts the pointer to the ADC handler descriptor and a Timeout value, which
represents the maximum time expressed in milliseconds we are willing to wait. Alternatively, we
can pass the HAL_MAX_DELAY to wait indefinitely.
To retrieve the result, we can use the function:
⁸ This is not possible in STM32F1 MCUs.
Analog-To-Digital Conversion 397
uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc);
We are now finally ready to analyze a complete example. We will start by seeing the APIs used to
perform conversions in polling mode. As you will see, there is nothing new compared to what seen
so far with other peripherals.
The example we are going to study does a simple thing: it uses the internal temperature sensor
available in all STM32 MCUs as source for the ADC. The temperature sensor is connected to an
internal ADC input. The exact input number depends on the specific MCU family and package.
For example, in an STM32F401RE MCU the temperature sensor is connected to the IN18 of ADC1
peripheral. However, the HAL is designed to abstract this specific aspect. Before we analyze the real
code, it is best to give a quick look at the electrical characteristics of the temperature sensor, which
are reported in the datasheet of the MCU you are considering.
Table 3: Electrical characteristics of the temperature sensor in an STM32F401RE MCU
Table3showsthecharacteristicsofthetemperaturesensorinanSTM32F401REMCU.Ithasatypical
accuracyof1°C⁹andanaverageslopeof2.5mV/°C.Moreover,thetemperaturesensorjunctionworks
so that at 25°C the voltage drops is 760mV. This means that, to calculate the detected temperature
we can use the formula:
Temp( ° C) =
(V SENSE − V 25 )
Avg _ Slope
+ 25 [1]
The following code shows how to perform an A/D conversion of the internal temperature sensor
output in an STM32F401RE MCU.
⁹ STM32 internal temperature sensors are factory calibrated during the IC production. Two temperatures are usually sampled at 30°C
and 110°C. They are called TS_CAL1 and TS_CAL2 respectively. The detected temperatures are stored inside the non-volatile system memory.
The exact memory address is reported in the specific datasheet. Using this data, it is possible to perform a linearization of the detected
temperatures, so that the error is leaded back in the typical accuracy value of 1°C. ST provides an application note dedicated to this topic: the
AN3964(http://bit.ly/1XfbuO6). However, keep in mind that the internal temperature sensor measures the temperature of the IC (and therefore
of the PCB). According to the specific STM32 family, the MCU running frequency, operations performed, peripherals enabled, power section
and so on, the detected temperature can be much higher than the effective ambient temperature. For example, this author have verified that
an STM32F7 MCU running at 200MHz has a working temperature of about ∼ 45°C, at a room temperature of 20°C.
Analog-To-Digital Conversion 398
Filename: src/main-ex1.c
6 /* Private variables ---------------------------------------------------------*/
7 extern UART_HandleTypeDef huart2;
8 ADC_HandleTypeDef hadc1;
9
10 /* Private function prototypes -----------------------------------------------*/
11 static void MX_ADC1_Init(void);
12
13 int main(void) {
14
15 HAL_Init();
16 Nucleo_BSP_Init();
17
18 /* Initialize all configured peripherals */
19 MX_ADC1_Init();
20
21 HAL_ADC_Start(&hadc1);
22
23 while (1) {
24 char msg[20];
25 uint16_t rawValue;
26 float temp;
27
28 HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
29
30 rawValue = HAL_ADC_GetValue(&hadc1);
31 temp = ((float)rawValue) / 4095 * 3300;
32 temp = ((temp - 760.0) / 2.5) + 25;
33
34 sprintf(msg, "rawValue: %hu\r\n", rawValue);
35 HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
36
37 sprintf(msg, "Temperature: %f\r\n", temp);
38 HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
39 }
40 }
41
42 /* ADC1 init function */
43 void MX_ADC1_Init(void) {
44 ADC_ChannelConfTypeDef sConfig;
45
46 /* Enable ADC peripheral */
47 __HAL_RCC_ADC1_CLK_ENABLE();
48
49 /* Configure the global features of the ADC (Clock, Resolution, Data Alignment and number
50 of conversion) */
51 hadc1.Instance = ADC1;
Analog-To-Digital Conversion 399
52 hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV2;
53 hadc1.Init.Resolution = ADC_RESOLUTION_12B;
54 hadc1.Init.ScanConvMode = DISABLE;
55 hadc1.Init.ContinuousConvMode = ENABLE;
56 hadc1.Init.DiscontinuousConvMode = DISABLE;
57 hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
58 hadc1.Init.NbrOfConversion = 1;
59 hadc1.Init.DMAContinuousRequests = DISABLE;
60 hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
61 HAL_ADC_Init(&hadc1);
62
63 /* Configure for the selected ADC regular channel its corresponding rank in the sequencer
64 and its sample time. */
65 sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
66 sConfig.Rank = 1;
67 sConfig.SamplingTime = ADC_SAMPLETIME_480CYCLES;
68 HAL_ADC_ConfigChannel(&hadc1, &sConfig);
69 }
Thefirstparttoanalyzeisthefunction MX_ADC1_Init() ,whichinitializestheADC1peripheral.First
ofall,atline52theADCisconfiguredsothattheADCCLK(thatis,theclockoftheanalogpartofthe
ADC) is the half of the PCLK frequency, which in an STM32F401RE running at its maximum speed
is 84MHz. Next, the ADC resolution is configured to the maximum: 12-bit. The scan conversion
mode is disabled (line 54), while the continuous conversion mode is enabled (line 55) so that we
can repeatedly poll for a conversion without stopping and then restarting the ADC. Therefore, the
EOC flag is set to ADC_EOC_SEQ_CONV at line 60. Take note that the parameter NbrOfConversion at
line 59 is completely meaningless and redundant in this case, because the single conversion mode
automatically assumes that the number of sampled channels is equal to 1.
Lines [66:68] configure the temperature sensor channel and assign it the rank 1: even if we are not
performingascanconversion,weneedtospecifytherank forthechannelused.Thesamplingtimeis
set to 480 cycles: this means that, given the clock speed of 84MHz, and considered that the ADCCLK
is set to the half of the PCLK speed, we have that an A/D conversion is performed every 10μs¹⁰.
Why we are choosing that conversion speed? The reason comes from the Table 3, which
states that the ADC sampling time, T S _ temp , is equal to 10μs to have an accuracy of 1°C. For
example, if you increase the speed to 3 cycles, by setting the SamplingTime field to ADC_-
SAMPLETIME_3CYCLES you will see that the converted result is often completely wrong.
Always in the same table you can find another interesting data: the temperature sensor start
time (that is, the time needed to stabilize the output voltage when the sensor is enabled)
ranges between 6 and 10μs. However, we do not need to take care of this aspect, since
the HAL_ADC_ConfigChannel() routine is designed to handle the startup time correctly. This
means that, the function will perform busy-wait for 10μs to allow the temperature sensor to
settle.
¹⁰ That number comes from the fact that the ADCCLK interface, running at 48MHz, performs 48 cycles every 1μs. So 480 cycles divided for
48 cycles/μs gives 10μs.
Analog-To-Digital Conversion 400
We can now focus on the main() routine. Once the ADC1 peripheral is started (line 21), we start
an infinite loop that cyclically polls the ADC for the A/D conversion. When completed, we can
retrieve the converted value and apply equation [1] to compute the temperature in Celsius degrees.
The result is finally printed on the UART2 interface.
The HAL_ADC module in the CubeF1 HAL slightly differs from the other HALs. To start a conversion
driven by software it is required that the parameter hadc.Init.ExternalTrigConv = ADC_SOFT-
WARE_START isspecifiedduringtheADCinitialization.ThiscompletelydiffersfromwhatotherHALs
do, and it is not clear why ST developers have adopted this different approach. Moreover, even
CubeMX offers a different configuration to take in account this peculiarity when it generates the
corresponding initialization code. Refer to book examples for the complete configuration procedure.
12.2.5 A/D Conversions in Interrupt Mode
Performing an A/D conversion in interrupt mode is not too much different from what seen so far.
As usual, we have to define the ISR connected to the ADC interrupt, to assign a wanted interrupt
priority and to enable the corresponding IRQ. Like all other HAL peripherals, we have to call the
HAL_ADC_IRQHandler() from the ADC ISR and to implement the callback routine HAL_ADC_ConvC-
pltCallback() , which is automatically called by the HAL when a conversion ends. Finally, all the
ADC related interrupts are enabled by starting the ADC using the HAL_ADC_Start_IT() function.
Thefollowingexamplejustshowshowtoperformaconversionininterrupt mode.Theinitialization
code for the ADC is the same used in the previous example.
int main(void) {
HAL_Init();
Nucleo_BSP_Init();
/* Initialize all configured peripherals */
MX_ADC1_Init();
HAL_NVIC_SetPriority(ADC_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(ADC_IRQn);
HAL_ADC_Start_IT(&hadc1);
while (1);
}
void ADC_IRQHandler(void) {
HAL_ADC_IRQHandler(&hadc1);
}
Analog-To-Digital Conversion 401
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
char msg[20];
uint16_t rawValue;
float temp;
rawValue = HAL_ADC_GetValue(&hadc1);
temp = ((float)rawValue) / 4095 * 3300;
temp = ((temp - 760.0) / 2.5) + 25;
sprintf(msg, "rawValue: %hu\r\n", rawValue);
HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
sprintf(msg, "Temperature: %f\r\n", temp);
HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
}
12.2.6 A/D Conversions in DMA Mode
ThemostinterestingmodetodrivetheADCperipheralistheDMAone.Thismodeallowstoperform
conversions without the intervention of the CPU and, using DMA in circular mode, we can easily
setupADCsothatitperformscontinuousconversions.Moreover,aswewilldiscovernext,thismode
isperfecttodriveconversionsusingatimer,allowingtosampleinputsignalatafixedsamplingrate.
ItisalsomandatorytousetheADCperipheralinDMAmodewhenwewanttoperformconversions
of multiple channels using scan mode.
To perform A/D conversions in DMA mode, as usual the steps involved in this process are the
following ones:
• Setup the ADC peripheral according the wanted conversion mode (scan single, scan continu-
ous, etc).
• Setup the DMA channel/stream corresponding to the ADC controller used.
• Link the DMA handler descriptor to the ADC handler using the __HAL_LINKDMA() macro.
• Enable the DMA and the IRQ associated to the DMA stream used.
• StarttheADCinDMAmodeusingthe HAL_ADC_Start_DMA() passingthereferencetothearray
used to store acquired data from the ADC.
• Be prepared to capture EOC event by defining the HAL_ADC_ConvCpltCallback() ¹¹ callback.
The following example, designed to run on an STM32F401RE MCU, shows how to perform a single
scan conversion using DMA mode. The first part we are going to analyze is the one related to the
setup of both ADC peripheral and DMA controller.
¹¹ The HAL_ADC module also provides the HAL_ADC_ConvHalfCpltCallback() callback called when half of the scan conversion sequence is
completed.
Analog-To-Digital Conversion 402
Filename: src/main-ex2.c
44 }
45
46 /* ADC1 init function */
47 void MX_ADC1_Init(void) {
48 ADC_ChannelConfTypeDef sConfig;
49
50 /* Enable ADC peripheral */
51 __HAL_RCC_ADC1_CLK_ENABLE();
52
53 /**Configure the global features of the ADC
54 */
55 hadc1.Instance = ADC1;
56 hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
57 hadc1.Init.Resolution = ADC_RESOLUTION_12B;
58 hadc1.Init.ScanConvMode = ENABLE;
59 hadc1.Init.ContinuousConvMode = DISABLE;
60 hadc1.Init.DiscontinuousConvMode = DISABLE;
61 hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
62 hadc1.Init.NbrOfConversion = 3;
63 hadc1.Init.DMAContinuousRequests = DISABLE;
64 hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
65 HAL_ADC_Init(&hadc1);
66
67 /**Configure for the selected ADC regular channels */
68 sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
69 sConfig.Rank = 1;
70 sConfig.SamplingTime = ADC_SAMPLETIME_480CYCLES;
71 HAL_ADC_ConfigChannel(&hadc1, &sConfig);
72
73 sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
74 sConfig.Rank = 2;
75 HAL_ADC_ConfigChannel(&hadc1, &sConfig);
76
77 sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
78 sConfig.Rank = 3;
79 HAL_ADC_ConfigChannel(&hadc1, &sConfig);
80 }
81
82 void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc) {
83 if(hadc->Instance==ADC1) {
84 /* Peripheral clock enable */
85 __HAL_RCC_ADC1_CLK_ENABLE();
86
87 /* Peripheral DMA init*/
88 hdma_adc1.Instance = DMA2_Stream0;
89 hdma_adc1.Init.Channel = DMA_CHANNEL_0;
Analog-To-Digital Conversion 403
90 hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
91 hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
92 hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
93 hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
94 hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
95 hdma_adc1.Init.Mode = DMA_NORMAL;
96 hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
97 hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
98 HAL_DMA_Init(&hdma_adc1);
99
100 __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc1);
101 }
102 }
103
104 void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
The MX_ADC1_Init() configures the ADC so that it perform a single scan of three inputs. The
ADCCLK is set to the lowest one (line 55), and the scan mode is enabled (line 58). As you can see,
we are configuring the ADC so that it always performs a conversion from the internal temperature
sensor: this is not useful, but unfortunately Nucleo boards do not embed analog peripherals to play
with.
The HAL_ADC_MspInit() function is automatically called by the HAL once the HAL_ADC_Init()
routine is invoked at line 65. It simply configures the DMA2 Stream0/Channel0 so that peripheral-
to-memory transfers are performed when the ADC completes a conversion. Clearly, the conversion
sequence is specified by the rank assigned to a channel. Since the ADC data register is 16-bit wide,
we configure the DMA so that a half-word transfer is performed. Finally, the HAL_ADC_ConvCplt-
Callback() function is automatically called by the HAL when the scan conversion ends (the call
to this function is triggered by the HAL_DMA_IRQHandler() invoked from the DMA2_Stream0_IRQHan-
dler() , which is not shown here). The callback sets a global variable used to signal the end of
conversion.
Filename: src/main-ex2.c
7 extern UART_HandleTypeDef huart2;
8 ADC_HandleTypeDef hadc1;
9 DMA_HandleTypeDef hdma_adc1;
10 volatile uint8_t convCompleted = 0;
11
12 /* Private function prototypes -----------------------------------------------*/
13 static void MX_ADC1_Init(void);
14
15 int main(void) {
16 char msg[20];
17 uint16_t rawValues[3];
18 float temp;
19
Analog-To-Digital Conversion 404
20 HAL_Init();
21 Nucleo_BSP_Init();
22
23 /* Initialize all configured peripherals */
24 MX_ADC1_Init();
25
26 HAL_ADC_Start_DMA(&hadc1, (uint32_t*)rawValues, 3);
27
28 while(!convCompleted);
29
30 HAL_ADC_Stop_DMA(&hadc1);
31
32 for(uint8_t i = 0; i < hadc1.Init.NbrOfConversion; i++) {
33 temp = ((float)rawValues[i]) / 4095 * 3300;
34 temp = ((temp - 760.0) / 2.5) + 25;
35
36 sprintf(msg, "rawValue %d: %hu\r\n", i, rawValues[i]);
37 HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
38
39 sprintf(msg, "Temperature %d: %f\r\n",i, temp);
40 HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
41 }
The above lines of code show the main() function. The ADC is started in DMA mode at line 26,
passing the pointer to the rawValues array and the number of conversion: this has to correspond to
the hadc1.Init.NbrOfConversion field at line 60. Finally, when the convCompleted variable is set to
1, the content of the rawValues array is converted and the result is printed on the UART2 interface.
Please take note that the HAL_ADC_Stop_DMA() is invoked at line 30: this operation is not performed
to stop the conversion (which automatically stops after the three samples but to allow successive
usages of the ADC peripheral in DMA mode (otherwise the conversion will not start).
12.2.6.1 Convert Multiple Times the Same Channel in DMA Mode
To perform a given number of conversions of the same channel (or the same channel sequence) in
DMA mode, you need to do the following way:
• Set the hadc.Init.ContinuousConvMode field to ENABLE .
• Allocate a sufficient-sized buffer.
• Pass to the HAL_ADC_Start_DMA() the number of wanted acquisitions.
12.2.6.2 Multiple and not Continuous Conversions in DMA Mode
To perform multiple conversions in DMA mode, you need to do the following steps:
• Set the hadc.Init.DMAContinuousRequests field to ENABLE .
Analog-To-Digital Conversion 405
• Call the HAL_ADC_Start_DMA() to start conversions in DMA mode.
If, instead, the hadc.Init.DMAContinuousRequests field is set to DISABLE , then you need to call
the HAL_ADC_Stop_DMA() at the end of every conversion sequence and before calling the HAL_ADC_-
Start_DMA() again. Otherwise the conversion will not start.
12.2.6.3 Continuous Conversions in DMA Mode
To perform continuous conversions in DMA mode, you need to do the following steps:
• Set the hadc.Init.ContinuousConvMode field to ENABLE .
• Set the hadc.Init.DMAContinuousRequests field to ENABLE , otherwise the ADC does not
retrigger the DMA once the first scan sequence completes.
• Configure the DMA Stream/Channel in DMA_CIRCULAR mode.
12.2.7 Errors Management
ADC peripheral has the ability to notify developers in case a conversion is lost. This error condition
happens when a continuous or scan mode conversion is ongoing and the ADC data register is
overwritten by the successive transaction before it is read. When this happens a special bit in the
ADC_SR register is set and the ADC interrupt is generated.
We can capture the overrun error by implementing the following callback:
void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc);
When the overrun error occurs, DMA transfers are disabled and DMA requests are no longer
accepted. In this case, if a DMA request is made, the regular conversion in progress is aborted and
further regular triggers are ignored. It is then necessary to clear the OVR flag and the DMAEN bit of
the used DMA stream, and to reinitialize both the DMA and the ADC to have the wanted converted
channel data transferred to the right memory location (all these operations are automatically
performed by the HAL when calling the HAL_ADC_Start_DMA() routine).
We can simulate an overrun error by enabling the continuous conversion mode in the previous
example, and setting to ENABLE the hadc.Init.DMAContinuousRequests field¹²: if the ADC interrupt
is enabled, and the HAL_ADC_IRQHandler() is invoked from it, then you will be able to catch the
overrun error.
¹² In some STM32 MCUs it is also required to explicitly enable the overrun detection by setting the hadc.Init.Overrun to ADC_OVR_DATA_-
OVERWRITTEN . Consult the HAL source code for the MCU family you are considering.
Analog-To-Digital Conversion 406
The overrun error is not only related to wrong configurations of the ADC interface. It
can be generated even when the ADC works in DMA circular mode. For a custom design
based on an STM32F4 MCU I made a while ago, where the DMA was heavily exploited by
several peripherals, I experienced that the overrun error can occur when other concurrent
transactions are performed by the DMA. Even if the bus arbitration should avoid race
conditions, especially when priorities are properly set, I experienced this error in some
non-reproducible situations. By correctly handling the overrun error I was able to restart
conversions when this happened. Needless to say that, before I realized the source of
unexpected stops in DMA conversion, I spent several days trying to debug the issue.
12.2.8 Timer-Driven Conversions
ADC peripheral can be configured to be driven from a timer through the TRGO trigger line. The
timer used to perform this operation is hardwired during the chip design. For example, in an
STM32F401RE MCU the ADC1 peripheral can be synchronized using the TIM2 timer. This feature
is extremely useful to perform ADC conversions at a given frequency. For example, we can sample
an audio wave generated by a microphone at 20kHz frequency. The result data can be then stored
in a persistent memory.
The ADC conversions can be driven by timers both in interrupt and DMA mode. The former is
useful when we sample just one channel at low frequencies. The latter is mandatory for scan mode
conversions at high frequencies. To enable timer-driven conversions you can follow this procedure:
• Configure the timer connected to the ADC through the TRGO line according the wanted
sampling frequency.
• Configure the timer’s TRGO line so that it triggers every time the update event is generated
( TIM_TRGO_UPDATE )¹³.
• Configure the ADC so that the selected timer TRGO line triggers the conversions, and be
sure that continuous conversion mode is disabled (because it is the TRGO line that fires the
conversion). Moreover, set the hadc.Init.DMAContinuousRequests field to ENABLE and the
DMA in circular mode if you want to perform N conversion at time indefinitely, or set the
hadc.Init.DMAContinuousRequests field to DISABLE if you want to stop after N conversions
are performed.
• Be sure to set the hadc.Init.ContinuousConvMode field to DISABLE , otherwise the ADC
performs conversions by its own without waiting the timer trigger.
• Start the timer.
• Start the ADC in interrupt or DMA mode.
The following example shows how to trigger a conversion every 1s in an STM32F401RE MCU using
the TIM2 timer.
¹³ Please,takenotethatitisimportanttoconfigurethetimer’sTRGOoutputmodebyusingthe HAL_TIMEx_MasterConfigSynchronization()
routine even if the timer does not work in master mode. This is a source of confusion for novice users and I have to admit that that is a little
bit counter-intuitive.
Analog-To-Digital Conversion 407
Filename: src/main-ex3.c
17 int main(void) {
18 char msg[20];
19 uint16_t rawValues[3];
20 float temp;
21
22 HAL_Init();
23 Nucleo_BSP_Init();
24
25 /* Initialize all configured peripherals */
26 MX_TIM2_Init();
27 MX_ADC1_Init();
28
29 HAL_TIM_Base_Start(&htim2);
30 HAL_ADC_Start_DMA(&hadc1, (uint32_t*)rawValues, 3);
31
32 while(1) {
33 while(!convCompleted);
34
35 for(uint8_t i = 0; i < hadc1.Init.NbrOfConversion; i++) {
36 temp = ((float)rawValues[i]) / 4095 * 3300;
37 temp = ((temp - 760.0) / 2.5) + 25;
38
39 sprintf(msg, "rawValue %d: %hu\r\n", i, rawValues[i]);
40 HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
41
42 sprintf(msg, "Temperature %d: %f\r\n",i, temp);
43 HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);
44 }
45 convCompleted = 0;
46 }
47 }
48
49 /* ADC1 init function */
50 void MX_ADC1_Init(void) {
51 ADC_ChannelConfTypeDef sConfig;
52
53 /* Enable ADC peripheral */
54 __HAL_RCC_ADC1_CLK_ENABLE();
55
56 /**Configure the global features of the ADC
57 */
58 hadc1.Instance = ADC1;
59 hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
60 hadc1.Init.Resolution = ADC_RESOLUTION_12B;
61 hadc1.Init.ScanConvMode = DISABLE;
62 hadc1.Init.ContinuousConvMode = DISABLE;
Analog-To-Digital Conversion 408
63 hadc1.Init.DiscontinuousConvMode = DISABLE;
64 hadc1.Init.ExternalTrigConv = ADC_EXTERNALTRIG2_T2_TRGO;
65 hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
66 hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
67 hadc1.Init.NbrOfConversion = 3;
68 hadc1.Init.DMAContinuousRequests = ENABLE;
69 hadc1.Init.EOCSelection = 0;
70 HAL_ADC_Init(&hadc1);
71
72 /**Configure for the selected ADC regular channels */
73 sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
74 sConfig.Rank = 1;
75 sConfig.SamplingTime = ADC_SAMPLETIME_480CYCLES;
76 HAL_ADC_ConfigChannel(&hadc1, &sConfig);
77 }
78
79 void MX_TIM2_Init(void) {
80 TIM_ClockConfigTypeDef sClockSourceConfig;
81 TIM_MasterConfigTypeDef sMasterConfig;
82
83 __HAL_RCC_TIM2_CLK_ENABLE();
84
85 htim2.Instance = TIM2;
86 htim2.Init.Prescaler = 41999; // 84MHz / 42000 = 2000
87 htim2.Init.Period = 1999;
88 htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
89 htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
90 HAL_TIM_Base_Init(&htim2);
91
92 sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
93 HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig);
94
95 sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
96 sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
97 HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);
98 }
99
100 void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
101 convCompleted = 1;
102 }
The code should be really easy to understand. The function MX_TIM2_Init() configures the TIM2
timer so that it overflow ever 1s. Moreover, the timer is configured so that the TRGO line is asserted
when it overflows (line 95). The ADC, instead, is configured to perform 3 conversions from the
same channel (the channel connected to the temperature sensor). The ADC is also configured to be
triggered from the TIM2 TRGO line (lines [65:66]). Finally, the timer is started at line 29 and the
Analog-To-Digital Conversion 409
ADC is started in DMA mode to perform 3 acquisitions from the DMA data register. The DMA
is also configured to work in circular mode. If you run the example, you can see that ever three
seconds the DMA completes the transfer and the convCompleted variable is set: this causes that the
three conversions are printed on the UART2 interface.
Owners of Nucleo boards based on STM32F410RB MCU will find a slightly different
example. This because those STM32 MCUs do not allow to trigger the ADC on the timer
update event, but only through the Capture Compare Event. For this reason, the timer is
started in output capture compare mode, as described in Chapter 11.
12.2.9 Conversions Driven by External Events
In some STM32 MCUs it is possible to configure an EXTI line to trigger A/D conversions. For
example, in an STM32F401RE MCU the EXTI line 11 can be enabled for such uses. This means
that any MCU pin connected on that line (PA11, PB11, etc.) is a valid source to trigger conversions.
Take note that it is not possible to use an EXTI line and a timer as trigger source at the same time.
12.2.10 ADC Calibration
The ADCs implemented by some STM32 families, like the STM32L4 and STM32F3 ones, provide
an automatic calibration procedure that drives all the calibration sequence including the power-
on/off sequence of the ADC. During the procedure, the ADC calculates a calibration factor, which
is 7-bit wide and which is applied internally to the ADC until the next ADC power-off. During
the calibration procedure, the application must not use the ADC and must wait until calibration
is complete. Calibration is preliminary to any ADC operation. It removes the offset error that may
vary from chip to chip due to process or bandgap variation. The calibration factor to be applied
for single-ended input conversions is different from the factor to be applied for differential input
conversions.
The HAL_ADC_Ex module provides three functions useful to work with ADC calibration. The
HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc, uint32_t SingleDiff);
automatically performs a calibration procedure. It must be called just after the HAL_ADC_Init() , and
before any HAL_ADC_Start_XXX() routine is used. Passing the parameter ADC_SINGLE_ENDED a single-
ended calibration is performed, while passing the ADC_DIFFERENTIAL_ENDED performs a differential
input calibration.
The function
Analog-To-Digital Conversion 410
uint32_t HAL_ADCEx_Calibration_GetValue(ADC_HandleTypeDef* hadc, uint32_t SingleDiff);
is used to retrieve the computed calibration value, while the
HAL_StatusTypeDef HAL_ADCEx_Calibration_SetValue(ADC_HandleTypeDef* hadc, uint32_t SingleDiff,\
uint32_t CalibrationFactor);
is used to set up a custom derived calibration value. For more information, consult the reference
manual for the MCU you are considering.
12.3 Using CubeMX to Configure ADC Peripheral
CubeMX allows to easily configure the ADC peripheral in a few steps. The first one consists in
enabling the wanted ADC channels in the IP Tree view, as shown in Figure 11.
Figure 11: The IP Tree view pane allows to select input channels of the ADC
Once the inputs are enabled, we can configure the ADC peripheral from the Configuration view, as
shown in Figure 12.
Analog-To-Digital Conversion 411
Figure 12: The ADC configuration view in CubeMX
The fields reflect the ADC configuration parameters seen so far. There is only one part that tends to
confusenoviceusers:thewaychannelsareconfigured.Infact,wefirstneedtoconfigurethenumber
ofchannelsusedbysettingtheNumberofConversionfield.Next,(thisisreallyimportant)weneed
to click elsewhere in the configuration dialog so that the number of Rank fields increases according
the specified number of channels. In those MCU providing the notion ofregular and injected groups
we can select the sampling speed for each channel independently. CubeMX will generate all the
initialization code automatically.
Asstatedbeforeinthischapter,the HAL_ADC moduleintheCubeF1HALdiffersfromtheotherHALs.
Tostartaconversiondrivenbysoftwareitisrequiredthattheparameter hadc.Init.ExternalTrigConv
= ADC_SOFTWARE_START is specified during the ADC initialization. CubeMX reflects this different
configuration, but it is tricky to understand how to configure the peripheral in the right way. So,
to enable software-driven conversion, the External Trigger Conversion Edge parameter must be
set to Trigger detection on the rising edge. This makes the field External Trigger Conversion
Source available and you have to select the entry Software trigger. Otherwise you will not be able
to perform conversions.
Analog-To-Digital Conversion 412
13. Digital-To-Analog Conversion
In the previous chapter we focused our attention on the ADC controller, showing the most relevant
characteristics of this important peripheral that all STM32 microcontrollers provide. The reverse of
this operation is demanded to the Digital to Analog Converter (DAC).
Depending on the family and package used, STM32 microcontrollers usually provide only a DAC
withoneortwodedicatedoutputs,withtheexceptionoffewpartnumbersfromtheSTM32F3-series
that implement two DACs, the first one with two outputs and the other one with just one output.
DAC channels can be configured to work in 8/12-bit mode, and the conversion of the two
channels can be performed independently or simultaneously: this last mode is useful in those
applications where two independent but synchronous signals must be generated (for example, in
audio applications). Like the ADC peripheral, even the DAC can be triggered by a dedicated timer,
in order to generate analog signals at a given frequency.
This chapter gives a quick introduction to the most relevant characteristics of this peripheral,
leaving to the reader the responsibility to deepen the features of the DAC in the specific STM32
microcontroller he is considering. As usual, we are now going to give a brief explanation about how
a DAC controller works.
13.1 Introduction to the DAC Peripheral
A DAC is a device that converts a number to an analog signal, which is proportional to a supplied
reference voltage V REF (see Figure 1). There are many categories of DACs. Some of these include
Pulse Width Modulators (PWM), interpolating, sigma-delta DACs and high speed DACs. We have
analyzed how to use an STM32 timer to generate PWM signals in Chapter 11, and we have used this
capability to generate an output sine wave with the help of a RC low-pass filter.
Figure 1: The general structure of a DAC
DACperipherals available in STM32 microcontrollers arebased on the common R-2R resistorladder
network. A resistor ladder is an electrical circuit made of repeating units of resistors, and it is
an inexpensive and simple way to perform a digital-to-analog conversion using repetitive resistor
Digital-To-Analog Conversion 414
networks, made with high-precise resistors. The network acts as a programmable voltage divider
between the reference voltage and the ground.
Figure 2: How a R-2R network can be used to convert a digital quantity to an analog signal
A 8-bit R–2R resistor ladder network is shown in Figure 2. Each bit of the DAC is driven by
digital logic gates. Ideally, these gates switch the input bit between V = 0 (logic 0) and V = V REF
(logic 1). The R–2R network causes these digital bits to be weighted in their contribution to the
output voltage V OUT . Depending on which bits are set to 1 and which to 0, the output voltage
will have a corresponding stepped value between 0 and V REF minus the value of the minimal step,
corresponding to bit 0.
For a given numeric value D , of a R–2R DAC with N bits and 0V /V REF logic levels, the output
voltage V OUT is:
V OUT =
V REF × D
2 N
[1]
For example, if N = 12 (hence 2 N = 4096) and V REF = 3.3 V (typical analog supply voltage in an
STM32 MCU), then V OUT will vary between 0V (VAL = 0 = 00000000 2 ) and the maximum (VAL =
4095 = 11111111 2 ):
V OUT = 3.3 ×
4095
4096
≈ 3.29V
with steps (corresponding to VAL = 1):
∆V OUT = 3.3 ×
1
4096
≈ 0.0002V
However, always keep in mind that the precision and stability of the DAC output is heavily affected
by the quality of VDDA power domain and the layout of PCB.
Digital-To-Analog Conversion 415
In STM32 microcontrollers, the DAC module has an accuracy of 12-bit, but it can be configured to
workin8-bittoo.In12-bitmode,thedatacouldbeleft-orright-aligned.Dependingonthesalestype
and package used, the DAC has two output channels, each one with its own converter. In dual DAC
channel mode, conversions could be done independently or simultaneously when both channels are
grouped together for synchronous update operations. An input reference pin, VREF+ (shared with
others analog peripherals) is available for better resolution. As it happens for the ADC peripheral,
even the DAC may be used in conjunction with the DMA controller to generate variable output
voltages at a given fixed frequency. This is extremely useful in audio applications, or when we want
to generate analog signals working at a given carrier frequency. As we will see later in this chapter,
the STM32 DACs have the ability to generate noise waves and triangular waves.
Finally, the DAC implemented in STM32 MCUs integrates an output buffer for each channel (see
Figure 2), which can be used to reduce the output impedance and to drive external loads directly
without having to add an external operational amplifier. Each DAC channel output buffer can be
enabled and disabled.
Table 1 lists the exact number of DAC peripherals and their related output channels for all STM32
MCUs equipping the sixteen Nucleo boards we are considering in this book.
Table 1: The availability of DAC peripheral in STM32 MCUs equipping Nucleo boards
13.2 HAL_DAC Module
After a brief introduction to the most important features offered by the DAC peripheral in STM32
microcontrollers, it is the right time to dive into the related CubeHAL APIs.
Digital-To-Analog Conversion 416
To manipulate the DAC peripheral, the HAL defines the C struct DAC_HandleTypeDef , which is
defined in the following way:
typedef struct {
DAC_TypeDef *Instance; /* Pointer to DAC descriptor */
__IO HAL_DAC_StateTypeDef State; /* DAC communication state */
HAL_LockTypeDef Lock; /* DAC locking object */
DMA_HandleTypeDef *DMA_Handle1; /* Pointer DMA handler for channel 1 */
DMA_HandleTypeDef *DMA_Handle2; /* Pointer DMA handler for channel 2 */
__IO uint32_t ErrorCode; /* DAC Error code */
} DAC_HandleTypeDef;
Let us analyze the most important fields of this struct .
• Instance : is the pointer to the DAC descriptor we are going to use. For example, DAC1 is the
descriptor of the first DAC peripheral.
• DMA_Handle{1,2} : this is the pointer to the DMA handler configured to perform D/A conver-
sions in DMA mode. In DACs with two output channels, there exist two independent DMA
handlers used to perform conversions for each channel.
As you can see, the DAC_HandleTypeDef struct differs from the other handler descriptors used so
far. In fact, it does not provide a dedicated Init parameter, used by the HAL_DAC_Init() function
to configure the DAC. This because the effective configuration of the DAC is performed at channel
level, and it is demanded to the struct DAC_ChannelConfTypeDef , which is defined in the following
way:
typedef struct {
uint32_t DAC_Trigger; /* Specifies the external trigger for the selected
DAC channel */
uint32_t DAC_OutputBuffer;/* Specifies whether the DAC channel output buffer
is enabled or disabled */
} DAC_ChannelConfTypeDef;
• DAC_Trigger : specifies the source used to trigger the DAC conversion. It can assume the value
DAC_TRIGGER_NONE when the DAC is driven manually using the HAL_DAC_SetValue() function;
the value DAC_TRIGGER_SOFTWARE when the DAC is driven in DMA mode without a timer to
“clock” the conversions; the value DAC_TRIGGER_Tx_TRGO to indicate a conversion driven by a
dedicated timer.
• DAC_OutputBuffer : enables the dedicated output buffer.
To actually configure a DAC channel, we use the function:
Digital-To-Analog Conversion 417
HAL_StatusTypeDef HAL_DAC_ConfigChannel(DAC_HandleTypeDef* hdac,
DAC_ChannelConfTypeDef* sConfig, uint32_t Channel);
whichacceptsthepointertoaninstanceofthe DAC_HandleTypeDef struct ,thepointertoaninstance
of the DAC_ChannelConfTypeDef struct seen before and the macro DAC_CHANNEL_1 to configure the
first channel and DAC_CHANNEL_2 for the second one.
In some more recent STM32 microcontrollers, like the STM32L476, the DAC also provides additional
low-power features. For example, it is possible to enable the sample-and-hold circuitry that allows
to keep the output voltage stable even if the DAC is powered off. This is extremely useful in battery-
powered applications. In these MCUs the structure of the DAC_ChannelConfTypeDef struct differs,
to allow the configuration of these additional features. Refer to the HAL source code for the MCU
you are considering.
13.2.1 Driving the DAC Manually
The DAC peripheral can be driven manually or using the DMA and a trigger source (e.g. a dedicated
timer). We are now going to analyze the first method, which is used when we do not need
conversions at high frequencies.
The first step consists in starting the peripheral by calling the function
HAL_StatusTypeDef HAL_DAC_Start(DAC_HandleTypeDef* hdac, uint32_t Channel);
The function accepts the pointer to an instance of the DAC_HandleTypeDef struct , and the channel
to activate ( DAC_CHANNEL_1 or DAC_CHANNEL_2 ).
Once the DAC channel is enabled, we can perform a conversion by calling the function:
HAL_StatusTypeDef HAL_DAC_SetValue(DAC_HandleTypeDef* hdac, uint32_t Channel,
uint32_t Alignment, uint32_t Data);
where the Alignment parameter can assume the value DAC_ALIGN_8B_R to drive the DAC in 8-bit
mode, DAC_ALIGN_12B_L or DAC_ALIGN_12B_R to drive the DAC in 12-bit mode passing the output
value left- or right-aligned respectively.
Thefollowingexample,designedtorunonaNucleo-F072RB,showshowtodrivetheDACperipheral
manually. The example is based on the fact that in the majority of Nucleo boards providing the DAC
peripheral one of the output channels corresponds to the PA5 pin, which is connected to LD2 LED.
This allows us to fade ON/OFF the LD2 using the DAC.
Digital-To-Analog Conversion 418
Filename: src/main-ex1.c
8 DAC_HandleTypeDef hdac;
9
10 /* Private function prototypes -----------------------------------------------*/
11 static void MX_DAC_Init(void);
12
13 int main(void) {
14 HAL_Init();
15 Nucleo_BSP_Init();
16
17 /* Initialize all configured peripherals */
18 MX_DAC_Init();
19
20 HAL_DAC_Init(&hdac);
21 HAL_DAC_Start(&hdac, DAC_CHANNEL_2);
22
23 while(1) {
24 int i = 2000;
25 while(i < 4000) {
26 HAL_DAC_SetValue(&hdac, DAC_CHANNEL_2, DAC_ALIGN_12B_R, i);
27 HAL_Delay(1);
28 i+=4;
29 }
30
31 while(i > 2000) {
32 HAL_DAC_SetValue(&hdac, DAC_CHANNEL_2, DAC_ALIGN_12B_R, i);
33 HAL_Delay(1);
34 i-=4;
35 }
36 }
37 }
38
39 /* DAC init function */
40 void MX_DAC_Init(void) {
41 DAC_ChannelConfTypeDef sConfig;
42 GPIO_InitTypeDef GPIO_InitStruct;
43
44 __HAL_RCC_DAC1_CLK_ENABLE();
45
46 /* DAC Initialization */
47 hdac.Instance = DAC;
48 HAL_DAC_Init(&hdac);
49
50 /**DAC channel OUT2 config */
51 sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
52 sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
53 HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_2);
Digital-To-Analog Conversion 419
54
55 /* DAC GPIO Configuration
56 PA5 ------> DAC_OUT2
57 */
58 GPIO_InitStruct.Pin = GPIO_PIN_5;
59 GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
60 GPIO_InitStruct.Pull = GPIO_NOPULL;
61 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
62 }
The code is really straightforward. Lines [40:62] configure the DAC so that the Channel 2 is used
as output channel. For this reason, the PA5 is configured as analog output (lines [58:61]). Please,
take note that since we are going to drive the DAC conversions manually, the channel trigger source
is set to DAC_TRIGGER_NONE (line 51). Finally, the main() is nothing more than an infinite loop that
increases/decreases the output voltage so that the LD2 fades ON/OFF.
13.2.2 Driving the DAC in DMA Mode Using a Timer
The most common usage of the DAC peripheral is to generate an analog waveform with a given
frequency (e.g. in audio applications). If this the case, then the best way to drive the DAC is by using
the DMA and a timer to trigger the conversions.
To start the DAC and perform a transfer in DMA mode we need to configure the corresponding
DMA channel/stream pair and use the function:
HAL_StatusTypeDef HAL_DAC_Start_DMA(DAC_HandleTypeDef* hdac, uint32_t Channel,
uint32_t* pData, uint32_t Length, uint32_t Alignment);
which accepts the pointer to an instance of the DAC_HandleTypeDef struct , the channel to activate
( DAC_CHANNEL_1 or DAC_CHANNEL_2 ), the pointer to the array of values to transfer in DMA mode, its
length, and the alignment of output values in memory, which can assume the value DAC_ALIGN_8B_R
to drive the DAC in 8-bit mode, DAC_ALIGN_12B_L or DAC_ALIGN_12B_R to drive the DAC in 12-bit
mode passing the output value left- or right-aligned respectively.
For example, we can easily generate a sinusoidal wave using the DAC. In Chapter 11 we have
analyzed how to use the PWM mode of a timer to generate sine waves. If our MCU provides a
DAC, then the same operation can be carried out more easily. Moreover, depending the specific
application, by enabling the output buffer we can avoid external passives at all.
To generate a sinusoidal wave running at a given frequency, we have to divide the complete period
in a number of steps. Usually more than 200 steps are are a good approximation for an output wave.
This means that if we want to generate a 50Hz sine wave, then we need to perform a conversion
every:
f sinewave = 50Hz ∗ 200 = 10kHz [2]
Digital-To-Analog Conversion 420
SincetheSTM32DAChasaresolutionof12-bit,wehavetodividethevalue4095,whichcorresponds
to the maximum output voltage, by 200 steps using the following formula:
DAC Output =
(
sin
(
x ·
2π
n s
)
+ 1
)( 4096
2
)
[3]
where n s is the number of samples, that is 200 in our example.
Using the above formula we can generate an initialization vector to feed the DAC in DMA mode.
LikefortheADCperipheral,wecanuseatimerconfiguredtotriggertheTRGOlineatthefrequency
given by [2]. The following example shows how to generate a 50Hz sine wave using the DAC in an
STM32F072 MCU.
Filename: src/main-ex2.c
7 #define PI 3.14159
8 #define SAMPLES 200
9
10 /* Private variables ---------------------------------------------------------*/
11 DAC_HandleTypeDef hdac;
12 TIM_HandleTypeDef htim6;
13 DMA_HandleTypeDef hdma_dac_ch1;
14
15 /* Private function prototypes -----------------------------------------------*/
16 static void MX_DAC_Init(void);
17 static void MX_TIM6_Init(void);
18
19 int main(void) {
20 uint16_t IV[SAMPLES], value;
21
22 HAL_Init();
23 Nucleo_BSP_Init();
24
25 /* Initialize all configured peripherals */
26 MX_TIM6_Init();
27 MX_DAC_Init();
28
29 for (uint16_t i = 0; i < SAMPLES; i++) {
30 value = (uint16_t) rint((sinf(((2*PI)/SAMPLES)*i)+1)*2048);
31 IV[i] = value < 4096 ? value : 4095;
32 }
33
34 HAL_DAC_Init(&hdac);
35 HAL_TIM_Base_Start(&htim6);
36 HAL_DAC_Start_DMA(&hdac, DAC_CHANNEL_1, (uint32_t*)IV, SAMPLES, DAC_ALIGN_12B_R);
37
38 while(1);
39 }
Digital-To-Analog Conversion 421
40
41 /* DAC init function */
42 void MX_DAC_Init(void) {
43 DAC_ChannelConfTypeDef sConfig;
44 GPIO_InitTypeDef GPIO_InitStruct;
45
46 __HAL_RCC_DAC1_CLK_ENABLE();
47
48 /**DAC Initialization */
49 hdac.Instance = DAC;
50 HAL_DAC_Init(&hdac);
51
52 /**DAC channel OUT1 config */
53 sConfig.DAC_Trigger = DAC_TRIGGER_T6_TRGO;
54 sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
55 HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1);
56
57 /**DAC GPIO Configuration
58 PA4 ------> DAC_OUT1
59 */
60 GPIO_InitStruct.Pin = GPIO_PIN_4;
61 GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
62 GPIO_InitStruct.Pull = GPIO_NOPULL;
63 HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
64
65 /* Peripheral DMA init*/
66 hdma_dac_ch1.Instance = DMA1_Channel3;
67 hdma_dac_ch1.Init.Direction = DMA_MEMORY_TO_PERIPH;
68 hdma_dac_ch1.Init.PeriphInc = DMA_PINC_DISABLE;
69 hdma_dac_ch1.Init.MemInc = DMA_MINC_ENABLE;
70 hdma_dac_ch1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
71 hdma_dac_ch1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
72 hdma_dac_ch1.Init.Mode = DMA_CIRCULAR;
73 hdma_dac_ch1.Init.Priority = DMA_PRIORITY_LOW;
74 HAL_DMA_Init(&hdma_dac_ch1);
75
76 __HAL_LINKDMA(&hdac,DMA_Handle1,hdma_dac_ch1);
77 }
78
79
80 /* TIM6 init function */
81 void MX_TIM6_Init(void) {
82 TIM_MasterConfigTypeDef sMasterConfig;
83
84 __HAL_RCC_TIM6_CLK_ENABLE();
85
86 htim6.Instance = TIM6;
Digital-To-Analog Conversion 422
87 htim6.Init.Prescaler = 0;
88 htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
89 htim6.Init.Period = 4799;
90 HAL_TIM_Base_Init(&htim6);
91
92 sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
93 sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
94 HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig);
95 }
The function MX_DAC_Init() configures the DAC so that the first channel performs a conversion
when the TIM6 TRGO line is generated. Moreover, the DMA is configured accordingly, setting it
in circular mode so that it transfers the content of the initialization vector in the DAC data register
continuously. The MX_TIM6_Init() function sets the TIM6 so that it overflows with a frequency
equal to 10kHz, triggering the TRGO line that is internally connected to the DAC. Finally, lines
[29:32] generate the initialization vector according the equation [3]. Its content is then used to feed
the DAC, which is started in DMA mode after the TIM6 is enabled.
Figure 3: The output sine wave generated with the DAC peripheral
By connecting an oscilloscope probe to the PA4 pin of our Nucleo board we can see the output sine
wave generate by the DAC (see Figure 3).
If we are interested in knowing when a DAC conversion in DMA mode has been completed, we can
implement the callback function:
void HAL_DACEx_ConvCpltCallbackChX(DAC_HandleTypeDef* hdac);
which is automatically called by the HAL_DMA_IRQHandler() routine invoked from the ISR of the
DMA channel associated to the DAC peripheral. The final X in the function name must be replaced
with 1 or 2 depending on the channel used.
13.2.3 Triangular Wave Generation
In several audio applications it is useful to generate triangular waves. While it is perfectly possible
to generate a triangular wave using the DMA technique seen before, STM32 DACs allow to generate
Digital-To-Analog Conversion 423
waves with a triangular shape in hardware.
Figure 4: A triangular wave generated with the DAC
TheFigure4showsthethreeparametersthatdefinetheshapeofthetriangularwave.Letusanalyze
them.
• Amplitude: it is a value ranging from 0 to 0xFFF and it determines the maximum height of the
wave. It is directly connected to the offset value, as we will see next. Amplitude cannot be an
arbitrary value, but it is part of a list of of fixed values. Consult the HAL source code for the
complete list of admissible values.
• Offset: it is the minimum output value and it represents the lowest point of the wave. The sum
of the offset and amplitude cannot exceed the maximum value of 0xFFF. This means that the
maximum amplitude of the wave will be given by the difference amplitude - offset.
• Frequency: is the frequency of the wave and it is determined by the update frequency of the
timer connected to the DAC. The update frequency of the timer is determined by the equation
[4] below. This means that if we want to generate a 50Hz triangular wave with an amplitude
equal to 2047, the prescaler of a timer running at 48MHz needs to be configured to 234.
f UEV = 2 · amplitude · f wave [4]
To generate a triangular waveform we use the function
HAL_StatusTypeDef HAL_DACEx_TriangleWaveGenerate(DAC_HandleTypeDef* hdac, uint32_t Channel,
uint32_t Amplitude);
which accepts the DAC channel to use and the wanted amplitude. The wave offset, instead, is
configured using the HAL_DAC_SetValue() routine. The full procedure to generate a triangular wave
is the following one:
• Configure the DAC channel used to generate the wave.
• Configure the timer associated to the DAC, and configure its prescaler according equation [4].
• Start the DAC using the HAL_DAC_Start() function.
• Configure the wanted offset value using the HAL_DAC_SetValue() routine.
• Start triangular wave generation by calling the HAL_DACEx_TriangleWaveGenerate() function.
Digital-To-Analog Conversion 424
13.2.4 Noise Wave Generation
STM32DACsarealsoabletogeneratenoisewaves(seeFigure5),usingapseudo-randomgenerator.
This is useful in some application domains, like audio applications and RF systems. Moreover, it can
be also used to increase the accuracy of ADC peripheral¹.
In order to generate a variable-amplitude pseudo-noise, an LFSR (linear feedback shift register) is
available in the DAC. This register is preloaded with the value 0xAAA, which may be masked
partially or totally. This value is then added up to the DAC data register contents without overflow
and this value is then used as output value.
Figure 5: a noise wave generated with the DAC
To generate the noise wave we can use the HAL routine
HAL_StatusTypeDef HAL_DACEx_NoiseWaveGenerate(DAC_HandleTypeDef* hdac, uint32_t Channel,
uint32_t Amplitude);
which accepts the channel used to generate the wave and the amplitude value, which is added to
the LFSR content to generate the pseudo-random wave. Like for the triangular wave generation, a
timer can be used to trigger conversion: this means that the frequency of the wave is determined by
the overflow frequency of the timer.
¹ ST provides the AN2668(http://bit.ly/25lJoqx) dedicated to this topic.
14. I²C
Nowadays even the simplest PCB contains two or more digital integrated circuits (IC), in addition
to the main MCU, designated to specific tasks. ADCs and DACs, EEPROM memories, sensors, logic
I/O ports, RTC clocks, RF circuits and dedicated LCD controllers are just a small list of possible
ICs specialized in doing just a single task. Modern digital electronics design is all about the right
selection (and programming) of powerful, specific and, most of the times, cheap ICs to mix on the
final PCB.
Depending on the characteristics of these ICs, they are often designed to exchange messages
and data with a programmable device (which usually is, but not limited to, a microcontroller)
according to a well-defined communication protocol. Two of the most used protocols for intra-
board communications are the I²C and the SPI, both date back to early ‘80 but still widespread in
the electronics industry, especially when communication speed is not a strict requirement and it is
limited to the PCB boundaries¹.
Almost all STM32 microcontrollers provide dedicated hardware peripherals able to communicate
using I²C and SPI protocols. This chapter is the first of two dedicated to this topic, and it briefly
introduces the I²C protocol and the related CubeHAL APIs to program this peripheral. If interested
in deepen the I²C protocol, the UM10204 by NXP² provides the complete and the most updated
specification.
14.1 Introduction to the I²C specification
The Inter-Integrated Circuit (aka I²C - pronounced I-squared-C or very rarely I-two-C) is a
hardware specification and protocol developed by the semiconductor division of Philips (now NXP
Semiconductors³) back in 1982. It is a multi-slave⁴, half-duplex, single-ended 8-bit oriented serial bus
specification,whichusesonlytwowirestointerconnectagivennumberofslavedevicestoamaster.
Until October 2006, the development of I²C-based devices was subject to the payment of royalty fees
to Philips, but this limitation has been superseded⁵.
¹ Although there exist applications where I²C and SPI protocols are used to exchange messages over external wires (usually with a length
around the meter), these specifications were not designed to guarantee the robustness of communication over potentially noisy mediums. For
this reason, their application is limited to the single PCB.
² http://bit.ly/29URmka
³ NXP acquired Freescale Semiconductor in 2015 and both companies provide Cortex-M based microcontrollers. This means that NXP
currently provides two distinct and complimentary families of Cortex-M based MCU, the LPC one coming from NXP and the Kinetis one from
Freescale. These two families are direct competitors of the STM32 portfolio, and it is not clear which of the two families will survive after
this important acquisition (keep evolving both of them is a non-sense, according this author). Although both Kinetis and LPC portfolios are
comparable with the STM32-series, this last one is probably more widespread, especially between makers and students.
⁴ The I²C can be also a multi-master protocol, meaning that two or more masters can exist on the same bus, but only one master at a time
can take the bus control and it is up to masters to arbitrate the access to the bus. In practice, it is really rare to use the I²C in multi-master mode
in embedded systems. This book does not cover the multi-master mode.
⁵ You still have to pay royalties to NXP if you want to receive an official and licensed I²C address pool for your devices, but I think that
this not the case of readers of this book.
I²C 426
Figure 1: A graphical representation of the I²C bus
The two wires forming an I²C bus are bidirectional open-drain lines, named Serial Data Line (SDA)
and Serial Clock Line (SCL) respectively (see Figure 1). The I²C protocol specifies that these two
lines need to be pulled up with resistors. The sizing of these resistors is directly connected with the
bus capacitance and the transmission speed. This document from Texas Instruments⁶ provides the
necessary math to compute the resistors value. However, it is quite common to use resistors with a
value close to 4.7KΩ.
Modern microcontrollers, like STM32 ones, allow to configure GPIO lines as open-drain
pull-up, enabling internal pull-up resistors. It is quite common to read around in the web
that you can use internal pull-ups to pull I²C lines, avoiding the usage of dedicated resistors.
However, in all STM32 devices the internal pull-up resistors have a value close to 20KΩ to
avoid unwanted power leaks. Such a value increases the time needed by the bus to reach the
HIGH state, reducing the transmission speed. If speed is not important for your application
and if (very important) you are not using long traces between the MCU and the IC (less then
2cm), then it is ok to use internal pull-up resistors for a lot of applications. But, if you have
sufficient room on the PCB to place a couple of resistors, then it is strongly suggested to use
external and dedicated ones.
Read Carefully
STM32F1 microcontrollers do not provide the ability to pull-up SDA and SCL lines. Their
GPIOs must be configured as open-drain, and two external resistors are required to pull-up
I²C lines.
Beingaprotocolbasedonjusttwowires,thereshouldbeawaytoaddressanindividualslavedevice
on the same bus. For this reason, I²C defines that each slave device provides a unique slave address
⁶ http://bit.ly/29URjoy
I²C 427
for the given bus⁷. The address may be 7- or 10-bit wide (this last option is quite uncommon).
I²C bus speeds are well-defined by the protocol specification, even if it is not so uncommon to find
chips able to talk with custom (and often fuzzy) speeds. Common I²C bus speeds are the 100kHz⁸,
also known as standard mode, and the 400kHz, known asfast mode. Recent revisions of the standard
can run at faster speeds (1MHz, known as fast mode plus, and 3.4MHz, known as high speed mode,
and 5MHz, known as ultra fast mode).
I²CprotocolisasufficientlysimpleprotocolsothataMCUcan“simulate”adedicatedI²Cperipheral
if it does not provide one: this technique is called bit-banging and it is commonly used in really
low-cost 8-bit architectures, which sometimes do not provide a dedicated I²C interface to reduce
pin-count and/or IC cost.
14.1.1 The I²C Protocol
In the I²C protocol all transactions are always initiated and completed by the master. This is one of
the few rules of this communication protocol to keep in mind while programming (and, especially,
debugging) I²C devices. All messages exchanged over the I²C bus are broken up into two types of
frame: an address frame, where the master indicates to which slave the message is being sent, and
one or more data frames, which are 8-bit data messages passed from master to slave or vice versa.
Data is placed on the SDA line after SCL goes low, and it is sampled after the SCL line goes high.
The time between clock edges and data read/write is defined by devices on the bus and it vary from
chip to chip.
As said before, both SDA and SCL are bidirectional lines, connected to a positive supply voltage via
a current-source or pull-up resistors (see Figure 1). When the bus is free, both lines are HIGH. The
output stages of devices connected to the bus must have an open-drain or open-collector to perform
the wired-AND function. The bus capacitance limits the number of interfaces connected to the bus.
For a single master application, the master’s SCL output can be a push-pull driver design if there are
no devices on the bus that would stretch the clock (more about this later).
We are now going to analyze the fundamental steps of an I²C communication.
Figure 2: The structure of a base I²C message
⁷ This constitutes one of the most practical limits of the I²C protocol. In fact, IC manufacturers rarely dedicate enough pins to configure
the full slave address used on a given board (no more than three pins are dedicated to this feature, if you are lucky, giving only eight choices
of slave addresses). When designing a board with several I²C devices, pay attention to their address and in case of collision you will need to
use two or more I²C peripherals to drive them.
⁸ There exist ICs communicating only at lower-speeds, but nowadays are uncommon.
I²C 428
14.1.1.1 START and STOP Condition
All transactions begin with a START and are terminated by a STOP (see Figure 2). A HIGH to
LOW transition on the SDA line while SCL is HIGH defines a START condition. A LOW to HIGH
transition on the SDA line while SCL is HIGH defines a STOP condition.
START and STOP conditions are always generated by the master. The bus is considered to be busy
after the START condition. The bus is considered to be free again a certain time after the STOP
condition. The bus stays busy if a repeated START (also called RESTART condition) is generated
insteadofaSTOPcondition(moreaboutthissoon).Inthiscase,theSTARTandRESTARTconditions
are functionally identical.
14.1.1.2 Byte Format
Every word transmitted on the SDA line must be eight bits long, and this also includes the address
frame as we will see in a while. The number of bytes that can be transmitted per transfer is
unrestricted. Each byte must be followed by an Acknowledge (ACK) bit. Data is transferred with
the Most Significant Bit (MSB) first (see Figure 2). If a slave cannot receive or transmit another
complete byte of data until it has performed some other function, for example servicing an internal
interrupt, it can hold the clock line SCL LOW to force the master into a wait state. Data transfer
then continues when the slave is ready for another byte of data and releases clock line SCL.
14.1.1.3 Address Frame
The address frame is always first in any new communication sequence. For a 7-bit address, the
address is clocked out most significant bit (MSB) first, followed by a R/W bit indicating whether
this is a read (1) or write (0) operation (see Figure 2).
Figure 3: The message structure in case if 10-bit addressing is used
In a 10-bit addressing system (see Figure 3), two frames are required to transmit the slave address.
The first frame will consist of the code 1111 0XXD 2 where XX are the two MSB bits of the 10-bit slave
addressand D isthe R/W bit as described above.The first frameACKbit will beasserted byall slaves
matching the first two bits of the address. As with a normal 7-bit transfer, another transfer begins
immediately, and this transfer contains bits [7:0] of the address. At this point, the addressed slave
should respond with an ACK bit. If it doesn’t, the failure mode is the same as a 7-bit system.
Note that 10-bit address devices can coexist with 7-bit address devices, since the leading 11110 part
of the address is not a part of any valid 7-bit addresses.
I²C 429
14.1.1.4 Acknowledge (ACK) and Not Acknowledge (NACK)
The ACK takes place after every byte. The ACK bit allows the receiver to signal the transmitter⁹
that the byte was successfully received and another byte may be sent. The master generates all
clock pulses over the SCL line, including the ACK ninth clock pulse.
The ACK signal is defined as follows: the transmitter releases the SDA line during the acknowledge
clock pulse so that the receiver can pull the SDA line LOW and it remains stable LOW during
the HIGH period of this clock pulse. When SDA remains HIGH during this ninth clock pulse, this
is defined as the Not Acknowledge (NACK) signal. The master can then generate either a STOP
condition to abort the transfer, or a RESTART condition to start a new transfer. There are five
conditions leading to the generation of a NACK:
1. No receiver is present on the bus with the transmitted address so there is no device to respond
with an acknowledge.
2. The receiver is unable to receive or transmit because it is performing some real-time function
and is not ready to start communication with the master.
3. During the transfer, the receiver gets data or commands that it does not understand.
4. During the transfer, the receiver cannot receive any more data bytes.
5. A master-receiver must signal the end of the transfer to the slave transmitter.
The effectiveness of the ACK/NACK bit is due to the open-drain nature of the I²C protocol.
Open-drain means that both master and slave involved in a transaction can pull the
corresponding signal line LOW, but cannot drive it HIGH. If one between the transmitter
and receiver releases a line, it is automatically pulled HIGH by the corresponding resistor if
the other does not pull it LOW. The open-drain nature of the I²C protocol also ensures that
can be no bus contention where one device is trying to drive the line HIGH while another
tries to pull it LOW, eliminating the potential for damage to the drivers or excessive power
dissipation in the system.
14.1.1.5 Data Frames
After the address frame has been sent, data can begin being transmitted. The master will simply
continue generating clock pulses on SCL at a regular interval, and the data will be placed on SDA by
eitherthemasterortheslave,dependingonwhethertheR/Wbitindicatedareadorwriteoperation.
Usually,thefirstorthefirsttwobytescontainstheaddressoftheslaveregistertowriteto/readfrom.
For example, for I²C EEPROMs the first two bytes following the address frame represent the address
of the memory location involved in the transaction.
Depending on the R/W bit, the successive bytes are filled by the master (if the R/W bit is set to 1)
or the slave (if R/W bit is 0). The number of data frames is arbitrary, and most slave devices will
⁹ Please,takenotethatherewearegenericallytalkingaboutreceiver andtransmitter becauseACK/NACKbitcanbesetbyboththemaster
and the slave.
I²C 430
auto-increment the internal register, meaning that subsequent reads or writes will come from the
next register in line. This mode is also called sequential or burst mode (see Figure 4) and it is a way
to speed up transfer speed.
Figure 4: A transmission in burst mode where multiple bytes are exchanged in one transaction
14.1.1.6 Combined Transactions
The I²C protocol essentially has a simple communication pattern:
• a master sends on the bus the address of the slave device involved in the transaction;
• the R/W bit, which is the LSB bit in the slave address byte, establishes the direction of data
flow (from master to slave - W - or from slave to master - R)
• a number of bytes are sent, each one interleaved with an ACK bit, by one of the two peers
according to the transfer direction, until a STOP condition occurs.
This communication schema has a great pitfall: if we want to ask something specific to the slave
device we need to use two separated transactions. Let us consider this example. Suppose we have an
I²C EEPROM. Usually this kind of devices has a number of addressable memory locations (a 64Kbits
EEPROM is addressable in the range 0 - 0x1FFF ¹⁰). To retrieve the content of a memory location,
the master should perform the following steps:
• start a transaction in write mode (last bit of the slave address set to 0) by sending the slave
address on the I²C bus so that the EEPROM begins sampling the messages over the bus;
• send two bytes representing the memory location we want to read;
• end a transaction by sending a STOP condition;
• start a new transaction in read mode (last bit of the slave address set to 1) by sending the slave
address on the I²C bus;
• read n-bytes (usually one if reading the memory in random mode, more than one if reading
it in sequential mode) sent by the slave device and then ending the transaction with a STOP
condition.
¹⁰ That values come from the fact that 64Kbits are equal to 65536 bits, but every memory location is 8-bit wide, so 65536/8 = 8196 = 0x2000.
Since the memory locations starts from 0, then the last one has the 0x1FFF address.
I²C 431
Figure 5: The structure of a combined transaction
Tosupportthiscommoncommunicationschema,theI²Cprotocoldefinesthecombinedtransactions,
where the direction of data flow is inverted (usually from slave to master, or vice versa) after a
number of bytes have been transmitted. Figure 5 schematizes this way to communicate with slave
devices. The master starts sending the slave address in write mode (note theW in red-bold inFigure
5) and then sends the addresses of registers we want to read. Then a new START condition is sent,
without terminating the transaction: this additional START condition is also called repeated START
condition (or RESTART). The master sends again the slave address but this time the transaction is
started in read mode (note the R in bold in Figure 5). The slave now transmits the content of wanted
registers, and the master acknowledges every byte sent. The master ends the transaction by issuing
a NACK (this is really important, as we will see next) and a STOP condition.
14.1.1.7 Clock Stretching
Sometimes, the master data rate will exceed the slave ability to provide that data. This happens
because the data isn’t ready yet (for example, the slave hasn’t completed an analog-to-digital
conversion) or because a previous operation hasn’t yet completed (say, an EEPROM which hasn’t
completed writing to non-volatile memory yet and needs to finish that before it can service other
requests).
Inthiscase,someslavedeviceswillexecutewhatisreferredtoasclockstretching.Inclockstretching
the slave pauses a transaction by holding the SCL line LOW. The transaction cannot continue until
the line is released HIGH again. Clock stretching is optional and most slave devices do not include
an SCL driver so they are unable to stretch the clock (mainly to simplify the hardware layout of the
I²Cinterface).Aswewilldiscoverlater,anSTM32MCUconfiguredinI²Cslavemodecanoptionally
implement the clock stretching mode.
14.1.2 Availability of I²C Peripherals in STM32 MCUs
Depending on the family type and package used, STM32 microcontrollers can provide up to four
independent I²C peripherals. Table 1 summarizes the availability of I²C peripherals in STM32 MCUs
equipping all sixteen Nucleo boards we are considering in this book.
I²C 432
Table 1: Effective availability of I²C peripherals in MCUs equipping all sixteen Nucleo boards
For every I²C peripheral, and a given STM32 MCU, Table 1 shows the pins corresponding to SDA
and SCL lines. Moreover, darker rows show alternate pins that can be used during the layout of the
board. For example, given the STM32F401RE MCU, we can see that I2C1 peripheral is mapped to
PB7 and PB6, but PB9 and PB8 can be also used as alternate pins. Note that the I2C1 peripheral uses
the same I/O pins in all STM32 MCUs with LQFP-64 package. This is a paramount example of the
pin-to-pin compatibility offered by STM32 microcontrollers.
We are now ready to see how-to use the CubeHAL APIs to program this peripheral.
I²C 433
14.2 HAL_I2C Module
To program the I²C peripheral, the CubeHAL defines the C struct I2C_HandleTypeDef , which is
defined in the following way:
typedef struct {
I2C_TypeDef *Instance; /* I²C registers base address */
I2C_InitTypeDef Init; /* I²C communication parameters */
uint8_t *pBuffPtr; /* Pointer to I²C transfer buffer */
uint16_t XferSize; /* I²C transfer size */
__IO uint16_t XferCount; /* I²C transfer counter */
DMA_HandleTypeDef *hdmatx; /* I²C Tx DMA handle parameters */
DMA_HandleTypeDef *hdmarx; /* I²C Rx DMA handle parameters */
HAL_LockTypeDef Lock; /* I²C locking object */
__IO HAL_I2C_StateTypeDef State; /* I²C communication state */
__IO HAL_I2C_ModeTypeDef Mode; /* I²C communication mode */
__IO uint32_t ErrorCode; /* I²C Error code */
} I2C_HandleTypeDef;
Let us analyze the most important fields of this C struct .
• Instance : is the pointer to the I²C descriptor we are going to use. For example, I2C1 is the
descriptor of the first I²C peripheral.
• Init : is an instance of the C struct I2C_InitTypeDef used to configure the peripheral. We
will study it more in depth in a while.
• pBuffPtr : pointer to the internal buffer used to temporarily store data transferred to and from
the I²C peripheral. This is used when the I²C works in interrupt mode and should be not
modified from the user code.
• hdmatx , hdmarx : pointer to instances of the DMA_HandleTypeDef struct used when the I²C
peripheral works in DMA mode.
The setup of the I²C peripheral is performed by using an instance of the C struct I2C_InitTypeDef ,
which is defined in the following way:
I²C 434
typedef struct {
uint32_t ClockSpeed; /* Specifies the clock frequency */
uint32_t DutyCycle; /* Specifies the I²C fast mode duty cycle. */
uint32_t OwnAddress1; /* Specifies the first device own address. */
uint32_t OwnAddress2; /* Specifies the second device own address if dual addressing
mode is selected */
uint32_t AddressingMode; /* Specifies if 7-bit or 10-bit addressing mode is selected. */
uint32_t DualAddressMode; /* Specifies if dual addressing mode is selected. */
uint32_t GeneralCallMode; /* Specifies if general call mode is selected. */
uint32_t NoStretchMode; /* Specifies if nostretch mode is selected. */
} I2C_InitTypeDef;
These are the functions of the most relevant fields of this C struct .
• ClockSpeed : this field specifies the speed of the I²C interface and it should correspond to bus
speeds defined in the I²C specifications (standard mode, fast mode, and so on). However, the
exact value of this field is also a function of the DutyCycle one, as we will see next. The
maximum value for this field is, for the majority of STM32 microcontrollers, 400000 (400kHz),
meaning that STM32 MCUs can support up to the fast mode. STM32F0/F3/F7/L0/L4 MCUs
constitute an exception to this rule (see Table 1), and they support also the fast mode plus
(1MHz). In these other MCUs, ClockSpeed field is replaced with another one called Timing .
The configuration value for the Timing field is computed differently, and we will not cover it
here. ST provides a dedicated application note (AN4235¹¹) that explains how to compute the
exact value for this field according to the wanted I²C bus speed. However, CubeMX is able to
generate the right configuration value for you.
Table 2: Characteristics of the SDA and SCL bus lines for standard, fast, and fast-mode plus I²C-bus devices
• DutyCycle : this field, which is available only in those MCU not supporting the fast mode plus
communication speed, specifies the ratio between t LOW and t HIGH of the I²C SCL line. It can
assume the values I2C_DUTYCYCLE_2 and I2C_DUTYCYCLE_16_9 to indicate a duty cycle equal to
2:1 and 16:9. By choosing a given clock duty we can “prescale” the peripheral clock to achieve
the wanted I²C clock speed. To better understand the role of this configuration parameter, we
need to review some fundamental concepts of the I²C bus. In Chapter 11 we have seen that
the duty cycle is the percentage of one period of time (for example, 10μs) in which a signal is
active. For every I²C bus speed, the I²C specification precisely defines the minimum t LOW and
¹¹ http://bit.ly/2bxBoP1
I²C 435
t HIGH values. Table 2, extracted from the UM10204 by NXP¹², shows t LOW and t HIGH values
for the given communication speed (values have been highlighted in yellow in Table 2). The
ratio of these two values is the duty cycle, which is independent of the communication speed.
For example, a 100kHz period corresponds to 10μs, but t HIGH + t LOW from the Table 2 is less
than 10μs (4μs+4.7μs=8.7μs). Thus, the ratio of the actual values can vary as long as the t LOW
and t HIGH minimum timings are met (4.7μs and 4μs respectively). The point of these ratios is to
illustrate that I²C timing constraints are different between I²C modes. They aren’t mandatory
ratios that STM32 I²C peripherals need to keep. For example, t HIGH = 4s and t LOW = 6s would
be a 0.67 ratio, which is still compatible with timings of the standard mode (100kHz) (because
t HIGH = 4s and t LOW > 4.7s , and their sum is equal to 10μs). The I²C peripherals in STM32
MCUs define the following duty cycles (ratios). For standard mode the ratio is fixed to 1:1.
This means that t LOW = t HIGH = 5s . For fast mode we can use two ratios: 2:1 or 16:9. 2:1
ratio means that 4μs (=400kHz) are obtained with t LOW = 2.66s and t HIGH = 1.33s and both
the values are higher than the one reported in Table 2 (0.6μs and 1.3μs). A 16:9 ratio means
that 4μs are obtained with t LOW = 2.56s and t HIGH = 1.44s and both the values are still higher
than the one reported in Table 2. When to use a 2:1 ratio instead of the 16:9 one and vice
versa? It depends on the peripheral clock (PCLK1) frequency. A 2:1 ratio means that 400MHz
are achieved by dividing the clock source by three (1+2). This means that the PCLK1 must be a
multiple of 1.2MHz (400kHz * 3). Using a 16:9 ratio means that we are dividing the PCLK1 by
25. That means we can obtain the maximum I²C bus frequency when the PCLK1 is a multiple
of10MHz(400kHz*25).So,therightselectionofthedutycyclesdependsontheeffectivespeed
of the APB1 bus, and the wanted (maximum) I²C SCL frequency. It is important to underline
that, even if the SCL frequency is lower than 400kHz (for example, using a ratio equal to 16:9
while having a PCLK1 frequency of 8MHz we can reach a maximum communication speed
equal to 360kHz) we still satisfy the requirements of the I²C fast mode specification (400kHz
are an upper limit).
• OwnAddress1 , OwnAddress2 : the I²C peripheral in STM32 MCUs can be used to develop both
master and slave I²C devices. When developing I²C slave devices, the OwnAddress1 field allows
to specify the I²C slave address: the peripheral automatically detects the given address on the
I²C bus, and it automatically triggers all the related events (for example, it can generate the
corresponding interrupt so that the firmware code can start a new transaction on the bus). I²C
peripheral supports 7- or 10-bit addressing, as well as the 7-bit dual addressing mode: in this
case we can specify two distinct 7-bit slave addresses, so that the device is able to answer to
requests sent to both addresses.
• AddressingMode : this field can assume the values I2C_ADDRESSINGMODE_7BIT or I2C_ADDRESS-
INGMODE_10BIT to specify 7- or 10-bit addressing mode respectively.
• DualAddressMode : this field can assume the values I2C_DUALADDRESS_ENABLE or I2C_DUALAD-
DRESS_DISABLE to enable/disable the 7-bit dual addressing mode.
• GeneralCallMode : the General Call is a sort of broadcast addressing in the I²C protocol. A
special I²C slave address, 0x0000 000 , is used to send a message to all devices on the same bus.
General call is an optional feature and, by setting this field to the I2C_GENERALCALL_ENABLE
¹² http://bit.ly/29URmka
I²C 436
value, the I²C peripheral will generate events when the general call address is matched. We
will not treat this mode in this book.
• NoStretchMode : this field, which can assume the values I2C_NOSTRETCH_ENABLE or I2C_NOS-
TRETCH_DISABLE is used to disable/enable the optional clock stretching mode (take note that
by setting it to I2C_NOSTRETCH_ENABLE you disable the clock stretching mode). For more
information about this optional I²C mode, refer to UM10204 by NXP¹³ and to the reference
manual for your MCU.
As usual, to configure the I²C peripheral we use the function:
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c);
which accepts a pointer to an instance of the I2C_HandleTypeDef seen before.
14.2.1 Using the I²C Peripheral in Master Mode
We are now going to analyze the main routines provided by the CubeHAL to use the I²C peripheral
in master mode. To perform a transaction over the I²C bus in write mode, the CubeHAL provides
the function:
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
uint8_t *pData, uint16_t Size, uint32_t Timeout);
where:
• hi2c : it is the pointer to an instance of the struct I2C_HandleTypeDef seen before, which
identifies the I²C peripheral;
• DevAddress : it is the address of the slave device, which can be 7- or 10-bits long depending on
the specific IC;
• pData : it is the pointer to an array, with a length equal to the Size parameter, containing the
sequence of bytes we are going to transmit;
• Timeout : represents the maximum time, expressed in milliseconds, we are willing to wait for
the transmit completion. If the transmission does not complete in the specified timeout time,
the function aborts and returns the HAL_TIMEOUT value; otherwise it returns the HAL_OK value if
no other errors occur. Moreover, we can pass a timeout equal to HAL_MAX_DELAY ( 0xFFFF FFFF )
to wait indefinitely for the transmit completion.
To perform a transaction in read mode we can use, instead, the following function:
¹³ http://bit.ly/29URmka
I²C 437
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
uint8_t *pData, uint16_t Size, uint32_t Timeout);
Both the previous functions perform the transaction in polling mode. For interrupt based transac-
tions, we can use the functions:
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
uint8_t *pData, uint16_t Size); \
HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
uint8_t *pData, uint16_t Size);
These functions work in the same way of other routines seen in previous chapters (for example,
those one related to UART transmission in interrupt mode). To use them correctly, we need to
enable the corresponding ISR and to place a call to the HAL_I2C_EV_IRQHandler() routine, which in
turn calls the HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c) to signal the completion
of the transfer in write mode, or the HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
to signal the end of a transfer in read mode. Except for STM32F0 and STM32L0 families, the I²C
peripheral in all STM32 MCUs uses a separated interrupt to signal error conditions (take a look at
the vector table related to your MCU). For this reason, in the corresponding ISR we need to call
the HAL_I2C_ER_IRQHandler() , which in turn calls the HAL_I2C_ErrorCallback(I2C_HandleTypeDef
*hi2c) in case of an error. There exist ten different callbacks invoked by the CubeHAL. The Table
3 lists all of them, together with the ISR that invokes the callback.
Table 3: CubeHAL available callbacks when an I²C peripheral works in interrupt or DMA mode
Callback Calling ISR Description
HAL_I2C_MasterTxCpltCallback() I2Cx_EV_IRQHandler() Signals that the transfer from master to
slave is completed (peripheral working in
master mode).
HAL_I2C_MasterRxCpltCallback() I2Cx_EV_IRQHandler() Signals that the transfer from slave to
master is completed (peripheral working in
master mode).
HAL_I2C_SlaveTxCpltCallback() I2Cx_EV_IRQHandler() Signals that the transfer from slave to
master is completed (peripheral working in
slave mode).
HAL_I2C_SlaveRxCpltCallback() I2Cx_EV_IRQHandler() Signals that the transfer from master to
slave is completed (peripheral working in
slave mode).
HAL_I2C_MemTxCpltCallback() I2Cx_EV_IRQHandler() Signals that the transfer from master to an
external memory is completed (this is called
only when HAL_I2C_Mem_xxx() routines are
used and the peripheral works in master
mode).
I²C 438
Table 3: CubeHAL available callbacks when an I²C peripheral works in interrupt or DMA mode
Callback Calling ISR Description
HAL_I2C_MemRxCpltCallback() I2Cx_EV_IRQHandler() Signals that the transfer from an external
memory to the master is completed (this is
called only when HAL_I2C_Mem_xxx()
routines are used and the peripheral works
in master mode).
HAL_I2C_AddrCallback() I2Cx_EV_IRQHandler() Signals that the master has placed the
peripheral slave address on the bus
(peripheral working in slave mode).
HAL_I2C_ListenCpltCallback() I2Cx_EV_IRQHandler() Signals that the listen mode is completed
(this happens when a STOP condition is
issued and the peripheral works in slave
mode - more about this later).
HAL_I2C_ErrorCallback() I2Cx_ER_IRQHandler() Signals that an error condition is occurred
(peripheral working both in master and
slave mode).
HAL_I2C_AbortCpltCallback() I2Cx_ER_IRQHandler() Signals that a STOP condition has been
raised and the I²C transaction has been
aborted (peripheral working both in master
and slave mode).
Finally, the functions:
HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c,uint16_t DevAddress,
uint8_t *pData, uint16_t Size);
HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
uint8_t *pData, uint16_t Size);
allow to perform I²C transactions using DMA.
Tomakecompleteandfullworkingexamplesweneedanexternaldeviceabletointeractthroughthe
I²C bus, since Nucleo boards do not provide such peripherals. For this reason we will use an external
EEPROMmemory:the24LCxx.ThisisareallypopularfamilyofserialEEPROMs,whicharebecome
a sort of standard in electronics industry. They are cheap (cost usually few tens of cents), they are
produced in several packages (ranging from “old” THT P-DIP packages, up to modern and compact
WLCP ones), they provide a data retention for more than 200 years and individual pages can be
erased more 1 million of times. Moreover, a lot of silicon manufacturers have their own compatible
versions (ST also provides its own set of 24LCxx compatible EEPROMs). These memories have the
same popularity of 555 timers, and I bet that they will survive for a lot of years to technology
innovation.
I²C 439
Figure 6: The pinout of a 24LCxx EEPROM with a PDIP-8 package
Our examples will be based on the 24LC64 model, which is a 64Kbits EEPROM (this means that the
memory is able to store 8Kb or, if you prefer, 8192 bytes). The pinout of the PDIP-8 version is shown
in Figure 6. A0, A1 and A2 are used to set the LSB bits of the I²C address, as shown in Figure 7: if
one of those pins is tied to the ground, then the corresponding bit is set to 0; if tied to VDD, then the
bit is set to 1. If all three pins are tied to the ground, then the I²C address corresponds to 0xA0.
Figure 7: How the 24LCxx I²C address is composed.
WP pin is the write protection pin: if tied to the ground, we can write inside individual memory
cells. On the contrary, if connected to VDD, write operations have no effects. Since I2C1 peripheral
is mapped to the same pins in all Nucleo boards, Figure 8 shows the right way to connect a 24LCxx
EEPROM to the Arduino connector in all sixteen Nucleo boards.
Read Carefully
STM32F1 microcontrollers do not provide the ability to pull-up SDA and SCL lines. Their
GPIOs must be configured as open-drain. So, you have to add two additional resistors to
pull-up I²C lines. Something between 4K and 10K is a proven value.
As said before, a 64Kbits EEPROM has 8192 addresses, ranging from 0x0000 up to 0x1FFF . An
individual byte write is performed by sending over the I²C bus the EEPROM address, the upper
half of the memory address followed by the lower half, and the value to store in that cell, closing
the transaction with a STOP condition.
I²C 440
Figure 8: How to connect a Nucleo to a 24LCxx EEPROM
Assuming we want to store the value 0x4C inside the memory location 0x320, then Figure 9 shows
the right transaction sequence. The address 0x320 is split in two parts: the upper part, equal to 0x3
is transmitted first, and the lower part equal to 0x20 is sent right after. Then the data to store is sent.
We can also send multiple bytes in the same transaction: an internal address counter automatically
increments at every byte sent. This allows us to reduce the transaction time and increase the total
throughput.
The ACK bit set by the I²C EEPROM after the last sent byte does not means that data has
been effectively stored inside the memory. Sent data is stored in a temporarily buffer, since
EEPROM location memories are erased page-by-page and not individually. The whole page (which
is composed by 32 bytes) is refreshed at every write operation, and the transferred bytes are stored
only at the end of this operation. During the erase time, every command sent to the EEPROM will
be ignored. To detect when a write operation has been completed, we need to use the acknowledge
polling. This involves the master sending a START condition followed by slave address plus the
control byte for a write command (R/W bit set to 0). If the device is still busy with the write cycle,
then no ACK will be returned. If no ACK is returned, the START bit and control byte must be re-
sent. If the cycle is complete, the device will return the ACK and the master can then proceed with
the next read or write command.
Figure 9: How to perform a write operation with a 24LCxx EEPROM
Read operations are initiated in the same way as write operations, with the exception that the R/W
bit of the control byte is set to 1. There are three basic types of read operations: current address read,
random read and sequential read. In this book we will focus our attention on the random read mode
only, leaving to the reader the responsibility to deepen the other modes.
Random read operations allow the master to access any memory location in a random manner. To
perform this type of read operation, the memory address must be sent first. This is accomplished by
sending the memory address to the 24LCxx as part of a write operation (R/W bit set to ‘0’). Once the
I²C 441
memory address is sent, the master generates a RESTART condition (repeating START) following
theACK¹⁴.Thisterminatesthewriteoperation,butnotbeforetheinternaladdresscounterisset.The
master then issues the slave address again, but with the R/W bit set to a 1 this time. The 24LCxx will
then issue an ACK and transmit the 8-bit data word. The master will not acknowledge the transfer
andgeneratesaSTOPcondition,whichcausestheEEPROMtodiscontinuetransmission(seeFigure
10). After a random read command, the internal address counter will point to the address location
following the one that was just read.
Figure 10: How to perform a random read operation with a 24LCxx EEPROM
We are finally ready to arrange a complete example. We will create two simple functions, named
Read_From_24LCxx() and Write_To_24LCxx() thatallowstowrite/readdatafroma24LCxxmemory,
using the CubeHAL. We will then test these routines by simply storing a string inside the EEPROM,
and then reading it back: if the original string is equal to the one read from the EEPROM, then the
Nucleo LD2 LED starts blinking.
Filename: src/main-ex1.c
14 int main(void) {
15 const char wmsg[] = "We love STM32!";
16 char rmsg[20];
17
18 HAL_Init();
19 Nucleo_BSP_Init();
20
21 MX_I2C1_Init();
22
23 Write_To_24LCxx(&hi2c1, 0xA0, 0x1AAA, (uint8_t*)wmsg, strlen(wmsg)+1);
24 Read_From_24LCxx(&hi2c1, 0xA0, 0x1AAA, (uint8_t*)rmsg, strlen(wmsg)+1);
25
26 if(strcmp(wmsg, rmsg) == 0) {
27 while(1) {
28 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
29 HAL_Delay(100);
30 }
31 }
32
33 while(1);
34 }
35
36 /* I2C1 init function */
37 static void MX_I2C1_Init(void) {
38 GPIO_InitTypeDef GPIO_InitStruct;
¹⁴ The 24LCxx EEPROM memories are designed so that they work in the same way even if we end the transaction by issuing a STOP
condition, and then we immediately start a new one in read mode. This degree of flexibility we will allow us to build the first example of this
chapter, as we will see in a while.
I²C 442
39
40 /* Peripheral clock enable */
41 __HAL_RCC_I2C1_CLK_ENABLE();
42
43 hi2c1.Instance = I2C1;
44 hi2c1.Init.ClockSpeed = 100000;
45 hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
46 hi2c1.Init.OwnAddress1 = 0x0;
47 hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
48 hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
49 hi2c1.Init.OwnAddress2 = 0;
50 hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
51 hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
52
53 GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
54 GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
55 GPIO_InitStruct.Pull = GPIO_PULLUP;
56 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
57 GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
58 HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
59
60 HAL_I2C_Init(&hi2c1);
61 }
Let us analyze the above fragment of code starting from the MX_I2C1_Init() routine. It starts
enabling the I2C1 peripheral clock, so that we can program its registers. Then we set the bus speed
(100kHz in our case - the duty cycle setting is ignored in this case, because the duty cycle is fixed to
1:1 when the bus runs at speeds lower or equal to 100kHz). We then configure PB8 and PB9 pins so
that they act as SCL and SDA lines respectively.
The main() routine is really simple: it stores the string "We love STM32!" at the 0x1AAA memory
location;thestringisthenreadbackfromtheEEPROMandcomparedwiththeoriginalone.Weneed
to explain just why we are storing and reading a buffer with a length equal to strlen(wmsg)+1 . This
because the C strlen() routines gives back the length of the string skipping the string terminator
char ( '\0' ). Without storing this char, and then reading it back from the EEPROM, the strcmp() at
line 26 wouldn’t be able to compute the exact length of the string.
I²C 443
Filename: src/main-ex1.c
63 HAL_StatusTypeDef Read_From_24LCxx(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemA\
64 ddress, uint8_t *pData, uint16_t len) {
65 HAL_StatusTypeDef returnValue;
66 uint8_t addr[2];
67
68 /* We compute the MSB and LSB parts of the memory address */
69 addr[0] = (uint8_t) ((MemAddress & 0xFF00) >> 8);
70 addr[1] = (uint8_t) (MemAddress & 0xFF);
71
72 /* First we send the memory location address where start reading data */
73 returnValue = HAL_I2C_Master_Transmit(hi2c, DevAddress, addr, 2, HAL_MAX_DELAY);
74 if(returnValue != HAL_OK)
75 return returnValue;
76
77 /* Next we can retrieve the data from EEPROM */
78 returnValue = HAL_I2C_Master_Receive(hi2c, DevAddress, pData, len, HAL_MAX_DELAY);
79
80 return returnValue;
81 }
82
83 HAL_StatusTypeDef Write_To_24LCxx(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAd\
84 dress, uint8_t *pData, uint16_t len) {
85 HAL_StatusTypeDef returnValue;
86 uint8_t *data;
87
88 /* First we allocate a temporary buffer to store the destination memory
89 * address and the data to store */
90 data = (uint8_t*)malloc(sizeof(uint8_t)*(len+2));
91
92 /* We compute the MSB and LSB parts of the memory address */
93 data[0] = (uint8_t) ((MemAddress & 0xFF00) >> 8);
94 data[1] = (uint8_t) (MemAddress & 0xFF);
95
96 /* And copy the content of the pData array in the temporary buffer */
97 memcpy(data+2, pData, len);
98
99 /* We are now ready to transfer the buffer over the I2C bus */
100 returnValue = HAL_I2C_Master_Transmit(hi2c, DevAddress, data, len + 2, HAL_MAX_DELAY);
101 if(returnValue != HAL_OK)
102 return returnValue;
103
104 free(data);
105
106 /* We wait until the EEPROM effectively stores data in memory */
107 while(HAL_I2C_Master_Transmit(hi2c, DevAddress, 0, 0, HAL_MAX_DELAY) != HAL_OK);
108
I²C 444
109 return HAL_OK;
110 }
We can now focus our attention on the two routines to use the 24LCxx EEPROM. Both of them are
designed to accept:
• the I²C slave address of the EEPROM memory ( DevAddress );
• the memory address where start storing/reading data ( MemAddress );
• the pointer to the memory buffer used to exchange data with the EEPROM ( pData );
• the amount of data to store/read ( len );
The Read_From_24LCxx() function starts computing the two halves of the memory address (MSB
and LSB part). It then sends the two parts over the I²C bus using the HAL_I2C_Master_Transmit()
routine (line 72). As said before, the 24LCxx memory is designed so that it sets the internal address
countertothepassedaddress.Wecansostartanewtransactioninreadmodetoretrievetheamount
of data from the EEPROM (line 77).
The Write_To_24LCxx() functions does a similar thing, but in a different way. It must adhere to
the 24LCxx protocol described in Figure 9, which slightly differs from the one in Figure 8 . This
means that we cannot use two separated transactions for the memory address and the data to store,
but we have to perform a unique I²C transaction. For this reason we use a temporary and dynamic
buffer (line 88), which contains the two halves of the memory address plus the data to store in
the EEPROM. We can so perform a transaction over the I²C bus (line 98) and then wait until the
EEPROM completes the memory transfer (line 105).
14.2.1.1 I/O MEM Operations
The protocol used by the 24LCxx EEPROM is indeed common to all I²C devices that have memory-
addressable registers to read to and to write from. For example, a lot of I²C sensors, like the HTS221
by ST, adopt the same protocol. For this reason, ST engineers have already implemented specific
routines inside the CubeHAL that do the same job of Read_From_24LCxx() and Write_To_24LCxx()
better and faster. The functions:
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
uint16_t MemAddress, uint16_t MemAddSize,
uint8_t *pData, uint16_t Size, uint32_t Timeout);
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
uint16_t MemAddress, uint16_t MemAddSize,
uint8_t *pData, uint16_t Size, uint32_t Timeout);
allow to store and retrieve data from memory-addressable I²C devices, with just one notably
difference:the HAL_I2C_Mem_Write() functionisnotdesignedtowaitforthewrite-cyclecompletion,
as we have done in the previous example at line 105. But, even for this operation the HAL provides
a dedicated and more portable routine:
I²C 445
HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
uint32_t Trials, uint32_t Timeout);
This function accepts a maximum number of Trials before returning back an error condition, but
if we pass to the function the HAL_MAX_DELAY as Timeout value, then we can pass 1 to the Trials
argument. When the polled I²C device is ready the function returns HAL_OK . Otherwise it returns the
HAL_BUSY value.
So, the main() function seen before can be rearranged in the following way:
14 int main(void) {
15 char wmsg[] ="We love STM32!";
16 char rmsg[20];
17
18 HAL_Init();
19 Nucleo_BSP_Init();
20
21 MX_I2C1_Init();
22
23 HAL_I2C_Mem_Write(&hi2c1, 0xA0, 0x1AAA, I2C_MEMADD_SIZE_16BIT, (uint8_t*)wmsg,
24 strlen(wmsg)+1, HAL_MAX_DELAY);
25 while(HAL_I2C_IsDeviceReady(&hi2c1, 0xA0, 1, HAL_MAX_DELAY) != HAL_OK);
26
27 HAL_I2C_Mem_Read(&hi2c1, 0xA0, 0x1AAA, I2C_MEMADD_SIZE_16BIT, (uint8_t*)rmsg,
28 strlen(wmsg)+1, HAL_MAX_DELAY);
29
30 if(strcmp(wmsg, rmsg) == 0) {
31 while(1) {
32 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
33 HAL_Delay(100);
34 }
35 }
36
37 while(1);
38 }
The above APIs works in polling mode, but the CubeHAL provides also corresponding routines to
performtransactionsininterruptandDMAmode.Asusual,theseotherAPIshaveasimilarfunction
signature, with just one thing to note: the callback functions used to signal the end of transfers are
the HAL_I2C_MemTxCpltCallback() and HAL_I2C_MemRxCpltCallback() , as reported in Table 3.
14.2.1.2 Combined Transactions
The transmission sequence of a read operation in a 24LCxx EEPROM memory is a combined
transaction. A RESTART condition is used before inverting the direction of the I²C transmission
(from write to read). In the first example we were able to use two separated transactions inside
I²C 446
the Read_From_24LCxx() because 24LCxx EEPROMs are designed to work in the same way. This
is possible thanks to the internal address counter: the first transaction sets the address counter to
the wanted location; the second one, performed in read mode, retrieves the data from the EEPROM
starting from that location. However, this not only reduces the maximum throughput that may
be reached but, more important, often leads to not portable code: there exist several I²C devices
that strictly adhere to the I²C protocol and implement combined transactions according to the
specification using a RESTART condition (so they do not tolerate a STOP condition in the middle).
The CubeHAL provides twodedicated routines to handle combined transaction or,as theyare called
in the Cube HAL, sequential transmissions:
HAL_I2C_Master_Sequential_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
uint8_t *pData, uint16_t Size,uint32_t XferOptions);
HAL_I2C_Master_Sequential_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
uint8_t *pData, uint16_t Size, uint32_t XferOptions);
Compared to the other routines seen before, the only relevant parameter to highlight here is
XferOptions .ItcanassumeoneofthevaluesreportedinTable4anditisusedtodrivethegeneration
of START/RESTART/STOP conditions in a single transaction. Both functions work in this way. Let
us assume that we want to read n-bytes from the 24LCxx EEPROM. According to the I²C protocol,
we must execute the following operations (refer to Figure 10):
1. we have to begin a new transaction in write mode issuing a START condition followed by the
slave address;
2. we then transfer two bytes containing MSB and LSB parts of the memory address;
3. we so issue a RESTART condition and transmit the slave device address with the last bit set to
1 to indicate a read transaction.
4. the slave device starts sending data byte-by-byte until we end the transaction by issuing a
NACK or a STOP condition.
Table 4: Values for the XferOptions parameter to drive the generation of STAR/RESTART/STOP conditions
Transfer option Description
I2C_FIRST_FRAME This option allows to generate just the START condition, without generating
the final STOP condition at the end of transmission.
I2C_NEXT_FRAME This option allows to generate a RESTART before transmitting data if the
direction changes (that is we call
HAL_I2C_Master_Sequential_Transmit_IT() after
HAL_I2C_Master_Sequential_Receive_IT() or vice versa), or it allows to
manage only the new data to transfer if no direction changes and without a
final STOP condition in both cases.
I2C_LAST_FRAME This option allows to generate a RESTART before transmitting data if the
direction changes (that is we call
HAL_I2C_Master_Sequential_Transmit_IT() after
HAL_I2C_Master_Sequential_Receive_IT() or vice versa), or it allows to
manage only the transfer of new data if no direction changes and with a
final STOP condition in both cases.
I²C 447
Table 4: Values for the XferOptions parameter to drive the generation of STAR/RESTART/STOP conditions
Transfer option Description
I2C_FIRST_AND_LAST_FRAME No sequential usage. Both the routine work in the same way of
HAL_I2C_Master_Transmit_IT() and HAL_I2C_Master_Receive_IT()
functions.
Using sequential transmission routines we can proceed in the following way:
1. we invoke the HAL_I2C_Master_Sequential_Transmit_IT() routine by passing the slave ad-
dress and the two bytes forming the memory location address; we invoke the function by
passing the value I2C_FIRST_FRAME , so that it generates a START condition without issuing a
STOP condition after the two bytes have been sent;
2. wesocallthe HAL_I2C_Master_Sequential_Receive_IT() routinebypassingtheslaveaddress,
the pointer to the buffer used to store read bytes, the amount of bytes to read from the
EEPROM and the value I2C_LAST_FRAME , so that the function generates a RESTART condition
and terminates the transaction at the end of transfer by issuing a STOP condition.
At the time of writing this chapter, sequential transmission routines exist only in interrupt mode
version. We do not analyze a usage example here, because we will use them extensively (together
with the ones used to develop I²C slave applications) in the next paragraph.
Read Carefully
At the time of writing this chapter, latest releases of the CubeHAL for F1 and L0 families
do not provide sequential transmission routines. I think that ST is actively working on this,
and next releases of the HAL should introduce them.
For the same reason, owners of the Nucleo-F103RB and Nucleo-L0XX boards will not be
able to execute the examples related to the usage of the I²C peripheral in slave mode.
14.2.1.3 A Note About the Clock Configuration in STM32F0/L0/L4 families
In STM32F0/L0 families it is possible to select different clock sources for the I2C1 peripheral. This
because in those families the I2C1 peripheral is able to work even in some low-power modes,
allowing to wake-up the MCU when the I²C works in slave mode and the configured slave address
is placed on the bus. Refer to the Clock view in CubeMX for more about this.
In STM32L4 MCUs it is possible to select the clock source for all I²C peripherals.
14.2.2 Using the I²C Peripheral in Slave Mode
Nowadays there are a lot of System-on-Board (SoB) modules on the marked. These are usually small
PCBsalreadypopulatedwithseveralICsandspecializedindoingsomethingrelevant.GPRSandGPS
I²C 448
modules or multi-sensors boards are examples of SoB modules. These modules then are soldered
to the main board, thanks to the fact that they expose solderable pads on their sides also know
as “castellated vias” or “castellations”. Figure 11 shows the INEMO-M1 module by ST, which is an
integratedandprogrammablemodulewithanSTM32F103andtwohighly-integratedMEMSsensors
(a 6-axis digital e-compass and a 3-axis digital gyroscope).
Figure 11: The INEMO-M1 module by ST
The MCU on these boards usually comes pre-programmed with a firmware, which is specialized
in doing a well-established task. The host board also contains another programmable IC, maybe
another MCU or something similar. The main board interacts with the SoB using a well-known
communication protocol, which usually are the UART, the CAN bus, the SPI or the I²C bus. For this
reason, it is quite common to program STM32 devices to make they working in I²C slave mode.
The CubeHAL provides all the necessary glue to develop I²C slave applications easily. The slave
routines are identical to the one used to program I²C peripherals in master mode. For example, the
following routines are used to transmit/receive data in interrupt mode when the I²C peripheral is
used in slave mode:
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData,
uint16_t Size);
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData,
uint16_t Size);
In the same way, the callback routines invoked at the end of data transmission/reception are the
following ones:
void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c);
void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c);
We are now going to analyze a complete example that shows how to develop I²C slave applications
using the CubeHAL. We will realize a sort of digital temperature sensor with an I²C interface really
similar to the majority of digital temperature sensors on the marked (for example, the popular
TMP275 by TI and the HT221 by ST). This “sensor” will provide just three registers:
I²C 449
• a WHO_AM_I register, used by master code to check that the I²C interface works correctly; this
register returns the fixed value 0xBC.
• two temperature-related registers, named TEMP_OUT_INT and TEMP_OUT_FRAC , which contains
the integer and fractional part of the acquired temperature; for example, if the detected
temperature is equal to 27.34°C, then the TEMP_OUT_INT register will contain the value 27 and
the TEMP_OUT_FRAC the value 34.
Figure 12: The I²C protocol used to read internal register of our slave device
Our sensor will be designed to answer to a really simple protocol, based on combined transactions,
which is shown in Figure 12. As you can see, the only notably difference with the protocol used
by 24LCxx EEPROMs, when accessing to memory in random read mode, is the size of the memory
register, which is just one byte in this case.
Theexampleprovidesbotha“slave”anda“master”implementation:themacro SLAVE_BOARD ,defined
at project level, drives the compilation of the two parts. The example requires two Nucleo boards¹⁵.
Filename: src/main-ex2.c
15 volatile uint8_t transferDirection, transferRequested;
16
17 #define TEMP_OUT_INT_REGISTER 0x0
18 #define TEMP_OUT_FRAC_REGISTER 0x1
19 #define WHO_AM_I_REGISTER 0xF
20 #define WHO_AM_I_VALUE 0xBC
21 #define TRANSFER_DIR_WRITE 0x1
22 #define TRANSFER_DIR_READ 0x0
23 #define I2C_SLAVE_ADDR 0x33
24
25 int main(void) {
26 char uartBuf[20];
27 uint8_t i2cBuf[2];
28 float ftemp;
29 int8_t t_frac, t_int;
30
31 HAL_Init();
32 Nucleo_BSP_Init();
33
34 MX_I2C1_Init();
35
36 #ifdef SLAVE_BOARD
¹⁵ Unfortunately, when I started designing this example I thought that it were possible to use just one board, connecting the pins associated
with an I²C peripheral to those ones of another I²C peripheral (for example, I2C1 pins directly connected to the I2C3 pins). But, after a lot of
struggling, I reached to the conclusion that I²C peripherals in an STM32 are not “truly asynchronous” and it is not possible to use two I²C
peripherals concurrently. So, to run this examples you will need two Nucleo boards, or just one Nucleo and another development kit: in this
case, you need to rearrange the master part accordingly.
I²C 450
37 uint16_t rawValue;
38 uint32_t lastConversion;
39
40 MX_ADC1_Init();
41 HAL_ADC_Start(&hadc1);
42
43 while(1) {
44 HAL_I2C_EnableListen_IT(&hi2c1);
45 while(!transferRequested) {
46 if(HAL_GetTick() - lastConversion > 1000L) {
47 HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
48
49 rawValue = HAL_ADC_GetValue(&hadc1);
50 ftemp = ((float)rawValue) / 4095 * 3300;
51 ftemp = ((ftemp - 760.0) / 2.5) + 25;
52
53 t_int = ftemp;
54 t_frac = (ftemp - t_int)*100;
55
56 sprintf(uartBuf, "Temperature: %f\r\n", ftemp);
57 HAL_UART_Transmit(&huart2, (uint8_t*)uartBuf, strlen(uartBuf), HAL_MAX_DELAY);
58
59 sprintf(uartBuf, "t_int: %d - t_frac: %d\r\n", t_frac, t_int);
60 HAL_UART_Transmit(&huart2, (uint8_t*)uartBuf, strlen(uartBuf), HAL_MAX_DELAY);
61
62 lastConversion = HAL_GetTick();
63 }
64 }
65
66 transferRequested = 0;
67
68 if(transferDirection == TRANSFER_DIR_WRITE) {
69 /* Master is sending register address */
70 HAL_I2C_Slave_Sequential_Receive_IT(&hi2c1, i2cBuf, 1, I2C_FIRST_FRAME);
71 while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_LISTEN);
72
73 switch(i2cBuf[0]) {
74 case WHO_AM_I_REGISTER:
75 i2cBuf[0] = WHO_AM_I_VALUE;
76 break;
77 case TEMP_OUT_INT_REGISTER:
78 i2cBuf[0] = t_int;
79 break;
80 case TEMP_OUT_FRAC_REGISTER:
81 i2cBuf[0] = t_frac;
82 break;
83 default:
I²C 451
84 i2cBuf[0] = 0xFF;
85 }
86
87 HAL_I2C_Slave_Sequential_Transmit_IT(&hi2c1, i2cBuf, 1, I2C_LAST_FRAME);
88 while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY);
89 }
90 }
The most relevant part of the main() function starts at line 44. The HAL_I2C_EnableListen_IT()
routine enables all the I²C peripheral-related interrupts. This means that a new interrupt will fire
when the master places the slave device address (which is defined by the macro I2C_SLAVE_ADDR ).
The HAL_I2C_EV_IRQHandler() routines so will automatically call the HAL_I2C_AddrCallback()
function, that we will analyze later.
The main() function then starts performing an A/D conversion of the internal temperature sensor
every second, and it splits the acquired temperature (stored in the ftemp variable) in two 8-bit
integers, t_int and t_frac : these represent the integer and fractional parts of the temperature. The
mainfunctiontemporarilystopstheA/Dconversionassoonas transferRequested variablebecomes
equal to 1: this global variable is set by the HAL_I2C_AddrCallback() function, together with the
transferDirection one, which contains the transfer direction (read/write) of the I²C transaction.
If the master is starting a new transaction in write mode, then it means that it is transferring the
register address. The HAL_I2C_Slave_Sequential_Receive_IT() function is then invoked at line 70:
this will cause that the register address is received from the master. Since the function works in
interrupt mode, we need a way to wait until the transfer is completed. The HAL_I2C_GetState()
returns the internal status of the HAL, which is equal to HAL_I2C_STATE_BUSY_RX_LISTEN until the
transfer finishes. When this happens, the status goes back to HAL_I2C_STATE_LISTEN and we can
proceed by transferring to the master the content of the wanted register.
This is performed at line 87, where the function HAL_I2C_Slave_Sequential_Transmit_IT() is
called: the function inverts the transfer direction, and sends to the master the content of the wanted
register. The tricky part is represented by the line 88. Here we do a busy spin until the I²C peripheral
state is equal to HAL_I2C_STATE_READY . Why we do not check the peripheral status against the
HAL_I2C_STATE_LISTEN state, as we have performed at line 71? To understand this aspect we need
to remember an important thing of combined transactions. When a transaction inverts the transfer
direction, the master starts acknowledging every byte sent. Remember that only the master knows
how long a transaction lasts, and it decides when to stop the transaction. In combined transactions,
a master ends the transfer from the slave to the master by issuing a NACK, which causes the slave
to issue a STOP condition. From the I²C peripheral point of view, a STOP condition causes the
peripheral to exit from listen mode (technically speaking, it generates an abort condition - if you
implement the HAL_I2C_AbortCpltCallback() callback, you can track when this happens), and that
is the reason why we need to check against the HAL_I2C_STATE_READY state and to place again the
peripheral in listen mode at line 44.
I²C 452
Filename: src/main-ex2.c
92 #else //Master board
93 i2cBuf[0] = WHO_AM_I_REGISTER;
94 HAL_I2C_Master_Sequential_Transmit_IT(&hi2c1, I2C_SLAVE_ADDR, i2cBuf,
95 1, I2C_FIRST_FRAME);
96 while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY);
97
98 HAL_I2C_Master_Sequential_Receive_IT(&hi2c1, I2C_SLAVE_ADDR, i2cBuf,
99 1, I2C_LAST_FRAME);
100 while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY);
101
102 sprintf(uartBuf, "WHO AM I: %x\r\n", i2cBuf[0]);
103 HAL_UART_Transmit(&huart2, (uint8_t*) uartBuf, strlen(uartBuf), HAL_MAX_DELAY);
104
105 i2cBuf[0] = TEMP_OUT_INT_REGISTER;
106 HAL_I2C_Master_Sequential_Transmit_IT(&hi2c1, I2C_SLAVE_ADDR, i2cBuf,
107 1, I2C_FIRST_FRAME);
108 while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY);
109
110 HAL_I2C_Master_Sequential_Receive_IT(&hi2c1, I2C_SLAVE_ADDR, (uint8_t*)&t_int,
111 1, I2C_LAST_FRAME);
112 while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY);
113
114 i2cBuf[0] = TEMP_OUT_FRAC_REGISTER;
115 HAL_I2C_Master_Sequential_Transmit_IT(&hi2c1, I2C_SLAVE_ADDR, i2cBuf,
116 1, I2C_FIRST_FRAME);
117 while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY);
118
119 HAL_I2C_Master_Sequential_Receive_IT(&hi2c1, I2C_SLAVE_ADDR, (uint8_t*)&t_frac,
120 1, I2C_LAST_FRAME);
121 while (HAL_I2C_GetState(&hi2c1) != HAL_I2C_STATE_READY);
122
123 ftemp = ((float)t_frac)/100.0;
124 ftemp += (float)t_int;
125
126 sprintf(uartBuf, "Temperature: %f\r\n", ftemp);
127 HAL_UART_Transmit(&huart2, (uint8_t*) uartBuf, strlen(uartBuf), HAL_MAX_DELAY);
128
129 #endif
130
131 while (1);
132 }
Finally,itisimportanttounderlinethattheimplementationofthe“slavepart”isstillnotsufficiently
robust. In fact, we should handle all the possible wrong cases that may happen. For example,
the master may shutdown the connection just in the middle of the two transactions. This would
I²C 453
complicate a lot the example, and it is left to exercise to the reader.
The “master part” of the example starts at line 92. The code is really straightforward. Here we use
the HAL_I2C_Master_Sequential_Transmit_IT() function to start a combined transaction and the
HAL_I2C_Master_Sequential_Receive_IT() to retrieve the content of the wanted register from the
slave. The integer and fractional part of the temperature are then combined again in a float , and
the acquired temperature is printed on the UART2.
Filename: src/main-ex2.c
134 void I2C1_EV_IRQHandler(void) {
135 HAL_I2C_EV_IRQHandler(&hi2c1);
136 }
137
138 void I2C1_ER_IRQHandler(void) {
139 HAL_I2C_ER_IRQHandler(&hi2c1);
140 }
141
142 void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMat\
143 chCode) {
144 UNUSED(AddrMatchCode);
145
146 if(hi2c->Instance == I2C1) {
147 transferRequested = 1;
148 transferDirection = TransferDirection;
149 }
150 }
The last part we need to analyze is represented by ISR handlers. The ISR I2C1_EV_IRQHandler()
invokes the HAL_I2C_EV_IRQHandler() , as said before. This causes that the HAL_I2C_AddrCallback()
function is called every time the master transmit the slave address on the bus. When invoked, the
callback will receive the pointer to the I2C_HandleTypeDef representing the specific I²C descriptor,
the direction of the transfer ( TransferDirection ) and the matched I²C address ( AddrMatchCode ):
this is required because an STM32 I²C peripheral working in slave mode can answer to two different
addresses, and so we have a way to write conditional code depending on the I²C address issued by
the master.
14.3 Using CubeMX to Configure the I²C Peripheral
As usual, CubeMX reduces to the minimum the effort needed to configure the I²C peripheral. Once
the peripheral is enabled in the IP tree pane (from the Pinout view), we can configure all settings
from the Configuration view, as shown in Figure 13.
I²C 454
Figure 13: The CubeMX configuration view to setup the I²C peripheral
Read Carefully
By default, when enabling the I2C1 peripheral in STM32 MCUs with LQFP-64 packages,
CubeMX enables as default peripheral I/Os PB7 and PB6 pins (SDA and SCL respectively).
These aren’t the pins latched to the Arduino connector on the Nucleo, but you need to
select the two alternative pins PB9 and PB8 by clicking on them and then selecting the
corresponding function from the drop-down menu, as shown in the following picture.
Figure 14: How to select the right I2C1 pins in a Nucleo-64 board
15. SPI
Inthepreviouschapterwehaveanalyzedoneofthetwomostwidespreadcommunicationstandards
that rule the “market” of intra-boards communication systems: the I²C protocol. Now it is time to
analyze the other player: the SPI protocol.
All STM32 microcontrollers provide at least one SPI interface, which allows to develop both master
andslaveapplications.TheCubeHALimplementsallthenecessarystufftoprogramsuchperipherals
easily.Thischaptergivesaquickoverviewofthe HAL_SPI moduleafter,asusual,abriefintroduction
to the SPI specification.
15.1 Introduction to the SPI Specification
The Serial Peripheral Interface (SPI) is a specification about serial, synchronous and full-duplex
communications between a master controller (which is usually implemented with an MCU or
something with programmable functionalities) and several slave devices. As we will see next, the
nature of the SPI interface allows full duplex as well as half duplex communications over the same
bus. SPI specification is a de facto standard, and it was defined by Motorola¹ in late ‘70, and it is still
largely adopted as communication protocol for many digital ICs. Different from the I²C protocol,
the SPI specification does not force a given message protocol over its bus, but it is limited to bus
signaling giving to slave devices total freedom about the structure of exchanged messages.
Figure 1: The structure of a typical SPI bus
¹ Motorola was a company that has been split in several sub-companies over the years. The semiconductor division of Motorola flowed
into ON Semiconductor, which is still one of the largest semiconductors company in the world.
SPI 456
A typical SPI bus is formed by four signals, as shown in Figure 1, even if it is possible to drive some
SPI devices with just three I/Os (in this case we talk about 3-wire SPI):
• SCK: this signal I/O is used to generate the clock to synchronize data transfer over the SPI bus.
It is generated by the master device, and this means that in an SPI bus every transfer is always
started by the master. Different from the I²C specification, the SPI is intrinsically faster and the
SPI clock speed is usually several MHz. Nowadays is quite common to find SPI devices able
to exchange data at a rate up to 100MHz. Moreover, the SPI protocol allows to devices with
different communication speeds to coexist over the same bus.
• MOSI: the name of this signal I/O stands for Master Output Slave Input, and it is used to send
data from the master device to a slave one. Different from the I²C bus, where just one wire is
used to exchange data both the ways, the SPI protocol defines two distinct lines to exchange
data between master and slaves.
• MISO: it stands for Master Input Slave Output and it corresponds to the I/O line used to send
data from a slave device to the master.
• SSn: it stands for Slave Select and in a typical SPI bus there exist ‘n’ separated lines used to
address the specific SPI devices involved in a transaction. Different from the I²C protocol, the
SPI does not use slave addresses to select devices, but it demands this operation to a physical
line that is asserted LOW to perform a selection. In a typical SPI bus only one slave device can
be activeat same time byasserting lowits SS line. This isthe reason why deviceswith different
communication speed can coexist on the same bus².
Having two separated data communication lines, MOSI and MISO, the SPI intrinsically allows full-
duplex communications, since a slave device is able to send data to the master while it receives new
one from it. In a one-to-one SPI bus (just one master and one slave), the SS signal can be omitted
(the corresponding slave’s I/O is tied to the ground), and MISO/MOSI lines are fused in a single line
called Slave In/Slave Out (SISO). In this case we can talk about 2-wire SPI, even if it is essentially a
3-wire bus.
² For the sake of completeness, we have to say that this is not the exact reason why it is possible to have devices with different
communication speeds on the same bus. The main reason is due to the fact that slave I/Os are implemented with tri-state I/Os, that is they are
placed in high-impedance state (disconnected) when the SS line is not asserted LOW.
SPI 457
Figure 2: How data is exchanged over a SPI bus in a full-duplex transmission
Every transaction over the bus is started by enabling the SCK line according the maximum slave
frequency. Once the clock line starts generating the signal, the master asserts the SS line LOW and
data transmission can begin. Transmissions normally involve two registers of a given word size³,
one in the master and one in the slave. Data is usually shifted out with the most-significant bit first,
while shifting a new least-significant bit into the same register. At the same time, data from the
slave is shifted into the least-significant bit register. After the register bits have been shifted out and
in, the master and slave have exchanged data. If more data needs to be exchanged, the shift registers
are reloaded and the process repeats. Transmission may continue for any number of clock cycles.
When complete, the master stops toggling the clock signal, and typically deselects the slave.
Figure 2 shows the way data is transferred in a full-duplex transmission, while Figure 3 shows the
way it is typically exchanged in a half-duplex connection.
Figure 3: How data is exchanged over a SPI bus in a half-duplex transmission
³ 8-bit data transmissions are the rule, but some slave devices support even 16-bit ones.
SPI 458
15.1.1 Clock Polarity and Phase
In addition to setting the bus clock frequency, the master and slaves must also agree on the clock
polarity and phase with respect to the data exchanged over MOSI and MISO lines. SPI Specification
by Motorola⁴ names these two settings as CPOL and CPHA respectively, and most silicon vendors
have adopted that convention.
The combinations of polarity and phase are often referred to as SPI bus modes which are commonly
numbered according Table 1. The most common mode are mode 0 and mode 3, but the majority of
slave devices support at least a couple of bus modes.
Table 1: SPI bus modes according CPOL and CPHA configuration
Mode CPOL CPHA
0 0 0
1 0 1
2 1 0
3 1 1
The timing diagram is shown in Figure 4, and it is further described below:
• At CPOL=0 the base value of the clock is zero, i.e. the active state is 1 and idle state is 0.
– For CPHA=0, data is captured on the SCK rising edge (LOW → HIGH transition) and
data is output on a falling edge (HIGH → LOW clock transition).
– For CPHA=1, data is captured on the SCK falling edge and data is output on a rising edge.
• At CPOL=1 the base value of the clock is one (inversion of CPOL=0), i.e. the active state is 0
and idle state is 1.
– For CPHA=0, data is captured on SCK falling edge and data is output on a rising edge.
– For CPHA=1, data is captured on SCK rising edge and data is output on a falling edge.
That is, CPHA=0 means sampling on the first clock edge, while CPHA=1 means sampling on the
second clock edge, regardless of whether that clock edge is rising or falling. Note that with CPHA=0,
the data must be stable for a half cycle before the first clock cycle.
⁴ http://bit.ly/2cc3T3S
SPI 459
Figure 4: The SPI timing diagram according CPOL and CPHA settings
15.1.2 Slave Select Signal Management
As said before, the SPI slave devices do not have an address that identify them on the bus, but
they start exchanging data with the master as long as the Slave Select (SS) signal is LOW. STM32
microcontrollers provide two distinct modes to handle the SS signal, which is called NSS in the ST
documentation. Let us analyze them.
• NSS software mode: The SS signal is driven by the firmware and any free GPIO can be used to
drive an IC when the MCU works in master mode, or to detect when another master is starting
a transfer if the MCU works in slave mode.
• NSS hardware mode: a specific MCU I/O is used to drive the SS signal, and it is internally
managed by the SPI peripheral. Two configurations are possible depending on the NSS output
configuration:
– NSS output enabled: this configuration is used only when the device operates in master
mode. The NSS signal is driven LOW when the master starts the communication and is
kept LOW until the SPI is disabled. It is important to remark that this mode is suitable
when there is just one SPI slave device on the bus and its SS I/O is connected to the NSS
signal. This configuration does not allow multi-master mode.
– NSS output disabled: this configuration allows multi-master capability for devices
operating in master mode. For devices set as slave, the NSS pin acts as a classical NSS
input: the slave is selected when NSS is LOW and deselected when NSS HIGH.
15.1.3 SPI TI Mode
SPI peripherals in STM32 microcontrollers support the TI Mode when working in master mode and
when the NSS signal is configured to work in hardware. In TI mode the clock polarity and phase
are forced to conform to the Texas Instruments protocol requirements whatever the values set. NSS
management is also specific to the TI protocol, which makes the configuration of NSS management
transparent for the user. In TI mode, in fact, the NSS signal “pulses” at the end of every transmitted
byte (it goes from LOW to HIGH from the beginning of the LSB bit and goes from HIGH to LOW
SPI 460
at the starting of the MSB bit forming the next transferred byte). For more information about this
communication mode, refer to the reference manual for the MCU you are considering.
Table 2: Effective availability of SPI peripherals in MCUs equipping all sixteen Nucleo boards
15.1.4 Availability of SPI Peripherals in STM32 MCUs
Depending on the family type and package used, STM32 microcontrollers can provide up to six
independentSPIperipherals.Table2summarizestheavailabilityofSPIperipheralsinSTM32MCUs
equipping all sixteen Nucleo boards we are considering in this book.
SPI 461
For every SPI peripheral, and a given STM32 MCU, Table 2 shows the pins corresponding to MOSI,
MISO and SCK lines. Moreover, darker rows show alternate pins that can be used during the layout
of the board. For example, given the STM32F401RE MCU, we can see that SPI1 peripheral is mapped
to PA7, PA6 and PA5, but PB5, PB5 and PB3 can be also used as alternate pins. Note that the SPI1
peripheral uses the same I/O pins in all STM32 MCUs with LQFP-64 package. This is another clear
example of the pin-to-pin compatibility offered by STM32 microcontrollers.
We are now ready to see how-to use the CubeHAL APIs to program this peripheral.
15.2 HAL_SPI Module
To program the SPI peripheral, the HAL defines the C struct SPI_HandleTypeDef , which is defined
in the following way⁵:
typedef struct __SPI_HandleTypeDef {
SPI_TypeDef *Instance; /* SPI registers base address */
SPI_InitTypeDef Init; /* SPI communication parameters */
uint8_t *pTxBuffPtr; /* Pointer to SPI Tx transfer Buffer */
uint16_t TxXferSize; /* SPI Tx Transfer size */
__IO uint16_t TxXferCount; /* SPI Tx Transfer Counter */
uint8_t *pRxBuffPtr; /* Pointer to SPI Rx transfer Buffer */
uint16_t RxXferSize; /* SPI Rx Transfer size */
__IO uint16_t RxXferCount; /* SPI Rx Transfer Counter */
DMA_HandleTypeDef *hdmatx; /* SPI Tx DMA Handle parameters */
DMA_HandleTypeDef *hdmarx; /* SPI Rx DMA Handle parameters */
HAL_LockTypeDef Lock; /* Locking object */
__IO HAL_SPI_StateTypeDef State; /* SPI communication state */
__IO uint32_t ErrorCode; /* SPI Error code */
} SPI_HandleTypeDef;
Let us analyze the most important fields of this struct.
• Instance : is the pointer to the SPI descriptor we are going to use. For example, SPI1 is the
descriptor of the first SPI peripheral.
• Init : is an instance of the C struct SPI_InitTypeDef used to configure the peripheral. We
will study it more in depth in a while.
• pTxBuffPtr , pRxBuffPtr : pointer to the internal buffers used to temporarily store data trans-
ferred to and from the SPI peripheral. This is used when the SPI works in interrupt mode and
should be not modified from the user code.
• hdmatx , hdmarx : pointer to instances of the DMA_HandleTypeDef struct used when the SPI
peripheral works in DMA mode.
The setup of the SPI peripheral is performed by using an instance of the C struct SPI_InitTypeDef ,
which is defined in the following way:
⁵ Somefieldshavebeenomittedforsimplicity.RefertotheCubeHALsourcecodefortheexactdefinitionofthe SPI_HandleTypeDef struct .
SPI 462
typedef struct {
uint32_t Mode; /* Specifies the SPI operating mode. */
uint32_t Direction; /* Specifies the SPI bidirectional mode state. */
uint32_t DataSize; /* Specifies the SPI data size. */
uint32_t CLKPolarity; /* Specifies the serial clock steady state. */
uint32_t CLKPhase; /* Specifies the clock active edge for the bit capture. */
uint32_t NSS; /* Specifies whether the NSS signal is managed by
hardware (NSS pin) or by software */
uint32_t BaudRatePrescaler; /* Specifies the Baud Rate prescaler value which will be
used to configure the SCK clock. */
uint32_t FirstBit; /* Specifies whether data transfers start
from MSB or LSB bit. */
uint32_t TIMode; /* Specifies if the TI mode is enabled or not. */
uint32_t CRCCalculation; /* Specifies if the CRC calculation is enabled or not. */
uint32_t CRCPolynomial; /* Specifies the polynomial used for the CRC calculation. */
} SPI_InitTypeDef;
• Mode : this parameter sets the SPI in master or slave mode. It can assume the values SPI_MODE_-
MASTER and SPI_MODE_SLAVE .
• Direction : it specifies whatever the slave peripheral works in 4-wire (two separated lines for
input/output) or 3-wire (just one line for I/O). It can assume the value SPI_DIRECTION_2LINES
to configure a full-duplex 4-wire mode; the value SPI_DIRECTION_2LINES_RXONLY to setup a
half-duplex 4-wire mode; the value SPI_DIRECTION_1LINE to configure a half-duplex 3-wire
mode.
• DataSize : configures the size of the transferred data over the SPI bus, and it can assume the
values SPI_DATASIZE_8BIT and SPI_DATASIZE_16BIT .
• CLKPolarity : it configures the SCK CPOL setting and it can assume the values SPI_POLARITY_-
LOW (which corresponds to CPOL=0) and SPI_POLARITY_HIGH (which corresponds to CPOL=1).
• CLKPhase this related field sets the clock phase, and it can assume the values SPI_PHASE_1EDGE
(which corresponds to CPHA=0) and SPI_PHASE_2EDGE (which corresponds to CPHA=1).
• NSS : this field handles the behaviour of the NSS I/O. It can assume the values SPI_NSS_SOFT to
configure NSS signal in software mode; the values SPI_NSS_HARD_INPUT and SPI_NSS_HARD_-
OUTPUT to configure the NSS signal in input and output hardware mode respectively.
• BaudRatePrescaler : it sets the prescaler of the APB clock and it establishes the maximum SCK
clock speed. It can assume the values SPI_BAUDRATEPRESCALER_2 , SPI_BAUDRATEPRESCALER_4 ,
…, SPI_BAUDRATEPRESCALER_256 (all two’s powers from 2¹ up to 2⁸).
• FirstBit : specifies the data transmission ordering, and it can assume the values SPI_FIRST-
BIT_MSB and SPI_FIRSTBIT_LSB .
• TIMode : it is used to enable/disable the TI mode, and it can assume the values SPI_TIMODE_-
DISABLE and SPI_TIMODE_ENABLE .
• CRCCalculation and CRCPolynomial : the SPI peripheral in all STM32 microcontrollers supports
the CRC generation in hardware. A CRC value can be transmitted as last byte in Tx mode,
or automatic CRC error checking can be performed for last received byte. The CRC value is
SPI 463
calculated using an odd programmable polynomial on each bit. The calculation is processed on
the sampling clock edge defined by the CPHA and CPOL configurations. The calculated CRC
value is checked automatically at the end of the data block as well as for transfer managed
by CPU or by the DMA. When a mismatch is detected between the CRC calculated internally
on the received data and the CRC sent by the transmitter, an error condition is set. The CRC
feature is not available when the SPI is driven in DMA circular mode. For more information
about this option, refer to the reference manual for the STM32 MCU you are considering.
As usual, to configure the SPI peripheral we use the function:
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi);
which accepts a pointer to an instance of the SPI_HandleTypeDef struct seen before.
15.2.1 Exchanging Messages Using SPI Peripheral
Once the SPI peripheral is configured, we can start exchanging data with slave devices. Since the
SPI specification does not forces a given communication protocol, there is no difference among the
CubeHAL routines when using the SPI peripheral in slave or master mode. The only difference
resides in the peripheral configuration, setting the Mode parameter of the SPI_InitTypeDef structure
accordingly.
As usual, the CubeHAL provides three ways to communicate over a SPI bus: polling, interrupt and
DMA mode.
To send an amount of bytes to a slave device in polling mode, we use the function:
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size,
uint32_t Timeout);
The function signature is almost identical to other communication routines seen so far (for example,
thoseusedfortheUARTmanipulation),sowewillnotdescribeitsparametershere.Thisfunctioncan
beusediftheSPIperipheralisconfiguredtoworkbothin SPI_DIRECTION_1LINE or SPI_DIRECTION_-
2LINES modes. To receive an amount of bytes in polling mode, we use the function:
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size,
uint32_t Timeout);
This function can be used in all three Direction modes.
If the slave device supports the full-duplex mode, then we can use the function:
SPI 464
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData,
uint8_t *pRxData, uint16_t Size,
uint32_t Timeout);
whichallowstotransmitagivenamountofbyteswhilereceivingthesamequantitysimultaneously.
Clearly it works only when the SPI Direction is set to SPI_DIRECTION_2LINES .
To exchange data over the SPI in interrupt mode, the CubeHAL provides the functions:
HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData,
uint16_t Size);
HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData,
uint16_t Size);
HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData,
uint8_t *pRxData, uint16_t Size);
The CubeHAL routine to exchange data over the SPI in DMA mode are identical to the three one
before, except for the fact that they end in _DMA .
Once using interrupt- and DMA-based routines, we must be prepared to be notified when the
transmission is ended, since it is performed asynchronously. This means that we need to enable
the corresponding interrupt at NVIC level and to call the function HAL_SPI_IRQHandler() from the
ISR. There exist six different callbacks we can implement, as reported in Table 3.
Table 3: CubeHAL available callbacks when an SPI peripheral works in interrupt or DMA mode
Callback Description
HAL_SPI_TxCpltCallback() Signals that a given amount of bytes have been transmitted
HAL_SPI_RxCpltCallback() Signals that a given amount of bytes have been received
HAL_SPI_TxRxCpltCallback() Signals that a given amount of bytes have been transmitted and
received
HAL_SPI_TxHalfCpltCallback() Signals that the DMA SPI half transmit process is complete
HAL_SPI_RxHalfCpltCallback() Signals that the DMA SPI half receive process is complete
HAL_SPI_TxRxHalfCpltCallback() Signals that the DMA SPI half transmit and receive process is
complete
When the SPI peripheral is configured in DMA circular mode, we can use the following routines to
pause/resume/abort a DMA circular transaction:
HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi);
HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi);
HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi);
When the SPI works in DMA circular mode, the following restriction apply:
• the DMA circular mode cannot be used when the SPI is accessed exclusively in receive mode;
SPI 465
• the CRC feature is not managed when the DMA circular mode is enabled
• when the SPI DMA pause/stop features are used, we must use the function HAL_SPI_DMA-
Pause() / HAL_SPI_DMAStop() only under the SPI callbacks.
Inthischapterwewillnotanalyzeanyconcreteexample.InChapter26wewillusetheSPIperipheral
to program a hardwired TCP/IP embedded Ethernet controller, which allows us to build Internet-
based applications with Nucleo boards.
15.2.2 Maximum Transmission Frequency Reachable using the
CubeHAL
The SCK frequency is derived from the PCLK frequency using a programmable prescaler. This
prescaler ranges from 2¹ up to 2⁸. However, as said several other times before, the CubeHAL adds an
unavoidable overhead when driving peripherals. And this also applies to the SPI one. In fact, using
the CubeHAL it is not possible to reach all supported SPI frequencies with the different SPI modes.
ST engineers have clearly documented this in the CubeHAL. If you open the stm32XXxx_hal_-
spi.c file, you can see (about at line 60) two tables that report the maximum reachable transmission
frequency given the direction mode (half-duplex or full-duplex) and the way to program and use
the peripheral (polling, interrupt and DMA).
For example, in an STM32F4 MCU we can reach the a SCK frequency equal to f PCLK /8 if the SPI
peripherals works in slave mode and we program it using CubeHAL in interrupt mode.
15.3 Using CubeMX to Configure SPI Peripheral
To use CubeMX in order to enable the wanted SPI peripheral, we have to proceed in the following
order. First, we need to select the wanted communication mode from the IP tree view, as shown in
Figure 5. Next, we need to specify the behaviour of the NSS signal in the same configuration view.
Once these two parameters are set, we can proceed by configuring other SPI settings in the CubeMX
Configuration view.
Figure 5: How to select the SPI communication mode in CubeMX
16. Cyclic Redundancy Check
In digital systems it is perfectly possible that data gets corrupted, especially if it flows through a
communication medium. In digital electronics, a message is a stream of bits either equal to 0 or 1
and it becomes corrupted when one of more of these bits accidentally change during transmission.
For this reason, messages are always exchanged with some additional data used to detect if the
original message was corrupted. In Chapter 8 we have analyzed an early form of error detection
related to data transmission: the parity bit is an additional bit added to the message used to keep
track if the number of bits equal to 1 is odd or even (depending on the type of parity). However, this
method is not able to detect errors if two or more bits change at the same time.
The Cyclic Redundancy Check (CRC) is a widely-used technique for detecting errors in digital
data, both during transmission and storage. In the CRC method, a number of check bits, called
the checksum¹, are appended to the message being transmitted. The receiver can determine whether
or not the check bits agree with the data, to assert with a certain degree of probability if an error
occurred in transmission. If so, the receiver can ask to the sender to retransmit the message again.
This technique is also applied in some data storage devices, such as Hard Disk Drives. In this case
eachblockonthediskwouldhavecertaincheckbits,andthehardwaremightautomaticallyinitiatea
rereadoftheblockwhenanerrorisdetected,oritmightreporttheerrortosoftware.Itisimportantto
underline that CRC is a good method to identify corrupted messages, but not for making corrections
when errors are detected.
Being the CRC method used by a lot of communication peripherals and protocols (like the Ethernet,
MODBUS, etc.), it is quite common to find in microcontrollers dedicated hardware peripherals able
to compute CRC checksum of byte streams, freeing the CPU from performing this operation in
software. All STM32 microcontrollers provide a dedicated CRC peripheral, and this chapter briefly
explains how to use the corresponding CubeHAL module.
As usual, before going into the implementation details, we will first give a brief introduction to the
math behind the CRC technique².
16.1 Introduction to CRC Computing
CRC technique is based on well-known properties of polynomial arithmetic. To compute the
checksum of a stream of bits, the message is seen as a polynomial that is divided by another fixed
polynomial, called generator polynomial. The remainder of this operation is the checksum, which is
¹ The checksum is often called the CRC. This is not entirely correct, because the CRC is a specific error-detecting method, which uses a
well-characterized algorithm plus a checksum sequence of bits to detect if a message is corrupted. However, it is quite common to refer to the
checksum as the CRC, or the CRC code.
² A really excellent dissertation of CRC algorithms is represented by this on-line document by Ross N. Williams (http://www.zlib.net/crc_-
v3.txt)
Cyclic Redundancy Check 467
added to original message. The receiver will use it, together with the generator polynomial, to check
if the message is correct.
In practice, all CRC methods use polynomials in GF(2ⁿ). GF(pⁿ) stands for Galois field, also known
as finite field, that is a field with a finite number of elements. As with any field, aGalois field is a set
on which the operations of multiplication, addition, subtraction and division are defined and satisfy
certain basic rules. The most common examples of finite fields are given by the integers modulo p ,
where p is a prime number. In our case, p is equal to 2 and this implies that the GF(2ⁿ) field contains
only two elements, when n=1: 0 and 1.
In GF(2ⁿ) addition and subtraction are performed modulo 2, that is they correspond to the XOR
logical operation.
⊕ 0 1
0 0 1
1 1 0
The multiplication, instead, corresponds to the AND logical operation.
∧ 0 1
0 0 0
1 0 1
Polynomials in GF(2ⁿ) are polynomials in a single variable x whose coefficients are either 0 or 1. The
CRC technique interprets the bits of a data message as coefficients of a polynomial in GF(2ⁿ) with
a degree equal to n − 1 , where n is the length of the message. For example, assuming the message
11100110 2 , whose length is equal to 8, this corresponds to the polynomial:
x 7 · 1 + x 6 · 1 + x 5 · 1 + x 4 · 0 + x 3 · 0 + x 2 · 1 + x 1 · 1 + x 0 · 0 = x 7 + x 6 + x 5 + x 2 + x
As said before, in GF(2ⁿ) addition and subtraction correspond to XOR logical operation. This means
that the sum of the polynomials x 4 + x 3 + 1 and x 3 + x + 1 is equal to x 4 + x ³. Clearly, this is also the
same of the subtraction of the two polynomials.
Multiplication of polynomials in GF(2ⁿ) is, as usual, much like multiplying decimal integers
keeping track of powers of x instead of decimal places. For example, multiplying the previous two
polynomials we have:
³ Instead, in normal algebra the addition would be equal to x 4 + 2x 3 + x + 2 .
Cyclic Redundancy Check 468
As you can see, each term in the first multiplies each term in the second, and then we add them
following the addition rules in GF(2ⁿ).
Division of one polynomial by another in GF(2ⁿ) is analogous to long division (with remainder)
of integers, except there is no borrowing nor carrying. For example, let us divide the polynomial
x 7 + x 6 + x 5 + x 2 + x by the polynomial x 3 + x + 1 .
We start by dividing the first term of the dividend by the highest term of the divisor (meaning the
one with the highest power of x, which in this case is x 3 ). Next, we multiply the divisor by the result
just obtained (the first term of the eventual quotient).
Now we subtract the product just obtained from the appropriate terms of the original dividend
applying the rules of subtraction in GF(2ⁿ).
We repeat the previous steps, except this time use the two terms that have just been written as the
dividend.
Cyclic Redundancy Check 469
The process continues until the obtained dividend has a degree lower than the divisor. We have so
obtained the remainder of the division, which represents the checksum to append to the original
message.
There are two ways for the receiver to assess the correctness of the transmission. It can compute the
checksum from the first n bits of the received data, and verify that it agrees with the last r received
bits. Alternatively, and following usual practice, the receiver can divide all the received bits by the
generator polynomial and check that the r -bit remainder is 0.
However, the exact algorithm of CRC calculation usually differs from the normal polynomial
division. Moreover, the generator polynomial may define specific initial and final condition, as we
will see soon. This means that the generator polynomial cannot be left to change, but it is kept from
a portfolio⁴ of well-studied polynomials. For example, the widely adopted CRC-32 polynomial has
the form:
x 26 + x 23 + x 22 + x 16 + x 12 + x 11 + x 10 + x 8 + x 7 + x 5 + x 4 + x 2 + x + 1
which can be represented in binary with the sequence 00000100110000010001110110110111 2 and
in hexadecimal with the number 0x04C1 1DB7 . It is adopted by many transmission and storage
protocols, like Ethernet, Serial ATA, MPEG-2, BZip2 and PNG.
16.1.1 CRC Calculation in STM32F1/F2/F4/L1 MCUs
The long division of polynomial is suitable to perform manual calculations. However, another more
efficient CRC algorithm is the polynomial division with the bitwise message XORing technique,
⁴ http://bit.ly/293h2Hd
Cyclic Redundancy Check 470
which is suited to be implemented with dedicated hardware circuitry: shift registers.
The process of CRC calculation in STM32 microcontrollers is related to the algorithm defined by the
CRC-32 polynomial, which is the following one⁵:
• Initialize the CRC register with 0xFFFF FFFF XORed with the data value.
• Shift in the input stream bit by bit. If the popped out MSB is a ‘1’, XOR the CRC register value
with the generator polynomial.
• If all input bits are handled, the CRC shift register contains the CRC value.
Assuming a data value equal to 10100101 2 (0xAD), a CRC polynomial equal to 00010110 2 (0x16), the
algorithm implemented by STM32 MCUs works in this way (Figure 1 schematizes this process):
1. The initial content of CRC register is computed by XORing 0xFF and 0xAD.
2. Being the MSB bit 0, the CRC register is just left-shifted.
3. Now the MSB bit of CRC register is 1. We so first left-shift the register and then we perform
XOR with the CRC polynomial (0x16).
4. Being the MSB bit 0, the CRC register is just left-shifted.
5. Now the MSB bit of CRC register is 1. We so first left-shift the register and then we perform
XOR with the CRC polynomial (0x16).
6. Being the MSB bit 0, the CRC register is just left-shifted.
7. Now the MSB bit of CRC register is 1. We so first left-shift the register and then we perform
XOR with the CRC polynomial (0x16).
8. Now the MSB bit of CRC register is 1. We so first left-shift the register and then we perform
XOR with the CRC polynomial (0x16).
9. Finally the MSB is again 0. We so perform a left-shift of the CRC register. The final value
represents the checksum to prepend to the message.
The above algorithm is just a simplification of the actual one implemented in STM32 MCUs. In fact,
it differs for two main reasons:
• The CRC polynomial is fixed and corresponds to the CRC-32 ( 0x04C1 1DB7 ).
• The single input/output data register is 32-bit wide and the CRC checksum is computed on the
whole 32-bit register and not byte-by-byte⁶.
This dramatically limits the effective usability of this peripheral.
⁵ As we will see next, STM32F0,F3,F7,L0,L4 MCUs uses a slightly different and powerful CRC peripheral not limited to the CRC-32
polynomial.
⁶ This is an important distinction compared to algorithms implemented in several libraries and on-line calculators, which usually perform
CRC computation by splitting the word in sub-bytes. Refer to this post(http://bit.ly/29303sh) and this other one(http://bit.ly/293067u) on the
official ST forum by the clive1 user (the most active and experienced user on STM32 related sub-forum).
Cyclic Redundancy Check 471
Figure 1: How CRC checksum is computed in an STM32
16.1.2 CRC Peripheral in STM32F0/F3/F7/L0/L4 MCUs
In the previous paragraph we have seen that the STM32 peripheral provided by some STM32 MCUs
is limited to the computation of the CRC using the CRC-32 Ethernet polynomial. Moreover, the
handled data size for every computation is 32-bit.
In more recent STM32-series this limitation has been superseded. In fact, STM32F0/F3/F7/L0/L4
MCUs provide a more advanced CRC peripheral, as shown in Table 1.
Cyclic Redundancy Check 472
Table 1: Effective implementation of the CRC peripheral in STM32 MCUs
In these MCUs, the CRC peripheral is designed to be compatible by default with the simpler CRC
peripheral provided by STM32F1/F2/F4/L1 MCUs. This means that, without an explicit configura-
tion,thecodedesignedtorunonSTM32F1/F2/F4/L1MCUswillrunonSTM32F0/F3/F7/L0/L4MCUs
without any change.
16.2 HAL_CRC Module
The CubeHAL provides a dedicated module to manipulate CRC peripheral registers: the HAL_CRC .
The CRC peripheral is referenced by using an instance of the CRC_HandleTypeDef struct . In
STM32F1/F2/F4/L1 MCUs providing the simplest CRC peripheral, this struct is defined in the
following way:
typedef struct {
CRC_TypeDef *Instance; /* CRC registers base address */
HAL_LockTypeDef Lock; /* CRC locking object */
__IO HAL_CRC_StateTypeDef State; /* CRC communication state */
} CRC_HandleTypeDef;
The only relevant field is the Instance one, which is the pointer to the CRC peripheral descriptor
(whose base address is defined by the CRC macro).
Instead, in STM32F0/F3/F7/L0/L4 MCUs the CRC_HandleTypeDef struct is defined in the following
way:
Cyclic Redundancy Check 473
typedef struct {
CRC_TypeDef *Instance; /* Register base address */
CRC_InitTypeDef Init; /* CRC configuration parameters */
HAL_LockTypeDef Lock; /* CRC Locking object */
__IO HAL_CRC_StateTypeDef State; /* CRC communication state */
uint32_t InputDataFormat; /* Specifies input data format. */
} CRC_HandleTypeDef;
The only relevant difference is the existence of the Init field, which is used to configure the CRC
peripheral as we will see in a while, and the InputDataFormat field, which specifies the data size of
the input data: it can assume a value from Table 2.
Table 2: Input data formats for the CRC peripheral
Data format Description
CRC_INPUTDATA_FORMAT_BYTES Input data is a stream of bytes (8-bit data)
CRC_INPUTDATA_FORMAT_HALFWORDS Input data is a stream of half-words (16-bit data)
CRC_INPUTDATA_FORMAT_WORDS Input data is a stream of words (32-bits data)
To configure the CRC peripheral in those MCUs we use an instance of the CRC_InitTypeDef struct ,
which is defined in the following way:
typedef struct {
uint8_t DefaultPolynomialUse; /* Indicates if default polynomial is used */
uint8_t DefaultInitValueUse; /* Indicates if default init value is used */
uint32_t GeneratingPolynomial; /* Set CRC generating polynomial */
uint32_t CRCLength; /* Indicates CRC length */
uint32_t InitValue; /* Set the initial value to start CRC computation */
uint32_t InputDataInversionMode; /* Specifies input data inversion mode */
uint32_t OutputDataInversionMode; /* Specifies output data (i.e. CRC) inversion mode */
} CRC_InitTypeDef;
Let us analyze the fields of this struct :
• DefaultPolynomialUse : this field indicates if the default polynomial (that is, the CRC-32) or a
custom one is used. It can assume the values DEFAULT_POLYNOMIAL_ENABLE or DEFAULT_POLYNO-
MIAL_DISABLE . In this last case, the fields GeneratingPolynomial and CRCLength must be set.
• DefaultInitValueUse :thisfieldindicatesifthedefaultCRCinitializationvalue(thatis, 0xFFFF
FFFF ) or a custom one is used. It can assume the values DEFAULT_INIT_VALUE_ENABLE or
DEFAULT_INIT_VALUE_DISABLE . In this last case, the field InitValue must be set.
• GeneratingPolynomial : sets CRC generating polynomial. 7, 8, 16 or 32-bit long value for a
polynomial degree equal to 7, 8, 16 or 32. This field is written in normal representation, e.g.,
for a polynomial of degree 7, X 7 + X 6 + X 5 + X 2 + 1 is written 0x65.
• CRCLength : this field indicates the length of the CRC, and it can assume a value from Table 3.
Cyclic Redundancy Check 474
• InitValue : sets the custom initial value to start CRC computation.
• InputDataInversionMode : specifies if the input data must be inverted or not. It can assume a
value from Table 4.
• OutputDataInversionMode : specifies if the output data (the computed CRC) must be inverted
or not. It can assume the values CRC_OUTPUTDATA_INVERSION_DISABLE and CRC_OUTPUTDATA_-
INVERSION_ENABLE . In this last case, the operation is done at bit level: for example, output data
0x1122 3344 is converted into 0x22CC 4488 .
Table 3: CRC length
CRC Length Description
CRC_POLYLENGTH_32B 32-bit CRC
CRC_POLYLENGTH_16B 16-bit CRC
CRC_POLYLENGTH_8B 8-bit CRC
CRC_POLYLENGTH_7B 7-bit CRC
Table 4: Input data inversion mode
Inversion mode Description
CRC_INPUTDATA_INVERSION_NONE No input data inversion
CRC_INPUTDATA_INVERSION_BYTE Byte-wise inversion, 0x1A2B 3C4D becomes 0x58D4 3CB2
CRC_INPUTDATA_INVERSION_HALFWORD Halfword-wise inversion, 0x1A2B 3C4D becomes 0xD458 B23C
CRC_INPUTDATA_INVERSION_WORD Word-wise inversion, 0x1A2B 3C4D becomes 0xB23C D458
Once an instance of the CRC_InitTypeDef struct is defined, and its fields are correctly populated,
we configure the CRC peripheral by calling the function:
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc);
To compute the CRC checksum of a data buffer, we use the function:
uint32_t HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[],
uint32_t BufferLength);
which accepts a pointer to an uint32_t array and its length. This function sets the default CRC
initial value to 0xFFFF FFFF or the specified value if we are working with an STM32F0/F3/F7/L0/L4
MCU. If, instead, we need to compute the CRC starting with the previous computed CRC as initial
value, then we can use the function:
Cyclic Redundancy Check 475
uint32_t HAL_CRC_Accumulate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[],
uint32_t BufferLength);
This is useful especially when we are computing CRC checksum of large block of data, using a
temporary buffer having a size smaller than the source block.
17. IWDG and WWDG Timers
Anything that can go wrong, will go wrong, states the Murphy’s Law¹. And this is dramatically
true especially for embedded systems. Apart from hardware faults, which can also impact on the
software, even the most careful design may have some unexpected conditions that lead to abnormal
behaviour of our device. And this may have important costs, especially if the device is designed to
work in dangerous and critical contexts.
Almost all embedded microcontrollers on the market provide a WatchDog Timer (WDT)². A
watchdog is usually implemented as a free-running and down-counter timer, which causes a reset
of the MCU when it reaches zero or if the timer counter is not reloaded to its initial value within a
well defined temporal window (in this case we talk about windowed watchdog). Once enabled, the
firmware needs to “constantly” refresh the watchdog counter register to its initial value, otherwise
the MCU reset line is asserted low by the timer and a hard reset keeps going.
A smart management of the WDT can help us to handle all those unwanted situations that lead
to faulty conditions of the embedded firmware (un-handled exceptions, stack overflows, access to
invalid memory locations, corruption of the SRAM due to unstable power source, unconditional
loops and so on). Moreover, if the WDT is able to warn us when the timer is running out, we can
try to recover the regular activities of the firmware or, at least, to put the device in a safe state.
STM32 microcontrollers provide two independent watchdog timers: the Independent Watchdog
(IWDG) and the System Window Watchdog (WWDG). They share almost the same characteristics,
except for a couple of them that make one timer more suitable than the other in some specific
applications.ThischaptershowshowtousetheCubeHALtotakeadvantageofthesetwoimportant,
and often underused, peripherals.
17.1 The Independent Watchdog Timer
The IWDG is a 12-bit down-counter timer clocked by the Low-Speed Internal (LSI) oscillator: this
explains the adjective independent, meaning that this peripheral is not fed by the peripheral clock,
which is in turn generated by HSI or HSE oscillators. This is an important characteristic, which
allows to the IWDG timer to work even if the main clock fails: the watchdog still keeps counting
even if the CPU is halted, and it will reset the MCU when reaches zero. If the firmware is properly
designed to address this issue, the MCU can recover from a faulted clock using the internal oscillator
(HSE).
¹ This author prefers the less famous Smith’s Law, which states: Murphy was an optimist.
² There exist really low-cost MCUs that do not provide this feature, or which implement it in a unreliable way, requiring to adopt external
and dedicated ICs.
IWDG and WWDG Timers 477
In STM32F0/F3/F7/L0/L4 families, this timer can optionally work in windowed mode. This means
that we can setup a temporal window (ranging from 0x0 up to 0xFFF) that establishes when it is ok
to refresh the timer counter. If we refresh the timer before the counter reaches the window value,
then the MCU is reset in the same way when the timer reaches zero. This allows to ensure that
“things” are moving in the right way, especially when the MCU accomplishes repetitive tasks that
work in a well-defined temporal window.
How long does the IWDG timer take before the MCU is reset? The following formula establishes
the update event of the IWDG timer:
UpdateEvent IWDG =
(2 IWDG PSC )(Period + 1)
LSI clock
[1]
where Period ranges from 0 up to 4095 and IWDG PSC corresponds to a dedicate 3-bit prescaler that
ranges from 2 to 8. For example, assuming an LSI clock running at 32kHz, a Period equal to 0xFFF
and a IWDG PSC equal to 2, we have that the IWDG timer will underflow after:
UpdateEvent IWDG =
(2 2 )(4096)
32000
≈ 0.5s
The IWDG timer also supports the hardware watchdog feature. A special bit of the option bytes
region, an area of the flash memory that we will study in Chapter 21, configures the timer so that it
automatically starts counting after every system reset.
Different from regular timers, and from other microcontroller architectures, once an STM32
watchdog timer is started there is no way to stop it. This is an important thing to keep in mind
while developing low-power applications³.
17.1.1 Using the CubeHAL to Program IWDG Timer
To manipulate the IWDG peripheral, the HAL defines the C struct IWDG_HandleTypeDef , which is
defined in the following way:
typedef struct {
IWDG_TypeDef *Instance; /* Pointer to IWDG descriptor */
IWDG_InitTypeDef Init; /* IWDG initialization parameters */
HAL_LockTypeDef Lock; /* IWDG locking object */
__IO HAL_IWDG_StateTypeDef State; /* IWDG communication state */
} IWDG_HandleTypeDef;
To configure the IWDG peripheral we use an instance of the C struct IWDG_InitTypeDef , which is
defined in the following way:
³ In Chapter 19 about power management, we will see how to address this limitation.
IWDG and WWDG Timers 478
typedef struct {
uint32_t Prescaler; /* Selects the prescaler of the IWDG */
uint32_t Reload; /* Specifies the IWDG down-counter reload value */
uint32_t Window; /* Specifies the window value to be compared to the down-counter */
} IWDG_InitTypeDef;
Let us study the fields of this C struct .
• Prescaler : this field specifies the prescaler value, and it can assume all powers of two ranging
from 2² up to 2⁸. To specify this value, the CubeHAL defines seven different macros - IWDG_-
PRESCALER_4 , IWDG_PRESCALER_8 , …, IWDG_PRESCALER_256 .
• Reload : specifies the timer period, that is the auto-reload value when the timer is refreshed. It
can range from 0x0 up to 0xFFF (the default value).
• Window : for those STM32 MCUs providing a windowed IWDG, this field sets the corresponding
window value within which it is allowed to refresh the timer. It can ranges from 0x0 up to
0xFFF (the default value).
To configure and to start the IWDG timer, we use the CubeHAL function:
HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg);
while to refresh it before it reaches zero, we use the function:
HAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg);
17.2 The System Window Watchdog Timer
The WWDG is a 7-bit down-counter timer clocked by the APB clock. Different from the IWDG
timer, the WWDG one is designed to be refreshed within a given temporal window, otherwise it
triggers the MCU reset. The way the WWDG timer works may seem a little bit counterintuitive for
newcomers. Let us explain the way it works step-by-step.
The WWDG is a 7-bit timer (see Figure 1). Its counter register can be set from 0x7F down to 0x40.
This value will be used to reload the counter register upon refresh (we are going to call this value
T S ).
Figure 1: The content of the WWDG counter register upon reset
IWDG and WWDG Timers 479
The WWDG timer has this particular characteristic: when the counter’s 7th bit (T6 in Figure 1)
switches from 1 to 0, a system reset takes place. This means that when the counter reaches the value
T E = 0x3F , which corresponds to 0111111 2 , the MCU is reset.
The WWDG is fed by the APB bus main clock. The clock is prescaled by a fixed factor (4096) plus
a programmable one, according to the following formula:
WWDG PSC = 4096 · 2 i where 0 ≤ i ≤ 3
Forexample,assuminga WWDG PSC = 4096·8 andanAPBclockof48MHz,wehavethatthecounter
is decremented by 1 every 682.6μS.
As said before, the WWDG timer can be refreshed only within a given temporal window: this
programmable value can range from T S down to 0x40: the closer to T S is, the wider is the window.
For example, if we configure the window register with the value T W = 0x5F , we can refresh the
WWDG timer only when its counter goes from 0x5F down to 0x40. The Figure 2 clearly shows the
role of the temporal window. If we try to refresh the WWDG timer in those greyed regions, that is
between 0x7F and 0x60, or when the counter goes below 0x3F, then the MCU will be reset.
Figure 2: How the temporal window defines the counter interval within which it is allowed to refresh the WWDG
timer
How long does the temporal window last? This is defined by the following formula:
WWDG Window =
WWDG PSC · (Period + 1)
APB clock
[2]
where
Period = T S − T W [3]
Forexample,letussupposetosetthecounterrefreshvalue(thatis, T S )to0x7Fandthewindowvalue
(that is, T W ) to 0x5F. Moreover, let us assume an APB clock equal to 48MHz and a programmable
prescaler factor equal to 8. We have that:
WWDG W MIN =
4096 · (2 3 ) · (0x20 + 1)
48000000
≈ 22.5ms
IWDG and WWDG Timers 480
This represents the minimum timeout we have to wait before we can refresh the WWDG counter.
The maximum timeout, instead, is represented by the lower and fixed value 0x40. Using again [2],
we have that:
WWDG W MAX =
4096 · (2 3 ) · (0x3F + 1)
48000000
≈ 43.6ms
This means that refreshing the WWDG timer before 22.5ms or after 43.6ms since the last refresh
will cause a system reset.
WWDG has another important characteristic: when the counter reaches the value T I = 0x40 , just
one “tick” before the 0x3F value that will cause the MCU reset, a dedicate IRQ fires, if enabled. This
interrupt, called Early Wakeup Interrupt (EWI), can be used to eventually refresh the WWDG timer
in extremis, or to place the device in a safe state. The dedicated ISR is called WWDG_IRQHandler() ,
and it is the first ISR after the fifteen Cortex-M exceptions.
Finally, even the WWDG supports the hardware watchdog feature like the IWDG timer.
17.2.1 Using the CubeHAL to Program WWDG Timer
To manipulate the WWDG peripheral, the HAL defines the C struct WWDG_HandleTypeDef , which
is defined in the following way:
typedef struct {
WWDG_TypeDef *Instance; /* Pointer to WWDG descriptor */
WWDG_InitTypeDef Init; /* WWDG initialization parameters */
HAL_LockTypeDef Lock; /* WWDG locking object */
__IO HAL_WWDG_StateTypeDef State; /* WWDG communication state */
} WWDG_HandleTypeDef;
To configure the WWDG peripheral we use an instance of the C struct WWDG_InitTypeDef , which
is defined in the following way:
typedef struct {
uint32_t Prescaler; /* Select the prescaler of the WWDG */
uint32_t Window; /* Specifies the window value to be compared to the down-counter */
uint32_t Counter; /* Specifies the WWDG down-counter reload value */
uint32_t EWIMode; /* Specifies if WWDG Early Wakeup Interupt is enable or not.
This parameter can be a value of @ref WWDG_EWI_Mode */
} WWDG_InitTypeDef;
Let us study the fields of this C struct .
• Prescaler : this field specifies the prescaler value, and it can range from all powers of two
between 1 and 8. To specify this value, the CubeHAL defines four different macros - WWDG_-
PRESCALER_1 , WWDG_PRESCALER_2 , …, WWDG_PRESCALER_8 .
IWDG and WWDG Timers 481
• Window : this field sets the corresponding window value within which it is allowed to refresh
the timer. It can ranges from the value of the Counter field (the default one) down to 0x3F.
• Counter : specifies the timer period, that is the reload value when the timer is refreshed. It can
range from 0x7F (the default value) down to 0x3F.
• EWIMode : this fields enables the Early Wakeup Interrupt (EWI) and it can assume the values
WWDG_EWI_ENABLE and WWDG_EWI_DISABLE .
To configure and to start the WWDG timer, we use the CubeHAL function:
HAL_StatusTypeDef HAL_WWDG_Init(WWDG_HandleTypeDef *hwwdg);
When the WWDG timer EWI mode is enabled, we have to implement the WWDG_IRQHandler() ISR
and to place a call to the function:
void HAL_WWDG_IRQHandler(WWDG_HandleTypeDef *hwwdg);
Theproperwaytobenotifiedwhentheinterruptfiresconsistsinimplementingthecallbackroutine:
void HAL_WWDG_EarlyWakeupCallback(WWDG_HandleTypeDef* hwwdg);
To refresh the WWDG timer within the temporal window, we use the function:
HAL_StatusTypeDef HAL_WWDG_Refresh(WWDG_HandleTypeDef *hwwdg, uint32_t Counter);
where the Counter parameter corresponds to the value to reload inside the WWDG counter register.
Finally, being the WWDT timer clocked by the APB clock, we need to enable the peripheral clock
by using the macro __HAL_RCC_WWDG_CLK_ENABLE() .
17.3 Detecting a System Reset Caused by a Watchdog
Timer
It could be useful to detect when a system reset is caused by the expiring of a watchdog timer. This
mayhelpusunderstandingwhatisgoingwrongduringadebugsession.Twospecialbitsinaregister
of the Reset and Clock Control (RCC) peripheral allows to detect this event.
To detect if a reset has been caused by the IWDG timer, we can check the corresponding flag using
the following macro:
IWDG and WWDG Timers 482
__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST);
while for the WWDG timer we can check this other flag:
__HAL_RCC_GET_FLAG(RCC_FLAG_WWDGRST));
17.4 Freezing Watchdog Timers During a Debug Session
During a debug session, both WWDG and IWDG timers will keep counting. This will prevent us
to carry out a step-by-step debugging. We can configure debug interface so that it halts watchdog
timers when the MCU is halted using the following macros:
__HAL_DBGMCU_FREEZE_IWDG();
__HAL_DBGMCU_FREEZE_WWDG();
17.5 Selecting the Right Watchdog Timer for Your
Application
Both the watchdog timers have similar functionalities, and both of them do the same thing: to reset
the MCU if we do not refresh their counter register in a given amount of time. But when it is best
to prefer a timer over to other?
The IWDG timer is to prefer when we need to be sure that the main clock is working. Being the
IWDGclockedbytheindependentLSI,itisreallyusefultodetectsuchmalfunctions.Moreover,ifwe
are using an RTOS, we can setup an independent thread configured with the maximum priority and
that uses a software timer to refresh the IWDG timer periodically. This also helps us understanding
that the kernel is properly scheduling threads.
TheWWDGtimermustbepreferredtotheIWDGonewhenwehavetobesurethatsomeoperations
are carried out in a fixed and well-characterized temporal window. If that procedure takes less or
more time, it will not be able to refresh the timer in the temporal window, causing a system reset.
Moreover, the WWDG is the right choice if we want to perform critical operations (like putting the
machine in a safe state, or saving special data in non-volatile memory): thanks to the early-warning
IRQ, we can get notified of the ongoing system reset.
18. Real-Time Clock
There exist a significant number of embedded applications that need to keep track of the current
time and date. Data-loggers, timers, home appliances and control devices are just a limited example.
Traditionally, microcontrollers are interfaced with dedicated ICs, which are able to communicate
using the SPI or the I²C bus. For example, the same ST Microelectronics sells the M41T81¹ IC, a
popular Real-Time Clock (RTC) that requires a couple of passives and a 32kHz oscillator to keep
track of the current time. Moreover, the same IC is also able to generate alarm events and to act as
a watchdog timer.
All STM32 microcontrollers provide an integrated RTC unit that is not limited to keeping track of
the current date/time. In fact, RTC provides some additional and relevant features such as anti-
tampering detection, generation of alarm events and the ability to wake-up the MCU from deeper
low-power modes. This chapter shows how to program this peripheral using the related CubeHAL
module.
18.1 Introduction to the RTC Peripheral
The STM32 RTC is an independent Binary Coded Decimal (BCD) counter. BCD is one type of binary
encoding where each digit of a decimal number is represented independently by a fixed number of
bits. For example, the RTC timer represents the current hour in the following way:
• two bits are used to encode the hour tens;
• four bits are used to encode the hour units;
• three bits are used to encode the minute tens;
• four bits are used to encode the minute units.
Figure 1: How the time is encoded in BCD format in an STM32 MCU
Figure 1 shows how the STM32 RTC encodes the current hour in BCD format. Why to use this
approach to encode the date/time? This way to keep track of current date/time is typical of small
embeddedsystemsanditallowstorepresentthetimeinhuman-readableformatwithoutperforming
¹ http://bit.ly/2fj3vCM
Real-Time Clock 484
any type of conversion. Traditionally, high-level Operating Systems keep track of the time using
an unsigned long variable, which is automatically incremented at every second. For example, the
UNIXtimeisrepresentedwiththenumberofsecondselapsedsincetheEpoch,whichcorrespondsto
the00:00:00,Thursday,January1st1970.However,alotofCPUpowerandfirmwareroomisrequired
to convert the number of seconds elapsed since that date to the current date/time. Conversion
routines need to keep track of several factors, like how many days are in a month, leap years and
seconds, and so on. BCD encoding allows to immediately arrange current date/time in a way that
is understandable for a lot of people on the earth, at the cost of a more complex internal circuitry.
The STM32 RTC peripheral allows to easily configure and to display the calendar data fields:
• Calendar with:
– sub-seconds (not programmable)
– seconds
– minutes
– hours in 12-hour or 24-hour format
– day of the week (day)
– day of the month (date)
– month
– year
• Automatic management of 28-, 29- (leap year), 30-, and 31-day months
• Daylight saving time adjustment programmable by software
Differentfrom the majority of STM32 peripherals, the RTCcan be clocked independently from three
distinct clock sources: LSI, LSE and HSE. A series of dedicated prescalers allows delivering a 1Hz
clocktocalendarunit,regardlessoftheclocksource.WhentheclocksourcefortheRTC(RTCCLK)is
theHSE,itisuserresponsibilitytoproperlyconfiguretheprescalerssothattherightclockfrequency
can fed the RTC. However, CubeMX is designed to handle that automatically according to the
specified HSE crystal frequency.
Even if the RTC provides tools to correct imprecisions of the clock, as we will see later, not all
clock sources are suitable to achieve a good precision of the RTC, especially if the MCU works at
temperatures different from the ambient one. If precision is important for your application, then
it is strongly suggested to use a dedicated external LSE crystal, tuned according to the crystal
specifications and PCB layout.
The RTC functionalities are not limited to the time/date management. The RTC provides two
independent alarm units, named Alarm A and Alarm B, which can be used to generate events
when the RTC counter reaches the configured alarm value. Alarm units are highly customizable:
sub-second, seconds, minutes, hours and date fields can be independently selected or masked to
provide a rich combination of alarms. Together with the two alarm units, the RTC provides an
independent, programmable and dedicated wakeup unit used to wake up the MCU from deeper
sleep states. In fact, in the next chapter we will see that the RTC is the only peripheral able to wake
up the MCU from the standby sleep state on a programmable basis.
Real-Time Clock 485
Finally, the RTC provides the ability to sample a number of given inputs to detect tampering: since
the RTC peripheral can be powered by a battery² in several STM32 microcontrollers, it is also able
to detect tampering even if the device is powered off. On tamper detection, a particular register is
set and the content of the backup memory is also zeroed.
18.2 HAL_RTC Module
ToprogramtheRTCperipheral,theHALdefinestheC struct RTC_HandleTypeDef ,whichisdefined
in the following way:
typedef struct {
RTC_TypeDef *Instance; /* Register base address */
RTC_InitTypeDef Init; /* RTC required parameters */
HAL_LockTypeDef Lock; /* RTC locking object */
__IO HAL_RTCStateTypeDef State; /* Time communication state */
} RTC_HandleTypeDef;
The only notably fields of this struct are Instance , which is the pointer to the RTC peripheral
descriptor, and the Init field used to configure the peripheral. This field is an instance of the C
struct RTC_InitTypeDef , which is defined in the following way:
typedef struct {
uint32_t HourFormat; /* Specifies the RTC Hour Format. */
uint32_t AsynchPrediv; /* Specifies the RTC Asynchronous Predivider value. */
uint32_t SynchPrediv; /* Specifies the RTC Synchronous Predivider value. */
uint32_t OutPut; /* Specifies which signal will be routed to the RTC output. */
uint32_t OutPutPolarity; /* Specifies the polarity of the output signal. */
uint32_t OutPutType; /* Specifies the RTC Output Pin mode. */
} RTC_InitTypeDef;
• HourFormat :thisfieldspecifiesthehourformat,anditcanassumethevalues RTC_HOURFORMAT_-
12 to setup the AM/PM hour format ant the RTC_HOURFORMAT_24 to specify the 24 hour/day
format.
• AsynchPrediv and SynchPrediv : two prescalers are used to derive the 1Hz clock to feed the
RTC peripheral from the LSI/LSE/HSE oscillator sources. The first one is the asynchronous
prescaler, a 7-bit counter that feeds in turn the synchronous prescaler, another 15-bit counter.
The values of these two fields must be set so that the 1Hz frequency is reached according to
equation [1], where Calendar CLK is one of LSI/LSE/HSE. At the time of writing this chapter,
the latest CubeMX release (4.22) is not able to automatically derive the proper values for the
AsynchPrediv and SynchPrediv fields. You can use the values reported in Table 1 for most
relevant oscillator frequencies.
² In the next chapter we will see that STM32 MCUs with high pin count provide several independent power domains. The RTC belongs to
the VBAT domain, that is the set of all peripherals that are powered through the VBAT pin. This domain is especially designed to be tied to a
battery, and all peripherals belonging to this domain keep working even when the main power, and hence the MCU core, is OFF.
Real-Time Clock 486
Calendar CLK =
RTCCLK
(AsynchPrediv + 1)(SynchPrediv + 1)
[1]
Table 1: Correct values for the AsynchPrediv and SynchPrediv fields according to the most common clock sources
Calendar CLK AsynchPrediv SynchPrediv
HSE_RTC = 1MHz 124 7999
LSE = 32.768kHz 127 255
LSI = 32kHz 127 249
LSI = 37kHz 127 295
• OutPut :specifiesthesignalI/OroutedtotheRTCoutput.Itcanassumethevalues RTC_OUTPUT_-
ALARMA , RTC_OUTPUT_ALARMB , RTC_OUTPUT_WAKEUP and RTC_OUTPUT_DISABLE to route the output
to the signal related to Alarm A, B, Wakeup or to disable the output signal. Please, take note
that the actual GPIO associated to a given alarm is designed during the MCU development and
it is fixed. Depending on the type of package used, just one signal I/O may be available and
shared between the three alarm sources. For example, all STM32 MCU with LQFP-64 package
have just one alarm I/O named AF1 and connected to the PC13 pin.
• OutPutPolarity : this field specifies the output polarity of the signal, and it can assume the
values RTC_OUTPUT_POLARITY_HIGH and RTC_OUTPUT_POLARITY_LOW .
• OutPutType : this field specifies the type of the output signal, and it can assume the values
RTC_OUTPUT_TYPE_OPENDRAIN and RTC_OUTPUT_TYPE_PUSHPULL .
As usual, to configure the RTC peripheral we use the function:
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc);
which accepts a pointer to an instance of the RTC_HandleTypeDef struct seen before.
18.2.1 Setting and Retrieving the Current Date/Time
The CubeHAL implements separated routines and C structs to set and retrieve the current date and
time. The functions:
HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc,
RTC_TimeTypeDef *sTime, uint32_t Format);
HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc,
RTC_TimeTypeDef *sTime, uint32_t Format);
are used to set/get the current time, while the functions:
Real-Time Clock 487
HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc,
RTC_DateTypeDef *sDate, uint32_t Format);
HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc,
RTC_DateTypeDef *sDate, uint32_t Format);
are used to set/get the current date.
The RTC_TimeTypeDef struct , used to set/get the current time, is defined in the following way:
typedef struct {
uint8_t Hours; /* Specifies the RTC Time Hour.
This parameter must be a number between 0 and 12 if the
12 hours format is selected. Otherwise it must be a
number between 0 and 23 if the 24 hours format is selected */
uint8_t Minutes; /* Specifies the RTC Time Minutes.
This parameter must be a number between 0 and 59 */
uint8_t Seconds; /* Specifies the RTC Time Seconds.
This parameter must be a number 0 and 59 */
uint8_t TimeFormat; /* Specifies the RTC AM/PM Time. */
uint32_t SubSeconds; /* Specifies the RTC_SSR RTC Sub Second register content.
Not used when setting the timer */
uint32_t SecondFraction; /* Specifies the range or granularity of Sub Second register */
uint32_t DayLightSaving; /* Specifies DayLight Save Operation. */
uint32_t StoreOperation; /* Specifies Store Operation value */
} RTC_TimeTypeDef;
Let us analyze the role of the most important fields:
• Hours , Minutes , Seconds : these fields are used to set the current time.
• TimeFormat : it is used to set the time format (12/24 hours) and it can assume the values RTC_-
HOURFORMAT_12 or RTC_HOURFORMAT_24 .
• SubSeconds : when the struct RTC_TimeTypeDef is populated by the HAL_RTC_GetTime() rou-
tine, this field contains the current sub-second value. It is ignored by the HAL_RTC_SetTime()
routine. This field corresponds to a time unit range between [0-1] second, with granularity
equal to 1s/( SecondFraction +1).
• SecondFraction : specifies the granularity of SubSeconds field, and it corresponds to Syn-
chronous prescaler factor value. This field will be used only by HAL_RTC_GetTime() function.
• DayLightSaving : this field specifies the DayLight saving and it can assume the values RTC_-
DAYLIGHTSAVING_SUB1H , RTC_DAYLIGHTSAVING_ADD1H , RTC_DAYLIGHTSAVING_NONE .
The RTC_DateTypeDef struct , used to set/get the current date, is defined in the following way:
Real-Time Clock 488
typedef struct {
uint8_t WeekDay; /* Specifies the RTC Date WeekDay. */
uint8_t Month; /* Specifies the RTC Date Month (in BCD format). */
uint8_t Date; /* Specifies the RTC Date. */
uint8_t Year; /* Specifies the RTC Date Year. */
} RTC_DateTypeDef;
Allthefourtime/daterelatedfunctionsacceptaslastparametertheformatoftime/daterelatedfields.
This parameter can assume the values RTC_FORMAT_BIN and RTC_FORMAT_BCD . If the RTC_FORMAT_BIN
constant is passed, then the time/date related fields are expressed in conventional binary format. For
example, the time “12:45” is expressed as is. If, instead, the RTC_FORMAT_BCD constant is passed, then
the values are expressed in BCD. This means that every time/date related field (which occupies one
byte) must be interpreted as two sub-nibbles, which correspond to the digits of a decimal number.
So, following the same previous example, we have that the decimal number “12” is expressed as 18 10
in binary format, which corresponds to 12 in the hexadecimal representation (see Figure 2).
Figure 2: How the time encoded in BCD format is returned by the
18.2.1.1 Correct Way to Read Date/Time Values
The current date/time value cannot be read freely, but there is a well-defined procedure to follow.
This because, by default, we do not directly access to RTC internal date/time registers. The RTC is
a peripheral that runs by its own and that it is not clocked through the APB bus. When the code
reads the calendar fields, it accesses to shadow registers that contain a copy of the real calendar time
and date clocked by the RTC clock (RTCCLK). The copy is performed every two RTCCLK cycles,
synchronized with the system clock (SYSCLK). Moreover, we must call the HAL_RTC_GetDate()
after HAL_RTC_GetTime() even if we are not interested to the current date. This because the call to
the HAL_RTC_GetDate() unlocks the values in the higher-order calendar shadow registers to ensure
consistencybetweenthetimeanddatevalues.ReadingRTCcurrenttimelocksthevaluesincalendar
shadow registers until current date is read. This is a really frequent error made by novices of the
STM32 platform: when accessing the time-related fields using the HAL_RTC_GetTime() we receive
the last transferred time unless we read the content of the date-related fields in the corresponding
shadow register.
Afterasystemresetorafterexitinglow-power modes,theapplicationmustwaitthesynchronization
between the RTC internal and shadow registers, before reading the calendar shadow registers. To
perform this operation, the CubeHAL provides the function:
Real-Time Clock 489
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc);
However, calling this function is required if and only if we want to access to shadow registers
immediately after a system reset or a wake up from a low-power mode, when the SYSCLK speed
is still at its minimum frequency (since it is fed by the HSI). If the HCLK speed is at least eight
time faster then the RTCCLK, then the synchronization of shadow registers happens in a few clock
cycles. When using the HAL_RTC_WaitForSynchro() routine, it is important to keep in mind that the
access in write mode to the so called backup domain (which include the RTC peripheral) is disabled
by default, to prevent corruption of peripheral registers due to an unstable power source. However,
the HAL_RTC_WaitForSynchro() routine needs to access in write mode to RTC registers, and so we
need to enable the access in write mode to the backup domain by using the macro __HAL_RTC_-
WRITEPROTECTION_DISABLE() , as shown below:
1 /* Disable the write-protection */
2 __HAL_RTC_WRITEPROTECTION_DISABLE(&hrtc);
3 /* Wait until the shadow registers are synchronized */
4 HAL_RTC_WaitForSynchro(&hrtc);
5 /* Enable again the write-protection to prevent registers corruption */
6 __HAL_RTC_WRITEPROTECTION_ENABLE(&hrtc);
Finally, it is possible to bypass the access to shadow registers. In this case, it is not mandatory to
wait for the synchronization time, but the calendar registers consistency must be checked by the
software. The user must read the required calendar field values twice. The results of the two read
sequencesarethencompared.Iftheresultsmatch,thereadresultiscorrect.Iftheydonotmatch,the
fields must be read one more time, and the third read result is valid. To bypass the shadow registers,
the CubeHAL provides the function:
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef* hrtc);
To re-enable shadow registers access again, we can use the function:
HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef* hrtc);
18.2.2 Configuring Alarms
STM32 RTC provides two alarms, named Alarm A and Alarm B, which have the same functional-
ities. An alarm can be generated at a given time or/and date programmed by the user. To setup an
alarm we use the function:
Real-Time Clock 490
HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc,
RTC_AlarmTypeDef *sAlarm, uint32_t Format);
We can eventually poll an alarm until the event has occurred by using the function:
HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
An alarm can be configured so that it asserts a dedicated interrupt when it fires. The IRQ associated
to both the alarms is the RTC_Alarm_IRQn , and to configure an alarm in interrupt mode we can use
the following dedicated routine:
HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc,
RTC_AlarmTypeDef *sAlarm, uint32_t Format);
Like all CubeHAL interrupt handler routines, we need to invoke the HAL_RTC_AlarmIRQHandler()
from the RTC_Alarm_IRQn ISR. To be notified from the alarm event, we can implement the
corresponding callback:
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
An alarm can be deactivated by using the function:
HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm);
The struct RTC_AlarmTypeDef , used to setup an alarm, is defined in the following way:
typedef struct {
RTC_TimeTypeDef AlarmTime; /* Specifies the RTC Alarm Time members */
uint32_t AlarmMask; /* Specifies the RTC Alarm Masks. */
uint32_t AlarmSubSecondMask; /* Specifies the RTC Alarm SubSeconds Masks. */
uint32_t AlarmDateWeekDaySel; /* Specifies the RTC Alarm is on Date or WeekDay. */
uint8_t AlarmDateWeekDay; /* Specifies the RTC Alarm Date/WeekDay. */
uint32_t Alarm; /* Specifies the alarm (A or B). */
} RTC_AlarmTypeDef;
• AlarmTime : this field is an instance of the RTC_TimeTypeDef struct seen before, and it is used
to setup the alarm time.
• AlarmMask : an alarm consists of a register with the same length as the RTC time counter. When
the RTC counter matches the value configured in the alarm register, it generates an event. The
AlarmMask field defines the comparison criteria between the alarm and the RTC time register.
It can assume one or more values (by bit-masking them) from those reported in Table 2. For
example, if we want that the alarm occurs at 12:45:03, we use the RTC_ALARMMASK_NONE value.
If, instead, we want to generate an alarm every hour, at a given minute and second, we can use
the value RTC_ALARMMASK_HOURS .
Real-Time Clock 491
Table 2: Available alarm masks to set up the alarm behaviour
Mask value Alarm behaviour
RTC_ALARMMASK_NONE All fields are used in alarm comparison (e.g., alarm occurs at 12:45:03)
RTC_ALARMMASK_SECONDS Seconds do not matter in alarm comparison(e.g., alarm occurs at every
seconds of 12:45)
RTC_ALARMMASK_SECONDS Seconds do not matter in alarm comparison(e.g., alarm occurs at every
seconds of 12:45)
RTC_ALARMMASK_MINUTES Minutes do not matter in alarm comparison (e.g., alarm occurs at the 3rd
second of every minute of 12:XX)
RTC_ALARMMASK_HOURS Hours do not matter in alarm comparison (e.g., alarm occurs at the 3rd
second of every 45th minute)
RTC_ALARMMASK_DATEWEEKDAY Week day (or date, if selected) do not matter in alarm comparison (e.g.,
alarm occurs all days at 12:45:03)
RTC_ALARMMASK_ALL Alarm occurs every second
• AlarmDateWeekDaySel : specifies if the alarm is set on a date (day of the month) or on a
weekday (monday, tuesday, etc.). It can assume the value RTC_ALARMDATEWEEKDAYSEL_DATE or
RTC_ALARMDATEWEEKDAYSEL_WEEKDAY .
• AlarmDateWeekDay : if the AlarmDateWeekDaySel field is set to RTC_ALARMDATEWEEKDAYSEL_DATE ,
thenthisfieldmustbesettoavalueinthe1-31range.Instead,ifthe AlarmDateWeekDaySel field
is set to RTC_ALARMDATEWEEKDAYSEL_WEEKDAY , then this field must be set to symbolic constants
RTC_WEEKDAY_MONDAY , RTC_WEEKDAY_TUESDAY and so on.
• AlarmSubSecondMask : the sub-seconds register of the RTC time can be used to generate events
with granularity lower than the second. By masking individual bits of the sub-seconds register
it is possible to generate events every 1/128s, 1/64s, and so on. For more information about the
masking possibilities, and their effect on the alarm behaviour, refer to the officialAN3371 from
ST³. This functionality allows, for example, to use the RTC as timebase generator for the HAL.
ST provides a such example in the CubeHAL projects. Refer to them for more about this.
• Alarm : it specifies the configured alarm, and it can assume the values RTC_ALARM_A and RTC_-
ALARM_B .
18.2.3 Periodic Wakeup Unit
In the next chapter we will see that STM32 microcontrollers provide the ability to selectively disable
internal functionalities in order to reduce the power consumption. Several low-power modes give to
programmersthepossibilitytodecidethepowerconsumptionlevelthatbestfitshisneeds,especially
when developing battery-powered devices.
TheSTM32RTCfeaturesaperiodictimebaseandwakeupunitthatcanwakeupthesystemwhenthe
microcontroller operates in low-power modes. This unit is a programmable 16-bit down-counting
and auto-reload timer. When this counter reaches zero, a flag is set and an interrupt (if enabled) is
generated. The wakeup unit has the following features:
³ http://bit.ly/2fcR1uE
Real-Time Clock 492
• Programmable down-counting auto-reload timer.
• Specific flag and interrupt able of waking up the device from low power modes.
• Wakeup alternate function output that can be routed to RTC alarm output (the output is shared
between Alarm A, Alarm B or Wakeup unit) with configurable polarity.
• A full set of prescalers to select the desired waiting period.
The wakeup counter counting frequency can be derived either by the RTCCLK source, and even-
tually further prescaled, or by the calendar clock (that is, after the asynchronous and synchronous
prescalers).Thisgivesthepossibilitytogeneratewakeupeventswithafrequencyrangingfrom122μs
up to more than 48 days when an external clock is chosen for the LSE oscillator.
To setup a wakeup event, the CubeHAL provides the function:
HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc,
uint32_t WakeUpCounter, uint32_t WakeUpClock);
where the WakeUpCounter parameter sets the autoreload value (that is, the period) of the wakeup
counter, and the WakeUpClock parameters sets the counter frequency, and it can assume one of the
values listed in Table 3.
Table 3: Available values for the WakeUpClock parameter
Wakeup counter clock source Description
RTC_WAKEUPCLOCK_RTCCLK_DIV2 The wakeup counter clock source is set to RTCCLK/2
RTC_WAKEUPCLOCK_RTCCLK_DIV4 The wakeup counter clock source is set to RTCCLK/4
RTC_WAKEUPCLOCK_RTCCLK_DIV8 The wakeup counter clock source is set to RTCCLK/8
RTC_WAKEUPCLOCK_RTCCLK_DIV16 The wakeup counter clock source is set to RTCCLK/16
RTC_WAKEUPCLOCK_CK_SPRE_16BITS The wakeup counter clock source is set to Calendar CLK
RTC_WAKEUPCLOCK_CK_SPRE_17BITS The wakeup counter clock source is set to Calendar CLK and the
wakeup counter increases of an additional bit (so it can count up to
0x1FFFF ).
An independent IRQ ( RTC_WKUP_IRQn ) is associated with the wakeup counter, and it can be enabled
by using the function:
HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter,
uint32_t WakeUpClock);
As usual, we must call the HAL_RTCEx_WakeUpTimerIRQHandler() from the ISR, and be prepared
to be notified of the wakeup event by implementing the HAL_RTCEx_WakeUpTimerEventCallback() .
Otherwise, if using the wakeup counter in polling mode, we can use the HAL_RTCEx_PollForWake-
UpTimerEvent() to detect the wakeup event (not that useful to be honest).
Real-Time Clock 493
18.2.4 Timestamp Generation and Tamper Detection
The RTC peripheral is hardwired to a number of signal I/Os depending on the package used. These
I/Os can be used to generate a timestamp when their state changes. Current date/time is so saved
inside dedicated registers, and the correspondng interrupt is also fired if enabled.
To set the timestamp generation, the CubeHAL provides the function:
HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge,
uint32_t RTC_TimeStampPin);
The TimeStampEdge parameter specifies the pin edge on which the timestamp is activated. This
parametercanbeoneofthefollowingvalues: RTC_TIMESTAMPEDGE_RISING and RTC_TIMESTAMPEDGE_-
FALLING . The RTC_TimeStampPin specifies the I/Os used to generate the timestamp, and it can
assume the value RTC_TIMESTAMPPIN_DEFAULT (which usually corresponds to PC13 pin), or the value
RTC_TIMESTAMPPIN_PA0 or RTC_TIMESTAMPPIN_POS1 to indicate an alternative pin (usually PA0 or
PI8).
Toenablethecorrespondinginterrupt,whichisassociatedwiththededicated TAMP_STAMP_IRQn IRQ,
we can use the function:
HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge,
uint32_t RTC_TimeStampPin);
The HAL_RTCEx_TamperTimeStampIRQHandler() is the handler to call from the ISR, while the HAL_-
RTCEx_TimeStampEventCallback() is the corresponding callback. If, instead, we want to use the
timestamp feature in polling mode, we can use the function:
HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout);
to poll for timestamp event. To retrieve the date/time saved in the timestamp registers, we can use
the function:
HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTimeStamp,
RTC_DateTypeDef *sTimeStampDate, uint32_t Format);
The same I/Os can be configured to detect tampering. The CubeHAL provides dedicated routines
and C structures to program this feature. We will not address them here. Refer to the CubeHAL
source code (especially to the module HAL_RTCEx ) for more about this.
18.2.5 RTC Calibration
RTC can be calibrated to compensate imprecisions of the RTCCLK source. This is especially useful
for applications that need an elevate RTC precision and for those applications that demand RTC
stability when temperature changes.
RTC peripheral offers two types of calibration: coarse and smooth calibration. Let us analyze them.
Real-Time Clock 494
18.2.5.1 RTC Coarse Calibration
The digital coarse calibration can be used to compensate crystal inaccuracy by adding (positive
calibration) or masking (negative calibration) clock cycles at the output of the asynchronous
prescaler. A negative calibration can be performed with a resolution of about 2 ppm, and a positive
calibration can be performed with a resolution of about 4 ppm. The maximum calibration ranges
from -63 ppm to 126 ppm.
WecanmeasuretheoutputfrequencybeforetheAsynchronousprescalerbyroutingittoadedicated
pin (which usually coincides with the AF1 pin). When this I/O is used for such operation it is also
referred to as AFO_CALIB pin. By measuring the output frequency with an oscilloscope we can
evaluate the quality of the RTCCLK. The AFO_CALIB is expected to emit a square wave with a
fixed 512Hz frequency.
To set the coarse calibration, the HAL provides the function:
HAL_RTCEx_SetCoarseCalib(RTC_HandleTypeDef *hrtc, uint32_t CalibSign, uint32_t Value);
The CalibSign parameter can accept the values RTC_CALIBSIGN_POSITIVE and RTC_CALIBSIGN_NEG-
ATIVE , while the Value parameter can range from 0 to 63 with a 2 ppm step when using negative
sign or from 0 to 126 with a 4 ppm step when using positive sign.
Figure 3: The structure of the RTC clock distribution
When calibrating the RTC using coarse calibration, it is important to underline the following points.
• It is not possible to check the calibration result, as the 512Hz output is before the calibration
block (see Figure 3⁴). You can check the calibration in some STM32 MCUs, as the 1Hz CK_Spre
output is after the coarse calibration block. Refer to the reference manual for your MCU.
• The calibration settings can only be changed during initialization. So use coarse calibration
only for static correction.
18.2.5.2 RTC Smooth Calibration
RTC frequency can be calibrated with a resolution of about 0.954 ppm with a range from -487.1
ppm to +488.5 ppm. The correction of the frequency is performed using series of small adjustments
(adding and/or simultaneously subtracting individual RTCCLK pulses). These adjustments are well
⁴ The figure is taken from the AN3371 from ST(http://bit.ly/2fcR1uE).
Real-Time Clock 495
distributed on a range of several seconds (8, 16 or 32 seconds), so that the RTC is well calibrated
even when observed over short durations of time.
Two RTC registers, named CALP and CALM , are used to add and/or subtract a given number of
RTCCLK pulses over the selected range (8, 16 or 32 seconds). While CALM allows the RTC frequency
to be reduced by up to 487.1 ppm with fine resolution, the bit CALP can be used to increase the
frequency by 488.5 ppm. Setting CALP register to ‘1’ effectively inserts an extra RTCCLK pulse every
2¹¹ RTCCLK cycles, which means that 512 clocks pulses are added during every 32-second cycle. By
specifying the number of RTCCLK pulses to be masked during the 32-second cycle using the CALM
register, the number of clock pulses to add can be decreased up to 0.
Using CALM together with CALP , an offset ranging from -511 to +512 RTCCLK cycles can be added
during the 32-second cycle, which translates to a calibration range of -487.1 ppm to +488.5 ppm with
a resolution of about 0.954 ppm. The formula to calculate the effective calibrated frequency ( F CAL )
given the input frequency ( F RTCCLK ) is as follows:
F CAL = F RTCCLK × [1 +
(CALP × 512 − CALM)
(220 + CALM − CALP × 512) ]
[2]
To set the smooth calibration, the HAL provides the function:
HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef* hrtc, uint32_t SmoothCalibPeriod,
uint32_t SmoothCalibPlusPulses, uint32_t SmouthCalibMinusPulsesValue);
SmoothCalibPeriod parameter can assume the values listed inTable 4 and it defines the distribution
interval. SmoothCalibPlusPulses parameter can assume the values RTC_SMOOTHCALIB_PLUSPULSES_-
SET and RTC_SMOOTHCALIB_PLUSPULSES_RESET and it is used to set/reset the single bit inside the CALP
register.
The SmouthCalibMinusPulsesValue parameter sets the number of clock pulses to subtract and it can
be any value from 0 to 511.
Table 4: Available values for the SmoothCalibPeriod parameter
Wakeup counter clock source Description
RTC_SMOOTHCALIB_PERIOD_8SEC The smooth calibration period is 8s
RTC_SMOOTHCALIB_PERIOD_16SEC The smooth calibration period is 16s
RTC_SMOOTHCALIB_PERIOD_32SEC The smooth calibration period is 32s
Differentfrom the RTCcoarse calibration, the smooth calibration effects on the calendar clock (RTC
Clock) can be easily checked by checking the output of the AFO_CALIB pin. A smooth calibration
can be also performed on the fly so that it can be changed when the temperature changes or if other
factors are detected.
Real-Time Clock 496
18.2.5.3 Reference Clock Detection
In some applications, the RTC can be actively calibrated using an external reference clock. The
reference clock (at 50Hz or 60Hz - the typical mains frequency) should have a higher precision than
a 32.768kHz LSE clock. That is the reason why the RTC in STM32 MCUs with higher pin count
provides a reference clock input (named RTC_50Hz pin), which can be used to compensate the
imprecision of the calendar frequency (1Hz).
The RTC_50Hz pin should be configured in input floating mode. This mechanism enables the
calendar to be as precise as the reference clock. The reference clock detection is enabled by using
the function:
HAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef* hrtc);
When the reference clock detection is enabled, both asynchronous and synchronous prescalers must
be set to their default values: 0x7F and 0xFF . When the reference clock detection is enabled, each
1Hz clock edge is compared to the nearest reference clock edge (if one is found within a given time
window). In most cases, the two clock edges are properly aligned. When the 1Hz clock becomes
misaligned due to the imprecision of the LSE clock, the RTC shifts the 1Hz clock a bit so that future
1Hz clock edges are aligned. The update window is three ck_calib periods ( ck_calib is the output
of the coarse calibration block - see Figure 3).
If the reference clock halts, the calendar is updated continuously based solely on the LSE clock.
The RTC then waits for the reference clock using a detection window centered on the synchronous
prescaler output clock ( ck_spre ) edge. The detection window is seven ck_calib periods.
The reference clock can have a large local deviation (for instance in the range of 500ppm), but in
the long term it must be much more precise than a 32kHz quartz. The detection system is used only
when the reference clock needs to be detected back after a loss. As the detection window is a bit
largerthanthereferenceclockperiod,thisdetectionsystembringsanuncertaintyof1 ck_ref period
(20msfora50Hzreferenceclock)becausewecanhave2 ck_ref edgesinthedetectionwindow.Then
the update window is used, which brings no error as it is smaller than the reference clock period.
We assume that ck_ref is not lost more than once a day. So the total uncertainty per month would
be 20ms * 1 * 30 = 0.6s, which is much less than the uncertainty of a typical quartz (1.53 minute per
month for 35ppm quartz).
18.3 Using the Backup SRAM
The majority of STM32 microcontrollers provide an additional memory region called backup
memory (or RTC backup data memory). This memory is powered-on by VBAT when VDD is
switched off, if the VBAT pin is connected to a backup power source, so that its content is not lost
upon a system reset. Content of the backup memory remains valid even when the device operates
in low-power mode. Instead, backup registers are reset when a tamper detection event occurs.
Real-Time Clock 497
By default, after a system reset, the access in write mode to the so called backup domain (which
includes the backup memory and the RTC registers) is disabled to protected it from possible and
unwanted write accesses due to unstable power source. In order to modify the whole domain, and
hence the backup memory, we need to explicitly follow this procedure:
• enable the power interface clock by using the macro __HAL_RCC_PWR_CLK_ENABLE() ;
• callthe HAL_PWR_EnableBkUpAccess() functiontoenabletheaccesstothebackupdomain(RTC
registers, RTC backup data memory).
• Use the functions HAL_RTCEx_BKUPWrite() and HAL_RTCEx_BKUPRead() function to write/read
inside the available backup registers (the number of registers differs among the several STM32
MCUs).
III Advanced topics
19. Power Management
Energyefficiencyisoneofthetrendtopicsintheelectronicsindustry.Evenifyouarenotdesigninga
battery-powered device, probably you have to address power-related requirements anyway. A well-
designed device, from the power point of view, not only consumes less energy, but it also allows to
simplify and minimize its power-section, reducing the overall dimension of the PCB, the BOM and
the power dissipation.
Oftenwethinkthatthepowermanagementofanelectronicboardisallrelatedtoitspoweringstage.
In the last two decades, power-conversion has been the hot topic. The research and development
madebyICvendorsdidgeneratealotofintegrateddevicesabletoboosttheoverallpowerefficiency
inalotofapplicationsfields,rangingfromlow-powersolutionstohigh-loadpowerconversionunits
able to supply thousands of amperes. Instead, as embedded developers, we have great responsibility
in ensuring that our firmware can minimize the energy consumption of devices we make.
Modern microcontrollers provide to developers a lot of tools to minimize the energy used. Cortex-
M cores aren’t an exception, and they provide an “abstract” power management model that is
rearranged by silicon manufacturers to create their own power management scheme. This is exactly
the case of STM32 MCUs: even if power management is addressed in all STM32-series, it reaches
a very sophisticated implementation in STM32L families, which provide to developers a scalable
power model to precisely tune-up the energy needed. This allows to design electronic devices able
to run even for years while powered by a coin-cell battery.
In this chapter we will give a quick look at the way power management is implemented in STM32
MCUs, analyzing the STM32F-series and the STM32L-series separately. We will start examining
which features are provided by the Cortex-M core and then we will discover how ST engineers have
specialized them to provide up to eleven different power modes in the recent STM32L4-series.
19.1 Power Management in Cortex-M Based MCUs
Before we study the features provided by Cortex-M based microcontrollers to programmatically
selectthepowermode oftheMCU,itisbesttodosomeconsiderationsaboutthepowerconsumption
sources in a digital device.
Firstofall,thecomplexityofthedeviceitselfimpactsontheenergyconsumed.Themoreperipherals
and features our board provides, the more power is needed. Moreover, some peripherals are
intrinsically energy-intensive. For example, TFT displays consume a lot of power if compared
with other parts of the electronic board. Finally, a low-power design needs a careful selection
of all components in the BOM. For example, in applications where the Real-Time Clock (RTC)
Power Management 500
is maintained active at all conditions¹, including sleep, shutdown and VBAT modes, the current
consumption of the LSE becomes more critical in overall system-level application design.
Focusing our attention exclusively on the MCU, the first aspect that affects the power consumption
is its running frequency: the faster goes the CPU, the higher it consumes. And this a law written in
the stone that all firmware developers must know: even if the MCU we are using is able to run up
to 200MHz, if we do not need all that speed then we can save a lot of energy by simply reducing the
clock frequency. And this is one of the main reasons why STM32 microcontrollers have a complex
clock distribution tree.
Another implication of this aspect is that the more peripherals are actively running, the more
power the MCU eats. This means that a well-designed firmware always immediately disables a
peripheral that becomes unnecessary. For example, if we need an I²C EEPROM only during the
bootstrap process (because it stores some configuration parameters that we retain in RAM during
the firmware life-cycle), then we have to disable the I²C peripheral once finished². This is the
reason why STM32 MCUs offer the ability to selectively disable every peripheral, gating its clock
source, by calling the __HAL__RCC_<PPP>_CLK_DISABLE() , where <PPP> is the specific peripheral
(for example, the __HAL_RCC_DMA1_CLK_DISABLE() allows to gate the clock of the DMA1, while the
__HAL_RCC_DMA1_CLK_ENABLE() to enable it).
When talking about microcontrollers, it is best to talk about energy efficiency instead of just their
power consumption. While the power consumption of a device talks just about how many mA or
µA it uses, the energy efficiency measures “how much work” it can do with a limited amount of
energy, for example, in the form of DMIPS/mW or CoreMark/mW. We can so discover that for an
STM32L4 MCU the best energy compromise is reached when it runs in Low-Power RUN (LPRUN)
mode, as shown in Figure 8.
Finally, the design itself of the MCU and its peripherals impact on the overall power consumption.
This is the reason why STM32L microcontrollers are expressly designed to provide the best-in class
power consumption while providing the best performances according the specific sub-family. For
example,some of the communication peripherals in an STM32L4 MCU (the LPUARTis one of these)
allow exchanging data in DMA mode while the MCU is in STOP2 mode³.
19.2 How Cortex-M MCUs Handle Run and Sleep Modes
When a Cortex-M based microcontroller resets, its power mode is set to the run⁴ one. In this mode
the energy needed is certainly established by the whole MCU design, but mainly from the running
frequency and the number of active peripherals. Here it is important to remark that also the flash
¹ As we will discover next, in some really “deep” sleep modes the MCU can be woken up only by few peripherals, which always include
the RTC.
² The I²C peripheral consumes up to 720µA in an “old” STM32F103 running at its maximum clock speed. This might seem not that much
for a device powered from the mains, but it has a dramatic impact on a battery-powered device.
³ In this mode, the core of an STM32L4 MCU consumes about 1.1µA.
⁴ Official ARM documentation talks about active mode, which is opposed to the sleep one used to indicate a non-running core. However,
since this book is all about STM32 microcontrollers, and since the power scheme of a Cortex-M MCU is left to the specific vendor
implementation, we will use in this book the term run mode, which is what ST uses to indicate a CPU actively running.
Power Management 501
and the SRAM memories are “peripherals” external to the Cortex-M core. Moreover, the adoption
of advanced flash prefetch technologies, like the ART TM Accelerator, impact on the overall power
consumption too.
In this mode the developer can change the way the MCU consumes energy by regulating the clock
speed and by disabling the unneeded peripherals. This may seem obviously, but it is important to
remark that this is the best power optimization we can do in a lot of real situations. As we will see
later in this chapter, STM32L MCUs structure the run mode in several sub-modes, offering more
control on the power consumption while guaranteeing the majority of functionalities and the best
CPU performances.
If we know that we do not need to process anything for a given period of time, then Cortex-M cores
allow us to put them in sleep mode without doing busy-waits. In this mode the core is halted and it
can be woken up only by “external events” coming from the EXTI controller (for example, a push-
button connected to a GPIO). Again, STM32L MCUs expand this mode offering up to eight different
sub-modes, as we will see next.
It is important to underline that the Cortex-M core enters in sleep mode on “a voluntary basis”: two
distinct ARM instructions, that we are going to see in while, halts the CPU while leaving some of
its event lines active. By triggering these lines, the CPU resumes the execution in a given wake-up
time, which depends on the effective sleep level and the Cortex-M core type (M0, M3, and so on).
The wake-up latency can be expressed in term of CPU cycles for “lightweight” sleep modes, and in
µs for deep sleep modes. This means that the deeper is the sleep mode, the longer is the wake-up
time. Developers need to decide which sleep mode should be used for their specific applications: the
energy and time consumed entering and then exiting a deep low power state may outweigh any
potential power saving gains. In a wearable device energy efficiency is the most important factor,
while in some industrial control applications the wake-up latency can be really critical.
There are also different approaches to designing low power systems. Nowadays a lot of embedded
systems are designed to be interrupt driven. This means that the system stays in sleep mode when
there are no requests to be processed. When an interrupt request arrives, the processor wakes up
and processes it, and goes back into sleep mode when the work is done. Alternatively, if the data
processing request is periodic and has a constant duration, and if the data processing latency is not
an issue, you could run the system at the slowest possibly clock speed to reduce the power. There is
no clear answer to which approach is better, as the choice will be dependent on the data processing
requirements of the application, the microcontroller being used, and other factors like the type of
power source available.
Power Management 502
Figure 1: How a firmware could potentially manage clock speed and power modes during its activity
The Figure 1 shows a possible strategy for the minimization of power consumption. During the
microcontroller booting process, the MCU runs at its maximum speed to allow a fast completion of
all initialization activities. When all peripherals are configured, the clock speed is lowered and the
MCU enters in sleep modes. In this period, the MCU is woken-up by interrupts that can be processed
at lower CPU speeds. When CPU-intensive operations need to be carried out, the clock speed can
be increased up to the maximum, and then decreased again once finished.
So, when to go into sleep mode? As said before, it is up to us to decide the right time to place the
MCU in one of the possible sleep modes. If we know that the MCU is waiting for asynchronous
events notified with interrupts, then it could be the right time to go into sleep mode instead of doing
busy-wait. Let us consider the classical blinking LED application we have seen several times in this
book.
...
while(1) {
HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
HAL_Delay(500);
}
This apparently innocent code has a dramatic impact on the power consumption of our device. Even
if we do not have too much to do during those 500ms, we waste a lot of power checking the value
of the global SysTick tick count to see if that time has been elapsed. Instead, we can rearrange that
code to stay in sleep mode for the most of the time, and we can set up a timer that wakes up the
MCU after 100ms.
Letting other software components decide when to place the MCU in sleep mode could represent
another approach. As we will discover in Chapter 23, a Real-Time Operating System may be
programmed to automatically put the MCU in sleep mode when there is nothing to do⁵.
⁵ We will discover in that chapter that one possible strategy consists in placing the MCU in sleep mode when the idle thread is scheduled.
The idle thread is that thread executed by an RTOS when all other threads are “un-runnable”. This clearly means that the MCU has nothing
relevant to do, and it can be placed in sleep mode safely.
Power Management 503
19.2.1 Entering/exiting sleep modes
As said in the previous paragraph, the CPU enters in sleep mode exclusively on a voluntary basis,
by using specific ARM assembly instructions. This means that, as programmers, we have all the
responsibility of the power consumption of devices we make⁶.
Cortex-M based MCUs offer two instructions to place the MCU in sleep mode: WFI and WFE . The
Wait For Interrupt ( WFI ) instruction is also called the un-conditional sleep instruction. When the
CPU executes that instruction it immediately halts the core execution. The CPU will be resumed
only by an interrupt request, depending on the interrupt priority and the effective sleep level (more
about this later), or in case of debug events. If an interrupt is pending while the MCU executes the
WFI instruction, it enters in sleep mode and wakes up again immediately.
The Wait For Event ( WFE ) is the other instruction that allows to place the MCU in sleep mode. It
differs from the WFI due to the fact that it checks the status of a particular event register⁷ before
it halts the core: if this register is set, the WFE clears it and does not halt the CPU, continuing the
program execution (this allows us to manage the pending event, if needed). Otherwise, it halts the
MCU until this event register is set again.
But what is exactly the difference between an event and an interrupt? Events are a source of
confusion in the STM32 world (also in the Cortex-M world in general). They appear like something
intangible,comparedtotheinterruptsthatwehavelearnedtohandleinChapter7.Beforeweclarify
what events are, we need to better explain the role of the EXTI controller in an STM32 MCU. The
Extended Interrupts and Events Controller (EXTI) is the hardware component internal to the MCU
that manages the external and internal asynchronous interrupts/events and generates the event
request to the CPU/NVIC controller and a wake-up request to the Power Controller (see Figure
2). The EXTI allows the management of several event lines, which can wake up the MCU from some
sleep modes (not all events can wake up MCU). The lines are either configurable or direct and hence
hardwired inside the MCU:
• The lines are configurable: the active edge can be chosen independently, and a status flag
indicates the source of the interrupt. The configurable lines are used by the I/Os external
interrupts, and by few peripherals (more about this soon).
• The lines are direct and hardwired: they are used by some peripherals to generate a wakeup
from stop event or interrupt. The status flag is provided by the peripheral itself. For example,
the RTC can be used to generate an event to wake up the MCU.
⁶ Clearly, we are talking about the power consumption of the MCU core and all integrated peripherals. The power consumption of the
overall board is determined by other things that we will not address here.
⁷ This register is internal to the core and not accessible to the user.
Power Management 504
Figure 2: How events can be used to wake-up the core
AnotherimportantaspecttoclarifyaboutEXTIandNVICcontrollersisthateachlinecanbemasked
independently for an interrupt or an event generation. For example, in Chapter 6 we have seen that
a GPIO can be configured to work in GPIO_MODE_EVT_* mode, which is different from the GPIO_-
MODE_IT_* mode: in the first case, when an I/O is triggered it will not generate an IRQ request, but
it will set the event flag. This will cause the MCU to wake up if it has entered a low-power mode
using the WFE instruction.
So the WFE instruction checks that no event is pending, and for this reason it is also called the
conditional sleep instruction. This event register can be set by:
• exception entrance and exit;
• when SEV-On-Pend feature is enabled, the event register can be set when an interrupt pending
status is changed from 0 to 1 (more about this soon);
• a peripheral sets its dedicated event line (this is peripheral-specific);
• execution of the SEV (Send Event) instruction;
• debug event (e.g., halting request).
In Chapter 7 we have seen that in Cortex-M3/4/7 cores we can temporarily mask the execution of
those interrupts having a priority lower than a value set in the BASEPRI register. However, these
interrupts are still enabled and marked as pending if they fires. We can configure the MCU to set
the event register in case of pending interrupts, by setting the SCR->SEVONPEND bit. As the name
suggest, this register will cause to “set the event register if interrupts are pending”. This means that,
if the processor was placed in sleep mode by the WFE instruction, the CPU is immediately awakened
and we can eventually process pending interrupts. Instead, the WFI instruction would never wake
up the core. The Cube HAL provides two convenient functions, HAL_PWR_EnableSEVOnPend() and
HAL_PWR_DisableSEVOnPend() , to perform this setting.
Power Management 505
If, instead, interrupts are masked by setting the PRIMASK register, a pending interrupt can wake up
the processor, regardless for the sleep instruction used ( WFI or WFE ): this characteristic allows some
parts of the MCU to be turned OFF by software by gating its clock, and the software can turn it back
on after waking up before executing the ISR.
So, to recap, the WFI and WFE have the same following behaviour:
• wakeuponinterrupt/exceptionrequests thatareenabled andwithhigher prioritythancurrent
level⁸;
• can be woken up by debug events;
• can be used to produce both sleep and deep sleep modes (more about this soon).
Instead, the WFI and WFE differ for the following reasons:
• execution of WFE does not enter sleep mode if the internal event register is set, while the
execution of WFI always results in sleep;
• newpendingofadisabledormaskedinterruptcanwakeuptheprocessorfrom WFE if SEVONPEND
is set;
• WFE can be woken up by en external event;
• WFI can be woken up by an enabled interrupt when PRIMASK is set.
19.2.1.1 Sleep-On-Exit
TheSleep-On-Exit featureisusefulforinterrupt-drivenapplicationswherealloperations(apartfrom
the initialization stage) are performed inside interrupt handlers. This is a programmable feature,
and can be enabled or disabled setting a bit of the SCB->SCR register. When enabled, the Cortex-
M core automatically enters sleep mode (with the same behavior of WFI instruction) when exiting
from an exception/interrupt handler. The Sleep-On-Exit feature should be enabled at the end of the
initialization stage. Otherwise, if an interrupt event happens during the initialization stage while
the Sleep-On-Exit feature is already enabled, the processor will enter sleep even if the initialization
stage was not yet completed.
TheCubeHALprovidestwoconvenientroutinestoenable/disablethismode: HAL_PWR_EnableSleep-
OnExit() and HAL_PWR_DisableSleepOnExit() .
19.2.2 Sleep Modes in Cortex-M Based MCUs
So far, we have talked broadly about sleep mode. This mainly because the power management
schemedefinedbyARMisfurtherspecializedbychipvendors,likeSTdoeswithitsproducts.Cortex-
M based microcontrollers architecturally support two sleep modes: normal sleep and deep sleep. As
we will discover later in this chapter, STM32F microcontrollers calls them sleep and stop modes
⁸ Disabling interrupt on a priority basis is only applicable to Cortex-M3/4/7 based MCUs.
Power Management 506
and add a third even deeper mode called standby. The STM32L-series further specializes these two
“main” operative modes in several sub-modes.
Both sleep and deep sleep modes are reached using the WFI and WFE instructions seen before. The
only difference is that the deep sleep mode is achieved by setting the SLEEPDEEP bit to 1 in the PWR-
>SCR register. However, we do not need to deal with these details since the CubeHAL is designed to
abstract them.
Usually STM32 microcontrollers are designed so that in sleep mode only the CPU clock is turned
OFF, while there are no effects on other clocks or analog clock sources (this means that all enabled
peripherals remain active). In stop mode, instead, all peripherals belonging to the 1.8V (or 1.2V for
more recent STM32 MCUs) domain clock are turned OFF, while the VDD domain is left ON⁹, except
for HSI and HSE oscillator that are turned OFF. Instandby mode both the 1.8V domain and the VDD
domain are turned OFF. However, in the next paragraph we will deepen these topics.
19.3 Power Management in STM32F Microcontrollers
The concepts illustrated so far are common to all STM32 microcontrollers. However, the STM32
portfolio is divided in two main branches: STM32F and STM32L series. The second one is addressed
to low-power applications, and it provides a lot of more operative modes to minimize the power
consumption.
We will start by analyzing how to manage power modes in STM32F microcontrollers. However, it
is important to underline that, as often happens for the other features offered by this large portfolio,
some STM32 families, and even some certain part numbers, offer specific peculiarities that differ
from the way the power management is handled in the majority of STM32 microcontrollers. For
this reason, always keep on hand the reference manual for the MCU you are considering.
19.3.1 Power Sources
Figure 3 shows the power sources of an STM32F microcontroller¹⁰. As said before, even if we are
used to supply the MCU by just one power source (more about this in Chapter 27), the MCU has
an internal power distribution network that defines several voltage domains used to power those
peripherals that share the same powering characteristics. For example, the VDDA domain includes
those analog peripherals that need a separated (better filtered) power source, fed through the VDDA
pins.
⁹ As we will discover next, STM32 microcontroller can be powered by a variable voltage source ranging from 2.0V to 3.6V (some of them
allow to be powered even down to 1.7V). This voltage source is also called VDD domain and all components inside the MCU powered from
this source are said to be part of the VDD domain. However, the internal MCU core and some other peripherals are powered by a dedicated
1.8V (or even 1.0V in low power STM32L MCUs) internal voltage regulator. This defines the 1.8V domain. The low-voltage internal regulator
can be independently turned OFF. More about this later.
¹⁰ It is important to remark that the diagram in Figure 3 is just a scheme. Some STM32F MCUs, especially those providing a TFT-LCD
controller or other communication interfaces like the Ethernet, introduce other power source domains. In the same way, STM32 MCUs with
lower pin count (especially those ones with less then 32 pins) have a simplified power distribution network. However, the concepts illustrated
here remain valid.
Power Management 507
Figure 3: The power sources in an STM32F microcontroller
TheVDD andVDD18 domainsarethemostrelevantone.TheVDDdomainissuppliedbyanexternal
power source, while the VDD18 domain is supplied by a voltage regulator internal to the MCU. This
regulator can be configured to work in low-power mode, as we will see next. To retain the content
of the backup registers¹¹ and supply the RTC function when VDD is turned OFF, VBAT pin can be
connected to an optional standby voltage supplied by a battery or by another source. The VBAT pin
powers the RTC unit, the LSE oscillator and one or two pins used to wake up the MCU from deep
sleep modes, allowing the RTC to operate even when the main power supply is turned OFF. For this
reason, the VBAT power source is said to power the RTC domain. The switch to the VBAT supply
is controlled by the Power Down Reset (PDR) embedded in the reset block.
19.3.2 Power Modes
In the first part of this chapter, we have seen that a Cortex-M MCU provides three main power
modes: run, sleep and deep sleep. Now it is the right time to see how ST engineers have rearranged
them in STM32F MCUs. Table 1 summarizes these modes and shows the three main functions
provided by the HAL to place the MCU in the corresponding power mode. We will analyze them
more in depth later.
¹¹ Backup registers are a dedicated memory area, with a typical size of 4Kb, that is powered by a different power source usually connected
to a battery or a super-capacitor. This is used to store volatile data that remains valid even when the MCU is powered OFF, either if the whole
device is turned OFF or the MCU is placed in standby mode.
Power Management 508
Table 1: The three power modes supported by STM32F MCUs
19.3.2.1 Run Mode
By default, and after power-on or a system reset, STM32F MCUs are placed in run mode, which is
a fully active mode that consumes much power even when performing minor tasks. Consumptions
of both the run and the sleep modes depend on the operating frequency¹².
The Figure 4¹³ shows the power consumption levels of some of the most recent STM32F4 MCUs.
In run mode, the main regulator supplies full power to the 1.8-1.2V domain (CPU core, memories
and digital peripherals). In this mode, the regulator output voltage (around 1.8-1.2V depending on
the particular STM32F MCU) can be scaled by software to different voltage values (more about this
soon). Some recent STM32F4 MCUs provide two run modes: * Normal mode: the CPU and core
logic operate at maximum frequency at a given voltage scaling (scale 1, scale 2 or scale 3). * Over-
drive mode: this mode allows the CPU and the core logic to operate at a higher frequency than the
normal mode for the voltage scaling scale 1 and scale 2. More about this mode later.
¹² Don’t forget that in sleep mode only the CPU clock is turned OFF, while other peripherals remain active. So, the speed of the HCLK clock
source still continues to affect the overall power consumption.
¹³ The figure is taken from the ST AN4365(http://bit.ly/1XzmF2o) application note.
Power Management 509
Figure 4: The power consumption of some STM32F4 MCU
19.3.2.1.1 Dynamic Voltage Scaling in STM32F4/F7 MCUs
The power used by a DC circuit is given by the current drawn and the voltage of the circuit. This
means that we can reduce the power needed by the circuit by reducing the voltage. STM32F4/F7
provides a smart powering technology named Dynamic Voltage Scaling (DVS) distinctive of
STM32L-series. The idea behind DVS is that many embedded systems do not always require the
system’s full processing capabilities, because not all subsystems are always active. When this is
the case, the system can remain in the active mode without the processor running at its maximum
operating frequency. The voltage supplied to the processor can be then decreased when a lower
frequency is sufficient. With such power management, we reduce the power drawn battery by
monitoring the processor input voltage in response to the system’s performance requirements.
That consists in scaling the STM32F4 regulator output voltage that supplies the 1.2V domain (core,
memories and digital peripherals) when we lower the clock frequency based on processing needs.
STM32F4/F7 offer three voltages scales (scale 1, scale 2 and scale 3). The maximum achievable core
frequency for a given voltage scale is determined by the specific STM32 MCU. For example, the
STM32F401 provides only two voltage scales, scale 2 and scale 3, that allow to run the core up to
84MHz and 60MHz respectively. To control the voltage scaling, the CubeHAL provides the function:
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling);
which accepts the symbolic constants PWR_REGULATOR_VOLTAGE_SCALE1 , PWR_REGULATOR_VOLTAGE_-
SCALE2 and PWR_REGULATOR_VOLTAGE_SCALE3 . The voltage scale can be changed only if the source
clock for the System Clock Multiplexer is the HSI or HSE. So, to increase/reduce the voltage scale
you can follow this procedure:
Power Management 510
• Set the HSI or HSE as system clock frequency using the HAL_RCC_ClockConfig() .
• Call the HAL_RCC_OscConfig() to configure the PLL.
• Call HAL_PWREx_ConfigVoltageScaling() API to adjust the voltage scale.
• Set the new system clock frequency using the HAL_RCC_ClockConfig() .
For more information about this topic, refer to the AN4365¹⁴.
19.3.2.1.2 Over/Under-Drive Mode in STM32F4/F7 MCUs
Some MCUs from the STM32F4 family and all STM32F7 ones provide two or even several sub-
running modes. These modes are called over-drive and under-drive. The first one consists in
increasing the core frequency with a sort of “overclocking”. It is recommended to enter over-
drive mode when the application is not running critical tasks and when the system clock source
is either HSI or HSE. These features are useful when we want to temporarily increase/decrease
the MCU clock speed without reconfiguring the clock tree, which usually introduces a non-
negligible overhead. The HAL provides two convenient functions, HAL_PWREx_EnableOverDrive()
and HAL_PWREx_DisableOverDrive() to perform this operation.
The under-drive mode is the opposite of the over-drive one and consists in lowering the CPU
frequency and by disabling some peripherals. In this mode it is possible to place the internal voltage
regulator in low-power mode. In some STM32F4/F7 MCUs the under-drive mode is available even
in stop mode.
19.3.2.2 Sleep Mode
Thesleep modeisenteredbyexecutingthe WFI or WFE instruction.Inthesleep mode,allI/Opinskeep
the same state as in the run mode. However, we should not care to deal with assembly instructions,
since the CubeHAL provides the function:
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry);
The first parameter, Regulator , is meaningless in sleep mode for all STM32F-series, and it is left for
compatibility with STM32L-series. The second parameter, SLEEPEntry , can assume the values PWR_-
SLEEPENTRY_WFI or PWR_SLEEPENTRY_WFE :asthenamessuggest,theformerperformsa WFI instruction
and the latter a WFE .
Ifyoutakealookatthe HAL_PWR_EnterSLEEPMode() functionyoudiscoverthat,ifwepassthe
parameter PWR_SLEEPENTRY_WFE , it executes two WFE instructions consecutively. This causes
that the HAL_PWR_EnterSLEEPMode() enters in the sleep mode in the same way as it would
be called with the parameter PWR_SLEEPENTRY_WFI (calling WFE twice causes that if the event
registerisset,thenitisclearedbythefirst WFE instruction,andthesecondoneplacetheMCU
in sleep mode). I do not know why ST has adopted this approach. If you want full control
overthewaytheMCUisplacedinlow-powermodes,thanyouhavetorearrangethecontent
of that function at your need. Clearly, the MCU will exit from sleep mode following the exit
condition of the WFE instruction.
¹⁴ http://bit.ly/1XzmF2o
Power Management 511
If the WFI instruction is used to enter in sleep mode, any peripheral interrupt acknowledged by the
nested vectored interrupt controller (NVIC) can wake up the device from sleep mode.
If the WFE instruction is used to enter sleep mode, the MCU exits sleep mode as soon as an event
occurs. The wakeup event can be generated either by:
• enabling an interrupt in the peripheral control register but not in the NVIC, and enabling the
SEVONPEND bitintheSystemControlRegiste-WhentheMCUresumesfrom WFE ,theperipheral
interrupt pending bit and the peripheral NVIC IRQ channel pending bit (in the NVIC interrupt
clear pending register) have to be cleared;
• or configuring an external or internal EXTI line in event mode - When the CPU resumes from
WFE , it is not necessary to clear the peripheral interrupt pending bit or the NVIC IRQ channel
pending bit as the pending bit corresponding to the event line is not set.
This mode offers the lowest wakeup time as no time is wasted in interrupt entry/exit.
19.3.2.3 Stop Mode
The stop mode is based on the Cortex-M deep sleep mode combined with peripheral clock gating.
In stop mode all clocks in the 1.8V domain are stopped, the PLL, the HSI and the HSE oscillators are
disabled. SRAM and register contents are preserved. In the stop mode, all I/O pins keep the same
state as in the run mode. The voltage regulator can be configured either in normal or low-power
mode. To place the MCU in stop mode the HAL provides the function:
void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry);
where the Regulator parameter accepts the value PWR_MAINREGULATOR_ON to leave the internal
voltage regulator ON, or the value PWR_LOWPOWERREGULATOR_ON to place it in low-power mode. The
parameter STOPEntry can assume the values PWR_STOPENTRY_WFI or PWR_STOPENTRY_WFE .
Toenterstop mode,allEXTI-linependingbits,allperipheralsinterruptpendingbitsandRTCAlarm
flag must be reset. Otherwise, the stop mode entry procedure is ignored and program execution
continues.Iftheapplicationneedstodisabletheexternalhigh-speedoscillator(HSE)beforeentering
stop mode, the system clock source must be first switched to HSI and then clear the HSEON bit.
Otherwise,ifbeforeenteringstop modetheHSEONbitiskeptat1,thesecuritysystem(CSS)feature
must be enabled to detect any external oscillator (external clock) failure and avoid a malfunction
when entering stop mode.
Any EXTI-line configured in interrupt or event mode forces the CPU to exit from stop mode,
according if it entered in low-power mode using the WFI or WFE instruction. Since both HSE and
PLL are disabled before entering in stop mode, when exiting from this low-power mode the MCU
source clock is set to the HSI. This means that our code shall reconfigure the clock tree according to
wanted SYSCLK speed.
Power Management 512
19.3.2.4 Standby Mode
The standby mode allows to achieve the lowest power consumption. It is based on the Cortex-M
deep sleep mode, with the voltage regulator disabled. The 1.8-1.2V domain is consequently powered
OFF. PLL multiplexer, HSI and HSE oscillators are also switched OFF. SRAM and register contents
are lost except for registers in the standby circuitry. To place the MCU in standby mode the HAL
provides the function:
void HAL_PWR_EnterSTANDBYMode(void);
The microcontroller exits the standby mode when an external reset (NRST pin), an IWDG reset,
a rising edge on one of the enabled WKUPx pins or an RTC event occurs. All registers are reset
after wakeup from standby except for Power Control/Status Register ( PWR->CSR ). After waking up
from standby mode, program execution restarts in the same way as after a reset (boot pin sampling,
option bytes loading, reset vector is fetched, etc.). Using the macro:
__HAL_PWR_GET_FLAG(PWR_FLAG_SB);
we can check if the MCU is resetting due to an exit from standby mode. Since both HSE and PLL
are disabled before entering in stop mode, when exiting from this low-power mode the MCU source
clock is set to the HSI. This means that our code shall reconfigure the clock tree according to wanted
SYSCLK speed.
Read Carefully
Some STM32 MCUs have a hardware bug that prevents entering or exiting from standby
mode. Particular conditions must be met before we enter in this mode. Consult the errata
sheet for your MCU for more about this (if applicable).
19.3.2.5 Low-Power Modes Example
The following example, designed to run on a Nucleo-F030R8¹⁵ shows the way low-power modes
work.
¹⁵ For other Nucleo boards refer to the book examples.
Power Management 513
Filename: src/main-ex1.c
14 int main(void) {
15 char msg[20];
16
17 HAL_Init();
18 Nucleo_BSP_Init();
19
20 /* Before we can access to every register of the PWR peripheral we must enable it */
21 __HAL_RCC_PWR_CLK_ENABLE();
22
23 while (1) {
24 if(__HAL_PWR_GET_FLAG(PWR_FLAG_SB)) {
25 /* If standby flag set in PWR->CSR, then the reset is generated from
26 * the exit of the standby mode */
27 sprintf(msg, "RESET after STANDBY mode\r\n");
28 HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
29 /* We have to explicitly clear the flag */
30 __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU|PWR_FLAG_SB);
31 }
32
33 sprintf(msg, "MCU in run mode\r\n");
34 HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
35 while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET) {
36 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
37 HAL_Delay(100);
38 }
39
40 HAL_Delay(200);
41
42 sprintf(msg, "Entering in SLEEP mode\r\n");
43 HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
44
45 SleepMode();
46
47 sprintf(msg, "Exiting from SLEEP mode\r\n");
48 HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
49
50 while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET);
51 HAL_Delay(200);
52
53 sprintf(msg, "Entering in STOP mode\r\n");
54 HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
55
56 StopMode();
57
58 sprintf(msg, "Exiting from STOP mode\r\n");
59 HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
Power Management 514
60
61 while(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET);
62 HAL_Delay(200);
63
64 sprintf(msg, "Entering in STANDBY mode\r\n");
65 HAL_UART_Transmit(&huart2, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
66
67 StandbyMode();
68
69 while(1); //Never arrives here, since MCU is reset when exiting from STANDBY
70 }
71 }
72
73
74 void SleepMode(void)
75 {
76 GPIO_InitTypeDef GPIO_InitStruct;
77
78 /* Disable all GPIOs to reduce power */
79 MX_GPIO_Deinit();
80
81 /* Configure User push-button as external interrupt generator */
82 __HAL_RCC_GPIOC_CLK_ENABLE();
83 GPIO_InitStruct.Pin = B1_Pin;
84 GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
85 GPIO_InitStruct.Pull = GPIO_NOPULL;
86 HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
87
88 HAL_UART_DeInit(&huart2);
89
90 /* Suspend Tick increment to prevent wakeup by Systick interrupt.
91 Otherwise the Systick interrupt will wake up the device within 1ms (HAL time base) */
92 HAL_SuspendTick();
93
94 __HAL_RCC_PWR_CLK_ENABLE();
95 /* Request to enter SLEEP mode */
96 HAL_PWR_EnterSLEEPMode(0, PWR_SLEEPENTRY_WFI);
97
98 /* Resume Tick interrupt if disabled prior to sleep mode entry*/
99 HAL_ResumeTick();
100
101 /* Reinitialize GPIOs */
102 MX_GPIO_Init();
103
104 /* Reinitialize UART2 */
The macro __HAL_RCC_PWR_CLK_ENABLE() at line 21 enables the PWR peripheral: before we can
Power Management 515
perform any operation related to power management, we need to enable the PWR peripheral, even
if we are simply checking if the standby flag is set inside the PWR->CSR register. This is a source of a
lot of headaches in novice users struggling with power management.
Lines [24:31] check if the standby flag is set: if so, it means that the MCU was reset after exiting
from standby mode. Lines [33:38] represent the run mode: the LD2 LED blinks until we press the
Nucleo USER button connected to the PC13 pin. The remaining lines of code in the main() just cycle
through the three low-power modes at every pressure of the USER button.
Lines [74:106] define the SleepMode() function, used to place the MCU in sleep mode. All GPIOs
are configured as analog, to reduce current consumption on non-used IOs (especially those pins
that may be source of leaks). The corresponding peripheral clock is turned OFF, except for the
GPIOC peripheral: the PC13 GPIO is used to resume from low-power modes. The same apply for the
UART2 interface and theSysTick timer, which is halted to prevent the MCU from exiting low-power
mode after 1ms. The call to the HAL_PWR_EnterSLEEPMode() function at line 96 places the MCU in
sleep mode, until it wakes up when the USER button is pressed (the MCU wakes up because we
configure the corresponding IRQ that causes the WFI instruction exiting from the low-power mode).
The StopMode() function, not shown here, is almost identical to the SleepMode() one, except for the
fact that it calls the function HAL_PWR_EnterSTOPMode() to place the MCU in stop mode.
Filename: src/main-ex1.c
140 void StandbyMode(void) {
141 MX_GPIO_Deinit();
142
143 /* This procedure come from the STM32F030 Errata sheet*/
144 __HAL_RCC_PWR_CLK_ENABLE();
145
146 HAL_PWR_DisableWakeUpPin(PWR_WAKEUP_PIN1);
147
148 /* Clear PWR wake up Flag */
149 __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);
150
151 /* Enable WKUP pin */
152 HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN1);
153
154 /* Enter STANDBY mode */
155 HAL_PWR_EnterSTANDBYMode();
156 }
Finally, lines [144:160] define the StandbyMode() function. Here we follow the procedure described
in the STM32F30 errata sheet, since that MCU is affected by a hardware bug that prevents the CPU
from entering in standby mode: we have to disable the PWR_WAKEUP_PIN1 pin firstly, then to clear the
wake up flag in the PWR->CSR peripheral and to re-enable the wake up pin, which in an STM32F030
MCU coincides with the PA0 pin.
Power Management 516
STM32 MCUs usually have two wake up pins, named PWR_WAKEUP_PIN1 and PWR_WAKEUP_-
PIN2 .ForalotofSTM32MCUswithLQFP64packagethesecondwake-uppincoincideswith
PC13, which is connected to the USER button in all Nucleo boards (except for the Nucleo-
F302whereitisconnectedtoPB13pin).However,wecannotusethe PWR_WAKEUP_PIN2 inour
example, because that pin is pulled high by a resistor on the PCB. When we configure wake
up pins in conjunction with the standby mode, we are not using the corresponding GPIO
peripheral, which would allow us to configure the pin input mode, because it is powered
down before entering in standby mode: the wake up pins are directly handled by the PWR
peripheral, which resets the MCU if one of the two pins goes high. So, in the example we
use the PWR_WAKEUP_PIN1 pin, which corresponds to the PA0 pin in an STM32F030 MCU.
Figure 5: How to measure the MCU power consumption in a Nucleo board
Nucleo boards allow to measure the current consumption of the MCU using the IDD pin header.
Before you start measurements, you should establish the connection with the board as shown in
Figure 5 by removing the IDD jumper and connect the ammeter cables. Ensure that the ammeter is
set to the mA scale. In this way you can see the power consumption for every power mode.
19.3.3 An Important Warning for STM32F1 Microcontrollers
During the development of the examples for the FreeRTOS tickless mode in the related chapter, I
have encountered a nasty behaviour of the STM32F103 MCU when entering in stop mode using the
HAL_PWR_EnterSTOPMode() routine from the CubeF1 HAL. In particular, the problem encountered is
Power Management 517
related to the exit from the this low-power mode when the MCU enters it using the WFI instruction.
Inthatspecificscenario,theMCUdoesenterinstop modecorrectly,butwhenitiswokenupfroman
interrupt it immediately generates an Hard Fault exception. I have reached to the conclusion that
ST developers do not follow what ARM suggests when entering low-power modes in Cortex-M3
processors, as reported here¹⁶.
Modifying the HAL routine in this way fixed the issue:
1 void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry) {
2 /* Check the parameters */
3 assert_param(IS_PWR_REGULATOR(Regulator));
4 assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
5
6 /* Clear PDDS bit in PWR register to specify entering in STOP mode when CPU enter in Deepsle\
7 ep */
8 CLEAR_BIT(PWR->CR, PWR_CR_PDDS);
9
10 /* Select the voltage regulator mode by setting LPDS bit in PWR register according to Regula\
11 tor parameter value */
12 MODIFY_REG(PWR->CR, PWR_CR_LPDS, Regulator);
13
14 /* Set SLEEPDEEP bit of Cortex System Control Register */
15 SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
16
17 /* Select Stop mode entry --------------------------------------------------*/
18 if(STOPEntry == PWR_STOPENTRY_WFI)
19 {
20 /* Request Wait For Interrupt */
21 __DSB(); //Added by me
22 __WFI();
23 __ISB(); //Added by me
24 }
25 else
26 {
27 /* Request Wait For Event */
28 __SEV();
29 PWR_OverloadWfe(); /* WFE redefine locally */
30 PWR_OverloadWfe(); /* WFE redefine locally */
31 }
32 /* Reset SLEEPDEEP bit of Cortex System Control Register */
33 CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
34 }
The change simply consists in adding two memory barrier instructions, one before and one after the
WFI instruction, as shown at lines X and Y.
¹⁶ http://bit.ly/1rVwDBf
Power Management 518
I have asked a question regarding this issue on the official ST forum¹⁷, but I have not still received
an answer at the time of writing this chapter, and I suspect that I will not receive anything.
19.4 Power Management in STM32L Microcontrollers
The STM32L-series is a quite extensive portfolio of MCUs tailored for low-power applications. It is
divided in three main families: L0, L1 and the more recent L4. These microcontrollers provide more
power modes than the STM32F ones, offering the ability to precisely tune the energy consumed
by the CPU core and integrated peripherals. Moreover, they provide specific low-power peripherals
(like the LPUART or the LPTIM timers). All these features make STM32L MCUs suitable for battery-
powered devices.
In this part of the chapter we will analyze the most relevant power management-related character-
istics offered by STM32L MCUs, focusing our attention mainly on the STM32L4 family.
19.4.1 Power Sources
Figure 6 shows the power sources of an STM32L4 microcontroller. As you can see, to allow a precise
tuning of the power consumed by peripherals, these MCUs provide morevoltage domains compared
to the STM32F ones.
¹⁷ http://bit.ly/1rVx4LN
Power Management 519
Figure 6: The power sources in an STM32L4 microcontroller
Even in these families, the VDD domain is the most relevant one. It is used to supply other voltage
domains, like the VDDIO1 domain, which is used to power the most of MCU pins, and the internal
voltage regulator used to supply the VCORE domain. This can be programmed by software to two
different power ranges (scale 1, scale 2 and so on) in order to optimize the consumption depending
on the maximum operating frequency of the system (thanks to the voltage scaling technology seen
before). It is interestingly to remark that for those MCU providing the GPIOG peripheral (that is,
those MCU coming with package with high pin count), the VDDIO2 domain is used to supply the
GPIOG peripheral independently. This domain, together with the USB domain, can be selectively
enabled/disabled by dedicated functions provided by the HAL ( HAL_PWREx_EnableVddIO2() , HAL_-
PWREx_EnableVddUSB() , etc.).
To retain the content of the backup registers and supply the RTC function when VDD is turned
OFF, VBAT pin can be connected to an optional standby voltage supplied by a battery or by another
source. The VBAT pin powers the RTC unit, the LSE oscillator and one or two pins used to wake up
the MCU from deep sleep modes, allowing the RTC to operate even when the main power supply is
turned OFF. For this reason, the VBAT power source is said to power the RTC domain. The switch
to the VBAT supply is controlled by the PDR. The VLCD pin is provided to control the contrast of
the LCD.
Power Management 520
19.4.2 Power Modes
Apart from a dedicated design that allows to reduce the power consumption of each component of
the MCU, STM32L MCU provide to the user up to eleven different power modes, as shown inFigure
7. For the first three power modes, consumption values per MHz are an average between the power
consumption value when the CPU runs instructions from the flash and from the SRAM¹⁸. The first
three power modes are based on the Cortex-M run mode, while the next four modes are based on
the sleep one. Finally, all other low-power modes rely in the Cortex-M deep sleep mode.
Table 2 summarizes nine power modes and shows the functions provided by the HAL to place the
MCU in the corresponding power mode. We will analyze them more in depth later.
Figure 7: The eleven power modes supported by STM32L4 microcontrollers
19.4.2.1 Run Modes
Bydefault,andafterpower-onorasystemreset,STM32LMCUsareplacedinrun mode.Thedefault
clock source is set to the MSI, a power-optimized clock source that we have encountered in Chapter
10. STM32L microcontrollers offer to developers more fine-tune capabilities, which allow to reduce
the power consumption in this mode. If we do not need too much computing power, then we can
leave the MSI as the main clock source, avoiding the powering consumption introduced by the PLL
multiplexer. By reducing the clock speed down to 24-26MHz, we can configure theDynamic Voltage
Scaling (DVS) scale 2 that decreases the VCORE domain down to 1.0V in more recent STM32L4
¹⁸ The power consumption values reported in Figure 7 refer to the STM32L476 series.
Power Management 521
MCUs.Thismodeisalsocalledrunrange2 andtheoverallpowerconsumptioncanfurtherdecreased
by disabling the flash memory.
As said before, the flash in STM32L MCU and in some recent STM32F4 MCU (like
the STM32F446) can be disabled even in the run mode. The CubeHAL function HAL_-
FLASHEx_EnableRunPowerDown() automatically performs this operation for us, while the
HAL_FLASHEx_DisableRunPowerDown() routine enables again the flash memory. The only
required condition is that this function, and all those other routines used when the flash is
OFF (interrupt vector included) are placed in SRAM, otherwise aBus Fault occurs as soon
as the flash is powered down. This can be easily performed creating a custom linker script,
as we will see in Chapter 20. For this reason, ST engineers have collected these routines in
a separated file named stm32f4xx_hal_flash_ramfunc.c .
Table 2: Nine of the eleven power modes supported by STM32L MCUs
To further reduce the energy consumption when the system is in run mode, the internal voltage
regulator can be configured in low-power mode. In this mode, the system frequency should
not exceed 2 MHz. The HAL_PWREx_EnableLowPowerRunMode() function performs this operation
automatically for us. In this mode we can eventually disable the flash memory, to further reduce
the overall power consumption.
The low-power run mode represents the best compromise in STM32L MCUs from the energy
Power Management 522
efficiency point of view, as shown in Figure 8¹⁹. As you can see, enabling the ART accelerator
increases performance but also reduces the dynamic consumption. Best consumption is most often
reached when the Instruction Cache is ON, Data Cache is ON and Prefetch Buffer is OFF, as this
configuration reduces the number of flash memory accesses.
The small flash dynamic consumption allows a small consumption each time the firmware needs to
access the flash memory. Consumptions from SRAM1 and SRAM2 are quite similar, but SRAM2 is
much more power efficient than SRAM1, when not remapped at address 0, thanks to its 0-wait state
access.
Figure 8: Power optimization vs frequency in STM32L4-series
19.4.2.2 Sleep Modes
Sleep modes allow all peripherals to be used, providing the fastest wakeup time at the same time. In
thesemodes,theCPUisstoppedandeachperipheralclockcanbeconfiguredbysoftwaretobegated
ON or OFF during the sleep and low-power sleep modes. These modes are entered by executing the
assembler instructions WFI or WFE . To place the MCU in one of the two sleep modes, the CubeHAL
provides the function:
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry);
The first parameter, Regulator , can accept the values PWR_MAINREGULATOR_ON and PWR_LOWPOWER-
REGULATOR_ON : the former places the MCU in sleep mode, the latter in low-power sleep mode. The
second parameter, SLEEPEntry , can assume the values PWR_SLEEPENTRY_WFI or PWR_SLEEPENTRY_WFE :
as the names suggest, the first one performs a WFI instruction and the second one a WFE .
¹⁹ The Figure 8 is taken from this ST official document(http://bit.ly/1WcHv8W). ST also provides a really useful application note, the
AN4746(http://bit.ly/1Nkp8NI), about power consumption optimization in STM32L4 MCUs.
Power Management 523
Read Carefully
Please, take note that for STM32L MCUs the system frequency should not exceed MSIrange
1 value in this power mode. Please refer to product datasheet for more details on voltage
regulator and peripherals operating conditions.
If the WFI instruction is used to enter in sleep mode, any peripheral interrupt acknowledged by the
NVIC can wake up the device from sleep mode.
If the WFE instruction is used to enter sleep mode, the MCU exits sleep mode as soon as an event
occurs. The wakeup event can be generated either by:
• enabling an interrupt in the peripheral control register but not in the NVIC, and enabling the
SEVONPEND bitintheSystemControlRegister-WhentheMCUresumesfrom WFE ,theperipheral
interrupt pending bit and the peripheral NVIC IRQ channel pending bit (in the NVIC interrupt
clear pending register) have to be cleared;
• or configuring an external or internal EXTI line in event mode - When the CPU resumes from
WFE , it is not necessary to clear the peripheral interrupt pending bit or the NVIC IRQ channel
pending bit as the pending bit corresponding to the event line is not set.
After exiting the low-power sleep mode, the MCU is automatically placed in low-power run mode.
19.4.2.2.1 Batch Acquisition Mode
Batch Acquisition Mode (BAM) is an implicit and optimized mode for transferring data. Only the
needed communication peripheral (e.g. the I²C one), one DMA and the SRAM are configured with
clock enable in sleep mode. flash memory is put in power-down mode and the flash memory clock
is gated OFF duringsleep mode. The MCU can enter eithersleep or low-power sleep mode. Take note
that the I²C clock can be set at 16 MHz even in low-power sleep mode, allowing support for 1MHz
fast-mode plus. The USART and LPUART clocks can also be based on the HSI oscillator. Typical
applications of BAM are sensor hubs.
19.4.2.3 Stop Modes
STM32L MCUs can provide up to 2 different stop modes, named stop1 and stop2. Stop modes are
based on the Cortex-M deep sleep mode combined with the peripheral clock gating. The voltage
regulator can be configured either in normal²⁰ or low-power mode. In stop1 mode, all clocks in
the VCORE domain are stopped; the PLL, the MSI, the HSI16 and the HSE oscillators are disabled.
Someperipheralswiththewakeupcapability(I²C,USARTandLPUART)canswitchONtheHSI16to
receiveaframe,andswitchOFFtheHSI16afterreceivingtheframeifitisnotawakeupframe.Inthis
case, the HSI16 clock is propagated only to the peripheral requesting it. SRAM1, SRAM2 and register
contents are preserved. Several peripherals can be functional in stop1 mode: PVD, LCD controller,
²⁰ The HAL calls this mode stop0, and this achieved by calling the HAL_PWREx_EnterSTOP0Mode() function.
Power Management 524
digital to analog converters, operational amplifiers, comparators, independent watchdog, LPTIM
timers (if available), I²C, UART and LPUART. The stop2 differs from the stop1 mode by the fact
that only the following peripherals are available: PVD, LCD controller, comparators, independent
watchdog, LPTIM1, I2C3, and the LPUART.
The BOR is always available in both in stop1 and stop2 modes. The consumption is increased when
thresholds higher than VBOR0 are used.
To place the MCU in stop mode the HAL provides the function:
void HAL_PWREx_EnterSTOPxMode(uint8_t STOPEntry);
wherethe‘ x ’isequalto0,1and2dependingonthestopmode.Theparameter STOPEntry canassume
the values PWR_STOPENTRY_WFI or PWR_STOPENTRY_WFE . For compatibility with the other HALs, the
HAL_PWR_EnterSTOPMode() is also available.
Toenterstop mode,allEXTI-linependingbits,allperipheralsinterruptpendingbitsandRTCAlarm
flag must be reset. Otherwise, the stop mode entry procedure is ignored and program execution
continues. Stop1 mode can be entered from run mode and low-power run mode, while it is not
possible to enter stop2 mode from the low-power run mode.
Any EXTI-line configured in interrupt or event mode forces the CPU to exit from stop mode,
according if it entered in low-power mode using the WFI or WFE instruction. Since both HSE and
PLL are disabled before entering in stop mode, when exiting from this low-power mode the MCU
source clock is set to the HSI. This means that our code shall reconfigure the clock tree according to
wanted SYSCLK speed.
19.4.2.4 Standby Modes
STM32L MCUs provide two standby modes, which are based on the Cortex-M deep sleep mode. The
standby modeisthelowestpowermodeinwhich32KbytesofSRAM2canberetained,theautomatic
switch from VDD to VBAT is supported and the I/Os level can be configured by independent pull-
up and pull-down circuitry. By default, the voltage regulators are in power down mode and the
SRAMs and the peripherals registers are lost. The 128-byte backup registers are always retained.
The ultra-low-power BOR is always ON to ensure a safe reset regardless of the VDD slope.
To place the MCU in standby mode the HAL provides the function:
void HAL_PWR_EnterSTANDBYMode(void);
If we want to retain 32 Kbytes of SRAM2, then we can call the function:
void HAL_PWREx_EnableSRAM2ContentRetention(void);
Power Management 525
before we call the HAL_PWR_EnterSTANDBYMode() ;
In STM32L microcontrollers each I/O can be configured with or without a pull-up or pull-down
resistors, by calling the HAL function HAL_PWREx_EnablePullUpPullDownConfig() . This allows to
control the inputs state of external components even during standby mode. For more information
about this topic, refer to the reference manual of your MCU.
The microcontroller exits the standby mode when an external reset (NRST pin), an IWDG reset,
a rising edge on one of the enabled WKUPx pins or an RTC event occurs. All registers are reset
after wakeup from standby except for Power Control/Status Register ( PWR->CSR ). After waking up
from standby mode, program execution restarts in the same way as after a reset (boot pin sampling,
option bytes loading, reset vector is fetched, etc.). Using the macro:
__HAL_PWR_GET_FLAG(PWR_FLAG_SB);
we can check if the MCU is resetting due to an exit from standby mode. Since both HSE and PLL
are disabled before entering in stop mode, when exiting from this low-power mode the MCU source
clock is set to the HSI. This means that our code shall reconfigure the clock tree according to wanted
SYSCLK speed.
19.4.2.5 Shutdown Mode
The shutdown mode is the lowest power mode with only 30 nA at 1.8 V in STM32L4 MCUs. This
mode is similar to the standby one but without any power monitoring: the BOR is disabled and
the switch to VBAT is not supported in this mode. The LSI is not available, and consequently the
independent watchdog is also not available. A Brown-Out Reset is generated when the device exits
shutdown mode: all registers are reset except those in the backup domain, and a reset signal is
generated on the pad. The 128-byte backup registers are retained in shutdown mode. When exiting
shutdown mode, the wakeup clock is MSI at 4 MHz.
To enter shutdown mode the HAL provides the function:
void HAL_PWREx_EnterSHUTDOWNMode(void);
The microcontroller exits the shutdown mode when an external reset (NRST pin), a rising edge on
one of the enabled WKUPx pins or an RTC event occurs. All registers are reset after wakeup from
standby, including the Power Control/Status Register ( PWR->CSR ). After waking up from shutdown
mode, program execution restarts in the same way as after a reset (boot pin sampling, option bytes
loading, reset vector is fetched, etc.).
19.4.3 Power Modes Transitions
STM32L MCUs offer a lot of power modes. However, it is important to remark that it is not possible
to reach every power mode starting from a given one, but the power mode transitions are limited.
Power Management 526
The Figure 9 shows the valid power mode transitions in an STM32L4 microcontroller. As you can
see, from run mode, it is possible to access all low-power modes except the low-power sleep one. In
order to go into low-power sleep mode, it is required to move first to low-power run mode and then
to execute a WFI or WFE instruction while the regulator is the low-power one. On the other hand,
when exiting low-power sleep mode, the STM32L4 is in low-power run mode.
When the device is inlow-power run mode, it is possible to go into all low-power modes exceptsleep
and stop2 modes. Stop2 mode can only be entered from the run one.
If the device enters in Stop1 mode from the low-power run one, it will exit in low-power run mode.
If the device enters standby or shutdown from low-power run mode, it will exit in run mode.
Figure 9: The allowable power mode transitions in an STM32L4 MCU
19.4.4 Low-Power Peripherals
Almost all STM32L MCUs provide dedicated low-power peripherals. Here you can find a brief
introduction to them.
19.4.4.1 LPUART
The Low-Power UART (LPUART) is an UART that allows bidirectional UART communications with
limitedpowerconsumption.Onlya32.768kHzLSEclockisrequiredtoallowUARTcommunications
up to 9600 baud/s. Higher baud rates can be reached when the LPUART is clocked by clock sources
different from the LSE clock. Even when the microcontroller is in stop mode, the LPUART can wait
for an incoming UART frame while having an extremely low-energy consumption. The LPUART
includesallnecessaryhardwaresupporttomakeasynchronousserialcommunicationspossiblewith
minimum power consumption. It supports half-duplex single wire communications and modem
operations (CTS/RTS). It also supports multiprocessor communications. DMA can be used for data
transmission/reception even in stop 2 mode.
To program the LPUART peripheral we use the same functions from the HAL_UART module.
Power Management 527
19.4.4.2 LPTIM
The Low-Power Timer (LPTIM) is a 16-bit timer that benefits from the ultimate developments in
power consumption reduction. Thanks to its diversity of clock sources, the LPTIM is able to keep
running whatever the selected power mode, different from standard STM32 timers that do not run
during stop modes. Given its capability to run even with no internal clock source, the LPTIM can be
used as a pulse counter which can be useful in some applications. Moreover, the LPTIM capability
to wake up the system from low-power modes makes it suitable to realize timeout functions with
extremely low-power consumption. In Chapter 23 about FreeRTOS, we will use the LPTIM timer as
source timebase for tickless idle mode. The LPTIM introduces a flexible clock scheme that provides
the needed functionalities and performances, while minimizing the power consumption.
These are the relevant features of a LPTIM peripheral:
• 16 bit upcounter
• 3-bit prescaler with 8 possible dividing factor (1,2,4,8,16,32,64,128)
• Selectable clock source
– Internal clock sources: LSE, LSI, HSI16 or APB clock
– External clock source over ULPTIM input (working with no LP oscillator running, used
by pulse counter application)
• 16 bit period register
• 16 bit compare register
• Continuous/one shot mode
• Selectable software/hardware input trigger
• Configurable output: Pulse, PWM
• Configurable I/O polarity
• Encoder mode
To program an LPTIM timer we use the dedicated HAL_LPTIM module.
19.5 Power Supply Supervisors
The majority of STM32 microcontrollers provide two power supply supervisors: BOR and PVD. The
Brownout Reset (BOR) is a unit that keeps the microcontroller under reset until the supply voltage
reaches the specified VBOR threshold. VBOR is configured through device option bytes. By default,
BOR is OFF. The user can select between three to five programmable VBOR threshold levels. For
full details about BOR characteristics, refer to the “Electrical characteristics” section in the device
datasheet. STM32 devices that do not provide a BOR unit, usually have a similar unit named Power
on Reset (POR)/Power Down Reset (PDR), which perform the same operation of the BOR unit but
with a fixed and factory-configured voltage threshold.
The power supply can be actively monitored by the firmware by using the Programmable Voltage
Detector (PVD). The PVD allows to configure a voltage to monitor, and if this VDD is higher or
Power Management 528
lower than the given level, a corresponding bit in the Power Control/Status Register ( PWR->CSR ) is
set. If properly configured, the MCU can generate a dedicated IRQ through the EXTI controller. To
enable/disablethePVDinthoseMCUswiththisfeatures,theHALprovidesthefunctions HAL_PWR_-
EnablePVD() / HAL_PWR_DisablePVD() , while to configure the voltage level it provides the function
HAL_PWR_ConfigPVD() . For more information, refer to the HAL_PWREx module of the CubeHAL.
19.6 Debugging in Low-Power Modes
By default, the debug connection is lost if the application puts the MCU in sleep, stop and standby
modes while the debug features are used. This is due to the fact that the Cortex-M core is no
longer clocked. However, by setting some configuration bits in the DBGMCU_CR register of the MCU
debugcomponent (DBGMCU),thesoftwarecanbedebuggedevenwhenusingthelow-powermodes
extensively.
The CubeHAL provides convenient functions to enable/disable debug mode in low-power modes.
The function HAL_DBGMCU_EnableDBGSleepMode() is used to enable debugging during sleep mode²¹;
thefunctions HAL_DBGMCU_EnableDBGStopMode() and HAL_DBGMCU_EnableDBGStandbyMode() allowto
use debug interface during stop and standby modes respectively.
It is important to remark that, if we want to debug the MCU in low-power modes, we also
have to leave ON the GPIO peripherals corresponding to SWDIO/SWO/SWCLK pins. In all
Nucleo boards these pins coincide with PA13, PA14 and PB3.
Please, take note that, before enabling MCU debugging in low-power modes, DBGMCU
interface must be enabled by calling the __HAL_RCC_DBGMCU_CLK_ENABLE() macro.
19.7 Using the CubeMX Power Consumption Calculator
It may be a nightmare to manually estimate the power consumption of a microcontroller, with
several peripheral enabled and several transition states in its different power modes. Even if
MCU datasheets provide all necessary information, it is really hard to figure out the exact power
consumption levels.
CubeMX provides a convenient tool, named Power Consumption Calculator (PCC), which allows us
to build a power sequence and to perform estimations of the MCU power consumption.
²¹ Debuggingduringthesleep modeisnotavailableinSTM32F0microcontrollersandhencethecorrespondingHALfunctionisnotprovided
by the HAL.
Power Management 529
Figure 10: The Power Consumption Calculator main view
The Figure 10 shows the main PCC view. To use it we have to first select the Vdd Power Supply
source, otherwise the tool does not allow us to create steps in the power sequence. The next optional
step consists in selecting a battery used to power the MCU when the main power is absent. This
is useful to evaluate the battery life. We can choose from a portfolio of well-known batteries, or
eventually add a custom one.
By clicking on the green ‘+’, we can add a step of the sequence. Here we can specify the power mode
(run, sleep, etc), the memories configuration (flash enabled/disabled, ART enabled/disabled, and so
on) and the power voltage level. From the same dialog we can also choose the CPU frequency, the
duration of the step and the enabled peripherals.
With this tool we can so figure out how much power is needed by the microcontroller. In L0, L1
and L4 MCUs is also possible to enable the Transition Checker, which allows to identify invalid
transition states (for example, we cannot switch from the run mode to the low-power sleep one
without passing from the low-power run mode). For more information about the PCC view refer to
the UM1718²² from ST.
19.8 A Case Study: Using Watchdog Timers With
Low-Power Modes
Both IWDG and WWDG timers cannot be stopped once started. The WWDG timer keeps counting
until the stop mode, while the IWDG timer, being clocked by the LSI oscillator, works even in
shutdown mode. This means that watchdog timers prevents the MCU from staying in low-power
mode for a long time.
²² http://bit.ly/1WDpa5r
Power Management 530
If you need to use both watchdog timer and low-power modes in your application, then you need to
followthistrickbasedonthefactthatthecontentoftheSRAMmemorysurvivestosuccessiveresets
(clearly, it does not survive to a power-on reset). So to keep track of a reset caused by a watchdog
timer while staying in a low-power mode, you can use a variable that keeps track of this fact (for
example, you set the content of an uint32_t variable to a special “key” value before entering in a
low-power mode). Once the MCU resets, you can check the content of this variable, and you can
avoid starting the watchdog timer if that variable is configured accordingly.
However, we need a “safe” place to store this variable, otherwise it is likely to be overwritten by
startup routines. So, the best thing to do is to reduce the size of the SRAM region inside the mem.ld
file, and to place this sentinel variable at the end of the SRAM memory, where usually the main
stack starts:
volatile uint32_t *lpGuard = (0x20000000 + SRAM_SIZE);
For example, assuming an STM32F030R8 MCU with 8KB of SRAM, and assuming that we define
the SRAM region in the mem.ld file in the following way:
MEMORY {
FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 64K
SRAM (xrw) : ORIGIN = 0x20000000, LENGTH = 8K - 4
}
we have that the macro SRAM_SIZE will be equal to 0x2000-4 = 0x1FFC . The content of the lpGuard
variable will be so placed at the address 0x2000 1FFC
I am aware of the fact that these concepts may look attally obscure. A lot of thing will be clarified
once you read the next chapter about the memory layout of an STM32 application.
20. Memory layout
Every time we compile our firmware using the GCC ARM tool-chain, a series of non-trivial things
takes place. The compiler translates the C source code in the ARM assembly and organizes it to
be flashed on a given STM32 MCU. Every microprocessor architecture defines an execution model
that needs to be “matched” with the execution model of the C programming language. This means
that several operations are performed during bootstrap, whose task is to prepare the execution
environment for our application: the stack and heap creation, the initialization of data memory, the
vector table initialization are just some of the activities performed during startup. Moreover, some
STM32 microcontrollers provide additional memories, or allow to interface external ones using the
FSMC controller, that can be assigned to specific tasks during the firmware lifecycle.
This chapter aims to throw light to those questions that are common to a lot of STM32 developers.
What does it happen when the MCU resets? Why providing the main() function is mandatory? And
how long does it take to execute since the MCU resets? How to store variables in flash instead of
SRAM? How to use the STM32 CCM memory?
20.1 The STM32 Memory Layout Model
In Chapter 1 we have analyzed how STM32 MCUs organize the 4GB memory address space. Figure
4 from that chapter clearly shows how the first 0.5GB of memory are dedicated to the code area. In
turn this area is subdivided in several sub-regions. The most important one, starting from 0x0800
0000 address, is dedicated to the mapping of the internal flash memory. Instead, the internal SRAM
memory starts from the 0x2000 0000 address, and it is organized in several sub-regions dedicated
to specific tasks that we will see in a while.
Figure1showsthetypicallayoutofflashandSRAMmemoriesinanSTM32MCU¹.InChapter7we
learned that the initial bytes of flash memory are dedicated to theMain Stack Pointer (MSP) and the
vectortable².TheMSPcontainstheaddresswherethestackbegins.TheCortex-Marchitecturegives
maximum freedom of placing the stack in the SRAM memory as well as in other internal memories
(for example, the CCM RAM available in some STM32 MCUs) or external ones (connected to the
FSMC controller). This explains the need for the MSP.
The flash memory can be also used to store read only data, also known as const data due to the fact
that variables declared as const are automatically placed in this memory. Finally, the flash memory
contains the assembly code generated from the C source code.
¹ It is important to remark that this layout reflects just one of the possible memory configurations, and it changes in case we use an RTOS.
However, the underlying concepts remain the same, and it is better to consider this memory organization here.
² Remember that, as we will see next, the Cortex-M architecture defines the 0x0000 0000 address as the memory location where starting
to place MSP and vector table. This means that the flash starting address ( 0x0800 0000 ) is aliased to 0x0000 0000 .
Memory layout 532
Figure 1: The typical layout of flash and SRAM memories
The SRAM memory is also organized in several sub-regions. A variable-sized region starting from
the end of SRAM and growing downwards (that is, its base address has the highest SRAM address)
is dedicated to the stack. This happens because Cortex-M cores use a stack memory model called
full-descending stack. The base stack pointer, also called Main Stack Pointer (MSP), is computed
at compile time, and it is stored at 0x0800 0000 flash memory location. Once we call a function, a
new stack frame is pushed on the stack. This means that the pointer to current stack frame (SP) is
automatically decremented at every function call (for example, the ARM assembly push instruction
automatically decrements it).
The SRAM is also used to store variable data, and this region usually starts at beginning of
SRAM ( 0x2000 0000 ). This region is in turn divided between initialized and un-initialized data.
To understand the difference, let us consider this code fragment:
Memory layout 533
...
uint8_t var1 = 0xEF;
uint8_t var2;
...
var1 and var2 are two global variables. var1 is an initialized variable (we fix its starting value at
compile time), while the value var2 is un-initialized: it is up to the run-time to initialize it to zero.
For the same reason, we have two .data sections: one stored in flash and one in RAM, as we will
see next.
Finally, the SRAM memory could contain another growing region: the heap. It stores variables that
are allocated dynamically during the execution of the firmware (by using the C malloc() routine or
similar).Thisareacanbeinturnorganizedinseveralsub-regions,accordingtotheallocator used(in
the next chapter we will see how FreeRTOS provides several allocators to handle dynamic memory
allocation). The heap grows upwards (that is, the base address is the lowest in its region) and it has
a fixed maximum size.
From the compiler point of view, these sections are traditionally named in a different way inside
the application binary. For example, the section containing assembly code is named .text , .rodata
is the one containing const variables and strings, while the section for initialized data is named
.data . These names are also common to other computer architectures, like x86 and MIPS. Others
are specific of “microcontrollers world”. For example, the .isr_vector section is the one designated
to store the vector table in Cortex-M based MCUs³.
Since every STM32 MCU has its own quantity of SRAM and flash, and since every program has
a variable number of instructions and variables, the dimension and location in memory of these
sections differ. Before we can see how to instruct the compiler to generate the binary file for the
specific MCU, we have to understand all the steps and tools involved during the generation ofobject
files.
20.1.1 Understanding Compilation and Linking Processes
The process that goes from the compilation of the C source code to the generation of the final binary
image to flash on our MCU involves several steps and tools provided by the GCC tool-chain. The
Figure 2 tries to outline this process. All starts from the C source files. They usually contain the
following program structures.
³ However, we will see next that its name is just a convention.
Memory layout 534
Figure 2: The compilation process from the source file to the final binary image
• Global variables: these can be in turn divided between un-initialized and initialized variables;
a global variable can also defined as static , that is its visibility is limited to the current source
file.
• Localvariables:thesecanbedividedbetweensimplelocal(alsocalledautomatic)variablesand
static local variables (that is those variables whose lifetime extends across the entire run of the
program).
• Const data: these can be in turn divided between const data types (e.g. const int c = 5 ) and
string constants (e.g. "Hello World!" ).
• Routines: these constitute the program and they will be translated in assembly instructions.
• External resources: these are both global variables (declared as extern ) and routines defined
in other source files. It will be a linker job to “link” the references to these symbols defined in
other source files and to merge the sections coming from the corresponding binary files.
Once a source file is compiled, the above program structures are mapped inside specific sections of
the binary file. The Table 1 summarizes the most relevant ones.
Memory layout 535
Table 1: The mapping of program structures and binary file sections
Language structure Binary file section Memory region at run-time
Global un-initialized variables .common Data (SRAM)
Global initialized variables .data Data (SRAM+Flash)
Global static un-initialized variables .bss Data (SRAM)
Global static initialized variables .data Data (SRAM+Flash)
Local variables <no specific section> Stack or Heap (SRAM)
Local static un-initialized variables .bss Data (SRAM)
Local static initialized variables .data Data (SRAM+Flash)
Const data types .rodata Code (Flash)
Const strings .rodata.1 Code (Flash)
Routines .text Code (Flash)
For every source file ( .c ) composing our application, the compiler will generate a corresponding
object file ( .o ), which contains the sections in Table 1⁴. An object file is a type of binary file that
adheres to a well-known standard. There are a lot of standards for binary files around (PE, COFF,
ELF, etc.). The one used by GCC ARM is the ELF32, an open standard really popular, due its usage in
Linux-based Operating Systems, and it is widely supported even by other tools like OpenOCD and
the STM32CubeProgrammer. File ending with .o ⁵ are, however, a special type of object files. These
are also known as relocatable files. This name comes from the fact that all the memory addresses
contained in this type of file are relative to the same file, and starts from the 0x0000 0000 address.
This means that also .text section will start from that address, and we know that this is in contrast
with the starting address of flash memory ( 0x0800 0000 ) in an STM32 MCU⁶.
Starting from a series of relocatable files (plus some other configuration files that we will see in a
while), the linker will assemble their content to form one common object file that will represent
our firmware to flash on the MCU. In this process, called linking, the linker will relocate all relative
addresses to the actual memory addresses. This type of file is also known as absolute file, because
all addresses are absolute and specific of the given STM32 MCU⁷.
How does the linker know where to place in memory the sections contained in the absolute file?
It is thanks to linker scripts (those files ending with .ld ) that we can arrange the content of the
absolute file according to the actual memory layout. We have already seen a linker script inChapter
⁴ It is important to underline that an object file contains much more sections. The most of them are related to debugging, and contain
relevant information like the original source code, all the symbols contained in the source file (even those that have been optimized by the
compiler), and so on. However, for the purposes of this discussion, it is better to leave them out.
⁵ Take in mind that, from the compiler point of view, the file extension is just a convention.
⁶ Those of you that want to deepen this matter can take a look at the readelf tool provided in the GCC ARM tool-chain.
⁷ Here, again, the story is more complex. First of all, the linker could assemble other pieces from several external statically linked libraries
(those ending with .a ). These library, also known as archive files, are nothing more than a merge of several relocatable files. During the linking
process, only those program structures actually used in our application will be merged with the final firmware. Another important aspect
to remark is that this process is essentially the same for every microprocessor platform (like the x86 and so on), and it is also called static
linking. More powerful architectures face an advanced linking process, also known as dynamic linking, which postpones the linking when the
program will be loaded in the OS process. This allows to dramatically reduce the size of executables, and to update the dependency libraries
without recompiling the whole application. In dynamic linking libraries are called shared objects (or shared libraries, or DLL in Windows),
and in modern Operating Systems it is possible to share the same .text section from these libraries among the processes that use them by
using mmap() or similar system calls. This allows reducing as well the SRAM occupation of processes (think to the tons of system libraries that
should be “replicated” among the several processes running on a modern PC).
Memory layout 536
4, when we have configured the mem.ld file to specify the right flash origin address. CubeMX also
embeds the right linker script for our MCU inside the generated C project (it is contained inside
the sub-folder SW4STM32 ). However, it is really hard to study the content of those scripts if we have
not mastered several concepts before. So, it is better to start smoothly creating a bare bone STM32
application.
20.2 The Really Minimal STM32 Application
The most of applications seen until now seem really simple. Instead, both from the memory
organization point of view and from the operations performed when the MCU boots, they already
execute a lot of operations under the hood. For this reason, we are going to build a really essential
application.
The first step is creating an empty project using Eclipse.Go toFile->New->CProjectmenu. Choose
the Empty projecttype and select theCross ARM GCCtool-chain, as shown inFigure 3. Complete
the project wizard.
Figure 3: The project settings to choose
Create now a new file named main.c and place the following code inside it⁸.
⁸ This code is designed to work with the Nucleo-F401RE. Refer to the book examples for the other Nucleos.
Memory layout 537
Filename: src/main-ex1.c
1 typedef unsigned long uint32_t;
2
3 /* Memory and peripheral start addresses (common to all STM32 MCUs) */
4 #define FLASH_BASE 0x08000000
5 #define SRAM_BASE 0x20000000
6 #define PERIPH_BASE 0x40000000
7
8 /* Work out end of RAM address as initial stack pointer
9 * (specific of a given STM32 MCU */
10 #define SRAM_SIZE 96*1024 // STM32F401RE has 96 KB of RAM
11 #define SRAM_END (SRAM_BASE + SRAM_SIZE)
12
13 /* RCC peripheral addresses applicable to GPIOA
14 * (specific of a given STM32 MCU */
15 #define RCC_BASE (PERIPH_BASE + 0x23800)
16 #define RCC_APB1ENR ((uint32_t*)(RCC_BASE + 0x30))
17
18 /* GPIOA peripheral addresses
19 * (specific of a given STM32 MCU */
20 #define GPIOA_BASE (PERIPH_BASE + 0x20000)
21 #define GPIOA_MODER ((uint32_t*)(GPIOA_BASE + 0x00))
22 #define GPIOA_ODR ((uint32_t*)(GPIOA_BASE + 0x14))
23
24 /* User functions */
25 int main(void);
26 void delay(uint32_t count);
27
28 /* Minimal vector table */
29 uint32_t *vector_table[] __attribute__((section(".isr_vector"))) = {
30 (uint32_t *)SRAM_END, // initial stack pointer
31 (uint32_t *)main // main as Reset_Handler
32 };
33
34 int main() {
35 /* Enable clock on GPIOA peripheral */
36 *RCC_APB1ENR = 0x1;
37 /* Configure the PA5 as output pull-up */
38 *GPIOA_MODER |= 0x400; // Sets MODER[11:10] = 0x1
39
40 while(1) {
41 *GPIOA_ODR = 0x20;
42 delay(200000);
43 *GPIOA_ODR = 0x0;
44 delay(200000);
45 }
46 }
Memory layout 538
47
48 void delay(uint32_t count) {
49 while(count--);
50 }
The first 21 lines contain just macros that define the most common STM32 peripheral addresses.
Some are generic and some specific of the given MCU. At line 26 we are defining the vector table.
Being “minimal”, it just contains two things: the address in SRAM of the MSP (remember that this
it the first entry of the vector table and it must be placed at 0x0800 0000 address) and the pointer to
the handler of the Reset exception. What exactly are we doing?
In Chapter 7 we mentioned that when the MCU resets, the NVIC controller generates a Reset
exception after few cycles. This means that its handler is the real entry point of our application, and
the execution of the firmware starts from there. Here we are going to define the main() function
as the handler of Reset exception. The GCC keyword __attribute__((section(".isr_vector")))
says to the compiler to place the vector_table array inside the section named .isr_vector , which
in turn will be contained in the object file main.o . Finally the main() routine contains nothing more
then the classical blinking application.
Before we can compile the firmware, we need to specify a couple of project settings. Go in Project
settings->C/C++ Build->Settings. In the Target Processor settings select the Cortex-M core that
fits your MCU. Then go in the Cross ARM C Linker->General section and check the entry Do not
use standard start files⁹ and uncheck the entry Remove unused sections, as shown in Figure 4.
If you try to compile the application, you will see the following warning in the Eclipse console:
warning: cannot find entry symbol _start; defaulting to 0000000000008000
What does it mean? GCC (or better, LD) is saying to us that it does not know which is the entry
routine of our application ( _start() - this entry point name is a convention in GCC) and it does not
know at which absolute memory location to start placing the code. So, how can we address this?
We need a linker script.
⁹ Leaving that option unchecked causes that the initialization routines from libc are used. These are usually “less optimized”, since they
need to deal with some advanced feature from libc related to the C++ programming language. So, usually the startup routines from ST are
specific for this platform, allowing to save a lot of flash memory and to reduce the boot time.
Memory layout 539
Figure 4: The project settings to choose
Create a new file named ldscript.ld and place the following content inside it.
Filename: src/ldscript.ld
1 /* memory layout for an STM32F401RE */
2
3 MEMORY
4 {
5 FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 512K
6 SRAM (xrw) : ORIGIN = 0x20000000, LENGTH = 96K
7 }
8
9 ENTRY(main)
10
11 /* output sections */
12 SECTIONS
13 {
14 /* program code into FLASH */
15 .text : ALIGN(4)
16 {
17 *(.vector_table) /* Vector table */
Memory layout 540
18 *(.text) /* Program code */
19 KEEP(*(.vector_table))
20 } >FLASH
21
22 /* Initialized global and static variables (which
23 we don't have any in this example) into SRAM */
24 .data :
25 {
26 *(.data)
27 } >SRAM
28 }
Let us see the content of this file. Lines [3:7] contain the definition of the flash and SRAM memories.
Eachregioncanhaveseveralattributes(w=writable,r=readable,x=executable).Wealsospecifytheir
starting address and length (in the above example they are related to an STM32F401RE MCU). Line
9 specifies the main() function as the entry point of our application (overriding the default _start
symbol)¹⁰. Lines [12:28] define the content of the .text and .data sections. The .text section will
be composed first by the vector table and then by the program code. With the ALIGN(4) directive
we are saying that the section is word (4 bytes) aligned, while the >FLASH directive specifies that
the .text section will be placed inside the flash memory. The KEEP(*(.isr_vector)) says to LD to
keep the vector table inside the final absolute file, otherwise the section could be “stripped” by other
tools that perform optimizations on the final file. Finally, the .data section is also defined (even if
does not contain nothing in this example), and it is placed inside the SRAM memory.
Before we can compile the firmware we need to instruct Eclipse to include the linker script
during compilation. Go in Project settings->C/C++ Build->Settings. In the Cross ARM C Linker-
>General section add the entry ”../ldscript.ld” to the Script files (-T) list. Now you can compile the
firmware and flash your Nucleo. Congratulation: it is almost impossible to have a smaller STM32
application¹¹.
20.2.1 ELF Binary File Inspection
An ELF binary file can be inspected using a series of tools provided by the GNU MCU tool-chain.
objdump and readelf are the most common ones. Describing their usage is outside the scope of
this book. However, it is strongly suggested to dedicate a couple of hours playing with their optional
parameterstothecommand-line.Understandinghowabinaryfileismadecandramaticallyimprove
the knowledge of what under the hood. For example, running objdump with the -h parameter shows
the content of all sections contained in the firmware binary¹².
¹⁰ The ENTRY() directive is meaningless in embedded applications, where the actual entry point corresponds to the handler of the Reset
exception. However, it may be informative for debuggers and simulators, and for this reason you will find it in ST official LD linker scripts.
¹¹ Ok, coding it in assembly will allow you to save additional space, but this book is not for masochists ;-D
¹² When you run the command, you will se much more sections all related to debug. Here you will not see them because the debug
information has been “stripped” from the file using the arm-none-eabi-strip command.
Memory layout 541
# ~/STM32Toolchain/gcc-arm/bin/arm-none-eabi-objdump -h nucleo-f401RE.elf
nucleo-f401RE.elf: file format elf32-littlearm
Sections:
Idx Name Size VMA LMA File off Algn
0 .text 00000008 08000000 08000000 00008000 2**2
CONTENTS, ALLOC, LOAD, READONLY, DATA
1 .text.main 00000040 08000008 08000008 00008008 2**2
CONTENTS, ALLOC, LOAD, READONLY, CODE
2 .text.delay 00000020 08000048 08000048 00008048 2**2
CONTENTS, ALLOC, LOAD, READONLY, CODE
3 .comment 00000070 00000000 00000000 0000b1d2 2**0
CONTENTS, READONLY
4 .ARM.attributes 00000033 00000000 00000000 0000b242 2**0
CONTENTS, READONLY
Lookingtotheaboveoutputweseeseveralthingsregardingthesectionscontainedinthebinaryfile.
Every section has a size, expressed in bytes. A section has also two addresses: the Virtual Memory
Address (VMA) and the Load Memory Address (LMA). In embedded systems like the STM32 MCUs,
the VMA is the address that the section will have when the firmware starts execution. The LMA is
the address at which the section will be loaded. In most cases the two addresses will be the same.
As we will discover in the next section, they differ for the .data region.
Every section has several attributes that say to the loader (in our case, for example, the loader is
GDB in conjunction with OpenOCD, or the STM32CubeProgrammer tool) what to do with the
given section. Let us see what they mean:
• CONTENTS : this attribute says to the loader that the section in the binary file contains data to
load in the final LMA address. As we will see next, the .bss section does not have content in
a binary file.
• ALLOC : this says to allocate a corresponding space in the LMA memory (which could be both
flash and SRAM memory). The dimension of the space allocated is given by the Size column.
• LOAD : this indicates to load the data from the section contained in the binary file to the final
LMA memory.
• READONLY : this indicates that the content of the section is read-only.
• CODE : this indicates that the content of the section is binary code.
Another interesting thing to remark from the previous output is that the binary file contains a
dedicated section for every callable contained in the source code ( .text.main for the main() and
.text.delay for delay() ). We have to specify to the linker to merge all the .text sections in a
whole common section, modifying the linker script in this way:
Memory layout 542
.text : ALIGN(4)
{
*(.isr_vector) /* Vector table */
*(.text) /* Program code */
*(.text*) /* Merge all .text.* sections inside the .text section */
KEEP(*(.isr_vector))
} >FLASH
As we will see later, the ability to have separated sections for every callable, allow us to selectively
place some functions inside different memories (for example, the fast CCM memory in some STM32
MCUs).
Finally, the File off column specifies the offset of the section inside the binary file, while the Algn
column indicates the data align in memory, which is 4-bytes.
20.2.2 .data and .bss Sections Initialization
Let us introduce a minor modification to the previous example.
36 volatile uint32_t dataVar = 0x3f;
37
38 int main() {
39 /* enable clock on GPIOA and GPIOC peripherals */
40 *RCC_APB1ENR = 0x1 | 0x4;
41 *GPIOA_MODER |= 0x400; // Sets MODER[11:10] = 0x1
42
43 while(dataVar == 0x3f) { // This is always true
44 *GPIOA_ODR = 0x20;
45 delay(200000);
46 *GPIOA_ODR = 0x0;
47 delay(200000);
48 }
49 }
This time we use a global initialized variable, dataVar , to start the blinking loop. The variable has
been declared volatile just to avoid that the compiler optimizes it (however, when compiling this
example, disable all optimizations [-ON] in the project settings). Looking at the code, we can reach
to the conclusion that it does the same thing of the previous example. However, if you try to flash
your Nucleo, you will see that the LD2 LED does not blink. Why not?
Tounderstandwhat’shappening,wehavetoreviewsomethingsfromtheCprogramminglanguage.
Consider the following code fragment:
Memory layout 543
...
uint32_t globalVar = 0x3f;
void foo() {
volatile uint32_t localVar = 0x4f;
while(localVar--);
}
Here we have two variables: one defined at global scope, one locally. The localVar variable is
initialized to the value 0x4f . When does this exactly happen? The initialization is executed when
the foo() routine is invoked, as shown by the following assembly code:
1 void foo() {
2 0: b480 push {r7} ;Save the current FP
3 2: b083 sub sp, #12 ;Allocate 12 bytes on the stack
4 4: af00 add r7, sp, #0 ;Save the new FP
5 volatile uint32_t localVar = 0x4f;
6 6: 234f movs r3, #79 ;Place 0x4f in r3
7 8: 607b str r3, [r7, #4] ;Store r3 (that is 0x4f) in the 4-th byte
8
9 while(localVar--);
10 a: bf00 nop
11 c: 687b ldr r3, [r7, #4]
12 e: 1e5a subs r2, r3, #1
13 10: 607a str r2, [r7, #4]
14 12: 2b00 cmp r3, #0
15 14: d1fa bne.n c <foo+0xc>
16 }
Lines [2:4] are the function prolog. Each routine is responsible of allocating its own stack frame,
saving some CPU internal registers. This is also called calling convention, and the way this is
performed is defined by a specific standard (in case of ARM based processors, it is defined by the
ARMArchitectureProcedureCallStandard (AAPCS)).Wewillnotgointodetailsofthismatterhere,
because we will better analyze the ARM calling convention in Chapter 24.
The instructions we are interested in are those at lines [5:6]. Here we are storing the value 0x4f
(which is 79 in base 10) inside the general-purpose register R3 and then moving its content inside
the second word in the stack, which corresponds to the localVar variable ¹³.
The remaining part of the assembly code contains the while(localVar--) and the function epilog
(not shown here), which is responsible of restoring the state before going back to the caller function.
So, the calling convention defines that local variables are automatically initialized upon function
call. What about global variables? Since they are not involved in a calling process, they need to be
¹³ It is important to clarify that the above assembly code is generated with all optimizations disabled.
Memory layout 544
initialized by some specific code when the MCU resets (remember that the SRAM is volatile, and
its content is undefined after a reset). This means that we have to provide a specific initialization
function.
The following routine can be used to simply copy the content of the flash region containing the
initialization values to the SRAM region dedicated to global initialized variables.
void __initialize_data (unsigned int* flash_begin, unsigned int* data_begin,
unsigned int* data_end) {
unsigned int *p = data_begin;
while (p < data_end)
*p++ = *flash_begin++;
}
Figure 3: The copy process of initialized data from the flash to the SRAM memory
Before we can use this routine, we need to define few other things. First of all, we need to instruct
LD to store the initialization values for each variable contained in the .data section inside a specific
region of the flash memory, which will correspond to the LMA memory address. Second, we need
a way to pass to the __initialize_data() function the start and the end of .data section in SRAM
(thatwearegoingcall _sdata and _edata respectively)andthestartinglocation(thatwearegoingto
call _sidata ) where initialization values are stored in the flash memory (it is important to stress that
when we initialize a variable to a given value we need to store that value somewhere in the flash,
and use it to initialize the SRAM location corresponding to the variable). The Figure 3 schematizes
this process.
Once again, all these operations can be performed using the linker script, which we can modify in
the following way:
Memory layout 545
25 /* Used by the startup to initialize data */
26 _sidata = LOADADDR(.data);
27
28 .data : ALIGN(4)
29 {
30 . = ALIGN(4);
31 _sdata = .; /* create a global symbol at data start */
32
33 *(.data)
34 *(.data*)
35
36 . = ALIGN(4);
37 _edata = .; /* define a global symbol at data end */
38 } >SRAM AT>FLASH
The instruction at line 26 defines the variable _sidata , which will contain the LMA address of
the .data section (that is, the starting address of flash memory containing initialization values).
Instructions at line [30:31] use a special operator: the “.” operator. It is named location counter and it
is a counter that keeps track of the memory location reached during the generation of each section.
The location counter independently counts location memory of every memory region (SRAM, flash
and so on). For example, in the above code, it starts from 0x2000 0000 since the .data section is
the first one loaded in SRAM. When the two instructions *(.data) and *(.data*) are performed,
the location counter is incremented by the size of all .data sections contained in the file. With
the instruction . = ALIGN(4); we are just forcing the location counter to be word aligned. So, to
recap, _sdata will contain 0x2000 0000 and _edata will be equal to the size of .data section (in our
example, .data section contains only one variable - dataVar - and hence its size is 0x2000 0004 ).
Finally, the directive >SRAM AT>FLASH says to the link editor that the VMA address of the .data
section is bound to the SRAM address space (so 0x2000 0000 ), but the LMA address (that is, where
the initialization values are stored) is mapped inside the flash memory space.
Thanks to this new memory layout configuration, we can now arrange the main.c file in the
following way:
Filename: src/main-ex2.c
22 void _start (void);
23 int main(void);
24 void delay(uint32_t count);
25
26 /* Minimal vector table */
27 uint32_t *vector_table[] __attribute__((section(".isr_vector"))) = {
28 (uint32_t *)SRAM_END, // initial stack pointer
29 (uint32_t *)_start // main as Reset_Handler
30 };
31
32 // Begin address for the initialisation values of the .data section.
33 // defined in linker script
Memory layout 546
34 extern uint32_t _sidata;
35 // Begin address for the .data section; defined in linker script
36 extern uint32_t _sdata;
37 // End address for the .data section; defined in linker script
38 extern uint32_t _edata;
39
40
41 volatile uint32_t dataVar = 0x3f;
42
43 inline void
44 __initialize_data (uint32_t* flash_begin, uint32_t* data_begin,
45 uint32_t* data_end) {
46 uint32_t *p = data_begin;
47 while (p < data_end)
48 *p++ = *flash_begin++;
49 }
50
51 void __attribute__ ((noreturn,weak))
52 _start (void) {
53 __initialize_data(&_sidata, &_sdata, &_edata);
54 main();
55
56 for(;;);
57 }
58
59 int main() {
60
61 /* enable clock on GPIOA and GPIOC peripherals */
62 *RCC_APB1ENR = 0x1 | 0x4;
63 *GPIOA_MODER |= 0x400; // Sets MODER[11:10] = 0x1
64
65 while(dataVar == 0x3f) {
66 *GPIOA_ODR = 0x20;
67 delay(200000);
68 *GPIOA_ODR = 0x0;
69 delay(200000);
70 }
71 }
The entry point is now the _start() routine,which is used as handler for theReset exception.When
the MCU resets, it is automatically called, and in turn it calls the __initialize_data() function,
passing the parameters _sidata , _sdata and _edata computed by the Linker during the linking
process. _start() then calls the main() routine, which now works as expected.
Using the objdump tool we can check how the sections are organized in the ELF file.
Memory layout 547
# ~/STM32Toolchain/gcc-arm/bin/arm-none-eabi-objdump -h nucleo-f401RE.elf
nucleo-f401RE.elf: file format elf32-littlearm
Sections:
Idx Name Size VMA LMA File off Algn
0 .text 000000c0 08000000 08000000 00008000 2**2
CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .data 00000004 20000000 080000c0 00010000 2**2
CONTENTS, ALLOC, LOAD, DATA
2 .comment 00000070 00000000 00000000 00010004 2**0
CONTENTS, READONLY
3 .ARM.attributes 00000033 00000000 00000000 00010074 2**0
CONTENTS, READONLY
As you can see, the tool confirms that the .data section has a size equal to 4 bytes, a VMA address
equal to 0x2000 0000 and an LMA address equal to 0x0800 00c0 , which corresponds to the end of
.text section.
The same applies to the .bss section, which is reserved to uninitialized variables. According to the
ANSI C standard, the content of this section must be initialized to 0. However, the .bss section does
not have a corresponding flash region containing all zeros, but it is again up to the startup code to
initialize this region. The following linker script fragment shows the definition of the .bss section¹⁴:
25 /* Uninitialized data section */
26 .bss : ALIGN(4)
27 {
28 /* This is used by the startup in order to initialize the .bss section */
29 _sbss = .; /* define a global symbol at bss start */
30 *(.bss .bss*)
31 *(COMMON)
32
33 . = ALIGN(4);
34 _ebss = .; /* define a global symbol at bss end */
35 } >SRAM AT>SRAM
while the following routine, always invoked from the _start() one, is used to zero the .bss region
in SRAM:
void __initialize_bss (unsigned int* bss_begin, unsigned int* bss_end) {
unsigned int *p = bss_begin;
while (p < bss_end)
*p++ = 0;
}
Changing the main() routine in the following way allow us to check that all works correctly:
¹⁴ Please, take note that the order of sections inside a linker scripts reflects their order in memory. If we have two sections, named A and B,
both loaded in SRAM, if section A is defined before than B, then it will be placed in SRAM before then B.
Memory layout 548
Filename: src/main-ex3.c
76 volatile uint32_t dataVar = 0x3f;
77 volatile uint32_t bssVar;
78
79 int main() {
80
81 /* enable clock on GPIOA and GPIOC peripherals */
82 *RCC_APB1ENR = 0x1 | 0x4;
83 *GPIOA_MODER |= 0x400; // Sets MODER[11:10] = 0x1
84
85 while(bssVar == 0) {
86 *GPIOA_ODR = 0x20;
87 delay(200000);
88 *GPIOA_ODR = 0x0;
89 delay(200000);
90 }
91 }
Once again, we can see how the .bss section is arranged by invoking the objdump tool on the final
binary file
# ~/STM32Toolchain/gcc-arm/bin/arm-none-eabi-objdump -h nucleo-f401RE.elf
nucleo-f401RE.elf: file format elf32-littlearm
Sections:
Idx Name Size VMA LMA File off Algn
0 .text 000000e8 08000000 08000000 00008000 2**2
CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .data 00000004 20000000 080000e8 00010000 2**2
CONTENTS, ALLOC, LOAD, DATA
2 .bss 00000004 20000004 20000004 00010004 2**2
ALLOC
3 .comment 00000070 00000000 00000000 00010004 2**0
CONTENTS, READONLY
4 .ARM.attributes 00000033 00000000 00000000 00010074 2**0
CONTENTS, READONLY
The above output shows that the section has a size equal to four bytes, but it does not occupy room
in the final binary file since the section has only the ALLOC attribute.
20.2.2.1 A Word About the COMMON Section
Inthepreviouslinkerscriptwehaveusedthespecialdirective *(COMMON) duringthedefinitionofthe
.bss section. This simply says to the LD to merge the content of the common section inside the .bss
section. But what is exactly the common section? To better understand its role, we need to revise
Memory layout 549
some little known features of the C language. Suppose that we have two source files, and both of
them define two global initialized variables with the same name:
File A.c
int globalVar[3] = {0x1, 0x2, 0x3};
...
File B.c
int globalVar[3] = {0x1, 0x2, 0x3};
...
When we try to generate the final application linking the two relocatable files ( .o ), we obtain the
following error:
B.o:(.data+0x0): multiple definition of 'globalVar'
A.o:(.data+0x0): first defined here
collect2: error: ld returned 1 exit status
The reason why this happens is evident: we are defining the same global variable in two different
source files. But what if we declare the two symbols as un-initialized global variables?
File A.c
int globalVar[3];
...
File B.c
int globalVar[6];
...
If you try to generate the final binary file you will discover that the linker does not generate errors.
Why do the linker complain about both symbol definitions? Because the C Standard says nothing
to prohibit it. But if the language essentially allows to define multiple times a global un-initialized
variable, how much memory will be allocated? (that is, globalVar will be an array containing 3
or 6 elements?). This aspect is leaved to compiler implementation. Recent GCC versions place all
un-initialized global variables (not declared as static ) inside a whole “common” section, and the
amount of memory for a given symbol will assume the value of the greatest one (in our case, the
array will have room for six elements of type int - that is, 12 bytes).
So, to recap, static global un-initialized variables are local to a given relocatable, and hence go in
its .bss section; global un-initialized variables are global to the whole application, and go inside
the common section. The previous linker script places both types of global un-initialized variables
inside the .bss section, that will be zeroed at run-time by the __initialize_bss() routine.
Memory layout 550
This behavior can be overridden specifying the option -fno-common to the GCC command. GCC
will allocate global un-initialized variables inside the .data section, initializing them to zero. This
means that if we are declaring an un-initialized global array of 1000 elements, the .data section will
contain one thousand times the value 0: this will waste a lot of flash memory. So, for embedded
applications is better to avoid using that command line option.
20.2.3 .rodata Section
A program usually makes usage of constant data. Strings and numeric constants are just two
examples, but also large arrays of data can be initialized as constants (for example, a HTML file
used to generate web pages can be converted in an array, using tools like the xxd UNIX command).
Being immutable, constant data can be placed inside the internal flash memory (or inside external
flash memories connected to the MCU through the Quad-SPI interface) to save SRAM space. This
can be simply achieved defining the .rodata section inside the linker script:
/* Constant data goes into flash */
.rodata : ALIGN(4)
{
*(.rodata) /* .rodata sections (constants) */
*(.rodata*) /* .rodata* sections (strings, etc.) */
} >FLASH
For example, considering this C code:
Filename: src/main-ex4.c
76 const char msg[] = "Hello World!";
77 const float vals[] = {3.14, 0.43, 1.414};
78
79 int main() {
80 /* enable clock on GPIOA and GPIOC peripherals */
81 *RCC_APB1ENR = 0x1 | 0x4;
82 *GPIOA_MODER |= 0x400; // Sets MODER[11:10] = 0x1
83
84 while(vals[0] >= 3.14) {
85 *GPIOA_ODR = 0x20;
86 delay(200000);
87 *GPIOA_ODR = 0x0;
88 delay(200000);
89 }
90 }
we have that both the string msg and the array vals are placed inside the flash memory, as shown
by the objdump tool:
Memory layout 551
# ~/STM32Toolchain/gcc-arm/bin/arm-none-eabi-objdump -h nucleo-f401RE.elf
nucleo-f401RE.elf: file format elf32-littlearm
Sections:
Idx Name Size VMA LMA File off Algn
0 .text 00000590 08000000 08000000 00008000 2**3
CONTENTS, ALLOC, LOAD, READONLY, CODE
1 .rodata 00000024 08000590 08000590 00008590 2**2
CONTENTS, ALLOC, LOAD, READONLY, DATA
2 .comment 00000070 00000000 00000000 000085b4 2**0
CONTENTS, READONLY
3 .ARM.attributes 00000033 00000000 00000000 00008624 2**0
CONTENTS, READONLY
Pointers to Const Data
Pay attention that declaring a string in this way:
char *msg = "Hello World!";
...
is completely different from declaring it in this other way:
char msg[] = "Hello World!";
...
In the first case we are declaring a pointer to a const array, which implies that a word will be
allocated inside the .data section to store the location in flash memory of the string "Hello
World!" . In the second case, instead, we are correctly defining an array of chars.Remember
that in C arrays are not pointers.
20.2.4 Stack and Heap Regions
WehavealreadyseeninFigure1thatheapandstackaretwodynamicregionsoftheSRAMmemory
that grow in the opposite direction. The stack is a descendant structure, which grows from the end
of SRAM up to the end of .bss section, or the end of the heap if used. The heap grows in the opposite
direction. While the stack is a mandatory structure in C, the heap is used only if dynamic memory
allocation is needed. In some application fields (like in automotive area) the dynamic allocation is
not used, or at least is strongly suggested not to be used, because of the risk involved. A decent
management of the heap introduces a lot of performance penalties, and it is the source of possible
leaks and memory fragmentation.
However, if your application needs to allocate dynamically some portions of the memory, you can
consider to use the classical malloc() ¹⁵ routine from the C library. Let us consider this following
example:
¹⁵ There are other better alternatives, however. We will explore them in the next chapter.
Memory layout 552
Filename: src/main-ex5.c
107 int main() {
108 /* enable clock on GPIOA and GPIOC peripherals */
109 *RCC_APB1ENR = 0x1 | 0x4;
110 *GPIOA_MODER |= 0x400; // Sets MODER[11:10] = 0x1
111
112 char *heapMsg = (char*)malloc(sizeof(char)*strlen(msg));
113 strcpy(heapMsg, msg);
114
115 while(strcmp(heapMsg, msg) == 0) {
116 *GPIOA_ODR = 0x20;
117 delay(200000);
118 *GPIOA_ODR = 0x0;
119 delay(200000);
120 }
121 }
The above code is really simple. heapMsg is a pointer to a memory region dynamically allocated by
the malloc() function. We simply copy the content of the msg string and check if both strings are
equal. If so, the LD2 LED starts blinking.
If you try to compile the above code, you will see the following linking error:
Invoking: Cross ARM C++ Linker
arm-none-eabi-g++ ... ./src/ch10/main-ex5.o
/../../../../arm-none-eabi/lib/armv7e-m/libg_nano.a(lib_a-sbrkr.o): In function `_sbrk_r':
sbrkr.c:(.text._sbrk_r+0xc): undefined reference to `_sbrk'
collect2: error: ld returned 1 exit status
What’s happening? The malloc() function relies on the _sbrk() routine, which is a feature OS and
architecture dependent. The newlib leaves to the user the responsibility of providing this function.
The _sbrk() is a routine that accepts the amount of bytes to allocate inside the heap memory and
returns the pointer to the start of this contiguous “chunk” of memory. The algorithm underlying the
_sbrk() function is fairly simple:
1. First, it needs to check that there is sufficient space to allocate the desired amount of memory.
To accomplish this task, we need a way to provide to the _sbrk() routine the maximum heap
size.
2. If the heap has sufficient room to allocate the needed memory, it increments the current heap
size and returns the pointer to the beginning of the new memory block.
3. If the heap does not have sufficient room (heap overflow), then the _sbrk() fails, and it is up
to the user to provide an error feedback.
Thefollowingcodeshowsapossibleimplementationforthe _sbrk() routine.Letusanalyzeitscode.
Memory layout 553
Filename: src/main-ex5.c
81 void *_sbrk(int incr) {
82 extern uint32_t _end_static; /* Defined by the linker */
83 extern uint32_t _Heap_Limit;
84
85 static uint32_t *heap_end;
86 uint32_t *prev_heap_end;
87
88 if (heap_end == 0) {
89 heap_end = &_end_static;
90 }
91 prev_heap_end = heap_end;
92
93 #ifdef __ARM_ARCH_6M__ //If we are on a Cortex-M0/0+ MCU
94 incr = (incr + 0x3) & (0xFFFFFFFC); /* This ensure that memory chunks are
95 always multiple of 4 */
96 #endif
97 if (heap_end + incr > &_Heap_Limit) {
98 asm("BKPT");
99 }
100
101 heap_end += incr;
102 return (void*) prev_heap_end;
The _end_static and _Heap_Limit areprovidedbythelinker,andtheycorrespondtotheendof .bss
section and the highest memory address for the heap region (that is, _Heap_Limit - _end_static is
the size of the heap). We will see in a while how they are defined inside the linker script. heap_end
is a statically allocated variable, and it is used to keep track of the first free memory location inside
the heap. Since it is a static un-initialized local variable, according to Table 1 it is placed inside the
.bss section, and hence it is zeroed at run-time. So, the first time _sbrk() is called it is equal to
zero, and hence it is initialized to the value of _end_static variable. The if at line 97 ensures that
there is sufficient room in the heap memory. If not, the ARM assembly BKPT instruction is called,
causing that the debugger stops the execution¹⁶. The tricky part is represented by the instructions
at line [93:96]. The preprocessor macro checks if the ARM architecture is the ARMv6-M, that is the
architectures of Cortex-M0/0+ based processors. Those processors, in fact, do not allow unaligned
memory access. The instruction at line 95 ensures that the allocated memory is always a multiple
of 4 bytes.
We have left to analyze the linker script. The part we are interested in starts at line 51.
¹⁶ Here, we may use a different way to signal the heap overflow. For example, a global error() function could be called, and take the
appropriate actions there. However, this is often a programming style, so feel free to arrange that code at your needs.
Memory layout 554
Filename: src/ldscript5.ld
51 _end_static = _ebss;
52 _Heap_Size = 0x190;
53 _Heap_Limit = _end_static + _Heap_Size;
_end_static is nothing more than an alias to the _ebss memory location, that is the end of .bss
section. _Heap_Size is fixed by us, and it establishes the dimension of the heap (400 bytes). Finally,
_Heap_Limit contains nothing more than the final address of the heap memory.
A Note About Linker Script Symbols
In this chapter we have extensively used symbols defined in linker scripts from the C
source code. For every symbol, we have defined a corresponding extern uint32_t _symbol
variable. Every time we need to access to the content of that symbol, we use the syntax
&_symbol . This could be a source of confusion.
The way symbols are handled in linker scripts is different from that of C. In C a symbol is
a triple made of the symbol, its memory location and the value. Symbols in liker scripts are
tuple, made of the symbol and its memory location. So symbols are containers for memory
locations, as they would be pointers, without no value. So the following instruction:
extern uint32_t _symbol;
uint32_t symbol_value = _symbol;
is completely meaningless (there is no corresponding value for _symbol ).
Whilethiswayofdealingwithlinkersymbolscouldbeobviouslyifthe _symbol isamemory
location, it is a source of lot of mistakes in case it is a constant value. For example, to retrieve
the _Heap_Size value in C we have to use the following code:
unsigned int heapSize = (unsigned int)&_Heap_Size;
_Heap_Size , again contains the heap size as an address (that is 0x00000190), but it is not a
valid STM32 address. This fact can be also analyzed by inspecting the symbol table of the
final binary file, using the objdump tool with the -t command line parameter.
20.2.5 Checking the Size of Heap and Stack at Compile-Time
Microcontrollers have limited memory resources. Especially with Value-lines STM32 MCUs, it is
really common to exceed the maximum SRAM memory. We can use the linker script also to add
a sort of “static” checking about the maximum memory usage. The following linker script section
helps ensuring that we are not using too much SRAM:
Memory layout 555
_Min_Stack_Size = 0x200;
/* User_heap_stack section, used to check that there is enough RAM left */
._user_heap_stack :
{
. = ALIGN(4);
. = . + _Heap_Size;
. = . + _Min_Stack_Size;
. = ALIGN(4);
} >SRAM
With the above code, we are defining a “dummy” section inside the final binary file. Using the
location counter operator (“.”) we increment the size of this section so that it has a dimension equal
to the maximum heap size and the “estimated” minimum stack size. If the sum of .data , .bss , stack
and heap regions is greater than the SRAM size, the linker will emit an error, as shown below:
arm-none-eabi-g++ ... ./src/ch10/main-ex5.o
../../../../arm-none-eabi/bin/ld: nucleo-f401RE.elf section `._user_heap_stack' will not fit i\
n region `SRAM'
../../../../arm-none-eabi/bin/ld: region `SRAM' overflowed by 9520 bytes
collect2: error: ld returned 1 exit status
make: *** [nucleo-f401RE.elf] Error 1
It is important to underline that this is a static checking and it is not related to the activities of the
firmware at run-time. Different strategies are needed to detect a stack overflow, and it is really hard
to have a complete solution for embedded system. We will analyze this topic in Chapter 22.
20.2.6 Differences With the Tool-Chain Script Files
The linker script made so far works well for the majority of STM32 applications. However, if you
are going to code your firmware in C++, or simply using libraries made in C++, then those linker
script and starting sequences are not sufficient. To understand why, consider the following C++
application:
1 class MyClass {
2 int i;
3
4 public:
5 MyClass() {
6 i = 100;
7 }
8
9 void increment() {
10 i++;
Memory layout 556
11 }
12 };
13
14 MyClass instance;
15
16 int main() {
17 instance.increment();
18 for (;;);
19 }
Let us focus our attention on line 14. Here we are defining an instance of the class MyClass .
The instance is defined as global variable. But declaring an instance of a class assumes that the
constructorofthatclassisautomaticallycalled.So,tobeclear,whenwecallthe increment() method
at line 17, the instance attribute i will be equal to 101 . But who takes care of calling the instance
constructor? When an instance is created locally (that is, from a global function or another method),
it is up to that callable to perform class initialization. But when this happens at global scope, it is up
to other initializations routines. Usually the compiler automatically generates an array of function
pointers that will contain initializations routines for all globally and statically allocated objects.
These arrays are usually called __init_array and __fini_array (which contains the call to object
destructors).
Both the linker scripts and startup routines provided by the GNU MCU plugin and ST in its HAL
contain all necessary code to handle these and other initialization activities. Explaining them is
outside the scope of this book (this also involves analyzing in depth some libc activities performed
at startup). However, now that we know how to master the content of a linker script, it should not
be too much difficult to deal with them.
Memory layout 557
20.3 How to Use the CCM Memory
Some microcontrollers from STM32F3/4/7 families provide an additional SRAM memory named
Core Coupled Memory (CCM). Different from the regular SRAM, this memory is tightly coupled
with the Cortex-M core. A direct path connects both the D-Bus and I-Bus to this memory area (see
Figure 5¹⁷), allowing 0-wait state execution. Although it is perfectly possible to store data in this
memory, like look-up tables and initialization vectors, the best usage of this area is to store critical
and computational intensive routines, which may be executed in real-time. For this reason, MCUs
with CCM memory are said to implement routine booster technology.
Figure 5: The direct connection between the Cortex-M core and the CCM SRAM
¹⁷ The figure has been arranged from the one contained in the AN4296 from ST(http://bit.ly/1QSctkT).
Memory layout 558
Why Use CCM to Store Code Instead of Data?
It is quite common to read around on the web that the CCM memory can be used to store
critical data. This guarantees a fast access to it from the core. While this is true in theory, it
doesnotgivepracticaladvantages.AllSTM32MCUswithCCMmemoryalsoprovideSRAM
that can be addressed at maximum system clock frequency without wait states¹⁸. Moreover,
SRAM can be accessed by both CPU and DMA, while the CCM only by the Cortex core.
Instead, when code is located in CCM SRAM and data is stored in the regular SRAM, the
CortexcoreisintheoptimumHarvardconfiguration,becauseallows0-waitstatesaccessfor
theI-Bus(whichaccessestoCCM)andtheD-Bus(whichaccessesinparalleltotheSRAM)¹⁹.
However,itisclearthatifdeterministicperformancesarenotimportantforyourapplication,
and you need additional SRAM storage, then the CCM is a good reserve for data memory.
In all STM32 MCUs with this additional memory, the CCM SRAM is mapped starting from the
0x1000 0000 address²⁰. Once again, to use it we need to define this memory region inside the linker
script, in the following way²¹:
/* memory layout for an STM32F334R8 */
MEMORY
{
FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 64K
SRAM (xrw) : ORIGIN = 0x20000000, LENGTH = 12K
CCM (xrw) : ORIGIN = 0x10000000, LENGTH = 4K
}
Obviously, the LENGTH attribute has to reflect the size of the CCM memory for the specific STM32
MCU. Once the region is defined, we have to create a specific section inside the linker script:
.ccm : ALIGN(4) {
*(.ccm .ccm*)
} >CCM
TorelocateaspecificroutineinsidetheCCM memory wecanuse theGCCkeyword __attribute__ ,
as seen before for the .isr_vector section:
¹⁸ Some STM32 MCUs provide two SRAM memories, with one of these allowing 0-wait access. Always consult the datasheet for your MCU.
¹⁹ Keep in mind that to reach a full parallel access to the SRAM, no other masters (e.g. the DMA) must contend the access to the SRAM
through the BusMatrix.
²⁰ The STM32F7 provides a dedicated Tightly Coupled Memory (TCM) interface, with two separated bus that interconnect the Cortex-M7
core to flash and SRAM. The instruction ITCM-RAM is a 16 Kb read-only region accessible only by the core and mapped from the 0x0000 0000
address. The data DTCM-RAM is a 64Kb region mapped at address 0x2000 0000 and accessible by all AHB masters from AHB bus Matrix but
through a specific AHB slave bus of the CPU. Refer to the STM32F7 Reference Manual for more information.
²¹ The memory configuration refer to a Nucleo-F334 that, together with the Nucleo-F303, provides the CCM memory.
Memory layout 559
void __attribute__((section(".ccm"))) routine() {
...
}
If, instead, we want to store data inside the CCM memory, than we also need to initialize it as
we have seen for .bss and .data regions in regular SRAM memory. In this case, we need a more
articulated liker script:
/* Used by the startup to initialize data in CCM */
_siccm = LOADADDR(.ccm.data);
/* Initialized data section in CCM */
.ccm.data : ALIGN(4)
{
_sccmd = .;
*(.ccm.data .ccm.data*)
. = ALIGN(4);
_eccmd = .;
} >CCM AT>FLASH
/* Uninitialized data section in CCM */
.ccm.bss (NOLOAD) : ALIGN(4)
{
_sccmb = .;
*(ccm.bss ccm.bss*)
. = ALIGN(4);
_eccmb = .;
} >CCM
Here we are defining two sections: .ccm.data , which will be used to store global initialized data
in CCM, and .ccm.bss used to store global un-initialized data. As done for the regular SRAM, will
need to call the __initialize_data() and __initialize_bss() routines from the _start() routine:
...
__initialize_data(&_siccm, &_sccmd, &_eccmd);
__initialize_bss(&_sccmb, &_eccmb);
...
Then, to place data inside the CCM, we have to instruct the compiler using the attribute keyword:
Memory layout 560
uint8_t initdata[] __attribute__((section(".ccm.data"))) = {0x1, 0x2, 0x3, 0x4};
uint8_t uninitdata __attribute__((section(".ccm.bss")));
20.3.1 Relocating the vector table in CCM Memory
TheCCM memory can be also used to storeISR routines,relocating the wholevectortable inside the
CCMmemory.ThiscanbeespeciallyusefulforISRsthatneedtobeprocessedintheshortestpossible
time. However, relocating the vector table requires additional steps, since the Cortex-M architecture
is designed so that the vector table starts from the 0x0000 0004 address (which corresponds to the
0x0800 0004 address of the internal flash memory). The steps to follow are these ones:
• define the vector table to place in the CCM RAM using the __attribute__((section(".isr_-
vector_ccm")) keyword;
• define the exception handlers for the interested exceptions and ISRs and place them in the
corresponding section using the __attribute__((section(".ccm")) keyword;
• define a minimal vector table, composed by the MSP pointer and the address of the Reset
exception handler, to place in the flash memory starting from 0x0800 0000 address;
• relocate the vector table from the Reset exception by copying the content of the .ccm section
from the flash memory into the SRAM.
Let us start defining the vector table to place in CCM RAM. Here we are defining a file named
ccm_vector.c with the following content:
Filename: src/ccm_vector.c
1 #include <stm32f3xx_hal.h>
2
3 #define GPIOA_ODR ((uint32_t*)(GPIOA_BASE + 0x14))
4
5 extern const uint32_t _estack;
6
7 void SysTick_Handler(void);
8
9 uint32_t *ccm_vector_table[] __attribute__((section(".isr_vector_ccm"))) = {
10 (uint32_t *)&_estack, // initial stack pointer
11 (uint32_t *) 0, // Reset_Handler not relocatable
12 (uint32_t *) 0,
13 (uint32_t *) 0,
14 (uint32_t *) 0,
15 (uint32_t *) 0,
16 (uint32_t *) 0,
17 (uint32_t *) 0,
18 (uint32_t *) 0,
19 (uint32_t *) 0,
Memory layout 561
20 (uint32_t *) 0,
21 (uint32_t *) 0,
22 (uint32_t *) 0,
23 (uint32_t *) 0,
24 (uint32_t *) 0,
25 (uint32_t *) SysTick_Handler
26 };
27
28 void __attribute__((section(".ccm"))) SysTick_Handler(void) {
29 *GPIOA_ODR = *GPIOA_ODR ? 0x0 : 0x20; //Causes LD2 LED to blink
30 }
The file contains just the vector table, which is placed inside the .isr_vector_ccm section, and the
handler for the SysTick exception, which is placed inside the .ccm section. Next, we need to arrange
the linker script in the following way:
Filename: src/ldscript6.ld
75 /* Used by the startup to load ISR in CCM from FLASH */
76 _slccm = LOADADDR(.ccm);
77
78 .ccm : ALIGN(4)
79 {
80 _sccm = .;
81 *(.isr_vector_ccm)
82 *(.ccm)
83 KEEP(*(.isr_vector_ccm .ccm))
84
85 . = ALIGN(4);
86 _eccm = .;
87 } >CCM AT>FLASH
88
89 /* Size of the .ccm section */
90 _ccmsize = _eccm - _sccm;
The linker script does not contain anything different from what seen so far. The .ccm section is
defined and we instruct the linker to place in it the content of the .isr_vector_ccm section first and
thenthecontentfromthe .ccm section,whichinourcasecontainsjustthe SysTick_Handler routine.
We also instruct the linker to store the content of .ccm section inside the flash memory (using the
directive CCM AT>FLASH ), while the VMA addresses of the .ccm section are bound to the CCM range
of memory addresses (that is, the starting address is 0x1000 0000 ).
Finally,weneedtomanuallycopythecontentofthe .ccm sectionfromtheflashmemorytotheCCM
one and to relocate the vector table. This work is performed again by the Reset_Handler exception.
Memory layout 562
Filename: src/main-ex6.c
68 /* Minimal vector table */
69 uint32_t *vector_table[] __attribute__((section(".isr_vector"))) = {
70 (uint32_t *)&_estack, // initial stack pointer
71 (uint32_t *)_start // main as Reset_Handler
72 };
73
74 void __attribute__ ((noreturn,weak))
75 _start (void) {
76 /* Copy the .ccm section from the FLASH memory (_slccm) into CCM memory */
77 memcpy(&_sccm, &_slccm, (size_t)&_ccmsize);
78
79 __DMB(); //This ensures that write to memory is completed
80
81 SCB->VTOR = (uint32_t)&_sccm; /* Relocate vector table to 0x1000 0000 */
82 SYSCFG->RCR = 0xF; /* Enable write protection for CCM memory */
83
84 __DSB(); //This ensures that following instructions use the new configuration
85
86 __initialize_data(&_sidata, &_sdata, &_edata);
87 __initialize_bss(&_sbss, &_ebss);
88 main();
89
90 for(;;);
91 }
92
93 int main() {
94 /* enable clock on GPIOA peripheral */
95 *RCC_APB1ENR |= 0x1 << 17;
96 *GPIOA_MODER |= 0x400; // Sets MODER[11:10] = 0x1
97
98 SysTick_Config(4000000); //Underflows every 0.5s
99 }
100
101 void delay(uint32_t count) {
102 while(count--);
103 }
Lines [69:72] define the minimal vector table used when the CPU resets. It is just composed by the
MSP pointer and the address of the Reset_Handler exception, which is represented by the _start()
routine. When the MCU resets, we copy at line 77 the content of the .ccm section from the flash
memory (the base address is stored inside the _slccm variable) to the CCM memory, and then we
relocate the whole vector table assigning the position in CCM memory of the ccm_vector_table
array to the register VTOR in the System Control Block (SCB) - line 79. Next, we enable the write
protection on the whole CCM memory to avoid unwanted writings that may corrupt the code.
Memory layout 563
The CCM RAM is subdivided in pages of 1Kb. Every bits in the RCR register of the System
Configuration Controller (SYSCFG) is used to set the write protection on individual page
basis (bit 1 sets protection of first page, bit 2 sets protection on second page and so on). Here,
we are write-protecting the whole CCM memory of an STM32F334 MCU, which has a CCM
memory made of four 1Kb pages.
It is important to remark that, if we disable writing of the whole CCM memory, we cannot
place global or statically allocated variables in it, otherwise a fault will occur. On the other
side, placing both code and data in CCM memory makes us lose the benefits obtained by
the CCM memory, due to the simultaneous access to the same memory both by the D-Bus
and I-Bus bus (looking at Figure 5 you can se that the CCM memory is connected to just
one master port of the BusMatrix - the port M3 -; so the access from D-Bus and I-Bus is
disciplined by the BusMatrix).
The vector table relocation is not limited to the CCM memory. As we will see in Chapter
22, this technique is also used when the MCU boots from different sources than the internal
flash. In this case, the vector table is usually placed in SRAM and it has to be relocated.
The vector table relocation is a feature not available in Cortex-M0 microcontrollers, while
is available in Cortex-M0+. As we will see in Chapter 22, there exists a procedure that tries
to address this limitation.
20.4 How to Use the MPU in Cortex-M0+/3/4/7 Based
STM32 MCUs
Apart from the Cortex-M0 core, all Cortex-M based microcontrollers can optionally provide a
Memory Protection Unit (MPU). And the good news is that all STM32 MCUs based on that cores
provide it. The MPU should not be confused with the Memory Management Unit (MMU), an
advanced hardware component available in more performing microprocessors like Cortex-A, which
is mostly dedicated to the translation of virtual memory addresses in physical ones.
The MPU is used to protect up to eight memory regions, numbered from 0 to 7. These, in turn can
have eight subregions, if the main region is at least 256 bytes. The subregions have all the same
size, and can be enabled or disabled according to the subregion number. The MPU is used to make
an embedded system more robust and more secure, and in some application domains its usage is
mandatory (e.g. in automotive and aerospace). The MPU can be used to:
• Prohibit the user applications from corrupting data used by critical tasks (such as the operating
system kernel).
Memory layout 564
• Define the SRAM memory region as a non-executable to prevent code injection attacks.
• Change the memory access attributes.
If the CPU core violates the access definitions of a given memory region (for example, trying to
execute code from a non executable region), the HardFault exception (or the more specific Memory
Fault one as we will see in Chapter 24) is raised.
The MPU regions can spawn the whole 4GB address space, and they can also overlap. The region
characteristics are defined by two parameters: the region type and its attributes. There are three
memory types:
• Normal memory: allows the load and store of bytes, half-words and words²² to be arranged
by the CPU in an efficient manner (the compiler is not aware of memory region types). For
the normal memory region the load/store is not necessarily performed by the CPU in the order
listed in the program. SRAM and FLASH memories are two examples of normal memory.
• Device memory: within the device region, the loads and stores are done strictly in order. This
is to ensure the registers are set in the proper order, otherwise the device behaviour will be
impacted.
• Strongly ordered memory: everything is always done in the programmatically listed order,
where the CPU waits the end of load/store instruction execution (effective bus access) before
executing the next instruction in the program stream. This can cause a performance hit.
Table 2: Memory region attributes
Region Attribute Description
XN Execute never
AP Access permission (see Table 3)
TEX Type Extension field (not available in Cortex-M0+
S Shareable
C Cacheable
B Bufferable
SRD Subregion disable/enable
SIZE Size of the memory region
Each memory region has eight attributes, reported in Table 2:
• Executenever(XN):amemoryregionmarkedwiththisattributedoesnotallowtheexecution
of program code.
• AccessPermission(AP):definestheaccesspermissionstothememoryregion.Permissionsare
set both for privileged (e.g. the RTOS kernel) and unprivileged code (e.g. an individual thread).
Table 3 lists all possible combinations.
²² Remember that Cortex-M0/0+ cores are only able to perform word-aligned access.
Memory layout 565
• TEX, C and B: these fields are used to define cache properties for the region, and to some
extent, its shareability. They are encoded according to the Table 4. Take note that in Cortex-
M0+ cores the TEX field is always 0. This because Cortex-M0+ cores support one level of cache
policy.
• S: this fields configures a shareable memory region. The memory system provides data
synchronization between bus masters in a system with multiple bus masters, for example, a
processor with a DMA controller. Strongly-ordered memory is always shareable. If multiple
bus masters can access a non-shareable memory region, the software must ensure the data
coherency between the bus masters. This field is not supported in ARMv6-M architecture and
therefore is always set to 0 in the Cortex-M0+ processors.
• SRD: defines whether a particular subregion is enabled or disabled. Disabling a subregion
means that another region overlapping the disabled range matches instead. If no other enabled
region overlaps the disabled subregion the MPU issues a fault.
• SIZE: specifies the memory region size. The size cannot be arbitrary, but it can assume a value
from a well known pool of region sizes (it depends on the specific STM32 family).
Table 3: Access permissions to a region
Privileged access Unprivileged access Description
No access No access All accesses to the region generate a permission fault
RW No access Access from a privileged software only
RW RO Writings by an unprivileged software generate a permission
fault
RW RW Full access to the region
Unpredictable Unpredictable RESERVED
RO No access Read by a privileged software only
RO RO Read only, by privileged or unprivileged software
STM32F7 microcontrollers provide an integrated L1-cache, as we will see in the next chapter. For
these MCUs the following additional memory attributes are available:
• Cacheable/non-cacheable: means that the dedicated region can be cached or not.
• Write through with no write allocate: on hits it writes to the cache and the main memory,
on misses it updates the block in the main memory not bringing that block to the cache.
• Write-back with no write allocate: on hits it writes to the cache setting dirty bit for the
block, the main memory is not updated. On misses it updates the block in the main memory
not bringing that block to the cache.
• Write-back with write and read allocate: on hits it writes to the cache setting dirty bit for the
block, the main memory is not updated. On misses it updates the block in the main memory
and brings the block to the cache.
Memory layout 566
Table 4: Region cache properties and shareability
TEX C B Memory Type Description Shareable
000 0 0 Strongly Ordered Strongly Ordered Yes
000 0 1 Device Shared Device Yes
000 1 0 Normal Write through, no write allocate S bit dependent
000 1 1 Normal Write-back, no write allocate S bit dependent
001 0 0 Normal Non-cacheable S bit dependent
001 0 1 Reserved Reserved Reserved
001 1 0 Undefined Undefined Undefined
001 1 1 Normal Write-back, write and read allocate S bit dependent
010 0 0 Device Non-shareable device No
010 0 1 RESERVED RESERVED RESERVED
Table5lists the types and attributes of the memories found in an STM32 microcontroller.As wewill
seeinthenextchapter,theintegratedL1-cacheinSTM32F7MCUsalsoallowstodefineascacheable
regions external memories accessible through the FMC controller. This is a great performance
improvement that this families of MCUs offers.
Table 5: Memory attributes for the typical STM32 memories
Memory Memory type Memory attributes
ROM, flash (program memories) Normal memory Non-shareable, write-through C=1, B=0, TEX=0,
S=0
Internal SRAM Normal memory Shareable, write-through C=1, B=0, TEX=0, S=1/S=0
External RAM (through FMC) Normal memory Shareable, write-back C=1, B=1, TEX=0, S=1/S=0
Peripherals Device Shareable devices C=0, B=1, TEX=0, S=1/S=0
Table 6 shows a comparison of the MPU features in Cortex-M0+/3/4/7 cores. The MPU bypass is a
feature offered by the MPU to bypass access permissions to a region when the processor is running
NMI or HardFault exceptions. For example, the MPU might be used as a mechanism to detect stack
limit by allocating a small SRAM space at the bottom of the stack as non accessible. When the stack
limit is reached, the HardFault handler can bypass the MPU restriction and utilize the reserved
SRAM space for fault handling.
Table 6: Comparison of MPU features between the various Cortex-M cores
Cortex®-M0+ Cortex®-M3/M4 Cortex®-M7
Number of regions 8 8 8
Region address Yes Yes Yes
Region size 256 bytes to 4GB 32 bytes to 4GB 32 bytes to 4 GB
Region memory attributes S, C, B, XN TEX, S, C, B, XN TEX, S, C, B, XN
Region access permission Yes Yes Yes
Subregion disable Yes Yes Yes
Memory layout 567
Table 6: Comparison of MPU features between the various Cortex-M cores
Cortex®-M0+ Cortex®-M3/M4 Cortex®-M7
MPU bypass for
NMI/HardFault
Yes Yes Yes
Fault exception HardFault only HardFault/MemManage HardFault/MemManage
20.4.1 Programming the MPU With the CubeHAL
The CubeHAL provides all the necessary abstraction layer to program the MPU. The function
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init);
allows to configure a memory region. All region settings are specified with an instance of the MPU_-
Region_InitTypeDef struct , which is defined in the following way:
typedef struct {
uint8_t Enable; /* Specifies the status of the region. */
uint8_t Number; /* Specifies the number of the region to protect. */
uint32_t BaseAddress; /* Specifies the base address of the region to protect. */
uint8_t Size; /* Specifies the size of the region to protect. */
uint8_t SubRegionDisable; /* Specifies the number of the subregion protection
to disable. */
uint8_t TypeExtField; /* Specifies the TEX field level. */
uint8_t AccessPermission; /* Specifies the region access permission type. */
uint8_t DisableExec; /* Specifies the instruction access status. */
uint8_t IsShareable; /* Specifies the shareability status of the
protected region. */
uint8_t IsCacheable; /* Specifies the cacheable status of the region protected. */
uint8_t IsBufferable /* Specifies the bufferable status of the protected region. */
} MPU_Region_InitTypeDef;
Let us analyze the most relevant fields of this struct.
• Enable : specifies the status of the region, and it can assume the values MPU_REGION_ENABLE and
MPU_REGION_DISABLE .
• Number : it is the region ID and it can spawn from 0 up to 7.
• BaseAddress : corresponds to the base address of the region. In Cortex-M0+ this address must
be word-aligned.
• Size : specifies the size of the region and corresponds to all power of two from 2⁵ up to 2³². The
CubeHAL defines a set of 27 macros, ranging from MPU_REGION_SIZE_32B up to MPU_REGION_-
SIZE_4GB . Take a look at the file stm32XXxx_hal_cortex.h for the complete list.
Memory layout 568
• AccessPermission :specifiestheregionpermissionattributesanditcanassumethevalueslisted
in Table 7.
• DisableExec :specifiesifitispossibletoexecutecodeinsidetheregion.Itcanassumethevalues
MPU_INSTRUCTION_ACCESS_ENABLE and MPU_INSTRUCTION_ACCESS_DISABLE .
• IsShareable : specifies if the region has the shareable attribute, and it can assume the values
MPU_ACCESS_SHAREABLE and MPU_ACCESS_NOT_SHAREABLE .
• IsCacheable : specifies if the region has the cacheable attribute, and it can assume the values
MPU_ACCESS_CACHEABLE and MPU_ACCESS_NOT_CACHEABLE .
• IsBufferable : specifies if the region has the bufferable attribute, and it can assume the values
MPU_ACCESS_BUFFERABLE and MPU_ACCESS_NOT_BUFFERABLE .
Table 7: CuneHAL macros to define access permissions to a region
Access permission Description
MPU_REGION_NO_ACCESS All accesses to the region generate a permission fault
MPU_REGION_PRIV_RW Access from a privileged software only
MPU_REGION_PRIV_RW_URO Writings by an unprivileged software generate a permission fault
MPU_REGION_FULL_ACCESS Full access to the region
MPU_REGION_PRIV_RO Read by a privileged software only
MPU_REGION_PRIV_RO_URO Read only, by privileged or unprivileged software
TheMPUmustbedisabledbeforeconfiguringanymemoryregion(orbeforechangingitsattributes).
To perform this operation the HAL provides the function:
void HAL_MPU_Disable(void);
while to enable the MPU we use the function:
void HAL_MPU_Enable(uint32_t MPU_Control);
The MPU_Control parameter specifies the control mode of the MPU during HardFault, NMI,
FAULTMASK and privileged access to the default memory. It can assume a value from those listed
in Table 8. It is important to note that the MemFault exception is automatically enabled once the
MPU is enabled.
Table 8: CubeHAL macros to define MPU control during HardFault, NMI and FAULTMASK
Access permission Description
MPU_HFNMI_PRIVDEF_NONE The default memory map is used for privileged accesses, and it assumes the
role of a background region (also called “region -1”, where “-1” is the region
ID). The access to the whole 4GB is so prohibited by unprivileged code, except
in those regions that explicitly allow it.
MPU_HARDFAULT_NMI The MPU is disabled when HardFault and NMI exceptions raise.
Memory layout 569
Table 8: CubeHAL macros to define MPU control during HardFault, NMI and FAULTMASK
Access permission Description
MPU_PRIVILEGED_DEFAULT The background region is disabled and any access not covered by any enabled
region will cause a fault.
MPU_HFNMI_PRIVDEF The MPU is enabled when HardFault and NMI exceptions raise.
1 MPU_Region_InitTypeDef MPU_InitStruct;
2
3 /* Disable MPU */
4 HAL_MPU_Disable();
5
6 /* Configure RAM region as Region N°0, 8kB of size and R/W region */
7 MPU_InitStruct.Enable = MPU_REGION_ENABLE;
8 MPU_InitStruct.BaseAddress = 0x20000A00;
9 MPU_InitStruct.Size = MPU_REGION_SIZE_32B;
10 MPU_InitStruct.AccessPermission = MPU_REGION_PRIV_RO_URO;
11 MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
12 MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
13 MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
14 MPU_InitStruct.Number = MPU_REGION_NUMBER0;
15 MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
16 MPU_InitStruct.SubRegionDisable = 0x00;
17 MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
18 HAL_MPU_ConfigRegion(&MPU_InitStruct);
19
20 /* Defines a pointer to the first word of protected region */
21 volatile uint32_t *p = (uint32_t*)0x20000A00;
22 *p = 0xDDEEFF00;
23
24 /* Re-enable the MPU and enable the background region */
25 HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
26
27 if(*p != 0xDDEEFF00)
28 asm("BKPT #0");
29
30 *p = 0xAABBCCDD; //This will generate a MemManage fault
The previous code fragment shows how to define a memory region over the SRAM memory and to
preventaccesstoitinwritemode,bothfromprivilegedandunprivilegedcode.Theregionstartsfrom
the address 0x2000 0A00 and lasts 32 bytes. A pointer to the beginning of that region is defined (line
x)andthecontentofthefirstwordismodified(linex).TheMPUisenabledandtheregionattributes
prevent code from modify its content. The if at line x will not match, because the first region
word effectively contains the value 0xDDEEFF00 . However, the instruction at line x will generate a
MemManage fault, due to read only attribute of the region.
21. Flash Memory Management
Flash memory is a silent peripheral that we use without worrying too much about it. Once we are
sure that the flash has sufficient room to store the firmware, we upload the binary image using the
debugger or a dedicated flashing tool. And we completely forget it.
However, the internal flash provided by all STM32 microcontrollers works in the same way of other
peripherals. It can be programmed directly from the firmware by configuring specific registers,
and this allows us to upgrade the firmware using the same on-board code or to store relevant
configuration data without using dedicated external hardware (an external I²C EEPROM or an SPI
flash).
ThischaptershowshowtoprogramtheinternalSTM32flashmemoryusingthededicated HAL_FLASH
module from the CubeHAL. It describes how the flash is usually organized in a typical STM32
microcontroller, briefly illustrating the differences among each family and the steps involved to
program specific areas of this memory directly from the same microcontroller.
Finally, the role of the ART TM Accelerator is described, together with the evolutions of this ST
proprietary technology in STM32F7 microcontrollers.
21.1 Introduction to STM32 Flash Memory
Different from other embedded architectures¹, all STM32 microcontrollers provide a dedicated flash
memory to store program code and constant data. There are currently eleven memory sizes, ranging
from 16KB up to 2MB. The last digit of the part number of a given STM32 MCU defines the size of
the flash memory, as shown in Table 1. For example, an STM32F401RE MCU has 512KB of flash
memory.
Table 1: The size of the flash memory given the last digit in an STM32 part number
Last digit in P/N Flash memory size (KB)
4 16
6 32
8 64
B 128
Z 192
C 256
D 384
E 512
¹ This is especially true for Cortex-A microprocessors or FPGAs, where the non-volatile memory is provided by external flash memories
connected to the CPU through dedicated bus lines.
Flash Memory Management 571
Table 1: The size of the flash memory given the last digit in an STM32 part number
Last digit in P/N Flash memory size (KB)
F 768
G 1024
I 2048
DependingontheSTM32family,salestypeandpackagedused,theflashmemoryofanSTM32MCU
can be organized in:
• one or two banks: the majority of STM32 microcontrollers provide just one bank of flash
memory, while the most performing ones up to two banks. The multi-bank architecture allows
dual and simultaneous operations: while programming or erasing in one bank, read operations
are possible in the other one. This approach provides higher flexibility for dual operations
especially for high performance applications. In some more recent STM32 MCUs, like the latest
STM32F7, multi-bank is a programmable feature that can be optionally enabled, and the bank
sizes can be configured at need.
• each bank is in turn divided in sectors: each flash memory bank is partitioned in several
sub-blocks, called sectors. Some STM32 MCUs provide flash memory having all sectors with
the same size (usually equal to 1KB or 2KB). Some other ones provide several sectors with
different sizes (usually the first sectors have a smaller size than the remaining ones).
• each sector can be divided in pages: in some STM32 MCUs, a sector is further partitioned in
several smaller pages. Sometimes, this happens only for the fist sectors, and this allows erasing
and then programming only a fraction of the sector.
Table 2² shows how the flash memory is organized in some STM32F0 microcontrollers. As you can
see, they can provide up to seventeen sectors, each one in turn divided in four pages. Moreover,
a dedicated area, called Information Block, is mapped to another address range: this non-volatile
memory is used to store special configuration registers (named Option bytes) and some factory pre-
programmedbootloaders,whichwewillstudyinthenextChapter.InmorepowerfulSTM32MCUs,
the Information Block region also contains the One-time Programmable (OTP) memory (which can
range from 512 up to 1024 bytes): this is a non-volatile memory that can be used to store relevant
configuration parameters of the device.
Why having such memory organization? Before we can answer to this question, we need to
introduce some fundamental concepts regarding flash memory technologies. Without entering in
specific implementation details, there are two main families of flash memories: NAND and NOR.
NAND-flash memories offer a more compact physical architecture, allowing to store more memory
cell in the same silicon area. NAND memories are available in greater storage densities and at lower
costsperbitthanNOR-flash(rememberthatinelectronics,apartfromtheR&Dcosts,theproduction
cost of an IC is all about the die size). NAND memories also have up to ten times the endurance of
² The table is extracted from the ST RM0360 reference manual (http://bit.ly/1GfS3iC)
Flash Memory Management 572
NOR-flash. NAND is more fit as storage media for large files including video and audio. The USB
thumb drives, SD cards and MMC cards are of NAND type.
Table 2: Flash memory organization in F030x4, F030x6, F070x6 and F030x8 devices
NAND-flash does not provide a random-access external address bus so the data must be read
on a block-wise basis, where each block holds hundreds to thousands of bits, resembling to a
kind of sequential data access. This makes NAND-flash technology not suitable for embedded
microcontrollers, because most of the microprocessors and microcontrollers require byte-level
random access.
An important thing to know about flash memory technologies is that a write operation in any type
of flash device can only be performed on an empty or erased unit. So in most cases a write operation
must be preceded by an erase operation. While the erase operation is fairly straightforward in the
case of NAND-flash devices, in NOR-flash it is mandatory that all bytes in the target block should
be written with all zeros before they can be erased. Conversely, NOR-flash memories offer complete
Flash Memory Management 573
address and data buses to randomly access any of its memory location (addressable to every byte).
This makes them suitable for store code and constant data, because they rarely need to be updated.
NORmemoriesenduranceis10,000to100,000erasecycles.NOR-flashmemoriesareslowerinerase-
operation and write-operation compared to NAND-flash. That means the NAND-flash has faster
erase and write times. Moreover NAND has smaller erase units. So fewer erases are needed and this
makes them more suitable to store filesystems. NOR-flash can read data slightly faster than NAND.
NOR-flash devices are divided into erase units, also called blocks, pages or sectors. This division
is necessary to reduce prices and overcome physical limitations. Writing information to a specific
block can only be performed if that block is empty/erased, as said before. In the majority of NOR-
flash memories, after an erase cycle an individual cell contains the value “1”, and a write operation
allows to change its value to “0”. This means that a word memory location is set to 0xFFFF FFFF
after an erase. There exists, however, some NOR-flash memories where the cell-default value after
an erase is “0”, and we can set it to “1” with a write operation.
Partitioning the flash memory in several blocks gives us an indirect advantage: we can erase and
then reprogram only small fractions of the flash memory. This is especially useful when we use the
flash memory to store non-volatile configuration parameters, without using dedicated and external
EEPROM memories³.
To completely avoid unwanted writings in theNon Volatile Memory (NVM), the flash memory in all
STM32 MCUs is write protected, and there exists a specific unlocking sequence to follow to disable
it: two dedicated key registers are provided in the Option Bytes region, which allow to disable flash
writingprotectionbyissuingaspecificvalueinsidethem.InsomeSTM32MCUsthewriteprotection
must be individually disabled for each sector. Depending on the STM32 family, the write access is
performed by 8-, 16-, 32- or 64-bit.
To protect the intellectual property, the flash memory can be read-protected against external
access from debug interface (clearly, the read access is still permitted from the Cortex-M core and
DMA controllers). This avoids that other malicious users can save the content of flash memory to
disassemble or replicate it on counterfeit devices⁴. We will analyze this topic later.
Depending on the STM32 family, the flash memory can perform several program/erase operations
in parallel, allowing to write more bytes at once. Particular conditions must be met to carry out
program operations in parallels. Usually, a given VDD voltage is required to reach the maximum
parallelism. Always consult the reference manual of your MCU to discover more about this.
21.2 The HAL_FLASH Module
Like all other STM32 peripherals, even the flash memory provides several registers used to
manipulateitssettings,assaidbefore.The HAL_FLASH module,togetherwiththerelated HAL_FLASHEx
³ SeveralSTM32MCUsfromtheSTM32L-seriesprovideadedicatedandtrueEEPROMmemory,likeinotherlow-cost8-bitmicrocontrollers
(for example, ATMEL AVR microcontrollers).
⁴ However, keep in mind that there exists companies able to bypass read-protection using advanced hardware techniques (this usually
involves the usage of lasers that overwrite the read-protection bits inside the Option Bytes region - it is not inexpensive, but it is possible ;-) )
Flash Memory Management 574
module, allows to easily erase and reprogram the NVM memory without dealing too much with its
implementation details. The next subparagraphs introduce the most relevant functions from those
modules.
21.2.1 Flash Memory Unlocking
The flash memory is write-protected by default, to prevent accidental writings caused by electrical
disturbances or program malfunctions. To enable write mode a sequence of operations must be
performed, and this is specific of the given STM32 family. To accomplish this task, the CubeHAL
provides the function:
HAL_StatusTypeDef HAL_FLASH_Unlock(void);
whichallowsustocompletelyignorethespecificflashmemoryarchitecture.Oncetheflashmemory
write/erase protection is disabled, we can perform an erase or write operation. The reverse of the
unlock procedure is performed by using the function:
HAL_StatusTypeDef HAL_FLASH_Lock(void);
The write protection is automatically set upon a system reset. However, it is strongly suggested
to explicitly re-lock the memory when all writing operations are completed. This prevents any
accidental writing caused by firmware malfunction or power instability.
21.2.2 Flash Memory Erasing
Before we can change the content of a flash memory location we need to reset its bits to the default
value (“0” or “1” depending on the NOR-flash type). This is performed by an erase operation on
sector/page granularity. Alternatively, a mass erase of the whole bank can be performed: this means
that on those STM32 MCUs providing two banks we can mass erase each bank at a time.
In the majority of STM32 microcontrollers, the individual cells of a flash memory block (sector or
page)aresetto“1”afteraneraseoperation,withjusttwonotablyexceptions:STM32L0andSTM32L1
microcontrollers, whose default value is instead “0”.
The CubeHAL provides two ways to perform a flash erase operation: flash erasing in polling and
interrupt mode.
The function:
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit,
uint32_t *SectorError);
Flash Memory Management 575
allows to perform a flash erasing in polling mode. It accepts a pointer to an instance of the
FLASH_EraseInitTypeDef struct , that we are going to see in a while, and a pointer to variable
( SectorError ) which returns the id of faulty sectors/pages in case of error during the erasing
procedure (for example, if the erasing procedure fails on the 4th page, the SectorError parameter
will contain the value 3 ).
The FLASH_EraseInitTypeDef struct differs a lot between each STM32 family. For this reason, take
a look at the stm32XXxx_hal_flash_ex.h file of the CubeHAL for your MCU. Here, we are going
to consider the implementation found in CubeHALs for the most performing STM32 MCU like the
F2/F4/F7 ones.
typedef struct {
uint32_t TypeErase; /* Mass erase or sector Erase */
uint32_t Banks; /* Select banks to erase when Mass erase is enabled */
uint32_t Sector; /* Initial FLASH sector to erase when Mass erase is disabled */
uint32_t NbSectors; /* Number of sectors to be erased */
uint32_t VoltageRange;/* The device voltage range which defines the erase parallelism */
} FLASH_EraseInitTypeDef;
• TypeErase : specifies if we are performing a mass erase of the whole bank or a sector/page
erasing. It can assume the values FLASH_TYPEERASE_SECTORS or FLASH_TYPEERASE_MASSERASE .
• Banks : this parameter, which is available only in those STM32-series providing a multi-bank
internal flash memory, specifies the bank involved in a mass-erase. It can assume the values
FLASH_BANK_1 , FLASH_BANK_2 or FLASH_BANK_BOTH to delete both the banks.
• Sector ( Page ): this field refers to the sector id involved in a sector-based erasing. It can
assumethevalue FLASH_SECTOR_0 , FLASH_SECTOR_1 andsoon(themaximumnumberofsectors
dependsonthespecificmicrocontroller).InthoseSTM32MCUsprovidingaflashmemorywith
page granularity, this fields is replaced by the first address of the page involved in an erasing
procedure. Consult the CubeHAL source code for more about this.
• NbSectors ( NbPages ): the number of sectors (pages) that will be erased starting from the
specified Sector .
• VoltageRange : even if we are erasing a whole sector (or page), actually the erasing procedure
cycles over a subset of it (usually two bytes). More performing STM32 MCUs allows to erase
multiple bytes at once. This feature is called flash parallelism and it is related to the MCU
operatingvoltage:thehigherisVDD,themorebytesareerasedatatime⁵.Thisfieldcanassume
a value from Table 3. However, always consult the reference manual for your MCU for more
about this.
⁵ STM32L4-series provides a similar feature named fast program/erase mode. It is related to both the VDD and the clock speed. It allows
to erase/program the flash on a double word granularity. Consult the reference manual for your MCU for more about this.
Flash Memory Management 576
Table 3: Program/erase parallelism depending on the voltage range
VoltageRange Voltage range Parallelism
FLASH_VOLTAGE_RANGE_1 1.7 - 2.1 V 8 bits at a time
FLASH_VOLTAGE_RANGE_2 2.1 - 2.4 V 16 bits at a time
FLASH_VOLTAGE_RANGE_3 2.4 - 3.6 V 32 bits at a time
FLASH_VOLTAGE_RANGE_4 2.7 - 3.6 V with External VPP 64 bits at a time
The HAL_FLASHEx_Erase() is a blocking function: it will wait until the erasing procedure has been
completed. This may be a quite “long” procedure, depending on the STM32 family, the HCLK
speed, the number of sector/pages involved in the erasing and the VDD voltage in those STM32
MCU providing program/erase parallelism. To avoid blocking the firmware activities during this
procedure, the HAL provides the function:
HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit,
uint32_t *SectorError);
whichperformsanerasingprocedureininterrupt mode.Wecangetnotifiedoftheendoftheerasing
procedure by enabling the FLASH_IRQn interrupt and implementing the corresponding ISR.
Read Carefully
Specialcaremustbeplacedincaseweareerasingflashmemorylocationcontainingprogram
code, especially if we are deleting first sector/page containing thevector table (this is always
true if we are performing a mass-erase). If this the case, then we need to move the program
codeandrelocatethewholevectortableinsidetheSRAM,asshowninChapter20,otherwise
a fault will occur once the interrupt fires.
21.2.3 Flash Memory Programming
Onceasector/pageiserased,wecanproceedprogrammingitscontent.Intheory,itisperfectpossible
to directly access to a flash location to change its content⁶ writing a C code like the following one:
...
*(volatile uint16_t*)0x0800AA00 = Data;
...
However, this is basically not convenient for two main reasons. First of all, in some STM32 MCUs
preliminary operations (like setting specific registers) may be required before we can program a
flash location. Secondly, depending on the specific STM32-series and the VDD voltage range, the
number of bytes that can be simultaneous transferred to the flash may significantly differ. For these
reasons, the HAL defines the function:
⁶ Obviously, the flash must be unlocked before we can modify it.
Flash Memory Management 577
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data);
which is designed to abstract all specific implementation details. Let us analyze the function
arguments:
• TypeProgram :itindicateshowmanybytesaretransferredduringthewriteoperation,anditcan
assume the values FLASH_TYPEPROGRAM_HALFWORD , FLASH_TYPEPROGRAM_WORD and FLASH_TYPE-
PROGRAM_DOUBLEWORD . Please, take note that this parameter specifies only the amount of data
transferredusingthe HAL_FLASH_Program() function.Theeffectivenumberofbytestransferred
in a single transaction depends on the STM32 family and the parallelism degree, if available.
• Address : it is the initial memory address where start placing content.
• Data : it is the data to store inside the flash memory location (represented as a double word
variable).
Like for the erase procedure seen before, it is possible to perform a flash programming procedure in
interrupt mode by using the function:
HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram,
uint32_t Address, uint64_t Data);
21.2.4 Flash Read Access During Programming and Erasing
A read access to the flash memory while an erase or write operation is ongoingwill cause a bus stall,
at least in the majority of STM32 microcontrollers⁷. This means that if you need to carry out other
operationsinparallel,youneedtorelocateinSRAMcodetobeexecutedduringaflashprogramming
operation. A typical scenario is represented by a custom bootloader: we may program our code so
that we exchange the new firmware to flash using the UART in interrupt or DMA mode. If this the
case, we cannot lose asynchronous events (for example, an interrupt that notifies us a data transfer)
because the MCU is stalled waiting for the ongoing operation. If so, it is best to relocate the code in
SRAM (and eventually to relocate the vector table too).
21.3 Option Bytes
Option bytes are two or more bytes whose bits are special configuration values. The concept of
option bytes is similar to the one found in other microcontroller architectures, like the fuses in the
AVR series from Atmel or the Configuration Bits found in PIC microcontrollers from Microchip.
Each individual bit of these special bytes in the Information Block region has a special meaning.
The number and type of configuration parameters depend on the specific STM32 MCU. The most
common configuration parameters are related to:
⁷ In some STM32 MCUs, like the STM32L0-series, a bus fault may occur if we try to access the flash memory while a half-page program
operation is ongoing. For more information, consult the reference manual for the MCU you are considering.
Flash Memory Management 578
• BOOT: in the majority of STM32 microcontrollers two option bits allow to select the boot
origin (FLASH, System memory or SRAM).
• RDP: these bits set the flash memory read-protection level, and we will analyze them more in
depth later in this chapter.
• BOR_LEVEL: these bits contain the supply level threshold that activates/releases the reset.
They can be written to program a new BOR level. By default, BOR is off. When the supply
voltage (VDD) drops below the selected BOR level, a device reset is generated.
• MCU behaviour when entering in some low-power modes: in almost all STM32 microcon-
trollers it is possible to configure the MCU so that it generates a reset when entering in stop or
sleep low-power modes.
• Hardware watchdog: in some STM32 MCUs, there exist one or two bits used to configure the
WWDG and IWDG in “hardware mode”, that is they are automatically started upon a MCU
reset.
• Flashwriteprotection:thesebitsallowtoindividuallywrite-protectsomeflashsectors/pages,
preventing from writing into them even if the flash memory is unlocked. If a given bit is set
to ‘1’, the corresponding sector/page is not write-protected; if, instead, the bit is set to ‘0’, then
the sector/page is write-protected.
To program the option bytes there is a specific procedure to follow, which is independent from the
programming of the whole flash memory. So, the CubeHAL provides dedicated routines to use.
First of all, this region must be unlocked by calling the function:
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void);
Next, a give option byte is programmed entirely by using the function:
HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit);
The value of an option byte is automatically modified by first erasing the information block and
then programming all the option bytes with the values passed to the HAL_FLASHEx_OBProgram()
routine. The function accepts an instance of the C struct FLASH_OBProgramInitTypeDef , whose
fields represent the content of the given option byte. For more information about the exact type and
number of fields consult the source code of the CubeHAL.
Similarly, to retrieve the content of a given option byte we use the function:
void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);
Once an option byte is modified, we have to force the MCU to reload its content by using the
function:
Flash Memory Management 579
HAL_StatusTypeDef HAL_FLASH_OB_Launch(void);
Please take note that changing some option bits in particular STM32 MCUs may cause a reset of the
chip.
Finally, the ST-LINK debugger and the related STM32CubeProgrammer provide the ability to easily
modify the option bytes. Once you have connected the ST-LINK debugger to the target MCU, click
on the Option bytes icon (the third green icon on the left). The Option bytes section appears,
as shown in Figure 1. The same STM32CubeProgrammer tool also allows to erase selected flash
sectors/pages.
Figure 1: The Option Bytes configuration dialog in the STM32CubeProgrammer
21.3.1 Flash Memory Read Protection
Read Carefully
Some procedures described in this paragraph may brick your microcontroller preventing
you from flashing and erasing it forever. Read carefully the content of this paragraph and
avoid performing operations if they are not totally clear.
One option byte (called RDP) deserves a separated paragraph: the configuration byte related to the
flash read protection. To avoid unwanted access to the flash memory through the debug interface it
is possible to temporarily or permanently disable the read access to this memory from the external
world (clearly, the access from the CPU core and the DMA controllers is always possible). There
exist three protection levels, which correspond to three different values to store in the option byte:
Flash Memory Management 580
• Level 0 (no read protection): when the read protection level is set to Level 0 by writing 0xAA
into the read protection option byte (RDP), all read/write operations (if no write protection
is set) from/to the flash memory or the backup SRAM are possible in all boot configurations
(flash user boot, debug or boot from RAM).
• Level 1 (read protection enabled): it is the default read protection level after option bytes
erase (which is automatically performed by the HAL_FLASHEx_OBProgram() routine). The read
protection Level 1 is activated by writing any value (except for 0xAA and 0xCC used to set
Level 0 and Level 2, respectively) into the RDP option byte. When the read protection Level
1 is set, no access (read, erase, program) to flash memory or backup SRAM can be performed
while the debugger is connected or while booting from RAM or system memory bootloader.
A bus error is generated in case of read request. Instead, when booting from flash memory,
accesses(read,erase,program)toflashmemoryandbackupSRAMfromusercodeareallowed.
When Level 1 is active, programming the protection option byte (RDP) to Level 0 causes the
flashmemoryandthebackupSRAMtobemass-erased.Asaresulttheusercodeareaiscleared
before the read protection is removed. The mass erase only erases the user code area. The
other option bytes including write protections remain unchanged from before the mass-erase
operation. The OTP area is not affected by mass erase and remains unchanged. Mass erase
is performed only when Level 1 is active and Level 0 requested. When the protection level is
increased (0->1, 1->2, 0->2) there is no mass erase.
• Level 2 (!!!debug/chip read protection permanently disabled!!!): the read protection Level 2
is activated by writing 0xCC to the RDP option byte. When the read protection Level 2 is set:
– All protections provided by Level 1 are active.
– Booting from RAM is no more allowed.
– Booting system memory bootloader is possible and all the commands are not accessible
except Get, GetID and GetVersion. Refer to AN2606.
– JTAG, SWV (single-wire viewer), ETM, and boundary scan are disabled.
– User option bytes can no longer be changed.
– When booting from Flash memory, accesses (read, erase and program) to Flash memory
and backup SRAM from user code are allowed.
Memory read protection Level 2 is an irreversible operation. When Level 2 is
activated, the level of protection cannot be decreased to Level 0 or Level 1. Just to
clarify once again, this means that you will be no longer able to flash and debug your
MCU.
Table4summarizestheeffectsofagivenprotectionlevelontheflashmemory,optionbytesandOTP
memory, when these memories are accessed by the debugger interface, one of the pre-programmed
bootloaders,codeplacedinSRAMandinflashmemory.Asyoucansee,theLevel2doesnotprevent
user code from writing into flash memory (for example, a custom bootloader is still able to program
the MCU).
Flash Memory Management 581
Table 4: The effects of read protection levels on the individual NVM memories
21.4 Optional OTP and True-EEPROM Memories
More recent and powerful STM32 microcontrollers provide an One-Time Programmable (OTP)
memory. This is a dedicated memory with a size ranging from 512 up to 1024 bytes with an unique
characteristic: once a bit of this memory turns from 1 to 0 is no longer possible to restore it to 1.
This means that this region is not erasable. This memory area is especially useful to store relevant
configuration parameters connected with the given device, such as serial numbers, MAC address,
calibration values and so on. A typical practice in the electronics industry is to produce devices
with different functionalities starting from the same PCB or even the same complete board. This
area could be also used to store configuration parameters employed by the firmware to adapt board
features.
The OTP area is divided into N OTP data blocks of 32 bytes and one lock OTP block of N bytes. The
OTP data and lock blocks cannot be erased. The lock block contains N bytes LOCKB i (0 ≤ i ≤ N-1)
to lock the corresponding OTP data block (blocks 0 to N). Each OTP data block can be programmed
until the value 0x00 is programmed in the corresponding OTP lock byte (clearly an individual bit
already set to 0 cannot be restored to 1). The lock bytes must only contain 0x00 and 0xFF values,
otherwise the OTP bytes might not be taken into account correctly.
Flash Memory Management 582
Table 5: The organization of the OTP memory in an STM32F401RE MCU
Table 5 shows the organization of the OTP memory in an STM32F401RE MCU, and it is extracted
from the related reference manual. As you can see, this MCU provides 16 OTP data blocks, with a
total of 512 bytes. Sixteen lock bytes allow to lock the corresponding OTP data block.
Another common practice in digital electronics is to use dedicated and often external EEPROM
memories to store configuration parameters. EEPROM memories have several benefits compared to
the flash ones:
• Their blocks can be individually erased.
• Each block can be erased up to and even more than 1.000.000 times (flash erase cycles is limited
to 100.000 cycles).
• The rated lifetime is usually higher than flash memories.
• They are usually cheap than flash (NOR and NAND) memories.
• There exist EEPROM memories able to operate up to 200°C.
However, the main drawback of EEPROM memories is that they are usually much slower than flash
memories and occupy additional space on PCB.
If your design is all about reducing the BOM cost, then ST provides several application notes that
describe how to emulate an EEPROM memory using the STM32 integrated flash memory (this
application note are titled “EEPROM emulation in STM32Fxx microcontrollers”). Finally, several
MCUs from the STM32L-series provide an integrated true-EEPROM. For more information, consult
the datasheet of your MCU.
21.5 Flash Read Latency and the ART™ Accelerator
In Chapter 1 we have seen that Cortex-M cores provide an n-stage⁸ instruction pipeline designed
to boost the program execution. However, that pipeline has to be filled with machine instructions
⁸ The exact number of pipeline stages depend on the specific Cortex-M core.
Flash Memory Management 583
normally stored inside the flash memory. This operation is a substantial bottleneck, because flash
memories are slower if compared to the CPU clock speed.
If both the CPU and the flash memory run at the same speed, the CPU can feed its internal pipeline
without any penalty⁹. For example, an STM32F401RE MCU running at a clock speed lower than
30MHz can access to the flash memory without delays. Unfortunately, in more performing MCUs
it is required to interleave two successive accesses to the flash memory with one or more (in some
cases even up to ten) delays, called wait states. Wait states correspond to hardware “busy waits”
performed in one or more CPU cycles, and they are a way to synchronize the CPU with the slower
flashmemory.WaitstatesdramaticallyreducetheeffectiveperformancesoftheCPU.Thislimitation
is usually addressed by using dedicated cache memories.
Configuring the exact number of needed wait states is a critical step that depends on the specific
STM32 MCU you are considering. This operation is usually performed during the SYSCLK config-
uration, because the higher the CPU frequency is the more wait states are needed. Configuring the
correct number of wait states is critical especially when we are increasing the CPU speed: we have
to setup the right number of wait states before we increase the CPU speed, otherwise a BusFault
is generated. However, CubeMX is designed to abstract these details, and it generates the right
configuration code depending on the specific STM32 MCU and the wanted core speed (take a look
at the code inside the SystemClock_Config() routine).
Figure 2: The main blocks forming the ART TM Accelerator
ST has developed a distinctive technology available in its more powerful STM32 microcontrollers:
the ART TM Accelerator. The ART TM Accelerator is a pool of cache technologies (see Figure 2),
external to Cortex-M core, which can zero the effects of wait states. The ART TM Accelerator is
designed so that it preservers the Harvard architecture of Cortex-M microcontrollers, providing
separated cache pools for the I-Bus and the D-Bus.
The ART TM Accelerator is composed by:
• an instruction prefetch buffer;
⁹ Talking about “speed” in this context is improper, because we should talk about the “latency” needed to perform a machine operation.
This latency is essentially formed by the time needed by the CPU to decode and execute a machine instruction, plus the time needed by the
flash controller to retrieve the given instruction from the NVM memory. However, here we are interested to the fact that these two “devices”
(the CPU and the flash memory with its controller) may need different amount of time to carry out their activities.
Flash Memory Management 584
• a dedicated instruction cache to reduce the effects of branching;
• a data cache for literal pools;
• a scheduling policy of the AHB bus that facilitates the access of the CPU to the flash controller
through the D-Bus bus.
Let us analyze the exact role of these technologies.
The Instruction Prefetch Buffer
When the CPU accesses to the flash memory, it does not fetch one byte at a time, but it usually
reads from 64 up to 256 bits at a time depending on the specific STM32 MCU. These bits contains a
variable number of instructions and for this reason they are called instruction lines: assuming that
the CPU reads 128 bits (this is what happens in STM32F4 MCUs), this may contain four 32-bit wide
instructions or eight 16-bit wide instructions (it depends if the CPU is running in thumb mode or
not). So, in case of sequential code, at least four CPU cycles are needed to execute the previous read
instruction line. Prefetch on the I-Bus bus can be used to read the next sequential instruction line
fromtheflashmemorywhilethecurrentinstructionlineisbeingrequestedbytheCPU.Thisfeature
is useful if at least one wait state is needed to access the flash memory.
Instruction prefetch buffer can be enabled by setting the PREFETCH_ENABLE macro to 1 inside the
stm32xxxx_hal_conf.h file.
The Instruction Cache Memory
Thecontentoftheprefetchbuffercanbeinvalidedduebranching.Tolimitthetimelostduetojumps,
it is possible to retain a given number of instruction lines in an instruction cache memory. Each time
a miss occurs (requested data not present in the currently used instruction line, in the prefetched
instructionlineorintheinstructioncachememory),thelinereadiscopiedintotheinstructioncache
memory. If the CPU requests data contained in the instruction cache memory, it is provided without
inserting any delay. Once all the “empty” instruction cache memory lines have been filled, a Least
Recently Used (LRU) policy is used to determine the line to replace in the instruction memory cache.
This feature is particularly useful in case of code containing loops.
This feature can be enabled by setting the INSTRUCTION_CACHE_ENABLE macro to 1 inside the
stm32xxxx_hal_conf.h file, for those MCU providing the ART TM Accelerator. Data Cache Memory
Assembly instructions often move data between memory locations and CPU registers. Sometimes,
this data is stored inside the flash memory (they are constant values): in this case, we talk about
literalpools.LiteralpoolsarefetchedfromflashmemorythroughtheD-Busbusduringtheexecution
stage of the CPU pipeline. The CPU pipeline is consequently stalled until the requested literal pool
is provided. To limit the time lost due to literal pools, accesses through the AHB data-bus D-Bus
have priority over accesses through the AHB instruction bus I-Bus (this is indeed a bus-arbitration
policy over the D-Bus bus).
Moreover, a dedicated data cache memory exists between the D-Bus bus and the flash memory.
This cache is smaller than the instruction cache, but it helps increasing the overall performances
of the CPU. This feature can be enabled by setting the DATA_CACHE_ENABLE macro to 1 inside the
stm32xxxx_hal_conf.h file, for those MCU providing the ART TM Accelerator.
Flash Memory Management 585
21.5.1 The Role of the TCM Memories in STM32F7 MCUs
The memory organization of more recent and powerful STM32F7 MCUs deserves a separate
mention. In fact, this family of microcontrollers faces a more complex and flexible memory and
bus organization, offering two distinct interfaces to access flash and SRAM memories: theAdvanced
eXtensibleInterface (AXI),whichisanARMbusspecificationthatinterconnectstheCPUcoretothe
other peripherals; the Tightly-Coupled Memory (TCM) interface which interconnects the CPU core
to volatile and non-volatile memories directly coupled with it. Both the interfaces, AXI and TCM,
face a Harvard architecture, providing separated lines for instructions (I-Bus) and data (D-Bus).
Looking at Figure 3¹⁰, you can see that the Cortex-M7 core has three distinct paths to access the
flash controller (and so the flash memory). Before we describe these three paths, it is important to
note a fundamental thing: the Cortex-M7 core already provides an integrated L1-cache. This cache
has two dedicated cache pools, each one 64KB wide, one dedicated to the I-Bus and one for the
D-Bus: this differs from other STM32 families, where data and instruction caches are implemented
exclusively inside the ART TM Accelerator.
Figure 3: How the flash memory is accessed in an STM32F7 MCU
In all STM32F7 MCUs, flash memory is accessible through three main interfaces for read and/or
write accesses: * A 64-bit ITCM interface: it connects the embedded flash memory to the Cortex-
M7 via the ITCM bus (Path 1 in Figure 3) and it is used for the program execution and data read
access for literal values. The write access to the flash memory is not permitted via this bus.
The flash memory is accessible by the CPU through ITCM starting from the address 0x0020 0000 .
Being the embedded flash memory slower than the CPU core, the ART TM Accelerator allows 0-
wait execution from the flash memory at a CPU frequency up to 216MHz. The STM32F7 ART TM
Accelerator is available only for a flash memory access on the ITCM interface. It implements an
unified instruction and branch cache of 256 bits x 64 lines in the STM32F74xxx and STM32F75xxx
and 128/256 bits x 64 lines in the STM32F76xxx and STM32F77xxx devices following the bank
¹⁰ The figure is taken from the AN4667 from ST(http://bit.ly/29gmp61).
Flash Memory Management 586
mode selected¹¹. The ART TM Accelerator is available for both the instruction and data access, which
increases the execution speed of sequential code and loops. The ART TM Accelerator implements also
an instruction prefetch buffer. * A 64-bit AHB interface: it connects the embedded flash memory to
the Cortex-M7 via the AXI/AHB bridge (Path 2 in Figure 3). It is used for the code execution, read
and write accesses. The flash memory is accessible by the CPU through AXI/AHB bridge starting
from the address 0x0800 0000 and it is cacheable (that is, it can use the L1-cache) reaching the
same 0-wait performances of the ART TM Accelerator. The L1-cache in Cortex-M7 cores can range
from 4KB to 16KB. STM32F74xxx and STM32F75xxx MCUs provide two cache pools, one for the
instructions (I-Bus) and one for the literal pools (D-Bus), each one 4KB wide. Instead, STM32F76xxx
andSTM32F77xxxMCUsprovidetwocachepoolseachone16KBwide.TheL1-cachesonallCortex-
M7 cores are divided into lines of 32 bytes. Each line is tagged with an address. The data cache is
4-way set associative (four lines per set) and the instruction cache is 2-way set associative. This
is a hardware compromise to keep from having to tag each line with an address. * A 32-bit AHB
interface: it is used for DMAs transfers from the flash memory (Path 3 in Figure 3). The DMAs
flash memory access is performed starting from the address 0x0800 0000 .
A fourth path exists (see Figure 3) through the Advanced Bus Peripheral (AHBP) interface, and it is
reserved to the access to flash peripheral registers inside the 0x4000 0000 peripheral mapped region.
Figure 4: The bus matrix in an STM32F7 MCU
What is the advantage of this apparently complex architecture? If both the flash interfaces, that is
¹¹ STM32F76xxx and STM32F77xxx microcontrollers provide a dual-bank architecture that is highly customizable: the MCU can be
configured to work in dual-bank mode (two banks each one equal to 512/1024KB) or in single-bank mode (one bank equal to 1024/2048KB). In
the first case, the cache in the ART TM Accelerator is split in two, each one made of 128 bits x 64 lines. If a single-bank mode is used, the cache
pool is unique and made of 256 bits x 64 lines.
Flash Memory Management 587
the AXI/AHB and the ITCM, provide 0-wait execution (one thanks to internal L1-cache and one
thanks to the ART TM Accelerator), why we should deal with this complexity during the firmware
design?
The answer comes from the bus-matrix architecture of an STM32F7 MCU, which is shown inFigure
4¹². As you can see, the AXI/AHB bus is connected to the internal L1-cache thanks to the AXIM
interface. This means that accesses to some peripherals on the bus are cacheable. And this is the
case of the FMC and QuadSPI controllers. Thanks to this architecture, it is possible to use external
NVM memories to store data or program code, taking advantage of the 64K L1-cache, while having
parallelaccess(withoutthebusarbitration)totheinternalflashmemorythroughtheITCMinterface
and the ART TM Accelerator. This is a great performance boost for devices that make use of a lot of
memory to store images, videos and multimedia content in general, but also of large constant data
table, like FFT IV.
The CMSIS layer for Cortex-M7 based MCUs defines a dedicated set of routines to manipulate
Cortex-M7 L1-cache memory (see Table 6).
Table 6: CMSIS functions to manipulate Cortex-M7 L1-caches
CMSIS-F7 Function Description
void SCB_EnableICache(void) Invalidate and then enable the instruction cache
void SCB_DisableICache(void) Disable the instruction cache and invalidate its contents
void SCB_InvalidateICache(void) Invalidate the instruction cache
void SCB_EnableDCache(void) Invalidate and then enable the data cache
void SCB_DisableDCache(void) Disable the data cache and then clean and invalidate its
contents
void SCB_InvalidateDCache(void) Invalidate the data cache
void SCB_CleanDCache(void) Clean the data cache
void SCB_CleanInvalidateDCache(void) Clean and invalidate the data cache
¹² The figure is taken from the AN4667 from ST(http://bit.ly/29gmp61).
Flash Memory Management 588
Figure 1: The four SRAM memories available in STM32F7 microcontrollers
Looking at Figure 5¹³, there is another important thing to note. As you can see, STM32F7
microcontrollers offer four distinct SRAM memories, accessible through three separated paths:
• The instruction RAM (ITCM-RAM), mapped at the address 0x0000 0000 and accessible only
by the core, that is, through Path 1 in Figure 5. It is accessible by bytes, half-words (16 bits),
words (32 bits) or double words (64 bits). The ITCM-RAM can be accessed at a maximum CPU
clock speed without latency. The ITCM-RAM is protected from a bus contention since only the
CPU can access to this RAM region. The ITCM-RAM plays the same role of the CCM memory
in other STM32 MCUs.
• The data RAM (DTCM-RAM), mapped on the TCM interface at the address 0x2000 0000 and
accessible by all AHB masters from the AHB bus Matrix: by the CPU through the DTCM
bus (Path 5 in Figure 5) and by DMAs through the specific AHBS “bridge” in the Cortex-
M7 core (Path 6 in Figure 5). It is accessible by bytes, half-words (16 bits), words (32 bits) or
double words (64 bits). The DTCM-RAM is accessible at a maximum CPU clock speed without
latency. The concurrent accesses to the DTCM-RAM by the masters (core and DMAs) and
their priorities can be handled by the slave control register of the Cortex-M7 core ( CM7_AHBSCR
register). A higher priority can be given to the CPU to access the DTCM-RAM versus the other
masters (DMAs). For more details of this register, please refer to “ARM Cortex-M7 processor
Technical Reference Manual”.
¹³ The figure is taken from the AN4667 from ST(http://bit.ly/29gmp61).
Flash Memory Management 589
• The SRAM1, accessible by all the AHB masters from the AHB bus Matrix, that is, all general
purpose DMAs as well as dedicated DMAs. The SRAM1 is accessible by bytes, half-words (16
bits) or words (32 bits). Refer to Figure 5 (Path 7) for possible SRAM1 accesses. It can be used
for the data load/store as well as the code execution (even if it does not offer any specific
performance boost).
• The SRAM2, accessible by all the AHB masters from the AHB bus matrix. All the general
purpose DMAs as well as the dedicated DMAs can access to this memory region. The SRAM2
is accessible by bytes, half-words (16 bits) or words (32 bits). Refer to Figure 5 (Path 8) for
possible SRAM2 accesses. It can be used for the data load/store as well as the code execution
(even if it does not offer any specific performance boost).
Figure 6: FMC and QuadSPI external memory controllers
InadditiontotheinternalflashandSRAMmemories,STM32F7memorypoolscanbeextendedusing
the Flexible Memory Controller (FMC) and the Quad-SPI controller. Figure 6¹⁴ shows the paths that
connect the CPU with these external memories via the AXI bus. As shown in Figure 6, the external
memories can benefit of the Cortex-M7 L1-cache, reaching the maximum of the performances both
while loading/storing data or during the code execution. The Cortex-M7 L1-cache offers a great
performance improvement to STM32F7 microcontrollers compared to the STM32F4 with the same
external memory controllers.
Table 7 summarizes the memory types, both internal and external to the MCU, available in
STM32F74xxx/STM32F75xxx MCUs. The table shows the size of these memories, how they are
mapped and the bus interface used to access them. For example, you can see that the address
range 0x0020 0000 - 0x002F FFFF allows to access to the internal flash memory through the ITCM
interface, which is cacheable thanks to the ART accelerator.Table 8 summarizes the same memories
for the STM32F76xxx/STM32F77xxx MCUs (the FMC and QSPI characteristics are the same and so
they are not listed in Table 8).
For more information about these topics, it is strongly suggested to have a look at the AN4667 from
¹⁴ The figure is taken from the AN4667 from ST(http://bit.ly/29gmp61).
Flash Memory Management 590
ST¹⁵.
Table 7: Memory mapping and sizes in STM32F74xxx/STM32F75xxx MCUs
Table 8: Memory mapping and sizes in STM32F76xxx/STM32F77xxx MCUs
21.5.1.1 How to Access Flash Memory Through the TCM Interface
A common question to all novices of the STM32F7 platform is how to take advantage of the TCM
interface. This is clearly a linker script job, which has to remap the addresses of .text , .bss and
.data regions using as base addresses the ones reported in Tables 7 and 8.
However, this operation cannot be easily performed by changing the starting address of the FLASH
region inside the linker script. This because, as said before, the access in write-mode through the
¹⁵ http://bit.ly/29gmp61
Flash Memory Management 591
ITCM interface is not permitted. This means that OpenOCD, or any equivalent debugger, would not
be able to load the program code using the address range 0x0020 0000 - 0x002F FFFF . To address
this limitation, we need to separate the VMA address range from the LMA one, in the same way
we have done for the .data region. For example, the following linker script fragment shows how to
perform this operation.
1 /* Specify the memory areas */
2 MEMORY {
3 ITCM_FLASH (rx): ORIGIN = 0x00200000, LENGTH = 1024K
4 AXI_FLASH (rx): ORIGIN = 0x08000000, LENGTH = 1024K
5 RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 320K
6 }
7
8 /* Define output sections */
9 SECTIONS
10 {
11 /* The startup code goes first into FLASH */
12 .isr_vector :
13 {
14 . = ALIGN(4);
15 KEEP(*(.isr_vector)) /* Startup code */
16 . = ALIGN(4);
17 } >ITCM_FLASH AT>AXI_FLASH
18
19 /* The program code and other data goes into FLASH */
20 .text :
21 {
22 . = ALIGN(4);
23 *(.text) /* .text sections (code) */
24 *(.text*) /* .text* sections (code) */
25
26 KEEP (*(.init))
27 KEEP (*(.fini))
28
29 . = ALIGN(4);
30 _etext = .; /* define a global symbols at end of code */
31 } >ITCM_FLASH AT>AXI_FLASH
32
33 /* Constant data goes into FLASH */
34 .rodata :
35 {
36 . = ALIGN(4);
37 *(.rodata) /* .rodata sections (constants, strings, etc.) */
38 *(.rodata*) /* .rodata* sections (constants, strings, etc.) */
39 . = ALIGN(4);
40 } >ITCM_FLASH AT>AXI_FLASH
Flash Memory Management 592
Asyoucansee(lookat lines17,31and40), theVMAaddressrange(that istheaddressrangeusedby
the CPU to fetch program code) is mapped to the ITCM-FLASH interface, while the LMA address
range (that is the address range used to store the program in flash memory) is mapped to the AXI
interface, which allows to access to flash memory in write-mode.
21.5.1.2 Using CubeMX to Configure Flash Memory Interface
CubeMX simplifies the configuration of the bus used to access flash memory (TCM/AXI), of the
ART TM Accelerator and Cortex-M7 L1-cache. Going into Configuration section and then clicking
on the Cortex-M7 button it is possible to configure these parameters, as shown in Figure 7.
Figure 7: The Cortex-M7 configuration view in CubeMX
Please, take note that at the time of writing this chapter (August 2016) the generated linker
script is wrong, because it does not specify distinct LMA and VMA addresses, as shown in
the previous paragraph.
22. Booting Process
In Chapter 20 we have seen that the handler of the Reset exception corresponds to the first routine
to be executed when the CPU starts. The fixed memory layout model of Cortex-M based processors
establishes that the address in memory ofReset exception handler is placed just after theMain Stack
Pointer (MSP), that is at the address 0x0000 0004 . This memory location usually corresponds to the
beginning of flash memory. However, silicon vendors can bypass this limitation by “aliasing” other
memories to the 0x0000 0000 address with an operation called physical remapping. This operation
is performed in hardware after few clock cycles, and it is different from the vector table relocation
seen in Chapter 20, which is performed by the same code running on the MCU.
Moreover, the STM32 platform provides a factory pre-programmed boot loader, which can be used
to load the firmware inside the flash memory from several sources. Depending on the STM32 family
and sales type used, an STM32 MCU can load the code using USART, USB, CAN, I²C and SPI
communication peripherals. The bootloader is selected thanks to specific boot pins.
This chapter completes the Chapter 20 by showing the booting process performed by STM32
microcontrollers after a system reset. It gives a detailed description of the steps involved during
the bootstrap and it briefly shows how to use the factory pre-programmed bootloader in all STM32
MCUs. Finally, a custom bootloader is also shown, which allows to upgrade the on-board firmware
using the USART interface and a custom upload procedure.
22.1 The Cortex-M Unified Memory Layout and the
Booting Process
Different from more advanced microprocessor architectures, like the ARM Cortex-A, Cortex-M
microcontrollers do not provide a Memory Management Unit (MMU), which allows to alias logical
addresses to actual physical addresses. This means that, from the Cortex-M core point of view, the
memory map is fixed and standardized among all implementations.
In Cortex-M based microcontrollers, the code area starts from the 0x0000 0000 address (accessed
through the I-Bus/D-Bus¹ buses in Cortex-M3/4/7 and through the S-Bus in Cortex-M0/0+) while
thedataarea(SRAM)startsfromaddress 0x2000 0000 (accessedthroughtheS-Bus).Cortex-MCPUs
always fetch the vector table from the I-Bus, which implies that they only boot from the code area
(which typically correspond to flash memory).
STM32 microcontrollers implement a special mechanism, called physical remap, to boot from other
memories than the flash, which consists in sampling two dedicated MCU pins, called BOOT0 and
¹ For more information about these buses, refer to the Chapter 9.
Booting Process 594
BOOT1².Theelectricalstatusofthesepinsestablishesthebootstartingaddress,andhencethesource
memory.
Table 1: The boot modes available in an STM32F401RE MCU
Table 1 shows the boot modes available in an STM32F401RE MCU, and it is extracted from the
relative reference manual. The ‘ x ’ inside the BOOT1 column means that, when the BOOT0 pin is
tied to the ground, the BOOT1 pin logical state can be arbitrary. The first row corresponds to the
most common booting mode: the MCU will alias the flash memory to the address 0x0000 0000 . The
other two boot modes correspond to booting from the internal SRAM and the System Memory, a
ROM memory containing a special bootloader in all STM32 MCUs and that we will study later.
The status of the BOOT pins is latched on the 4th rising edge of SYSCLK after a reset. It is up to the
user to set BOOT pins after a reset to select the required boot mode. BOOT pins are also resampled
when exiting the standby low-power mode. Consequently, they must be kept in the wanted boot
mode configuration when entering in standby mode. Once this startup time is elapsed, the CPU
fetches the Main Stack Pointer (MSP) from the address 0x0000 0000 , and so starts code execution
from the boot memory starting from the 0x0000 0004 address. The selected memory (flash, SRAM
or ROM) is always accessible with its original address space.
If we configure the MCU to boot from the SRAM memory, which is a volatile memory, we have to
upload the program code inside this memory and ensure that a valid vector table (made of at least
a pointer to the base stack and a pointer to the Reset exception) is properly set at the 0x0000 0000
address. This requires that we use a debugger tool, which pre-loads all the necessary code inside the
SRAM before starting the execution. Moreover, a custom linker script is also needed. We will see a
complete example later.
22.1.1 Software Physical Remap
Once the MCU boots up, that is the Reset exception is being executed, it is still possible to remap the
memory accessible through the code area (that is through I-Bus and D-Bus lines) by programming
some bits of the SYSCFG memory mapped register ( SYSCFG->MEMRMP in the CMSIS library).
Depending on the specific STM32 MCU, the following memories can be remapped:
² Depending on the package used, in some STM32 MCUs the BOOT1 pin is absent and it is replaced by a special bit, called nBOOT1, inside
the option bytes region. Consult the reference manual for your MCU for more about this. In some other STM32 families, like the STM32F7, the
functionality of the BOOT1 pin is completely replaced by two dedicated option bytes. Finally, in those MCUs providing two boot pins, BOOT0
is most of the times a dedicated pin used exclusively to select boot origin, while BOOT1 is shared with a GPIO pin. Once BOOT1 has been
sampled, the corresponding GPIO pin is freed and can be used for other purposes. However, there exist exceptions in those MCUs with less
than 36 pins where even BOOT0 pin is treated as input GPIO once sampled during the first clock cycles (for example, the STM32L011K4T is
one of these).
Booting Process 595
• Internal flash memory
• System Memory
• Internal SRAM
• FMC NVM bank1
• FMC SDRAM bank 1
The last two memories are available only in those MCUs providing the Flexible Memory Controller
(FMC), a peripheral that allows to interface external NVM and SDRAM memories. According to
Table1,directbootfromexternalNORaswellasSDRAMmemoriesisnotallowed.Thesememories
can only be mapped at the 0x0000 0000 address using software physical remap after that the MCU
is already started with a minimal firmware loaded from the internal flash memory.
Once an external memory has been physical remapped at the address 0x0000 0000 , the CPU
can access it via the I-Bus and D-Bus lines, instead of the crowded S-Bus, boosting the overall
performances. This is especially important for Cortex-M7 based MCU, where those lines are tightly
coupled with a dedicated L1-cache.
WhentheCPUboots,thecontentofthe SYSCFG->MEMRMP registerislatchedtothevaluesoftheBOOT
pins: this means that the physical remap is automatically performed from the MCU when sampling
BOOT pins. Before changing the content of this register, to perform a remap, it is important to have
into the destination memory a working vector table³.
22.1.2 Vector Table Relocation
In Chapter 20 we have seen how to relocate the vector table in CCM memory so that we can take
advantage of this core-coupled memory. When we perform physical remapping, either setting the
BOOT pins or configuring the SYSCFG->MEMRMP register accordingly, there is no need to perform
vector table relocation since the MCU automatically aliases the starting address of the selected
memory to 0x0000 0000 . Sometimes, however, we want to move the vector table in other memory
locations that do not correspond to its origin. For example, we may want to store two independent
firmware images inside the flash memory (see Figure 1) and to select one of these according a given
initial condition. This is the case of bootloaders, special “system” programs that carry out important
configuration tasks such as upgrading the main firmware, as we will see later in this chapter.
The Vector Table Offset Register (VTOR) is a register in the System Control Block (SCB) ( SCB->VTOR
in the CMSIS library) that allows to setup the base address of the vector table. Once the content of
this register is set, the CPU will treat the addresses starting from the new base location as pointers
to interrupt service routines.
³ It is important to clarify that the CPU will not restart a reset sequence, invoking the handler of the Reset exception, once the memory
has been remapped using the SYSCFG->MEMRMP register. It will be your responsibility to invoke that exception handler, and to ensure that the
CPU is placed to the initial conditions that the target firmware expects to find (e.g. all peripherals disabled, and so on).
Booting Process 596
Figure 1: Two independent firmware images may be stored inside the flash memory
Figure 2: The structure of the VTOR register
When modifying the content of the VTOR register, it is important to consider that:
• The VTOR register is not available in Cortex-M0 based MCU and hence it is not possible to
relocate the vector table without using the physical remap (a way to bypass this limitation
exists, as we will see later).
• In STM32F1 MCUs, which are based on the Cortex-M3 r1p0 core revision, the bits [31:30] of
the VTOR register are reserved (see Figure 2) and hence it is possible to relocate the vector
table only in the code memory ( 0x0000 0000 ) and in SRAM ( 0x2000 0000 ).
• ARM specification suggests to use a dmb (Data Memory Barrier) instruction before updating the
content of the VTOR register and a dsb (Data Synchronization Barrier) instruction after the
update. Refer to the example 6 in Chapter 20 for a complete example.
• Before changing the content of the VTOR register, ensure that a minimal vector table for your
application is already in the new location.
Booting Process 597
• If the application is using peripheral interrupts, suspend all interrupts before starting the
relocation procedure.
22.1.3 Running the Firmware From SRAM Using the GNU MCU
Eclipse Toolchain
Sometimes, it can be useful to load the binary firmware inside the SRAM and to boot from it. This
requires a special support of the debugger, and the following steps:
1. BOOT pins (or the corresponding bit in the option bytes region) must be configured so that the
MCU boots from SRAM (both pins connected to VDD in the most of STM32 MCUs).
2. The linker script must be modified so that the FLASH region is mapped to the starting address
0x0000 0000 (or to the 0x2000 0000 address, which correspond to the same memory if the
SRAM is selected as boot origin).
3. OpenOCD must be properly instructed to set the initial value for the program counter to the
origin of SRAM address, plus 4 bytes.
The first step can be easily accomplished in Nucleo boards by connecting both BOOT0 pin (which
corresponds to the pin 7 in the CN7 morpho connector) and BOOT1 pin (that is PB2 pin in almost
all STM32 MCUs with LQFP-48 package, and which corresponds to the pin 22 in the CN10 morpho
connector) to VDD, as shown in Figure 3.
The second step can be usually limited to modifying the origin of the FLASH memory inside the
linker script (the file mem.ld in the GNU MCU Eclipse tool-chain), setting its origin to the 0x0000
0000 (or the 0x2000 0000 address which also corresponds to the SRAM memory). If this procedure
sounds new to you, you have to study Chapter 19 better.
Finally, we need to instruct OpenOCD so that it sets the Program Counter (PC) to the base address
of SRAM memory. This can be simply accomplished by modifying the debug configuration for our
project, going inside the Startup section, and then checking the Debug from RAM entry and
unchecking thePre-run/Restartreset.Thesesettingswillalsocausethatthefirmwareisuploaded
again in SRAM every time we reset the MCU from the IDE (obviously, if we reset the board by using
the dedicated hardware button on the Nucleo, the code is lost or, at least, it may be corrupted).
Before filing a support request to this author, because this procedure may not to work in
your case, take in account that this procedure may not work for those of you having Nucleo
boards based on STM32 MCUs with few SRAM memory. This because it could happen that
the code area falls through the stack area. This procedure essentially works for really small
and limited programs.
Booting Process 598
Figure 3: How to tie BOOT0 and BOOT1 pins to VDD in a Nucleo board so that MCU boots from SRAM
22.2 Integrated Bootloader
Inmoderndigitalelectronicsitisalmostimpossibletodistributeelectronicdeviceswithoutreleasing
successive upgrades of the firmware. And this is especially true for complex boards with a lot
of integrated circuits and peripherals. Soon or later, all embedded developers will need a way to
distribute a firmware upgrade and, most important, they will need a way to let customers uploading
it on the MCU without a dedicated (and sometimes expensive) debugger. Moreover, often the SWD
debug port is not added to the final PCB for a design choice.⁴.
Abootloader isapieceofsoftware,usuallyexecutedfirstwhentheMCUboots,whichhastheability
to upgrade the firmware inside the internal flash. This operation is also known as In-Application
Programming (IAP), which is distinct from the MCU programming using an external and dedicated
debugger: this other way to program MCUs is also known as In-System Programming (ISP).
Bootloaders are usually designed so that they accept commands through a communication periph-
eral (USART, USB, Ethernet and so on), which is used to exchange the firmware binary with the
MCU. A dedicated program, designed to run on an external PC, is usually also needed.
All STM32 MCUs come from the factory with a pre-programmed bootloader in a ROM memory,
called System memory, which is mapped inside the address range 0x1FFF 0000 - 0x1FFF 77FF in
the majority of STM32 microcontrollers⁵. Depending on the MCU family and package used, this
bootloader can interact with the outside world using:
⁴ For those of you wondering how to upload the firmware on a board without the debug port, and without using the integrated bootloader,
itcouldbeusefultoknowthatSTcanshiptoyouMCUswithyourfirmwarealreadypre-programmedduringMCUproduction.Thispossibility
is offered for quite large orders (as far as I know lots with more than 10.000pcs). Ask to your sales representative for more about this.
⁵ Figure 4 in Chapter 1 gives you an idea of the System memory position inside the Cortex-M 4GB address space.
Booting Process 599
• USART
• USB (DFU)
• CAN bus
• I²C
• SPI
Foreachoneofthesecommunicationperipherals,SThasdefinedastandardizedprotocolthatallows
to:
• Retrieve the bootloader release and supported commands.⁶
• Get the chip ID.
• Read a number of bytes of memory starting from an address specified by the host application.
• Write a number of bytes to the RAM or flash memory starting from an address specified by
the host application.
• Erase one or more flash memory pages/sectors.
• Jump to user application code located in the internal flash memory or in SRAM.
• Enable/disable the read/write protection for some pages/sectors.
For each communication protocol, ST provides a dedicated application note called “PPP protocol
used in STM32 bootloader”, where PPP is the peripheral type. For example, the AN3155⁷ is about the
USART protocol.
Apart from the communication peripheral used, the bootloader uses several other hardware
resources:
• The HSI oscillator, which is selected as the clock source.
• The SysTick timer (not for all communication peripherals).
• About 2K of SRAM memory.
• The IWDG peripheral (prescaler is configured to its maximum value and IWDG is periodically
refreshed to prevent reset in case the hardware IWDG option was previously enabled by the
user).
Moreover, there are some limitations regarding memory management through the bootloader:
• Some STM32 microcontrollers don’t support mass-erase operation. To perform a mass-erase
using bootloader, two options are available: to erase all sectors one-by-one using the Erase
command or to set flash read protection level to Level 1 and then to set it back to Level 0.
⁶ Thisisnotasecondaryfeature,sincethereexistdifferentreleasesofSTM32bootloaders,andsomeofthemhavenonnegligibledifferences.
⁷ http://bit.ly/2cojjQI
Booting Process 600
• Bootloader firmware in STM32L1/L0 series allows to manipulate EEPROM in addition to
standard memories (internal flash and SRAM, option bytes and system memory). The starting
address and the size of this memory type depend on the specific part number. EEPROM can be
readandwrittenbutcannotbeerasedusingtheEraseCommand.WhenwritinginanEEPROM
location,thebootloaderfirmwaremanagestheeraseoperationofthislocationbeforeanywrite.
A write to the EEPROM must be word-aligned (address to be written should be a multiple of
4) and the number of data must also be a multiple of 4. To erase an EEPROM location, you can
write zeros at this location.
• Bootloader firmware in STM32F2/F4/F7/L4 series supports OTP memory in addition to stan-
dard memories (internal Flash, internal SRAM, option bytes and system memory). The starting
addressandthesizeofthisareadependsonthespecificpartnumber.Pleaserefertotheproduct
reference manual for more information. OTP memory can be read and written but cannot be
erased using Erase command. When writing in an OTP memory location, make sure that the
relative protection bit is not reset.
• For STM32F2/F4/F7 series the internal flash write operation format depends on voltage range.
Bydefault,writeoperationsareallowedbyonebyteformat(half-word,wordanddouble-word
operationsarenotallowed).Toincreasethespeedofwriteoperations,theusershouldapplythe
adequate voltage range that allows write operations by half-word, word or double-word and
update this configuration on the fly by using the bootloader software. Some virtual locations
are reserved for this operation. For more information about this, refer to the AN2606 from ST⁸.
To interface the integrated bootloader using the USART protocol, ST provides a convenient tool,
named STM32-FLASHER⁹, which is a Window-based tool able to program STM32 MCUs using the
USART bootloader. This allows you to program your board using the integrated bootloader and
without the need for a custom PC application.
If, instead, your final PCB provides a USB device port connected to the MCU through its dedicated
pins,youcaninterfacetheMCUbootloaderusingthestandardUSBDeviceFirmwareUpgrade(DFU)
protocol, a vendor- and device-independent mechanism for upgrading the firmware of USB devices.
ST provides a dedicated set of tools, which allow to upgrade firmware in flash memory using this
protocol. Moreover, some other open source applications, like the dfu-util ¹⁰ tool, can be also used
on Windows as well as on Linux and MacOS. For more information about USB DFU mode in STM32
bootloaders, consult the UM0412¹¹ user manual from ST.
22.2.1 Starting the Bootloader From the On-Board Firmware
The execution of the integrated bootloader is connected to the status of BOOT pins, which are
sampled during the first clock cycles. However, for several design choices, you may not be able to
configure BOOT pins as required. For this reason, you can “jump” to the System memory from the
firmware (for example, the user may be forced to press a hidden switch).
⁸ http://bit.ly/29sEb8t
⁹ http://bit.ly/2cok2kP
¹⁰ http://dfu-util.sourceforge.net/
¹¹ http://bit.ly/29sJen2
Booting Process 601
Forcing the bootloader execution from the user code is not that hard: it is just about defining a
function pointer.
1 __set_MSP(SRAM_END);
2 uint32_t JumpAddress = *(volatile uint32_t*)(0x1FFF0000 + 4);
3 void (*boot_loader)(void) = JumpAddress;
4 SYSCFG->MEMRMP = 0x1; //Remap 0x0000 0000 to System Memory
5 boot_loader();
6 //Never coming here
The instruction at line 1 sets the main stack pointer to the end of SRAM (this should not be usually
required, but just in case….). Then we create a pointer to a function whose address is set to the
beginning of the System Memory ¹² and we simply jump to the integrated bootloader by calling the
function boot_loader() after a physical remap to System Memory¹³.
However, we must place special care when jumping to the System Memory. The bootloader, in fact,
is designed to be called just after a reset and it assumes that the CPU and its peripherals are set
to the default initial state. A better solution could be achieved by storing a special code inside the
SRAM memory and then forcing a system reset in software: we may check from theReset exception
handler against this special code and jump to the System Memory before any other initialization
procedure. This guard value must be stored in a memory location outside of .data and .bss regions,
otherwise it may be initialized during firmware booting (alternatively, we can place this code inside
Reset exception handler before those regions are initialized).
22.2.2 The Booting Sequence in the GNU MCU Eclipse Tool-chain
Now that the booting process is clear, we can analyze a really fundamental topic: what are the
exact steps performed during boot by an application developed with the GNU MCU Eclipse tool-
chain? The answer is not trivial, and there are several important things an experienced programmer
working with this tool-chain must know.
InChapter19wehavedeeplyanalyzedthewayaReset exceptionworks.However,examplesmadein
that chapter are insulated from the real tool-chain: we have developed a minimal STM32 application
that does not use either the CubeHAL nor the startup files from GNU MCU Eclipse tool-chain. So,
to understand the actual boot sequence, we have to start from the beginning: the Reset exception.
In Chapter 7 we have seen that the assembly file system/src/cmsis/startup_stm32xxxx.S contains
the definition of the vector table. This files is provided by ST and it is specific for the given STM32
MCU. Opening the one fitting your MCU, you can find the definition of the Reset_Handler , about
at line 76.
¹² The above address, 0x1FFF 0000 , coincides with the starting address of System Memory in an STM32F401RE MCU; consult the reference
manual for your MCU for the exact value).
¹³ Probably the physical remap is not strictly needed, since the bootloader seems to work well the same.
Booting Process 602
76 .section .text.Reset_Handler
77 .weak Reset_Handler
78 .type Reset_Handler, %function
79 Reset_Handler:
80 ldr sp, =_estack /* set stack pointer */
81
82 /* Copy the data segment initializers from flash to SRAM */
83 movs r1, #0
84 b LoopCopyDataInit
85
86 CopyDataInit:
87 ldr r3, =_sidata
88 ldr r3, [r3, r1]
89 str r3, [r0, r1]
90 adds r1, r1, #4
91
92 LoopCopyDataInit:
93 ldr r0, =_sdata
94 ldr r3, =_edata
95 adds r2, r0, r1
96 cmp r2, r3
97 bcc CopyDataInit
98 ldr r2, =_sbss
99 b LoopFillZerobss
100 /* Zero fill the bss segment. */
101 FillZerobss:
102 movs r3, #0
103 str r3, [r2], #4
104
105 LoopFillZerobss:
106 ldr r3, = _ebss
107 cmp r2, r3
108 bcc FillZerobss
109
110 /* Call the clock system intitialization function.*/
111 bl SystemInit
112 /* Call static constructors */
113 bl __libc_init_array
114 /* Call the application's entry point.*/
115 bl main
116 bx lr
117 .size Reset_Handler, .-Reset_Handler
It is written in assembly, but it should be really easy to understand now that we have mastered a
lot of fundamental concepts. A new section named .text.Reset_Handler is defined at line 76, while
the routine body starts at line 80. Here the MSP is set to the content of the _estack linker variable (it
coincides with the end of SRAM). Then the control is transferred to the LoopCopyDataInit routine,
Booting Process 603
which initializes the .data section. The control is then transferred to the LoopFillZerobss routine,
which initializes the .bss sections and calls the SystemInit() routine (we will analyze it in a while)
andcallsC++staticconstructorsbycallingthe __libc_init_array() .Finally,ittransfersthecontrol
to the main() routine.
This is the Reset exception provided by ST. But, wait! Taking a look at line 77 you can see that
the Reset_Handler routine is declared weak : this means that another routine with the same name,
defined elsewhere in the source tree, can override this one. In fact, if you open the file system/src/-
cortexm/exception_handlers.c you can see that the handler is overridden there, about at line 29,
and it calls the function _start() which is defined inside the file system/src/newlib/_startup.c.
Thisroutineessentiallyperform .data and .bss initializationandtransfersthecontroltothe main() ,
but before performing these operations, it calls the function __initialize_hardware_early()
defined in the file system/src/cortexm/_initialize_hardware.c. The most relevant lines of code
of that function are reported below.
33 void __attribute__((weak))
34 __initialize_hardware_early(void)
35 {
36 // Call the CSMSIS system initialization routine.
37 SystemInit();
38
39 #if defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__)
40 // Set VTOR to the actual address, provided by the linker script.
41 // Override the manual, possibly wrong, SystemInit() setting.
42 SCB->VTOR = (uint32_t)(&__vectors_start);
43 #endif
44 ...
Asyoucansee,itcallsthe SystemInit() routineandrelocatesthevectortableattheaddressspecified
by the linker symbol __vectors_start (this operation is not performed on Cortex-M0).
The CMSIS routine SystemInit() is platform-dependent and it is provided by ST inside the file
named system/src/cmsis/system_stm32xxxx.c. Explaining the exact content of that routine is
outside the scope of this book: it is really specific for a given MCU, and it essentially performs
the early initialization of some peripherals (mainly the clock). However, if you take a look at the
end of that routine, you can see that ST also relocates the vector table with this instruction:
1 SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET;
As you can see, the VTOR is set to the base of flash memory plus an offset ( VECT_TAB_OFFSET ) that
can be eventually defined inside the same file.
So all this to say that the effective relocation of the vector table is performed by the initialization
procedure of the GNU MCU Eclipse tool-chain and not by the ST official startup files. This is a
Booting Process 604
relevant thing to keep in handy if you are going to develop custom startup sequences, as we will see
later.
Finally, _start() also calls the __initialize_hardware() routine, which calls the CMSIS function
SystemCoreClockUpdate() provided by ST inside the system/src/cmsis/system_stm32xxxx.c file.
This a platform-dependent routine that updates the CMSIS global variable SystemCoreClock
according to the specific clock registers. The SystemCoreClock variable is widely used inside the
HAL code, and it is important to keep it synchronized with the effective clock tree configuration, as
seen in Chapter 10.
22.3 Developing a Custom Bootloader
Read Carefully
The bootloader described in this paragraph works correctly if and only if the ST-LINK
interface has a firmware version equal or higher than 2.27.15. Older releases have a bug
on the VCP preventing the USART interface to work as expected. Ensure that your Nucleo
is updated.
Integrated bootloaders work well in a lot of cases. Many real projects can benefit from their usage.
Moreover, the free-of-charge tools provided by ST can reduce the effort needed to develop custom
applications that upload the firmware on the MCU. However, for some applications you may need
additional functionalities not implemented in standard bootloaders. For example, we may want to
encrypt the distributed firmware so that only the on-board bootloader is able to decode it using a
pre-shared key hardcoded inside the bootloader code.
Wearenowgoingtodevelopacustombootloaderthatwillallowustouploadanewfirmwareonthe
target MCU. This will essentially provide only a fraction of the features implemented by integrated
bootloaders, but it will give us the opportunity to review the fundamental steps needed to develop
a custom bootloader. It will provide the following functionalities:
• Upload a new firmware using the UART interface (in our case, the UART2 interface provided
by all Nucleo boards).
• Retrieve the MCU type.
• Erase a given amount of flash sectors/pages.
• Write a series of bytes starting from a given address.
• Encrypt/Decrypt the exchanged firmware using AES-128 algorithm¹⁴.
¹⁴ As far as I know, ST provides on request a custom bootloader that implements firmware encryption, in the same way other silicon
manufacturers do. However, I am almost sure that you have to compile and sign a lot of license agreements, and probably you have to prove
that you will use STM32 MCUs in your projects. As we will see next, it is not that difficult to create a custom bootloader with such capabilities.
Booting Process 605
Table 2: The flash memory organization in an STM32F401RE MCU
The code that we will analyze here relies on the flash memory layout of STM32F401RE microcon-
trollers, which is shown in Table 2 and extracted from the corresponding reference manual. As
you can see, the 512KB of flash memory are partitioned in seven sectors. The first one, the sector 0
highlighted in blue in Table 2, will be used to store the integrated bootloader. If you are working on
a different STM32 MCU, refer to the book examples to see how the bootloader has been arranged
for your MCU.
Once the MCU resets, the bootloader starts its execution¹⁵. This means that the bootloader is
compiled so that it is mapped starting from the 0x0800 0000 address, as it happens for all standard
STM32 applications seen in this book.
A really minimal vector table is defined, which allows to the MCU to properly start the execution.
The bootloader so samples the PC13 pin, which in almost all Nucleo boards corresponds to the blue
button on the board. If the button is pressed, then it starts accepting commands on the UART2
interface. Otherwise, it immediately relocates the VTOR register and passes the control to the Reset
exception handler of the main firmware.
A companion script, written in Python, is also provided. It is named flasher.py and you can find it
inside the book examples. We will describe how to use it in a following paragraph.
Before we go into the details of the commands used to exchange messages with the bootloader, we
will start analyzing the procedures executed during the boot process and the way the control is
transferred to the main firmware.
¹⁵ Clearly, the MCU pins must be configured so that the flash memory is the default boot source.
Booting Process 606
Filename: src/main-bootloader.c
7 /* Global macros */
8 #define ACK 0x79
9 #define NACK 0x1F
10 #define CMD_ERASE 0x43
11 #define CMD_GETID 0x02
12 #define CMD_WRITE 0x2b
13
14 #define APP_START_ADDRESS 0x08004000 /* In STM32F401RE this corresponds with the start
15 address of Sector 1 */
16
17 #define SRAM_SIZE 96*1024 // STM32F401RE has 96 KB of RAM
18 #define SRAM_END (SRAM_BASE + SRAM_SIZE)
19
20 #define ENABLE_BOOTLOADER_PROTECTION 0
21 /* Private variables ---------------------------------------------------------*/
22
23 /* The AES_KEY cannot be defined const, because the aes_enc_dec() function
24 temporarily modifies its content */
25 uint8_t AES_KEY[] = { 0x4D, 0x61, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6E, 0x67,
26 0x20, 0x20, 0x53, 0x54, 0x4D, 0x33, 0x32 };
27
28 extern CRC_HandleTypeDef hcrc;
29 extern UART_HandleTypeDef huart2;
The macro APP_START_ADDRESS at line 14 defines the starting address of the main firmware.
According to the memory layout of an STM32F401RE MCU, the second sector starts at that address
and the main application firmware will be stored there. This means that the MSP will be placed
at 0x0800 4000 and the address in flash memory of the Reset exception handler at 0x0800 4004 .
The AES_KEY array, defined at line 25, contains sixteen bytes forming the AES-128 key used to
encrypt/decrypt the uploaded firmware. We will analyze its usage later.
Filename: src/main-bootloader.c
44 /* Minimal vector table */
45 uint32_t *vector_table[] __attribute__((section(".isr_vector"))) = {
46 (uint32_t *) SRAM_END, // initial stack pointer
47 (uint32_t *) _start, // _start is the Reset_Handler
48 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (uint32_t *) SysTick_Handler };
The vector table is defined at line 45. It just contains the MSP pointer, which coincides with the
end of SRAM memory, the pointer to the Reset exception handler ( _start in this case, which does
nothing more than to initialize .data and .bss sections and to transfer the control to the main()
routine), and the pointer to the SysTick_Handler . This is required because we will use the standard
HAL routines to interface peripherals, and the HAL is build around an unique timebase, usually
Booting Process 607
generated using the SysTick timer. The HAL so needs to enable that timer and to catch the overflow
event so that the global tick count is increased.
Filename: src/main-bootloader.c
93 int main(void) {
94 uint32_t ulTicks = 0;
95 uint8_t ucUartBuffer[20];
96
97 /* HAL_Init() sets SysTick timer so that it overflows every 1ms */
98 HAL_Init();
99 MX_GPIO_Init();
100
101 #if ENABLE_BOOTLOADER_PROTECTION
102 /* Ensures that the first sector of flash is write-protected preventing that the
103 bootloader is overwritten */
104 CHECK_AND_SET_FLASH_PROTECTION();
105 #endif
106
107 /* If USER_BUTTON is pressed */
108 if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_RESET) {
109 /* CRC and UART2 peripherals enabled */
110 MX_CRC_Init();
111 MX_USART2_UART_Init();
112
113 ulTicks = HAL_GetTick();
114
115 while (1) {
116 /* Every 500ms the LD2 LED blinks, so that we can see the bootloader running. */
117 if (HAL_GetTick() - ulTicks > 500) {
118 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
119 ulTicks = HAL_GetTick();
120 }
121
122 /* We check for new commands arriving on the UART2 */
123 HAL_UART_Receive(&huart2, ucUartBuffer, 20, 10);
124 switch (ucUartBuffer[0]) {
125 case CMD_GETID:
126 cmdGetID(ucUartBuffer);
127 break;
128 case CMD_ERASE:
129 cmdErase(ucUartBuffer);
130 break;
131 case CMD_WRITE:
132 cmdWrite(ucUartBuffer);
133 break;
134 };
135 }
Booting Process 608
136 } else {
137 /* USER_BUTTON is not pressed. We first check if the first 4 bytes starting from
138 APP_START_ADDRESS contain the MSP(end of SRAM). If not, the LD2 LED blinks quickly. */
139 if (*((uint32_t*) APP_START_ADDRESS) != SRAM_END) {
140 while (1) {
141 HAL_Delay(30);
142 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
143 }
144 } else {
145 /* A valid program seems to exist in the second sector: we so prepare the MCU
146 to start the main firmware */
147 MX_GPIO_Deinit(); //Puts GPIOs in default state
148 SysTick->CTRL = 0x0; //Disables SysTick timer and its related interrupt
149 HAL_DeInit();
150
151 RCC->CIR = 0x00000000; //Disable all interrupts related to clock
152 __set_MSP(*((volatile uint32_t*) APP_START_ADDRESS)); //Set the MSP
153
154 __DMB(); //ARM says to use a DMB instruction before relocating VTOR */
155 SCB->VTOR = APP_START_ADDRESS; //We relocate vector table to the sector 1
156 __DSB(); //ARM says to use a DSB instruction just after relocating VTOR */
157
158 /* We are now ready to jump to the main firmware */
159 uint32_t JumpAddress = *((volatile uint32_t*) (APP_START_ADDRESS + 4));
160 void (*reset_handler)(void) = (void*)JumpAddress;
161 reset_handler(); //We start the execution from he Reset_Handler of the main firmware
162
163 for (;;)
164 ; //Never coming here
165 }
166 }
167 }
Wearenowgoingtoexplainthetasksperformedbythe main() routine.OnceitiscalledbytheReset
exception handler ( _start() routine), it firstly initializes the CubeHAL, reducing to the minimum
theamountofoperationsperformedinthisphase:thishelpsreducingtheboottime.The HAL_Init()
routine also configures the SysTick timer so that it expires every 1ms. The PC13 pin is so sampled,
andiftheuserkeepspressedtheUSERBUTTON,thentheroutineentersinaninfiniteloopaccepting
three commands on the UART2. We will analyze them later. Note that we leave the default clock
source as is (that is, the HSI oscillator).
If, instead, the USER BUTTON is left unpressed, then the main() routine verifies if the first memory
location of the second sector contains the MSP (we simply check that it does contain the SRAM_-
END value). If not, the firmware starts blinking LD2 LED very fast to signal that there is no main
application to run.
If that memory location contains the MSP pointer (line 144), we can start the boot sequence. GPIOs
Booting Process 609
are so placed to their default state, the HAL is deinitialized and the SysTick timer is stopped and
its exception disabled. All clock-related interrupts are disabled at line 151 and the MSP is set to the
addressspecifiedatthefirst4bytesofthesector1(becausethevectortable isplacedthere,aswewill
see later). The VTOR base location is so set to the APP_START_ADDRESS (that is, 0x0800 4000 for the
STM32F401RE bootloader). The address of Reset exception for the main firmware is derived from
the 0x0800 4004 memory location and a pointer to that function is defined. Finally, at line 161 the
Reset exception is invoked and the bootloader ends.
Before we analyze the three commands implemented by the bootloader, it is best to give a quick
look at the other application shipped with the examples of this chapter. It is named main-app1.c
and it is nothing more than a simple application that blinks the LD2 LED and prints a message on
the UART2. The only relevant thing to note is the companion linker script, named ldscript-app.ld ,
which defines the FLASH memory region in the following way:
Filename: src/ldscript-app.ld
14 MEMORY {
15 FLASH (rx) : ORIGIN = 0x08004000, LENGTH = 512K - 16K
16 RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 96K
As you can see, the linker will relocate the application code starting from the 0x0800 4000 address.
Moreover, the length of this memory region is set to 496KB: since the first sector is 16KB wide, 512-
16 is equal to 496. This definition of the flash memory region also allows us to upload and debug the
firmware using OpenOCD (or the STM32CubeProgrammer) without overwriting the bootloader.
According to what seen in the previous paragraph, the VTOR value set by the bootloader
will be overwritten by the startup routine of the main application. However, the code will
continue to work seamlessly, because in the main-app1.c ’s linker script the __vectors_-
start symbol coincides with the APP_START_ADDRESS macro (that is, 0x0800 4000 ). This is
an important aspect to keep in mind when programming a bootloader.
Now it is the right time to analyze the three commands supported by this bootloader: CMD_GETID ,
CMD_ERASE and CMD_WRITE .
Get ID Command
The CMD_GETID command is used to retrieve the MCU ID¹⁶ and it has the structure shown in Figure
4. The bootloader so expects to retrieve the byte 0x02 followed by the CRC-32 of this byte. The
bootloader answers to the request by sending an ACK (which is defined at line 8 of the main-
bootloader.c file and it is equal to 0x79 ) followed by two bytes containing the MCU ID.
¹⁶ The MCU ID is different from the CPU ID. The former identifies the STM32 family and chip type (for example, 0x433 identifies the
STM32F401RE MCU). The latter is an unique ID that identifies that specific MCU, and it is impossible (or at least really hard) that exist two
STM32 microcontrollers with the same CPU ID.
Booting Process 610
Figure 4: The structure of the CMD_GETID
Filename: src/main-bootloader.c
223 void cmdGetID(uint8_t *pucData) {
224 uint16_t usDevID;
225 uint32_t ulCrc = 0;
226 uint32_t ulCmd = pucData[0];
227
228 memcpy(&ulCrc, pucData + 1, sizeof(uint32_t));
229
230 /* Checks if provided CRC is correct */
231 if (ulCrc == HAL_CRC_Calculate(&hcrc, &ulCmd, 1)) {
232 usDevID = (uint16_t) (DBGMCU->IDCODE & 0xFFF); //Retrieves MCU ID from DEBUG interface
233
234 /* Sends an ACK */
235 pucData[0] = ACK;
236 HAL_UART_Transmit(&huart2, pucData, 1, HAL_MAX_DELAY);
237
238 /* Sends the MCU ID */
239 HAL_UART_Transmit(&huart2, (uint8_t *) &usDevID, 2, HAL_MAX_DELAY);
240 } else {
241 /* The CRC is wrong: sends a NACK */
242 pucData[0] = NACK;
243 HAL_UART_Transmit(&huart2, pucData, 1, HAL_MAX_DELAY);
244 }
245 }
Theabovecodeshowshowthecommandisimplemented.Asyoucansee,theCRCisextractedfrom
the message coming on the UART and compared with the one computed by the CRC peripheral. If
the two values match, then the MCU ID is derived from DEBUG interface and it is transmitted over
the UART together with the ACK. If the CRC does not match, a NACK (which is equal to 0x1F) is
sent.
Erase Command
The CMD_ERASE command is used to erase a given sector of the flash memory and it has the structure
shown in Figure 5. The command is composed by the id 0x43 that identifies the command type,
followed by the amount of sectors to delete (or the value 0xFF to delete all sector except the first one
where the bootloader resides) and the CRC-32. The bootloader answers by sending an ACK when
the erasing procedure completes.
Booting Process 611
Figure 5: The structure of the CMD_ERASE
Filename: src/main-bootloader.c
180 void cmdErase(uint8_t *pucData) {
181 FLASH_EraseInitTypeDef eraseInfo;
182 uint32_t ulBadBlocks = 0, ulCrc = 0;
183 uint32_t pulCmd[] = { pucData[0], pucData[1] };
184
185 memcpy(&ulCrc, pucData + 2, sizeof(uint32_t));
186
187 /* Checks if provided CRC is correct */
188 if (ulCrc == HAL_CRC_Calculate(&hcrc, pulCmd, 2) &&
189 (pucData[1] > 0 && (pucData[1] < FLASH_SECTOR_TOTAL - 1 || pucData[1] == 0xFF))) {
190 /* If data[1] contains 0xFF, it deletes all sectors; otherwise
191 * the number of sectors specified. */
192 eraseInfo.Banks = FLASH_BANK_1;
193 eraseInfo.Sector = FLASH_SECTOR_1;
194 eraseInfo.NbSectors = pucData[1] == 0xFF ? FLASH_SECTOR_TOTAL - 1 : pucData[1];
195 eraseInfo.TypeErase = FLASH_TYPEERASE_SECTORS;
196 eraseInfo.VoltageRange = FLASH_VOLTAGE_RANGE_3;
197
198 HAL_FLASH_Unlock(); //Unlocks the flash memory
199 HAL_FLASHEx_Erase(&eraseInfo, &ulBadBlocks); //Deletes given sectors */
200 HAL_FLASH_Lock(); //Locks again the flash memory
201
202 /* Sends an ACK */
203 pucData[0] = ACK;
204 HAL_UART_Transmit(&huart2, (uint8_t *) pucData, 1, HAL_MAX_DELAY);
205 } else {
206 /* The CRC is wrong: sends a NACK */
207 pucData[0] = NACK;
208 HAL_UART_Transmit(&huart2, pucData, 1, HAL_MAX_DELAY);
209 }
210 }
Theabovecodeshowshowthecommandisimplemented.Asyoucansee,theCRCisextractedfrom
themessagecomingontheUARTandcomparedwiththeonecomputedbytheCRCperipheral.Note
that, since the CRC peripheral has a 32-bit wide data register and the CRC-32 is computed over the
whole register, we covert the first two bytes to two 32-bit values.
If the CRC matches, then an instance of the FLASH_EraseInitTypeDef struct is filled so that the
flash sectors are erased starting from the second one (line 193) up to the amount of sectors specified
Booting Process 612
(line194).Theflashmemoryissounlocked(line198)andtheeraseprocedureisperformedbycalling
the HAL_FLASHEx_Erase() routine.
Write Command
The CMD_WRITE command is used to store sixteen bytes (that is, four words) starting from a given
memorylocation,andithasthestructurereportedinFigure6.Thecommandismadeoftwodistinct
parts. The first one is composed by the command id 0x2b , followed by the starting address where to
place data bytes and the command’s CRC-32. If the CRC matches and the specified address is equal
or higher than APP_START_ADDRESS , the bootloader answers with an ACK. The bootloader so expects
to receive another sequence made of sixteen bytes and the CRC-32 checksum of these bytes.
Figure 6: The structure of the CMD_WRITE
Filename: src/main-bootloader.c
267 void cmdWrite(uint8_t *pucData) {
268 uint32_t ulSaddr = 0, ulCrc = 0;
269
270 memcpy(&ulSaddr, pucData + 1, sizeof(uint32_t));
271 memcpy(&ulCrc, pucData + 5, sizeof(uint32_t));
272
273 uint32_t pulData[5];
274 for(int i = 0; i < 5; i++)
275 pulData[i] = pucData[i];
276
277 /* Checks if provided CRC is correct */
278 if (ulCrc == HAL_CRC_Calculate(&hcrc, pulData, 5) && ulSaddr >= APP_START_ADDRESS) {
279 /* Sends an ACK */
280 pucData[0] = ACK;
281 HAL_UART_Transmit(&huart2, (uint8_t *) pucData, 1, HAL_MAX_DELAY);
282
283 /* Now retrieves given amount of bytes plus the CRC32 */
284 if (HAL_UART_Receive(&huart2, pucData, 16 + 4, 200) == HAL_TIMEOUT)
285 return;
286
287 memcpy(&ulCrc, pucData + 16, sizeof(uint32_t));
288
289 /* Checks if provided CRC is correct */
Booting Process 613
290 if (ulCrc == HAL_CRC_Calculate(&hcrc, (uint32_t*) pucData, 4)) {
291 HAL_FLASH_Unlock(); //Unlocks the flash memory
292
293 /* Decode the sent bytes using AES-128 ECB */
294 aes_enc_dec((uint8_t*) pucData, AES_KEY, 1);
295 for (uint8_t i = 0; i < 16; i++) {
296 /* Store each byte in flash memory starting from the specified address */
297 HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, ulSaddr, pucData[i]);
298 ulSaddr += 1;
299 }
300 HAL_FLASH_Lock(); //Locks again the flash memory
301
302 /* Sends an ACK */
303 pucData[0] = ACK;
304 HAL_UART_Transmit(&huart2, (uint8_t *) pucData, 1, HAL_MAX_DELAY);
305 } else {
306 goto sendnack;
307 }
308 } else {
309 goto sendnack;
310 }
311
312 sendnack:
313 pucData[0] = NACK;
314 HAL_UART_Transmit(&huart2, (uint8_t *) pucData, 1, HAL_MAX_DELAY);
315 }
The above code shows how the command is implemented. As you can see, the CRC of the first part
of the message is checked against the transmitted value (lines [273:278]). If it corresponds, an ACK
is sent and the next bytes are processed. If the CRC-32 of these other bytes matches (line 290), then
the sent data bytes are decrypted using the AES-128 algorithm¹⁷ and the pre-shared key. Data bytes
are so stored inside the flash memory starting from the given memory location.
There is one more thing to analyze: the function CHECK_AND_SET_FLASH_PROTECTION() invoked by
the main() function if the macro ENABLE_BOOTLOADER_PROTECTION is set to 1.
¹⁷ The aes_enc_dec() function is taken from a library made by Eric Peeters, a TI employee. It can be downloaded from the TI
website(http://www.ti.com/tool/AES-128) and its license allows to use it freely. ST provides a complete cryptographic library for the STM32
platform, which is also compatible with the Cube framework (http://bit.ly/29zWN81). This library can also take advantage of those STM32
MCUs providing a dedicated hardware crypto unit. However, the license of this library prevents this author from shipping the library with the
examples in this book.
Booting Process 614
Filename: src/main-bootloader.c
317 void CHECK_AND_SET_FLASH_PROTECTION(void) {
318 FLASH_OBProgramInitTypeDef obConfig;
319
320 /* Retrieves current OB */
321 HAL_FLASHEx_OBGetConfig(&obConfig);
322
323 /* If the first sector is not protected */
324 if ((obConfig.WRPSector & OB_WRP_SECTOR_0) == OB_WRP_SECTOR_0) {
325 HAL_FLASH_Unlock(); //Unlocks flash
326 HAL_FLASH_OB_Unlock(); //Unlocks OB
327 obConfig.OptionType = OPTIONBYTE_WRP;
328 obConfig.WRPState = OB_WRPSTATE_ENABLE; //Enables changing of WRP settings
329 obConfig.WRPSector = OB_WRP_SECTOR_0; //Enables WP on first sector
330 HAL_FLASHEx_OBProgram(&obConfig); //Programs the OB
331 HAL_FLASH_OB_Launch(); //Ensures that the new configuration is saved in flash
332 HAL_FLASH_OB_Lock(); //Locks OB
333 HAL_FLASH_Lock(); //Locks flash
334 }
335 }
This function simply retrieves the current Option Bytes configuration and checks if the first sector
is write-protected (line 324). If not, the write-protection is enabled so that the bootloader cannot be
overwritten.
If you want to experiment with this function, then to disable the write-protection you can use the
STM32CubeProgrammer.
Some Considerations on the Custom Bootloader
The custom bootloader presented here is far from to be complete. It lacks of some relevant
featuresand,mostimportant,itisnotsufficientlyrobusttocovererrorconditions.Moreover,
the sole bootloader for the STM32F0/L0 platforms is about 13KB when compiled with the
GCC -Os option,whichproducesthemostsize-optimizedbinaryimage.Thisisdefinitelytoo
much for a bootloader. Unfortunately, the HAL has a non-negligible overhead on the final
size of the binary image. A well-designed bootloader is coded reducing to the minimum its
footprint.Thisaspectisoutsidethescopeofthisbook,whichmerelyshowsthefundamental
concepts behind the booting process.
22.3.1 Vector Table Relocation in STM32F0 Microcontrollers
So far, we have seen that in Cortex-M0 based microcontrollers it is not possible to relocate thevector
table as it happens in Cortex-M0+/3/4/7 MCUs. This means that we cannot use the code seen before
(at lines [154:161]) to pass the control to the main firmware, because Cortex-M0 cores always expect
Booting Process 615
to find the vector table at the address 0x0000 0000 , and this one coincides with the vector table of
the bootloader in our scenario.
We can, however, bypass this limitation in a somewhat craftier manner. The idea that we are going
to analyze is based on the fact that the software physical remap allows to alias SRAM memory at
the 0x0000 0000 address, while the original flash memory is always accessible at the 0x0800 0000
address. We can so relocate the vector table of the main firmware before passing the control to
its Reset exception handler by simply copying the “target” vector table inside the SRAM and then
performing the physical remapping. The addresses contained inside the target vector table are still
accessible at their original locations, allowing the correct execution of exception handlers and ISRs.
Figure 7 tries to represent this procedure. On the left side we have the main application (the
bootloader is not shown). Let us suppose for the sake of simplicity that its vector table is placed
at the address 0x0800 2C00 . This means that, starting from the address 0x0800 2C04 we have the
address in memory of Cortex-M0 exception handlers and ISRs. Clearly, these addresses point to
other memory locations above the 0x0800 2C00 address (in Figure 7 they are represented as grey
arrows).
Figure 7: How the vector table can be relocated in STM32F0 microcontrollers
The bootloader works in the following way. It copies the vector table inside the SRAM memory,
startingbyplacingitscontentfromtheinitialaddress 0x2000 0000 .Thismeansthatfromthe 0x2000
0004 memory location we have the addresses in flash memory of exception handlers and ISRs.
Clearly, these addresses still point to the same original flash memory locations, as indicated by
black arrows in Figure 7. At the end of the copy procedure the memory is remapped, so that the
Booting Process 616
0x0000 0000 address now coincides with the 0x2000 0000 address. The control is then transferred
to the Reset exception handler of the main firmware and its execution takes place. In this way we
have bypassed the limitation of Cortex-M0 based MCUs, which do not allow to relocate in memory
the vector table.
The following code shows our bootloader implemented for the STM32F030 microcontroller. Only
the part related to vector table relocation is shown.
Filename: src/main-bootloader.c
146 } else {
147 /* A valid program seems to exist in the second sector: we so prepare the MCU
148 to start the main firmware */
149 MX_GPIO_Deinit(); //Puts GPIOs in default state
150 SysTick->CTRL = 0x0; //Disables SysTick timer and its related interrupt
151 HAL_DeInit();
152
153 RCC->CIR = 0x00000000; //Disable all interrupts related to clock
154
155 uint32_t *pulSRAMBase = (uint32_t*)SRAM_BASE;
156 uint32_t *pulFlashBase = (uint32_t*)APP_START_ADDRESS;
157 uint16_t i = 0;
158
159 do {
160 if(pulFlashBase[i] == 0xAABBCCDD)
161 break;
162 pulSRAMBase[i] = pulFlashBase[i];
163 } while(++i);
164
165 __set_MSP(*((volatile uint32_t*) APP_START_ADDRESS)); //Set the MSP
166
167 SYSCFG->CFGR1 |= 0x3; /* __HAL_RCC_SYSCFG_CLK_ENABLE()
168 already called from HAL_MspInit() */
169
170 /* We are now ready to jump to the main firmware */
171 uint32_t JumpAddress = *((volatile uint32_t*) (APP_START_ADDRESS + 4));
172 void (*reset_handler)(void) = (void*)JumpAddress;
173 reset_handler(); //We start the execution from he Reset_Handler of the main firmware
174
175 for (;;)
176 ; //Never coming here
177 }
178 }
The code we are interested in starts at line 154. Two pointers are defined: one starting at the
beginning of SRAM memory ( pulSRAMBase ) and one at the beginning of the main firmware
( pulFlashBase , which is equal to 0x0800 2C00 following the previous example). The loop at lines
Booting Process 617
[158:162] does a copy of the vector table in SRAM, until the current flash memory location contains
the value 0xAABBCCDD (more about this soon). The MSP is then set to the end of SRAM (this should
be unnecessary, but just in case…) and the physical remap is performed (line 166). The control is
then transferred to the main firmware.
There are several things to note. First of all, to simplify the copy process and to avoid that the
vector table is overwritten by the growing stack, the vector table is copied in SRAM starting from its
beginning, and the rest of the application data (formed by .data section, .bss , heap and stack)
is placed next (see Figure 7). This requires that the linker script of main firmware is properly
configured, as shown below:
MEMORY {
FLASH (rx) : ORIGIN = 0x08002C00, LENGTH = 64K - 10K
RAM (xrw) : ORIGIN = 0x200000B8, LENGTH = 8K - 0xB8
Secondly,weneedawaytoknowwherethevectortablesends.SincenotallIRQsareusuallyenabled
in an application, we can place the sentinel value 0xAABBCCDD inside the first vector entry that comes
right after the last used IRQ. For example, assuming that our main firmware uses the USART2 in
interruptmode,wecanseethatthisIRQisthe46thentryinsidethevectortable.Wecansoplacethat
value in the 47th entry. This can be easily performed by modifying the file startup_stm32f0xxx.S,
as shown below.
Filename: src/startup_stm32f030x8.S
180 .word SPI1_IRQHandler /* SPI1 */
181 .word SPI2_IRQHandler /* SPI2 */
182 .word USART1_IRQHandler /* USART1 */
183 .word USART2_IRQHandler /* USART2 */
184 .word 0xAABBCCDD /* Reserved */
185 .word 0 /* Reserved */
186 .word 0 /* Reserved */
In this way we have a generic and configurable way to set the end of vector table. Looking at the
previous linker script fragment, we can see that we subtract from SRAM memory size the value
0xB8, which is 184 in base 10. Dividing 184 by 4 bytes, we have 46, which corresponds to the last
vector table entry.
Finally,notethatthe SYSCFG isaperipheralseparatedfromtheCortex-Mcore,andweneedtoenable
it by calling the __HAL_RCC_SYSCFG_CLK_ENABLE() .
22.3.2 How to Use the flasher.py Tool
As said before, you can find a Python script named flasher.py inside the book source files for
this chapter. This tool simply allows to upload to the MCU a firmware generated using the Intel
HEX binary format, a specification for binary files developed by Intel several years ago and still
Booting Process 618
widespread especially in low-cost embedded platforms. The source code of this script is not shown
here, but it should be really easy to understand the way it is made. This script requires three
additional modules: pyserial , IntelHex and pycrypto libraries¹⁸.
Linux and Mac users can easily install them using the pip command:
$ sudo pip install intelhex crypto pyserial
Instead, Windows user can install pyserial and IntelHex modules using pip command:
$ sudo pip install intelhex pyserial
while they need to download a pre-compiled release of pycryto library from this website¹⁹ (choose
the release that fits your Python version and platform type).
The script is designed to accept two arguments at command line:
• The serial port corresponding to the Nucleo VCP
– In Windows this is equal to “COMx” string, where ‘x’ must be replaced with the COM
number corresponding to Nucleo VCP (e.g. COM3).
– InLinuxandMacOSthiscorrespondstoafilemappedinthe /dev path(usuallysomething
similar to /dev/tty.usbmodemXXXX ).
• The complete path to the HEX file corresponding to the main firmware.
Figure 8: The binary file in HEX format inside the Eclipse build folder
By default, the GNU MCU Eclipse tool-chain automatically generates the HEX file of the the
compiled firmware. You can find it inside the build folder: this is an Eclipse folder with the same
name of the active build configuration (usually namedDebug or Release). Figure 8 shows the build
¹⁸ pycrypto is a collection of both secure hash functions (such as SHA256 and RIPEMD160), and various encryption algorithms (AES, DES,
RSA, etc.). It is the most widespread cryptographic library for Python, and it is developed and maintained by Dwayne Litzenberger. IntelHex is
a small library that allows to easily manipulate Intel HEX files. It is developed by Alexander Belchenko and distributed under the BSD license.
¹⁹ http://bit.ly/2a5OLCg
Booting Process 619
folder corresponding to active configuration (CH22-APP1) if you are working on the official book
samples repository.
Figure 9: How to derive the full path of the HEX file
You can derive the full path to the HEX file by clicking with the right mouse button on it and then
selecting Properties. You can find the full path inside the Resource view, as shown in Figure 9.
23. Running FreeRTOS
Taking full-advantage of the computing power offered by 32-bit microcontrollers is not easy,
especially for powerful STM32F2/F4/F7 series. Unless our device needs to perform really simple
tasks, the correct allocation of computing resources requires special care during the firmware
development.Moreover,theuseofimpropersynchronizationstructuresandpoor-designedinterrupt
serviceroutinescouldleadtothelossofimportantasynchronouseventsandtooverallunpredictable
behaviour of our device.
Real Time Operating Systems (RTOS) take advantage of the exceptions system provided by Cortex-
M cores to bring to programmers the notion of thread¹, an independent execution stream which
“contends” the MCU with other threads involved in concurrent activities. Moreover, they offer
advanced synchronization primitives, which allow both to coordinate the simultaneous access to
physical resources from different threads and to avoid wasting CPU cycles while waiting for slower
and asynchronous events.
The market segment of RTOSes is quite crowded nowadays, with several commercial as well
as free and open source solutions available to programmers. Being the Cortex-M a standardized
architectures among a lot of silicon manufacturers, STM32 developers can choose from a really
wide portfolio of RTOS systems, depending their need of complexity handling and dedicated (and
maybe commercial) support. ST Microelectronics has adopted one popular free and Open Source OS
as its official tool for the CubeHAL framework: FreeRTOS.
According some statistics, FreeRTOS is the most widespread RTOS on the market today. Thanks to
its dual license that allows the selling of commercial products without any restriction², FreeRTOS
has become a sort of standard in the electronics industry, and it is also widely adopted by the
Open Source community. Although it does not represent the only solution available for the STM32
platform, inthisbookwewillfocus ourattentionexclusivelyonthisOS,sinceitiswhatSTofficially
supports and integrates in the CubeHAL.
¹ Some RTOSes, like FreeRTOS, use the term task to indicate an independent execution stream contending the CPU with other tasks.
However,thisauthorconsidersthisterminologynotappropriate.Traditionally,ingeneralpurposeOperatingSystems,multitasking isamethod
by which multiple tasks, also known as processes, share common hardware resources (mainly the CPU and the RAM). With a multitasking OS,
such as Linux, you can simultaneously run multiple applications. Multitasking refers to the ability of the OS to quickly switch between each
computing task to give the impression that different applications are executing multiple actions simultaneously. A process has one relevant
characteristic: its memory space is physically insulated from other processes, thanks to features offered by the Memory Management Unit
(MMU) inside the CPU. Multithreading extends the idea of multitasking into single processes, so that you can subdivide specific operations
within a single application into individual threads. Each thread could run in parallel. The important trait of threads it that they share the same
memory address space. True embedded architectures, like the STM32 are, do not provide a MMU (only a features-limited Memory Protection
Unit - MPU - is available in some of them). The absence of this unit does not allow to have separated address spaces, since it is impossible to
alias physical addresses to logical ones. This means that they can carry out just one single application, which can be eventually split in several
threads sharing the same memory address space. For this reason, we will talk about threads in this book, even if sometimes we will use the
word “task” when talking about some FreeRTOS APIs or to indicate an activity of the firmware in general terms.
² FreeRTOS is licensed under a modified GPL 2.0 license, which allows companies to sell their devices based on FreeRTOS without any
restriction, unless they do not modify the FreeRTOS code and do not sell/distribute the derived firmware. If this the case, they also need to
distribute the FreeRTOS source code, while leaving their source code closed if they want. For more information about FreeRTOS licensing
model, see this page on the official web site(http://www.freertos.org/a00114.html).
Running FreeRTOS 621
FreeRTOS has been acquired by Amazon AWS in 2017, and now it is officially distributed
under the more permissive and “commercially friendly” MIT license. Following the AWS
acquisition, a new major release (v10.0) has been officially distributed. This new release has
been designed to be a drop-in compatible replacement for FreeRTOS 9.x. This last release is
still not supported by the CubaHAL. This chapter will be updated as soon as FreeRTOS 10.x
is adopted by ST engineers.
23.1 Understanding the Concepts Underlying an RTOS
This paragraph gives a quick introduction to the main concepts underlying real-time
Operating Systems. Experienced users can safely skip it.
Except for the ISRs and exception handlers, all the examples built so far are designed so that our
applications are composed by just one execution stream. Typically, starting from the main() routine,
a large and infinite while loop carries out firmware tasks:
...
while(1) {
doOperation1();
doOperation2();
...
doOperationN();
}
The time spent by each doOperationX() is broadly estimated by the developer, who has the
responsibility to avoid that one of those functions sticks for too much time, preventing other parts
of the firmware from running correctly. Moreover, the calling order of the functions also schedules
their execution, defining the sequence of operation performed by the firmware. This, indeed, is a
form of cooperative scheduling³, where each function concurs to the execution of the next activity
by voluntarily releasing the control periodically.
In this early form of multiprogramming, there is no guarantee that a function cannot monopolize
the CPU. The application designer carefully needs to ensure that every function should be carried
out in the shortest possible time. In this execution model, an “innocent”busy loop can have dramatic
effects. Let us consider the following pseudo-code:
³ Experienced user will point out that it is not correct to talk about cooperative scheduling in this context for two fundamental reasons: the
execution order of tasks is fixed (the “schedule” is computed by the programmer during the firmware development) and each routine is not
able to save its execution context before leaving, that is the stack frame of the doOperationX() routine is destroyed when it returns. As we will
see in a while, co-routine are a generalization of subroutines in non-preemptive multitasking systems.
Running FreeRTOS 622
uint32_t timeKeep = HAL_GetTick();
uint32_t uartData[20];
void blinkTask() {
while(HAL_GetTick() - timeKeep < 500);
HAL_GPIO_TooglePin(GPIOA, GPIO_PIN_5);
timeKeep = HAL_GetTick();
}
uint8_t readUART2Task() {
if(HAL_UART_Receive(&huart2, &uartData, 20, 1) == HAL_TIMEOUT)
return 0;
return 1;
}
while(1) {
blinkTask();
readUART2Task();
}
This code is quite common among several unexperienced embedded developers and, in some
circumstances, it is also correct. However, that code has a subtle weird behaviour. The blinkTask()
is designed so that it busy-spins for 500ms before it releases the control. If data arrives on the UART
interface during this period, the readUART2Task() will certainly loose some data⁴. A better way to
write down the blinkTask() is the following one:
void blinkTask() {
if(HAL_GetTick() - timeKeep > 500) {
HAL_GPIO_TooglePin(GPIOA, GPIO_PIN_5);
timeKeep = HAL_GetTick();
}
}
A simple modification to that routine ensures that we will not loose data coming from the UART in
the majority of situations, unless the UART transfers data really quickly.
As you can see, with cooperative scheduling programmers have a great responsibility in ensuring
their code will not affect the overallactivities of the firmware,introducing performance bottlenecks.
Thevoluntaryreleasingoftheexecutionflowisnottheonlylimitofthecodeseensofar.Letushave
a closer look at the blinkTask() routine. Here we need a global variable⁵, timeKeep , to keep track
of the global tick counter incremented by the CubeHAL every 1ms and to perform a comparison to
check if 500ms are elapsed. This is required because every time a routine exits, its execution context
(that is, the stack frame) is popped from the main stack and it is destroyed. Unless we do not use
⁴ With high baudrates, polling the UART is certainly not correct at all, but here we are interested to the point.
⁵ A local and static variable would have the same effect, however without changing the concept.
Running FreeRTOS 623
some nasty tricks offered by the language⁶, there is no way to exit from a function without losing
its context.
Continuation routines, abbreviated as co-routines or simply coroutines, are program structures that
generalize the concept of subroutines for non-preemptive multitasking, by allowing multiple entry
points for suspending and resuming execution at certain locations. Co-routines require special
support from the run-time of the language, and they are traditionally provided from more high-
level languages like Scheme, but also more widespread languages like Python and Perl provide a
form of co-routines. A co-routine is said not to return but to yield the execution flow. For example,
the blinkTask() could be rewritten using co-routines in this way:
1 void blinkTask() {
2 uint32_t timeKeep = HAL_GetTick();
3 while (1) {
4 if(HAL_GetTick() - timeKeep > 500) {
5 HAL_GPIO_TooglePin(GPIOA, GPIO_PIN_5);
6 timeKeep = HAL_GetTick();
7 }
8 yield; /* Pass the control to another routine, e.g. the scheduler */
9 }
10 }
Co-routinesworksothat,thenexttimethecontrolpassesto blinkTask() ,theexecutionwillresume
fromline3.Wewillnotgointodetailsofhowco-routines areimplementedinlanguagesthatsupport
them. However, this usually involves the creation of separated stacks for each co-routine, which
could call other co-routines that in turn may pass the control to other continuations.
A preemptive multitasking Operating System is a coordinator of physical resources that allows the
execution of multiple computing tasks⁷, each one with its independent stack, by assigning a limited
quantum time (also called slice time) to each task. Every task has a well-defined temporal window,
usually large about 1ms in embedded systems, during which it performs its activities before it is
preempted. The RTOS kernel decides the execution order of the tasks ready to be executed using a
scheduling policy: a scheduler is an algorithm that characterizes the way the OS plans the execution
of tasks.
A task is “moved” in/out from the CPU by a context switch operation. A context switch is performed
bytheOS,thankstohardwarefeatureswewillexplorenext,whichmakesa“snapshot”ofthecurrent
task state by saving the internal CPU registers ( PC , MSP , R0..R15 , etc.) before switching to another
task, which will be able to “re-use” again the CPU for the same quantum time (or even less if “it
wants”).
⁶ Which involves the use of the C setjmp() and longjmp() functions.
⁷ In this paragraph, and only in this one, the term task and thread will be used indiscriminately.
Running FreeRTOS 624
Figure 1: How an OS schedules the tasks execution by assigning them a fixed quantum time
Figure 1 shows how the task preemption works for the case of the example seen before. Here
we are supposing that we have just two tasks: one for the blinkTask() routine and one for the
readUART2Task() one. The OS start scheduling the blinkTask() task, which can “use” the CPU for
1000μs (that is, 1ms)⁸. After the time is gone, the OS schedules the execution of the readUART2Task()
which can now occupy the CPU for the same quantum time. After that period, the CPU will
reschedule the first task, and so on.
Figure 2 shows the way SRAM memory is typically organized by an OS. Each task is represented
by a memory segment containing the Thread Control Block (TCB), which is nothing more than a
descriptor containing all relevant information related to the task execution just “a moment”⁹ before
it is preempted (the stack pointer, the program counter, CPU registers and other few things), plus
the stack itself, that is activation records of those routines currently invoked on the thread stack.
By jumping between several threads, thanks to context switch operations, the OS guarantees the
same execution time to all threads, giving the impression that firmware activities are performed in
parallel.
⁸ Those values of quantum time are indicative, since the exact duration of a quantum is affected by a lot of things. Not last, the overhead
connected with a context switch, which is non-negligible. Moreover, here we are assuming that tasks have all the same priority, which usually
is not true especially in embedded systems.
⁹ This is not true at all, since before a task is preempted several other things take place. However, explaining into details these aspects
is outside the scope of this book. Refer to Joseph Yiu books if interested in deepen how context switch is performed on Cortex-M based
microcontrollers.
Running FreeRTOS 625
Figure 2: How the memory is organized in several tasks by an OS
A Real Time Operating Systems (RTOS) is an OS able to offer the notion of multitasking (or better,
multithreading as seen in note 1) while ensuring response within specified time constraints, often
referred to as deadlines. Real-time responses are often understood to be in the order of milliseconds,
and sometimes microseconds. A system not specified as operating in real-time cannot usually
guarantee a response within any timeframe, although actual or expected response times may be
given. General-purpose Operating Systems (like Linux, Windows and MacOS) cannot be real-time
Operating Systems (even if exist some their derivative releases - especially of Linux - engineered
for real-time applications) for two simply reasons: pagination and swapping. The former allows to
segment the task memory in small chunks named pages, which can be scattered in the RAM and
aliased from the MMU giving the illusion that the process can manage the whole 4GB address space
(even if the computer do not provide that amount of SRAM). The latter allows to swap-in/swap-out
those “unused” pages on an external (and slower) memorization unit (typically a hard drive). Those
two features are intrinsically non-deterministic, and prevent the OS to response to requests in short
and countable time.
An RTOS allows to use the first version of the blinkTask() function minimizing the impact of the
Running FreeRTOS 626
busy loop on the UART transfer process¹⁰. However, as we will see later in this chapter, typically an
RTOS also gives us tools to completely avoid busy loops: using software timers it is possible to ask to
the OS to re-schedule the blinkTask() only when the specified amount of time is elapsed. Moreover,
the RTOS also provides ways to voluntary release the control when we know that it is completely
useless to wait for an operation that will be performed by another task (or if we are waiting for an
asynchronous event).
We have said just one moment before that an RTOS gives a way to voluntary release the control to
other threads. But what if one task does not want to release it? For example, the first release of the
blinkTask() routine could monopolize the CPU up to more than 500ms in the worst case that, given
the typical slice time of 1ms, is a really huge time. So, who has the ability to perform the context
switch? It is impossible to “jump” to other program instructions (a context switch, is a sort of goto
to another program instruction) without loosing one relevant information: the value of the program
counter itself.
The context switch needs a substantial help from the hardware. In Chapter 7 we have seen that
interrupts and exceptions are a source of multiprogramming. The way they are handled by the
Cortex-M core allows to jump to the exception handler without loosing the current execution
context. By taking advantage of a dedicated hardware timer, usually the SysTick one, the RTOS
uses the periodic interrupt generated on the overflow event to perform the context switch. This
timer is configured to overflow (or underflow in case of the SysTick, which is a downcounter timer)
every 1ms. The RTOS then captures the exception and saves the current execution context in the
TCB, passing the control to the next task in the scheduling list by restoring its execution context and
exitingfromthetimerinterrupt.Thepreemptedthreadswillnotknowanythingthatthishappened¹¹.
¹⁰ This does not mean that using an RTOS we can write bad code without impacting on the overall performances. This only means that, a
true preemptive scheduler can guarantee a higher multiprogramming degree, ensuring that all threads have the same CPU time-slice. Unless
we mess with task priorities, as we will see later.
¹¹ However, this could not correspond to what an RTOS actually does. The story here is more complex, and it is related to the specific
hardware architectures and to the way interrupts are prioritized. During the execution of an interrupt handler, another interrupt with a higher
priority could suspend the execution of the current interrupt, as seen inChapter 7. But when this happens, the CPU cannot switch to thethread
mode (which is the regular mode when the normal code is executed) by performing the task switch without prior exiting from all interrupts
(which run in the handler mode - a special mode provided by Cortex-M core during the exception handling). This means that if the SysTick
IRQ takes place while another IRQ is active, the SysTick exception handler cannot perform the context switch (that is to pass the control to
another task running in thread mode), because another code running in handler mode has been preempted and needs to complete its activities.
Usually this is solved by deferring the effective context switch operation to the PendSV Handler, which is an exception configured to run at
the lowest priority. However, this is just one way to implement the context switch. If interested in deepen this topic, you have to consult the
source code or the documentation of your RTOS.
Running FreeRTOS 627
Figure 3: The impact of the context switch on tasks scheduling
In light of the considerations that we have shown up to this point, the Figure 1 needs to be updated
with the one shown in Figure 3 where the time spent by the OS while performing context switch
is also considered. Context switches are usually computationally intensive, and much of the design
of operating systems is to optimize the use of context switches. Special care must be placed when
developers decide to change the underflow frequency of the SysTick timer (often increasing it),
which also affects the slice time of each individual task, and hence the number of context switches
per second.
Before we can start doing practical things with an RTOS, we need to explain just one last concept.
What about the case when a task wants to voluntary leave the control? In this case often RTOSes
use the SVC (SuperVisor Call) instruction implemented by Cortex-M processors, which causes that
the SVC_Handler exception handler is called, or force the PendSV exception to be raised. Explaining
when they use one and when the other is outside the scope of this book and it is also a design choice
of OS maker. For more information, refer to Joseph Yiu¹² books if interested in deepen these topics.
ThisisjustanintroductiontothecomplextopicsunderlyinganRTOS.Wewillanalyzeseveralother
concepts, mainly related to the synchronization of concurrent tasks, later in this chapter. We will
now start seeing the most relevant features of FreeRTOS.
23.2 Introduction to FreeRTOS and CMSIS-RTOS
Wrapper
As said at the beginning of this chapter, FreeRTOS is the OS chosen by ST as official RTOS for its
Cube distribution. Recent releases of CubeMX offer a good support to this OS, and including it as
middleware component in a project is really easy. A lot of additional modules of the CubeHAL (like
the LwIP stack) rely on the services provided by it.
However, ST did not limit its integration in shipping FreeRTOS in its CubeHAL distribution. It
has built a complete CMSIS-RTOS wrapper over it, allowing to develop CMSIS-RTOS compliant
¹² http://amzn.to/1P5sZwq
Running FreeRTOS 628
applications.WehavetalkedaboutCMSIS-RTOSinChapter1,whenweintroducedthewholestack.
TheideabehindtheCMSISinitiativeisthat,usingacommonstandardizedsetofAPIsamongseveral
siliconmanufacturersandsoftwarevendors,itispossibleto“easily”portourapplicationondifferent
microcontrollersfromothervendors.Forthisreason,wewillintroducetheFreeRTOSfunctionalities
using as much as possible the CMSIS-RTOS API.
23.2.1 The FreeRTOS Source Tree
FreeRTOS source code is organized in a compact source tree, which spreads over a dozen of files.
The Figure 4 shows how FreeRTOS is organized inside the CubeHAL¹³. The files .c found in the
root folder contain the main OS features (for example, the file tasks.c contains all those routines
related to the thread management). The sub-folder include contains several include files used to
define the most of C struct and macros used by the OS. The most relevant of these files is the
FreeRTOSConfig.h one, which includes all the user-defined macros used to configure the RTOS
according user’s needs. The other sub-folder contained in the root tree is portable . FreeRTOS is
designed to run on about 30 different hardware architectures and compilers, while ensuring the
same consistent API. All platform-specific features are organized inside two files¹⁴, port.c and
portmarco.h , which are in turn collected in the sub-folder specific of the given architecture. For
example, the folder portable/GCC/ARM_CMO contains port.c and portmarco.h files providing the
code specific for the Cortex-M0/0+ architecture and the GCC compiler.
Finally, the CMSIS-RTOS folder contains the CMSIS-RTOS compliant layer developed by ST on the
top of FreeRTOS.
Figure 4: The FreeRTOS source tree organization in the CubeHAL
The next two paragraphs show how to import the FreeRTOS distribution inside an Eclipse project,
either manually or using the CubeMXImporter tool.
¹³ FreeRTOS is available in all CubeHALs, inside the Middleware/Third_Party/Source folder.
¹⁴ ThispartofFreeRTOSisconsideredseparatedfromthecoreFreeRTOSsourcethree,anditissaidtoimplementtheportlayer ofFreeRTOS.
Running FreeRTOS 629
23.2.1.1 How to Import FreeRTOS Manually
If you want to import the FreeRTOS source tree into an existing project, you can proceed in the
following way.
1. Create an Eclipse folder named Middleware/FreeRTOS inside the root of the project.
2. Drag into this folder the content of the STM32Cube_FW/Middlewares/Third_Party/FreeRTOS/-
Source excluding the Portable subdirectory.
3. Now create a sub-folder named portable/GCC¹⁵ inside the Middleware/FreeRTOS Eclipse
folder, and one named portable/MemMang.
4. Dragthefolder STM32Cube_FW/Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_-
CMx corresponding to the architecture of your STM32 MCU (for example, if you have
an STM32F4, which is based on a Cortex-M4 core, pick the folder ARM_CM4F ) inside the
portable/GCC Eclipse folder.
5. Drag just one¹⁶ of the files contained inside the STM32Cube_FW/Middlewares/Third_Par-
ty/FreeRTOS/Source/portable/MemMang folder inside the portable/MemMang Eclipse folder.
This folder contains 5 different memory allocation schemes used by FreeRTOS. We will study
them more in depth later. It is ok to use the heap_4.c for the moment.
At the end of the import process, you should have a project structure like the one shown in Figure
5
Figure 5: The Eclipse project structure after the import of FreeRTOS
Read Carefully
When we create new folders in an Eclipse project, by default Eclipse automatically excludes
them from the building process. So we need to enable compilation of the Middlewares
folder by right-clicking on in the Project Explorer tree-pane, then selecting Resource
configuration->Excludefrombuild,anduncheckingalltheprojectconfigurationsdefined.
¹⁵ If you are using another tool-chain, you have to rearrange the instructions accordingly.
¹⁶ It is ok to import all memory management schemes and exclude from compilation those unneeded. It is up to you how organize in the
best way the project.
Running FreeRTOS 630
Now we need to define the FreeRTOS config file and include the FreeRTOS headers in the project
settings. So, rename the Middlewares/FreeRTOS/include/FreeRTOSConfig_template.h file in
Middlewares/FreeRTOS/include/FreeRTOSConfig.h. Next, go in the Project Settings->C/C++
Build->Settings->Cross ARM C Compiler->Include section and add the entries:
• "../Middlewares/FreeRTOS/include"
• "../Middlewares/FreeRTOS/CMSIS_RTOS"
• "../Middlewares/FreeRTOS/portable/GCC/ARM_CMx" ¹⁷
as shown in Figure 6.
Figure 6: The include paths to add to project settings
23.2.1.2 How to Import FreeRTOS Using CubeMX and CubeMXImporter
The CubeMXImporter tool allows to automatically import a project generated with CubeMX and
with the FreeRTOS middleware. Once you have configured the MCU peripherals in CubeMX, you
can easily enable the FreeRTOS middleware by checking the flag Enabled in the corresponding IP
Tree entry, as shown in Figure 7.
¹⁷ Arrange this directory according your specific port layer.
Running FreeRTOS 631
Figure 7: How to enable the FreeRTOS middleware in CubeMX
Once the CubeMX project is generated, you can follow the same instructions reported in Chapter 4.
In the configuration section it is possible to set the FreeRTOS configuration parameters. We will
analyze the most relevant ones during this chapter. When you generate the CubeMX project,
CubeMX will ask you if you want to choose a separated timebase generator for the HAL, leaving the
SysTickonlyastimebasegeneratorfortheRTOS(seeFigure8).CubeMXasksthisbecauseFreeRTOS
is designed so that it automatically sets the SysTick IRQ priority to the lowest one (highest priority
number). This is an architectural requirement of FreeRTOS, which unfortunately conflicts with the
way the HAL is designed.
As said several other times before, the STM32Cube HAL is built around a unique timebase source,
which usually is SysTick timer. SysTick_Handler() ISR automatically increments the global tick
counter every 1ms. The HAL uses this feature by using the HAL_Delay() function really often in
several HAL routines. These are in turn called by the HAL_<PPP>_IRQHandler() functions, which
are executed in the context of an ISR (for example, the HAL_TIM_IRQHandler() is called from the
ISR of a timer). If the SysTick IRQ is not configured to run at the highest priority interrupt (which
is 0 in Cortex-M based processors), then calling the HAL_Delay() from an ISR context may lead to
deadlocks¹⁸ if the priority of the ISR that makes call to the HAL_Delay() is higher than the one of
the SysTick timer (and this is always true if you use FreeRTOS, as said before). So, it is best to use
another timer for the HAL.
Figure 8: The warning message suggests to choose a different timebase generator for the HAL
To change the HAL timebase source, follow the instructions written in Chapter 11.
¹⁸ In concurrent programming, a deadlock is a situation in which two or more concurrent execution streams are each waiting for the
other to finish, and thus neither ever does. Incur in deadlock is anything but difficult, and all programmers soon or later will encounter this
hard-to-debug event.
Running FreeRTOS 632
23.2.1.3 How to Enable FPU Support in Cortex-M4F and Cortex-M7 Cores
If you have a Cortex-M4F or a Cortex-M7 based STM32 MCU, and if you try to compile the project,
you will see several errors generated by the assembler, like the ones shown in Figure 9.
Figure 9: The errors generated by GCC while trying to compile FreeRTOS sources without enabling the FPU unit
Those errors are caused by the fact that Cortex-M4F or Cortex-M7 architectures provide a dedicate
Floating Point Unit (FPU), which allows to process floating point operations directly in hardware,
without the need of dedicated, and necessarily slow, functions provided by the C run-time library.
ProcessorsequippedwithanFPUunitimplementadditionalhardwareregistersthatneedtobesaved
during a context switch operation. For this reason, the FreeRTOS GCC port for M4F/7 architectures
expects that the FPU is enabled, which by default is disabled.
To enable it go in the Project Settings->C/C++ Build->Settings->Target Processor section and
select the entry FP instructions (hard) in the Float ABI field, and for the FPU Type field select
fpv4-sp-d16 if you have a Cortex-M4F based STM32 MCU, or fpv5-sp-d16¹⁹ if you have a Cortex-
M7 based microcontroller. In case you are working on the ultimate new STM32F76xx MCUs, which
provide a double precision FPU unit, then you have to select the fpv5-d16 entry.
Now you have to rebuild the whole source tree.
23.3 Thread Management
Once we have configured the Eclipse project, we can start coding using the CMSIS-RTOS layer and
hence FreeRTOS.
AtthebaseofallRTOSesthereisthenotionofthread,whichwehaveanalyzedinthefirstparagraph
of this chapter. A thread is nothing more than a C function, which FreeRTOS requires to be defined
in the following way:
¹⁹ fpv4-sp-d16meansthattheMCUimplementsafloating-pointunitconformingtotheVFPv4-D16 architecture,singleprecision(sp),while
fpv5-sp-d16 refers to the VFPv5-D16 architecture, single precision (sp).
Running FreeRTOS 633
void ThreadFunc(void const *argument) {
while(1) {
...
}
osThreadTerminate(NULL);
}
The function osThreadTerminate() is used to terminate a thread, and it accepts theThread ID (TID),
which we are going to see in a while. A thread is usually made of an infinite loop that contains
the thread instructions. Placing the osThreadTerminate() outside that loop is usually a precaution
in case the control exits from that loop, because it is not correct to terminate a thread by simply
returning from its function. Passing the NULL parameter to the osThreadTerminate() function will
cause that FreeRTOS terminates the current thread.
To start a new thread with the CMSIS-RTOS API we use the following function:
osThreadId osThreadCreate(const osThreadDef_t *thread_def, void *argument);
The osThreadDef_t is the thread descriptor, a C struct defined in the following way:
typedef struct os_thread_def {
char *name; /* Thread name */
os_pthread pthread; /* Pointer to thread function */
osPriority tpriority; /* Initial thread priority */
uint32_t instances; /* Maximum number of instances of that thread function:
this is meaningless in FreeRTOS */
uint32_t stacksize; /* Stack size requirements in words; 0 is default stack size */
#if( configSUPPORT_STATIC_ALLOCATION == 1 )
uint32_t *buffer; /* Stack buffer for static allocation */
osStaticThreadDef_t *controlblock; /* Control block to hold thread's data
for static allocation */
#endif
} osThreadDef_t;
However,theCMSIS-RTOSAPIprovidesaconvenientmacro, osThreadDef() ,todefineandinitialize
the parameters of a thread descriptor. Now it is the right time to see a practical example.
Running FreeRTOS 634
Filename: src/main-ex1.c
12 int main(void) {
13 osThreadId blinkTID;
14
15 HAL_Init();
16 Nucleo_BSP_Init();
17
18 osThreadDef(blink, blinkThread, osPriorityNormal, 0, 100);
19 blinkTID = osThreadCreate(osThread(blink), NULL);
20
21 osKernelStart();
22
23 /* Infinite loop */
24 while (1);
25 }
26
27 void blinkThread(void const *argument) {
28 while(1) {
29 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
30 osDelay(500);
31 }
32 osThreadTerminate(NULL);
33 }
34
35 void SysTick_Handler(void) {
36 HAL_IncTick();
37 HAL_SYSTICK_IRQHandler();
38 osSystickHandler();
39 }
Lines[17:18]defineandcreateanewthread,assigningtoitthename "blink" andpassingthepointer
tothe blinkThread() function,whichwillrepresentourthread.Thenanormalpriorityisassignedto
the thread (more about this soon). The fourth parameter refers to the number of maximum instances
a thread can have, but it is not used by FreeRTOS, so it is meaningless in this case. Finally, the last
parameter defines the stack size.
The CMSIS-RTOS API expresses the thread stack size in bytes, and you will find this
information in the CMSIS-RTOS layer on the top of FreeRTOS developed by ST. However,
FreeRTOSdefinesthestacksizeasamultipleofthewordsize,whichinaCortex-Mprocessor
is 32-bit, and hence 4 bytes. This means that, the value we pass to the osThreadDef() macro
is multiplied by four internally by FreeRTOS. This says it all about the effective portability
of these abstraction layers.
osThreadCreate() then effectively creates the new thread and asks to the kernel to schedule its
execution, returning the Thread ID (TID): this is used by other APIs to manipulate the thread status
Running FreeRTOS 635
and its configuration. Note that, once the thread is defined using the osThreadDef() macro, we
use the macro osThread() to refer to that thread in other part of the code. The second parameter
of the osThreadCreate() function is an optional parameter to pass to the thread. Finally, we start
the kernel scheduler by using the function osKernelStart() , which never returns unless something
wrong happens.
The function blinkThread() is nothing more than the omnipresent blinking application. The only
notably difference is the use of the osDelay() function instead of the classical HAL_Delay() : the
osDelay() is designed so that the thread will remain in blocked state for 500ms without impacting
on the CPU performances. After that time, the thread will be resumed and the LD2 LED will be
toggled again. We will talk more about the osDelay() function later.
Finally, note that, since we are using here the SysTick as timebase for the FreeRTOS kernel, we need
to add a call to the function osSystickHandler() inside the exception handler of the timer, and
configure it to generate a tick every 1ms (this is performed in the SystemClock_Config() routine, as
shown in Chapter 10).
23.3.1 Thread States
In FreeRTOS a thread can have two major execution states: running and not running. On a single-
core architecture, just one thread at once can be in running state.
In FreeRTOS the not running state is characterized by several sub-states, as shown in Figure 10.
A not running thread can be ready (this is also the state of new threads), that is it is ready to be
scheduled for execution by the RTOS kernel.
A running thread can voluntary suspend its execution, by calling the osThreadSuspend() function,
which accepts the TID of the thread to suspend or NULL if called by the same thread. In this case the
thread assumes the suspended²⁰ state. To resume a suspended thread the osThreadResume() is used.
²⁰ In FreeRTOS this state is called stopped, as shown in Figure 10.
Running FreeRTOS 636
Figure 10: The possible states of a thread in FreeRTOS
A running thread can put itself in blocked state by start waiting for “an external” event. This event
could be, for example, a synchronization primitive (e.g. a semaphore) that will be unlocked from
another thread. Another source of blocking state is the osDelay() function, which places the thread
in blocked state until the specified delay time does not pass. Ablocked thread can be placed in ready
state, and hence it becomes ready to be scheduled for execution, or in suspended state.
It is important to clarify, to avoid any misunderstanding, that a suspended or blocked thread needs
the intervention of an external entity to return in ready state.
23.3.2 Thread Priorities and Scheduling Policies
In the first example we have seen that each thread has a priority. But which practical effects have
priorities on threads execution? Priorities impact on the scheduling algorithm, allowing to alter
the execution order in case a thread with a higher priority turns in ready state. Priorities are a
fundamental aspect of RTOSes, and provide the foundation blocks to achieve short responses to
deadlines. It is important to underline that thread priority is not related to the priority of IRQs.
Imagine you are designing the control board of a machine that could potentially cause injuries to
workers in critical situations. Usually, this type of machines has an emergency stop button. That
button could be connected to one pin of the MCU, and the corresponding interrupt may resume
a blocked thread waiting for this event. This thread may be designed to shutdown an engine, or
something like that, and to place the machine in a safe state.
Once the IRQ fires, the task running at that moment is formally running but it is not effectively
running on the CPU, which is servicing the ISR. By invoking proper OS routines, that we will see
later, the OS places our emergency thread in ready mode, but we have to be sure that it will be the
first thread to be executed. Priorities allow to programmers to distinguish deferrable activities from
not-deferrable ones.
FreeRTOS has a user-defined priority system, which gives a great degree of flexibility in defining
priorities. The lowest priority (which means that threads with this priority will always be passed
Running FreeRTOS 637
over by higher priority threads, if ready to be executed) is equal to zero. The user can then assign
increasing priorities to more important threads, up to the maximum value defined by the symbolic
constant configMAX_PRIORITIES defined in the FreeRTOSConfig.h file.
Table 1: The fixed priorities defined in the CMSIS-RTOS specification
Priority level Description
osPriorityIdle idle priority (the lowest one, corresponding to priority of the Idle thread)
osPriorityLow low priority
osPriorityBelowNormal below normal priority
osPriorityNormal normal priority (default)
osPriorityAboveNormal above normal priority
osPriorityHigh high priority
osPriorityRealtime real-time priority (highest)
CMSIS-RTOS, instead, has a well-defined priority scheme, made of eight levels (reported in Table
1), which are mapped on the FreeRTOS priorities. The function
osStatus osThreadSetPriority(osThreadId thread_id, osPriority priority);
allows to change the priority of an existing thread, while the function
osPriority osThreadGetPriority(osThreadId thread_id);
allows to retrieve the priority of an existing thread.
It is quite meaningless to talk about thread priorities without knowing the exact scheduling policy
adopted by the RTOS. FreeRTOS provides three different scheduling algorithms, which are selected
by the right combination of the symbolic constants configUSE_PREEMPTION and configUSE_TIME_-
SLICING , both defined in the FreeRTOSConfig.h file. Table 2 shows the combination of these two
macros to select the wanted scheduling algorithm.
Table 2: How to select the wanted scheduling policy in FreeRTOS
configUSE_PREEMPTION configUSE_TIME_SLICING Scheduling algorithm
1 1 Prioritized preemptive scheduling with time slicing
1 0 or undefined Prioritized preemptive scheduling without time
slicing
0 any value Cooperative scheduling
Let us give a quick introduction to these algorithms.
• Prioritized preemptive scheduling with time slicing: this is the most common algorithm
implemented by all RTOSes, and it works in this way. Every thread has a fixed priority,
Running FreeRTOS 638
which is assigned during its creation. The scheduler will not never change this priority, but
the programmer is free to reassign a different priority by calling the osThreadSetPriority()
function. In this mode, the scheduler will immediately preempt a running thread if one with
a higher priority becomes ready to be executed. Being preempted means being involuntary
(without explicitly yielding or blocking) moved out of the running state into the ready state to
allow the higher priority thread to become running. The time slicing (also known as quantum
time)isusedtoshareCPUprocessingtimebetweenthreadswiththesamepriority,evenwhen
they leave the control by explicitly yielding or blocking. When a thread “consumes” its time
slice, the scheduler will select the next running thread in the scheduling list (if available) by
assigning it the same slice time. If there are no availableready threads, the scheduler will mark
asrunning aspecialthreadnamedidle,whichwewilldescribenext.Theslicetimecorresponds
totheticktimeoftheRTOS,whichbydefaultisequal1kHz,thatis1ms.Thiscanbechangedby
configuring the macro configTICK_RATE_HZ , and rearranging the UEV frequency of the timer
used as timebase generator. Tuning this value it is up to the specific application, and it also
depends on how fast the MCU runs. The slower the MCU runs, the slower the tick time should
be. Usually a value ranging from 100Hz up to 1000Hz is suitable for a lot of applications.
• Prioritized preemptive scheduling without time slicing²¹: this algorithm is almost equal to
the previous one, except for the fact that once a thread enters in running state, it will leave
the CPU only on a voluntary basis (by blocking, stopping or yielding) or if a higher priority
thread enters in ready state. This algorithm minimizes a lot the impact of the context switch
on the overall performances, since the number of switches is dramatically reduced. However, a
bad designed thread may monopolize the CPU, causing unpredictable behaviour of the whole
device.
• Cooperative scheduling: when this algorithm is used, a thread will leave the CPU only on a
voluntary basis (by blocking, stopping or yielding). Even if a higher priority thread becomes
ready, the OS will never preempt the current thread, and it will reschedule it again in case of
an external interrupt. This form of scheduling gives all the responsibility to the programmer,
which must carefully design the threads as if he were designing a firmware without using an
RTOS.
Special care must be placed when assigning priorities to threads, even if we are using a prioritized
preemptive scheduling with time slicing. Let us consider this example.
²¹ This is the default scheduling policy configured by CubeMX for STM32F0/L0 microcontrollers.
Running FreeRTOS 639
Filename: src/main-ex2.c
13 int main(void) {
14 HAL_Init();
15
16 Nucleo_BSP_Init();
17
18 osThreadDef(blink, blinkThread, osPriorityNormal, 0, 100);
19 osThreadCreate(osThread(blink), NULL);
20
21 osThreadDef(uart, UARTThread, osPriorityAboveNormal, 0, 100);
22 osThreadCreate(osThread(uart), NULL);
23
24 osKernelStart();
25
26 /* Infinite loop */
27 while (1);
28 }
29
30 void blinkThread(void const *argument) {
31 while(1) {
32 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
33 osDelay(500);
34 }
35 osThreadTerminate(NULL);
36 }
37
38 void UARTThread(void const *argument) {
39 while(1) {
40 HAL_UART_Transmit(&huart2, "UARTThread\r\n", strlen("UARTThread\r\n"), HAL_MAX_DELAY);
41 }
This time we have two threads, one that blinks the LD2 LED and one that constantly prints on
the UART2 a message. The UARTThread() is created with a priority higher than the blinkThread()
one. Running this example, you can see that the LD2 LED never blinks. This happens because
UARTThread() is designed to continuously do something and when its quantum time expires, it is
still in ready state and, having a higher priority, it is rescheduled for execution. This clearly proves
that priorities must be used carefully to prevent other processes from starving²².
23.3.3 Voluntary Release of the Control
A running thread can release the control (it is said to yield the control), if the programmer knows
that it is useless to consume CPU cycles, by calling the function
²² In concurrent programming, the starvation happens when a thread is perpetually denied necessary resources to process its work.
Starvation usually is caused by a bad synchronization among threads, but even by a wrong priority allocation scheme. The starvation is
an unwanted condition that no programmer would want never reach, and sometimes identify its origin can be a nightmare.
Running FreeRTOS 640
osStatus osThreadYield(void);
This causes a context switch, and the next ready thread in the scheduling list is placed in running
state. The osThreadYield() has a really relevant role if the cooperative scheduling is the scheduler
policy.
23.3.4 The idle Thread
ACPUneverstops,unlessweenteroneofthelow-powermodesofferedbySTM32microcontrollers.
This means that, if all threads in a system are blocked or stopped waiting for external events, then
we need a way to “do something” while waiting for other threads becoming active again. For this
reason, all Operative Systems provide a special tasks named idle, which is scheduled during system
inactive states, and its priority is defined as the lowest possible. For this reason, it is common to say
that the lowest priority corresponds to the idle priority.
In FreeRTOS versions prior to version 9, whenever a thread was deleted, the memory allocated by
FreeRTOS to the thread was freed by the idle thread. In FreeRTOS version 9, if one thread deletes
another thread, then the memory allocated by FreeRTOS to the deleted thread is freed immediately.
However,ifathreaddeletesitself,thenthememoryallocatedbyFreeRTOStothethreadisstillfreed
by the idle thread. Note that, in all cases, it is only the stack and task control block (TCB) allocated
to the thread by the RTOS that get freed automatically.
The idle thread also plays an important role in low-power designs, as we will discover later in this
chapter.
Running FreeRTOS 641
A Word About Concurrent Programming
You will be astonished by fantastic numbers presented to you by designers of Real
Time Operating Systems. They will say to you that their OS is able to fork hundred
of thousands of threads per second, showing stunning context switch performances.
Know that, from a practical point of view, this has the same utility of pub talks.
Figure 11: What usually happens when the number of thread increases too much
I often review projects sent to me from readers of this book (but sometimes I have
seen projects, having the same bad approach, made by professionals - whether you
believe it or not) where you can see tens of threads spawn around in the code that
do nothing relevant. Sometimes you can also find threads that do nothing more than
forking another thread after a comparison.
Theorists of concurrent programming will teach you that the more concurrent
streams you have the more issue you will probably have. Governing threads may
be really hard, and often the cost involved in synchronizing them overtakes the
advantage in using them. Moreover, the same operation of spawning a new thread
has a non-negligible cost. And the same applies to the context switch.
Multithreadedprogrammingmustalwayshandledwithcare,especiallyonembedded
systems, where the SRAM is often really limited. Remember: keep it simple.
23.4 Memory Allocation and Management
InthetwopreviousexampleswestartedusingFreeRTOSwithoutdealingtoomuchwiththememory
allocation for threads and the other structures used by the OS. The only exception is represented by
the last parameter passed to the osThreadDef() macro, which corresponds to the amount of stack to
reserve to the thread. FreeRTOS, however, not only needs sufficient memory for threads allocation,
butitalsousesadditionalSRAMportionsfortheallocationofitsinternalstructures(listofTCBs,and
so on). The same applies to other synchronization primitives we will study later, such as semaphores
Running FreeRTOS 642
and mutexes. Where is this memory exactly taken from?
Traditionally, FreeRTOS implemented a dynamic allocation model until the 8.x release. This
constituted an important limitation, because in some application domains the dynamic memory
allocation is strongly discouraged or even expressly prohibited. Even if, as we will see soon, one
of five dynamic allocators implemented by FreeRTOS answers to the majority of requirements
about memory allocation in these application domains, unfortunately this FreeRTOS characteristic
prevented its usage when this limitation applies. Starting from the latest 9.x release, FreeRTOS
implements two memory allocation models: a full static and a dynamic one.
Two macros are used to ebable the memory allocation model: configSUPPORT_STATIC_ALLOCATION
and configSUPPORT_DYNAMIC_ALLOCATION . Both of them can assume the values 0 or 1 to disable/en-
able the corresponding memory model. It is important to underline that the two memory models
are not mutually exclusive: it is possible to use both of them simultaneously according to the user
need. As we will see later, the two memory models force the usage of separated APIs.
23.4.1 Dynamic Memory Allocation Model
FreeRTOS implements a dynamic memory allocation model, which uses regions of the SRAM to
allocate all OS internal structures, including TCBs. When compared to static allocation model, the
dynamic one has some non-negligible advantages:
• The memory allocation occurs automatically, within the RTOS API functions.
• Developers do not need to concern with allocating memory themselves.
• The RAM used by an RTOS object can be re-used if the object is deleted, potentially reducing
the application’s maximum RAM footprint.
• RTOS API functions are provided to return information on heap usage, allowing the heap size
to be optimized.
• FreeRTOS provides five dynamic memory allocation schemes, and they can be chosen to best
suite the application requirements.
• Fewer function parameters are required when an object is created.
FreeRTOS does not make use of the classical malloc() and free() functions provided by the C
run-time library²³, because:
1. they uses a lot of code space, increasing the size of the firmware;
2. they are not designed to be thread safe;
3. they are not deterministic (the amount of time taken to execute the function will differ from
call to call).
²³ With one notably exception represented by the heap_3.c allocator, as we will see soon.
Running FreeRTOS 643
So, FreeRTOS provides its own dynamic allocation scheme to handle the memory it needs, but since
there are several ways to do it, each one with its benefits and tradeoffs, FreeRTOS is designed so that
this part is abstracted from the rest of the core OS, and it provides five different allocation schemes
the user can choose from, according his specific needs. The pvPortMalloc() and vPortFree() are
the most important functions implemented in each scheme, and their name clearly says what they
do.
This five schemes are not part of the FreeRTOS core, but they are part of the port layer, and
they are implemented inside five C source files, named heap_1.c .. heap_5.c , contained inside the
portable/MemMangfolder.BycompilingoneofthesefilestogetherwiththerestofFreeRTOScode,
we automatically choose that allocation scheme for our application. Moreover, we can eventually
provide our allocation model by implementing this API layer (we essentially need to implement 5
functions, in the worst case) according our specific needs.
23.4.1.1 heap_1.c
A lot of embedded applications use an RTOS to logically divide the firmware in blocks. Each block
has its own features, and often it runs independently from other blocks. For example, suppose that
you are developing a device with a TFT display (maybe the controller of a modern dishwasher).
Usually the firmware is partitioned in few threads, where one is the responsible of the graphical
interaction (it updates the display by printing information and showing stunning graphical widgets)
andotherthreadsareresponsibleofmanagingthewashingprogram(andsothehandlingofsensors,
motors, pumps and so on). These applications usually have a main() that spawns the threads (as we
have done in the past examples), and almost nothing more is initialized by the OS once it starts
spinning. This means that the memory allocator does not have to consider any of the more complex
allocation issues, such as determinism and fragmentation, and it can be simplified.
heap_1.c allocator implements a very basic version of the pvPortMalloc() , and does not pro-
vide vPortFree() . Applications that never delete a thread, or other kernel objects like queues,
semaphores, etc, are suitable to use this memory allocation scheme. Those application domains,
where the use of dynamically allocated memory is discouraged, may benefit from this allocation
scheme,sinceitoffersadeterministicapproachtothememorymanagement,avoidingfragmentation
(because the memory is never deallocated).
heap_1.c allocatorsubdividesastaticallyallocatedarrayinsmallchunks,ascallsto pvPortMalloc()
are made. This is indeed the FreeRTOS heap. The total size of this array (expressed in bytes) is
defined by the macro configTOTAL_HEAP_SIZE in the FreeRTOSConfig.h file. The only tradeoff with
this allocation scheme is that, being the whole array allocated at compile time, the application will
consume al lot of SRAM even if it does not entirely use it. This means that programmers have to
carefully choose the right value for configTOTAL_HEAP_SIZE size.
Running FreeRTOS 644
It is important to remark an important thing. The memory of C programs is traditionally
partitioned in two relevant regions: stack and heap. The heap is said to grow dynamically
at runtime, and it grows in the opposite direction of the stack. As you can see, however,
heap_1.c allocator has nothing related to heap of the whole application, since it uses an
array declared as static , which is allocated in .data section as we have learned in Chapter
13, to store the objects it needs dynamically. It is a form of dynamic allocation for sure, but
notconnectedwiththeuseof malloc() and free() functions.Thismeansthatwecansafely
use them in our application, evenif their usage is non encouraged in embedded applications.
23.4.1.2 heap_2.c
heap_2.c also works by subdividing a statically allocated array, which is dimensioned by the
configTOTAL_HEAP_SIZE macro. It uses a best-fit algorithm to allocate the memory and, unlike the
Heap_1.c allocation scheme, it allows memory to be freed. This algorithm is considered deprecated
and not suitable for new designs. The Heap_4.c is the better alternative to this allocator. For this
reason,wewillnotgointodetailsofhowitworks.Ifinterested,youcanconsulttheofficialFreeRTOS
documentation²⁴.
23.4.1.3 heap_3.c
heap_3.c uses the conventional C malloc() and free() functions to perform memory allocation.
This means that the configTOTAL_HEAP_SIZE parameter has no effects on the memory management,
since the malloc() is designed to manage the heap by itself. This means that we need to configure
our linker scripts accordingly, as shown in Chapter 13. Moreover, consider that the malloc()
implementation changes from the one provided by the newlib-nano and the regular newlib .
However, the more versatile implementation provided by the newlib library requires a lot of more
flash space.
heap_3.c makes malloc() and free() thread-safe by temporarily suspending FreeRTOS scheduler.
For more information about this, refer to the official FreeRTOS documentation.
23.4.1.4 heap_4.c
heap_4.c works in the same way of heap_1.c and heap_2.c . That is, it uses a statically allocated
array, dimensioned by the value of the configTOTAL_HEAP_SIZE macro, to store the objects allocated
at run-time. However, it has a different approach during the allocation of memory. In fact, it uses a
first fit algorithm, which combines adjacent free blocks into a single large block, reducing the risk
of memory fragmentation. This technique, commonly used by the garbage collector in languages
with dynamic and automatic memory allocation, is also called as coalescing.
Unfortunately, this behaviour of the heap_4.c allocator causes that it is non-deterministic: the
allocation/deallocation of many small objects, together with the creation/destroy of threads, could
²⁴ http://bit.ly/1PMSPRM
Running FreeRTOS 645
cause a lot of fragmentation, which requires more computing processing to pack the memory.
Moreover there is no guarantee that the algorithm avoids memory leaks at all. However, it is usually
faster than the most standard implementation of malloc() and free() , especially the ones provided
by the newlib-nano lib.
Explaining in detail the heap_4.c algorithm is outside the scope of this book. For more information
refer to the FreeRTOS documentation²⁵.
23.4.1.5 heap_5.c
heap_5.c uses the same algorithm of the heap_4.c allocator, but it allows to split the memory pool
among different non contiguous memory regions. It is especially useful for STM32 MCUs providing
the FSMC controller, which allows to transparently use external SDRAMs to increase the whole
RAM. Programmer may decide to allocate some heavy used thread in the internal SRAM memory
(or the CCM memory, if available) and then use the external SDRAM for less relevant objects like
semaphores and mutexes.
By defining a custom linker script, it is possible to allocate two pools in two memory regions, and
then use the vPortDefineHeapRegions() function from FreeRTOS to define them as memory pools.
However, this is an advanced usage of the OS that we will not detail here. If interested, you can
refer to the excellent book Mastering the FreeRTOS Real Time Kernel by Richard Barry, creator of
FreeRTOS.
23.4.1.6 How to Use malloc() and Related C Functions With FreeRTOS
As said before, except for the heap_3.c allocation scheme, FreeRTOS does not make use of the C
heap memory to allocate threads and other objects. So you are free to use malloc() and free() in
your application.
If, instead, you would like to use the pvPortMalloc() and vPortFree() routines, while ensuring
portability of your code, you may redefine malloc() and free() simply in this way:
void *malloc (size_t size) {
return pvPortMalloc(size);
}
void free (void *ptr) {
vPortFree(ptr);
}
This works because, in recent libc releases, both the functions are declared as __weak .
²⁵ http://bit.ly/1TqxX9S
Running FreeRTOS 646
23.4.1.7 FreeRTOS Heap Definition
Starting from FreeRTOS 9.x it is also possible to control the definition of the heap in addition to its
size. By setting the configAPPLICATION_ALLOCATED_HEAP macro to 1 we can declare the FreeRTOS
heap and we can decide to place it in specific memory regions (for example, in a faster memory like
the CCM one) with a custom linker script. When configuring the configAPPLICATION_ALLOCATED_-
HEAP to 1 we must provide a uint8_t array with the exact name and dimension as shown below.
uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
23.4.2 Static Memory Allocation Model
Starting from FreeRTOS 9.x, it is possible to enable a full-static memory allocation model. This
means that we are totally responsible of the correct allocation of memory pools needed by the OS
to carry our its activities. Statically allocated RAM provides developers some important advantages:
• OS structures can be placed at specific memory locations. This constitutes an important
advantage for those STM32 microcontrollers having CCM memory or other cached SRAM
memories.
• The maximum RAM footprint can be determined at link time, rather than at run-time.
• Developers do not need to concern themselves with graceful handling of memory allocation
failures.
• It allows the OS to be used in applications that simply do not allow any dynamic memory
allocation(althoughFreeRTOSincludesallocationschemesthatcanovercomemostobjections,
as we will see later).
The static memory allocation model is enabled by setting the configSUPPORT_STATIC_ALLOCATION
macro to 1 and it affects all the APIs used to define FreeRTOS objects. For example, the function
corresponding to osThreadDef() when using the static allocation model is osThreadStaticDef() .
When using static allocation we must provide to FreeRTOS the memory areas where to store objects
bypre-allocating it. Forexample,when creatinga newthreadweneedto supplythe areaof memory
containing the single TCP plus the stack used by the thread.
...
osThreadId threadID;
uint32_t threadStack[ 128 ];
osStaticThreadDef_t threadTCB;
osThreadStaticDef(tid, ThreadFunc, osPriorityNormal, 0, 128, threadStack, &threadTCB);
threadID = osThreadCreate(osThread(tid), NULL);
ST engineers have defined a dedicated API to statically allocate FreeRTOS objects, such as threads,
semaphores and so on. This API slightly differs from the official CMSIS-RTOS API. The functions
differing in the two memory allocation models are listed in Table A.
Running FreeRTOS 647
Table A: How to select the wanted scheduling policy in FreeRTOS
Dynamic allocation model Static allocation model
osThreadDef() osThreadStaticDef()
osMutexDef() osMutexStaticDef()
osSemaphoreDef() osSemaphoreStaticDef()
osMessageQDef() osMessageQStaticDef()
osTimerDef() osTimerStaticDef()
23.4.2.1 idle Thread Allocation With Static Memory Allocation Model
With the dynamic allocation, FreeRTOS completely takes care of the memory allocation for the idle
thread (including its stack and TCB). Instead, when using static allocation we are responsible of the
proper memory allocation for the idle thread like any other thread.
Being the idle thread automatically allocated by the kernel during its initialization, FreeRTOS
provides a generic way to supply the necessary memory room for the idle thread. The function:
void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleT\
askStackBuffer, uint32_t *pulIdleTaskStackSize);
is invoked by FreeRTOS before starting the idle thread. That routine must be used to allocate the
idle TCB and stack and to pass the reference to those memory areas to the kernel. When using
CubeMXtogenerateaprojectwithFreeRTOS,andthestaticmemoryallocationmodelischosen,the
file src/freertos.c already contains an implementation for the vApplicationGetIdleTaskMemory()
function.
23.4.3 Memory Pools
The CMSIS-RTOS specification provides the notion of memory pools, and the layer developed by ST
on the top of the FreeRTOS OS implements them²⁶. Memory pools are fixed-size blocks of dynamic-
allocated memory, implemented so that they are thread-safe. This allows them to be accessed
from threads and ISRs alike. Memory pool are implemented by ST using the pvPortMalloc()
and vPortFree() routines, and hence the effective memory allocation is demanded to one of the
heap_x.c allocators. Memory pools are an optional feature, which we need to enable by setting the
osFeature_Pool macro to 1 in the cmsis_os.h file.
A memory pool is defined by the following C struct :
²⁶ FreeRTOS does not provide this data structure. Moreover, memory pools are available if and only if we enable the dynamic memory
allocation model.
Running FreeRTOS 648
typedef struct os_pool_def {
uint32_t pool_sz; /* Number of items (elements) in the pool */
uint32_t item_sz; /* Size of each item */
void *pool; /* Type of objects in pool */
} osPoolDef_t;
Like for the thread definitions seen before, a memory pool can be easily defined by using the macro
osPoolDef() . A pool is effectively created using the function:
osPoolId osPoolCreate(const osPoolDef_t *pool_def);
The CMSIS-RTOS specifications defines the function:
void *osPoolAlloc(osPoolId pool_id);
to retrieve a single block of memory from the pool, whose size is equal to the item_sz parameter
of the struct osPoolDef_t . If no more space is available in the pool, the function returns NULL . To
free a block in the poll, we use the function:
osStatus osPoolFree(osPoolId pool_id, void *block);
The CMSIS-RTOS specifications also defines the function:
void *osPoolCAlloc(osPoolId pool_id);
which allocates a memory block from a memory pool and sets memory block to zero.
The following pseudo-code shows how to easily use memory pools.
1 #include "cmsis_os.h"
2
3 typedef struct {
4 uint8_t Buf[32];
5 uint8_t Idx;
6 } MEM_BLOCK;
7
8 osPoolDef (MemPool, 8, MEM_BLOCK);
9
10 void AllocMemoryPoolBlock (void) {
11 osPoolId MemPool_Id;
12 MEM_BLOCK *addr;
13
14 MemPool_Id = osPoolCreate (osPool (MemPool));
15 if (MemPool_Id != NULL) {
16 // allocate a memory block
Running FreeRTOS 649
17 addr = (MEM_BLOCK *)osPoolAlloc (MemPool_Id);
18
19 if (addr != NULL) {
20 // memory block was allocated
21 }
22 }
23 }
At line 8 a new pool is defined so that it contains eight elements each one with a size equal to
sizeof(MEM_BLOCK) (the size is automatically computed by the macro). Then the pool is effectively
created at line 14 and one of the eight bock is retrieved from the pool at line 17 by using the
osPoolAlloc() routine.
23.4.4 Stack Overflow Detection
Before we talk about the features offered by FreeRTOS to detect stack overflows, we should spend
some words about how to compute the right amount of memory a thread needs.
Unfortunately, it is not easy to give a definite answer, because it depends on a quite long list of
aspects to keep in mind. First of all, stack size is affected by how deep is the call stack, that is by
the number of functions called by our thread, and by the room occupied by each one of them. This
space is essentially composed by local variables and passed parameters. Another relevant factors are
the processor architecture, the compiler used and the optimization level chosen.
Usually the stack size of a thread is computed experimentally, and FreeRTOS offers a way to try to
detect stack overflows. Read my leaps: to try to detect. Because stack overflow detection is one of
the most hard aspect of debugging, as well as static analysis of program code.
FreeRTOS offers two ways to detect stack overflows. The first one consists in using the function:
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );
which returns the number of “unused” words of the thread stack. For example, assume a thread
defined with a stack of 100 words (that is, 400 bytes on an STM32). Suppose that, in the worst
scenario, the thread uses 90 words of its stack. Then the uxTaskGetStackHighWaterMark() returns
the value 10.
The TaskHandle_t type of the parameter xTask is nothing more than the osThreadId returned by
the osThreadCreate() function, and if we call the uxTaskGetStackHighWaterMark() from the same
thread we can pass NULL .
This function is available only if:
• the configCHECK_FOR_STACK_OVERFLOW macro is defined with a value higher than 0, or
• the configUSE_TRACE_FACILITY is defined with a value higher than 0, or
Running FreeRTOS 650
• the INCLUDE_uxTaskGetStackHighWaterMark is defined with a value higher than 1.
All of them must be obviously defined in the FreeRTOSConfig.h file.
Figure 12: How FreeRTOS fills the stack with a fixed value (0xA5) to detect stack overflows
How does the uxTaskGetStackHighWaterMark() know how much stack has been used?
There is nothing magic performed by that function. When one of the above macros is
defined, FreeRTOS fills the stack of a thread with a “magic” number (defined by the macro
tskSTACK_FILL_BYTE inside the task.c file), as shown in Figure 12. This is a “watermark”
used to derive the number of free memory locations (that is the number of locations through
the end of the thread stack still containing that value). This is one of the most efficient
techniques used to detect buffer overflows.
The uxTaskGetStackHighWaterMark() function can be also used to verity the effective usage of the
thread stack, and hence reduce its size if too much space is wasted.
FreeRTOSofferstwoadditionalmethodstodetectatrun-timeastackoverflow.Bothofthemconsist
in setting the configCHECK_FOR_STACK_OVERFLOW macro in the FreeRTOSConfig.h file. If we set it to
1, then every time a thread runs out, FreeRTOS check for the value of the current stack pointer: if it
is higher than the top of the thread stack, then it is likely that a stack overflow is happened. In this
case, the callback function:
void vApplicationStackOverflowHook(xTaskHandle *pxTask, signed portCHAR *pcTaskName);
is automatically called. By defining this function in our application we can detect the stack overflow
and debug it. For example, during a debug session we could place a software breakpoint in it:
void vApplicationStackOverflowHook(xTaskHandle *pxTask, signed portCHAR *pcTaskName) {
asm("BKPT #0"); /* If a stack overflow is detected then, the debugger stop
the firmware execution here */
}
This method is fast, but it could miss stack overflows that happen in the middle of a context
switch. So, by configuring the macro configCHECK_FOR_STACK_OVERFLOW to 2, FreeRTOS will apply
Running FreeRTOS 651
the same method of the function uxTaskGetStackHighWaterMark() , that is it will fill the stack with
a watermark value and it will call the vApplicationStackOverflowHook in case the latest 20 bytes
of the stack have changed from their expected value. Since FreeRTOS performs this check at every
context switch, this mode impacts on overall performances, and it should be used only during the
firmware development (especially for high tick frequencies).
23.5 Synchronization Primitives
In a multi-threaded application, soon or later threads need a way to synchronize themselves, both
while accessing to shared resources and when transmitting data between several execution streams.
The literature about concurrent programming is full of algorithms and data structures best suited
as synchronization primitives. The CMSIS-OS API, and the underlying FreeRTOS OS, defines those
primitives that are common to all Operating Systems and threading libraries. This paragraph briefly
introduces the most relevant ones.
23.5.1 Message Queues
A queue²⁷ is a First-In-First-Out (FIFO) collection, which is implemented in FreeRTOS with a linear
data structure where the first added element will be the first to be removed. When an element is
added to the queue is said to be enqueued, while when it is removed is said to be dequeued.
Queues are widely used in concurrent programming, especially when data need to be exchanged
between several threads that have different response time to events. For example, often we have
two threads, one acting as producer and one as consumer, sharing a common buffer. The producer’s
jobistogenerateapieceofdata,putitintothebufferandstartagain.Atthesametime,theconsumer
job consists in removing it from the buffer one piece at a time. The problem is to make sure that the
producer will not try to add data into the buffer if it is full and that the consumer will not try to
remove data from an empty buffer. In an RTOS, queues are designed so that if a thread tries to add
data in full queue, it can be placed in blocked mode until at least one element is removed from the
queue. At the same time, the OS kernel places the consumer in blocking mode if no data is available
in the queue). Being handled from the OS, queues are designed so that no race conditions can occur
between different threads (unless the programmer introduces evident errors in its code).
Queues are an optional data structure in the CMSIS-RTOS layer, which must be enabled by setting
the osFeature_MessageQ to 1 in cmsis_os.h file. A queue is defined by the following C struct :
²⁷ The CMSIS-RTOS use the term message queues to indicate what usually are simply called queues. As we will see in a while, this also
impacts on the API (all structures and functions have the prefix osMessage ). However, in the remaining part of this chapter, we will simply
refer to them as queues.
Running FreeRTOS 652
typedef struct os_messageQ_def {
uint32_t queue_sz; /* Number of elements in the queue */
uint32_t item_sz; /* Size of an item */
} osMessageQDef_t;
To easily define a queue, we can use the osMessageQDef() macro. A queue is effectively created by
using the function:
osMessageQId osMessageCreate(const osMessageQDef_t *queue_def, osThreadId thread_id);
which accepts an instance of the struct osMessageQDef_t created with the macro osMessageQDef()
andtheidofthreadassociatedtothequeue.However,theFreeRTOSAPIdoesnotpermittoassociate
a thread to a queue, so that parameter is simply ignored and you can safely pass the NULL value.
To enqueue a new element in the queue we use the function
osStatus osMessagePut(osMessageQId queue_id, uint32_t info, uint32_t millisec);
where queue_id is the id of the queue returned by the function osMessageCreate , while info can
be both the data (an unsigned long integer literal) to enqueue or the address of a memory location
containing a more articulated C data structure (for example, a block coming from a memory pool).
Finally,the millisec parameterrepresentsthetimeout,thatisitindicatestheamountofmilliseconds
we are willing to wait if the queue is full: if sufficient room is not made available before the timeout
period, then the osMessagePut() function returns the value osErrorTimeoutResource ²⁸. Passing
osWaitForever will cause osMessagePut() to wait indefinitely.
To dequeue a data from the queue we use the function
osEvent osMessageGet(osMessageQId queue_id, uint32_t millisec);
which returns an instance of the C struct osEvent that is defined in the following way:
typedef struct {
osStatus status; /* Status code: event or error information */
union {
uint32_t v; /* Message as 32-bit value */
void *p; /* Message or mail as void pointer */
int32_t signals; /* Signal flags */
} value; /* Event value */
...
} osEvent;
²⁸ The osMessagePut() and osMessageGet() can return other status codes, according if they are called from a thread or an ISR. For more
information, consult the official CMSIS-RTOS specification (http://bit.ly/1VAAz57).
Running FreeRTOS 653
As you can see, an instance of that struct is able to provide both the status code (which is equal
to osEventMessage if an element is successfully dequeued, osEventTimeout in case of timeout) and
the dequeued element, which is contained inside the osEvent.value.v field (or we can also use the
*p field of the union if the queued value is an address of a memory location containing a more
articulated data structure instance).
If wewant to leavean element in the queue,without physically removingit, wecan use the function
osEvent osMessagePeek(osMessageQId queue_id, uint32_t millisec);
Take in account that FreeRTOS provides two separated APIs to manipulate queues from
a thread or from an ISR. For example, the xQueueReceive() function is used to dequeue
an element from a thread, while the xQueueReceiveFromISR() is used to safely dequeue
elements from an ISR. The CMSIS-RTOS layer developed by ST is designed to abstract this
aspect, and it automatically checks if we are performing the call from a thread or from an
ISR. As usual, at the expense of speed.
The following example shows how a queue can be used to exchange data between two threads, one
acting as producer ( UARTThread() ) and one as consumer ( blinkThread() ), which can run really slow
if a really large timeout is specified.
Filename: src/main-ex3.c
14 osMessageQDef(MsgBox, 5, uint16_t); // Define message queue
15 osMessageQId MsgBox;
16
17 int main(void) {
18 HAL_Init();
19
20 Nucleo_BSP_Init();
21
22 RetargetInit(&huart2);
23
24 osThreadDef(blink, blinkThread, osPriorityNormal, 0, 100);
25 osThreadCreate(osThread(blink), NULL);
26
27 osThreadDef(uart, UARTThread, osPriorityNormal, 0, 300);
28 osThreadCreate(osThread(uart), NULL);
29
30 MsgBox = osMessageCreate(osMessageQ(MsgBox), NULL);
31 osKernelStart();
32
33 /* Infinite loop */
34 while (1);
35 }
36
Running FreeRTOS 654
37 void blinkThread(void const *argument) {
38 uint16_t delay = 500; /* Default delay */
39 osEvent evt;
40
41 while(1) {
42 evt = osMessageGet(MsgBox, 1);
43 if(evt.status == osEventMessage)
44 delay = evt.value.v;
45
46 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
47 osDelay(delay);
48 }
49 osThreadTerminate(NULL);
50 }
51
52 void UARTThread(void const *argument) {
53 uint16_t delay = 0;
54
55 while(1) {
56 printf("Specify the LD2 LED blink period: ");
57 scanf("%hu", &delay);
58 printf("\r\nSpecified period: %hu\n\r", delay);
59 osMessagePut(MsgBox, delay, osWaitForever);
60 }
The UARTThread , defined at lines [51:60] uses the I/O retargeting technique seen in Chapter 8,
allowingustousetheclassical printf() / scanf() routinesoftheCstandardlibrary.Thethreadreads
an uint16_t valuefromtheUARTandplacesitinsidethequeue MsgBox .The blinkThread() ,defined
at lines [37:49] takes these values from the queue and uses them as delay values for the osDelay()
function. This simple application allows us to pass the wanted LD2 LED blinking frequency from a
terminal emulator.
Ifyouspecifyalargedelayvalue,youcaneasilyseehowqueuescanbeusedwhenaproducer thread
runs faster than a consumer one. By passing a delay equal to 10000, we can then immediately put
another delay value equal to 50 inside the queue (because the queue has sufficient room to store
another value). As you will see, we need about 10 seconds before the LED starts blinking at a rate
of 20Hz, since blinkThread() is blocked by the osDelay() function.
The CMSIS-RTOS API specifies another type of queues, called mail queues. A mail queue resembles
a message queue, but the data that is being transferred consists of memory blocks that need to be
allocated (before putting data in) and freed (after taking data out). The mail queue uses a memory
pooltocreateformattedmemoryblocksandpassespointerstotheseblocksinamessagequeue.This
allows the data to stay in an allocated memory block while only a pointer is moved between the
separatethreads.Thisisanadvantageovermessagesthatcantransferonlya32-bitvalueorapointer.
Using the mail queue functions, you can control, send, receive, or wait for “mails”. Mail queues are
implemented by ST using indeed message queues and memory pools, and they are available if and
Running FreeRTOS 655
only if we enable the dynamic memory allocation model. We will not go into details of mail queues.
23.5.2 Semaphores
In concurrent programming, a semaphore is a datatype used to control the access, by multiple
execution streams, to a common resource. A really simple form of semaphore is represented by
a boolean variable: the state of the variable is used as a condition to control the access to a resource.
For example, if the variable is equal to False , then a thread is placed in the blocked state until that
variable becomes True again. A semaphore is said to be taken from the thread that acquires it, that
is the thread that firstly finds the semaphore equal to True . This is indeed a binary semaphore, since
it can assume only two states, and in FreeRTOS is implemented as a queue with just one element.
If the queue is empty, then the first thread that tries to acquire it places a “flag” value in the queue,
and it continues its execution; other threads will not be able to add other “flags” until the thread
that has acquired the semaphore does not dequeue its flag.
Amoregeneralformofsemaphoreisthecountingsemaphore,whichallowsmorethanonethreadsto
acquireit.Justasbinarysemaphoresareimplementedasqueuesthathavealengthofone,acounting
semaphore can be thought as queues that have a length more than one. A counting semaphore
usually has an initial value, which is decremented every time a thread acquires it. While binary
semaphores are usually used to discipline the concurrent access to just one resource, a counting
semaphore can be used to:
• discipline the access to pools of common resources: in this case the count value indicates
the number of available resources;
• countthenumberofrecurringevents:inthiscaseanexecutionstream(forsimplicityassume
that it is an ISR) will release a semaphore (causing that its counter increases) to signal to
another thread that a given event is occurred (e.g. a data coming from the UART is ready
to be processed); this threads can then take the semaphore and start performing its activities; if
another “event” takes place (new data arrived), then the ISR will increase again the semaphore
by releasing it; in this way the processing thread will be able to take again the semaphore and
perform its activities.
However, a simple variable cannot be used as a semaphore, since there is no guarantee that the
operation of “taking” a semaphore is carried out in an atomic manner. So to acquire a semaphore
we need the intervention of a “third party”, that is the OS kernel, which suspends the execution of
other threads during the acquisition process.
FreeRTOSprovidestwodistinctAPIstomanagebinaryandcountingsemaphores,whiletheCMSIS-
RTOS specifies that semaphores are implemented as counting semaphore (leaving to the mutexes
the role of binary semaphores). However, the usage of counting semaphores increases the FreeRTOS
codebase, which may have a dramatic impact on microcontrollers with small amount of flash mem-
ory. For this reason, FreeRTOS provides them only if the macro configUSE_COUNTING_SEMAPHORES in
the FreeRTOSConfig.h file is defined and equal to 1. The CMSIS-RTOS layer developed by ST is able
Running FreeRTOS 656
to detect this case, and it uses FreeRTOS counting semaphores if available, otherwise it uses binary
semaphores. In this case, all settings related to the counter value of the semaphore are meaningless.
In the CMSIS-RTOS layer semaphores are optional, and they must be enabled by setting the
osFeature_Semaphore macro to 1 in the cmsis_os.h file. In the CMSIS-RTOS API a semaphore is
defined using the macro osSemaphoreDef() , which simply accepts the semaphore name as the only
one parameter. Then the semaphore is effectively created by using the function
osSemaphoreId osSemaphoreCreate(const osSemaphoreDef_t *semaphore_def, int32_t count);
As said before, count is the starting value of the semaphore, which is meaningless if configUSE_-
COUNTING_SEMAPHORES is undefined or equal to 0. To acquire a semaphore we use the function
int32_t osSemaphoreWait(osSemaphoreId semaphore_id, uint32_t millisec);
whichacceptsthesemaphoreidandthetimeout( millisec )value.Ifthesemaphorecounterishigher
then zero, the thread acquires it (reducing the counter) and it can continue. Otherwise it is placed
in blocked state for a period equal to the timeout value, until the counter increases again. A thread
can wait indefinitely by specifying the osWaitForever value. The osSemaphoreWait() returns osOK
if the thread has successfully acquired the semaphore, otherwise it return osErrorOS ²⁹. To release a
semaphore we use the function
osStatus osSemaphoreRelease(osSemaphoreId semaphore_id);
AsemaphoreisdynamicallyallocatedbytheOSuponitscreation,anditmustbeexplicitlydestroyed
by using the function
osStatus osSemaphoreDelete(osSemaphoreId semaphore_id);
AsseenfortheAPIsrelatedtoqueuesmanipulation,FreeRTOSprovidestwoseparatedAPIs
tomanipulatesemaphoresfromathreadorfromanISR.Forexample,the xSemaphoreTake()
function is used to acquire a semaphore from a thread, while the xSemaphoreTakeFromISR()
is used to perform this operation from an ISR. The CMSIS-RTOS layer developed by ST is
designed to abstract this aspect.
The following example shows how to use a semaphore as notification primitive. This is again the
classical blinking application, but this time the delay of the blinkThread() is established by another
thread, delayThread() , which “unlock” the blinking thread by releasing a binary semaphore.
²⁹ As you can see, the osSemaphoreWait() is designed to return an int32_t instead of the classical osStatus return value. This because the
CMSIS-RTOS API specifies that it should return the semaphore counter after this has been decremented by the acquiring procedure. However,
FreeRTOS does not provide this facility.
Running FreeRTOS 657
Filename: src/main-ex4.c
14 osSemaphoreId semid;
15
16 int main(void) {
17 HAL_Init();
18
19 Nucleo_BSP_Init();
20
21 RetargetInit(&huart2);
22
23 osThreadDef(blink, blinkThread, osPriorityNormal, 0, 100);
24 osThreadCreate(osThread(blink), NULL);
25
26 osThreadDef(delay, delayThread, osPriorityNormal, 0, 100);
27 osThreadCreate(osThread(delay), NULL);
28
29 osSemaphoreDef(sem);
30 semid = osSemaphoreCreate(osSemaphore(sem), 1);
31 osSemaphoreWait(semid, osWaitForever);
32
33 osKernelStart();
34
35 /* Infinite loop */
36 while (1);
37 }
38
39 void blinkThread(void const *argument) {
40 while(1) {
41 osSemaphoreWait(semid, osWaitForever);
42 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
43 }
44 osThreadTerminate(NULL);
45 }
46
47 void delayThread(void const *argument) {
48 while(1) {
49 osDelay(500);
50 osSemaphoreRelease(semid);
51 }
Lines [29:31] define and create a binary semaphore named sem : the semaphore is immediately
acquired, causing its counter to become equal to zero. blinkThread() and delayThread() are
scheduled, but the first one is placed in blocked state as soon as it reaches the osSemaphoreWait()
call: being the semaphore already “acquired”, the thread will be swapped out until the semaphore is
released by the delayThread() thread, which performs this operation every 500ms. This will cause
the LD2 LED to blink at a 2Hz rate.
Running FreeRTOS 658
23.5.3 Thread Signals
The example 4 could be rearranged to use a feature more suitable for this kind of applications: the
signals. Signals are used to trigger execution states between threads or between ISRs and threads.
The signal management functions in CMSIS-RTOS allow you to control or wait for signal flags.
Each thread has up to 31 assigned signal flags. However, the actual maximum number of signal
flags is defined in the cmsis_os.h file by the macro osFeature_Signals . In FreeRTOS signals are
called task notifications and they are an optional feature available if the macro config_USE_TASK_-
NOTIFICATIONS inside the FreeRTOSConfig.h file is set and equal to 1.
Signals have their benefits and drawbacks: they are faster than semaphores and need less RAM, but
they cannot be used to exchange data between threads and they cannot be used to trigger multiple
threads at once.
If we want to trigger a thread signal, we have to set it using the function
int32_t osSignalSet(osThreadId thread_id, int32_t signals);
where the parameter thread_id is clearly the thread id and signal is the id of the signal we want to
trigger. Once a signal is set, it remains in this state until we expressly clear it by using the function
int32_t osSignalClear(osThreadId thread_id, int32_t signals);
A thread can be placed in blocked state waiting for a signal by using the function
osEvent osSignalWait(int32_t signals, uint32_t millisec);
where the millisec parameter represents the timeout.
23.6 Resources Management and Mutual Exclusion
In embedded applications it is quite frequent to access to hardware resources. For example, assume
that we use the UART peripheral to write debug messages to the console, and assume that our
applicationismadeofseveralthreadsthatcanprintmessagesusingthe HAL_UART_Trasmit() routine.
If you remember, in Chapter 8 we have seen that when we use the UART in polling mode, the bytes
contained in the message we are going to transmit are transferred one-by-one in the UART Data
Register (DR). This is a quite “slow procedure”, compared to the number of activities an RTOS may
performs in a unit of time. This means that, if two threads call the HAL_UART_Trasmit() they are
likely to overwrite the content of the buffer register.
If you remember, always in that chapter we have seen that the HAL tries to protect
concurrent accesses to peripherals by using the __HAL_LOCK() macro. However, there is no
guarantee that in a multithreaded environment that macro will prevent race conditions,
since the locking operation is not performed atomically.
Running FreeRTOS 659
While semaphores are best suited to synchronize thread activities, mutexes and critical sections
are a way to protect shared resources in concurrent programming. FreeRTOS provides us both the
primitives,whiletheCMSIS-RTOSlayeronlydefinesthenotionofmutex.However,criticalsections
come in handy in several situations, and sometimes they represent a better solution to problems
that would require more programming effort from the developer to avoid subtle conditions, like the
priority inversion.
23.6.1 Mutexes
Mutex is acronym for MUTual EXclusion, and they are a sort of binary semaphores used to
control the access to shared resources. From a conceptual point of view, mutexes differentiate from
semaphore for two reasons:
• a mutex must be always taken and then released to signal that the protected resource is now
available again,while a semaphore can even be released to wake up a blocking thread (we have
seen this mode in the example 4); moreover, usually a mutex is taken and released by the same
thread³⁰;
• a mutex implement the priority inheritance, a feature we will analyze later used to minimize
the priority inversion problem.
To use mutexes, we need to define the macro configUSE_MUTEXES inside the FreeRTOSConfig.h file
and set it to 1. A mutex is defined using the macro osMutexDef() , which accepts the mutex name as
the only parameter, and it is effectively created by the function
osMutexId osMutexCreate(const osMutexDef_t *mutex_def);
Similarly to semaphores, to acquire a mutex we use the function
osStatus osMutexWait(osMutexId mutex_id, uint32_t millisec);
and to release it we use the function:
osStatus osMutexRelease(osMutexId mutex_id);
Finally, to destroy a mutex we must explicitly call the function
osStatus osMutexDelete(osMutexId mutex_id);
³⁰ However, different from other Operating Systems, FreeRTOS is not implemented to check that only the thread that has acquired the
mutex can release it.
Running FreeRTOS 660
23.6.1.1 The Priority Inversion Problem
Mutexes may introduce an unwanted subtle problem, well known in literature as the priority
inversion problem. Let us consider this scenario with the help of the Figure 13.
Figure 13: The diagram schematizes the priority inversion problem
ThreadL() , ThreadM() and ThreadH() are three threads with an increasing priority ( L stands for low,
M for medium and H for high). ThreadL() starts its execution and it acquires a mutex used to protect
a shared resource. During its execution, ThreadH() returns in ready mode and it is scheduled for
executionhavingahigherpriority.However,italsoneedstoacquirethesamemutexanditgoesback
in blocked state. Suddenly, the medium-priority thread ThreadM() goes available, and it is scheduled
for execution having a priority higher than ThreadL() . This cannot so finish its job and the mutex
remain locked, preventing ThreadH() from being executed. In this case, we have the practical effect
that the priority between ThreadL() and ThreadH() is inverted, since ThreadH() cannot be executed
until ThreadL() releases the mutex.
The priority inversion problem should be avoided at all by rearranging application in a different
manner. However, FreeRTOS tries to minimize the impact of this issue by temporarily increasing
the priority of the mutex holder (in our case ThreadL() ) to the priority of the highest priority thread
that is attempting to acquire the same mutex.
Running FreeRTOS 661
Figure 14: How the priority inversion problem is addressed by temporary increasing the priority of ThreadL
The Figure 14 clearly shows this process. ThreadL() starts its execution and it acquires a mutex.
During its execution, ThreadH() returns in ready mode and it is scheduled for execution having
a higher priority. However, it also needs to acquire the same mutex and it goes back in blocked
state. This time, the priority of the ThreadL() is increased to the same of ThreadH() , preventing the
ThreadM() from being executed. ThreadL() is scheduled again and it can release the mutex, allowing
ThreadH() to run. Finally, ThreadM() can execute, since the priority of ThreadL() is decreased to its
original priority when it releases the mutex.
23.6.1.2 Recursive Mutexes
Sometimes it happens that, especially when our application is fragmented in several APIs, a thread
accidentally acquire a mutex more than once. Since a mutex can be acquired only once, any
subsequent attempt from the same thread to acquire the same mutex will cause a deadlock (because
a successive call to the osMutexWait() will place the thread inblocking state, but it is the only thread
designed to release the mutex).
To prevent this unwanted behaviour, FreeRTOS introduces the notion of recursive mutexes, that is
mutexes than can be acquired more than once. Clearly, a recursive mutex needs to be released the
same number of times it has been acquired. Since the CMSIS-RTOS API does not provide APIs to
handle recursive mutexes, we will not go into details of this topic. You can consult the FreeRTOS
documentation³¹ for more about this.
23.6.2 Critical Sections
Sometimes, especially when we need to perform a really quick operation on a shared resource, it is
best to avoid using synchronization primitives at all. As seen before, it is really easy to introduce
weird behaviour in our application unless we handle with special care synchronization constructs
offered by the RTOS.
³¹ http://www.freertos.org/RTOS-Recursive-Mutexes.html
Running FreeRTOS 662
Critical sections are a way to protect the access to shared resources. A critical section is a region of
code that is executed after all interrupts have been disabled. Since the preemption of tasks occurs
inside an ISR (the ISR of the the timer chosen as timebase generator), by disabling all ISRs we are
sure that no other code will preempt the execution of the code inside the critical section.
...
__disable_irq();
//All IRQs are disabled and we are sure that the next code will not be preempted
...
//Critical code here
...
__enable_irq();
//All IRQs are now enabled again, and normal behaviour of the RTOS is restored
Implementing a critical section using CMSIS APIs is not a trivial task, because we need to take care
of special hardware situations may occur. However, FreeRTOS provide us four routines that we can
use to define critical sections in our application.
The taskENTER_CRITICAL() and taskEXIT_CRITICAL() functions allow to define a critical section
inside a thread. Those routines are designed to keep tracking of the nesting, that is each time the
taskENTER_CRITICAL() is called a counter is incremented, and it is decremented on a subsequent
call to the taskEXIT_CRITICAL() function. This means that we have to be sure to respect the calling
order.
taskENTER_CRITICAL(); //Internal counter increased to 1
...
taskENTER_CRITICAL(); //Internal counter increased to 2
...
taskEXIT_CRITICAL(); //Internal counter decreased to 1
...
taskEXIT_CRITICAL(); //Internal counter decreased to 0
Critical sections works well only if they are used to protect really few lines of code, that perform
their activities in short time. Otherwise, the whole application can be impacted by their usage.
The taskENTER_CRITICAL() and taskEXIT_CRITICAL() functions should never called from an
ISR: the corresponding The taskENTER_CRITICAL_FROM_ISR() and taskEXIT_CRITICAL_FROM_ISR()
functionsaresuitedforthisapplication.FormoreinformationconsulttheFreeRTOSdocumentation.
23.6.3 Interrupt Management With an RTOS
The general rule of thumb of interrupt service routines is that they need to be fast. A slow ISR may
cause the lost of other events, both generated from the same peripheral or from other sources if this
ISR has a higher priority.
Running FreeRTOS 663
SomefeaturesofanRTOScansimplifytheinterruptmanagementbydeferringtheeffectiveinterrupt
handling to a thread. A deferred execution, or simply a deferred, consists in delegating to another
execution stream, not working at the same “low-level” of interrupt routines, the effective interrupt
handling. For example, in Chapter 8 we have seen that the USARTx_IRQn interrupt is generated when
a new data is ready to be transferred from the UART Data Register: the ISR effectively takes this
bytes from the register and places it inside a buffer. However, we have also seen that the UART_IRQ_-
Hanler() performs a lot of other operations, that slow down the ISR execution.
In this scenario, we could have a dedicated thread for each ISR. This thread would spend a lot of
time in blocking mode waiting for a given signal. When the IRQ fires, we could trigger that signal,
causing that the blocked thread is resumed to carry out the job that would be performed by the
corresponding ISR. By assigning different priorities to threads, we may establish an execution order
in case of concurrent ISRs. Another approach is to use a queue to transfer the data coming to the
peripheraltoaworkerthread,whichwillprocessitlater.Thisisespeciallyusefulwhentheconsumer
thread is slower than the peripheral ISR, which acts as a consumer thread in this case.
FreeRTOS provides another convenient way to defer the ISR execution to another execution stream.
This is called centralized deferred interrupt processing and it consists in deferring the execution of
a routine in the FreeRTOS daemon task³². This method uses the xTimerPendFunctionCallFromISR()
which is documented in the FreeRTOS manual³³.
However, take in mind that either deferring the execution to another thread or using a queue to
exchange data implies that several operations are performed by the CPU, and this may impact on
the reliability of ISR management. If your peripheral runs really fast, it is better to use other ways to
transfer data, for example using the DMA. Always considering the example of the UART transfer,
if our application exchanges fixed-length messages over the UART we could setup the DMA to
transfer a message and then use the DMA IRQ to move the whole message inside a queue. This
would certainly minimize the overhead connected with the transfer of individual bytes.
23.6.3.1 FreeRTOS API and Interrupt Priorities
So far we have seen that FreeRTOS provides some APIs that are expressly designed to be called
within ISRs. For a given FreeRTOS function, there exists a corresponding ISR-safe routine ending
with FromISR() (for example, the xQueueReceiveFromISR() for the xQueueReceive() routine). These
routines are designed so that interrupts are masked (by entering and then exiting a critical section),
preventing the execution of other interrupts that could generate race conditions by calling other
FreeRTOS functions.
The interrupts masking is required because interrupts are a source of multiprogramming handled by
the hardware. While threads are different program flows handled by the RTOS, which avoids race
conditions by simply suspending the execution of the scheduler, ISR are generated by the hardware
and there is little we can do to avoid race conditions unless we mask their execution or define a
strict priority-based execution order. Moreover, the nesting mechanism offered by Cortex-M cores
³² The FreeRTOS daemon task is also called the timer service task because it is the thread that handles the execution of timers callback
routines, which we will analyze later.
³³ http://www.freertos.org/xTimerPendFunctionCallFromISR.html
Running FreeRTOS 664
increases the risk of race conditions in our code. For example, an ISR starting acquiring a semaphore
may be preempted by another ISR with higher priority performing the same operation. This will
have a catastrophic effect for sure.
Even if the CMSIS-RTOS layer is designed to abstract this dual API system, we must place special
care when calling FreeRTOS APIs from ISR routines in Cortex-M3/4/7 based microcontrollers. This
happens because these cores allow to selectively mask interrupts on a priority level basis. InChapter
7 we have seen that the BASEPRI register allows to disable selectively ISRs execution by masking all
those IRQs having a priority lower than a given value. FreeRTOS uses this mechanism to allow the
executionofhigherpriorityinterrupts,whichareassumedtobenon-interruptible,whilesuspending
lower ones. This means that it is not safe to call FreeRTOS APIs from all ISRs, but it is only safe to
call FreeRTOS functions from those ISRs having a given (or lower) priority level.
We can set this maximum priority level by defining the macro configLIBRARY_MAX_SYSCALL_IN-
TERRUPT_PRIORITY ³⁴ in the FreeRTOSConfig.h file. CubeMX automatically performs this operation
for us, and usually the maximum priority level is set to 5. Special care must be placed when we
enable IRQs using CubeMX: even if recent releases of CubeMX seem to handle this aspect correctly,
always ensure that an ISR that calls FreeRTOS functions is configured with a priority equal to
configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY or lower.
Despite to the fact that this macro is also defined in projects generated by CubeMX for STM32F0/L0
MCUs, this has no practical effects since the FreeRTOS port for those families uses the PRIMASK
register to mask all interrupts (Cortex-M0/0+ cores do not offer a way to selectively disable IRQs).
So, that macro is simply ignored.
Finally, it is important to remember that FreeRTOS is designed so that the tick interrupt (that is
the IRQ associated to the timer that acts as timebase generator for the kernel) must be set to the
lowest possible interrupt, which is equal to 7 in STM32F0/L0 families and to 15 for all other MCUs.
The macro configLIBRARY_LOWEST_INTERRUPT_PRIORITY in FreeRTOSConfig.h file sets this, and it is
strongly suggested to leave it as is.
23.7 Software Timers
Software timers are the way an RTOS provides to schedule the execution of routines on a time-
basis. Software timers are implemented by, and under the control of, the FreeRTOS kernel. They
do not require specific hardware support (except for the timer used as tick generator for the OS)
and they have nothing related to hardware timers. Moreover, they are not able to provide the same
accuracy of hardware timers and should never used to perform activities related with the hardware
(for example, to trigger a DMA event).
³⁴ If you read the official FreeRTOS documentation, you can see that the macro used to setup the maximum interruptible priority level is
configMAX_SYSCALL_INTERRUPT_PRIORITY . However, being FreeRTOS portable among several silicon vendors, the priority level specified with
that macro is the exact value of the IPR register, that accepts only the upper 4 bits in STM32 MCUs (for example, a priority equal to 0x2
must be specified as 0x20). ST engineers have defined the macro configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY so that we can specify the
priority level according the HAL convention (in LSB form), while the configMAX_SYSCALL_INTERRUPT_PRIORITY is defined in the following
way: #define configMAX_SYSCALL_INTERRUPT_PRIORITY ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
Running FreeRTOS 665
Software timers are an optional feature in FreeRTOS, and they need to be enabled by setting the
macro config_USE_TIMERS to 1 in the FreeRTOSConfig.h file. When we enable timers, FreeRTOS
also requires that we define the macros configTIMER_TASK_PRIORITY , configTIMER_QUEUE_LENGTH ,
configTIMER_TASK_STACK_DEPTH . We will see the role of this macro in a while.
In the CMSIS-RTOS layer, a software timer is defined using the macro osTimerDef() , which accepts
thenameofthetimerandthepointertothecallbackfunction.Asoftwaretimeriseffectivelycreated
by the function
osTimerId osTimerCreate(const osTimerDef_t *timer_def, os_timer_type type, void *argument);
which allows to specify the timer type and an optional argument to pass to the callback routine.
The CMSIS-RTOS API provides two kinds of software timers: one-shot timers, that is timers that
execute the callback only once, and periodic timers, which act like hardware STM32 timers that
restarts counting again after they overflow.
To start a timer, we use the function
osStatus osTimerStart(osTimerId timer_id, uint32_t millisec);
where the millisec parameter represents the period of the timer. To stop it we use the function
osStatus osTimerStop(osTimerId timer_id);
Finally,atimerisdynamicallyallocatedbytheOSandneedstobedestroyedwhennolongerneeded
by using the function
osStatus osTimerDelete(osTimerId timer_id);
The following example shows our omnipresent blinking application made with a software timer.
Filename: src/main-ex5.c
13 int main(void) {
14 osTimerId stim1;
15
16 HAL_Init();
17
18 Nucleo_BSP_Init();
19
20 RetargetInit(&huart2);
21
22 osTimerDef(stim1, blinkFunc);
23 stim1 = osTimerCreate(osTimer(stim1), osTimerPeriodic, NULL);
24 osTimerStart(stim1, 500);
25
Running FreeRTOS 666
26 osKernelStart();
27
28 /* Infinite loop */
29 while (1);
30 }
31
32 void blinkFunc(void const *argument) {
33 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
34 }
The code is really self-explaining. Lines [22:24] define a new timer, named stim1 . This timer is
configured to execute the blinkFunc() routine when it expires, and it is started with a delay of
500ms. This will cause the Nucleo LD2 LED to blink at 2Hz rate.
23.7.1 How FreeRTOS Manages Timers
As you can see in the previous example, our application does not use threads. So, who takes care
of timers? FreeRTOS uses a centralized thread, named RTOS daemon (or also timer service thread),
which automatically calls the callback routineswhen a timer expires.This thread is a regular thread,
which has a priority defined by the macro configTIMER_TASK_PRIORITY and a stack with a size
defined by the macro configTIMER_TASK_STACK_DEPTH . Moreover, it has an internal pool of timer
objects, whose size is defined by the macro configTIMER_QUEUE_LENGTH .
Another interesting aspect to consider is how FreeRTOS computes the time internally. FreeRTOS
measure the time in function of the tick frequency, which is in turn defined by the overflow
frequency of the timer chosen as timebase generator. This means that, if we use the SysTick timer
configured to overflow ever 1ms, then internal software timers have a resolution of 1ms (which
corresponds to 1 tick). The millisec value passed to the osTimerStart() routine is hence converted
in ticks. This means that, in the case of the example 5, if the tick time is 1ms, then 500ms will be
equal to 500 ticks. If the tick time is set to 500μs, the 500ms delay is converted to 1000 ticks.
23.8 A Case Study: Low-Power Management With an
RTOS
This is a really advanced topic, that requires the knowledge of many concepts underlying an
RTOS. Moreover, a decent knowledge of the concepts illustrated in Chapter 20 is required.
Un-experienced users can safely skip this part.
In Chapter 19 we have analyzed the low-power features offered by STM32 microcontrollers. We
haveseenthat,especiallyforMCUsbelongingtotheSTM32L-series,theyofferseveralpowermodes
Running FreeRTOS 667
useful to reduce the energy consumption of the MCU when there is not too much active work to
do. We have also seen that the MCU enters in one of its low-power modes on a voluntary basis, by
calling one of the two dedicated assembly instructions: WFI or WFE . If we know that the firmware
has nothing important to do for a “long” period of time, we can enter in low-power mode waiting
for an external interrupt or event.
When we use an RTOS, it is harder to say “when there is not too much work to do”. So far, we have
seen that the RTOS schedules a particular thread when all other threads are inblocked or suspended
state: the idle. This means that an RTOS always has to find a way to do something (simply because
the CPU never stops), unless we enter in a low-power mode halting the MCU core.
An RTOS is so a source of “power leaks” if we do not find a solution to suspend its execution. There
are essentially two ways to place the MCU in a low-power mode when we use an RTOS: one is
suitable “to take a nap”, another one to longer and deeper sleep modes. Let us analyze both of them.
23.8.1 The idle Thread Hook
So far we have seen that the ISR associated to the timer used as timebase generator for the RTOS
(usually the SysTick timer) rules the RTOS activities. Every 1ms the SysTick timer underflows, and
its ISR passes the control to the OS scheduler, which establishes the next thread to be executed³⁵. If
no thread is in ready state, then the OS execute the idle thread, until another thread becomes ready.
This means that, when the idle thread is scheduled, it is likely to be the right time to place the MCU
in sleep mode to reduce power consumption.
For this reason, FreeRTOS gives to the user the ability to define an idle hook, that is a callback
function invoked within the idle thread. To enable the hook, we have to define the macro
configUSE_IDLE_HOOK inside the FreeRTOSConfig.h file and set it to 1. Next, we can define the
function vApplicationIdleHook(void) somewhere in our source code.
For example, to place the MCU in sleep mode every time the idle thread is scheduled, we can define
that function in this way:
void vApplicationIdleHook( void ) {
//Assume __HAL_RCC_PWR_CLK_ENABLE() is called elsewhere
HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFE);
}
³⁵ This is behaviour is enabled when the scheduling policy is the prioritized preemptive scheduling with time slicing, according Table 2.
Running FreeRTOS 668
Which Sleep Instruction to Use?
Cortex-M based MCUs offer two assembly instructions to enter in low-power modes: WFI
and WFE . But which one is more suitable to be called from the idle hook? The WFI instruction
will keep the MCU core OFF until an interrupt is raised. This could be either the interrupt
of the SysTick timer or of another peripheral. The WFE instruction, instead, is conditional:
it does not enter in sleep mode if the event register is set (the WFI always enter and then
re-exit, if an interrupt is pending, wasting several CPU cycles). Moreover, it allows to wake
up the processor if we are using events associated to a given peripheral instead of interrupts,
while it is still able to wake up in case of interrupts. For these reasons, the WFE instruction is
always preferred to the WFI one in idle loops.
The power saving that can be achieved by this simple method is limited by the necessity to
periodically exit and then re-enter the low-power mode to process tick interrupts (which are related
to the underflow frequency of the SysTick timer), as shown in Figure 15. Moreover, if the frequency
of the tick interrupt is too high, the energy and time consumed entering and then exiting a low-
power mode for every tick will outweigh any potential power saving gain for all but the lightest
power saving modes.
For these reasons, it is completely impracticable to enter deeper sleep modes, like the stop one.
Moreover, the overhead connected with the entering and exiting from low-power mode affects the
reliability of the tick counter, causing shifts that impact on software timers and timeout delays.
23.8.2 The Tickless Mode in FreeRTOS
Toaddresstheseissues,FreeRTOSoffersaworkingmodenamedticklessidlemode(orsimplytickless
mode), which stops the periodic tick interrupt during idle periods. The duration of these periods is
arbitrary: it can be several milliseconds, some seconds, minutes or even days. When the MCU exits
from low-power mode, FreeRTOS makes a correcting adjustment to the tick count value when the
tick interrupt is restarted, if needed (more about this soon). This means that FreeRTOS does not stop
the timer at all: it just configures the timer so that it reaches its maximum update period before
overflowing. When the MCU wakes up again, the kernel reads the counter value of the timer and
computes the number of elapsed ticks during the sleep time.
Running FreeRTOS 669
Figure 15: The effects of SysTick interrupts on the power consumption
For example, assume a 16-bit timer clocked at the core SYSCLK frequency of 48MHz. The maximum
values for the Period and Prescaler registers are equal to 0xFFFF. So instead of configuring the
timer so that it overflow ever 1ms, we can configure it to overflow after:
UpdateEvent =
48.000.000
0xFFFF × 0xFFFF
≈ 90s
FreeRTOS provides a built-in tickless functionality, which is enabled by defining the macro confi-
gUSE_TICKLESS_IDLE as1in FreeRTOSConfig.h .Thebuilt-intickless modeisplatformdependent:for
thisreason,itisimplementedinsidethe port.c file.Thebuilt-intickless isavailableforallCortex-M
cores, but it has one relevant limitation: it relies on the SysTick timer, because it is the only timer
available in all MCUs based on this architecture.
What’s wrong with it? The SysTick timer is a 24-bit down-counter timer, clocked at the same core
clock frequency. Unfortunately, it cannot be easily prescaled like regular STM32 timers (it has just
one prescaler value, equal to 8, in all STM32 MCUs). For example, for an STM32F030 running at
48MHz we have that, applying the equation [1] from Chapter 11, the SysTick timer will overflow
every:
UpdateEvent =
48.000.000
8 × 0xFFFFFF
≈ 0.350Hz ≈ 2.8s
Since we cannot lose the overflow event at all, otherwise the global tick count would be compro-
mised³⁶,wehavetowakeupagainevenifwehavenothingrelevanttodo.Forthemostoflow-power
applications this is a really short time between two consecutive sleep periods.
A solution may be represented by lowering the HCLK speed to further increase the overflow period,
but we have to pay attention to lowering the core frequency too much, because when the MCU
³⁶ As we will discover later, under certain circumstances we can safely stop incrementing the global tick counter. This can be done when
we are not going to use software timers and timeouts: if all threads are blocked or suspended indefinitely, then it is safe to completely turn
OFF the timebase generator.
Running FreeRTOS 670
exits from low-power mode to service an interrupt a low HCLK speed could compromise the system
reliability. And to increase the clock speed from an ISR is not a smart thing.
Why tick Count Accuracy Is So Relevant?
The accuracy of the global tick count is important for two main reasons: to guarantee the
same quantum time to all ready threads with the same priority (if preemption is enabled)
and to ensure precise timeout delays. In fact, several blocking OS routines allow to specify a
maximum delay we are willing to wait before the operation is performed. Timeouts are
specified in milliseconds in the CMSIS-ROS API and they are converted by underlying
implementation in ticks, knowing that a tick usually lasts 1ms for Cortex-M FreeRTOS port.
Ifwespecifyatimeoutsmallerthan osWaitForever ,thenitisimportantthatthetick countis
themostaccurateone.Theglobaltick countisalsousedbyFreeRTOStoimplementsoftware
timers.
Another limitation in using the SysTick timer arises from the fact that it cannot be used in stop
modes, because the HCLK clock source is turned off. This is one of the typical applications of the
low-powertimers(LPTIM)providedbythemostofSTM32Lmicrocontrollers.LPTIMtimers,infact,
are able to run independently from the system clock: this allows to use them even in stop modes.
For all those reasons, we are now going to provide a custom implementation of the tickless idle
functionality, which can be provided for any FreeRTOS port (including those that provide a built in
implementation) by defining configUSE_TICKLESS_IDLE to 2 in FreeRTOSConfig.h . When this con-
figuration is chosen, we can override two FreeRTOS functions: void prvSetupTimerInterrupt() ³⁷
and void vPortSuppressTicksAndSleep() . The former is used by the kernel to setup the timer used
as tick generator. The latter is automatically called by the kernel when some conditions (that we
will see later) are satisfied, and we can enter in low-power modes delaying or suspending at all the
periodic timer interrupt.
23.8.2.1 A Schema for the tickless Mode
Before we dive into the real source code needed to implement those two routines, it is best to take
a look at the underlying logic without struggling with implementation details.
³⁷ In Cortex-M3/4 ports this function is called vPortSetupTimerInterrupt() .
Running FreeRTOS 671
1 /* Override the default definition of vPortSetupTimerInterrupt() with a version
2 that configures another STM32 timer to generate the tick interrupt. */
3 void vPortSetupTimerInterrupt(void) {
4 /* Scale the clock so longer tickless periods can be achieved by dividing
5 the HCLK frequency for the wanted tick frequency (usuallu 1ms). */
6
7 htimx.Instance = TIMx;
8 htimx.Init.Prescaler = PRESCALER_VALUE;
9 htimx.Init.Period = PERIOD_VALUE
10 HAL_TIM_Base_Init(&htimx);
11
12 /* Enable the TIMx interrupt. This must execute at the lowest interrupt priority. */
13 HAL_NVIC_SetPriority(TIMx_IRQn, configLIBRARY_LOWEST_INTERRUPT_PRIORITY, 0);
14 HAL_NVIC_EnableIRQ(TIMx_IRQn);
15
16 /* Start the timer */
17 HAL_TIM_Base_Start_IT(&htimx);
18 }
Thefirstroutinewearegoingtooverrideisthe vPortSetupTimerInterrupt() one.Itsimplyusesone
of the available STM32 timers as timebase generator, configuring the right Period and Prescaler
values to achieve a tick interrupt with a frequency equal to 1kHz. The timer ISR (shown later) will
have the responsibility to increment the global tick counter.
Read Carefully
In Chapter 10 we have seen that the HAL is designed to automatically invoke the
SystemCoreClockUpdate() when we change the HCLK frequency. This ensures us that the
SysTick interrupt is generated every 1ms even if the core clock changes. If, instead, we use
another timer for the RTOS tick counter, then it is up to us to carefully ensure that the
timer is reconfigured accordingly when the APB bus clock speed where the timer belongs
to changes.
The next lines of code show a possible implementation for the vPortSuppressTicksAndSleep() ,
which is called when the following two conditions are both true:
1. The idle thread is the only thread able to run because all the application threads are either in
the blocked or in the suspended state.
2. At least n further complete tick periods will pass before the kernel moves an application thread
outoftheblocked state,wheren issetbythe configEXPECTED_IDLE_TIME_BEFORE_SLEEP macro
in FreeRTOSConfig.h file³⁸.
³⁸ This is a user-defined parameter that represents a further delay before to start the tick suppression procedure. Since this procedure
is computational intensive, and it may introduce minor shifts in the global tick count, we can programmatically decide to wait at least n
consecutive ticks before starting the procedure.
Running FreeRTOS 672
If the above conditions are satisfied, then the scheduler is suspended and the vPortSuppressTick-
sAndSleep() function is called, allowing us to temporarily suppress the tick interrupt or to delay its
execution.
20 /* Override the default definition of vPortSuppressTicksAndSleep() with a version
21 that uses another STM32 timer to derive how long the micro is remained in sleep state */
22 void vPortSuppressTicksAndSleep(TickType_t xExpectedIdleTime) {
23 unsigned long ulLowPowerTimeBeforeSleep, ulLowPowerTimeAfterSleep;
24 eSleepModeStatus eSleepStatus;
25
26 /* Read the current time from the timer configured by the
27 vPortSetupTimerInterrupt() function */
28 ulLowPowerTimeBeforeSleep = __HAL_TIM_GET_COUNTER(TIMx);
29
30 /* Stop the timer that is generating the tick interrupt. */
31 HAL_TIM_Base_Stop_IT(TIMx);
32
33 /* Enter a critical section that will not affect interrupts bringing the MCU
34 out of sleep mode. */
35 __disable_irq();
36
37 /* Ensure it is still ok to enter the sleep mode. */
38 eSleepStatus = eTaskConfirmSleepModeStatus();
39
40 if (eSleepStatus == eAbortSleep) {
41 /* A task has been moved out of the Blocked state since this macro was
42 executed, or a context switch is being held pending. Do not enter a
43 sleep state. Restart the tick and exit the critical section. */
44 HAL_TIM_Base_Start_IT (TIMx)
45 __enable_irq();
46 } else {
47 if (eSleepStatus == eNoTasksWaitingTimeout) {
48 /* There are no running state tasks and no tasks that are blocked with a
49 time out. Assuming the application does not care if the tick time slips
50 with respect to calendar time then enter a deep sleep that can only be
51 woken by another interrupt. */
52 StopMode();
53 } else {
54 /* Configure an interrupt to bring the microcontroller out of its low
55 power state at the time the kernel next needs to execute. The
56 interrupt must be generated from a source that remains operational
57 when the microcontroller is in a low power state. */
58 vSetWakeTimeInterrupt(xExpectedIdleTime);
59
60 /* Enter the low power state. */
61 SleepMode();
62
Running FreeRTOS 673
63 /* Determine how long the microcontroller was actually in a low power
64 state for, which will be less than xExpectedIdleTime if the
65 microcontroller was brought out of low power mode by an interrupt
66 other than that configured by the vSetWakeTimeInterrupt() call.
67 Note that the scheduler is suspended before
68 vPortSuppressTicksAndSleep() is called, and resumed when it returns.
69 Therefore no other tasks will execute until this function completes. */
70 ulLowPowerTimeAfterSleep = __HAL_TIM_GET_COUNTER(TIMx);
71
72 /* Correct the kernels tick count to account for the time the
73 microcontroller spent in its low power state. */
74 vTaskStepTick( ulLowPowerTimeAfterSleep – ulLowPowerTimeBeforeSleep );
75 }
76
77 /* Exit the critical section - it might be possible to do this immediately
78 after the prvSleep() calls. */
79 __disable_irq();
80
81 /* Restart the timer that is generating the tick interrupt. */
82 HAL_TIM_Base_Stop_IT(TIMx);
83 }
The routine starts by saving the current counter value of the timer before it is stopped. All
interrupts are disabled to prevent race conditions, entering in a critical section by calling the
CMSIS function __disable_irq() . As said before, vPortSetupTimerInterrupt() is called when
the scheduler is suspended, but an interrupt firing before we enter the critical section at line 35
may ask to the kernel to resume the execution of another thread in blocked state³⁹. By calling the
eTaskConfirmSleepModeStatus() we can know if we need to abort the tick suppression procedure,
resuming the timer. If the function returns the value eAbortSleep , then we restart the tick generator
timer and we immediately exit from the critical section by re-enabling all interrupts (line 45). If,
instead, the function returns the value eNoTasksWaitingTimeout , it means that there are no running
threads, no software timers⁴⁰ or other threads blocked with a definite timeout. Since there is no need
to preserve the tick count accuracy in this case (no timers, no running threads, no timeouts), we can
so enter in stop mode, which will cause that the timer clock is gated. The MCU will exit from the
StopMode() routine when an external interrupt wakes up the MCU.
If, instead, the eTaskConfirmSleepModeStatus() function returns the value eStandardSleep , the
else at line 53 matches and we can sleep for a time equal to the xExpectedIdleTime parameter,
which corresponds to the total number of tick periods before a thread is moved back into the ready
state.Theparametervalueisthereforethetimethemicrocontrollercansafelyremaininalow-power
state, with the tick interrupt temporarily suppressed. The timer ISR will wake up the MCU, exiting
from the SleepMode() routine and the global tick count is adjusted at line 74.
³⁹ This happens because this routine is called within an IRQ with the lowest possible priority, as seen before. So, a more privileged IRQ may
resume the execution of another blocked task.
⁴⁰ Please, take note that it is not sufficient we do not use timers in our code. The macro configUSE_TIMERS in FreeRTOSConfig.h must be
set to 0, otherwise the eTaskConfirmSleepModeStatus() never return the eNoTasksWaitingTimeout value.
Running FreeRTOS 674
23.8.2.2 A Custom tickless Mode Policy
Theabovepseudo-coderepresentsaschemathatallprogrammerscanusetoimplementtheircustom
tickless mode. For example, if we know that our software does not make use of software timers and
non-indefinite timeouts, then we can safely handle only the deep sleep mode case.
Nowwearegoingto implementa customtickless mode policy,analyzing realcode madeto workon
an STM32F030 MCU. Refer to the book example for other STM32 MCUs, even if the implementation
is almost the same.
Filename: src/tickless-mode.c
7 /* Calculate how many clock increments make up a single tick period.
8 Since we are using a prescaler equal to 1599, and assuming a clock
9 speed of 48MHz, according the equation [1] in Chapter 11 this
10 period value ensure a timer overflow ever 1ms. */
11 static const uint32_t ulMaximumPrescalerValue = 1599;
12 static const uint32_t ulPeriodValueForOneTick = 29;
13
14 /* Holds the maximum number of ticks that can be suppressed - which is
15 basically how far into the future an interrupt can be generated without
16 loosing the overflow event at all. It is set during initialization. */
17 static TickType_t xMaximumPossibleSuppressedTicks = 0;
18
19 /* Flag set from the tick interrupt to allow the sleep processing to know if
20 sleep mode was exited because of an tick interrupt or a different interrupt. */
21 static volatile uint8_t ucTickFlag = pdFALSE;
22
23 /* The HAL handler of the TIM6 timer */
24 TIM_HandleTypeDef htim6;
25
26 void xPortSysTickHandler( void );
27
28 /* Override the default definition of vPortSetupTimerInterrupt() that is weakly
29 defined in the FreeRTOS Cortex-M0 port layer with a version that configures TIM6
30 to generate the tick interrupt. */
31 void prvSetupTimerInterrupt(void) {
32 uint32_t ulPrescalerValue;
33
34 /* Enable the TIM6 clock. */
35 __HAL_RCC_TIM6_CLK_ENABLE();
36
37 /* Ensure clock stops in debug mode. */
38 __HAL_DBGMCU_FREEZE_TIM6();
39
40 /* Configure the TIM6 timer */
41 htim6.Instance = TIM6;
42 htim6.Init.Prescaler = (uint16_t) ulMaximumPrescalerValue;
Running FreeRTOS 675
43 htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
44 htim6.Init.Period = ulPeriodValueForOneTick;
45 HAL_TIM_Base_Init(&htim6);
46
47 /* Enable the TIM6 interrupt. This must execute at the lowest interrupt priority. */
48 HAL_NVIC_SetPriority(TIM6_IRQn, configLIBRARY_LOWEST_INTERRUPT_PRIORITY, 0);
49 HAL_NVIC_EnableIRQ(TIM6_IRQn);
50
51 HAL_TIM_Base_Start_IT(&htim6);
52 /* See the comments where xMaximumPossibleSuppressedTicks is declared. */
53 xMaximumPossibleSuppressedTicks = ((unsigned long) USHRT_MAX)
54 / ulPeriodValueForOneTick;
55 }
56
57 /* The callback function called by the HAL when TIM6 overflows. */
58 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
59 if (htim->Instance == TIM6) {
60 xPortSysTickHandler();
61
62 /* In case this is the first tick since the MCU left a low power mode.
63 The period is so configured by vPortSuppressTicksAndSleep(). Here
64 the reload value is reset to its default. */
65 __HAL_TIM_SET_AUTORELOAD(htim, ulPeriodValueForOneTick);
66
67 /* The CPU woke because of a tick. */
68 ucTickFlag = pdTRUE;
69 }
70 }
The first two functions we are going to analyze are related to the setup of the timer used as
tick generator and the handling of the related overflow interrupt. The prvSetupTimerInterrupt()
function is automatically invoked by FreeRTOS when the osKernelStart() routine is called. It
configures the TIM6 timer so that it expires every 1ms. The corresponding interrupt is enabled,
and the ISR priority is set to the lowest one (remember that, unless different needed, it is always
important to setup the timer ISR with the lowest priority). The HAL_TIM_PeriodElapsedCallback()
callbacksimplyincreasestheglobaltickcountby1.Don’tcareabouttheinstructionsatlines[65:68],
because they will be clear later.
Now we are going to analyze the most complex part: the vPortSuppressTicksAndSleep() function.
We will divide it in blocks, so that it is simpler to analyze its code. It is strongly suggested to keep
the real code in the IDE at your hands.
Running FreeRTOS 676
Filename: src/tickless-mode.c
78 void vPortSuppressTicksAndSleep(TickType_t xExpectedIdleTime) {
79 uint32_t ulCounterValue, ulCompleteTickPeriods;
80 eSleepModeStatus eSleepAction;
81 TickType_t xModifiableIdleTime;
82 const TickType_t xRegulatorOffIdleTime = 50;
83
84 /* Make sure the TIM6 reload value does not overflow the counter. */
85 if (xExpectedIdleTime > xMaximumPossibleSuppressedTicks) {
86 xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
87 }
88
89 /* Calculate the reload value required to wait xExpectedIdleTime tick
90 periods. */
91 ulCounterValue = ulPeriodValueForOneTick * xExpectedIdleTime;
92
93 /* To avoid race conditions, enter a critical section. */
94 __disable_irq();
95
96 /* If a context switch is pending then abandon the low power entry as
97 the context switch might have been pended by an external interrupt that
98 requires processing. */
99 eSleepAction = eTaskConfirmSleepModeStatus();
100 if (eSleepAction == eAbortSleep) {
101 /* Re-enable interrupts. */
102 __enable_irq();
103 return;
104 } else if (eSleepAction == eNoTasksWaitingTimeout) {
105 /* Stop TIM6 */
106 HAL_TIM_Base_Stop_IT(&htim6);
107
108 /* A user definable macro that allows application code to be inserted
109 here. Such application code can be used to minimize power consumption
110 further by turning off IO, peripheral clocks, the Flash, etc. */
111 configPRE_STOP_PROCESSING();
112
113 /* There are no running state tasks and no tasks that are blocked with a
114 time out. Assuming the application does not care if the tick time slips
115 with respect to calendar time then enter a deep sleep that can only be
116 woken by (in this demo case) the user button being pushed on the
117 STM32L discovery board. If the application does require the tick time
118 to keep better track of the calendar time then the RTC peripheral can be
119 used to make rough adjustments. */
120 HAL_PWR_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFI);
121
122 /* A user definable macro that allows application code to be inserted
123 here. Such application code can be used to reverse any actions taken
Running FreeRTOS 677
124 by the configPRE_STOP_PROCESSING(). In this demo
125 configPOST_STOP_PROCESSING() is used to re-initialize the clocks that
126 were turned off when STOP mode was entered. */
127 configPOST_STOP_PROCESSING();
128
129 /* Restart tick. */
130 HAL_TIM_Base_Start_IT(&htim6);
131
132 /* Re-enable interrupts. */
133 __enable_irq();
134 }
The function starts checking if the expected idle time, that is the time window within we can safely
stop the tick generation, is less than the xMaximumPossibleSuppressedTicks : this value is computed
inside the prvSetupTimerInterrupt() routine according the given Prescaler and Period values.
Then, at line 91, it computes the Period value to use so that the timer will overflow after the
xExpectedIdleTime time. To avoid race conditions, we then enter in a critical section (line 94) and
we invoke the eTaskConfirmSleepModeStatus() to decide how to proceed in the tick suppression
procedure. If the function returns eNoTasksWaitingTimeout , then we can stop the TIM6 timer at all,
and we can enter in stop mode until the MCU is woken up by an event or an interrupt.
Filename: src/tickless-mode.c
135 else {
136 /* Stop TIM6 momentarily. The time TIM6 is stopped for is not accounted for
137 in this implementation (as it is in the generic implementation) because the
138 clock is so slow it is unlikely to be stopped for a complete count period
139 anyway. */
140 HAL_TIM_Base_Stop_IT(&htim6);
141
142 /* The tick flag is set to false before sleeping. If it is true when sleep
143 mode is exited then sleep mode was probably exited because the tick was
144 suppressed for the entire xExpectedIdleTime period. */
145 ucTickFlag = pdFALSE;
146
147 /* Trap underflow before the next calculation. */
148 configASSERT(ulCounterValue >= __HAL_TIM_GET_COUNTER(&htim6));
149
150 /* Adjust the TIM6 value to take into account that the current time
151 slice is already partially complete. */
152 ulCounterValue -= (uint32_t) __HAL_TIM_GET_COUNTER(&htim6);
153
154 /* Trap overflow/underflow before the calculated value is written to TIM6. */
155 configASSERT(ulCounterValue < ( uint32_t ) USHRT_MAX);
156 configASSERT(ulCounterValue != 0);
157
158 /* Update to use the calculated overflow value. */
Running FreeRTOS 678
159 __HAL_TIM_SET_AUTORELOAD(&htim6, ulCounterValue);
160 __HAL_TIM_SET_COUNTER(&htim6, 0);
161
162 /* Restart the TIM6. */
163 HAL_TIM_Base_Start_IT(&htim6);
164
165 /* Allow the application to define some pre-sleep processing. This is
166 the standard configPRE_SLEEP_PROCESSING() macro as described on the
167 FreeRTOS.org website. */
168 xModifiableIdleTime = xExpectedIdleTime;
169 configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
170
171 /* xExpectedIdleTime being set to 0 by configPRE_SLEEP_PROCESSING()
172 means the application defined code has already executed the wait/sleep
173 instruction. */
174 if (xModifiableIdleTime > 0) {
175 /* The sleep mode used is dependent on the expected idle time
176 as the deeper the sleep the longer the wake up time. See the
177 comments at the top of main_low_power.c. Note xRegulatorOffIdleTime
178 is set purely for convenience of demonstration and is not intended
179 to be an optimized value. */
180 if (xModifiableIdleTime > xRegulatorOffIdleTime) {
181 /* A slightly lower power sleep mode with a longer wake up time. */
182 HAL_PWR_EnterSLEEPMode(PWR_LOWPOWERREGULATOR_ON, PWR_SLEEPENTRY_WFI);
183 } else {
184 /* A slightly higher power sleep mode with a faster wake up time. */
185 HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
186 }
187 }
If the eTaskConfirmSleepModeStatus() returns eStandardSleep , then we can enter in sleep mode.
The timer is stopped and its Period is set (at line 159) to the value computed before (at line 91). The
configPRE_SLEEP_PROCESSING() is a macro we can implement to perform operations preliminary
to the sleep mode (for example, in some STM32 MCUs it is required to lower the clock speed, or
we could use this macro to turn OFF unneeded peripherals). We can so enter in sleep mode or in
low-power sleep mode, according the computed sleep time (in some STM32 MCUs exiting from low-
power sleep requires more time that would waste a lot of power uselessly if the sleeping period is
too short).
Running FreeRTOS 679
Filename: src/tickless-mode.c
189 /* Allow the application to define some post sleep processing. This is
190 the standard configPOST_SLEEP_PROCESSING() macro, as described on the
191 FreeRTOS.org website. */
192 configPOST_SLEEP_PROCESSING( xModifiableIdleTime );
193
194 /* Re-enable interrupts. If the timer has overflowed during this period
195 then this will cause that the TIM6_IRQHandler() is called. So the
196 global tick counter is incremented by 1 and the ulTickFlag variable
197 is set to pdTRUE.
198 Take note that in the STM32L example in the official FreeRTOS
199 distribution interrupts are re-enabled after the TIM6 is stopped.
200 This is wrong, because it causes that the IRQ is leaved pending,
201 even if has been set. So we must first re-enable interrupts - this
202 causes that a pending TIM6 IRQ fires - and then stop the timer. */
203 __enable_irq();
204
205 /* Stop TIM6. Again, the time the clock is stopped for in not accounted
206 for here (as it would normally be) because the clock is so slow it is
207 unlikely it will be stopped for a complete count period anyway. */
208 HAL_TIM_Base_Stop_IT(&htim6);
209
210 if (ucTickFlag != pdFALSE) {
211 /* The MCU has been woken up by the TIM6. So we trap overflows
212 before the next calculation. */
213 configASSERT(
214 ulPeriodValueForOneTick >= (uint32_t ) __HAL_TIM_GET_COUNTER(&htim6));
215
216 /* The tick interrupt has already executed, although because this
217 function is called with the scheduler suspended the actual tick
218 processing will not occur until after this function has exited.
219 Reset the reload value with whatever remains of this tick period. */
220 ulCounterValue = ulPeriodValueForOneTick
221 - (uint32_t) __HAL_TIM_GET_COUNTER(&htim6);
222
223 /* Trap under/overflows before the calculated value is used. */
224 configASSERT(ulCounterValue <= ( uint32_t ) USHRT_MAX);
225 configASSERT(ulCounterValue != 0);
226
227 /* Use the calculated reload value. */
228 __HAL_TIM_SET_AUTORELOAD(&htim6, ulCounterValue);
229 __HAL_TIM_SET_COUNTER(&htim6, 0);
230
231 /* The tick interrupt handler will already have pended the tick
232 processing in the kernel. As the pending tick will be processed as
233 soon as this function exits, the tick value maintained by the tick
234 is stepped forward by one less than the time spent sleeping. The
Running FreeRTOS 680
235 actual stepping of the tick appears later in this function. */
236 ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
237 } else {
238 /* Something other than the tick interrupt ended the sleep. How
239 many complete tick periods passed while the processor was
240 sleeping? */
241 ulCompleteTickPeriods = ((uint32_t) __HAL_TIM_GET_COUNTER(&htim6))
242 / ulPeriodValueForOneTick;
243
244 /* Check for over/under flows before the following calculation. */
245 configASSERT(
246 ((uint32_t ) __HAL_TIM_GET_COUNTER(&htim6)) >=
247 (ulCompleteTickPeriods * ulPeriodValueForOneTick));
248
249 /* The reload value is set to whatever fraction of a single tick
250 period remains. */
251 ulCounterValue = ((uint32_t) __HAL_TIM_GET_COUNTER(&htim6))
252 - (ulCompleteTickPeriods * ulPeriodValueForOneTick);
253 configASSERT(ulCounterValue <= ( uint32_t ) USHRT_MAX);
254 if (ulCounterValue == 0) {
255 /* There is no fraction remaining. */
256 ulCounterValue = ulPeriodValueForOneTick;
257 ulCompleteTickPeriods++;
258 }
259 __HAL_TIM_SET_AUTORELOAD(&htim6, ulCounterValue);
260 __HAL_TIM_SET_COUNTER(&htim6, 0);
261 }
262
263 /* Restart TIM6 so it runs up to the reload value. The reload value
264 will get set to the value required to generate exactly one tick period
265 the next time the TIM6 interrupt executes. */
266 HAL_TIM_Base_Start_IT(&htim6);
267
268 /* Wind the tick forward by the number of tick periods that the CPU
269 remained in a low power state. */
270 vTaskStepTick(ulCompleteTickPeriods);
271 }
272 }
When the MCU exists from the sleep mode, either because the timer has overflowed or another
interrupt has been generated, the configPOST_SLEEP_PROCESSING() macro allows us to perform
needed operations, such as restoring some peripherals or increasing the clock speed. Now the tricky
part takes place, and we need to careful explain the operation involved.
After the MCU ha exited from low-power mode, ISRs are unmasked by exiting critical section
(line 203). This will cause that the TIM6_IRQHandler() ISR is called if we have exited from the
sleep mode due to a timer overflow. When this happens the HAL_TIM_PeriodElapsedCallback()
Running FreeRTOS 681
function is called: this causes that the ucTickFlag is set to TRUE and the timer Period to the standard
value(29).If,instead,theMCUhasexitedfromthelow-powermodeforanotherreason(forexample,
it has been awakened by the UART_RX interrupt), the ucTickFlag is equal to FALSE .
The code checks the status of the ucTickFlag at line 210. If it is equal to TRUE , then the global tick
counter is increased for a value equal to xExpectedIdleTime minus one, because the tick counter
has been already incremented by the HAL_TIM_PeriodElapsedCallback() routine by one (the ISR is
called as soon as we leave the critical section at line 203). If, instead, it is equal to FALSE , then we
compute how long the MCU has spent in sleep mode and we increase the tick counter accordingly.
This policy could be adapted according your actual needs. For example, if you are working on an
STM32L platform you may consider to use a LPTIM timer during the stop mode, so that you can
know how many ticks are elapsed during the stop mode (a regular STM32 timer do not work in stop
mode).
A Note About LPTIM Timers
I have spent a lot of time trying to use a LPTIM timer as timebase generator. While it works
well as a regular timer, I reached to the conclusion that LPTIM timers are not suitable to
be used with the tickless mode, because they are implemented so that reading the value
of the counter register ( LPTIM->CNT ) is not reliable, especially when the timer exits from
deeper low-power modes. This is clearly stated in the official STM32 documentation and it
constitutes a severe limit of this peripheral, according this author.
23.9 Debugging Features
The debugging of a firmware built using an RTOS could not be trivial. Context switches can make
complicated to perform step-by-step debugging. FreeRTOS offers some debugging features, and
some of them are useful especially when your design uses a lot of threads spawned dynamically.
23.9.1 configASSERT() Macro
FreeRTOS source code is full of calls to the macro configASSERT() . This is an empty macro that
developers can define inside the FreeRTOSConfig.h , and it plays the same role of the C assert()
function. CubeMX automatically defines it for us in the following way:
#define configASSERT( x ) if ((x) == 0) {taskDISABLE_INTERRUPTS(); for( ;; );}
The macro works so that if the assert condition is false then all interrupts are disabled (by setting the
PRIMASK register on Cortex-M0/0+ cores and rising the BASEPRI value in other STM32 MCUs) and
an infinite loop takes place. While this behaviour is ok during a debug session, it can be a source of
a lot of headaches if our device is not running under a debugger, because it is hard to say why the
firmware stopped working. So, this author prefers to define the macro in this other ways:
Running FreeRTOS 682
void __configASSERT(uint8_t x) {
if ((x) == 0) {
taskDISABLE_INTERRUPTS();
if((CoreDebug->DHCSR & 0x1) == 0x1) { /* If under debug */
HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
HAL_Delay(1000);
asm("BKTP #0");
} else {
HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
HAL_Delay(100);
}
}
}
#define configASSERT( x ) __configASSERT(x)
The __configASSERT() function uses the Cortex-M CoreDebug interface to check if the MCU is
under debug: debuggers set the first bit of the Debug Halting Control and Status Register (DHCSR)
when the MCU is under debugging. If so, a software breakpoint is placed when the assert condition
is false. However, this function has two relevant limitations:
• it works only on Cortex-M3/4/7 based microcontrollers;
• the DHCSR register is not reset to zero when a system reset occurs, neither it is possible to
clear the first bit within the firmware; this means that we need to completely power OFF the
device, otherwise the firmware will stuck if the assert condition is false.
23.9.2 Run-Time Statistics and Thread State Information
Whenthreadsarespawneddynamically,itishardtokeeptrackoftheirlifecycle.FreeRTOSprovides
a ways to retrieve both the complete list of live threads and some relevant information regarding
their status.
The uxTaskGetNumberOfTasks() function returns the number of live threads. With the term live
threads we mean all threads effectively allocated by the kernel, even those ones marked asdeleted⁴¹.
The function
UBaseType_t uxTaskGetSystemState(TaskStatus_t * const pxTaskStatusArray,
const UBaseType_t uxArraySize, unsigned long * const pulTotalRunTime );
returns the status information of every thread in the system, by populating an instance of the
TaskStatus_t structure for each thread. The TaskStatus_t structures is defined in the following
way:
⁴¹ Deleted threads usually persist in memory for really short time. When a thread is marked for deletion, it is effectively moved out from
the system by the idle thread.
Running FreeRTOS 683
typedef struct xTASK_STATUS {
TaskHandle_t xHandle; /* The handle of the thread to which the rest of the
information in the structure relates */
const char *pcTaskName; /* A pointer to the thread's name */
UBaseType_t xTaskNumber; /* Corresponds to Thread ID */
eTaskState eCurrentState; /* The state in which the thread existed when the
structure was populated */
UBaseType_t uxCurrentPriority; /* The priority at which the thread was running */
UBaseType_t uxBasePriority; /* The priority to which the thread will return
if the thread's current priority has been inherited
to avoid unbounded priority inversion when obtaining
a mutex. Only valid if configUSE_MUTEXES is defined
as 1 in FreeRTOSConfig.h. */
uint32_t ulRunTimeCounter; /* The total run time allocated to the thread so far,
as defined by the run time stats clock. */
uint16_t usStackHighWaterMark; /* The minimum amount of stack space that has remained
for the thread since the thread was created */
} TaskStatus_t;
The uxTaskGetSystemState() accepts a pre-allocated array containing the instances of TaskHan-
dle_t structures for each thread, the maximum number of elements that the array can hold
( uxArraySize ) and a pointer to a variable ( pulTotalRunTime ) that will contain the total run-time
since the kernel started. FreeRTOS, in fact, can optionally collect information on the amount of
processingtimethathasbeenusedbyeachthread.Therun-timestatisticsmustbeexplicitlyenabled
by defining the configGENERATE_RUN_TIME_STATS macro in the FreeRTOSConfig.h . Moreover, this
feature requires that we use another timer different from the one used to feed the tick counter. This
because the run-time statistics timebase needs to have a higher resolution than the tick interrupt,
otherwise the statistics may be too inaccurate to be truly useful.
If thread functions are well designed, and they do not make use of busy loops, usually a thread
lasts for less then the tick time, which is equal to 1ms and it represents the maximum slice time
dedicated to a thread. However, the run-time statistics work so that before the thread is moved in
running state the current value of the timer used for statistics is saved. When a thread exits from
the running state (either because it yields the control or its quantum time is over) a comparison is
performed between the previous saved time and the current one. If the tick timer is used for this
operation, this difference is always equal to zero. For this reason, it is recommended to configure
the timebase generator for statistics between 10 and 100 times faster than the tick interrupt. The
faster the timebase the more accurate the statistics will be - but also the sooner the timer value will
overflow.
When the configGENERATE_RUN_TIME_STATS macro is set to 1, we have to provide two additional
macros. The first one, portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() , is used to setup the timer
needed for run-time statistics. The second one, portGET_RUN_TIME_COUNTER_VALUE() , is used by
FreeRTOS to retrieve the cumulative value of the timer counter. Since this timer needs to run really
fast, it is not suggested to setup its ISR and to increase a global variable when it expires: this would
affect the overall system performance. In STM32 MCUs providing a 32-bit timer it is sufficient to
Running FreeRTOS 684
use one of these, setting the Period to the maximum value ( 0xFFFFFFFF ). Another alternative, on
Cortex-M3/4/7 consists in using the DWT cycle counter, as seen in Chapter 11. The following code
shows a possible implementation for the two macros:
#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() \
do { \
DWT->CTRL |= 1 ; /* enable the counter */ \
DWT->CYCCNT = 0; \
}while(0)
#define portGET_RUN_TIME_COUNTER_VALUE() DWT->CYCCNT
We are now going to analyze a complete tracing implementation, which consists in having a
dedicated thread that prints on the UART2 interface statistic information when the Nucleo USER
button is pressed.
Filename: src/main-ex7.c
32 void threadsDumpThread(void const *argument) {
33 TaskStatus_t *pxTaskStatusArray = NULL;
34 char *pcBuf = NULL;
35 char *pcStatus;
36 uint32_t ulTotalRuntime;
37
38 while(1) {
39 if(HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == GPIO_PIN_RESET) {
40 /* Allocate the message buffer. */
41 pcBuf = pvPortMalloc(100 * sizeof(char));
42
43 /* Allocate an array index for each task. */
44 pxTaskStatusArray = pvPortMalloc(xTaskGetNumberOfTasks() * sizeof(TaskStatus_t));
45
46 if(pcBuf != NULL && pxTaskStatusArray != NULL) {
47 /* Generate the (binary) data. */
48 uxTaskGetSystemState(pxTaskStatusArray, uxTaskGetNumberOfTasks(), &ulTotalRuntime);
49
50 sprintf(pcBuf, " LIST OF RUNNING THREADS \r\n
51 -----------------------------------------\r\n");
52 HAL_UART_Transmit(&huart2, (uint8_t*)pcBuf, strlen(pcBuf), HAL_MAX_DELAY);
53
54 for(uint16_t i = 0; i < uxTaskGetNumberOfTasks(); i++ ) {
55 sprintf(pcBuf, "Thread: %s\r\n", pxTaskStatusArray[i].pcTaskName);
56 HAL_UART_Transmit(&huart2, (uint8_t*)pcBuf, strlen(pcBuf), HAL_MAX_DELAY);
57
58 sprintf(pcBuf, "Thread ID: %lu\r\n", pxTaskStatusArray[i].xTaskNumber);
59 HAL_UART_Transmit(&huart2, (uint8_t*)pcBuf, strlen(pcBuf), HAL_MAX_DELAY);
60
Running FreeRTOS 685
61 sprintf(pcBuf, "\tStatus: %s\r\n",
62 pcConvertThreadState(pxTaskStatusArray[i].eCurrentState));
63 HAL_UART_Transmit(&huart2, (uint8_t*)pcBuf, strlen(pcBuf), HAL_MAX_DELAY);
64
65 sprintf(pcBuf, "\tStack watermark number: %d\r\n",
66 pxTaskStatusArray[i].usStackHighWaterMark);
67 HAL_UART_Transmit(&huart2, (uint8_t*)pcBuf, strlen(pcBuf), HAL_MAX_DELAY);
68
69 sprintf(pcBuf, "\tPriority: %lu\r\n", pxTaskStatusArray[i].uxCurrentPriority);
70 HAL_UART_Transmit(&huart2, (uint8_t*)pcBuf, strlen(pcBuf), HAL_MAX_DELAY);
71
72 sprintf(pcBuf, "\tRun-time time in percentage: %f\r\n",
73 ((float)pxTaskStatusArray[i].ulRunTimeCounter/ulTotalRuntime)*100);
74 HAL_UART_Transmit(&huart2, (uint8_t*)pcBuf, strlen(pcBuf), HAL_MAX_DELAY);
75 }
76 vPortFree(pcBuf);
77 vPortFree(pxTaskStatusArray);
78 }
79 }
80 osDelay(100);
Thecodeshouldbefairlyeasytounderstand.WhentheUSERbuttonispressed,thisthreadallocates
a buffer ( pxTaskStatusArray ) that will contain the TaskStatus_t structures for each thread in the
system. The uxTaskGetSystemState() at line 48 populates this array, and for each thread contained
in it some statistics are printed on the Nucleo VCP.
Whereas uxTaskGetSystemState() populatesa TaskStatus_t structureforeachthreadinthesystem,
vTaskGetInfo() populates a TaskStatus_t structures for just a single task, and it can be useful if we
want retrieve information about a specific thread.
Finally, FreeRTOSprovides some convenient routinesto automatically format the raw data statistics
into a human readable (ASCII) format. For example, the vTaskGetRunTimeStats() formats the raw
data generated by uxTaskGetSystemState() into a human readable (ASCII) table that shows the
amount of time each task has spent in the running state (how much CPU time each task has
consumed). For more information, refer to this page⁴² of the on-line FreeRTOS documentation.
23.10 Alternatives to FreeRTOS
As stated in the introduction to this book, there are several good alternatives to FreeRTOS on the
market. Here you will find some words about other good RTOS available for the STM32 platform.
⁴² http://www.freertos.org/rtos-run-time-stats.html
Running FreeRTOS 686
23.10.1 ChibiOS
If you are not new to the STM32 platform, probably you already know about ChibiOS⁴³. ChibiOS
is an independent and open source project started by an STMicroelectronics engineer, Giovanni Di
Sirio, who works at the ST site in Naples (Italy). ChibiOS is quite popular in the STM32 community,
due to the fact that Giovanni has a deep knowledge of the STM32 platform, and this has allowed to
him to create probably one of the most optimized solution for STM32 MCUs. However, ChibiOS is
designed to run on any MCU architecture apart from STM32.
ChibiOS is essentially composed by two layers: the kernels (named ChibiOS/RT or ChibiOS/NIL)
and a complete HAL (named Chibios/HAL), which allows to abstract from the underlying hardware
peculiarities.WhileitisperfectlypossibletomixtheofficialSTCubeHALwiththeChibiOS/RT/NIL
kernels, probably the ChibiOS/HAL is a simpler solution to program STM32 devices, at least for the
supported peripherals. Even if this author does not have a direct experience with it, ChibiOS has a
really good reputation among a lot of people he knows and some readers of this book. Moreover,
you can find several projects and good tutorials around in the web⁴⁴ based on this RTOS and
its related HAL. Different from the current production release of FreeRTOS, Chibios uses a full
static memory allocation model, allowing to use it in those application domains where dynamic
allocation is prohibited. Finally, Giovanni also provides a pre-configured version of Eclipse, named
ChibiStudio,whichshipsallrequiredtools(GCCtool-chain,OpenOCD,etc.)alreadypre-configured.
Unfortunately, it runs only on the Windows OS at the time of writing this chapter.
ChibiOS uses a mixed licensing model. ChibiOS RT and NIL kernels are distributed under the GPL 3
license, HAL is distributed under the more permissive Apache 2.0 license. GPL 3 prevents the usage
of the software if you sell electronic devices without releasing the firmware source code publicly. A
“free commercial license” exists that removes GPL 3 for commercial users. This license requires a
registration process and it is valid for 500 MCU cores. The free license can be renewed indefinitely
by just re-submitting the request form for extra 500 cores.
23.10.2 Contiki OS
Contiki⁴⁵ is another open source RTOS, which has a strong accent on wireless low-power sensors
and IoT devices. It is a project started by Adam Dunkels in 2003, but it is currently supported by
several large companies including Texas Instruments and Atmel. It is quite popular among CC2xxx
devicesfromTI.ItisbasedonakernelschedulerandanindependentTCP/IPstackdesignedforlow-
resources devices, which provides IPv4 networking, the uIPv6 stack and the Rime stack, which is a
setofcustomlightweightnetworkingprotocolsdesignedforlow-powerwirelessnetworks.TheIPv6
stack was contributed by Cisco and was, when released, the smallest IPv6 stack to receive the IPv6
Ready certification. The IPv6 stack also contains the Routing Protocol for Low power and Lossy
Networks (RPL) routing protocol for low-power lossy IPv6 networks and the 6LoWPAN header
compression and adaptation layer for IEEE 802.15.4 links.
⁴³ http://www.chibios.org/
⁴⁴ http://www.playembedded.org/
⁴⁵ http://www.contiki-os.org/
Running FreeRTOS 687
ST provides an application note, the UM2000⁴⁶, which describes how to get started with the Contiki
OSonitsmicrocontrollers,inconjunctionwiththeSPIRITtransceivertodevelopsub-1GHzwireless
devices.
Contiki is distributed with a BSD-style license, which allows to use its source code in commercial
applications without any form of limitations.
23.10.3 OpenRTOS
OPENRTOS is the commercial edition of FreeRTOS, described in this chapter and officially
supported by ST. OPENRTOS and FreeRTOS share the same code base. The additional value offered
by OPENRTOS is a “commercial and legal wrapper” for FreeRTOS users.
Developers upgrade to an OPENRTOS license for two main reasons: the ability to sell their devices
and/or to ship derived code without having to share source code publicly, and the dedicated support
in developing custom solutions based on OPENRTOS. For large companies the possibility to receive
paid support is really important.
⁴⁶ http://bit.ly/1URnLZc
24. Advanced Debugging Techniques
In Chapter 5 we have started analyzing basic tools and techniques to debug the firmware running
on a target microcontroller. We studied some important Eclipse features, like breakpoints and step-
by-step debugging, useful to understand what’s going wrong with our code. Moreover, we deeply
analyzed the way ARM semihosting works, a technique that exploits the ARM bkpt assembly
instruction to pass the control to the debugger so that data can be transferred from the MCU to
the OpenOCD debugger and vice versa. This feature is extremely useful especially if our device
does not provide a dedicated UART interface or if we want to use some functionalities that it would
be too complicated to perform on a low-cost embedded architectures. Those techniques, however,
could be not sufficient to debug real-life applications. Things can go wrong in several ways and it
is quite common the need of dedicated, and often expensive, hardware tools to better debug our
embedded applications.
This chapter aims to introduce the reader to some advanced debugging capabilities offered by
Cortex-M based microcontrollers. The role of Cortex-M exceptions is finally presented, showing
how to decode some relevant core registers that can provide really useful information about the
exception source. This chapter also provides a brief introduction to the ARM CoreSight TM features
implemented in Cortex-M3/4/7 MCUs, a distinctive ARM technology that allows to perform real-
time tracing of the MCU activities using an external debugger tool.
This chapter is not limited to low-level debugging techniques . We will also see in action some other
features offered by the GNU MCU Eclipse tool-chain, like debug expressions and Keil Packs, and we
will analyze the features offered by the CubeHAL to improve error management and to optimize
the debugging process.
In an ideal world, this chapter would come right after the Chapter 5. Information reported
hereisimportanttoperformanefficientdebugduringtheearlyexperienceswiththeSTM32
platform. Unfortunately, to master concepts illustrated in this chapter, you need to study
several other topics before you can deeply understand the techniques and tools shown here.
Asaruleofthumb,thisauthorsuggeststoreadatleastchapters7and15beforeapproaching
this one.
24.1 Understanding Cortex-M Fault-Related Exceptions
At beginning of this long journey we have seen that Cortex-M based microcontrollers implement
a number of system-related exceptions. Some of them are fault-related, that is those exceptions
are triggered when something wrong happens during the normal execution flow. By implementing
properhandlersforthosefault-relatedexceptions,wecangetridofthefaultorigin.Thisisextremely
Advanced Debugging Techniques 689
useful during debugging, because it helps us isolating the issue from the rest of the application.
However, a correct fault-handling can be useful even in a “production” firmware: once a fault is
detected, we may place the device in a safe state before trying to reset the board.
Cortex-M3/4/7 cores offer to programmers four fault-related exceptions (see Table 1 in Chapter 7):
• Memory Management Fault
• Bus Fault
• Usage Fault
• Hard Fault
The first three exceptions are triggered when specific faults take place and they are available only in
Cortex-M3/4/7cores.Thelastone,theHardFault exception,istheonlyoneavailableeveninCortex-
M0/0+ cores. It is also called the generic fault exception, due to the fact that it cannot be disabled
and it acts as a collector for specific fault conditions when the other fault-related exceptions are
disabled.
When a fault exception is raised, we can try to derive the cause of fault by analyzing the content of
some “system registers”. Moreover, the simple analysis of the stack trace can bring us to the root of
fault condition at least in the majority of fault causes.
What circumstances can generate a system fault? Answering to this obvious question is not trivial.
The most frequent source of fault is a bug in the firmware, especially during the development stage.
An access to an invalid memory location (quite often due to a broken pointer) is the most frequent
source of fault conditions. An invalid or a non well-implemented vector table is another common
source of faults. A stack overflow is another quite frequent fault condition, especially in low-cost
STM32 MCUs when running an RTOS.
Sometimes, the origin of the fault is not related to the software, but it may be caused by external
factors such as:
• Poor PCB design and layout (this is more common than you might think).
• Unstable or poor power supply (quite common in poor designs).
• Electrical noise (this is especially true for devices operating in rush environments).
• Electromagnetic interference (EMI) or electrostatic discharge (ESD).
• Extreme operation environment (e.g., temperature, humidity, etc.).
• Damage of some components (e.g., Flash/EEPROMs devices, crystal oscillators, electrolytic
capacitors).
• Radiations.
To diagnose the above nasty fault-conditions is really hard. Those are conditions that no hardware
developer would ever want to meet and they are outside the scopes of this book. Here we will
focus only on software-related faults and to the ways to identify them. However, before starting
analyzing the causes that trigger the four fault-related exceptions, it is fundamental to analyze the
way an exception is generated from the software point of view. This is important to identify, or at
least to try to, the code that leads to a fault exception.
Advanced Debugging Techniques 690
24.1.1 The Cortex-M Exception Entrance Sequence and the ARM
Calling Convention
For high-level programmers¹, to invoke a routine seems an obvious thing. We just write down the
nameofthefunctionwearegoingtocall,passingtoitagivennumberofparameters.However,from
the processor point-of-view, what happens under the hood needs to be specified down to the finest
details and it must match both the processor architecture and the programming language semantics.
For this reason, it is common to talk aboutcalling convention when describing the process of placing
a new routine on the stack.
TheARMArchitectureProcedureCallStandard (AAPCS)preciselydefinesthecallingconventionfor
ARMbasedarchitectures.InChapter1wehaveseenthatCortex-Mbasedmicrocontrollersprovidea
numberofcoreregisters,whichareshownagaininFigure1foryourconvenience.Notallthosecore
registers are available in all Cortex-M cores: for example, FPU registers S0-S31 are only available in
Cortex-M4F and Cortex-M7 cores, when the FPU unit is enabled and used.
Figure 1: Cortex-M CPU core registers
Some core registers play a special role, because they are used to carry out processor’s activities.
R13 is the Stack Pointer (SP), that is the pointer in SRAM (so something similar to 0x2000 XXXX
in an STM32) to the base of the most recent entry placed on the stack. This entry represents the
local memory area of a given function and, in a full-descendent stack, SP coincides with the lowest
address of the stack. R14 is the Link Register (LR), that is the address in FLASH² (so something
similar to 0x0800X XXXX in an STM32) of the instruction following the instruction that called the
¹ As C programmers, we are all “high level programmers”, whether you believe it or not.
² This is not entirely true, because CPU could execute code placed in SRAM as well as in other external memories. But it is ok to consider
it true here.
Advanced Debugging Techniques 691
given function on the stack. R15 is the Program Counter (PC), that is the register that contains the
address in FLASH memory of the current assembly instruction.
R0-R3 registers play another important role in the ARM calling convention. They are used to store
the first four parameters to pass to the called function (from now on, we will use the term callee
to indicate the called function, and caller to indicate the function that calls the another one). If
the callee uses less than four parameters, then the first four general purpose registers contain
the content of those parameters. Clearly, here we are assuming that arguments are word aligned
(four bytes aligned). If, instead, our function accepts more than four parameters, or their total size
exceeds sixteen bytes, than we need to allocate sufficient room on the callee stack to store the other
parameters, before passing the control to the callee. This usage of R0-R3 registers allows to speedup
calling process and to reduce the amount of used SRAM. Finally, R0-R1 registers are also used to
store the function return value. So, a good rule would be to restrict the number of parameters to
a maximum of four wherever possible. If that isn’t possible, then you should try to place the most
frequently accessed parameters in R0-R3 (that is, define them as the first four function parameters)
so that stack accesses in the callee are minimized.
Since some of the general-purpose registers play specific roles, as a callee we cannot modify their
content freely, but we must adhere to the following conventions:
• Callee can freely modify registers R0, R1, R2 and R3.
– This implies that caller needs to save their content (if they are used to store relevant data
for the caller) before passing the control to the callee.
• Callee cannot assume anything on the contents of R0, R1, R2 and R3 unless they are playing
the role of parameters.
• Callee can freely modify LR register but the value upon entering the function will be needed
when leaving the function (so this value need to be stored in the callee stack frame).
• Callee can modify all the remaining registers as long as their values are restored upon leaving
the function. This includes SP and registers R4-R11. This means that, after calling a function,
we have to assume that (only) registers R0-R3, R12 and LR have been overwritten.
• A function should not make any assumption on the contents of the Current Program Status
Register (CPSR).
• If FPU is enabled and used, callee can freely modify S0-S15 registers, which must be saved
(together with the FPSCR register) by the caller before calling the callee. Instead, callee needs
to save content of the S16-S31 registers before changing their content.
• R12 is a special “scratch register” used by linkers to perform dynamic linking. Not that useful
in true-embedded microcontrollers like Cortex-M ones, but it is a register that must be saved
by the caller according AAPCS³.
So, to recap, from the caller point-of-view, before invoking another routine we need to save the
content of the following registers: R0-R3, R12, R14, CPSR (plus S0-S15 and FPSCR if FPU is enabled).
These registers are highlighted in red in Figure 1.
³ It is important to underline that the same ARM calling convention applies to Cortex-A based microprocessors, which have all the features
to handle dynamic linking with high-level OSes like Linux and Windows.
Advanced Debugging Techniques 692
As high-level programmers, we do not need to take care about these rules. It is a compiler task to
ensure that AAPCS rules are respected. In Chapter 7 we saw that a distinctive feature of Cortex-
M cores is the ability to use regular C functions as exception handlers. This means that exception
handlers are “stacked” on the main stack as a regular C routine. But this implies that, in order to
allow a C function to be used as an exception handler, the exception mechanism needs to adhere to
the requirements of the AAPCS calling convention and so it needs to save automatically those “red”
registers in Figure 1 at exception entrance, and restore them at exception exit under the control of
the processors. In this way when returned to the interrupted program, all registers would have the
same values as when the interrupt entry sequence started.
In addition, since an exception corresponds to an interruption of the main program flow, and since
it can fire anytime, we need to save the content of the PC, otherwise we do not have a way to
return back to the main flow when the exception exits. In a regular function call, the value of the
PC is stored inside the LR register by the branching instructions. Instead, when an exception fires
the value of the return address (PC) is not stored in LR (the exception mechanism puts a special
EXC_RETURN code in LR at exception entry, which is used in exception return - we will analyze it in
a while), and the value of the return address also needs to be saved by the exception sequence.
So in total eight registers need to be saved during the exception handling sequence on the Cortex-M
based microcontrollers:
Figure 2: How core registers are stacked by the CPU on exception entrance
• R0-R3
• R12
• SP
Advanced Debugging Techniques 693
• LR
• CPSR
In addition, S0-S15 and FPSCR register need to be saved if the FPU is used.
Where does the processor store these registers? Obviously, they are stored on the stack⁴, right at
the beginning of the exception handler’s stack frame. This procedure is called stacking and Figure
2 clearly shows the process. Please note that in Figure 2 the color of core registers is lighter than
the one used in Figure 1. This because it is important to underline that the processors stores in
that locations the content of core registers before entering in the exception sequence. When the
exception fires, the content of core registers are updated with the data related to the exception
context (for example, the PC will point to the first instruction of the exception handler, or the SP
will point to the top of MSP right after the stacked core registers).
The content of saved core registers can be really useful in evaluating what did generate a fault
exception. For example, if a fault exception triggers due to an access to an invalid memory location
(maybe due to a broken pointer), by inspecting those registers we can try to understand the place
where the illegal memory access is performed. So the question is: as high-level programmers, do we
have a way to access to those values? For sure! We only need a little bit of assembly programming.
Let us suppose we want to access to the content of stacked register when the EXTI15_10_IRQHan-
dler() isinvoked(thisistheISRcalledwhenthePC13pin-connectedwiththeNucleo’sbluebutton
- is configured in interrupt mode on the majority of STM32 microcontrollers). We can define the ISR
in the following way:
1 void EXTI15_10_IRQHandler(void) {
2 asm volatile(
3 " tst lr,#4 \n"
4 " ite eq \n"
5 " mrseq r0,msp \n"
6 " mrsne r0,psp \n"
7 " mov r1,lr \n"
8 " ldr r2,=EXTI15_10_IRQHandler_C \n"
9 " bx r2"
10 );
11 }
12
13 EXTI15_10_IRQHandler (uint32_t *core_registers, uint32_t lr) {
14 /* core_registers points to the R0-R3, R13, SP and CPSR
15 registers, while the lr argument contains the content
16 of the LR register just before the exception entrance */
17 ....
18 }
⁴ Here the story is a little bit more complex. Depending on the usage of an RTOS, there could be “multiple” stacks at the same time: aMain
Stack or a stack specific for the single thread, called Process Stack. This topic is outside the scope of this book. For more information about it,
refer to the excellent book by Joseph Yiu(http://amzn.to/1P5sZwq) about Cortex-M architectures.
Advanced Debugging Techniques 694
The above assembly code may seem hard to understand, but instead is not that black magic art. The
tst instruction performs a bitwise comparison between the content of the LR register (the current
register, not the one saved on the stack) and the literal 4. If they match (that is, the fourth bit of LR
register is set to 1), then the PSP stack was the one used at the time of exception entrance. Otherwise
the MSP was the current used stack. The reason why this check is performed will be clear soon. Take
it as is here.
Instruction at line 7 does a simple thing (this is the tricky part): the content of the current LR register
is placed in the R1 register, and the function EXTI15_10_IRQHandler_C() is called (note the final
_C ). This other function accepts two parameters: core_registers and lr . According to the AAPCS
specification, core_registers will coincide with the register R0⁵ while lr with the content of R1.
When the exception handler is entered, R0 coincides with the starting address on the current stack
(MSP or PSP) where the core registers have been stored.
Figure 3: How current R0-R1 registers point to stacked register and actual LR register
Figure 3 clearly explains this. As you can see, core_registers corresponds to the R0 register, which
holds the base address of stacked registers. lr corresponds to the R1 register, whose content has
been filled with the one of the actual LR register by the assembly instruction at line 7. We can so
access to stacked registers from the EXTI15_10_IRQHandler_C() routine, and perform analysis of
their content, as we will see later.
⁵ Please, take note that the core_registers parameter is a pointer, so the R0 register will contain the memory location (a 32-bit integer)
where the core registers have been saved.
Advanced Debugging Techniques 695
24.1.1.1 How the GNU MCU Eclipse Tool-chain Handles Fault-Related Exceptions
The GNU MCU Eclipse tool-chain already provides an implementation for the Cortex-M fault
handlers. The tool-chain handlers collect information about the stacked core registers and prints
their content using ARM semihosting or the ITM interface, an advanced debugging feature that
we will analyze later in this chapter. Default handlers are defined inside the system/src/cor-
texm/exception_handlers.c file and they are defined with the GCC weak attribute, so that you
are free to redefine them in your code. You can enable ARM semihosting, by enabling the macro
OS_USE_TRACE_SEMIHOSTING_DEBUG at project level, so that the default handlers automatically print
the core registers content on the OpenOCD console. The tool-chain handlers also include a software
breakpoint using the BKPT #0 assembly instruction, as shown in Chapter 5. This will automatically
stop the code execution so that we can be warned of the fault condition during debugging.
Read Carefully
Please take note that latest CubeMX releases can generate function prototypes for the
fault handlers automatically. They are generated inside the src/stm32XXxx_it.c file. Once
generated, they clearly override the tool-chain handlers, and so you will not be able to see
on the OpenOCD console the registers content once a fault exception is raised. If you do
not need custom fault handlers, then check the CubeMX configuration so that it does not
generate them.
Figure 4: How Eclipse shows the call stack once a fault exception raises
The GNU MCU Eclipse tool-chain is also able to graphically show the call stack, so that you can
understand the line of code that generated a fault exception. The Eclipse IDE is able to automatically
Advanced Debugging Techniques 696
decode the content of the stacked core registers and to show you the source code that is supposed
to cause the fault. Figure 4 shows on the right the content of the stacked core registers as printed
by the default handler routine⁶. As you can see the value of the stacked PC coincides with the one
shown in the call stack by the Eclipse IDE (rectangular box highlighted in red). Moreover, the call
stack also shows the content of the current LR register, which is also called the EXC_RETURN value.
24.1.1.2 How to Interpret the Content of the LR Register on Exception Entrance
In Cortex-M based processors, the exception return mechanism is triggered using a special return
address called EXC_RETURN . This value is generated at exception entrance and it is stored in the
Link Register (LR). When this value is written to the PC with one of the allowed function return
instructions, it triggers the exception return sequence.
The EXC_RETURN address does not correspond to actual FLASH addresses. It can assume up to six
values, which are listed in Table 1.
Table 1: EXC_RETURN possible values and their interpretation
EXC_RETURN Return Mode Return Stack FPU Enabled Description
0xFFFF FFF1 0 (Handler) MSP N Returns to handler mode (using MSP)
0xFFFF FFF9 1 (Thread) MSP N Returns to thread mode (using MSP)
0xFFFF FFFD 1 (Thread) PSP N Returns to thread mode (using PSP)
0xFFFF FFE1 0 (Handler) MSP Y Returns to handler mode (using MSP)
0xFFFF FFE9 1 (Thread) MSP Y Returns to thread mode (using MSP)
0xFFFF FFED 1 (Thread) PSP Y Returns to thread mode (using PSP)
For example, if the CPU was running “regular code” (that is, the CPU was in Thread mode) before
entering the exception, if the stack used was the MSP and if the FPU unit was disabled, then the
LR register contains the value 0xFFFF FFF9 . If, instead, the CPU was servicing another exception
(maybe an interrupt) when the current exception entered (that is, the CPU was in Handler mode),
then the content of the LR register is 0xFFFF FFF1 .
It is thanks to the EXC_RETURN mechanism that regular C functions can be used as exception
handlers without writing any lines of assembly code. This differs from other microcontroller
architectures, where additional work from the compiler (or from the developer) is needed to handle
the stacking/unstacking of exception handlers.
⁶ For the sake of completeness, we have to say that the Figure 4 is showing an imprecise BusFault, that is the PC does not point to the line
that generated the fault but, instead, it is currently pointing to the next one. The reason why this happens will be explained better later.
Advanced Debugging Techniques 697
Figure 5: How the EXC_RETURN value is interpreted
Figure 5 shows the complete structure of the EXC_RETURN value. As you can see, the fourth bit
indicates which stack was used at the time the fault condition triggers. This clearly explains the
usage of the tst instruction in the previous assembly code to detect the used stack.
24.1.2 Fault Exceptions and Faults Analysis
The fault exception mechanism provided by Cortex-M CPU is really useful to detect sources of
faults. During the development lifecycle it is really common to have fault conditions, especially if
you are new to the STM32 platform or the embedded programming.
This paragraph shows a brief overview of the analysis of fault conditions. It does not aim to replace
the official ARM documentation or the excellent work from Joseph Yiu⁷(http://amzn.to/1P5sZwq).
Its main goal is to provide the necessary tools and concepts to understanding what’s going wrong
when one of the four fault exceptions is raised.
Cortex-M3/4/7 cores provide a number of registers that are used for fault analysis. They may be
used by the fault handler code, but in the majority of cases they are used during a debug session.
Table 2 lists the available registers useful to fault analysis.
Table 2: Registers for fault status and address information
CMSIS Symbol Register name Description
SCB->CFSR Configurable Fault Status Register Provides status information about configurable
exceptions (MemFault, BusFault, UsageFault)
SCB->HFSR Status for HardFault Provides status information for the HardFault
exception
SCB->DFSR Debug Fault Status Register Provides status information for the Debug
Monitor exception
SCB->MMFAR MemManage Fault Address Register If available, shows the address that triggered the
MemManage fault
SCB->BFAR BusFault Address Register If available, shows the address that triggered the
BusFault fault
SCB->CFSR is the Configurable Fault Status Register and it provides information for those exceptions
that can be optionally enabled (MemFault, BusFault, UsageFault). It is in turn dived in three sub-
registers,asshowninFigure6.Wearegoingtoprovideacompletedescriptionofthemintherelated
⁷ http://amzn.to/1P5sZwq
Advanced Debugging Techniques 698
sub-paragraphs.
Figure 6: How the SCB->CFSR is further divided in three sub-registers
24.1.2.1 Memory Management Exception
This exception can be triggered due to a violation of access rules defined by the MPU configuration.
Forexample,itistriggeredwhentryingtoaccessinwritemodetoaregiondefinedasreadonly.This
exception is available only in Cortex-M3/4/7 cores and it must be enabled. Once enabled, individual
bits of the SCB->MFSR register (which corresponds to the first byte of the SCB->CFSR register) can
assume the values reported in Table 3. The SCB->MFSR register is set to 0x0 upon reset, and its values
stayhighuntilavalueof1iswrittentotheregister.Byinspectingindividualbitvalueswecanderive
more information about the fault cause. For example, if the DACCVIOL bit is set, then an access to a
protected memory location caused the exception. In this case the MMARVALID bit is set, the register
SCB->MMFAR contains the destination memory location that generated the fault. To see this exception
at work, try to execute the example provided in the paragraph about the MPU unit.
Table 3: MemManage Fault Status Register ( SCB->MFSR )
Bit Name Description
7 MMARVALID Indicates that the content of SCB->MMFAR register is valid
6 RESERVED RESERVED
5 MLSPERR Floating point lazy stacking error (available on Cortex-M4F cores only)
4 MSTKERR Stacking error
3 MUNSTKERR Unstacking error
2 RESERVED RESERVED
1 DACCVIOL Data access violation
0 IACCVIOL Instruction access violation
24.1.2.2 Bus Fault Exception
This exception is mostly raised due to wrong access either to SRAM memory or program memory.
The two more frequent source of Bus Fault exception are a wrong pointer to an illegal SRAM
memory region and a bad function pointer. In addition, the bus fault can also occur during stacking
and unstacking of the exception handling sequence: * If the bus error occurred during stack pushing
in the exception entrance sequence, it is called a stacking error. * If the bus error occurred during
stack popping in the exception exit sequence, it is called an unstacking error.
Usually a stacking error indicates a stack overflow: the stack runs out of space and this causes
Bus Fault due to an access to an invalid SRAM location. The exception system triggers the fault
Advanced Debugging Techniques 699
exception, but the CPU cannot push saved core register on the full stack. This causes a stacking
error, which in turn triggers a Hard Fault. By accessing to the SCB->BFSR we can see that both bits
15 and 12 are set. The content of the SCB->BFAR is so valid, and we can see that it contains something
equal to 0x1fff bff8 . This is an invalid SRAM location in STM32 MCU, and so we can easily derive
that a stack overflow happened.
Table 4 shows the meaning of individual bits in the SCB->BFSR register.
Table 4: Bus Fault Status Register ( SCB->BFSR )
Bit Name Description
15 BFARVALID Indicates that the content of SCB->BFAR register is valid
14 RESERVED RESERVED
13 LSPERR Floating point lazy stacking error (available on Cortex-M4F cores only)
12 STKERR Stacking error
11 UNSTKERR Unstacking error
10 IMPRECISERR Imprecise data access error
9 PRECISERR Precise data access error
8 IBUSERR Instruction access error
Bus faults can be classified as:
• Precise bus faults: the fault exceptions happened immediately when the memory access
instruction is executed.
• Imprecise bus faults: the fault exceptions happened sometime after the memory access
instruction is executed.
Thereasonforabusfaulttobecomeimpreciseisduetothepresenceofwritebuffersintheprocessor
bus interface. When the processor writes data to a bufferable address, the processor can proceed to
execute the next instruction even if the transfer takes a number of clock cycles to complete. When
an imprecise data access error takes place, the SCB->BFAR register is invalid. To derive the source of
faultweneedtodisassembletheCsourcecodeandtoidentifytheassemblyinstructionthatlogically
precedes the one pointed by the stacked PC.
24.1.2.3 Usage Fault Exception
This exception can be raised by a really wide range of factors. The most common ones, while
developing STM32 applications, are:
• Execution of an undefined instruction (including trying to execute floating point instructions
when the floating point unit is disabled). This often happens when we have an invalid function
pointer, that points to a valid memory location (often it happens when we have some functions
in SRAM), but the content of the pointed location does not correspond to an ARM assembly
instruction.
Advanced Debugging Techniques 700
• Invalid EXC_RETURN code during exception-return sequence. For example, trying to return to
Thread Mode with exceptions still active (apart from the current serving exception).
• Unaligned memory access with multiple load or multiple store instructions (including load
double and store double instructions).
• Execution of SVC instruction when the priority level of the SVC is the same or lower than
current level. This may happens when something nasty has occurred with the FreeRTOS
configuration of system exceptions (usually theSysTick IRQ does not have the lowest priority).
It is also possible, once the corresponding configuration is set, to generate usage faults for the
following conditions: * Divide by zero. * All unaligned memory accesses.
Table 5 shows the meaning of individual bits in the SCB->UFSR register.
Table 5: Usage Fault Status Register ( SCB->UFSR )
Bit Name Description
31-26 RESERVED RESERVED
25 DIVBYZERO Indicates divide by zero fault (can be set only if enabled)
24 UNALIGNED Indicates that an unaligned access fault has taken place
23-20 RESERVED RESERVED
19 NOCP Attempt to execute a floating point instruction when the Cortex-M4F floating point
unit is not available or when the floating point unit has not been enabled.
18 INVPC Attempts to do an exception with a bad value in the EXC_RETURN number
17 INVSTATE Attempts to switch to an invalid state (e.g., from ARM to Thumb)
16 UNDEFINSTR Attempts to execute an undefined instruction
By default, Cortex-M based MCUs return the value 0 when dividing a number by zero. If, instead,
youneedtocatchadividebyzeroerror,thenyoucanenablethisfaultconditionbysetting DIV_0_TRP
bit in the SCB->CCR register:
SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
The same applies to unaligned memory accesses:
SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
24.1.2.4 Hard Fault Exception
This exception is usually raised by an escalation of the previous configurable exceptions, if not
enabled. In addition, the HardFault can be triggered by:
• Bus error received during a vector table fetch. This happens because the vector table is invalid
(the most of the times we forgot to include the assembly file provided by ST or we forgot to
modify its extension from lower .s to capital .S ).
Advanced Debugging Techniques 701
• Execution of breakpoint instruction ( asm("BKPT #0"); ) with a debugger attached.
Table 6 shows the meaning of individual bits in the SCB->HFSR register.
Table 6: Hard Fault Status Register ( SCB->HFSR )
Bit Name Description
31 DEBUGEVT Indicates that the Hard Fault is triggered by a debug event
30 FORCED Indicates that Hard Fault is generated by an escalation of configurable fault
exceptions while they are disabled. In this case we need to inspect the content of
SCB->MFSR , SCB->BFSR and SCB->UFSR register to derive the fault cause.
29-2 RESERVED RESERVED
1 VECTBL Indicates that the Hard Fault is caused by failed vector table fetch
0 RESERVED RESERVED
24.1.2.5 Enabling Optional Fault Handlers
MemoryFault,BusFault andUsageFault aredisabledbydefault.Neitherthe HAL_NVIC_EnableIRQ()
nor the NVIC_EnableIRQ() can turn ON those exceptions, which are enabled by setting bits 16, 17
and 18 of the SCB->SHCSR register. To enable the Memory Fault exception we use the following
instruction:
SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk; //Set bit 16
To enable the Bus Fault exception we use the following instruction:
SCB->SHCSR |= SCB_SHCSR_BUSFAULTENA_Msk; //Set bit 17
To enable the Usage Fault exception we use the following instruction:
SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk; //Set bit 18
Once one of those exception is enabled, we can configure its priority using the HAL_NVIC_SetPrior-
ity() , like any other configurable exception.
24.1.2.6 Fault Analysis in Cortex-M0/0+ Based Processors
Cortex-M0/0+ cores do not provide Memory Fault, Bus Fault and Usage Fault exception. Moreover,
the corresponding status registers are not available. This means that we do not have the same
diagnostic features offered by Cortex-M3/4/7 cores.
The analysis of the stacked registers is the sole relevant technique we can use to diagnose fault
reasons. This answer⁸ by Joseph Yiu on the official ARM forum provides additional useful details.
Other techniques, such as filling the SRAM with a sentinel value to detect a stack overflow, may
help you finding the source of fault in your code.
⁸ http://bit.ly/2deDjUB
Advanced Debugging Techniques 702
24.2 Eclipse Advanced Debugging Features
In Chapter 5 we have started analyzing the debugging functionalities offered by Eclipse CDT and
GNU MCU Eclipse plug-ins. We have familiarized with the most basic features like breakpoints
insertion and step-by-step debugging. Now it is the right time to see the other debugging function-
alities integrated in the GNU MCU Eclipse tool-chain.
All the features shown here are available through the Debugging perspective.
24.2.1 Expressions
TheExpressions viewisapowerfulfeaturethatallowstoaccesstothecontentofmemoryaddresses,
variables and other data structures during debugging. Moreover, it is also able to perform function
calls, so that you can evaluate the result of a given routine. The Expressions view must be explicitly
enabled going to Window->Show View->Expressions.
Figure 7: The Expressions view in the debug perspective
The Figure 7 shows several expression examples. msg is a character array containing the “Hello
World!” string. pMsg is a char pointer to the msg string. As you can see from Figure 7, by simply
writing down the variable name in the expression view we can access to its content wherever it is
defined in the code. We can also show a C pointer as an array, using the expression (variable@len) ,
where variable is the pointer name and len is the amount of data stored in the array.
In Figure 7 also shows that it is possible to call a function (the strlen() in our case) and to obtain
its result⁹. An expression can also contain arithmetic operations. Finally, the Expression view is also
able to access to the content of individual memory locations, and to cast their content to a given
datatype (by right-clicking on the expression row you can cast a variable to a different datatype).
Expressions view in recent Eclipse CDT releases accepts enhanced expressions. An enhanced
expression is a way of easily writing an expression pattern that will automatically expand to a
larger subset of children expressions. Four types of enhanced expressions can be used:
⁹ Clearly, that function must be included in the binary image, that is it must be a function used in the firmware code.
Advanced Debugging Techniques 703
• Pattern-matched local variables
• Pattern-matched registers
• Pattern-matched array elements
• Expression groups
For example, the pattern “=*” allows to show all local variable in the current stack frame, while the
pattern “=$*” shows core registers. For more information about enhanced expressions refer to the
Eclipse CDT documentation¹⁰.
24.2.1.1 Memory Monitors
Eclipse CDT allows to access to the content of the whole 4GB address space. You can access to the
content of a memory location by using Memory Monitors view. To show the view, go to Window-
>Show View->Memory.
Figure 8: The Memory Monitors view
Once the view is shown, you can add a new memory location to the monitor view by clicking on
the green cross shown in Figure 8. The next step consists in selecting a “renderer”, that is a way to
show the content of the memory location. You can choose between:
• Floating Point
• Traditional
• Hexadecimal
• ASCII
• Signed and unsigned integer
You can also add more renderers for the same memory location. An interesting feature of the
“Traditional” renderer is that the content of core registers is also shown simultaneously, as shown
in Figure 9. Finally, you can configure several options of the memory view (cell size, endianness,
memory format, etc.) by right-clicking on a memory cell.
¹⁰ http://bit.ly/2cRC6ra
Advanced Debugging Techniques 704
Figure 9: A memory location shown using Hexadecimal and Traditional renderers
24.2.2 Watchpoints
EveryCortex-Mbasedprocessorprovidesagivennumberofbreakpointsandwatchpoints(seeTable
7). While breakpoints are used to break execution at a given instruction, watchpoints are used to
break execution when a data location is accessed. Any data or peripheral address can be marked as
a watched variable, and an access to this address causes a debug event to be generated, which halts
program execution. Watchpoint can also be used to halt execution only when a given expression
matches.
Table 7: Available breakpoints/watchpoints in Cortex-M cores
Cortex-M Breakpoints Watchpoints
M0/0+ 4 2
M3/4/7 6 4
There are several ways to add a watchpoint in the Eclipse CDT tool-chain. For example, you can
right-click on a variable in the Variables view and the select the entry Add Watchpoint(C/C++).
The same can be performed from the Expressions view and the Memory monitors view while right-
clicking on a memory location.
Advanced Debugging Techniques 705
Figure 10: The watchpoint configuration view
Once clicked on the Add Watchpoint(C/C++) entry the watchpoint configuration view appears, as
shown in Figure 10. Here we can setup the amount of memory to watch starting from the first word
(Range field). Moreover, we can specify if we want to halt execution when that memory location is
accessed in Read or Write mode. The Enable field allows to enable/disable the watchpoint. Finally,
theConditionfieldallowstospecifyacondition.WatchpointsarelistedinsidetheBreakpointsview.
24.2.3 Instruction Stepping Mode
The Instruction Stepping Mode is a debugging mode that allows to perform step-by-step debugging
of ARM assembly instructions “underlying” a given C instruction.
Figure 11: The Instruction Stepping Mode icon on the Eclipse toolbar
Instruction Stepping Mode is enabled by clicking on the related icon on the Eclipse main toolbar, as
shown in Figure 11. Once enabled, the Disassembly appears, as shown in Figure 12. Eclipse will
automatically show ARM assembly instructions corresponding to the current C instruction.
Read Carefully
The Instruction Stepping Mode dramatically slows down the debugging process, because the
CPU halts at every assembly instruction. If you cannot understand why the debugging is so
slow, then you probably forgot the Disassembly view active.
Advanced Debugging Techniques 706
Figure 12: The disassembly view
24.2.4 Keil Packs and Peripheral Registers View
During a debug session we may need to access to peripheral registers to better understand what’s
going wrong with a given peripheral. Accessing a peripheral register with a memory monitor
requires a lot of effort from us to understand the meaning of individual bits. This is largely
impractical during a debug session.
The GNU MCU Eclipse tool-chains offers a way to visualize peripheral registers content. This
ability is connected with a large distribution project made by ARM: Keil Packs. Packs are a modular
technology,similartothepackagesdistributionintheLinuxworld,intendedtosimplifydistribution
of software and documentation. The main difference from usual libraries or source archives is that
the actual source/object files are accompanied by some form of metadata, defining the dependencies
between files, the use of constraints and conditions, plus lists of devices the software runs on, with
full descriptions of their memory map, registers and peripherals, etc.
Figure 13: The “Packs” icon on the perspective switcher toolbar
Tovisualizeperipheralregistersinaconvenientwaywesoneedtodownloadthepack corresponding
to the STM32 family for our MCU. To perform this operation, we first need to switch to the
Packs perspective, by clicking on the corresponding icon on the perspective toolbar (see Figure
13). The Packs perspective should appear empty on a fresh-new Eclipse installation. You so need to
synchronize Eclipse with the current Keil Packs repository by clicking on the icon highlighted in
Figure 14.
Advanced Debugging Techniques 707
Figure 14: How synchronize Eclipse with the Keil Packs repository
Once the synchronization is complete, you can select the STM32 family of your MCU from the tree
view on the left, as shown in Figure 15. A list of packs appears. Select the latest available package
and click on the install button (circled in red in Figure 15).
Figure 15: How to install a new pack
Once a package is installed, you can get the full outline of the pack version by selecting the desired
version. This will trigger an update of the outline window, with the brief outline being replaced by
a full outline.
BeforewecanvisualizetheperipheralregistersweneedtospecifyourparticularSTM32MCUinthe
Advanced Debugging Techniques 708
project settings. Go to Project->Properties and then to C/C++ Build->Settings. Select the Device
tab and choose the entry that matches your STM32 MCU, as shown in Figure 16. Once selected,
click on the Apply button (WARNING: do not skip this step! You need to click on the “Apply”
button and then on the “OK” one, otherwise the configuration is not applied).
Figure 16: How to configure the project so that the MCU register are correctly shown
Now start a new debug session (o restart if you were already performing a debug session) and go
into Peripheral view (if it is not available, go to Windows->Show View->Peripherals) and check
the peripherals you are interested in. This will cause that the peripheral registers will appear inside
a Memory monitor view, as shown in Figure 17.
Advanced Debugging Techniques 709
Figure 17: How to access to peripheral registers during a debug session
24.2.5 Core Registers View
The Register view, shown in Figure 18, allows to access to Cortex-M core registers, plus the FPU
registers in Cortex-M4F/7 cores if the FPU is enabled. The registers’ content can be eventually
modified by double-clicking on the register value.
Figure 18: The Registers view in the debug perspective
Advanced Debugging Techniques 710
24.3 Debugging Aids From the CubeHAL
The CubeHAL implements run-time failure detection by checking the input values of all HAL API.
The run-time checking is achieved by using an assert_param() macro. This macro is used in all
CubeHAL functions having an input parameter. It allows verifying that the input value lies within
the parameter allowed values.
To enable run-time checking you need to define the USE_FULL_ASSERT macro at project level (both
in the project settings or by uncommenting the macro definition in the stm32XXxx_hal_conf.h file).
CubeMX generates a function named assert_failed() in the main.c file. The function is defined in
the following way:
void assert_failed(uint8_t* file, uint32_t line);
The function is automatically invoked by the assert_param() macro if an assertion is not satisfied.
The macro will automatically pass to the function the filename and the exact lines of code where
the assert condition is not satisfied.
The implementation of the assert_failed() function is left to the user. A simple implementation
consists in placing a software breakpoint by invoking the bkpt ARM instruction:
void assert_failed(uint8_t* file, uint32_t line) {
asm("BKPT #0");
}
Enabling the USE_FULL_ASSERT macro during the development stage can provide a huge help to
understand what’s going wrong with the CubeHAL, especially if you are new to the CubeHAL.
24.4 External Debuggers
Serious projects demand serious tools. And this is dramatically true in electronics design. If you
reached this part of the book without skipping any fundamental chapter, then you already know the
limits of the ST-LINK debugging interface.
Unfortunately, ST-LINK tends to be slower then dedicated and external debuggers. It lacks of some
relevant features and it is affected by serious bugs that often make the debugging experience a
nightmare.Moreover,theOpenOCDsupporttotheST-LINKinterfaceisstillincomplete,andseveral
STM32 devices (especially those belonging to the STM32L-series) are not supported at all. Finally,
the OpenOCD development flows too slowly: the last stable OpenOCD release (0.9) is date back to
May 2015, and at the time of writing this chapter (November 2016) the next stable release (0.10) is
still under development.
Advanced Debugging Techniques 711
Figure 19: A SEGGER J-Link Ultra+ debug probe
SEGGER is a German company specialized in designing external debug probes for the ARM Cortex
portfolio(includingCortex-M/R/AmicroprocessorsandothermodernMCUslikePIC32andRenesas
RX series). SEGGER J-Links (see Figure 19) are the most widely used line of debug probes available
today, and they are often sold as OEM version for other vendors (IAR and Keil debug probes are
nothing more than a J-Link).
The most relevant features offered by J-Link debuggers are:
• Up to 3 MByte/s download speed.
• Compatible with all popular tool-chains including the GNU MCU Eclipse.
• Supports an unlimited number of software breakpoints in flash memory.
• Allows setting breakpoints in external flash memory of Cortex-M systems through FMC
controller.
• Cross platform support (Microsoft Windows, Linux, Mac OS X).
• Supports concurrent access to CPU by multiple applications.
• Support for multi core debugging.
• Remote Server included. Allows using J-Link remotely via TCP/IP.
• Software comes with free GDB server, allowing usage of J-Link with all GDB-based debug
solutions.
• Production flash programming software (J-Flash) available.
• Debugger independent flash download (internal flash, CFI flash, SPIFI flash).
• Supports CPU/MCU internal trace buffer (ETB, MTB, etc.).
Advanced Debugging Techniques 712
• Supports ETM tracing (J-Trace Cortex-M, J-Trace ARM).
• Wide target voltage range: 1.2V - 3.3V, 5V tolerant.
• Supports multiple target interfaces (JTAG, SWD, FINE, SPD, etc.).
J-LinkprobesrangesfromtheEDUedition,whichcostsabout60$,uptotheJ-TracePROeditionthat
costs about $1300. If you are a student or a low-budget hobbyist, the EDU edition worth spending
sinceitsupportsallrelevantfeaturesprovidedbyprofessionalJ-Linkprobes.Ifyouareaprofessional,
then the Ultra+ is a good deal according to this author.
However, for owners of STM development boards (Nucleo, Discovery, Eval) there is a good and
totally free alternative: in April 2016 SEGGER has released a firmware upgrade for the ST-LINK
interface that transforms it in a J-Link compatible debug probe. By downloading¹¹ a dedicated
software tool¹², your ST-LINK is transformed in a J-Link OB compatible interface, and you can
use the most important software tools by SEGGER¹³. Moreover, you can easily revert the interface
to an ST-LINK if you want.
When debugging with SEGGER debug probe, there is no need to use OpenOCD, because SEGGER
provides its own compatible GDB server, named JLinkGDBServer . This is one of the fundamental
reasons to choose these tools, because the JLinkGDBServer is a much more fast and reliable
alternative to OpenOCD being cross-platform at the same time.
The instructions to upgrade the ST-LINK interface to a J-Link compatible one are clearly reported
on the SEGGER website. We will not repeat them here. Instead, we are now going to analyze how
to use a J-Link debug probe with the GNU MCU Eclipse tool-chain.
24.4.1 Using SEGGER J-Link for ST-LINK Debugger
You need to install SEGGER software tools to start using SEGGER debug probes. You can download
them from the official SEGGER website¹⁴. The most relevant package is the J-Link Software and
Documentation Pack. You will find installers for the three major OSes: Windows, Mac OS and
Linux. Once the installation is completed, you need to configure your Eclipse workspace to make it
aware of the filesystem path where the JLinkGDBServer.exe (or simple JLinkGDBServer in Mac OS
and Linux) is stored.
¹¹ https://www.segger.com/jlink-st-link.html
¹² Unfortunately, at the time of writing this chapter, the upgrade tool is only available for the Windows OS.
¹³ Please, take note that the license of this “free” upgrade to the ST-LINK interface prevents you from using it to debug custom and
commercial devices. Take a look at the SEGGER website for the complete list of limitations.
¹⁴ https://www.segger.com/downloads/jlink
Advanced Debugging Techniques 713
Figure 20: How to configure the path of the JLinkGDBServer.exe tool
In the Eclipse menu, go into Eclipse general preferences and then into >Run/Debug->SEGGER J-
Link section (see Figure 20). Click the Restore Defaults button. Eclipse will suggest you the default
valuescomputedwhenitstarted:ifanewversionofSEGGERwasinstalledwhileEclipsewasactive,
restart Eclipse and click again the Restore Defaults button. Check the Executable field: it must
define the name of the command line J-Link GDB server executable. In most cases it should be set
correctly; if not, edit it to match the correct name. Check the Folder field: it must point to the actual
folder where the J-Link tools were installed on your platform. Click the OK button.
Windows Warning
Please take note that on Windows there are two GDB server executables, one with a UI and
one to be used as a command line ( JLinkGDBServerCL.exe ). You obviously need to configure
the executable field to point to JLinkGDBServerCL.exe .
TheGNUMCUEclipsetool-chainsupportscreationofDebugConfigurationsfortheJ-Linkdebugger
natively.Tocreateanewconfigurationforthecurrentproject,gotoRun->DebugConfigurations…
menu. Highlight the GDB SEGGER J-Link Debugging entry in the list view on the left and click
on the New icon.
Advanced Debugging Techniques 714
Figure 21: The Debugger section in a J-Link Debug configuration
Main, Source and Common tabs are identical to ones found in the GDB OpenOCD Debugging
configurationandwewillnotdescribethemhere(refertoChapter5).TheDebuggersection,shown
in Figure 21, contains configuration parameters regarding the debug interface and the specific
STM32 MCU to debug. Let us review the most relevant fields in that section.
• Executable: it is a pattern that will be replaced with the full path to the JLinkGDBServer
executable. It is strongly suggested to leave it as is.
• Device name: it corresponds to the device name of the target MCU. This value cannot be
arbitrary, and it must correspond to the exact device type. For example, for a Nucleo-F401RE
youhavetowritedownSTM32F401RE.IfyouhavealreadyinstalledKeilPacksforyourSTM32
MCU, and you have correctly associated the right device ID in the project settings, then this
field will be filled automatically.
• Endianness: corresponds to the order of bytes in memory, and it must be set toLittle for every
Cortex-M based processor.
• Connection: for USB J-Link probe, select USB. If you have a J-Link with Ethernet port, then
write down the IP address corresponding to the J-Link probe.
• Interface: STM32 MCU can be debugged through a classical JTAG interface or the SWD one.
If you are using an ST development board with the integrated ST-LINK interface, then select
the SWD entry.
Advanced Debugging Techniques 715
The rest of configuration parameters in the Debugger section can be left as is.
Figure 22: The Debugger section in a J-Link Debug configuration
Differences Between JTAG and SWD Interfaces
Novice users tend to be confused by these two debugging standards, which are both
supported by STM32 microcontrollers. The Joint Test Action Group (JTAG) is a standard
that defines both signaling characteristics and data protocol specification. It is based on five
signals, plus two additional wires used to detect target VDD voltage and GND. JTAG allows
to connect external debug probes to microcontrollers. It is a really widely adopted standard
in the electronics industry.
The Serial Wire Debug (SWD) is an alternative ARM proprietary 2-pin electrical interface
thatusesthesameJTAGprotocol.SWDenablesthedebuggertobecomeanotherAMBAbus
master for access to system memory and peripherals or debug registers. Data rate is up to 4
Mbytes/sec at 50 MHz. SWD also has built-in error detection. On JTAG devices with SWD
capability, the TMS and TCK are used as SWDIO and SWCLK signals, providing for dual-mode
programmers. An additional and optional signal, named Serial Wire Output (SWO), is used
to exchange data and messages with the host application with a little impact on the MCU
performances. We will analyze this functionality next.
Advanced Debugging Techniques 716
The Startup section contains additional configuration parameters. Let us review the most important
ones.
• Enable flash breakpoints: one relevant characteristic of J-Link debuggers is the ability to
set unlimited flash breakpoints, bypassing the Cortex-M limitation that allows a maximum
of 6 breakpoints for Cortex-M3/4/7 MCUs. This option allows to enable this feature which is
supported transparently by the Eclipse IDE.
• Enable semihosting: as the name suggests, this checkbox enables the support to the ARM
semihosting.
• Enable SWO: this enables the support to the SWO functionality. We will analyze it better in
the next paragraph.
The rest of configuration parameters in the Startup section can be left as is.
24.4.2 Using the ITM Interface and SWV Tracing
Cortex-M based microcontrollers integrate several debugging and tracing technologies in the same
die. As said before, JTAG and SWD are two complimentary specifications that allow to connect an
externaldebuggertothetargetMCU.Thesameinterfacesareusedtoimplementtracingcapabilities.
Tracing allows to export in real-time internal activities performed by the CPU. It is a sort of live-
hardware debugging, and it is carried out using the 5 signals of the JTAG port. Tracing is carried
out due to the presence of a technology named Embedded Trace Macrocell (ETM), but it requires
faster and more adavanced debuggers. ETM tracing is a sort of “sniffing” technology, and it does
not impact on the MCU performances. SEGGER produces a separated line of debug probes named
J-Trace, which offer live-tracing of the MCU through the ETM interface.
The Instrumentation Trace Macrocell (ITM) is a less demanding tracing technology that allows
sending software-generated debug messages through the SWD, using a specific signal I/O named
Serial Wire Output (SWO). The protocol used by the SWO pin to exchange data with the debugger
probe is called Serial Wire Viewer (SWV). The SWV support is not available in Cortex-M0/0+ based
microcontrollers.
Compared to other “debugging-alike” peripherals like UART or to other technologies like the ARM
semihosting, SWV is really fast. Its communication speed is proportional to the MCU speed, and
this allows to limit the impact of the exchanged data on firmware performances. Clearly, the more
fast runs the SWO I/O, the faster needs to be the debugger. That is the reason why SEGGER sells
several version of its J-Link probe. The expensive ones are based on a FPGA, which allows to sample
SWD I/Os at a speed up to 100MHz. The integrated ST-LINK interface, with the dedicated J-Link
firmware, can sample SWO signal up to 4500kHz. The J-Link Ultra+ is able to sample up to 100MHz.
The CMSIS-Core package for Cortex-M3/4/7 cores provides necessary glue to handle SWV protocol.
For example, the ITM_SendChar() routines allows to send a character using the SWO pin. The GNU
MCU Eclipse tool-chain automatically integrates the necessary logic: if we set the macro OS_USE_-
TRACE_ITM at project level, we can use the trace_printf() to print messages on the SWO port.
Advanced Debugging Techniques 717
To properly decode the bytes sent over the SWO port, the host debugger needs to know the
frequencies of CPU and SWO port. This last one is proportional to the core frequency. J-Link
debuggers have a method to derive these speeds automatically. If we set both the fields CPU
frequ and SWO freq to zero in the J-Link debug configuration (see Figure 22), then the debugger
will automatically derive such speeds when the debugging session begins. However, if we our
code changes the clock speed during the MCU initialization by calling the SystemClock_Config()
function, then the computed frequency will no longer match. To address this, you can specify the
running CPU frequency in the CPU frequ field and the SWO frequency in the SWO freq field. If in
doubt about which maximum SWO frequency to specify, you can use the JLinkSWOViewer which is
able to derive the right configuration values.
SWV protocol defines 32 different stimulus ports: a port is a “tag” on the SWV message used to
enable/disable messages selectively. In the GNU MCU Eclipse tool-chain it is possible to define
the stimulus port by defining the macro OS_INTEGER_TRACE_ITM_STIMULUS_PORT at project level.
The default stimulus port is 0. If you change the stimulus port, then you need to modify the Port
mask parameter in the J-Ling configuration settings. Please, take note that Port mask parameter
corresponds to the SWV stimulus port plus one (that is, if you choose the stimulus port 0 in your
code, then Port mask must be equal to 0x1, and so on).
The SWV support should be available even in OpenOCD, but at the time of writing this
chapteritisstillnoncompletelymatureandseveralissuesseemstoexists(themainproblem
is that OpenOCD does not include support to parse the SWO stream).
24.5 STM Studio
STM Studio¹⁵ is a run-time variables monitoring and visualization tool for STM32 microcontrollers.
It is developed and officially supported by ST, which distributes it freely. It is designed to work with
STM debuggers (ST-LINK, STIce, etc.). This tool supports both JTAG and SWD debugging protocols,
and it is a non-intrusive tool that allows to keep track of variable values while firmware runs. The
acquired values are then plotted on a graph and this is a powerful tool that allows to understand
what’s happening with our code without affecting its execution. It is a fundamental tool in several
time-critical applications, like motor-control and so on. Unfortunately, even if developed with Java,
at the time of writing this chapter STM Studio supports exclusively Windows OSes, from Windows
XP up to the latest Windows 10.
¹⁵ http://www.st.com/en/development-tools/stm-studio-stm32.html
Advanced Debugging Techniques 718
Figure 23: How to import variables inside STM Studio
It is really straightforward to use STM Studio. Once our code is compiled¹⁶ and uploaded on the
targetMCU,wecanlaunchSTMStudioandimporttheELFbinaryimagebygoingintoFile->Import
variables (or by clicking Shift + I). The complete list of all global variables¹⁷ is presented, as shown
in Figure 23. Select the variables you are interested in, and click on the Import button.
Importedvariables areshowninsidetheDisplayvariablestab.Youcanimporton thecurrentgraph
the ones you need to inspect by simply dragging them on the graph. You can have multiple graphs
in the same session, so that you can analyze variables separately, as shown in Figure 24.
¹⁶ It is important that the binary image is compiled with all debug symbols included.
¹⁷ Clearly, it is not possible to inspect local variables, because they are allocated on the current stack frame. If you need to keep track of
local variables, you can convert them to global ones.
Advanced Debugging Techniques 719
Figure 24: How variables are plotted inside STM Studio
Read Carefully
Often the current plot is outside the correct axis range and you will not see the variable
values. You can simply force STM Studio to rearrange the axis automatically by right-
clicking on the graph and then selecting Auto Range->Both menu.
STM Studio provides a lot of customizations. For more information refer to the official manual¹⁸.
24.6 Debugging two Nucleo Boards Simultaneously
We may need to debug two STM32 based devices simultaneously. This is not uncommon, especially
when dealing with communication protocols. OpenOCD allows us to debug two or more boards on
the same computer.
To launch two OpenOCD instances we need to derive a fundamental information: the Serial ID of
the ST-LINK interface, which corresponds to the CPU ID of the STM32F1 in the ST-LINK debugger.
Retrieve the ST-LINK Serial ID in Linux and MacOS
To retrieve the ST-LINK Serial ID we can use the ST-LINK Upgrade tool, available through the
ST website¹⁹ (you should already have downloaded it if you followed installation instructions in
Chapter2).Extractthe.zippackage(stsw-link007.zip)andgoinsidetheAllPlatformssub-directory.
¹⁸ http://bit.ly/2fB6iqW
¹⁹ http://bit.ly/1RLDp3H
Advanced Debugging Techniques 720
Start the upgrade tool by double-clicking on the STLinkUpgrade.jar file and take note of the Serial
ID that appears once you click on the Refresh device list button (see Figure 25).
Figure 25: How to derive the ST-LINK Serial ID in Linux and MacOS
Now we are ready to change the external tool configuration in Eclipse, by adding the following
parameters to the Arguments field (see Figure 26):
-f board/board.cfg -c "hla_serial 066FFF575056805087053651; ocd_gdb_port 3334; telnet_-
port 5554; tcl_port 6664"
where board.cfg is the configuration file that matches your board; ocd_gdb_port is the GDB port
(which, by default, is equal to 3333); telnet_port is the telnet port (which, by default, is equal to
5555); tcl_port is the JimTCL port (which, by default, is equal to 6666). Clearly, if you have two
OpenOCD instances running on the same PC, you need to specify different TCP ports. Moreover,
you need to change the Remote target port number into project debug configuration (see Figure
8 in Chapter 2), setting the same port number specified with the ocd_gdb_port parameter.
Advanced Debugging Techniques 721
Figure 26: How to fill the External Tools Configurations fields when using two ST-LINK simultaneously
25. FAT Filesystem
Electronic embedded devices are increasingly complex and nowadays it is really common to have
devicesthatneedtoreadandstorestructureddata.Forexample,consideranInternet-enableddevice,
which needs to serve HTTP requests and to transfer HTML files. Unless HTML pages are really
simple, this device will need a way to handle several and separated HTML files, as well as CSS
stylesheets and JavaScript files. For this reason, a lot of embedded developers need a way to handle
structured filesystems in their applications.
SThasintegratedinitsCubeHALawell-knownlibrarytomanipulateFATfilesystems(FAT12,FAT16
and FAT32): the FatFs library by Chan¹. This is a library expressly designed for embedded system,
with limited SRAM and flash memories. It is really popular and it is proven to be robust.
This chapter provides a quick introduction to this middleware library. It describes how to use
CubeMX to generate a project that integrates it and how to develop applications based on this
useful library. Moreover, we will see how to interface SD cards using SPI, which represents the
most widespread way to use memory cards with low-cost embedded microcontrollers.
25.1 Introduction to FatFs Library
The File Allocation Table (FAT) is a filesystem architecture designed by Microsoft in the early ‘80
and used as official filesystem for the MS-DOS and Windows Operating Systems until the Windows
NT 3.1 release. FAT filesystem was superseded by the more advanced NTFS, which offers improved
support for metadata, and the use of advanced data structures to improve performance, reliability,
and disk space utilization, plus additional extensions, such as security access control lists (that is,
file permissions) and file system journaling.
Thanks to its simplicity and robustness, the FAT file system is still commonly found on USB-based
memories, flash and other solid-state memory cards and modules like SD cards, and many portable
and embedded devices. Technically, the term “FAT file system” refers to all three major variants
of the file system: FAT12, FAT16 and FAT32. Those numbers essentially indicate how many bits
are used to address filesystem clusters, a contiguous area of disk storage. The more clusters the
filesystem can handle, the more bytes can be used. That’s the reason why FAT32 is nowadays the
most-used filesystem on large solid-state and removable memories. A disk as well as a solid state
memory initialized with the FAT filesystem can have an arbitrary number of partitions.
The FatFs is a really space-optimized² library which provides the following features:
¹ http://bit.ly/2d6QUC5
² For the sake of completeness, we have to say that the same author made an even smaller version of the FatFs library, named Petit
FatFs(http://bit.ly/2drLLAa), which is best suitable for 8-bit MCUs. It essentially implements a subset of the main FatFs library.
FAT Filesystem 723
• Supports FAT12, FAT16, FAT32(r0.0) and exFAT(r1.0) filesystems.
• Allows un unlimited number of open files (the only limit is the available SRAM memory).
• Supports up to 10 volumes each one with a size up to 2 TiB at 512 bytes/sector.
• Every file can grow up to 4 GiB on FAT volume and virtually unlimited on exFAT volume.
• The cluster goes up to 128 sectors on FAT volume and up to 16 MiB on exFAT volume.
• Supports 4 different sector sizes: 512, 1024, 2048 and 4096 bytes.
The FatFs library provides up to 37 APIs, and they can be selectively disabled thanks to several
configurationmacros.Infact,toreducetheflashmemoryfootprint,itispossibletodisableunneeded
functionalities. FatFs library is coded in pure ANSI C and it is totally abstracted from the underlying
hardware. The official library does not provide any support to specific memory technology devices,
and it is up to the user to implement the necessary glue to interface the hardware.
Figure 1: How the FatFs library interfaces the underlying hardware
ST engineers have integrated the FatFs library in the CubeHAL. They have developed necessary
adapters to use FatFs library with the following devices:
• SD memory cards using the SDIO peripheral: the Secure Digital Input Output (SDIO)
is an extension of the SD specification that covers I/O functions related to SD and MMC
cards. More advanced STM32 microcontrollers, such as some STM32F4 ones (for example, the
STM32F401RE) and STM32F7 microcontrollers, provide a this dedicated peripheral. The SDIO
FAT Filesystem 724
interface can be configured to work in 1 bit mode (that is, data is transferred to the SD using
just one output data port, maned DO, plus two additional I/Os for the clock and commands
transfer), or to work in 4 bit mode (that is data is transferred using 4 dedicated I/Os in addition
toclockandcommandlines).ThisisthefastestwaytouseSDcards,andthemaximumtransfer
rate of 50MHz can be reached in high-performing STM32 microcontrollers.
• Static as well as Dynamic RAM memories: two separated low-level drivers for SDRAM and
SRAM memories allow to create filesystems in RAM. These two drivers work in combination
with FMC and FSMC controllers. They allow to initialize RAM disks and this feature is
especially useful when performances are critical for your application (SRAM are a lot faster
than NVM memories).
• USB-based disks: a specific driver built upon the ST USB library allows to create USB host
devicessupportingtheMassStorageClass (MSC)(thatisadevicethatcaninterfaceUSBdisks).
Figure 1 shows the relation between the FatFs library and the CubeHAL. Unfortunately, ST
engineers have not still developed a driver for SD cards when working in SPI mode. In fact, SD
cards are designed to support, among the other protocols, commands exchanged through the SPI
bus. However, I have arranged a complete SPI-compliant SD driver that I will introduce you later.
To integrate the FatFs library with a memory device we essentially need to implement the following
six routines:
• disk_initialize() : this routine contains all the necessary code to initialize the hardware
device. For example, for an SD card working in SPI mode this routine must contain all the
necessary code to initialize the SPI interface and to place the SD in SPI mode (there exists a
specific procedure to follow, as documented on Chan’s website³).
• disk_status() : this function is used by the library to get information about the device status
(for example, if it is initialized, etc.).
• disk_read() :thisroutineisusedtoretrieveagivennumberofsectorsfromthememorydevice,
starting from a specified sector.
• disk_write() : as its name suggests, this function is used to store a given number of sector on
the device.
• disk_ioctl() : this function reads and configures some specific device parameters, such as the
size of sectors, the device power state, and so on.
• get_fattime() : returns the current time so that files can have a valid timestamp. If the MCU
does not provide an RTC unit, then this function can return 0.
Moreover, the last three routines are needed only if the FatFs library is compiled with the option
_FS_READONLY == 0 . That is, we can avoid to provide a valid implementation for those functions if
we use the FatFs read only mode.
³ http://bit.ly/2dtWpWS
FAT Filesystem 725
25.1.1 Using CubeMX to Include FatFs Library in Your Projects
As said before, FatFs library is a component of the CubeHAL framework, and CubeMX supports it.
However, the way CubeMX handles this library is a little bit counterintuitive, at least for beginners.
Figure 2: What CubeMX shows for those STM32 MCUs that does not provide a compatible adapter
Many of you will notice that CubeMX shows just one option related to the FatFs middleware
library, as shown in Figure 2. The obscure User-defined entry will appear for the majority of
STM32 microcontrollers. But what exactly that means? It simply means that your specific STM32
microcontroller provides no peripheral compatible with the adapters developed by ST developers
(SRAM/SDRAM, USB, and SDIO), and you will need to provide your own implementation for the
low-level I/O drivers.
Figure 3: What CubeMX shows for an STM32F746VG MCU
Figure 3, instead, shows the options available if you use an STM32F746VG MCU, which provides
the SDIO interface⁴, the FMC controller and an USB-device interface. However, as you can see in
Figure 3, the generation options appear grayed out. This happens because we need to enable the
corresponding peripheral first, and then check the wanted FatFs configuration. For example, let us
assume that we are working on an STM32F401RE MCU, which provides a SDIO peripheral. We first
need to enable the wanted SDIO mode (1-bit, 4-bit, etc) in the IP Tree view, and then check the
corresponding FatFs option.
ThegeneratedprojecthasastructuresimilartotheoneshowninFigure4.TheMiddlewares/Third_-
Party/FatFs/src folder contains the FatFs library, while the Middlewares/Third_Party/FatFs/src/-
drivers folder contains I/O routines to handle SD cards through the specific interface (the SDIO).
Those routines are abstracted from the specific board configurations, and they rely on APIs that
are implemented inside the src/bsp_driver_sd.c file. The routines contained in that file use in turn
CubeHAL functions (from the HAL_SD module for the SDIO).
⁴ In STM32F7 MCUs the SDIO peripheral is called SDMMC.
FAT Filesystem 726
Figure 4: The structure of a generated project with the FatFs middleware
If, instead, you generate a project choosing the User-defined option, then you will find the file
src/user_diskio.c, which contains the functions USER_initialize() , USER_status() , USER_read() ,
USER_write() and USER_ioctl() . Those routines are empty templates, and they need to be filled
with the code to drive your specific memory device.
Finally, consider that the CubeMXImporter tool knows how to automatically import projects
generated with the FatFs Middleware.
25.1.1.1 The Generic Disk Interface API
ST Engineers have developed another abstraction layer between the FatFs library and the low-level
devicedrivers.ThisiscalledGenericDiskInterfacelayeranditisessentiallyanabstractionlayerthat
allows to handle multiple disk-drivers in the same application. It resembles the Virtual Filesystem
in the Linux Operating System.
Each device driver in this layer corresponds to an instance of the following C struct :
FAT Filesystem 727
typedef struct {
DSTATUS (*disk_initialize) (BYTE);
DSTATUS (*disk_status) (BYTE);
DRESULT (*disk_read) (BYTE, BYTE*, DWORD, UINT);
#if _USE_WRITE == 1
DRESULT (*disk_write) (BYTE, const BYTE*, DWORD, UINT);
#endif /* _USE_WRITE == 1 */
#if _USE_IOCTL == 1
DRESULT (*disk_ioctl) (BYTE, BYTE, void*);
#endif /* _USE_IOCTL == 1 */
} Diskio_drvTypeDef;
This is nothing more then a C struct containing five function pointers, which correspond to the
implementation of those routines needed by the FatFs to handle the access to the specific memory
device. The function:
uint8_t FATFS_LinkDriver(Diskio_drvTypeDef *drv, char *path);
is responsible of linking an instance of that struct to a given mount path (e.g. the path “0:/” to
address the volume 0).
Thank to this little improvement by ST guys, we can use different filesystems using different devices
(for example a USB-disk filesystem in conjunction with another filesystem stored in the SD card).
25.1.1.2 The Implementation of a Driver to Access SD Cards in SPI Mode
SD memory cards are more than simple flash memories. They also include a dedicated processor,
which implements all the logic to exchange data through the SD interface (answering to several
communication protocols) and to handle the proper access to the specific flash memory (NOR,
NAND, etc.). Moreover, all SD cards implement wear-leveling techniques for prolonging the service
life of erasable flash memories.
One distinctive feature of SD cards is the ability to answer to commands and messages exchanged
over an SPI bus⁵. This allows them to be used in conjunction with low cost microcontrollers (even 8-
bitsonesaresuitableforthisoperation),andthisexplainstheirpopularityinembeddedapplications.
IwillnotdescribeheretheSPIprotocolsupportedbySDcards.Chanprovides⁶sufficientinformation
to get started with this matter. Repeat it here is useless and counter-productive. Chan also provides
several example projects that show how to interface SD card through the SPI interface.
The next chapter will show how to use SD cards in SPI mode to serve web pages stored on the SD
cards in a web-based embedded application.
⁵ However, the implementation of this functionality is not mandatory for SD manufacturers. There exist several SD cards on the market
that not implement the SPI specification or, at least, they do not implement it literally.
⁶ http://bit.ly/2dtWpWS
FAT Filesystem 728
25.1.2 Relevant FatFs Structures and Functions
We are now going to analyze the most important structures and functions provided by the FatFs
library to manipulate FAT drives⁷.
25.1.2.1 Mounting a Filesystem
Before accessing any file or directory on the filesystem we need to mount⁸ it using the function:
FRESULT f_mount(FATFS *fs, const TCHAR *path, BYTE opt);
fs is an instance of the C struct FATFS , which holds information about the logical drive (partition);
path is a pointer to the null-terminated string that specifies the logical drive (more about this in
a while); opt can assume the value 0 to delay the filesystem mounting until to the first access to
the volume (for example, opening a file or a directory) or it can assume the value 1 to immediately
mount the logical volume. Application program must not modify any member the FATFS structure,
otherwise the original logical/physical disk could me irremediably damaged.
The format of path parameter is similar to the drive name specification in Windows Operating
System,atitcanassumetheform N:/ ,whereNisanumberstartingfrom0whichuniquelyidentifies
alogicaldrive.Bydefaulteachphysicaldrivecanhavejustonelogicaldrive(thatis,apartition).This
means that if our disk hasmorethan one partition, then onlythe first partition in thepartitions table
will be mounted and assigned to a logical drive. Instead, by setting the macro _MULTI_PARTITION=1
in the ffconf.h file, FatFs library will associate a logical drive to every partition in a physical disk.
When drive number is omitted, the drive number is assumed as default drive (drive 0 or current
drive). We can so pass to the path parameter slash or backslash chars ( \ or / ) or even specify a NULL
string. For example, the following code forces the mounting of the first partition on a physical drive:
FATFS fs;
f_mount(&fs, "/", 1);
If the logical disk is correctly mounted, then the f_mount() function returns the value FR_OK . Other-
wise a series of error conditions may be returned ( FR_INVALID_DRIVE , FR_DISK_ERR , FR_NOT_READY ,
FR_NO_FILESYSTEM ).
25.1.2.2 Opening a File
Once the drive is mounted, we can open a file by using the function:
⁷ The full FatFS API is documented on the Chan’s website
⁸ The mounting of a disk is an operation performed by the filesystem driver that essentially consists in gathering all the logical information
associated to a physical drive or a part of it (number of partitions, partition dimension, dimension of clusters, number of clusters and so on).
It is impossible to use any filesystem primitive (directories, files, etc) before mounting it.
FAT Filesystem 729
FRESULT f_open(FIL* fp, const TCHAR* path, BYTE mode);
fp is an instance of the C struct FIL , which holds information about the open file (its name, size,
starting cluster, and so on); path corresponds to the filesystem path to reach the file (more about
this soon); mode specifies the type of access and open method for the file, and it can assume a value
from Table 1.
Table 1: Lists of file open methods
Value Description
FA_READ Specifies read access to the object. Data can be read from the file.
FA_WRITE Specifies write access to the object. Data can be written to the file. It can be combined
(logically or-ed) with FA_READ for read-write access.
FA_OPEN_EXISTING Opens the file. The function fails if the file is not existing. (Default)
FA_CREATE_NEW Creates a new file. The function f_open() fails with FR_EXIST if the file is existing.
FA_CREATE_ALWAYS Creates a new file. If the file is existing, it will be truncated and overwritten.
FA_OPEN_ALWAYS Opens the file if it is existing. If not, a new file will be created.
FA_OPEN_APPEND Same as FA_OPEN_ALWAYS except read/write pointer is set end of the file.
Regarding the file path, this corresponds to the full filesystem path to the file, including its name.
For example, 0:\dir1\filename.txt opens the file named filename.txt inside the directory named
dir1 onthefirstlogicaldisk.Ifourapplicationusesjustonelogicaldrive,thenwecansimplyspecify
the path in this other form: \dir1\filename.txt . Please, take note that FatFs is able to process paths
both in Windows and UNIX form. So, following the previous example, we can also specify the path
in this equivalent form: 0:/dir1/filename.txt .
If the file is correctly opened, then the f_open() function returns the value FR_OK . Otherwise a series
of error conditions may be returned (see documentation⁹ for more about this).
25.1.2.3 Reading From/Writing Into a File
Oncethefileisopened,wecanreaddatafromitorwritenewdatafromitaccordingthefileopening
mode . To do this, the FatFs library provides the following functions:
FRESULT f_read(FIL* fp, void* buff, UINT btr, UINT* br);
FRESULT f_write(FIL* fp, const void* buff, UINT btr, UINT* br);
fp corresponds to the file handler passed to the f_open() function; buff is the pointer to the buffer
containing the data to read from the file or to store in it; btw specifies the number of bytes to
read/write; bw corresponds to the amount of bytes effectively read/written.
The following example shows an application of the functions seen before. It is nothing more then a
file copy procedure.
⁹ http://bit.ly/2dICX94
FAT Filesystem 730
1 #define BUF_LEN 2048
2
3 FRESULT copy_file (char *srcPath, char *dstPath) {
4 FATFS fs; /* File system object corresponding to logical drive */
5 FIL fsrc, fdst; /* File objects */
6 BYTE buffer[BUF_LEN]; /* File copy buffer */
7 FRESULT fr; /* FatFs function common result code */
8 UINT br, bw; /* File read/write count */
9
10 /* Mount the filesystem */
11 f_mount(&fs[0], "0:", 0);
12
13 /* Open source file */
14 fr = f_open(&fsrc, srcPath, FA_READ);
15 if (fr) return (int)fr;
16
17 /* Create destination file */
18 fr = f_open(&fdst, dstPath, FA_WRITE | FA_CREATE_ALWAYS);
19 if (fr) return (int)fr;
20
21 /* Copy source to destination */
22 while(1) {
23 /* Read 'BUF_LEN' bytes from source file */
24 fr = f_read(&fsrc, buffer, BUF_LEN, &br);
25 if (fr != FR_OK || br == 0) break; /* Error condition or EOF */
26 /* Write read data to the destination file */
27 fr = f_write(&fdst, buffer, br, &bw);
28 if (fr != FR_OK || bw < br) break; /* Error or disk full */
29 }
30
31 /* Close open files */
32 f_close(&fsrc);
33 f_close(&fdst);
34
35 /* Unmount volume */
36 f_mount(NULL, "0:", 0);
37
38 return fr;
39 }
25.1.2.4 Creating and Opening a Directory
The FatFs library allows to easily manipulate files as well as directories. To create a new directory
we can use the function:
FAT Filesystem 731
FRESULT f_mkdir(const TCHAR* path);
which accepts the full path to the directory to create. For example, assuming that our filesystem
already stores a directory named dir1 in its root, than to create a subdirectory we can pass the
string "0:/dir1/subdir1" to create a subdirectory within it.
To open an already existing directory, we can use the function:
FRESULT f_opendir(DIR* dp, const TCHAR* path);
dp is an instance of the C struct DIR that represent the handle to the opened directory; path is the
full path to the directory we want to open. If a valid handle is returned by the f_opendir() function,
then we can read its content by using the function:
FRESULT f_readdir(DIR* dp, FILINFO* fno);
dp is the instance corresponding to the directory opened using the f_opendir() function; fno is an
instance of the FILINFO struct that holds information regarding the current item in the directory.
The f_readdir() function works in this way. Once a directory is opened, we invoke f_readdir()
until it returns a value different from FR_OK (in case of an error occurred) or the fno.fname entry
is null. This last condition indicates that we reached the end of a directory and there are no more
elements (files or directories) to retrieve.
The FILINFO struct is defined in the following way:
typedef struct {
DWORD fsize; /* File size */
WORD fdate; /* Last modified date */
WORD ftime; /* Last modified time */
BYTE fattrib; /* Attribute */
TCHAR fname[13]; /* Short file name (8.3 format) */
#if _USE_LFN
TCHAR* lfname; /* Pointer to the LFN buffer */
UINT lfsize; /* Size of LFN buffer in TCHAR */
#endif
} FILINFO;
Let us analyze the fields of this struct.
• fsize : it stores the size of the file in bytes. It is meaningless if the object is a directory.
• fdate : indicates the date when the file was modified or the directory was created, and it has
the following structure
– bit [15:9]: year origin from 1980 (0..127)
– bit [8:5]: month (1..12)
FAT Filesystem 732
– bit [4:0]: day (1..31)
• ftime : indicates the time when the file was modified or the directory was created, and it has
the following structure
– bit [15:11]: hour (0..23)
– bit [10:5]: minute (0..59)
– bit [4:0]: second / 2 (0..29)
• fattrib : corresponds to the file/directory attribute, which is a combination of the attributes
listed in Table 2.
• fname : this null terminated string corresponds to the file/directory name in FAT 8:3 format. A
NULL string is stored when there are no longer items to read and it indicates that the structure
is invalid.
• lfname : this null terminated string corresponds to the file/directory name when the support to
long file names is enabled ( _USE_LFN macro != 0). More about this later.
Table 2: Lists of file/directory attributes
File/Directory attribute Description
AM_RDO Read only
AM_ARC Archive
AM_SYS System
AM_HID Hidden
The following example shows a routine that performs a depth-first traversal of the filesystem, print-
ing the name of files and folders using the trace_printf() routine. The routine uses f_opendir()
and f_readdir() functions to retrieve the content of each directory. The _USE_LFN macro allows to
properly handle the support to long file names. Its usage will be explained in the next paragraph.
1 FRESULT scan_files (TCHAR* path) {
2 FRESULT res;
3 DIR dir;
4 UINT i;
5 static FILINFO fno;
6 static TCHAR lfname[_MAX_LFN];
7 TCHAR *fname;
8
9 res = f_opendir(&dir, path); /* Open the directory */
10 if (res == FR_OK) {
11 while(1) {
12 #if _USE_LFN > 0
13 fno.lfname = lfname;
14 fno.lfsize = _MAX_LFN - 1;
15 #endif
16 /* Read a directory item */
FAT Filesystem 733
17 res = f_readdir(&dir, &fno);
18 /* Break on error or end of directory */
19 if (res != FR_OK || fno.fname[0] == 0) break;
20 #if _USE_LFN > 0
21 fname = *fno.lfname ? fno.lfname : fno.fname;
22 #endif
23 if (fno.fattrib & AM_DIR) { /* It is a directory */
24 i = strlen(path);
25 sprintf(&path[i], "/%s", fname);
26 /* Scan directory recursively */
27 res = scan_files(path);
28 if (res != FR_OK) break;
29 path[i] = 0;
30 } else { /* It is a file. */
31 trace_printf("%s/%s\n", path, fname);
32 }
33 }
34 f_closedir(&dir);
35 }
36 return res;
37 }
25.1.3 How to Configure the FatFs Library
The FatFs library is highly customizable. A set of configuration parameters (that is, configuration
macros)allowstoreducethetotalfootprintofthelibraryandenable/disablesomefeaturesatcompile
time.
All the configuration parameters are automatically exported by CubeMX inside the ffconf.h file.
We are now going to analyze the most relevant ones. For a more complete treatment of this subject
the reader should refer to the official documentation¹⁰.
• _FS_TINY : this macro can assume the values 0 (default) and 1. This option allows to reduce the
SRAM occupation of the FatFs library. When set to 0, every instance of the FIL struct has
an its own temporary buffer used during file read/write. Instead, when set to 1, a global pool
defined in FATFS struct is used. This slows down the read/write operations.
• _FS_READONLY : this macro can assume the values 0 (default) and 1. This macro skips from com-
pilationthosefunctionalitiesusedtomodifythefilesystem,byremovingwritingAPIfunctions
such as f_write() , f_sync() , f_unlink() , f_mkdir() , f_chmod() , f_rename() , f_truncate() ,
f_getfree() and optional writing functions as well.
• _FS_MINIMIZE : this macro defines the library minimization level, which consists in removing
some API functions. If set to 0, all APIs are available. If set to 1, f_stat() , f_getfree() ,
f_unlink() , f_mkdir() , f_chmod() , f_utime() , f_truncate() and f_rename() functions are
¹⁰ http://bit.ly/2dJGh3E
FAT Filesystem 734
removed. If set to 2, f_opendir() , f_readdir() and f_closedir() routines are removed in
addition to those ones when _FS_MINIMIZE is set to 1. If set to 3, the f_lseek() function is also
removed.
• _CODE_PAGE : this option specifies the OEM code page to be used on the target system. Incorrect
setting of the code page can cause a file open failure. For western countries, the CP1252 (aka
Latin1) is the most widespread code page used in Windows OS.
• _USE_LFN : this option switches the support for Long File Names (LFN). When enabling the LFN
mode, Unicode support functions contained in the option/unicode.c file needs to be added to
the project. Moreover, when enabling LFN support, we need to provide a pre-allocated buffer
to store the long file name. This requirement is not well documented in the FatFs library, and
unexperienced people waste a lot of time trying to figure out how to retrieve LFN names.
The scan_files() routine seen so far clearly shows how to perform this operation. The buffer
lfname is statically allocated on the stack at line 6. Then the fno.lfname pointer is set to point
to the lfname buffer at line 13. In the same way, the size of the buffer is specified at line 14. This
allows to the FatFs library to properly retrieve the LFN name of a file or a directory. Otherwise,
the fno.fname buffer contains the filename in the 8.3 format.
• _MAX_LFN : this macro specifies the maximum LFN length to handle (from 12 to 255).
• _LFN_UNICODE :thisoptionswitchescharacterencodingontheAPI.(0:ANSI/OEMor1:Unicode).
To use Unicode strings for the path names, you have to enable LFN feature and set _LFN_-
UNICODE to 1. This option also affects behavior of string I/O functions. Please take note that to
allow transparent usage of Unicode strings in FatFs library, the library itself defines the TCHAR
datatype,whichisautomaticallyconvertedtoa char iftheUnicodesupportisdisabled,ortoan
uint16_t if enabled. For more information about this topic, refer to the FatFs documentation¹¹.
• _VOLUMES : this macro sets the maximum number of logical drives per each physical disk.
By default, this macro is set to 1. For more information about this topic, refer to the FatFs
documentation¹².
• _FS_REENTRANT : this option switches the re-entrancy (thread safe) of the FatFs library itself.
File/directory access to different volumes is always re-entrant and it can work simultaneously
regardless of this option. Volume control functions ( f_mount() , f_mkfs() and f_fdisk() )
are always not re-entrant. File/directory access to the same volume is not reentrant, unless
the _FS_REENTRANT macro is set to 1. To enable this feature, the user also needs to provide
synchronization handlers routines, ff_req_grant() , ff_rel_grant() , ff_del_syncobj() and
ff_cre_syncobj() . ST engineers have implemented these routines so that they use FreeRTOS
semaphores. Take a look at the option/syscall.c file for more about this.
• _SYNC_t : when the _FS_REENTRANT macro is set to 1 it is required to specify also this macro,
which specifies the “type” of synchronization structure. When using FreeRTOS in conjunction
with the FatFs library, this macro is set to the osSemaphoreId type.
¹¹ http://bit.ly/2dJP9q1
¹² http://bit.ly/2dJPoBx
26. Develop IoT Applications
In a connected world, more and more devices are getting connected. Cars, home appliances such
as washing machines and freezers, lights, blinds, thermostats, but also sensors for environmental
monitoringarejustfewexamplesofdevicesthatnowadaysexchangemessagesthroughtheInternet.
Several observers agree by saying that this is the Internet of Things (IoT) era. Actually, it is hard to
say if IoT will represent a new golden era for the electronics industry. But it is certain that many
semiconductor companies are investing billions in this field.
IoTisavagueterm.Itdoessaynothingaboutcommunicationstandards,protocols,applicationlayers
andevensystemarchitectures.TheworldofIoTcommunicationprotocolsandtechnologiesisajun-
gle. There exist tens of standards, especially for wireless communication protocols. WiFi, Bluetooth,
Zigbee, LoRaWAN, proprietary solutions like SimpliciTI from TI or MiWI from Microchip, 4G/3G
mobile networks. But there exist even tens of communication mediums. For example, in wireless
communications the 2.4GHz and 5.8GHz frequencies are worldwide standards, but there are several
regional and alternative frequencies such as the 868MHz in EU (915MHz in US), 434MHz in several
parts of EU and US, 169MHz in large parts of EU and Japan. Every one of these standards has its
own rules about TX power, duty cycle, and so on. Every one has its advantages and disadvantages.
The choice of communication medium and protocol also impacts on the application architecture.
For example, a WiFi or Ethernet enabled device can connect to the Internet using just a router
with integrated MODEM. A device that uses a proprietary protocol (for example, a Zigbee device)
usually needs an intermediate device (a control unit) that collects the messages and sends them to
a centralized server (or a cloud server as now are called centralized servers) through the Internet.
For some “industrial” applications this is often an advantage (local devices can keep working even
in absence of the Internet). For consumer applications usually this discourages users from adopting
the solution.
Nowadays there are several silicon manufacturers that offer microcontrollers with integrated wired
andwirelessconnectivity.TexasInstruments,aftertheacquisitionofChipCon,hasdevelopedseveral
MCU with integrated radio front ends. For example, the CC2540 is an 8051 MCU with a 2.4GHz
radio dedicated to Bluetooth applications. The CC3200 is a Cortex-M4 core with a 2.4GHz radio
able to communicate according to the WiFi standard. Recently, another player appeared on the
market. Espressif¹ is a Chinese company that introduced to the market a dual core Tensilica² LX6
microcontroller running at 240MHz with integrated 2.4GHz radio and MAC layer (ESP32³). These
MCUs cost less than 5 USD at low volumes and they are becoming really popular between makers.
Apart from the unlucky STM32W, ST still does not offer an STM32 MCU with integrated radio
front end. And this is really sad, especially because ST has all the required know-how to build radio
¹ https://espressif.com/
² Tensilica is a company that, like ARM, design IP cores that are later implemented by silicon manufacturers. It is currently owned by
Cadence, the same company that designs the Allegro CAD.
³ http://bit.ly/2dN52fx
Develop IoT Applications 736
applications (its SPIRIT RF transceivers are among the best solutions on the market, according this
author). Several STM32 MCUs belonging to the more powerful series provide an integrated Ethernet
controller, which just requires a LAN phyther to connect the MCU to the Internet. Unfortunately,
apart from a pair of part numbers from the STM32F1-series, all MCUs with Ethernet interface come
with an higher pin-count package.
This chapter provides a solution to owners of Nucleo-64 boards that do not implement an Ethernet
controller. The proposed solution is based on the W5500 network processor from WIZnet⁴, a Korean
company specialized in designing this kind of devices. This company reached a great popularity
thanks to the W5100 IC, which was used to develop the popular Arduino Ethernet Shield⁵. We
will see how to develop an embedded application with an integrated web-server using the Nucleo.
However,beforeenteringinthisstuff,IwillprovideaquickintroductiontowhatSTofferstodevelop
IoT applications with the CubeHAL initiative.
26.1 Solutions Offered by STM to Develop IoT
Applications
As said before, several STM32 microcontrollers from F1/2/4/7-series provide an integrated Ethernet
controller, which supports the Media-Independent Interface (MII) and its variant Reduced-MII
(RMII).Thisisacommunicationstandardthatabstractsfromthegivenphysicalmedium,andallows
to connect the MAC layer of the ethernet controller to a physical controller chip, also calledphyther.
There exists several LAN phythers on the market, and the interconnection to the chip is all handled
by the low-level MII protocol.
However the existence of a dedicated hardware interface does not allow to build IoT applications
quickly.AcompleteTCP/IPstackisalsoneeded,otherwisetohandleasocomplexprotocolstacklike
theTCP/IPisimpossibleforasingledeveloper.STdoesnotprovideacustomsolution,butitadopted
the Lightweight IP (LwIP) stack. LwIP is an Open Source framework started by Adam Dunkels
and now maintained by a large community. Moreover, several other semiconductor companies, like
Altera, Xilinx and Freescale, contribute to the development of this quite complex framework.
ST has integrated LwIP in CubeMX, which automatically adds to the project all the necessary files
to work with this framework. Once you have enabled the Ethernet controller, the LwIP appears as
a selectable middleware component. The current stable release is the 2.0.2, which was released by
the end of 2016. ST actively maintains and support it.
These are the most relevant features of LwIP:
• IP (Internet Protocol, IPv4 and IPv6) including packet forwarding over multiple network
interfaces
• ICMP (Internet Control Message Protocol) for network maintenance and debugging
⁴ http://www.wiznet.co.kr/
⁵ http://bit.ly/2dMXhGi
Develop IoT Applications 737
• IGMP (Internet Group Management Protocol) for multicast traffic management
• MLD (Multicast listener discovery for IPv6)
– Aims to be compliant with RFC 2710. No support for MLDv2
• ND (Neighbor discovery and stateless address autoconfiguration for IPv6)
– Aims to be compliant with RFC 4861 (Neighbor discovery) and RFC 4862 (Address
autoconfiguration)
• UDP (User Datagram Protocol) including experimental UDP-lite extensions
• TCP (Transmission Control Protocol) with congestion control, RTT estimation and fast recov-
ery/fast retransmit
• Raw/native socket API for enhanced performance
• Optional Berkeley-like socket API
• DNS (Domain names resolver)
LwIP also provides complete implementation for the following application protocols:
• HTTP server with SSI and CGI
• SNMPv2c agent with MIB compiler (Simple Network Management Protocol)
• SNTP (Simple network time protocol)
• NetBIOS name service responder
• MDNS (Multicast DNS) responder
• iPerf server implementation
Due to the lack of a RMII interface in STM32 MCUs equipping the sixteen Nucleo-64 boards, I
will not detail here the operations needed to setup LwIP in your applications. Refer to CubeHAL
examples for more about this. Moreover, you can find some posts on my blog regarding this topic.
Finally, the CubeMXImporter tool implements all the necessary logic to import the LwIP stack in a
GNU MCU Eclipse project.
Figure 1: The SPWF01SA WiFi monolithic module
To develop WiFi applications, ST provides a custom module⁶ named SPWF01SA⁷ (see Figure 1).
This is a monolithic module made with an STM32 plus a 2.4GHz radio front-end. The STM32 is not
⁶ http://bit.ly/2duX3IJ
⁷ There exists four variants of this module. They differ for the antenna (if the P/N ends with an “A”, them the module has an integrated
chip antenna, it the P/N ends with a “C”, then a micro SMA connector is provided) and for the size of the embedded flash (512KB vs 1.5KB).
Develop IoT Applications 738
intended to be programmed by the user, but it stores a complete TCP/IPv4 stack plus an embedded
webserver.ByissuingATcommandsthroughtheUARTinterface,theusercanconfigurethemodule
so that it performs network operations (connecting to the Wi-Fi, network, opening sockets, and so
on). The embedded web server is also able to process webpages stored in the internal flash (so the
sizeoftheflashiscritical).TheinternalfirmwarecanbeupgradedovertheUARTthankstoacustom
bootloader. ST does not provide any source code and details regarding the TCP/IP stack. I do not
have any experience with this module, and I cannot say if worth investing on it. I suspect that its
functionalities are really limited. Finally, a compatible-Nucleo expansion board exists and its named
X-NUCLEO-IDW01M1⁸.
To develop sub-gigahertz applications ST provides several solutions based on the SPIRIT1 IC.
Moreover, ST can provide under NDA a complete stack to develop wireless application using this
IC. This stack is also compatible with the 6LowPAN protocol. A Nucleo expansion board exists (X-
NUCLEO-IDS01A4⁹) and ST has added support to the ContikiOS¹⁰ to use it in conjunction with the
SPIRIT1 transceiver.
Finally, ST has recently announced a partnership with Semtech to develop custom solutions
compatiblewiththeLongRangeAlliance (LoRa).Accordingtothispressnews¹¹,STplanstodevelop
STM32 microcontrollers with on-chip LoRa technology that supports the LoRaWAN TM standardized
protocol. Semtech and ST will cooperate to integrate LoRa technology into multiple platforms that
target a variety of applications for several business initiatives around LoRa. At the time of writing
this chapter (November 2016), ST has released a library compatible with the CubeHAL¹² and a
referencekitbasedontheNucleoboard.ThekitusestheMBEDcompatibleshieldSX1272MB2xAS¹³
by Semtech. I will try them soon. Give a look at my blog. Finally, this Taiwanese company¹⁴
manufacturers System-in-a-Package (SiP) modules that integrate an STM32 and a Semtech RF IC in
a single package: it seems a really interesting integration.
26.2 The W5500 Ethernet Controller
Apart from the more recent Nucleo-144 boards, none of the other Nucleo-64 and Nucleo-32 boards
provide an STM32 MCU with the integrated Ethernet controller. This means that, if you want to
develop IoT applications with your Nucleo, you need to use an external expansion board.
WIZnet is a Korean company that reached the popularity thanks to the Arduino board. In fact, its
first ethernet controller, the W5100 IC, was the chip used to create the Arduino Ethernet Shield.
Starting from the W5100 controller, WIZnet has iterated the development of other similar products.
The current best-in-class product is the W5500, which we will study in this chapter.
The W5500 is a monolithic Ethernet controller, with integrated LAN Phyther. Moreover it is a
complete network processor, with hardwired TCP/IP stack. The chip is designed to exchange data
⁸ http://bit.ly/2duZ8UY
⁹ http://bit.ly/2duZIC0
¹⁰ http://bit.ly/2duZoTR
¹¹ http://bit.ly/2dv2PtK
¹² http://bit.ly/2dv3LOF
¹³ http://bit.ly/2dv3ECM
¹⁴ http://www.acsip.com.tw
Develop IoT Applications 739
with a host microcontroller through a fast SPI interface (the interface is able to work up to 80MHz).
These are the most important characteristic of this chip:
• Supports TCP, UDP, ICMP, IPv4, ARP, IGMP, PPPoE
• Supports 8 independent sockets simultaneously
• Supports Power down mode
• Supports Wake on LAN over UDP
• Supports High Speed Serial Peripheral Interface(SPI MODE 0, 3) up to 80MHz
• Internal 32Kbytes Memory for Tx/Rx Buffers
• 10BaseT/100BaseTX Ethernet PHY embedded
• Supports Auto Negotiation (Full and half duplex, 10 and 100-based)
• 3.3V operation with 5V I/O signal tolerance
• LED outputs (Full/Half duplex, Link, Speed, Active)
• 48 Pin LQFP Lead-Free Package (7x7mm, 0.5mm pitch)
Figure 2: A custom device made with an STM32F0 MCU (on the left) and a W5500 IC (on the right)
The W5500 IC is really easy to embed in a custom design. Just a crystal, few passives and a LAN
transformer are required to make it working. The chip also integrates the charging pump needed
to feed the LAN transformer. I have successfully used this chip in a couple of custom designs.
Being the whole TCP/IP stack included inside the network processor, this chip can be used even
in conjunction with low-cost STM32F0 microcontrollers. Moreover, for low-volume productions it
is more convenient to use one of these chips with a low-cost STM32 MCU instead of a powerful one
with the integrated Ethernet and the external dedicated LAN phyther. Figure 2 shows a custom
design made by this author where an STM32F030 MCU is used to drive the W5500 IC. Static
webpages are stored inside an external SPI FLASH memory.
Develop IoT Applications 740
WIZnet developed an Arduino compatible shield (see Figure 3) that works out of the box even with
Nucleo boards. This shield also integrates a MicroSD card reader, which is connected on the same
SPI port of the W5500 IC. This allows to store webpages and other static contents (images, CSS,
JavaScript files and so on) on an external SD card.
Figure 3: The W5500 Ethernet Shield by WIZnet
Network processors like the W5500 and similar work in a really simple way. The chip offers up to
eight sockets¹⁵. Every socket has a set of associated registers. By modifying the content of these
registers it is possible to drive the socket (open a connection, place it in listening mode, send/receive
dataandsoon).Totransferdataoverasocket,theW5500offersaninternal32KBbufferspace,which
can be freely subdivided between the eight socket as we will see later. By writing into/reading from
this buffer you can exchange data with the other endpoint. This means that, from the MCU point
of view, driving these ICs is just a matter of bytes exchanged over the SPI interface. However, to
handle all the internal states of a socket may be hard, especially for novices of these ICs. I have
developed a library to drive the W5100, and I can confirm that this activity is time consuming.
Moreover, unfortunately all W5X00 ICs (5100, 5200, 5300 and 5500) have some “nasty” and not well-
documented bugs that it is hard to address.
¹⁵ A socket in networking is an abstraction over the complex TCP/IP stack. It is just an handle that allows to send a stream of bytes from a
machine to another, without dealing with the complex underlying protocol (unless you need to perform advanced operations).
Develop IoT Applications 741
Figure 4: The architecture of the ioLibrary_Driver library
WIZnet started releasing a dedicated library for this family of chips about two years ago. It is
named ioLibrary_Driver and it is available on GitHub¹⁶. The library architecture is shown in
Figure 4. The library is essentially composed by two layers. One layer, called Ethernet , contains
the primitives used to establish connections between peers. The file Ethernet/socket.c contains
all routines related to socket management. The socket API is similar to the BSD socket API, even
if it is not totally complaint with it. The same Ethernet layer contains low-level drivers for each
WIZnet chip. For example, the file Ethernet/w5500.c contains all the necessary logic to drive the
W5500 chip. Finally, the Ethernet/wizchip_conf.h file contains configuration macros used to setup
the library (more about this later).
The Internet layer is built upon the Ethernet one and it is a collection of several Internet protocols
and services:
• DHCP client
• DNS client
• FTP client and server
• SNMP agent/trap
• SNTP client
• TFTP client
• HTTP server
The user application can use one or more of the above protocols or access directly to the Ethernet
layer to build a custom application.
¹⁶ https://github.com/Wiznet/ioLibrary_Driver
Develop IoT Applications 742
26.2.1 How to Use the W5500 Shield and the ioLibrary_Driver
Module
As said before, the W5500 mates seamlessly with all sixteen Nucleo boards. The Figure 5¹⁷ shows
the shield pinout. The SPI interface is routed to D13, D12 and D11 pins, and they correspond to the
same pins of the SPI1 peripheral (apart for the Nucleo-F302R8 board where those pins correspond
to SPI2 peripheral). The Slave Select (SS) pin for the W5500 pin corresponds to the Arduino D10 pin,
while the SS pin for the SD card corresponds to the Arduino D4 pin.
Figure 5: The pinout of the W5500 shield
¹⁷ The figure is taken from the WIZnet website(http://bit.ly/2dxjblH).
Develop IoT Applications 743
Looking to Figure 5, you can see that the D2 pin plays an important role. The
W5500 IC is designed to optionally assert low the INTn pin when several events
related to the network interface (e.g. IP collision, etc.) or to the single socket (e.g.
connection established, data received, etc.) happen. This feature allows to configure
thecorrespondingMCUpinas GPIO_MODE_IT_FALLING ,sothatthecorrespondingIRQ
fires when the IC asserts low the INTn pin. This allows to write down asynchronous
applications, especially if you are using the ioLibrary_Driver in conjunction with an
RTOS (for example, the ISR may use a semaphore to wake-up a sleeping thread that
starts performing operation with a socket).
Figure 6: To enable INTn pin, it is required to short 1-2 pads
Take note that in the W5500 shield the D2 pin is not connected to the W5500 INTn
pin. To enable it, you need to solder a 0603 0Ω resistor between pads 1-2, as shown in
Figure 6 (a joint with a solder drop is also sufficient).
Once the hardware connection is established, we can focus our attention to the software part. To
import the ioLibrary_Driver module in an existing Eclipse project is pretty easy. You first need to
drag the whole library in the Eclipse project root dir. Then you need to add the following path to
the list of Include paths inside the Project settings:
• "../ioLibrary_Driver/Ethernet"
• "../ioLibrary_Driver/Internet"
Finally you need to specify the exact W5XXX chip type, by setting the macro _WIZCHIP_ inside the
ioLibrary_Driver/Ethernet/wizchip_conf.h file.
Develop IoT Applications 744
26.2.1.1 Configuring the SPI Interface
The ioLibrary_Driver module is designed to be abstracted from specific MCU and routines to
manipulate the SPI interface. It can be used with an STM32, an AVR, a Microchip MCU and so
on. So we need a way to interface it with the HAL_SPI module needed to program the SPI peripheral.
As users of this library, we need to provide 6 callback routines that implement all the necessary logic
to drive the SPI. These routine are the following ones:
• void cs_sel() :thiscallbackisinvokedbythelibraryeverytimeitneedstoselect(assertLOW)
the pin latched to the W5500 SS pin.
• void cs_desel() : this callback is invoked by the library every time it needs to deselect (assert
HIGH) the pin latched to the W5500 SS pin.
• uint8_t spi_rb() : this routine is invoked when one byte needs to be read from the SPI
interface.
• void spi_wb(uint8_t b) : this routine is invoked when one byte need to be sent over the SPI
interface.
• void spi_rb_burst(uint8_t *buf, uint16_t len) : this optional callback is invoked when
more than three bytes need to be read over the SPI. This allows us to implement the callback
handling the SPI in DMA mode, which speeds up the transfer speed (this mode is also called
burst mode).
• void spi_wb_burst(uint8_t *buf, uint16_t len) : this optional callback is invoked when
more than three bytes need to be sent over the SPI. This allows us to implement the callback
handling the SPI in DMA mode.
Assuming that the SPI interface is configured accordingly, we can simply implement those callbacks
in the following way:
void cs_sel() {
HAL_GPIO_WritePin(W5500_CS_GPIO_Port, W5500_CS_Pin, GPIO_PIN_RESET); //CS LOW
}
void cs_desel() {
HAL_GPIO_WritePin(W5500_CS_GPIO_Port, W5500_CS_Pin, GPIO_PIN_SET); //CS HIGH
}
uint8_t spi_rb(void) {
uint8_t rbuf;
HAL_SPI_Receive(&hspi1, &rbuf, 1, HAL_MAX_DELAY);
return rbuf;
}
void spi_wb(uint8_t b) {
HAL_SPI_Transmit(&hspi1, &b, 1, HAL_MAX_DELAY);
}
Develop IoT Applications 745
void spi_rb_burst(uint8_t *buf, uint16_t len) {
HAL_SPI_Receive_DMA(&hspi1, buf, len);
while(HAL_SPI_GetState(&hspi1) == HAL_SPI_STATE_BUSY_RX);
}
void spi_wb_burst(uint8_t *buf, uint16_t len) {
HAL_SPI_Transmit_DMA(&hspi1, buf, len);
while(HAL_SPI_GetState(&hspi1) == HAL_SPI_STATE_BUSY_TX);
}
Once we have defined the hardware related functions, we have to “pass” them to the ioLibrary .
This job can be performed by using the following routines:
...
reg_wizchip_cs_cbfunc(cs_sel, cs_desel);
reg_wizchip_spi_cbfunc(spi_rb, spi_wb);
reg_wizchip_spiburst_cbfunc(spi_rb_burst, spi_wb_burst);
Finished.Withthosefewlinesofcodewehavesuccessfullyintegratedthe ioLibrary_Driver library
with the CubeHAL.
26.2.1.2 Configuring the Socket Buffers and the Network Interface
Now we are finally ready to start using the W5500 IC. The first step consists in initializing the
W5500 chip with a well-defined procedure. The first function to call, once the callbacks have been
configured, is the following one:
int8_t wizchip_init(uint8_t* txsize, uint8_t* rxsize);
This routine does two things: it resets the W5500 IC (mandatory procedure) and configures the size
of TX and RX buffers for each individual socket. All W5X00 ICs have two internal common memory
areas dedicated to TX and RX buffers. In W5500 chip these areas are 16KB wide each. These two
areas must be in turn subdivided among the sockets we want to use. The default configuration gives
2KBof these areas to each of the eightsocket.But if, for example,ourapplication needs just 4 socket,
than we can subdivide RX and TX buffer by four. Or, if one socket needs more rooms to exchange
data with the other peer, then we can give more space to just one socket and reduce the space to
other ones.
We can specify the allocation of TX and RX buffer by passing to wizchip_init() routine two arrays,
each one with eight values. The only requirement is that the sum of these values must not exceed
16. For example, assuming that we want to use just two sockets in our application, we can define
the configuration array in the following way:
Develop IoT Applications 746
uint8_t bufSize[] = {12, 4, 0, 0, 0, 0, 0, 0};
wizchip_init(bufSize, bufSize);
The above code simply allocates 12KB of TX and RX buffers to the first socket, and the remaining
4KB to the second socket. Clearly, we are free to arrange TX and RX buffer as long as we respect
the total size of 16KB.
Once the chip is initialized, we can configure the network interface, by using the function:
void wizchip_setnetinfo(wiz_NetInfo* pnetinfo);
where the wiz_NetInfo struct , used to pass to the library the network configuration parameters,
is defined in the following way:
typedef struct wiz_NetInfo_t {
uint8_t mac[6]; /* Source Mac Address */
uint8_t ip[4]; /* Source IP Address */
uint8_t sn[4]; /* Subnet Mask */
uint8_t gw[4]; /* Gateway IP Address (optional) */
uint8_t dns[4]; /* DNS server IP Address (optional) */
dhcp_mode dhcp; /* 1 - Static, 2 - DHCP (optional) */
} wiz_NetInfo;
I will not detail those fields here because they are really self-explaining. For example, to configure
the W5500 so that it can connect to the 192.168.1.0/24 subnet, we can proceed in the following way:
wiz_NetInfo netInfo = {.mac = {0x00, 0x08, 0xdc, 0xab, 0xcd, 0xef}, // Mac address
.ip = {192, 168, 1, 192}, // IP address
.sn = {255, 255, 255, 0}, // Subnet mask
.gw = {192, 168, 1, 1}}; // Gateway address
wizchip_setnetinfo(&netInfo);
Please, take note that here we are using an arbitrary MAC address in this example. This
procedure is permitted for a private and test environment, but it is completely forbidden if
you are planning to sell your W5500 based product. In this case, you have to buy a valid
pool of MAC address from IEEE (pools starts from batches of 4096 addresses for about 650
USD¹⁸). Alternatively, Microchip sells pre-programmed ICs¹⁹ with a valid IEEE EUI-48 and
EUI-64 MAC addresses (they work like I²C EEPROM). For small volume productions they
are a good alternative to buying custom MAC addresses.
¹⁸ http://bit.ly/2dKKlDJ
¹⁹ http://bit.ly/2dKLLhA
Develop IoT Applications 747
26.2.2 Socket APIs
The ioLibrary_Driver moduleprovidesanAPItomanipulatesocketsthatresemblestheBSDsocket
API. Even if it is not compatible with it, if you have already worked with BSD API then it will be
very easy for you to start working with it.
To initialize a new socket, we can use the function:
int8_t socket(uint8_t sn, uint8_t protocol, uint16_t port, uint8_t flag);
where:
• sn : corresponds to the socket number, and it can range from 0 up to 7 if you are using a W5500
IC that provides 8 sockets.
• protocol : this parameter defines the socket protocol type. The W5500 is able to handle three
protocol types: TCP, UDP and RAW socket²⁰. This parameter can so assume one of the values
Sn_MR_TCP , Sn_MR_UDP and Sn_MR_MACRAW .
• port : specify the port number associated to the socket.
• flag : it is a combination (logical or) of additional configuration parameters listed in Table 1.
On success, the socket() function returns the sn value, otherwise it may return SOCKERR_SOCKNUM
to indicate a wrong socket number, SOCKERR_SOCKMODE to indicate a wrong protocol or SOCKERR_-
SOCKFLAG to indicate an invalid flag parameter.
Table 1: Socket flag values
Mode Description
SF_IO_NONBLOCK Configures the socket in non-blocking mode
SF_ETHER_OWN W5500 can only receive broadcasting packet or packet sent to
itself. This parameter applies only to RAW socket
SF_IGMP_VER2 Enables IGMP version 2 when socket protocol is UDP and the
SF_MULTI_ENABLE mode is also specified
SF_MULTI_ENABLE Enables multicast mode when socket protocol is UDP
SF_TCP_NODELAY Configures a TCP socket so that the ACK packet is sent as soon
as a data packet is received from the remote peer
SF_BROAD_BLOCK Prevents the socket from receiving broadcast packets when the
socket protocol is UDP or RAW
SF_MULTI_BLOCK Prevents the socket from receiving broadcast packets when the
socket protocol is RAW
SF_IPv6_BLOCK Prevents the socket from receiving IPv6 packets when the socket
protocol is RAW
SF_UNI_BLOCK Prevents the socket from receiving unicast packets when the
socket protocol is UDP
²⁰ A RAW socket is a socket that allows to exchange packets using directly the IP protocol and without any protocol-specific transport layer
(that is, TCP or UDP).
Develop IoT Applications 748
To close a socket, and to deconfigure it, we use the function:
int8_t close(int8_t sn);
Read Carefully
Please, take note that if you are using I/O functions from the C standard library, then this
function will crash with the signature of the C stdlib close() function, which is designed
to accept and return an int type. A lot of compiler errors will be generated. Unfortunately,
WIZnet guys have chosen an unhappy name and signature. You can bypass this problem by
modifying the library declaring the close() function in this other way:
int close(int sn);
A W5500 socket has a well-defined status and it could be really useful to retrieve it to better
understate the connection state. The macro:
getSn_SR(sn);
automatically retrieves the socket status from its registers. The possible status values for a W5500
IC are listed in Table 2.
Table 2: Socket status values
Status Description
SOCK_CLOSED Closed
SOCK_INIT In initialization state
SOCK_LISTEN Listen
SOCK_ESTABLISHED Connection established
SOCK_CLOSE_WAIT Closing state
SOCK_UDP UDP Socket
SOCK_SYNSENT Connect-request packet (SYN) sent to remote peer
SOCK_SYNRECV Connect-request packet (SYN) received from remote peer
SOCK_FIN_WAIT Started socket closing procedure
SOCK_CLOSING Closing the socker
SOCK_TIME_WAIT Waiting for socket closing
SOCK_LAST_ACK The socket is still open but the remote peer closed the
connection
Develop IoT Applications 749
26.2.2.1 Handling Sockets in TCP Mode
Once the socket protocol and mode is configured, we can start a connection to a remote peer (client
application) or place the socket in listen mode to accept connections from a remote peer (server
application).
To start a connection with a remote peer, we use the function:
int8_t connect(uint8_t sn, uint8_t * addr, uint16_t port);
• sn : corresponds to the socket configured with the socket() function.
• addr : it is an array of four bytes corresponding to the IPv4 address of the remote peer.
• port : it is the port number of the remote peer.
On success, the connect() function returns SOCK_OK value. Otherwise a list of possible error values
exists. Take a look at the socket.h file.
When the connection with the remote peer is established, we can send a sequence of bytes by using
the function:
int32_t send(uint8_t sn, uint8_t * buf, uint16_t len);
where buf is the array of bytes having the len length.
Instead, to receive an array of bytes from the remote peer, we use the function:
int32_t recv(uint8_t sn, uint8_t * buf, uint16_t len);
To disconnect from the remote peer, we can use the function:
int8_t disconnect(uint8_t sn);
If, instead, we are going to create a server application, once the socket has been configured by using
the socket() function, we can place it in listen mode by using the function:
int8_t listen(uint8_t sn);
Once a connection is established, we can receive and send data using recv() and send() functions.
26.2.2.2 Handling Sockets in UDP Mode
UDP is a connection-less protocol, so we do not need to explicitly create connections to start
exchanging bytes with the remote peer.
To send an array of bytes to a remote peer when the socket is in UDP mode, we use the function:
Develop IoT Applications 750
int32_t sendto(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t port);
while to receive bytes from the remote peer we use the function:
int32_t recvfrom(uint8_t sn, uint8_t * buf, uint16_t len, uint8_t * addr, uint16_t *port);
26.2.3 I/O Retargeting to a TCP/IP Socket
In Chapter 8 we have seen how to retarget C terminal I/O functions, like printf() and scanf() , to
an UART interface. During the development of IoT applications, it comes really in handy to retarget
I/O to a network socket, so that we can debug our device through a network connection. This is
really useful especially if the device is not under our direct control.
This operation is really easy using a W5500 IC and the relative socket library. The RetargetInit()
function can be rewritten in the following way:
Filename: system/src/retarget/retarget-tcp.c
12 #ifdef RETARGET_TCP
13
14 #define STDIN_FILENO 0
15 #define STDOUT_FILENO 1
16 #define STDERR_FILENO 2
17
18 #ifndef RETARGET_PORT
19 #define RETARGET_PORT 5000
20 #endif
21
22 int8_t gSock = -1;
23
24 uint8_t RetargetInit(int8_t sn) {
25 gSock = sn;
26
27 /* Disable I/O buffering for STDOUT stream, so that
28 * chars are sent out as soon as they are printed. */
29 setvbuf(stdout, NULL, _IONBF, 0);
30
31 /* Open 'sn' socket in TCP mode with a port number equal
32 * to the value of RETARGET_PORT macro */
33 if(socket(sn, Sn_MR_TCP, RETARGET_PORT, 0) == sn) {
34 if(listen(sn) == SOCK_OK)
35 return 1;
36 }
37 return 0;
38 }
Develop IoT Applications 751
The code is really self-explaining. The RetargetInit() function accepts a socket number, which for
a W5500 IC ranges from 0 to 7. The function so configures the socket and places it in listening mode.
The _write() function can so be rearranged in the following way:
Filename: system/src/retarget/retarget-tcp.c
12 int _write(int fd, char* ptr, int len) {
13 int sentlen = 0;
14 int buflen = len;
15
16 if(getSn_SR(gSock) == SOCK_ESTABLISHED) {
17 if (fd == STDOUT_FILENO || fd == STDERR_FILENO) {
18 while(1) {
19 sentlen = send(gSock, (void*) ptr, buflen);
20 if (sentlen == buflen)
21 return len;
22 else if (sentlen > 0 && sentlen < buflen) {
23 buflen -= sentlen;
24 ptr += (len - buflen);
25 }
26 else if (sentlen < 0)
27 return EIO;
28 }
29 }
30 } else if(getSn_SR(gSock) != SOCK_LISTEN) {
31 /* Remote peer close the connection? */
32 close(gSock);
33 RetargetInit(gSock);
34 }
35
36 errno = EBADF;
The function starts checking if the socket state is equal to SOCK_ESTABLISHED : this means that the
remote peer has established a connection to our device. Instead, if the socket is not in listening
mode (line 66), then it could be that the remote peer closed the connection: we so need to configure
the socket again in listening mode by calling the RetargetInit() function. If the remote peer has
established the connection, then we can start sending the ptr buffer over the TCP/IP connection.
The _read() function is almost identical to the _write() one. Refer to the book examples for the
complete source code. To use this module we simply need to define the macro RETARGET_TCP at
project level, and to eventually remove the macro OS_USE_SEMIHOSTING .
To start a connection to the device, Linux and MacOS users can use the telnet command, while
Windows users can use a terminal emulator program like putty .
Develop IoT Applications 752
26.2.4 Setting up an HTTP Server
The Internet/httpServer module provides a complete HTTP server implementation built upon the
Ethernet layer.ThismoduleallowsyoutosetupanHTTPserverinafewsteps,especiallyifyouneed
just to serve static content (that is, simple webpages that do not need to process data dynamically).
The function
void httpServer_init(uint8_t * tx_buf, uint8_t * rx_buf, uint8_t cnt, uint8_t * socklist);
is used to configure the HTTP module. It accepts two pointers, tx_buf and rx_buf , to two memory
buffers used to store data exchanged by the HTTP server. These arrays need to have a sufficient
amount of space to store HTTP headers. In fact, when accessing to a webpage, the browser needs to
exchange with the webserver several “underlying” messages defined by the HTTP protocol. These
messages consume several hundreds of bytes, and for this reason a minimum viable size for both
tx_buf and rx_buf buffers is equal to 1024 bytes²¹. The cnt parameter says to the HTTP module
how many W5500 sockets it can use, and the socklist parameter is used to pass the exact list of
available sockets.
For example, the following code fragment initialize the HTTP server by passing two buffers, each
one sized 1024 bytes, and an array containing the list of sockets to use to process HTTP requests:
#define DATA_BUF_SIZE 1024
#define MAX_HTTPSOCK 5
uint8_t RX_BUF[DATA_BUF_SIZE], TX_BUF[DATA_BUF_SIZE];
uint8_t socknumlist[] = {0, 1, 2, 3, 4};
...
httpServer_init(TX_BUF, RX_BUF, MAX_HTTPSOCK, socknumlist);
...
Once the HTTP server is configured from the network point of view, we need to make it aware of
the content to serve (HTML pages, images, and so on). There are two ways to perform this: one is
suitableforreallysmallandlimitedapplications,andtheotheroneformorecomplexandstructured
web applications.
By using the function:
void reg_httpServer_webContent(uint8_t * content_name, uint8_t * content);
we can associate to a given resource (for example the file index.html ) an array of bytes to send over
the socket to the browser. The content_name parameter corresponds to the resource name and the
content one to the array containing the bytes forming the resource.
²¹ It is possible to reduce the size of the two buffers, since the HTTP library is able to split the whole HTTP stream in smaller chunks, but
this will increase the transfer time.
Develop IoT Applications 753
Why the HTTP server needs more than a free socket to accomplish its activities? This is a
fundamental concept to keep in mind while developing web-based embedded applications,
and so we will spend few words about it.
Modern web-based applications are really complex. Usually a website is made of several
resources:
• HTML pages that contains the actual content of the web application;
• images that adorn the HTML content and, in some cases, constitute the part of the
webpage content.
• CSS and Javascript files that configure the page rendering and its functionalities.
When a web browser accesses to a website, it starts loading the main HTML page (which
corresponds to the index.html file, if not specified). This page is parsed almost immediately
(some browser can start parsing pages as long as they receive the very first bytes), and
if it contains references to other web resources, the browser starts loading them almost
in parallel. This simultaneous access to website resources implies that several sockets are
opened by the browser towards the HTTP server (the HTTP protocol is stateless and it
defines that for each web resource a separated request must be performed to the server). For
a true web-server, like Apache or NGIX, designed to run on a powerful machine, this does
not constitute a problem. These server applications are designed to process even thousands
concurrent connections. Moreover, the powerful underlying hardware allows to serve a
content even in few milliseconds, depending on the connection speed. Sockets are so opened
and closed in less than a second.
Foraweb-serverrunningonatrue-embeddedplatformtheaccesstosimultaneousresources
is a thing that must be characterized carefully. Every socket eats several hardware resources
and for a WIZnet device the maximum number of socket is limited. This implies that we are
notfreetoarrangetheapplicationaswewant,andsomemodernframework(likeBootstrap,
Angular JS, and so on) often need to be rearranged when used on an embedded device
(sometimes we have to avoid them at all).
For example, to send a simple HTML page we can write the following code:
const char webpage[] = "<html>
<head>
<title>Simple Web Page</title>
</head>
<body>
<h1>Hello World!</h1>
</body>";
reg_httpServer_webContent((uint8_t*)"index.html", webpage);
...
This approach has several pitfalls. First of all, the web page is embedded inside the firmware code.
This means that the HTML content adds to the firmware itself, increasing the whole binary image.
Develop IoT Applications 754
Secondly, every time we change something to the web content we need to recompile the whole
binary image. For large and structured web applications this approach is impractical.
ThesecondapproachconsistsininstructingtheHTTPmodulesothatitfindsandtakesstaticcontent
from a memory device. For example, we can modify its code so that it loads the web resources from
a flash memory. This is what we will make in the next example, where we will use the FatFs library
to retrieve web content stored on the external SD card.
When the HTTP server is properly configured, we can start servicing requests coming from remote
peers. By default, this operation is performed in polling mode by calling the following function:
void httpServer_run(uint8_t seqnum);
This function accepts the index corresponding to the socket id stored inside the socklist parameter
passed to the httpServer_init() function. For every registered socket, this function checks the
status of the corresponding socket and executes the HTTP state machine according to the given
socket status. For example, if the passed socket is opened and in listening mode, the httpServer_-
init() function checks if a remote peer has established a connection. The whole HTTP protocol and
state machine is handled by the HTTP module, and there is no need to know the implementation
details unless we need to do something advanced with it.
Finally, the HTTP module uses some internal delays which are based on a common timebase unit
(tick). The function:
httpServer_time_handler();
must be called from a timer configured to expire every 1ms (the Systick ISR is a right place to call
that function).
26.2.4.1 A Web-Based Oscilloscope
Due to limited hardware resources of the most of STM32 MCUs equipping the sixteen
Nucleo boards, this example has been tested just on STM32F401RE, STM32F411RE and
STM32F446RE MCUs.
We are now going to review a more complete example that shows how to use the W5500 IC and
the ioLibrary_Driver ²² module to build complex and structured applications. In this example we
will use several STM32 peripherals to build a sort of web-based oscilloscope, which is shown in
Figure 7. By connecting a signal source to one of the inputs of the ADC peripheral, we can see the
corresponding waveform by simply accessing to a web console using a common browser. A video
that shows how the oscilloscope works can be seen here²³.
²² The ioLibrary_Driver shipped with this chapter’s example is not the official library provided by WIZnet. This author made several
modifications to the HTTP module to improve its reliability, performances and flexibility. For example, this modified version is able to serve
content stored on an SD card using the FatFs module or on the developer’s PC using ARM semihosting.
²³ https://youtu.be/fjtLQJDJ_04
Develop IoT Applications 755
Figure 7: The interface of the web-based oscilloscope
The example uses several popular and modern web-frameworks to structure the user interface:
Bootstrap²⁴, jQuery²⁵ and D3js²⁶. The description of these frameworks is outside the scope of the
book and it will be assumed that the reader has a decent knowledge of the most common and
modern web-development techniques.
The application is organized in two main parts: an “underlying” part responsible of the analog-
to-digital conversion from the selected ADC input (IN0 by default) and a part that serves HTTP
requests using the ioLibrary_Driver module. All web resources are assumed to be placed on an
SD card, which is accessed using the FatFs module and the SPI-compatible driver developed by this
author. However, to simplify the development process, the application is also able to serve content
from the developer’s PC using ARM semihosting calls and regular C stdlib functions.
Thefollowingcodefragmentisrelatedtothe main() function.Toacquireasignalthatvariesoverthe
time (for example, a 50Hz sine-wave), we need to perform ADC conversions at regular intervals. We
so use the TIM2 timer²⁷ to drive the ADC1 peripheral, which is configured to work in DMA circular
mode: in this way the timer will trigger conversion continuously. The ADC is so started in DMA
mode (line 145) and converted values are stored inside the _adcConv array. The adcSem semaphore
instantiated at line 140 will be used to rule the access to the _adcConv array, which holds the ADC
converted values. Its role will be better explained later.
²⁴ http://getbootstrap.com/
²⁵ https://jquery.com/
²⁶ https://d3js.org/
²⁷ The source code presented here is related to the Nucleo-F401RE board.
Develop IoT Applications 756
Filename: src/ch25/main-ex2.c
135 int main(void) {
136 HAL_Init();
137 Nucleo_BSP_Init();
138
139 osSemaphoreDef(adcSem);
140 adcSemID = osSemaphoreCreate(osSemaphore(adcSem), 1);
141
142 MX_ADC1_Init();
143 MX_TIM2_Init();
144 HAL_TIM_Base_Start(&htim2);
145 HAL_ADC_Start_DMA(&hadc1, (uint32_t*)_adcConv, 200);
146
147 MX_SPI1_Init();
148
149 #if defined(_USE_SDCARD_) && !defined(OS_USE_SEMIHOSTING)
150 SD_SPI_Configure(SD_CS_GPIO_Port, SD_CS_Pin, &hspi1);
151 MX_FATFS_Init();
152
153 if(f_mount(&diskHandle, "0:", 1) != FR_OK) {
154 #ifdef DEBUG
155 asm("BKPT #0");
156 #else
157 while(1) {
158 HAL_Delay(500);
159 HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
160 }
161 #endif //#ifdef DEBUG
162 }
163
164 #ifdef OS_USE_TRACE_ITM
165 /* Prints the SD content over the ITM port */
166 TCHAR buff[256];
167 strcpy(buff, (char*)L"/");
168 scan_files(buff);
169 #endif //#ifdef OS_USE_TRACE_ITM
170
171 #endif //#if defined(_USE_SDCARD_) && !defined(OS_USE_SEMIHOSTING)
172
173 osThreadDef(w5500, SetupW5500Thread, osPriorityNormal, 0, 512);
174 osThreadCreate(osThread(w5500), NULL);
175
176 osKernelStart();
177 /* Never coming here, but just in case... */
178 while(1);
179 }
Develop IoT Applications 757
If the global macro _USE_SDCARD_ is set and we are not using the ARM semihosting (so the global
macro OS_USE_SEMIHOSTING is not set), then this means that web resources (HTML files, images and
CSS/JS script files) are stored on a MicroSD card inserted in the W5500 shield card holder. The FatFs
library is so initialized (lines [150:151]) and the first partition is mounted (line 153). Moreover, if we
are using a debugger able to read ITM stimuluses, we print on the SWV console the content of the
SD card by calling the scan_files() routine (which has been shown in Chapter 25).
Finally the SetupW5500Thread() thread is started, which is responsible to configure the W5500 IC
and to handle the incoming HTTP requests. Its code is really simple and it is shown next.
Filename: src/ch25/main-ex2.c
181 void SetupW5500Thread(void const *argument) {
182 UNUSED(argument);
183
184 /* Configure the W5500 module */
185 IO_LIBRARY_Init();
186
187 /* Configure the HTTP server */
188 httpServer_init(TX_BUF, RX_BUF, MAX_HTTPSOCK, socknumlist);
189 reg_httpServer_cbfunc(NVIC_SystemReset, NULL);
190
191 /* Start processing sockets */
192 while(1) {
193 for(uint8_t i = 0; i < MAX_HTTPSOCK; i++)
194 httpServer_run(i);
195 /* We just delay for 1ms so that other threads with the same
196 * or lower priority can be executed */
197 osDelay(1);
198 }
199 }
The thread starts configuring both the W5500 IC and the ioLibrary_Driver library by calling the
function IO_LIBRARY_Init() (shown below). Next, the HTTP server is configured (line 188) and an
infinite loop calls the httpServer_run() function for every socket allocated to the HTTP server.
Filename: src/ch25/main-ex2.c
79 void IO_LIBRARY_Init(void) {
80 uint8_t runApplication = 0, dhcpRetry = 0, phyLink = 0, bufSize[] = {2, 2, 2, 2, 2};
81 wiz_NetInfo netInfo;
82
83 reg_wizchip_cs_cbfunc(cs_sel, cs_desel);
84 reg_wizchip_spi_cbfunc(spi_rb, spi_wb);
85 reg_wizchip_spiburst_cbfunc(spi_rb_burst, spi_wb_burst);
86 reg_wizchip_cris_cbfunc(vPortEnterCritical, vPortExitCritical);
87
88 wizchip_init(bufSize, bufSize);
Develop IoT Applications 758
89
90 ReadNetCfgFromFile(&netInfo);
91
92 /* Wait until the ETH cable is plugged in */
93 do {
94 ctlwizchip(CW_GET_PHYLINK, (void*) &phyLink);
95 osDelay(10);
96 } while(phyLink == PHY_LINK_OFF);
97
98 if(netInfo.dhcp == NETINFO_DHCP) { /* DHCP Mode */
99 DHCP_init(DHCP_SOCK, RX_BUF);
100
101 while(!runApplication) {
102 switch(DHCP_run()) {
103 case DHCP_IP_LEASED:
104 case DHCP_IP_ASSIGN:
105 case DHCP_IP_CHANGED:
106 getIPfromDHCP(netInfo.ip);
107 getGWfromDHCP(netInfo.gw);
108 getSNfromDHCP(netInfo.sn);
109 getDNSfromDHCP(netInfo.dns);
110 runApplication = 1;
111 break;
112 case DHCP_FAILED:
113 dhcpRetry++;
114 if(dhcpRetry > MAX_DHCP_RETRY)
115 {
116 netInfo.dhcp = NETINFO_STATIC;
117 DHCP_stop(); // if restart, recall DHCP_init()
118 #ifdef _MAIN_DEBUG_
119 printf(">> DHCP %d Failed\r\n", my_dhcp_retry);
120 Net_Conf();
121 Display_Net_Conf(); // print out static netinfo to serial
122 #endif
123 dhcpRetry = 0;
124 asm("BKPT #0");
125 }
126 break;
127 default:
128 break;
129 }
130 }
131 }
132 wizchip_setnetinfo(&netInfo);
133 }
The IO_LIBRARY_Init() function is responsible of the proper configuration of the W5500 IC. It starts
Develop IoT Applications 759
by configuring the functions used to exchange data over the SPI bus (lines [83:88], as seen in the
first example of this chapter). Next, at line 90, the function ReadNetCfgFromFile() is used to retrieve
network configuration from a file stored inside the SD card. This file is named net.cfg and it must
have the following structure:
1 NODHCP
2 0:11:22:33:44:55
3 192.168.1.165
4 255.255.255.0
5 192.168.1.1
6 8.8.8.8
Thefirstlinecanassumethevalues( NODHCP and DHCP )anditindicatesifthenetworkIPisconfigured
statically or dynamically. The second line corresponds to the MAC address, while the next four
lines correspond to the device IP, the subnet mask, the network gateway and the primary DNS.
By reading the content of this file the network interface is automatically configured. The user can
modify network parameter through a dedicated web page, as shown in Figure 8.
Once the network settings are retrieved from the configuration file, the IO_LIBRARY_Init() function
enters in an infinite loop until the LAN cable is plugged inside the RJ45 port (lines [93:96]). When
this happens, the function starts a DHCP discovery procedure if the network interface is configured
in DHCP mode. Finally, at line 132 the network interface is configured using settings stored inside
the net.cfg file or those ones retrieved by a DHCP server on the same network.
Figure 8: The web page used to setup network settings
The remaining of the application is essentially composed by the HTTP server. When a socket
establishes a connection with a remote peer, the httpServer_run() routine makes a call to the
http_process_handler() function, whichis responsible to process the incoming the HTTP requests.
Develop IoT Applications 760
This function starts analyzing the request’s HTTP method ( GET , POST , PUT and so on). Here we are
interested in the way the GET method is handled.
Filename: Middlewares/ioLibrary_Driver/Internet/httpServer/httpServer.c
531 case METHOD_GET :
532 get_http_uri_name(p_http_request->URI, uri_buf);
533 uri_name = uri_buf;
534
535 // If URI is "/", respond by index.html
536 if (!strcmp((char *)uri_name, "/")) strcpy((char *)uri_name, INITIAL_WEBPAGE);
537 if (!strcmp((char *)uri_name, "m")) strcpy((char *)uri_name, M_INITIAL_WEBPAGE);
538 if (!strcmp((char *)uri_name, "mobile")) strcpy((char *)uri_name, MOBILE_INITIAL_WEBPAGE);
539 // Checking requested file types (HTML, TEXT, GIF, JPEG and Etc. are included)
540 find_http_uri_type(&p_http_request->TYPE, uri_name);
541
542 #ifdef _HTTPSERVER_DEBUG_
543 printf("\r\n> HTTPSocket[%d] : HTTP Method GET\r\n", s);
544 printf("> HTTPSocket[%d] : Request Type = %d\r\n", s, p_http_request->TYPE);
545 printf("> HTTPSocket[%d] : Request URI = %s\r\n", s, uri_name);
546 #endif
547
548 if(p_http_request->TYPE == PTYPE_CGI)
549 {
550 content_found = http_get_cgi_handler(uri_name, pHTTP_TX, &file_len);
551 if(content_found && (file_len <= (DATA_BUF_SIZE-(strlen(RES_CGIHEAD_OK)+8))))
552 {
553 send_http_response_cgi(s, http_response, pHTTP_TX, (uint16_t)file_len);
554 }
555 else
556 {
557 send_http_response_header(s, PTYPE_CGI, 0, STATUS_NOT_FOUND);
558 }
559 }
560 else
561 {
562 // Find the User registered index for web content
563 if(find_userReg_webContent(uri_buf, &content_num, &file_len))
564 {
565 content_found = 1; // Web content found in code flash memory
566 content_addr = (uint32_t)content_num;
567 HTTPSock_Status[get_seqnum].storage_type = CODEFLASH;
568 }
569 // Not CGI request, Web content in 'SD card' or 'Data flash' requested
570 #if defined(_USE_SDCARD_) && !defined(OS_USE_SEMIHOSTING)
571 #ifdef _HTTPSERVER_DEBUG_
572 printf("\r\n> HTTPSocket[%d] : Searching the requested content\r\n", s);
573 #endif
Develop IoT Applications 761
574 if((fr = f_open(&HTTPSock_Status[get_seqnum].fs, (const char *)uri_name, FA_READ)) == 0)
575 {
576 content_found = 1; // file open succeed
577
578 file_len = f_size(&HTTPSock_Status[get_seqnum].fs);
579 HTTPSock_Status[get_seqnum].file_len = file_len;
580 strcpy(HTTPSock_Status[get_seqnum].file_name, uri_name);
581 HTTPSock_Status[get_seqnum].storage_type = SDCARD;
582 }
583 #elif defined(OS_USE_SEMIHOSTING)
584 // Not CGI request, Web content retrieved through ARM Semihosting
585 char *base_path = OS_BASE_FS_PATH;
586 char *path;
587
588 path = malloc(sizeof(char)*strlen(base_path)+strlen(uri_name));
589 strcpy(path, base_path);
590 strcpy(path+strlen(base_path), uri_name);
591
592 HTTPSock_Status[get_seqnum].fs = fopen((const char *)path,"r");
593 if(HTTPSock_Status[get_seqnum].fs != NULL) {
594 content_found = 1; // file open succeed
595
596 fseek(HTTPSock_Status[get_seqnum].fs, 0L, SEEK_END);
597 file_len = ftell(HTTPSock_Status[get_seqnum].fs);
598 HTTPSock_Status[get_seqnum].file_len = file_len;
599 fseek(HTTPSock_Status[get_seqnum].fs, 0L, SEEK_SET);
600 strcpy(HTTPSock_Status[get_seqnum].file_name, uri_name);
601 HTTPSock_Status[get_seqnum].storage_type = SDCARD;
602 }
603 }
The get_http_uri_name() function at line 532 retrieve the URL requested by the client application.
If this URL is only equal to "/" , then it means that the browser is requesting the default URL,
which corresponds to the index.html file. The call to the function find_http_uri_type() at line 541
determines the Content-Type associated to the requested URL. The Content-Type is derived from
the file extension. For example, the Content-Type of a file ending with .gif is set to PTYPE_GIF .
If the Content-Type is CGI²⁸ (line 549), then a call to the http_get_cgi_handler() function
determines the generation of the dynamic content. We will analyze how this function is struc-
tured later. For all the other registered Content-Types (give a look at the find_http_uri_type()
implementation for the complete list), the http_process_handler() function starts looking for the
requested resource (line 561). First of all, the function checks if the content has been registered using
the reg_httpServer_webContent() function. If so, the content is automatically retrieved from the
²⁸ The Common Gateway Interface (CGI) is a standardized protocol used to interface “server apllications” that processes requests coming
from clients dynamically. Historically, CGIs were introduced to generate web content dynamically. Nowadays, this form of server processing
in web applications has been superseded by a multitude of web frameworks, built using dynamic and more powerful scripting languages like
PHP, Python and Ruby.
Develop IoT Applications 762
flash memory and sent to the browser. If the content is not stored in the MCU flash memory and
the _USE_SDCARD_ macro is set, then the function checks if the requested content is stored inside the
MicroSD card (lines [575:584]). FatFs APIs are used to access the requested file. If, instead, the ARM
semihosting is enabled, then standard C routines are used to retrieve the file from the developer’s
PC (lines [586:605]).
The http_get_cgi_handler() function has the responsibility to generate dynamic content of the
web application (for example, data sampled by the ADC peripheral). The function is coded so that it
requests access to the /adc.cgi and /network.cgi dynamic pages. Let us start from the second one.
Filename: Middlewares/ioLibrary_Driver/Internet/httpServer/httpUtil.c
22 extern ADC_HandleTypeDef hadc1;
23 extern uint16_t adcConv[100], _adcConv[200];
24 extern TIM_HandleTypeDef htim2;
25 extern osSemaphoreId adcSemID;
26
27 uint8_t http_get_cgi_handler(uint8_t * uri_name, uint8_t * buf, uint32_t * file_len)
28 {
29 uint8_t ret = HTTP_FAILED;
30 uint16_t len = 0;
31
32 if(strcmp((const char*)uri_name, "adc.cgi") == 0) {
33 char *pbuf = (char*)buf;
34
35 /* Compute the current TIM2 frequency */
36 uint32_t freq = HAL_RCC_GetPCLK2Freq() / (((htim2.Init.Prescaler + 1) *
37 (htim2.Init.Period + 1)));
38 pbuf += sprintf(pbuf, "{\"f\":%lu,\"d\":[", freq);
39
40 /* Wait until the HAL_ADC_ConvCpltCallback() or
41 HAL_ADC_HalfConvCpltCallback() finish */
42 osSemaphoreWait(adcSemID, osWaitForever);
43 for(uint8_t i = 0; i < 100; i++)
44 pbuf += sprintf(pbuf, "%.2f,", adcConv[i]*0.805);
45 osSemaphoreRelease(adcSemID);
46
47 sprintf(--pbuf, "]}");
48 *file_len = strlen((char*)buf);
49
50 return HTTP_OK;
51
52 } else if(strcmp((const char*)uri_name, "network.cgi") == 0) {
53 wiz_NetInfo ni;
54 wizchip_getnetinfo(&ni);
55 sprintf((char*)buf, "{\"ip\":\"%d.%d.%d.%d\","
56 "\"nm\":\"%d.%d.%d.%d\","
57 "\"gw\":\"%d.%d.%d.%d\","
Develop IoT Applications 763
58 "\"dns\":\"%d.%d.%d.%d\","
59 "\"dhcp\":\"%d\"}", ni.ip[0], ni.ip[1], ni.ip[2], ni.ip[3],
60 ni.sn[0], ni.sn[1], ni.sn[2], ni.sn[3],
61 ni.gw[0], ni.gw[1], ni.gw[2], ni.gw[3],
62 ni.dns[0], ni.dns[1], ni.dns[2], ni.dns[3],
63 ni.dhcp);
64 *file_len = strlen((char*)buf);
65 return HTTP_OK;
66 }
67
68 if(ret) *file_len = len;
The network.cgi page does a simple thing: it returns the current network settings to the /net-
work.html page, which in turn makes an AJAX call to the /network.cgi page. Just to be sure that
all readers understand this matter, assuming that your Nucleo is reachable at the 192.168.1.165 IP
address, then going to the URL http://192.168.1.165/network.cgi²⁹ in your web browser will give you
the following result:
{"ip":"192.168.1.165","nm":"255.255.255.0","gw":"192.168.1.1","dns":"8.8.8.8","dhcp":"1"}
ThiscorrespondstothenetworksettingsreturnedinJSONformat.Whenthebrowseraccessestothe
/adc.cgi dynamic page, the application returns the current TIM2 frequency and the ADC sampled
data in JSON format. Lines [32:52] are responsible of this operation. The function http_get_cgi_-
handler() starts deriving the timer frequency at line 36. This information will be used by the web
application to plot the data on the graph. Lines [42:45] represents the “tricky part” of the function.
The ADC conversion is performed in DMA circular mode. The conversion so goes on its own,
and this operation is driven by the TIM2 timer. If the timer runs really fast, the access to
the _adcConv[] array could lead to a race condition: its content could be modified while the
http_get_cgi_handler() converts it in string at line 44. The application is so organized in this way:
half of the content of the _adcConv[] array is copied inside the adcConv[] array when HAL_ADC_-
ConvHalfCpltCallback() and HAL_ADC_ConvCpltCallback() routines are invoked, as shown below.
Filename: src/ch25/main-ex2.c
259 void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc) {
260 UNUSED(hadc);
261
262 if(osSemaphoreWait(adcSemID, 0) == osOK) {
263 memcpy(adcConv, _adcConv, sizeof(uint16_t)*100);
264 osSemaphoreRelease(adcSemID);
265 }
266 }
267
²⁹ http://192.168.1.165/network.cgi
Develop IoT Applications 764
268 void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
269 UNUSED(hadc);
270
271 if(osSemaphoreWait(adcSemID, 0) == osOK) {
272 memcpy(adcConv, _adcConv+100, sizeof(uint16_t)*100);
273 osSemaphoreRelease(adcSemID);
274 }
275 }
When the HAL_ADC_ConvHalfCpltCallback() function is invoked, one hundred values have been
stored inside the _adcConv[] array: we so copy the first half-part inside the adcConv[] array, which
has a size of 100. When the other callback is called, we copy the second half. Before the two callback
routines copy the content of the _adcConv[] array they try to acquire the semaphore adcSem . If
available,theyperformthecopy,otherwisethismeansthatthe http_get_cgi_handler() hasalready
acquired it and it is performing the conversion of the adcConv[] array. This solution prevents the
generation of race conditions, even if it is not the fastest one.
The function http_get_cgi_handler() handles all GET requests to CGI scripts. Similarly, the
function http_post_cgi_handler() handles all POST requests to CGI scripts.
Filename: Middlewares/ioLibrary_Driver/Internet/httpServer/httpUtil.c
72 uint8_t http_post_cgi_handler(uint8_t * uri_name, st_http_request * p_http_request, uint8_t * \
73 buf, uint32_t * file_len)
74 {
75 uint8_t ret = HTTP_OK;
76 uint16_t len = 0;
77 uint8_t *param = p_http_request->URI;
78
79 if(strcmp((const char *)uri_name, "sf.cgi") == 0) {
80 param = get_http_param_value((char*)p_http_request->URI, "f");
81 if(param != p_http_request->URI) {
82 /* User wants to change ADC sampling frequency. We so stop conversion */
83 HAL_ADC_Stop_DMA(&hadc1);
84 HAL_TIM_Base_Stop(&htim2);
85
86 /* Obtain the current TIM2 frequency */
87 uint32_t cfreq = HAL_RCC_GetPCLK2Freq() / (((htim2.Init.Prescaler + 1) *
88 (htim2.Init.Period + 1))), nfreq = 0;
89
90 if(*param == '1')
91 nfreq = cfreq * 2;
92 else
93 nfreq = cfreq / 2;
94
95 htim2.Init.Prescaler = 0;
96 htim2.Init.Period = 1;
Develop IoT Applications 765
97 /* We cycle until we reach the wanted frequency. At frequencies below 30Hz,
98 this algorithm is largely inefficient */
99 while(1) {
100 cfreq = HAL_RCC_GetPCLK2Freq() / (((htim2.Init.Prescaler + 1) *
101 (htim2.Init.Period + 1)));
102 if (nfreq < cfreq) {
103 if(++htim2.Init.Period == 0) {
104 htim2.Init.Prescaler++;
105 htim2.Init.Period++;
106 }
107 } else {
108 break;
109 }
110 }
111 HAL_TIM_Base_Init(&htim2);
112 HAL_TIM_Base_Start(&htim2);
113 HAL_ADC_Start_DMA(&hadc1, (uint32_t*)_adcConv, 200);
114
115 sprintf((char*)buf, "OK");
116 len = strlen((char*)buf);
117 }
118
119 }
120 else if(strcmp((const char *)uri_name, "network.cgi") == 0) {
121 wiz_NetInfo netInfo;
122 wizchip_getnetinfo(&netInfo);
123
124 param = get_http_param_value((char*)p_http_request->URI, "dhcp");
125 if(param != 0) {
126 netInfo.dhcp = NETINFO_DHCP;
127 } else {
128 netInfo.dhcp = NETINFO_STATIC;
129
130 param = get_http_param_value((char*)p_http_request->URI, "ip");
131 if(param != 0)
132 inet_addr_((u_char*)param, netInfo.ip);
133 else
134 return HTTP_FAILED;
135
136 param = get_http_param_value((char*)p_http_request->URI, "sn");
137 if(param != 0)
138 inet_addr_((u_char*)param, netInfo.sn);
139 else
140 return HTTP_FAILED;
141
142 param = get_http_param_value((char*)p_http_request->URI, "gw");
143 if(param != 0)
Develop IoT Applications 766
144 inet_addr_((u_char*)param, netInfo.gw);
145 else
146 return HTTP_FAILED;
147
148 param = get_http_param_value((char*)p_http_request->URI, "dns");
149 if(param != 0)
150 inet_addr_((u_char*)param, netInfo.dns);
151 else
152 return HTTP_FAILED;
153 }
154 if(!WriteNetCfgInFile(&netInfo))
155 sprintf((char*)buf, "FAILED");
156 else
157 sprintf((char*)buf, "OK");
158
159 /* Change network parameters */
160 wizchip_setnetinfo(&netInfo);
161 len = strlen((char*)buf);
162 }
163
164 if(ret) *file_len = len;
This function is coded to serve two dynamic pages: /sf.cgi and /network.cgi . The second one
handles the processing of the HTML form when the user changes network settings (take a look at
the network.html file). The /sf.cgi page, instead, handles the change of the TIM2 frequency. When
the user presses on the “zoom in/zoom out” icons, the browser performs a request to the /sf.cgi
page, by passing the value 1 to increase the frequency, 0 to decrease it.
The remaining of our example application is all about HTML, CSS and JavaScript. The files
index.html and network.html contain all the necessary code to plot the graph using D3js library
and to show and change the network settings.
To use this example, you can simply copy the content of the src/ch25/webpages subdirectory on
an SD card. Alternatively, you can use the ARM semihosting once the macro OS_BASE_FS_PATH has
been set with the full path to the src/ch25/webpages on your PC filesystem. For example, if you
are on Windows, the OS_BASE_FS_PATH could be set to the C:/STM32Toolchain/projects/nucleo-
f401RE/src/ch25/webpages path.
27. Getting Started With a New Design
If you use STM32 microcontrollers for work, or you are going to create your latest funny project
as a hobbyist, soon or later you will need to leave a development kit like the Nucleo, and you have
to design a custom board around a given STM32 MCU. For every hardware engineer this is always
an exciting process. You start from an idea, or a list of requirements, and you will obtain a piece of
hardware able to do magic things.
Thedevelopmentprocessofanewboardcanbedividedintwomainsteps:thehardwaredesignpart,
related to components selection and placement, and the software development part, that consists in
a starting configuration and all the code needed to make the board working. This chapter aims to
provide a brief introduction to this topic. The chapter is logically divided in two parts: one related
to the hardware design and one to software. Even if you are one of those lucky people working
in companies where the hardware engineer is a separated figure from the firmware developer, it is
strongly suggested to have a look at this chapter, which is essentially based on the hardware design.
Otherwise, if you are the classical one man band¹, reading this chapter at least once could help you
if you are totally new to the STM32 world.
27.1 Hardware Design
If you come from simpler microcontroller architectures, like the ATMEL AVR ATMega328p used for
the Arduino UNO, you may be familiar with some “artistic things” that often appear on the web
(Figure 1 is an example²). A lot of projects arise from a breadboard, few passives and several tons
of wires. And they work great too.
However, if you are going to make a new board with an STM32 MCU, you have to completely forget
this kind of design. This is because not only do not exist STM32 microcontrollers provided in a THT
package. These MCUs require that special attention must be placed to the PCB layout process, even
for the low-cost line STM32F030. The PCB design become really critical if you are planning to use
the fastest STM32 MCUs, like the F4 and F7 series, in conjunction with external devices like fast
QSPI memories and external SDRAM.
¹ Like this author is :-)
² The picture was taken from this site(https://degreesplato.wordpress.com)
Getting Started With a New Design 768
Figure 1: A creative “thing” made with an ATMega328 plus 1 mile of wires
For each STM32 family, ST provides a dedicated datasheet named “Getting started with STM32xx
hardware development”. For example, for the STM32F4 family, the AN4488³ is the corresponding
document. It is strongly suggested to read carefully these documents, since they contain the most
important information to design a new PCB correctly. For all my designs based on these MCUs, I
have always followed the information provided by ST engineers, and I have never had any issues.
The next paragraphs summarize the most important aspects and decision steps, according to me, to
follow during the design process of a new board based on an STM32 MCU.
27.1.1 PCB Layer Stack-Up
Every time you start a new design based on a microcontroller, you need to decide which PCB
technology best fits your design and BOM cost, keeping in mind this important axiom: the faster
your board goes, the more PCB layers are required. And this also true for STM32 MCUs. Even if it is
not rare to see some low-cost 8-bit MCUs soldered on a single layer CEM PCB⁴, for an STM32 MCU
a 2-layers board is the minimum requirement. But, if you are planning to use the fastest versions
of the STM32F4 series (like the STM32F446 MCU able to run up to 180MHz) or the latest STM32F7,
then you have to consider a 4-layers PCB as minimum requirement⁵.
Multi-layers PCBs have several advantages compared to 2-layers ones:
• More layers simplify the routing process, and this is really important if you have space
constraints or if you need to route differential pair nets.
• They allow better routing for power as well as ground connections; if the power is also on a
plane, it is available to all points in the circuit simply by adding vias.
³ http://bit.ly/1NVb6ly
⁴ This especially true for low-cost productions.
⁵ Consider that the STM32F746-Discovery KIT is made with an eight layers PCB.
Getting Started With a New Design 769
• They provide an intrinsic distributed capacitance between the power and ground planes,
reducing high-frequency noise especially if your board relies on an external SRAM or a fast
flash.
• For the same reason as before, they allow to significantly reduce EMI/RFI emissions, simplify-
ing the development cost and the CE/FCC certification phase.
However,4-layersPCBshaveareallyhighercostcomparedto2-layersones,andthiscostisoftennot
affordable for some low-cost and higher volumes productions. Moreover, it is right to say that the
Cortex-Mportfolio(andhencetheSTM32one)rangesfrom“low-cost”solutionsabletoruncorrectly
on 2-layers boards to more powerful MCUs really close to general purpose microprocessors (like the
Cortex-M7 series), which demand a more advanced PCB stackup.
My personal experience is based on PCB designed with STM32F030 and STM32F401 MCUs, both
implemented with 2-layers PCBs, and I had no significantly issues during the boards testing. Using
ground-planes on both layers allow to simplify the routing process and to reduce overall EMI
emissions of the board.
27.1.2 MCU Package
The MCU package choice is often related to the whole PCB technology. STM32 MCUs are provided
in several package variants (take a look at the final appendix to see the list of available packages).
The most common and “simple to use” packages are the LQFP ones, like the LQFP-64 package used
for all Nucleo boards. Packages with exposed pins have several advantages:
• They are easy to solder, even by hand for really low-volume productions or for prototypes.
With a little bit of practice, they can be soldered with the drag soldering technique⁶, or simply
placed on a PCB pre-covered with the solder paste using a stencil.
• They are easy to inspect using conventionalAutomatic Optical Inspection (AOI) machines, and
they do not require x-ray inspection, which increases the production cost of your boards.
• They cost less for low and mid-volume productions, compared to other type of packages.
• They can be used on 2-layers low class PCBs (even a pattern class equal to 6 is sufficient⁷),
different from other packages (like the BGA ones) that usually require more advanced PCB
due the use of vias with a really reduced annular ring.
• They provide a lot of signal I/O to interface external peripherals (this is obviously, but it is
always good to remark it).
However, if space is a strict requirement for your design, then you have to consider BGA and similar
packages, which offer more signal I/O in a smaller footprint.
⁶ Youtube is full of videos that show how to solder SMD packages with this technique.
⁷ Take a look at this document(http://bit.ly/1NVgYeI) from Eurocircuits to discover more about PCB production classes.
Getting Started With a New Design 770
27.1.3 Decoupling of Power-Supply Pins
A really important design step is the decoupling of every power supply pair (VDD, VSS). The key
aspects can be summarized here:
• Each power couple (VDD, VSS) should be connected to a parallel ceramic capacitor of about
100nF (which is a widespread proven value) plus one 4.7uF ceramic capacitor for the overall
MCU. It is best to choose 0805 or smaller capacitors (the smaller is the better is, since smaller
capacitors have less ESR - for an STM32F7, 0402 capacitors is an option to consider). These
capacitors need to be placed as close as possible to the appropriate pins, or the underside of the
PCB if a BGA package is used for the fastest STM32 MCUs. If a ground plane is used, it is safe
to connect VSS pins directly to the ground plane if this is extensive in the area of that pin.
• This author also uses a large electrolytic capacitor (typically 10 uF - a tantalum capacitor is
also OK if your budget allows it) no more than 3cm away from the chip. The purpose of this
capacitor is to be a reservoir of charge to supply the instantaneous charge requirements of the
circuits locally so the charge need not come through the inductance of the power trace.
• A small ferrite bead (with an impedance ranging from 600 to 1000Ω) placed in series between
the analog power supply (AVDD) and digital power supply (VDD)⁸. It is used to:
– Localizes the noise in the system.
– Keeps external high frequency noise from the IC.
– Keeps internally generated noise from propagating to the rest of the system.
• If your STM32 MCU provides a VBAT pin, it can be connected to the external battery (1.65 V
< VBAT < 3.6 V). If no external battery is used, it is recommended to connect this pin to VDD
with a 100nF external ceramic decoupling capacitor.
Figure2showsthereferenceschematicsofanSTM32F030CCMCU,whileFigure3showsthetypical
layout style used by this author to proper decouple power pins. As you can see, a solid ground plane
ensures that decoupling capacitors are connected to the ground with the shortest possible path⁹.
This document¹⁰ from Texas Instruments is a good introduction to this topic.
⁸ ST discourages the use of this ferrite if VDD is below 1.8V.
⁹ However,keepinmindthatthegroundingschemedependsontheactualimplementation.Somedesignsneedastrongseparationbetween
analog and digital ground, plus some EMC-friendly devices (like ferrite beads) to connect them. Welcome to the “obscure” world of EMC :-)
¹⁰ http://bit.ly/29pk0J9
Getting Started With a New Design 771
Figure 2: The minimal reference schematics for an STM32F030 MCU
Figure 3: The preferred way by the author of this book to place decoupling capacitors
Getting Started With a New Design 772
27.1.4 Clocks
If your design needs an external clock source, either the LSE or HSE one, special attention must be
placedtothepositionoftheexternalcrystalandtheselectionofthecapacitorsusedtomatchitsload
capacitance (this value is established by the crystal manufacturer, and it must be carefully checked
during the selection process).
ST provides a really excellent guide (AN2867¹¹) about oscillator design. Summarizing that guide is
outside the scope of this paragraph, so I strongly suggest to have a look at that application note.
However, it is important to underline some things.
The most starting up errors (that is, the MCU does not want to properly boot in our final design
when the external crystal is used) arises from bad choice of the external capacitors and bad placing
of the crystal. For example, assuming a stray capacitance equal to 5pF and a crystal capacitance
equal to 15pF, the following formula can be used to compute the value of external capacitors:
C 1,2 = 2( C L - C stray ) = 2(15pF - 5pF) = 20pF.
Moreover, it is best to place the crystal as close as possible to the MCU pins, surrounding it by a
separated ground plane, in turn connected to the bottom ground plane, as shown in Figure 4 (the
bottom ground plane is not shown).
ST shows several “bad examples” in its Application Note. Moreover, all STM32 MCUs provide a
really useful feature to debug external oscillator issues: the Clock Security System (CSS). CSS is a
self-diagnostic peripheral that detects the failure of the HSE. If this happens, HSE is automatically
disabled (this means that the internal HSI is automatically enabled) and a NMI interrupt is raised
to inform the software that something is wrong with the HSE. So, if your board refuses to work
correctly, I strongly suggest you to write down the exception handler for NMI, as described in
Chapter 10. If the code hangs inside it, then there is a problem with your oscillator design.
Finally, consider that a lot of EMC issues come from bad placing of external clocks. Pay attention to
the instructions contained in the ST application note.
The most of STM32 MCUs allow to connect an external or internal clock source (a PLL, the
HSI or HSE and so on) to an output pin, called Master Clock Output(MCO). This is useful in
some application, where this clock source may be used to drive an external IC or in audio
applications. However, pay attention to avoid long traces between the MCU and the device
connected to the MCO pin. In this case you have to consider the MCU like a normal clock
source, and hence you have to pay attention both to the length of the trace and to cross-talks
between MCO and other adjacent or underlying traces.
¹¹ http://bit.ly/1RFYZbZ
Getting Started With a New Design 773
Figure 4: A good design way to place external crystals using a separated ground plane
27.1.5 Filtering of RESET Pin
Toavoidunwantedresetofyourboard,itisstronglyrecommendedtoconnectadecouplingcapacitor
(100nF is a proven value) between the RESET pin (named NRST ) and the ground, even if your design
does not require the use of the reset pin.
27.1.6 Debug Port
In order to develop and test the firmware for the new board, or to simply upload it to production
devices, you need a way to interact with the target STM32 MCU using its debug port. STM32 MCUs
offer several ways to debug them. One of this is through the use of the Serial Wire Debug (SWD)
interface. SWD replaces the traditional JTAG port, using a clock line (named SWDCLK ) and a single bi-
directionaldatapin(named SWDIO ¹²),providingallthenormalJTAGdebugandtestfunctionalityplus
real-time access to system memory without halting the processor or requiring any target resident
code (the condition for this to happen is that the SWD related I/O are not remapped to a different
function-e.g.ageneralpurposeoutputGPIO).Moreover,itispossibletouseanyST-LINKdebugger
as debug device for your custom boards: all ST development boards (and, hence, the Nucleo too) are
¹² Sometimes, ST refers to these lines also as SWCLK and SWIO .
Getting Started With a New Design 774
designed so that you can disconnect the target MCU from the ST-LINK interface and connect it to
your board.
Figure 5: How to use the Nucleo as ST-LINK debugger
Figure 5 shows how to use a Nucleo as external debugger for a custom board. First, remove the two
jumpers from the CN2 pin header. Next, connect the PIN1 of SWD pin header to a VDD (3.3V or
lower) source of your custom board, PIN2 to the SWDCLK pin of the STM32 MCU in your board, PIN3
to the GND, PIN4 to SWDIO pin and finally the PIN5 to the NRST pin of the target STM32 MCU (this
step is optional, at least in theory). The connection may be easily done simply routing those signals
to a convenient pin header, which plays the role of debug port for your custom board. The SWO pin is
also available on the SWD pin header, and it corresponds to the PIN6. However, the SWO is connected
to the target MCU through a SMD jumper (SB15). So, if you want to use SWV functionality on you
board, you will need to desolder that jumper.
Another useful feature to have on this debug port may be at least the USART TX pin of one of the
available MCU USARTs. This could help you a lot during the development process, using it to print
messages on a console to trace the firmware execution, even if it is not under debugging. Again, you
could use the Nucleo board to interface the target MCU TTL USART to the Nucleo VCP, connecting
USART pins to the CN3 connector on the Nucleo board, as shown in Figure 6. If so, you may need
to desolder SB13 and SB13 jumper on your Nucleo, or leave PA2 and PA3 of the target Nucleo MCU
floating.
Getting Started With a New Design 775
Figure 6: The CN3 connector allow to use the ST-LINK VCP with any other USART
Read Carefully
Assaidbefore,theSWDinterfacerequiresjusttwopins.Thesearenamed SWDIO and SWDCLK .
You can easily identify them using CubeMX (more about this later), or downloading the
right datasheet for your MCU. However, it is strongly suggested to use also the NRST pin
for debugging. This is required because the STM32 microcontrollers allow to change the
function of SWD pins, both for wanted design reason and for an invalid firmware state after
a fault condition (e.g. a an invalid memory access has corrupted the peripheral memory).
Without routing the NRST signal to the debug port, it is impossible to connect to the target
MCU “under reset”, that is resetting the MCU just few CPU cycles before the MCU is placed
under debug. This will really help you in some critical situations. So, to resume, always
route to the custom “debug connector” on your board at least SWDIO , SWDCLK and NRST
pins, plus VDD and GND.
27.1.7 Boot Mode
Depending on the specific microcontroller model you are going to use in your design, STM32 MCUs
can load firmware from different sources: internal or external flash, internal or external SDRAM,
USART and USB are the most common sources for starting the firmware execution. This is a really
exciting feature of this platform described in Chapter 22.
This happens thanks to the fact that several boot loaders are pre-programmed in theSystem memory
(the sub-region of code area starting from 0x1FFF F000 ) during the MCU production. Each boot
loader can be selected configuring one or two pins named BOOT0 and BOOT1 ¹³.
The default behaviour, that is the regular boot from the internal flash, is obtained pulling to the
ground at least BOOT0 pin and leaving BOOT1 pin (if present) floating. Once the firmware starts
the execution, you can reuse BOOT pins as general I/O.
¹³ The actual implementation of these pins depends on the specific STM32 series. For example, the STM32F030 provides only BOOT0 pin, and
substitutes the BOOT1 pin with a specific bit inside the Option Bytes memory region.
Getting Started With a New Design 776
27.1.8 Pay attention to “pin-to-pin” Compatibility…
A lot of STM32 microcontrollers are designed to be pin-to-pin compatible with other MCUs in
the same series and between different series. This allows you to “simply” switch to a more/less
performant model in case you need to adapt your design for budget reasons or if you are looking
for a more powerful MCU.
However,thepin-to-pincompatibilityisafeaturethatneedstobeplannedduringtheMCUselection
process, evenfor MCUs belonging to the same STM32 series. Let us consider this example¹⁴. Suppose
that you decide to use an STM32 MCU from the STM32F030 catalogue, and suppose that you choose
the STM32F030R8 MCU, the one equipping the STM32F030 Nucleo. As soon as the board design is
finished, and gerber files are sent to the PCB fab, you start developing the firmware (this is what
often happens especially if you have to complete the project one day before you start developing
it). After a while, you discover that the 8k of SRAM provided by this MCU are not sufficient for
your project. So, you decide to switch to the STM32F030RC model, which provides 32K of SRAM
and 256K of internal flash. However, after struggling several hours trying to understand why you
cannot flash it, you discover that this model requires four additional power sources (PF4, PF5, PF6
and PF7), as you can see in Figure 7.
Figure 7: The STM32F030RC MCU requires four additional power sources compared to the STM32F030R8 one
So, how to avoid these kind of mistakes? The best option is to plan for the worst case. In this specific
case you may do a layout of your board that connects those pins (PF4, PF5, PF6 and PF7) to power
sources even if you are going to use the STM32F030R8 model (being those pins regular I/O pins, it
is ok to connect them to VDD and VSS, in parallel with decoupling capacitors).
¹⁴ This film is based on a true and sad story happened to this author :-)
Getting Started With a New Design 777
27.1.9 …And to Selecting the Right Peripherals
The most of STM32 MCUs have multiple peripherals of a given type (SPI1, SPI2, etc.). This is a
good thing for complex designs with multiple modules, but special care must be placed during the
peripheral selection even for simple designs. And this is not only a problem related to the I/Os
allocation. For example, suppose that you are basing your design on an STM32F030 MCU, and
suppose that your design needs an UART and a SPI interface. You decide to use UART1 and SPI2
peripherals. During the firmware development, for performance reasons you decide to use both of
them in DMA mode. However, looking to Table 1 in Chapter 9 you can see that it is not allowed to
use SPI2_TX and USART1_RX in DMA mode simultaneously (they share the same channel). So, it is
best to plan these software design choices while you are writing down the schematics.
If you are designing a device that will enter deeper sleep modes, like the standby one, and you want
your device to be woken up by the user (maybe by pressing a dedicated button), then remember
that usually just two I/Os can be used to this task (they are called wake up pins). So, avoid to assign
those pins to other usages.
27.1.10 The Role of CubeMX During the Board Design Stage
It happens really often to me to talk with people about CubeMX. A lot of them have a wrong
consideration of what CubeMX is. Some of them consider it as a totally useless tool. Others limit its
usage to the software development stage. There is nothing more wrong.
CubeMX is probably more useful during the hardware design process (both when drawing schemat-
ics and when doing board layout) than in the firmware development stage. Once you get familiar
with the CubeHAL, you will stop to use CubeMX as a tool for the IDE project generation¹⁵. But
CubeMX is essential during the design stage, unless you are going to reuse previous designs or to
base your projects always on few types of STM32 MCUs.
The most important part of CubeMX during the board design is the Chip view. Thanks to this
representation you can “preview” in your mind the layout of the MCU part, and eventually adopt
different layout strategies.
CubeMX is a tool that can be used iteratively. Let us me explain this concept better with an example.
Suppose that you need to design a board based on an STM32F030C8Tx MCU. It is an LQFP-48 MCU
from the F0 line. Suppose also that you need to use:
• Two SPI interfaces (SPI1 and SPI2).
• An I²C interface (I2C1).
• An external low speed clock source (LSE).
• Five GPIOs.
• An UART (UART2).
¹⁵ Honestly speaking, what CubeMX generates is not so good from a project organization point of view.
Getting Started With a New Design 778
Once you have started a new project with this MCU, CubeMX shows you the MCU representation
in the Chip view, as shown below.
Figure 8: CubeMX shows a graphical representation of the MCU when a new project is started
This immediately gives you three facts:
• You can quickly derive that your board will need 6 decoupling capacitors, 5 for the power
sources (4x100nF + 1x4.7uF) and 1x100nF for the NRST pin.
• PIN7 is the NRST pin and it must be decoupled.
• PIN44 is the BOOT0 pin and it must be pulled-down.
Read Carefully
Never forget to tie to the ground the BOOT0 pin using a pull-down resistor (this reduce
the power leakage). It is a really common mistake for novices of this platform to leave that
pin unconnected, or worst connecting it to a voltage source. STM32 hardware designers are
divided in two groups: those that have forgotten to tie BOOT0 to the ground and those that
will forget to do it.
The next step involves enabling all the required peripherals, the LSE and the SWD interface, leaving
out the 5 GPIOs for the moment. We obtaining the following representation in CubeMX:
Getting Started With a New Design 779
Figure 9: How CubeMX shows you the MCU when new peripherals are enabled
Ok.Nowitisthegoodtimetostartwritingdowntheboardschematics,connectingtheotherdevices
totheMCUpins.Onceyouhavecompletedthispartoftheschematics,youcanstartdoingthelayout
process. In this phase, you discover that it is not simple to route the SPI1 signals to PA5, PA6 and
PA7. So, doing a Ctrl+Click on the SPI1 signals you discover that you can remap them to PB3, PB4
and PB5, obtaining the following representation:
Figure 10: Pre-visualizing the MCU can help you during board layout
Now you can update your schematics and hence complete the layout of this part. Once the layout
is almost complete, you can assign the 5 GPIO to the MCU pins, deciding which one best fits your
layout. This is the reason why CubeMX can be used iteratively.
Getting Started With a New Design 780
Another important thing regarding CubeMX is the ability to give custom names to signals. This is
simply accomplished going into Pinout->Pins/Signal Options. CubeMX will use the custom labels
to generate corresponding C macros inside the main.h file. For example, an I/O labeled “TX_EN”
will generate a macro named TX_EN_Pin to indicate the pin and a macro named TX_EN_GPIO_Port to
indicate the corresponding GPIO port. This is really important especially if you keep synchronized
the CAD documentation and the project source files. It will help you to write better and more
portable code.
Finally, I prefer to prefix the name of all high-speed signals with “HS_”. This will guide you during
the design process: if your CAD allows you to place constraints on nets, it will simplify the routing
process, avoiding mistakes that would appear only during test phase.
27.1.11 Board Layout Strategies
The layout of the final board is a sort of “art”, a complex task that involves a deep knowledge of all
modulesusedinyourdesign.Thisisthereasonwhyinlargeorganizationsthisworkisaccomplished
by specific engineers.
Here, I would like to provide a brief introduction to the whole process based on my personal
experience.
• A good layout is all about component placing: if you are new to this task, remember that all
starts from placing components on the final board. Every board can logically and physically
divided in sub-modules: power part, MCU and digital part, analog part and so no. Don’t start
routing signals before you have placed all components on the final board. Moreover, a good
subdivision in sub-modules allows you to reuse design for different boards.
• Follow these steps when doing the layout of an STM32 MCU:
– start placing the MCU;
– if your board need external clock sources, place them immediately close to the MCU pins;
– next place all decoupling capacitors needed;
– connect power sources to the corresponding power lines or power planes if your layer
stackup allows them;
– never forget to tie to the ground BOOT0 pin if needed, and to decouple NRST pin;
– ifyourdesignneedanexternalSRAMorafastflashmemory,startplacingthemandroute
differential pair first;
– route all high speed signals;
– route remaining signals;
– avoid to use too many vias during the signal routing and use CubeMX looking for better
alternatives (that is, use other equivalent signal I/Os if possible).
Getting Started With a New Design 781
27.2 Software Design
Once you have completed the hardware design, you can start developing the firmware part. If you
have used CubeMX to design the MCU section of your custom board, you should be able to start
coding the firmware really quickly. If the CubeMX project observes faithfully the actual board
design, you can simply generate the project as we have done for the Nucleo development board,
then you can import it inside a new Eclipse project and start working on your application. Nothing
different from what described in Chapter 4.
If you have already developed the firmware using a development board, and you need to adapt it to
your custom design, you may proceed in this way:
• GenerateafreshnewCubeMXprojectbothforyourdevelopmentboard(e.g.theNucleo-F030),
enabling the needed peripherals, and for the custom board you have designed.
• Doacomparisonbetweentheinitializationroutinesfortheusedperipherals:iftheydiffer,start
replacing them one by one in the project made for the development board, and do a complete
project compilation before to continue with the next peripheral. This will allow you to keep
the control of what is changing in your firmware.
• To simplify the porting process, never change the peripheral initialization code generated by
CubeMX, but use CubeMX to change peripheral settings.
• Try to use macros to wrap peripheral handlers. Once you change them, you only need to
redefinethemacros(forexample,ifyourfirmwaredevelopedwiththeNucleousestheUSART2
peripheral, define a global macro in this way: #define USART_PERIPHERAL huart2 and base
your code on that macro; if your new design uses the USART1, then you have to redefine only
that macro accordingly).
Remember that CubeMX essentially generates 5 or 6 files. If you reduce the modification to these
files at minimum, it will be easy to rearrange the code.
Having a minimum viable firmware made with a development kit helps a lot during the debugging
of your custom board. It happens really often that, during the testing of a new board, you are in
doubt if your issues arise from the hardware or the software. Knowing that the firmware works
simplifies the hardware debugging stage.
27.2.1 Generating the binary image for production
In large organizations, who effectively loads the binary image of the firmware on the final board is
a completely different person. As as engineer, you may be asked to generate an image of the final
firmware in release mode. This is a way to indicate a binary image of the firmware compiled with
the highest possible optimization level, in order to reduce the final size of the image, and without
including any debug information. This last requirement is needed both to reduce the size of binary
image and to protect the intellectual property (the ELF file of a firmware compiled with debug
Getting Started With a New Design 782
symbols usually contains the whole firmware source code, so that GDB can show you the original
source code while debugging).
FromtheEclipse/GCCpointofview,generatingabinaryimageinreleasemode isnothingmorethan
to configure the project accordingly. You might have already noticed that every new Eclipse project
comes with twoBuild Configurations (go to Project->Build Configurations->Managemenu if you
have never used this feature before): one named Debug and one Release. A build configuration is
nothing more than a project configuration, and you can have as many separated configurations as
you want in a single project.
Figure 11: The Eclipse project settings dialog allows to switch to another build configuration easily
Figure 11 shows the project settings dialog (go toProject->Properties menu to open it). The C/C++
Build->Settings pane allows to configure the build options. Moreover, as you can see in Figure 11,
you can quickly move to another build configuration using the Configuration combo-box. In the
OptimizationsectionwecansetuptheGCCoptimizationlevels.GCCprovides5optimizationlevels.
Let us briefly introduce them:
• -O0: this corresponds to the no optimization level. It generates unoptimized code but usually
has the fastest compilation time. Note that other compilers do fairly extensive optimization
even if no optimization is specified. With GCC, it is very unusual to use -O0 for production
if execution time is of any concern, since -O0 really does mean no optimization at all. This
difference between GCC and other compilers should be kept in mind when doing performance
comparisons.
• -O1: this corresponds to a moderate optimization. It optimizes reasonably well but does not
degrade compilation time significantly.
Getting Started With a New Design 783
• -O2: this corresponds to full optimization. It generates highly optimized code and has the
slowest compilation time.
• -O3: this also corresponds to full optimization as in “-O2”, but it also uses more aggressive
automatic inlining of subprograms within a unit and attempts to vectorize loops.
• -Os: this corresponds to optimization for space. It optimize space usage (both code and data)
of resulting program.
• -Og: this corresponds to optimization for debug. It enables optimizations that do not interfere
with debugging. It should be the optimization level of choice for the standard edit-compile-
debug cycle, offering a reasonable level of optimization while maintaining fast compilation
and a good debugging experience.
By default, the GCC optimization level for the Release configuration is -Os. Higher optimization
levels perform more global transformations on the program and apply more expensive analysis
algorithms in order to generate faster and more compact code. However, in embedded programming
is usually suggested to start the development using the no optimization (-O0) level. This because
more aggressive optimizations my lead to different behaviour of time-constrained routines. As a
rule of thumb, develop your firmware with the -O0 or the -Og levels, and start increasing it as
long as you test all its features. Sometimes, it also happens that a firmware working perfectly when
compiled with the -O0 level stops working at all when a more aggressive optimization is chosen.
Thisoftenhappenswehavenotcorrectlydeclaredsharedandglobalvariablesas volatile ,andthey
are optimized to the compilers causing wrong behaviour of ISR routines or different threads if we
are using an RTOS.
Another important configuration parameter for the Release configuration is related to Debug level.
This feature is configured inside the Debugging view, and GCC offers four increasing levels: None,
-g1,-g(thedefaultinRelease configuration)and-g3.Ifyouwanttogenerateabinaryimagewithout
debug information, select the None level.
Appendix
A. Miscellaneous HAL functions and
STM32 features
This appendix chapter contains an overview of some HAL functions and STM32 features that makes
little sense to treat in a separate chapter.
Force MCU reset from the firmware
Sometimes, when all is lost and we no longer have control of what is happening, the only salvation
is to reset the microcontroller. The function
void HAL_NVIC_SystemReset(void);
initiates a system reset of the MCU. It uses the void NVIC_SystemReset(void) provided by the
CMSIS package.
STM32 96-bit Unique CPU ID
The most of STM32 microcontroller provides an unique CPU ID, which is factory-programmed. It
is read only, and it cannot be changed.
This ID can be really useful in several contexts. For example, it can be used:
• as unique USB device serial number;
• to generate custom license keys;
• for use as security keys in order to increase the security of code in Flash memory while using
and combining this unique ID with software cryptographic primitives and protocols before
programming the internal Flash memory;
• to activate secure boot processes, etc.
Unfortunately, the position in memory of this ID is not common to all STM32 microcontrollers,
but its memory mapped address changes between each STM32-series. Table 1 shows the memory-
mapped address of the Unique MCU ID for the MCUs equipping the Nucleos.
A. Miscellaneous HAL functions and STM32 features 786
Table 1: memory-mapped address of the Unique MCU ID
Nucleo P/N Factory-programmed 96-bit Unique-ID base address
NUCLEO-F446RE 0x1FFF 7A10
NUCLEO-F411RE 0x1FFF 7A10
NUCLEO-F410RB 0x1FFF 7A10
NUCLEO-F401RE 0x1FFF 7A10
NUCLEO-F334R8 NOT AVAILABLE
NUCLEO-F303RE 0x1FFF F7AC
NUCLEO-F302R8 0x1FFF F7AC
NUCLEO-F103RB 0x1FFF F7E8
NUCLEO-F091RC 0x1FFF F7AC
NUCLEO-F072RB 0x1FFF F7AC
NUCLEO-F070RB NOT AVAILABLE
NUCLEO-F030R8 NOT AVAILABLE
NUCLEO-L476RG 0x1FFF 7590
NUCLEO-L152RE 0x1FF8 00CC
NUCLEO-L073RZ 0x1FF8 007C
NUCLEO-L053R8 0x1FF8 007C
For example, in an STM32F401xE MCU it is mapped at 0x1FFF 7A10 . To access to the unique ID we
can use the following code fragment:
...
uint32_t *uniqueID = (uint32_t*)0x1FFF7A10;
for(uint8_t i = 0; i < 12; i++)
i < 11 ? printf("%x:", (uint8_t)uniqueID[i]) : printf("%d\n", (uint8_t)uniqueID[i]);
...
B. Troubleshooting guide
Here you can find common issues already reported from other readers. Before posting from any
kind of problem you can encounter, it is a good think to have a look here.
GNU MCU Eclipse Installation Issues
Several readers are reporting me issues in installing GNU MCU Eclipse plug-ins. During the
installation, Eclipse cannot access to the packages repository, and the following error appears:
This error is caused by Java, which does not support natively strong encryption due to limitations to
cryptographic algorithms in some countries. The workaround is described in this stackoverflow
answer: http://stackoverflow.com/a/38264878. Essentially, you need to download an additional
package (http://bit.ly/2jiC7GE) from the Java website; extract the “.zip” file and copy the content
of the UnlimitedJCEPolicyJDK8 directory inside the following dir:
• In Windows: C:\Program Files\Java\jre1.8.0_121\lib\security
• In Linux: /usr/lib/jvm/java-8-oracle/lib/security
• InMacOS: /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/se-
curity
Restart Eclipse. You should be able to install GNU MCU Eclipse plug-ins now.
Eclipse related issue
This section contains a list of frequently issues related with the Eclipse IDE.
B. Troubleshooting guide 788
Eclipse cannot locate the compiler
This is a problem that happens frequently on Windows. Eclipse cannot find the compiler installation
folder, and it generates compiling errors like the ones shown below.
This happens because the GNU MCU plug-in cannot locate the GNU cross-compiler folder. To
address this issue, open the Eclipse preferences clicking on the Window->Preferences menu, then
go to C/C++->Build->Global Tools Pathssection. Ensure that the Build tools folder path points to
the directory containing the Build Tools ( C:\STM32Toolchain\Build Tools\bin if you followed the
instructions in Chapter 3, or arrange the path accordingly), and the Toolchain folder paths point to
the GCC ARM installation folder ( C:\STM32Toolchain\gcc-arm\bin ). The following image shows
the right configuration:
B. Troubleshooting guide 789
Eclipse continuously breaks at every instruction during debug
session
If you have not enabled the instruction stepping mode, this happens because you have defined too
many hardware breakpoints. Please, consider that the number of hardware breakpoints is limited
for every Cortex-M family, as shown in the following table:
Available breakpoints/watchpoints in Cortex-M cores
Cortex-M Breakpoints Watchpoints
M0/0+ 4 2
M3/4/7 6 4
To check the used breakpoints in your application, go to the Debug perspective, then in the
Breakpoints pane (see figure below) and disable or delete unneeded breakpoints.
The step-by-step debugging is really slow
This happens when the Disassembly view is enabled, as shown below.
Eclipse needs to reload ARM assembly instructions at every steps (one C instruction can correspond
to a lot of assembly instructions), and this really slows down the debugging session. It is not an
issue related to OpenOCD or the ST-LINK interface, but instead is just an overhead connected with
Eclipse. Switch to another view (or simply close the Disassembly view) to resolve the issue.
B. Troubleshooting guide 790
The firmware works only under a debug session
This happens because, by default, projects generated with the GNU MCU Eclipse plugin have the
semihosting support enabled. As described in Chapter 5, ARM semihosting relies on the ARM
assembly BKPT instruction, which halts the CPU execution waiting for an action of the debugger.
Even if we do not use none of the tracing routines provided by the tool-chain, the startup routines
made by Liviu Ionescu use semihosting to print CPU register at firmware startup (you can take
a look at the _start() routine inside the system/src/newlib/_startup.c file). So, to avoid MCU
from halting when not under a debug session, we can disable semihosting by removing the macro
OS_USE_SEMIHOSTING at project level, as described in Chapter 5.
STM32 related issue
This section contains a list of frequently issues related with the programming of STM32 microcon-
trollers.
The microcontroller does not boot correctly
Although this might seem strange, there is a quite long list of reasons why an STM32 refuses to boot
properly. This issue usually has the following symptoms:
• the firmware does not start.
• theProgramCounterpointstoacompletelyinvalidaddress(usually 0xfffffffd or 0xfffffffe ,
but other addresses of the 4GB memory space are possible too), as shown by Eclipse during the
debug session.
To resolve this issue we need to distinguish between two cases: if you are developing the firmware
for a development board like the Nucleo or for a custom designed board (this difference is just to
simplify the analysis).
B. Troubleshooting guide 791
If you are developing the firmware using a development board then, especially if you are new to
this platform (but tiredness can play nasty tricks even to experienced users…), probably two things
may be wrong:
• The definition of memory sections inside the linker script mem.ld file is wrong, either for
the flash region or the SRAM region (usually, the flash region simply does not start from
0x08000000 ).
• The startup file is wrong or simply you forgot to rename its extension from lower .s to capital
.S .
If,instead,youaredevelopingthefirmwareforacustomboard,thenbesidescontrollingtheprevious
two points you must also check that:
• The configuration of BOOT pins is right (at least BOOT0 pin tight to ground, BOOT1 floating).
• The NRST pin is correctly decoupled using a 100nF capacitor.
Sometimes it happens that, even if all the previous points are correct, the micro still refuses to
boot. This often suddenly happens after a debug session, or after you have tested a buggy firmware
designed to access in write mode to the internal flash memory. Another recognizable symptom in
that neither OpenOCD is able to flash the MCU. If so, probably you have a corrupted Option bytes
memory region. The STM32CubeProgrammer can help you a lot to debug this situation. Once you
have connected the ST-LINK debugger, go inside the Option bytes section and check that BOOT
configuration (inside the User configuration section) correctly matches your MCU.
Finally, sometimes a full chip erase may also help in solving obscure booting issues ;-)
B. Troubleshooting guide 792
It is Not Possibile to Flash or to Debug the MCU
SometimesithappensthatitisnotpossibletoflashtheMCUortodebugitusingOpenOCD.Another
recognizablesymptominthattheST-LINKLD1LED(theonethatblinksredandgreenalternatively
while the board is under debugging) stops blinking and remains frozen with both the LEDs ON.
When this happens, it means that the ST-LINK debugger cannot access to the debug port (through
SWD interface) of the target MCU or the flash is locked preventing its access to the debugger. There
are usually two reasons that leads to this faulty condition:
• SWD pins have been configured as general-purpose GPIOs (this often happens if we perform
a reset of pins configuration in CubeMX).
• The MCU is in a deep low-power mode that turns off the debug port.
• There is something wrong with the option bytes configuration (probably the flash has been
write protected or read protection level 1 is turned on).
Toaddressthisissue,wehavetoforceST-LINKdebuggertoconnecttothetargetMCUwhilekeeping
itsnRSTpinlow.Thisoperationiscalledconnectionunderreset,anditcanbeperformedbyusingthe
STM32CubeProgrammer tool, by selection the Hardware reset mode inse the Reset mode combo
box, as shown below.
The same operation can be performed in OpenOCD, but with several additional steps. First of all,
we must say to OpenOCD to “connect under reset” by modifying the configuration file of our board
(for example, for a Nucleo-F0 we have to modify the file board/st_nucleo_f0.cfg ). In that file you
will find the reset_config command, which must be called in this other way:
reset_config srst_only connect_assert_srst
Next, we have to execute OpenOCD and connect to telnet console on the 4444 port, and issuing the
reset halt command:
$telnet localhost 4444
> reset halt
Now it should be possible to reprogram the MCU again, or eventually perform a mass erase.
C. Nucleo pin-out
In the next paragraphs, you can find the correct pin-out for all Nucleo boards. The pictures are taken
from the mbed.org website¹⁶.
Nucleo Release
Nucleo-F446RE
Nucleo-F411RE
Nucleo-F410RB
Nucleo-F401RE
Nucleo-F334R8
Nucleo-F303RE
Nucleo-F302R8
Nucleo-F103RB
Nucleo-F091RC
Nucleo-F072RB
Nucleo-F070RB
Nucleo-F030R8
Nucleo-L476RG
Nucleo-L152RE
Nucleo-L073RZ
Nucleo-L053R8
¹⁶ https://developer.mbed.org/platforms/?tvend=10
C. Nucleo pin-out 794
Nucleo-F446RE
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 795
Nucleo-F411RE
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 796
Nucleo-F410RB
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 797
Nucleo-F401RE
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 798
Nucleo-F334R8
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 799
Nucleo-F303RE
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 800
Nucleo-F302R8
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 801
Nucleo-F103RB
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 802
Nucleo-F091RC
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 803
Nucleo-F072RB
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 804
Nucleo-F070RB
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 805
Nucleo-F030R8
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 806
Nucleo-L476RG
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 807
Nucleo-L152RE
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 808
Nucleo-L073R8
Arduino compatible headers
Morpho headers
C. Nucleo pin-out 809
Nucleo-L053R8
Arduino compatible headers
Morpho headers
D. STM32 packages
Here you will find the most common packages used for STM32 MCU. They are here only as quick
reference. The images are taken from official ST Microelectronics datasheets. They are therefore
copyright of ST Microelectronics.
LFBGA
LQFP
D. STM32 packages 811
TFBGA
TSSOP
UFBGA
D. STM32 packages 812
UFQFPN
VFQFP
WLCSP
D. STM32 packages 813
E. History of this book
Being this an in-progress book, it is interesting to publish a complete history of modifications.
Release 0.1 - October 2015
First public version of the book, made of 5 chapters.
Release 0.2 - October 28th, 2015
This release contains the following fixes:
• Changed the Table 1 in Chapter 1: it wrongly stated that Cortex-M0/0+ allows 16 external
configurable interrupts. Instead, it is 32.
• Paragraph 1.1.1.6 wrongly stated that the number of cycles required to service an interrupt is
12 for all Cortex-M processors. Instead it is equal to 12 cycles for all Cortex-M3/4/7 cores, 15
cycles for Cortex-M0, 16 cycles for Cortex-M0+.
• Fixed a lot of errors in the text. Really thanks to Enrico Colombini (aka Erix - http://www.erix.
it) who is doing this dirty job.
This release adds the following chapters:
• Chapters 6 about GPIOs management.
• Added a troubleshooting section in the appendix.
• Added a section in the appendix about miscellaneous HAL functions.
Release 0.2.1 - October 31th, 2015
This release contains the following fixes:
• Changed again the Table 1 in Chapter 1: it did not indicate which Cortex exceptions are not
available in Cortex-M0/0+ based processors.
• Added several remarks to Chapter 4 (thanks again to Enrico Colombini) that better clarify
some steps during the import of CubeMX generated output in the Eclipse project. Moreover,
it is better explained why the startup file differs between Cortex-M0/0+ and Cortex-M3/4/7
processors.
E. History of this book 815
Release 0.2.2 - November 1st, 2015
This release contains the following fixes:
• Changed in Chapter 4 ( ∼ pg. 140) the description of project generated by CubeMX, since ST has
updated the template files after this author submitted a bug report. Now the code generated is
generic and works with all Nucleo boards (even the F302 one).
Release 0.3 - November 12th, 2015
This release contains the following changes:
• Tool-chain installation instructions have been successfully tested on Windows XP, 7, 8.1 and
the latest Windows 10.
• Added in chapter 4 the description of the CubeMXImporter, a tool made by this author to
automatically import a CubeMX project into an Eclipse project made with the GNU MCU
plug-in.
This release adds the following chapter:
• Chapter 7 about NVIC controller.
Release 0.4 - December 4th, 2015
This release contains the following changes:
• Added in Chapter 5 the definition of freestanding environment.
• Figures 11 and 12 in Chapter 5 have been updated to better clarify the signal levels.
• Added a paragraph about 96-bit Unique-ID in the Appendix A.
This release adds the following chapter:
• Chapter 8 about UART peripheral.
Release 0.5 - December 19th, 2015
This release adds the following chapter:
• Chapter 9 about how to start a new custom design with STM32 MCUs.
E. History of this book 816
Release 0.6 - January 18th, 2016
This release adds the following chapter:
• Chapter 9 about DMA controller and HAL_DMA module.
Release 0.6.1 - January 20th, 2016
This release contains the following changes:
• Better clarified in paragraphs 7.1 and 7.2 the relation between NVIC and EXTI controller.
• In chapter 9 clarified that the BusMatrix also allows to automatically interconnect several
peripherals between them. This topic will be explored in a subsequent chapter.
• Clarified at page 266 that the we have to enable the DMA controller, using the macro __DMA1_-
CLK_ENABLE() , before we can use it.
Release 0.6.2 - January 30th, 2016
This release contains the following changes:
• The Figure 4 in Chapter 1, and the text describing it, was completely wrong. It wrongly placed
the boot loaders at the beginning of code area ( 0x0000 0000 ), while they are contained inside
theSystem memory. Moreover,the role of the aliasing of flash addresses is better clarified, both
there and in Chapter 7.
• Better clarified the role of I-Bus, D-Bus and S-Bus in Chapter 9.
• Fixed several errors in the text. Really thanks to Omar Shaker who is helping me.
Release 0.7 - February 8th, 2016
This release adds the following chapter:
• Chapter 10 about memory layout and liker scripts.
• Appendix C with correct pin-out for all Nucleo boards.
This release also better introduces the whole Nucleo lineup in Chapter 1. Moreover, BB-8 droid by
Sphero is now among us. We welcome BB-8 (can you find it? :-)).
E. History of this book 817
Release 0.8 - February 18th, 2016
This release adds the following chapter:
• Chapter 10 about clock tree configuration.
This release contains the following changes:
• In paragraph 4.1.1.2 the meaning of each IP Tree pane symbol has been better clarified.
• Fixed several errors in the text. Again, really thanks to Omar Shaker who is helping me.
Release 0.8.1 - February 23th, 2016
This release contains the following changes:
• TheGCCtool-chainhasbeenupdatedtothelatest5.2release.Thereisnothingspecialtoreport.
Release 0.9 - March 27th, 2016
This release adds the following chapter:
• Chapter 11 about timers.
This release contains the following changes:
• The paragraph 9.2.6 has been updated: after several tests, I reach to the conclusion that the
peripheral-to-peripheral transfer is possible only if the bus matrix is expressly designed to
trigger transfers between the two peripherals.
• The paragraph 9.2.7 has been completely rewritten to better specify how to use the HAL_UART
module in DMA mode.
• Added the paragraph 9.4 that explains the correct way to declare buffers for DMA transfers.
• Added the paragraph 10.1.1.1 about the MSI RC clock source in STM32L MCUs.
• Added the paragraph 10.1.3 about clock source options in Nucleo boards.
• Added in Appendix C the Nucleo-L073 and Nucleo-F410 pinout diagrams.
Release 0.9.1 - March 28th, 2016
This release contains the following changes:
• Installation instructions have been updated to the latest CubeMX 4.14, which now officially
supports MacOS and Linux.
E. History of this book 818
Release 0.10 - April 26th, 2016
This release adds the following chapter:
• Chapter 12 about low-power modes.
This release contains the following changes:
• Explained in paragraph 6.2.2 why the field GPIO_InitTypeDef.Alternate is missed in CubeF1
HAL.
• Fixed example 3 in Chapter 9. The example contained two errors, one related to the EXTI2_3_-
IRQHandler() and one to the priority of IRQs. The code in the book examples repository was
instead correct.
• Added few words about I/O debouncing at page 207.
• The paragraph 7.6 has been completely rewritten to cover also the BASEPRI register.
• Added the paragraph 11.3.3 about how to generate timer-related events by software.
• ST engineers have changed the way a peripheral clock is enabled/disabled: now all the
__<PPP>_CLK_ENABLE() macros have been renamed to __HAL_RCC_<PPP>_CLK_ENABLE() . The
whole book has been updated. However, they are still laving the old macro available for
compatibility.
Release 0.11 - May 27th, 2016
This release adds the following chapter:
• Chapter 14 about FreeRTOS.
This release contains the following changes:
• Changed Figure 16 in Chapter 7: the temporal sequences of ISR B an C were wrong.
• Changed Figure 17 in Chapter 7: the sub-priority of ISRs B and C were wrong, because
according that execution sequence, the right sub-priority is 0x0 for C and 0x1 for B.
• Added another figure in Chapter 7 (the actual Figure 20), which better explains what happens
when the priority grouping is lowered from 4 to 1 in that example. Thanks to Omar Shaker
that helped me in refining this part.
• Paragraph 11.3.10.4 has been completely rewritten to better describe the update process of
TIMx->ARR register.
• Clarified in Chapter 9 that, when using the UART in DMA mode, it is also important to enable
the corresponding UART interrupt and to add a call to the HAL_UART_IRQHandler() from the
ISR.
• Added an Eclipse intermezzo at the end of Chapter 6: it shows how to customize Eclipse
appearance with themes.
• Added paragraph 12.3.3 regarding an important issue encountered with STM32F103 MCUs.
• Now the book has a brand new and professionally designed cover ;-)
E. History of this book 819
Release 0.11.1 - June 3rd, 2016
This release contains the following changes:
• Better explained the vector table relocation process in 13.3.1 (in the previous releases of the
book,thephysicalcopyofthe .ccm sectionfromtheflashmemorytotheCCMonewasmissed).
The example 6 has been changed accordingly.
Release 0.11.2 - June 24th, 2016
This release contains the following changes:
• Tool-chain installation instruction have been updated to Eclipse 4.6 (Neon) and GCC 5.3.
Release 0.12 - July 4th, 2016
This release adds the following chapter:
• Chapter 12 about ADC.
This release contains the following changes:
• Better clarified in paragraph 7.2 the difference between enabling an interrupt at NVIC level
and at the peripheral level.
Release 0.13 - July 18th, 2016
This release adds the following chapter:
• Chapter 13 about DAC.
Release 0.14 - August 12th, 2016
This release adds the following chapter:
• Chapter 17 about flash memory management.
This release contains the following changes:
• Clarified in paragraph 12.2.8 that the hadc.Init.ContinuousConvMode field must be set to
DISABLE , otherwise the ADC performs conversions by itself without waiting the timer trigger.
• Added the paragraph 12.2.6.1 about how to convert multiple times the same channel in DMA
mode (paragraph 12.2.6.1 is now 12.2.6.2).
E. History of this book 820
Release 0.15 - September 13th, 2016
This release adds the following chapter:
• Chapter 17 about booting process in STM32 microcontrollers.
This release contains the following changes:
• Equation [4] in Chapter 9 was wrong because, to properly measure the period between two
consecutive captures, the right formula is the following one (thanks to Davide Ruggiero to
point me this out):
Period = Capture ·
(
TIMx _ CLK
(Prescaler + 1)(CH Prescaler )(Polarity Index )
) −1
[4]
• Described in Chapter 19 how to configure Eclipse to generate binary images of the firmware
in Release mode.
• Added a new Eclipse Intermezzo at the end of the Chapter 7. It explains how to use code
templates to increase coding productivity.
Release 0.16 - October 3th, 2016
This release adds the following chapter:
• Chapter 14 about I²C peripheral.
This release contains the following changes:
• Added the paragraph 16.4 about MPU unit.
Release 0.17 - October 24th, 2016
This release adds the following chapter:
• Chapter 15 about SPI peripheral.
This release contains the following changes:
• Better clarified in paragraph 12.2.8 that the timer’s TRGO line must be properly configured to
triggertheADCconversion byusing the HAL_TIMEx_MasterConfigSynchronization() routine,
even if the timer is not configured in master mode.
E. History of this book 821
Release 0.18 - November 15th, 2016
This release adds the following chapter:
• Chapter 21 about advanced debugging techniques.
This release contains the following changes:
• Added the paragraph 12.2.6.2 that explains how to perform multiple and not continuous
conversions in DMA mode.
• Added the paragraph 1.3.7 that briefly mentions the new STM32H7-series.
• OpenOCD installation instructions for Windows, Linux and MacOS have been completely
revised. Since the next OpenOCD release (0.10) is still under development, I have decided to
use the precompiled packages made by Liviu Ionescu. This because they support the latest
STM development boards. Several of you are, in fact, experiencing issues with OpenOCD 0.9.
The latest development packages by Liviu should address these issues definitively. Please, Mac
users take note that MacOS releases prior to 10.11 (aka El Capitan) are no longer supported.
Release 0.19 - November 29th, 2016
This release adds the following chapter:
• Chapter 16 about CRC peripheral.
Release 0.20 - December 28th, 2016
This release adds the following chapter:
• Chapter 17 about IWDT and WWDT timers.
Release 0.21 - January 29th, 2017
This release adds the following chapter:
• Chapter 24 about FatFs middleware library.
This release contains the following changes:
• Installation instructions have been updated to the latest official OpenOCD 0.10, Eclipse Neon.2
and GCC 5.4. Please, take not that the latest ARM GCC 6.x appears to be incompatible
with the current GNU MCU Eclipse plug-ins. So keep using the 5.4 branch until Liviu
fixes incompatibilities. Take also note that latest version of Eclipse needs Java SE 8 update
121.
E. History of this book 822
Release 0.22 - May 2nd, 2017
This release adds the following chapter:
• Chapter 25 about W5500 ethernet processor.
This release contains the following changes:
• Chapter 22 has been updated to the latest FreeRTOS 9.x. Please take note that ST still has not
completed the rollout of latest FreeRTOS release to all STM32 families.
• Equation [1] in Chapter 17 was wrong. Thank you to Michael Kaiser to let me know that.
• Instructions in paragraph 23.6 have been updated to better clarify how to retrieve the right
ST-LINK serial number in Windows.
• Instructions in paragraph 8.3.1 have been updated to better clarify how to install RXTX library
in Windows.
• ST refactored the HAL_IWDG and HAL_WWDG modules. The chapter 17 has been updated to cover
the new APIs.
• This book is almost finished! Now it is the right time to add an acknowledgments section to
thank all those people that helped me to make this work possible.
Release 0.23 - July 20th, 2017
This release adds the following chapter:
• Chapter 18 about RTC.
This release contains the following changes:
• Chapter 4 has been updated to cover CubeMX 4.22 features.
• Updated paragraph 23.3.4 to cover the new behaviour in FreeRTOS 9.x: now if one thread
deletes another thread, then the memory allocated by FreeRTOS to the deleted thread is freed
immediately.
Release 0.24 - December 11th, 2017
This release contains the following changes:
• Chapter 1 has been updated to cover the new STM32L4+ family. Moreover, the STM32L4 series
has been updated to cover the latest MCUs.
• Installation instructions in Chapter 2 have been updated to cover Eclipse Oxygen and the latest
GNU MCU Eclipse plug-ins.
E. History of this book 823
Release 0.25 - January 3rd, 2018
This release contains the following changes:
• ST has released a new flashing utility named STM32CubeProgrammer. The big news is that
STM32CubeProgrammer is now multi-platform, and it runs on Windows, Mac and Linux. The
tool is not yet perfectly stable, but it is a good start. That allowed me to review installation
instructions: now there is no longer need to install QSTLink2 and texane .
Release 0.26 - May 7th, 2018
This release contains the following changes:
• Chapter 1 has been updated to cover the new STM32WB family.
• Minor fixes to the text.
